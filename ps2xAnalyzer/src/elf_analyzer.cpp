#include "ps2recomp/elf_analyzer.h"
#include "ps2recomp/elf_parser.h"
#include "ps2recomp/r5900_decoder.h"
#include "ps2recomp/types.h"
#include <iostream>
#include <sstream>
#include <algorithm>
#include <filesystem>
#include <regex>
#include <stack>
#include <queue>
#include <fstream>
#include <iomanip>
#include <functional>
#include <limits>
#include <optional>
#include <cctype>
#include <optional>

namespace fs = std::filesystem;

namespace ps2recomp
{
    static bool hasPs2ApiPrefix(const std::string &name);
    static bool hasReliableSymbolName(const std::string &name);
    static bool isDoNotSkipOrStub(const std::string &name);
    static uint32_t decodeAbsoluteJumpTarget(uint32_t instructionAddress, uint32_t targetField);
    static bool tryReadWord(const ElfParser *parser, uint32_t address, uint32_t &outWord);

    ElfAnalyzer::ElfAnalyzer(const std::string &elfPath)
        : m_elfPath(elfPath)
    {
        m_elfParser = std::make_unique<ElfParser>(elfPath);
        m_decoder = std::make_unique<R5900Decoder>();

        initializeLibraryFunctions();
    }

    ElfAnalyzer::~ElfAnalyzer() = default;

    bool ElfAnalyzer::analyze()
    {
        std::cout << "Analyzing ELF file: " << m_elfPath << std::endl;

        if (!m_elfParser->parse())
        {
            std::cerr << "Failed to parse ELF file" << std::endl;
            return false;
        }

        m_functions = m_elfParser->extractFunctions();
        m_symbols = m_elfParser->extractSymbols();
        m_sections = m_elfParser->getSections();
        m_relocations = m_elfParser->getRelocations();

        std::cout << "Extracted " << m_functions.size() << " functions" << std::endl;
        std::cout << "Extracted " << m_symbols.size() << " symbols" << std::endl;
        std::cout << "Extracted " << m_sections.size() << " sections" << std::endl;
        std::cout << "Extracted " << m_relocations.size() << " relocations" << std::endl;

        analyzeEntryPoint();
        analyzeDataUsage();
        identifyPotentialPatches();
        analyzeControlFlow();
        detectJumpTables();
        analyzePerformanceCriticalPaths();
        identifyRecursiveFunctions();
        analyzeRegisterUsage();
        analyzeFunctionSignatures();
        analyzeLibraryFunctions();
        optimizePatches();

        for (auto &func : m_functions)
        {
            categorizeFunction(func);

            if (!m_skipFunctions.contains(func.name) &&
                !m_libFunctions.contains(func.name))
            {
                func.instructions = decodeFunction(func);
            }
        }

        std::cout << "Analysis completed" << std::endl;
        std::cout << "- " << m_libFunctions.size() << " library functions to stub" << std::endl;
        std::cout << "- " << m_skipFunctions.size() << " functions to skip" << std::endl;
        std::cout << "- " << m_patches.size() << " potential patches identified" << std::endl;
        std::cout << "- " << m_jumpTables.size() << " jump tables detected" << std::endl;

        return true;
    }

    bool ElfAnalyzer::generateToml(const std::string &outputPath)
    {
        std::ofstream file(outputPath);
        if (!file)
        {
            std::cerr << "Failed to open output file: " << outputPath << std::endl;
            return false;
        }

        fs::path elfPathObj(m_elfPath);
        std::string elfFileName = elfPathObj.filename().string();

        fs::path outputPathObj(outputPath);
        fs::path outputDir = outputPathObj.parent_path();
        if (outputDir.empty())
        {
            outputDir = ".";
        }

        const fs::path generatedOutputDir = outputDir / "output";
        std::string outputDirStr = generatedOutputDir.generic_string() + "/";

        if (!fs::exists(generatedOutputDir))
        {
            fs::create_directories(generatedOutputDir);
        }

        file << "# PS2Recomp configuration for: " << elfFileName << "\n";
        file << "# Generated by ElfAnalyzer\n\n";

        file << "[general]\n";
        file << "# Path to input ELF file\n";
        file << "input = \"" << escapeBackslashes(m_elfPath) << "\"\n\n";

        file << "# Path to Ghidra exported function map (optional CSV)\n";
        file << "ghidra_output = \"\"\n\n";

        file << "# Path to output directory\n";
        file << "output = \"" << escapeBackslashes(outputDirStr) << "\"\n\n";

        file << "# Single file output mode (recommended for large games)\n";
        file << "single_file_output = false\n\n";

        file << "# Patch policy (instruction-driven handling is preferred for syscalls)\n";
        file << "patch_syscalls = false\n";
        file << "patch_cop0 = true\n";
        file << "patch_cache = true\n\n";

        std::unordered_map<std::string, size_t> functionNameCounts;
        functionNameCounts.reserve(m_functions.size());
        for (const auto &func : m_functions)
        {
            if (!func.name.empty())
            {
                functionNameCounts[func.name]++;
            }
        }

        auto makeSelector = [&](const std::string &name, uint32_t start) -> std::string
        {
            auto it = functionNameCounts.find(name);
            if (it == functionNameCounts.end() || it->second <= 1)
            {
                return name;
            }

            std::stringstream selector;
            selector << name << "@0x"
                     << std::hex << std::uppercase << std::setw(8) << std::setfill('0')
                     << start;
            return selector.str();
        };

        auto collectFunctionSelectors =
            [&](const std::unordered_set<std::string> &nameSet) -> std::vector<std::string>
        {
            std::vector<const Function *> orderedFunctions;
            orderedFunctions.reserve(m_functions.size());
            for (const auto &func : m_functions)
            {
                orderedFunctions.push_back(&func);
            }

            std::sort(orderedFunctions.begin(), orderedFunctions.end(),
                      [](const Function *a, const Function *b)
                      { return a->start < b->start; });

            std::vector<std::string> entries;
            std::unordered_set<std::string> seenEntries;
            std::unordered_set<std::string> coveredNames;

            for (const Function *func : orderedFunctions)
            {
                if (!nameSet.contains(func->name))
                {
                    continue;
                }

                coveredNames.insert(func->name);
                const std::string entry = makeSelector(func->name, func->start);
                if (seenEntries.insert(entry).second)
                {
                    entries.push_back(entry);
                }
            }

            std::vector<std::string> leftovers;
            leftovers.reserve(nameSet.size());
            for (const auto &name : nameSet)
            {
                if (!coveredNames.contains(name) && seenEntries.insert(name).second)
                {
                    leftovers.push_back(name);
                }
            }
            std::sort(leftovers.begin(), leftovers.end());
            entries.insert(entries.end(), leftovers.begin(), leftovers.end());

            return entries;
        };

        const std::vector<std::string> stubEntries = collectFunctionSelectors(m_libFunctions);
        const std::vector<std::string> skipEntries = collectFunctionSelectors(m_skipFunctions);

        file << "# Functions to stub (these will generate empty implementations)\n";
        file << "stubs = [\n";
        for (const auto &func : stubEntries)
        {
            file << "  \"" << func << "\",\n";
        }
        file << "]\n\n";

        file << "# Functions to skip (these will not be recompiled)\n";
        file << "skip = [\n";
        for (const auto &func : skipEntries)
        {
            file << "  \"" << func << "\",\n";
        }
        file << "]\n\n";

        if (!m_mmioByInstructionAddress.empty())
        {
            file << "# Detected MMIO accesses\n";
            file << "[mmio]\n";
            for (const auto &[instAddr, mmioAddr] : m_mmioByInstructionAddress)
            {
                file << "\"0x" << std::hex << instAddr << "\" = \"0x" << mmioAddr << "\"\n"
                     << std::dec;
            }
            file << "\n";
        }

        if (!m_jumpTables.empty())
        {
            file << "# Jump tables detected in the program\n";
            file << "[jump_tables]\n";

            for (const auto &jt : m_jumpTables)
            {
                file << "[[jump_tables.table]]\n";
                file << "address = \"0x" << std::hex << jt.address << "\"\n"
                     << std::dec;
                file << "entries = [\n";

                for (const auto &[index, target] : jt.entries)
                {
                    file << "  { index = " << index << ", target = \"0x"
                         << std::hex << target << "\" },\n"
                         << std::dec;
                }

                file << "]\n\n";
            }
        }

        if (!m_patches.empty())
        {
            file << "# Patches to apply during recompilation\n";
            file << "[patches]\n";
            file << "# Individual instruction patches\n";
            file << "instructions = [\n";
            for (const auto &[address, value] : m_patches)
            {
                file << "  { address = \"0x" << std::hex << address << "\", value = \"0x"
                     << std::hex << value << "\" },  # " << m_patchReasons[address] << "\n";
            }
            file << "]\n\n";
        }

        file << "# Performance critical functions (may need manual optimization)\n";
        file << "[performance]\n";
        file << "critical = [\n";
        for (const auto &func : m_functions)
        {
            if (hasMMIInstructions(func) || hasVUInstructions(func))
            {
                file << "  \"" << func.name << "\", # Uses SIMD instructions\n";
            }
            else if (isLoopHeavyFunction(func))
            {
                file << "  \"" << func.name << "\", # Contains heavy loops\n";
            }
        }
        file << "]\n\n";

        std::cout << "Generated TOML configuration: " << outputPath << std::endl;
        return true;
    }

    void ElfAnalyzer::initializeLibraryFunctions()
    {
        // Standard C library functions
        const std::vector<std::string> stdLibFuncs = {
            // I/O functions
            "printf", "sprintf", "snprintf", "fprintf", "vprintf", "vfprintf", "vsprintf", "vsnprintf",
            "puts", "putchar", "getchar", "gets", "fgets", "fputs", "scanf", "fscanf", "sscanf",
            "sprint", "sbprintf",

            // Memory management
            "malloc", "free", "calloc", "realloc", "aligned_alloc", "posix_memalign",

            // Memory manipulation
            "memcpy", "memset", "memmove", "memcmp", "memcpy2", "memchr", "bcopy", "bzero",

            // String manipulation
            "strcpy", "strncpy", "strcat", "strncat", "strcmp", "strncmp", "strlen", "strstr",
            "strchr", "strrchr", "strdup", "strtok", "strtok_r", "strerror",

            // File operations
            "fopen", "fclose", "fread", "fwrite", "fseek", "ftell", "rewind", "fflush",
            "fgetc", "fgets", "feof", "ferror", "clearerr", "fileno", "tmpfile", "remove", "rename",
            "open", "close", "read", "write", "lseek", "stat", "fstat",

            // Type conversion
            "atoi", "atol", "atoll", "atof", "strtol", "strtoul", "strtoll", "strtoull", "strtod", "strtof",

            // Math functions
            "rand", "srand", "random", "srandom", "drand48", "sqrt", "pow", "exp", "log", "log10",
            "sin", "cos", "tan", "asin", "acos", "atan", "atan2", "sinh", "cosh", "tanh",
            "floor", "ceil", "fabs", "fmod", "frexp", "ldexp", "modf",

            // Time functions
            "time", "ctime", "clock", "difftime", "mktime", "localtime", "gmtime", "asctime", "strftime",
            "gettimeofday", "nanosleep", "usleep",

            // Process control
            "abort", "exit", "_exit", "atexit", "system", "getpid", "fork", "waitpid",

            // Misc
            "qsort", "bsearch", "abs", "div", "labs", "ldiv", "llabs", "lldiv",
            "isalnum", "isalpha", "isdigit", "islower", "isupper", "isspace", "tolower", "toupper",
            "setjmp", "longjmp", "getenv", "setenv", "unsetenv",
            "perror", "fputc", "getc", "ungetc", "freopen", "setvbuf", "setbuf",

            // Extra string helpers
            "strnlen", "strspn", "strcspn", "strcasecmp", "strncasecmp"};

        m_knownLibNames.insert(stdLibFuncs.begin(), stdLibFuncs.end());
    }

    int ElfAnalyzer::findEntryFunctionIndexForHeuristics(const std::vector<Function> &functions, uint32_t entryAddress)
    {
        auto it = std::find_if(functions.begin(), functions.end(),
                               [entryAddress](const Function &f)
                               { return f.start == entryAddress; });
        if (it != functions.end())
        {
            return static_cast<int>(std::distance(functions.begin(), it));
        }

        it = std::find_if(functions.begin(), functions.end(),
                          [entryAddress](const Function &f)
                          { return f.start <= entryAddress && entryAddress < f.end; });
        if (it != functions.end())
        {
            return static_cast<int>(std::distance(functions.begin(), it));
        }

        return -1;
    }

    int ElfAnalyzer::findFallbackEntryFunctionIndexForHeuristics(const std::vector<Function> &functions)
    {
        auto it = std::find_if(functions.begin(), functions.end(),
                               [](const Function &f)
                               { return f.start == 0x100000 || f.start == 0x80100000; });
        if (it == functions.end())
        {
            return -1;
        }

        return static_cast<int>(std::distance(functions.begin(), it));
    }

    void ElfAnalyzer::analyzeEntryPoint()
    {
        const uint32_t entryAddress = m_elfParser->getEntryPoint();
        const int entryIndex = findEntryFunctionIndexForHeuristics(m_functions, entryAddress);
        if (entryIndex >= 0)
        {
            const Function &entryFunction = m_functions[static_cast<size_t>(entryIndex)];
            std::cout << "Found entry point from ELF header: 0x" << std::hex << entryAddress
                      << " in function " << entryFunction.name << " (starts at 0x" << entryFunction.start << ")"
                      << std::dec << std::endl;

            m_forceRecompileStarts.insert(entryFunction.start);
            m_skipFunctions.erase(entryFunction.name);

            std::vector<Instruction> instructions = decodeFunction(entryFunction);

            for (const auto &inst : instructions)
            {
                if (inst.opcode == OPCODE_JAL)
                {
                    uint32_t target = decodeAbsoluteJumpTarget(inst.address, inst.target);

                    for (const auto &func : m_functions)
                    {
                        if (func.start == target)
                        {
                            std::cout << "Found entry call to: " << func.name << " at 0x"
                                      << std::hex << inst.address << std::dec << std::endl;

                            if (hasReliableSymbolName(func.name) &&
                                !isDoNotSkipOrStub(func.name) &&
                                isSystemFunction(func.name))
                            {
                                m_skipFunctions.insert(func.name);
                            }
                            break;
                        }
                    }
                }
            }
        }
        else
        {
            std::cout << "Entry point 0x" << std::hex << entryAddress
                      << " not mapped to an extracted function" << std::dec << std::endl;

            const int fallbackIndex = findFallbackEntryFunctionIndexForHeuristics(m_functions);
            if (fallbackIndex >= 0)
            {
                const Function &fallbackEntry = m_functions[static_cast<size_t>(fallbackIndex)];
                std::cout << "Found potential entry point by address: " << fallbackEntry.name
                          << " at 0x" << std::hex << fallbackEntry.start << std::dec << std::endl;
                m_forceRecompileStarts.insert(fallbackEntry.start);
                m_skipFunctions.erase(fallbackEntry.name);
            }
        }
    }

    void ElfAnalyzer::analyzeLibraryFunctions()
    {
        for (const auto &symbol : m_symbols)
        {
            if (symbol.isFunction)
            {
                if (!hasReliableSymbolName(symbol.name))
                {
                    continue;
                }

                if (isLibraryFunction(symbol.name))
                {
                    m_libFunctions.insert(symbol.name);
                }
                else if (isSystemFunction(symbol.name))
                {
                    m_skipFunctions.insert(symbol.name);
                }
            }
        }

        for (const auto &func : m_functions)
        {
            if (!hasReliableSymbolName(func.name))
            {
                continue;
            }

            if (isLibraryFunction(func.name))
            {
                m_libFunctions.insert(func.name);
            }
            else if (isSystemFunction(func.name))
            {
                m_skipFunctions.insert(func.name);
            }
        }
    }

    void ElfAnalyzer::analyzeDataUsage()
    {
        std::cout << "Analyzing data usage patterns..." << std::endl;

        std::map<uint32_t, std::set<std::string>> memoryAccessMap;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);

            for (const auto &inst : instructions)
            {
                if (inst.opcode == OPCODE_LW || inst.opcode == OPCODE_SW ||
                    inst.opcode == OPCODE_LB || inst.opcode == OPCODE_SB ||
                    inst.opcode == OPCODE_LH || inst.opcode == OPCODE_SH ||
                    inst.opcode == OPCODE_LBU || inst.opcode == OPCODE_LHU ||
                    inst.opcode == OPCODE_LQ || inst.opcode == OPCODE_SQ)
                {
                    // Check if the memory address involves $gp (global pointer)
                    if (inst.rs == 28) // $gp is typically register 28
                    {
                        int16_t offset = static_cast<int16_t>(inst.immediate);
                        uint32_t gpValue = 0;

                        // Try to find GP value in ELF sections
                        for (const auto &section : m_sections)
                        {
                            if (section.name == ".got" || section.name == ".data" ||
                                section.name == ".sdata" || section.name == ".sbss")
                            {
                                gpValue = section.address;
                                break;
                            }
                        }

                        if (gpValue != 0)
                        {
                            uint32_t targetAddr = gpValue + offset;
                            memoryAccessMap[targetAddr].insert(func.name);

                            auto symIt = std::find_if(m_symbols.begin(), m_symbols.end(),
                                                      [targetAddr](const Symbol &s)
                                                      { return !s.isFunction && s.address == targetAddr; });

                            if (symIt != m_symbols.end())
                            {
                                std::cout << "Function " << func.name << " accesses data symbol "
                                          << symIt->name << " at 0x" << std::hex << targetAddr
                                          << std::dec << std::endl;

                                m_functionDataUsage[func.name].insert(symIt->name);
                            }
                            else
                            {
                                // Try to find the symbol it belongs to, even if not exact match
                                for (const auto &sym : m_symbols)
                                {
                                    if (!sym.isFunction && targetAddr >= sym.address &&
                                        targetAddr < sym.address + sym.size)
                                    {
                                        std::cout << "Function " << func.name << " accesses data within symbol "
                                                  << sym.name << " at offset 0x" << std::hex << (targetAddr - sym.address)
                                                  << std::dec << std::endl;

                                        m_functionDataUsage[func.name].insert(sym.name);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    // Also check for direct addressing with LUI+ADDIU combinations
                    else if (inst.opcode == OPCODE_LW || inst.opcode == OPCODE_SW)
                    {
                        // Look for the LUI instruction that sets up the high bits
                        uint32_t baseAddr = 0;
                        for (int i = 1; i <= 5 && static_cast<int>(inst.address) - i * 4 >= static_cast<int>(func.start); i++)
                        {
                            uint32_t prevAddr = inst.address - i * 4;
                            uint32_t prevInst = 0;
                            if (!tryReadWord(m_elfParser.get(), prevAddr, prevInst))
                            {
                                continue;
                            }

                            // Check if it's a LUI instruction for the same register
                            if (OPCODE(prevInst) == OPCODE_LUI && RT(prevInst) == inst.rs)
                            {
                                baseAddr = IMMEDIATE(prevInst) << 16;
                                break;
                            }
                        }

                        if (baseAddr != 0)
                        {
                            uint32_t targetAddr = baseAddr + static_cast<int16_t>(inst.immediate);

                            // Detect MMIO accesses
                            if ((targetAddr >= 0x10000000 && targetAddr < 0x14000000) || // I/O
                                (targetAddr >= 0x70000000 && targetAddr < 0x70004000))   // Scratchpad
                            {
                                m_mmioByInstructionAddress[inst.address] = targetAddr;
                                std::cout << "Detected MMIO access at " << std::hex << inst.address
                                          << " -> " << targetAddr << std::dec << std::endl;
                            }

                            for (const auto &section : m_sections)
                            {
                                if (targetAddr >= section.address && targetAddr < section.address + section.size)
                                {
                                    auto symIt = std::find_if(m_symbols.begin(), m_symbols.end(),
                                                              [targetAddr](const Symbol &s)
                                                              { return !s.isFunction && s.address <= targetAddr &&
                                                                       s.address + s.size > targetAddr; });

                                    if (symIt != m_symbols.end())
                                    {
                                        std::cout << "Function " << func.name << " directly accesses "
                                                  << (inst.opcode == OPCODE_LW ? "reads from" : "writes to")
                                                  << " data symbol " << symIt->name
                                                  << " at 0x" << std::hex << targetAddr << std::dec << std::endl;

                                        m_functionDataUsage[func.name].insert(symIt->name);
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Identify commonly accessed data (potential global structures)
        for (const auto &[addr, funcs] : memoryAccessMap)
        {
            if (funcs.size() > 3) // If multiple functions access this data
            {
                std::string dataName = formatAddress(addr);

                auto symIt = std::find_if(m_symbols.begin(), m_symbols.end(),
                                          [addr](const Symbol &s)
                                          { return !s.isFunction && s.address == addr; });

                if (symIt != m_symbols.end())
                {
                    dataName = symIt->name;
                }

                std::cout << "Common data: " << dataName << " at 0x" << std::hex << addr
                          << std::dec << " accessed by " << funcs.size() << " functions" << std::endl;

                m_commonDataAccess[addr] = dataName;
            }
        }

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);

            for (size_t i = 0; i < instructions.size(); i++)
            {
                const auto &inst = instructions[i];

                if ((inst.opcode == OPCODE_SPECIAL && (inst.function == SPECIAL_SLL || inst.function == SPECIAL_SLLV)) ||
                    (inst.opcode == OPCODE_SPECIAL && inst.function == SPECIAL_MULT))
                {
                    for (size_t j = i + 1; j < std::min(i + 5, instructions.size()); j++)
                    {
                        const auto &nextInst = instructions[j];

                        if ((nextInst.opcode == OPCODE_LW || nextInst.opcode == OPCODE_SW) &&
                            nextInst.rs == inst.rd)
                        {
                            std::cout << "Found possible array access in function " << func.name
                                      << " at 0x" << std::hex << nextInst.address << std::dec << std::endl;
                            break;
                        }
                    }
                }
            }
        }
    }

    void ElfAnalyzer::identifyPotentialPatches()
    {
        std::cout << "Identifying potential patches..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name))
            {
                continue;
            }

            const std::vector<Instruction> instructions = decodeFunction(func);

            for (size_t index = 0; index + 1 < instructions.size(); ++index)
            {
                tryPatchSelfModifyingStore(func, instructions, index);
            }
        }
    }

    bool ElfAnalyzer::tryPatchSelfModifyingStore(
        const Function &func,
        const std::vector<Instruction> &instructions,
        size_t index)
    {
        const Instruction &storeInst = instructions[index];
        if (storeInst.opcode != OPCODE_SW)
        {
            return false;
        }

        const Instruction &nextInst = instructions[index + 1];
        if (nextInst.opcode != OPCODE_J && nextInst.opcode != OPCODE_JAL)
        {
            return false;
        }

        uint32_t targetAddr = 0;
        if (!tryResolveBasePlusOffset(instructions, index, storeInst.rs, static_cast<int16_t>(storeInst.immediate), targetAddr))
        {
            return false;
        }

        if (!isCodeAddress(targetAddr))
        {
            return false;
        }

        const uint32_t jumpTarget = decodeAbsoluteJumpTarget(nextInst.address, nextInst.target);
        if (!isCodeAddress(jumpTarget))
        {
            return false;
        }

        std::cout << "Potential self-modifying code at " << formatAddress(storeInst.address)
                  << " writing to " << formatAddress(targetAddr)
                  << " then jumping to " << formatAddress(jumpTarget)
                  << " in function " << func.name << std::endl;

        m_patches[storeInst.address] = 0x00000000;
        m_patchReasons[storeInst.address] = "Potential self-modifying code";
        return true;
    }

    bool ElfAnalyzer::tryResolveBasePlusOffset(
        const std::vector<Instruction> &instructions,
        size_t index,
        uint32_t baseReg,
        int16_t offset,
        uint32_t &outAddr) const
    {
        uint32_t baseAddr = 0;
        if (!tryResolveLuiBase(instructions, index, baseReg, baseAddr))
        {
            return false;
        }

        outAddr = baseAddr + static_cast<int32_t>(offset);
        return true;
    }

    bool ElfAnalyzer::tryResolveLuiBase(
        const std::vector<Instruction> &instructions,
        size_t index,
        uint32_t reg,
        uint32_t &baseAddr) const
    {
        baseAddr = 0;

        const size_t start = (index > 8) ? (index - 8) : 0;
        for (size_t pos = index; pos-- > start;)
        {
            const Instruction &prev = instructions[pos];

            if ((prev.opcode == OPCODE_ADDIU || prev.opcode == OPCODE_ORI) && prev.rt == reg)
            {
                uint32_t hiBase = 0;
                if (!tryResolveLuiBase(instructions, pos, prev.rs, hiBase))
                {
                    return false;
                }

                if (prev.opcode == OPCODE_ADDIU)
                {
                    baseAddr = hiBase + static_cast<uint32_t>(static_cast<int32_t>(static_cast<int16_t>(prev.immediate)));
                }
                else
                {
                    baseAddr = hiBase | static_cast<uint32_t>(prev.immediate);
                }

                return true;
            }

            if (prev.opcode == OPCODE_LUI && prev.rt == reg)
            {
                baseAddr = prev.immediate << 16;
                return true;
            }

            if (prev.rt == reg || prev.rd == reg)
            {
                break;
            }
        }

        return false;
    }

    bool ElfAnalyzer::isCodeAddress(uint32_t addr) const
    {
        for (const auto &section : m_sections)
        {
            if (!section.isCode)
            {
                continue;
            }

            const uint32_t sectionEnd = section.address + section.size;
            if (addr >= section.address && addr < sectionEnd)
            {
                return true;
            }
        }

        return false;
    }

    void ElfAnalyzer::analyzeControlFlow()
    {
        std::cout << "Analyzing control flow of functions..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            CFG cfg = buildCFG(func);
            m_functionCFGs[func.start] = cfg;

            std::vector<Instruction> instructions = decodeFunction(func);
            for (const auto &inst : instructions)
            {
                if (inst.opcode == OPCODE_JAL ||
                    (inst.opcode == OPCODE_SPECIAL && inst.function == SPECIAL_JALR))
                {

                    uint32_t targetAddr = 0;

                    if (inst.opcode == OPCODE_JAL)
                    {
                        targetAddr = decodeAbsoluteJumpTarget(inst.address, inst.target);
                    }
                    else
                    {
                        // For JALR, the target is in the register - harder to statically analyze so lets skip it
                        continue;
                    }

                    for (const auto &targetFunc : m_functions)
                    {
                        if (targetFunc.start == targetAddr)
                        {
                            FunctionCall call;
                            call.callerAddress = inst.address;
                            call.calleeAddress = targetAddr;
                            call.calleeName = targetFunc.name;

                            m_functionCalls[func.start].push_back(call);

                            std::cout << "Function " << func.name << " calls " << targetFunc.name
                                      << " at " << formatAddress(inst.address) << std::endl;
                            break;
                        }
                    }
                }
            }
        }
    }

    std::vector<JumpTable> ElfAnalyzer::detectJumpTablesForHeuristics(
        const std::vector<Instruction> &instructions,
        const std::vector<Section> &sections,
        const std::function<bool(uint32_t, uint32_t &)> &readWord)
    {
        std::vector<JumpTable> jumpTables;

        auto addSignedImm16 = [](uint32_t hiPart, uint16_t imm16) -> uint32_t
        {
            return hiPart + static_cast<uint32_t>(static_cast<int32_t>(static_cast<int16_t>(imm16)));
        };

        auto orUnsignedImm16 = [](uint32_t hiPart, uint16_t imm16) -> uint32_t
        {
            return hiPart | static_cast<uint32_t>(imm16);
        };

        auto looksLikeCodeTarget = [sections](uint32_t addr) -> bool
        {
            if (addr == 0)
            {
                return false;
            }

            if (sections.empty())
            {
                return true;
            }

            for (const auto &section : sections)
            {
                if (!section.isCode)
                {
                    continue;
                }

                const uint32_t sectionEnd = section.address + section.size;
                if (addr >= section.address && addr < sectionEnd)
                {
                    return true;
                }
            }

            return false;
        };

        auto readJumpEntryCandidate = [&](uint32_t entryAddr, bool isLoadDouble, uint32_t &outTarget) -> bool
        {
            outTarget = 0;

            uint32_t w0 = 0;
            if (!readWord(entryAddr, w0))
            {
                return false;
            }

            if (!isLoadDouble)
            {
                outTarget = w0;
                return true;
            }

            uint32_t w1 = 0;
            if (!readWord(entryAddr + 4u, w1))
            {
                outTarget = w0; // still keep something
                return true;
            }

            const bool w0Looks = looksLikeCodeTarget(w0);
            const bool w1Looks = looksLikeCodeTarget(w1);

            if (w0Looks && !w1Looks)
            {
                outTarget = w0;
                return true;
            }
            if (w1Looks && !w0Looks)
            {
                outTarget = w1;
                return true;
            }
            outTarget = w0;
            return true;
        };

        auto tryBuildTable = [&](uint32_t baseAddr, uint32_t baseReg, uint32_t numEntries, uint32_t strideBytes, bool isLoadDouble) -> std::optional<JumpTable>
        {
            JumpTable jumpTable;
            jumpTable.address = baseAddr;
            jumpTable.baseRegister = baseReg;

            uint32_t validCodeTargets = 0;
            uint32_t totalRead = 0;

            for (uint32_t e = 0; e < numEntries; e++)
            {
                const uint32_t entryAddr = baseAddr + (e * strideBytes);

                uint32_t targetAddr = 0;
                if (!readJumpEntryCandidate(entryAddr, isLoadDouble, targetAddr))
                {
                    continue;
                }

                totalRead++;

                if (looksLikeCodeTarget(targetAddr))
                {
                    validCodeTargets++;
                }

                JumpTableEntry entry;
                entry.index = e;
                entry.target = targetAddr;
                jumpTable.entries.push_back(entry);
            }

            if (jumpTable.entries.empty())
            {
                return std::nullopt;
            }

            bool ok = false;
            if (sections.empty())
            {
                ok = (totalRead >= 2);
            }
            else
            {
                ok = (validCodeTargets >= 2) &&
                     (totalRead >= 2) &&
                     (validCodeTargets * 2 >= totalRead);
            }

            if (!ok)
            {
                return std::nullopt;
            }

            return jumpTable;
        };

        for (size_t i = 0; i < instructions.size(); i++)
        {
            const auto &inst = instructions[i];

            if (inst.opcode != OPCODE_SLTIU || i + 2 >= instructions.size())
            {
                continue;
            }

            const auto &nextInst = instructions[i + 1];
            if (nextInst.opcode != OPCODE_BNE && nextInst.opcode != OPCODE_BEQ)
            {
                continue;
            }

            // scan for LW/LD + JR pair
            for (size_t j = i + 2; j < std::min(i + 10, instructions.size()); j++)
            {
                const auto &loadInst = instructions[j];
                const bool isLoadWord = (loadInst.opcode == OPCODE_LW);
                const bool isLoadDouble = (loadInst.opcode == OPCODE_LD);

                if ((!isLoadWord && !isLoadDouble) || j + 1 >= instructions.size())
                {
                    continue;
                }

                const auto &jumpInst = instructions[j + 1];
                if (jumpInst.opcode != OPCODE_SPECIAL ||
                    jumpInst.function != SPECIAL_JR ||
                    jumpInst.rs != loadInst.rt)
                {
                    continue;
                }

                const uint32_t numEntries = inst.immediate;
                if (numEntries == 0 || numEntries >= 1000)
                {
                    break;
                }

                uint32_t baseAddr = 0;

                // A) LUI tmp ; ADDIU/ORI base, tmp, lo
                // B) LUI base ; ... ; LW/LD rt, lo(base)
                for (int k = static_cast<int>(j) - 1; k >= static_cast<int>(i); k--)
                {
                    const auto &addrInst = instructions[static_cast<size_t>(k)];
                    if (addrInst.opcode != OPCODE_LUI)
                    {
                        continue;
                    }

                    const uint32_t hiPart = (addrInst.immediate << 16);

                    if (static_cast<size_t>(k + 1) < instructions.size())
                    {
                        const auto &offsetInst = instructions[static_cast<size_t>(k + 1)];
                        const bool isAddiuOrOri = (offsetInst.opcode == OPCODE_ADDIU || offsetInst.opcode == OPCODE_ORI);

                        if (isAddiuOrOri &&
                            offsetInst.rs == addrInst.rt &&
                            offsetInst.rt == loadInst.rs)
                        {
                            if (offsetInst.opcode == OPCODE_ADDIU)
                            {
                                baseAddr = addSignedImm16(hiPart, offsetInst.immediate);
                            }
                            else
                            {
                                baseAddr = orUnsignedImm16(hiPart, offsetInst.immediate);
                            }
                            break;
                        }
                    }

                    if (addrInst.rt == loadInst.rs)
                    {
                        baseAddr = addSignedImm16(hiPart, loadInst.immediate);
                        break;
                    }
                }

                if (baseAddr == 0)
                {
                    break;
                }

                const uint32_t preferredStride = isLoadDouble ? 8u : 4u;

                std::optional<JumpTable> table = tryBuildTable(baseAddr, loadInst.rs, numEntries, preferredStride, isLoadDouble);
                if (!table && isLoadDouble)
                {
                    table = tryBuildTable(baseAddr, loadInst.rs, numEntries, 4u, isLoadDouble);
                }

                if (table)
                {
                    jumpTables.push_back(std::move(*table));
                }

                break;
            }
        }

        return jumpTables;
    }

    void ElfAnalyzer::detectJumpTables()
    {
        std::cout << "Detecting jump tables..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);
            std::vector<JumpTable> detectedTables = detectJumpTablesForHeuristics(
                instructions,
                m_sections,
                [this](uint32_t address, uint32_t &outWord) -> bool
                {
                    return tryReadWord(m_elfParser.get(), address, outWord);
                });

            for (const auto &jumpTable : detectedTables)
            {
                std::cout << "Detected jump table in function " << func.name
                          << " at " << formatAddress(jumpTable.address) << std::endl;
                for (const auto &[index, target] : jumpTable.entries)
                {
                    std::cout << "  - Jump table entry " << index << ": 0x"
                              << std::hex << target << std::dec << std::endl;
                }

                m_jumpTables.push_back(jumpTable);
            }
        }
    }

    void ElfAnalyzer::analyzePerformanceCriticalPaths() const
    {
        std::cout << "Analyzing performance-critical paths..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);

            for (const auto &inst : instructions)
            {
                if (inst.isBranch)
                {
                    int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                    uint32_t targetAddr = inst.address + 4 + offset;

                    if (targetAddr < inst.address)
                    {
                        size_t loopSize = (inst.address - targetAddr) / 4 + 1;

                        if (loopSize < 20)
                        {
                            std::cout << "Found tight loop in function " << func.name
                                      << " from " << formatAddress(targetAddr)
                                      << " to " << formatAddress(inst.address)
                                      << " (size: " << loopSize << " instructions)" << std::endl;

                            bool hasMultimedia = false;
                            for (const auto &instruction : instructions)
                            {
                                if (instruction.address >= targetAddr && instruction.address <= inst.address)
                                {
                                    if (instruction.isMultimedia)
                                    {
                                        hasMultimedia = true;
                                        break;
                                    }
                                }
                            }

                            if (hasMultimedia)
                            {
                                std::cout << "  - Loop contains multimedia instructions" << std::endl;
                            }
                        }
                    }
                }
            }
        }
    }

    std::unordered_set<std::string> ElfAnalyzer::findRecursiveFunctionsForHeuristics(
        const std::unordered_map<std::string, std::vector<std::string>> &callGraph)
    {
        std::unordered_set<std::string> nodes;
        for (const auto &[caller, callees] : callGraph)
        {
            nodes.insert(caller);
            for (const auto &callee : callees)
            {
                nodes.insert(callee);
            }
        }

        std::unordered_map<std::string, int> index;
        std::unordered_map<std::string, int> lowlink;
        std::unordered_set<std::string> onStack;
        std::vector<std::string> stack;

        index.reserve(nodes.size());
        lowlink.reserve(nodes.size());
        onStack.reserve(nodes.size());
        stack.reserve(nodes.size());

        int currentIndex = 0;
        std::vector<std::vector<std::string>> sccs;
        sccs.reserve(nodes.size());

        std::function<void(const std::string &)> strongconnect;
        strongconnect = [&](const std::string &v)
        {
            index[v] = currentIndex;
            lowlink[v] = currentIndex;
            currentIndex++;

            stack.push_back(v);
            onStack.insert(v);

            auto it = callGraph.find(v);
            if (it != callGraph.end())
            {
                for (const auto &w : it->second)
                {
                    if (!index.contains(w))
                    {
                        strongconnect(w);
                        lowlink[v] = std::min(lowlink[v], lowlink[w]);
                    }
                    else if (onStack.contains(w))
                    {
                        lowlink[v] = std::min(lowlink[v], index[w]);
                    }
                }
            }

            if (lowlink[v] == index[v])
            {
                std::vector<std::string> scc;
                while (!stack.empty())
                {
                    std::string w = stack.back();
                    stack.pop_back();
                    onStack.erase(w);
                    scc.push_back(w);
                    if (w == v)
                    {
                        break;
                    }
                }

                sccs.push_back(std::move(scc));
            }
        };

        for (const auto &name : nodes)
        {
            if (!index.contains(name))
            {
                strongconnect(name);
            }
        }

        std::unordered_set<std::string> recursive;
        for (const auto &scc : sccs)
        {
            if (scc.size() > 1)
            {
                recursive.insert(scc.begin(), scc.end());
                continue;
            }

            const std::string &name = scc[0];
            auto it = callGraph.find(name);
            if (it == callGraph.end())
            {
                continue;
            }

            if (std::find(it->second.begin(), it->second.end(), name) != it->second.end())
            {
                recursive.insert(name);
            }
        }

        return recursive;
    }

    void ElfAnalyzer::identifyRecursiveFunctions()
    {
        std::cout << "Identifying recursive functions..." << std::endl;

        // lets ignore skip and library
        std::unordered_set<std::string> eligible;
        eligible.reserve(m_functions.size());

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            eligible.insert(func.name);
        }

        std::unordered_map<std::string, std::vector<std::string>> callGraph;
        callGraph.reserve(eligible.size());

        for (const auto &func : m_functions)
        {
            if (!eligible.contains(func.name))
            {
                continue;
            }

            auto itCalls = m_functionCalls.find(func.start);
            if (itCalls == m_functionCalls.end())
            {
                continue;
            }

            auto &edges = callGraph[func.name];
            edges.reserve(itCalls->second.size());

            for (const auto &call : itCalls->second)
            {
                // non-eligible nodes to graph.
                if (!eligible.contains(call.calleeName))
                {
                    continue;
                }

                edges.push_back(call.calleeName);
            }
        }

        std::unordered_set<std::string> recursive = findRecursiveFunctionsForHeuristics(callGraph);
        for (const auto &name : recursive)
        {
            auto it = callGraph.find(name);
            if (it != callGraph.end() &&
                std::find(it->second.begin(), it->second.end(), name) != it->second.end())
            {
                std::cout << "Function " << name << " is directly recursive" << std::endl;
            }
            else
            {
                std::cout << "Function " << name << " is part of a mutually recursive cycle" << std::endl;
            }
        }
    }

    void ElfAnalyzer::analyzeRegisterUsage() const
    {
        std::cout << "Analyzing register usage patterns..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);
            std::set<uint32_t> regsRead, regsWritten;

            for (const auto &inst : instructions)
            {
                if (inst.rs != 0)
                    regsRead.insert(inst.rs);
                if (inst.rt != 0 && inst.opcode != OPCODE_SW && inst.opcode != OPCODE_SB &&
                    inst.opcode != OPCODE_SH && inst.opcode != OPCODE_SQ)
                {
                    regsRead.insert(inst.rt);
                }

                if (inst.opcode == OPCODE_SPECIAL || inst.opcode == OPCODE_REGIMM ||
                    inst.opcode == OPCODE_COP1 || inst.opcode == OPCODE_COP2)
                {
                    // R-type instructions
                    if (inst.rd != 0)
                        regsWritten.insert(inst.rd);
                }
                else if (inst.opcode == OPCODE_JAL)
                {
                    // JAL writes to $ra (r31)
                    regsWritten.insert(31);
                }
                else if (inst.opcode == OPCODE_LUI || inst.opcode == OPCODE_ADDIU ||
                         inst.opcode == OPCODE_ORI || inst.opcode == OPCODE_LW ||
                         inst.opcode == OPCODE_LB || inst.opcode == OPCODE_LH)
                {
                    // I-type instructions that write to rt
                    if (inst.rt != 0)
                        regsWritten.insert(inst.rt);
                }
            }

            // Check if function follows standard calling convention
            bool hasStackOps = false;
            bool savesFP = false;
            bool savesRA = false;

            for (size_t i = 0; i < std::min(static_cast<size_t>(10), instructions.size()); i++)
            {
                const auto &inst = instructions[i];

                // ADDIU $sp, $sp, -X (allocate stack frame)
                if (inst.opcode == OPCODE_ADDIU && inst.rs == 29 && inst.rt == 29 &&
                    static_cast<int16_t>(inst.immediate) < 0)
                {
                    hasStackOps = true;
                }

                // SW $fp, X($sp) (save frame pointer)
                if (inst.opcode == OPCODE_SW && inst.rt == 30 && inst.rs == 29)
                {
                    savesFP = true;
                }

                // SW $ra, X($sp) (save return address)
                if (inst.opcode == OPCODE_SW && inst.rt == 31 && inst.rs == 29)
                {
                    savesRA = true;
                }
            }

            if (hasStackOps)
            {
                std::cout << "Function " << func.name << " allocates a stack frame" << std::endl;

                if (savesFP)
                    std::cout << "  - Saves frame pointer ($fp)" << std::endl;
                if (savesRA)
                    std::cout << "  - Saves return address ($ra)" << std::endl;
            }

            if (regsRead.contains(4) || regsRead.contains(5) ||
                regsRead.contains(6) || regsRead.contains(7))
            {
                std::cout << "  - Uses argument registers (a0-a3)" << std::endl;
            }

            if (regsWritten.contains(2) || regsWritten.contains(3))
            {
                std::cout << "  - Sets return values (v0-v1)" << std::endl;
            }
        }
    }

    void ElfAnalyzer::analyzeFunctionSignatures() const
    {
        std::cout << "Analyzing function signatures..." << std::endl;

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.contains(func.name) ||
                m_libFunctions.contains(func.name))
            {
                continue;
            }

            std::vector<Instruction> instructions = decodeFunction(func);

            int paramCount = 0;
            bool usesFloatingPoint = false;
            bool usesDoublewords = false;
            bool returnsSomething = false;

            for (const auto &inst : instructions)
            {
                if ((inst.rs >= 4 && inst.rs <= 7) || (inst.rt >= 4 && inst.rt <= 7))
                {
                    paramCount = std::max(paramCount, static_cast<int>(std::max(inst.rs, inst.rt) - 3));
                }

                if (inst.opcode == OPCODE_COP1)
                {
                    usesFloatingPoint = true;
                }

                // Check for 64-bit operations
                if (inst.opcode == OPCODE_LD || inst.opcode == OPCODE_SD ||
                    (inst.opcode == OPCODE_SPECIAL &&
                     (inst.function == SPECIAL_DSLL || inst.function == SPECIAL_DSRL ||
                      inst.function == SPECIAL_DSRA || inst.function == SPECIAL_DSLLV ||
                      inst.function == SPECIAL_DSRLV || inst.function == SPECIAL_DSRAV)))
                {
                    usesDoublewords = true;
                }

                // Check for return value setting, addition we could do as well thous check (inst.opcode == OPCODE_ADDIU && inst.rs == 0) ||  // LI pattern using ADDIU $rt, $zero, imm  and (inst.opcode == OPCODE_ORI && i > 0 && instructions[i - 1].opcode == OPCODE_LUI && instructions[i - 1].rt == inst.rs && inst.rt == inst.rs)
                if ((inst.opcode == OPCODE_ADDIU || inst.opcode == OPCODE_ORI ||
                     inst.opcode == OPCODE_LW) &&
                    (inst.rt == 2 || inst.rt == 3))
                {
                    returnsSomething = true;
                }
                else if (inst.opcode == OPCODE_SPECIAL &&
                         (inst.function == SPECIAL_ADD || inst.function == SPECIAL_ADDU ||
                          inst.function == SPECIAL_SUB || inst.function == SPECIAL_SUBU ||
                          inst.function == SPECIAL_AND || inst.function == SPECIAL_OR ||
                          inst.function == SPECIAL_XOR || inst.function == SPECIAL_NOR) &&
                         (inst.rd == 2 || inst.rd == 3))
                {
                    returnsSomething = true;
                }
            }

            if (paramCount > 0 || usesFloatingPoint || usesDoublewords || returnsSomething)
            {
                std::cout << "Function " << func.name << " signature analysis:" << std::endl;
                if (paramCount > 0)
                {
                    std::cout << "  - Uses approximately " << paramCount << " parameter(s)" << std::endl;
                }
                if (usesFloatingPoint)
                {
                    std::cout << "  - Uses floating point operations" << std::endl;
                }
                if (usesDoublewords)
                {
                    std::cout << "  - Uses 64-bit operations" << std::endl;
                }
                if (returnsSomething)
                {
                    std::cout << "  - Returns a value" << std::endl;
                }
            }
        }
    }

    void ElfAnalyzer::optimizePatches()
    {
        std::cout << "Optimizing patches..." << std::endl;

        std::map<uint32_t, std::vector<uint32_t>> functionPatches;

        for (const auto &patch : m_patches)
        {
            uint32_t patchAddr = patch.first;

            for (const auto &func : m_functions)
            {
                if (patchAddr >= func.start && patchAddr < func.end)
                {
                    functionPatches[func.start].push_back(patchAddr);
                    break;
                }
            }
        }

        for (const auto &[funcStart, patchAddrs] : functionPatches)
        {
            auto funcIt = std::find_if(m_functions.begin(), m_functions.end(),
                                       [funcStart](const Function &f)
                                       { return f.start == funcStart; });

            if (funcIt != m_functions.end())
            {
                const Function &func = *funcIt;

                if (patchAddrs.size() > 3)
                {
                    std::cout << "Function " << func.name << " has " << patchAddrs.size()
                              << " patches. Consider skipping or stubing instead." << std::endl;

                    // If too many patches in one function, maybe better to skip it
                    if (shouldSkipForPatchDensityForHeuristics(func.name,
                                                               func.end - func.start,
                                                               patchAddrs.size(),
                                                               isLibraryFunction(func.name)))
                    {
                        std::cout << "  - Adding " << func.name << " to skip list due to high patch density" << std::endl;
                        m_skipFunctions.insert(func.name);

                        for (const auto &addr : patchAddrs)
                        {
                            m_patches.erase(addr);
                            m_patchReasons.erase(addr);
                        }
                    }
                }
            }
        }

        std::vector<uint32_t> patchAddrs;
        for (const auto &patch : m_patches)
        {
            patchAddrs.push_back(patch.first);
        }

        if (patchAddrs.size() == 0)
            return;

        std::sort(patchAddrs.begin(), patchAddrs.end());

        for (size_t i = 0; i < patchAddrs.size() - 1; i++)
        {
            if (patchAddrs[i] + 4 == patchAddrs[i + 1])
            {
                std::cout << "Sequential patches at " << formatAddress(patchAddrs[i])
                          << " and " << formatAddress(patchAddrs[i + 1]) << std::endl;

                // If they're both NOPs, we could potentially optimize them together
                if (m_patches[patchAddrs[i]] == 0 && m_patches[patchAddrs[i + 1]] == 0)
                {
                    std::cout << "  - Both are NOPs, could be combined in recompilation" << std::endl;
                }
            }
        }
    }

    bool ElfAnalyzer::identifyMemcpyPattern(const Function &func) const
    {
        std::vector<Instruction> instructions = decodeFunction(func);

        bool hasLoop = false;
        bool loadsData = false;
        bool storesData = false;
        bool incrementsPointers = false;

        for (const auto &inst : instructions)
        {
            if (inst.isBranch)
            {
                int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                if (inst.address + 4 + offset < inst.address)
                {
                    hasLoop = true;
                }
            }

            if (inst.opcode == OPCODE_LW || inst.opcode == OPCODE_LB ||
                inst.opcode == OPCODE_LH || inst.opcode == OPCODE_LD ||
                inst.opcode == OPCODE_LQ)
            {
                loadsData = true;
            }

            if (inst.opcode == OPCODE_SW || inst.opcode == OPCODE_SB ||
                inst.opcode == OPCODE_SH || inst.opcode == OPCODE_SD ||
                inst.opcode == OPCODE_SQ)
            {
                storesData = true;
            }

            if (inst.opcode == OPCODE_ADDIU &&
                (inst.immediate == 4 || inst.immediate == 8 || inst.immediate == 16))
            {
                incrementsPointers = true;
            }
        }

        return hasLoop && loadsData && storesData && incrementsPointers;
    }

    bool ElfAnalyzer::identifyMemsetPattern(const Function &func) const
    {
        std::vector<Instruction> instructions = decodeFunction(func);

        bool hasLoop = false;
        bool usesConstant = false;
        bool storesData = false;
        bool incrementsPointer = false;

        for (const auto &inst : instructions)
        {
            if (inst.isBranch)
            {
                int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                if (inst.address + 4 + offset < inst.address)
                {
                    hasLoop = true;
                }
            }

            if (inst.opcode == OPCODE_LUI || inst.opcode == OPCODE_ORI ||
                inst.opcode == OPCODE_ADDIU || inst.opcode == OPCODE_ANDI)
            {
                usesConstant = true;
            }

            if (inst.opcode == OPCODE_SW || inst.opcode == OPCODE_SB ||
                inst.opcode == OPCODE_SH || inst.opcode == OPCODE_SD ||
                inst.opcode == OPCODE_SQ)
            {
                storesData = true;
            }

            if (inst.opcode == OPCODE_ADDIU &&
                (inst.immediate == 4 || inst.immediate == 8 || inst.immediate == 16))
            {
                incrementsPointer = true;
            }
        }

        return hasLoop && usesConstant && storesData && incrementsPointer;
    }

    bool ElfAnalyzer::identifyStringOperationPattern(const Function &func) const
    {
        std::vector<Instruction> instructions = decodeFunction(func);

        bool hasLoop = false;
        bool checksZero = false;
        bool loadsByte = false;
        bool storesByte = false;

        for (const auto &inst : instructions)
        {
            if (inst.isBranch)
            {
                int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                if (inst.address + 4 + offset < inst.address)
                {
                    hasLoop = true;
                }
            }

            if ((inst.opcode == OPCODE_BEQ && (inst.rs == 0 || inst.rt == 0)) ||
                (inst.opcode == OPCODE_SPECIAL && inst.function == SPECIAL_SLT && inst.rd != 0))
            {
                checksZero = true;
            }

            if (inst.opcode == OPCODE_LB || inst.opcode == OPCODE_LBU)
            {
                loadsByte = true;
            }

            if (inst.opcode == OPCODE_SB)
            {
                storesByte = true;
            }
        }

        return hasLoop && checksZero && (loadsByte || storesByte);
    }

    bool ElfAnalyzer::identifyMathPattern(const Function &func) const
    {
        std::vector<Instruction> instructions = decodeFunction(func);

        int mathOps = 0;
        bool usesFPU = false;

        for (const auto &inst : instructions)
        {
            // Count ALU operations
            if (inst.opcode == OPCODE_SPECIAL &&
                (inst.function == SPECIAL_ADD || inst.function == SPECIAL_ADDU ||
                 inst.function == SPECIAL_SUB || inst.function == SPECIAL_SUBU ||
                 inst.function == SPECIAL_MULT || inst.function == SPECIAL_MULTU ||
                 inst.function == SPECIAL_DIV || inst.function == SPECIAL_DIVU))
            {
                mathOps++;
            }

            // Check for FPU usage
            if (inst.opcode == OPCODE_COP1)
            {
                usesFPU = true;
                mathOps++;
            }
        }

        // If more than 30% of instructions are math operations, it's likely a math function
        return mathOps > instructions.size() * 0.3 || usesFPU;
    }

    CFG ElfAnalyzer::buildCFG(const Function &function) const
    {
        CFG cfg;
        std::vector<Instruction> instructions = decodeFunction(function);
        std::map<uint32_t, size_t> addrToIndex;

        for (size_t i = 0; i < instructions.size(); i++)
        {
            addrToIndex[instructions[i].address] = i;
        }

        std::set<uint32_t> leaders = {function.start}; // Entry point is always a leader

        for (size_t i = 0; i < instructions.size(); i++)
        {
            const auto &inst = instructions[i];

            if (inst.isBranch || inst.isJump)
            {
                size_t fallthroughIndex = i + (inst.hasDelaySlot ? 2 : 1);
                if (fallthroughIndex < instructions.size())
                {
                    leaders.insert(instructions[fallthroughIndex].address);
                }

                if (inst.isBranch)
                {
                    int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                    uint32_t target = inst.address + 4 + offset;
                    leaders.insert(target);
                }

                // Jump target for J/JAL
                if ((inst.opcode == OPCODE_J || inst.opcode == OPCODE_JAL) && !inst.isCall)
                {
                    uint32_t target = decodeAbsoluteJumpTarget(inst.address, inst.target);
                    leaders.insert(target);
                }
            }
        }

        uint32_t currentLeader = 0;
        CFGNode currentNode;

        for (size_t i = 0; i < instructions.size(); i++)
        {
            const auto &inst = instructions[i];

            if (leaders.contains(inst.address))
            {
                if (currentLeader != 0)
                {
                    currentNode.endAddress = instructions[i - 1].address;
                    cfg[currentLeader] = currentNode;
                }

                currentLeader = inst.address;
                currentNode = CFGNode();
                currentNode.startAddress = currentLeader;
                currentNode.isJumpTarget = true;
                currentNode.instructions.clear();
            }

            currentNode.instructions.push_back(inst);

            if (i == instructions.size() - 1)
            {
                currentNode.endAddress = inst.address;
                cfg[currentLeader] = currentNode;
            }
        }

        for (auto &[addr, node] : cfg)
        {
            if (node.instructions.empty())
            {
                continue;
            }

            const auto &lastInst = node.instructions.back();
            const Instruction *terminator = &lastInst;

            if (node.instructions.size() >= 2)
            {
                const auto &candidate = node.instructions[node.instructions.size() - 2];
                if (candidate.hasDelaySlot &&
                    (candidate.isBranch || candidate.isJump) &&
                    candidate.address + 4 == lastInst.address)
                {
                    terminator = &candidate;
                }
            }

            if (terminator->isBranch)
            {
                int32_t offset = static_cast<int16_t>(terminator->immediate) << 2;
                uint32_t targetAddr = terminator->address + 4 + offset;

                if (cfg.contains(targetAddr))
                {
                    node.successors.push_back(targetAddr);
                    cfg[targetAddr].predecessors.push_back(addr);
                }

                bool likelyBranch = (terminator->opcode == OPCODE_BEQL ||
                                     terminator->opcode == OPCODE_BNEL ||
                                     terminator->opcode == OPCODE_BLEZL ||
                                     terminator->opcode == OPCODE_BGTZL);

                if (!likelyBranch)
                {
                    const uint32_t step = terminator->hasDelaySlot ? 8 : 4;
                    if (terminator->address + step <= function.end)
                    {
                        uint32_t nextAddr = terminator->address + step;

                        for (const auto &[blockAddr, blockNode] : cfg)
                        {
                            if (blockAddr == nextAddr ||
                                (nextAddr > blockAddr && nextAddr <= blockNode.endAddress))
                            {
                                node.successors.push_back(blockAddr);
                                cfg[blockAddr].predecessors.push_back(addr);
                                break;
                            }
                        }
                    }
                }
            }
            else if (terminator->isJump)
            {
                if (terminator->opcode == OPCODE_J || terminator->opcode == OPCODE_JAL)
                {
                    // Direct jump
                    uint32_t targetAddr = decodeAbsoluteJumpTarget(terminator->address, terminator->target);

                    // Only add successor if it's within this function
                    if (targetAddr >= function.start && targetAddr < function.end &&
                        cfg.contains(targetAddr))
                    {
                        node.successors.push_back(targetAddr);
                        cfg[targetAddr].predecessors.push_back(addr);
                    }
                }
                // We don't handle indirect jumps (JR/JALR) statically
            }
            else if (!lastInst.isReturn)
            {
                if (lastInst.address + 4 <= function.end)
                {
                    uint32_t nextAddr = lastInst.address + 4;

                    for (const auto &[blockAddr, blockNode] : cfg)
                    {
                        if (blockAddr == nextAddr)
                        {
                            node.successors.push_back(blockAddr);
                            cfg[blockAddr].predecessors.push_back(addr);
                            break;
                        }
                    }
                }
            }
        }

        return cfg;
    }

    std::string ElfAnalyzer::escapeBackslashes(const std::string &path)
    {
        std::string result;
        for (char ch : path)
        {
            if (ch == '\\')
                result.append("\\\\");
            else
                result.push_back(ch);
        }
        return result;
    }

    static bool hasPs2ApiPrefix(const std::string &name)
    {
        if (name.empty())
            return false;

        const std::vector<std::string> libraryPrefixes = {
            "sce", "Sce", "SCE",   // Sony prefixes
            "sif", "Sif", "SIF",   // SIF functions
            "pad", "Pad", "PAD",   // Pad functions
            "gs", "Gs", "GS",      // Graphics Synthesizer
            "dma", "Dma", "DMA",   // DMA functions
            "iop", "Iop", "IOP",   // IOP functions
            "vif", "Vif", "VIF",   // VIF functions
            "spu", "Spu", "SPU",   // SPU functions
            "mc", "Mc", "MC",      // Memory Card functions
            "libc", "Libc", "LIBC" // C library functions
        };

        std::string base = name;
        if (base[0] == '_' && base.size() > 1)
        {
            base = base.substr(1);
        }

        for (const auto &prefix : libraryPrefixes)
        {
            if (base.rfind(prefix, 0) == 0)
            {
                return true;
            }
        }

        return false;
    }

    static bool isDoNotSkipOrStub(const std::string &name)
    {
        static const std::unordered_set<std::string> kDoNotSkipOrStub = {
            "topThread",
            "cmd_sem_init"};

        return kDoNotSkipOrStub.contains(name);
    }

    static bool hasReliableSymbolName(const std::string &name)
    {
        if (name.empty())
        {
            return false;
        }

        auto startsWith = [&](const char *prefix) -> bool
        {
            return name.rfind(prefix, 0) == 0;
        };

        if (startsWith("sub_") || startsWith("FUN_") || startsWith("func_") ||
            startsWith("entry_") || startsWith("function_") || startsWith("LAB_"))
        {
            return false;
        }

        bool hasAlpha = false;
        bool allHexOrPrefix = true;
        for (char c : name)
        {
            if (std::isalpha(static_cast<unsigned char>(c)))
            {
                hasAlpha = true;
            }

            if (!(std::isxdigit(static_cast<unsigned char>(c)) || c == 'x' || c == 'X' || c == '_'))
            {
                allHexOrPrefix = false;
            }
        }

        if (!hasAlpha)
        {
            return false;
        }

        if ((startsWith("0x") || startsWith("0X")) && allHexOrPrefix)
        {
            return false;
        }

        return true;
    }

    bool ElfAnalyzer::isReliableSymbolNameForHeuristics(const std::string &name)
    {
        return hasReliableSymbolName(name);
    }

    bool ElfAnalyzer::isSystemSymbolNameForHeuristics(const std::string &name)
    {
        if (!hasReliableSymbolName(name))
        {
            return false;
        }

        static const std::unordered_set<std::string> systemFuncs = {
            "entry", "_start", "_init", "_fini",
            "abort", "exit", "_exit",
            "_profiler_start", "_profiler_stop",
            "__main", "__do_global_ctors", "__do_global_dtors",
            "_GLOBAL__sub_I_", "_GLOBAL__sub_D_",
            "__ctor_list", "__dtor_list", "_edata", "_end",
            "etext", "__exidx_start", "__exidx_end",
            "_ftext", "__bss_start", "__bss_start__",
            "__bss_end__", "__end__", "_stack", "_dso_handle"};

        return systemFuncs.contains(name) ||
               name.find("__") == 0 ||
               name.find(".") == 0; // .text.* or .plt.* symbols
    }

    bool ElfAnalyzer::shouldAutoSkipNameForHeuristics(const std::string &name)
    {
        if (isDoNotSkipOrStub(name))
        {
            return false;
        }

        // For named game logic, prefer recompiling and only skip explicit/system cases.
        if (!hasReliableSymbolName(name))
        {
            return true;
        }

        return isSystemSymbolNameForHeuristics(name);
    }

    bool ElfAnalyzer::isSystemFunction(const std::string &name) const
    {
        return isSystemSymbolNameForHeuristics(name);
    }

    bool ElfAnalyzer::isLibraryFunction(const std::string &name) const
    {
        if (name.empty())
            return false;

        if (!hasReliableSymbolName(name))
            return false;

        if (m_knownLibNames.find(name) != m_knownLibNames.end())
            return true;

        if (hasPs2ApiPrefix(name))
            return true;

        // Check for common C/C++ library function names
        static const std::regex cLibPattern("^_*(mem|str|time|f?printf|f?scanf|malloc|free|calloc|realloc|atoi|itoa|rand|srand|abort|exit|atexit|getenv|system|bsearch|qsort|abs|labs|div|ldiv|mblen|mbtowc|wctomb|mbstowcs|wcstombs).*");
        if (std::regex_match(name, cLibPattern))
        {
            return true;
        }

        return false;
    }

    bool ElfAnalyzer::isLibrarySymbolNameForHeuristics(const std::string &name) const
    {
        return isLibraryFunction(name);
    }

    bool ElfAnalyzer::hasHardwareIOSignalForHeuristics(const std::vector<Instruction> &instructions)
    {
        for (const auto &inst : instructions)
        {
            if (inst.opcode == OPCODE_LUI)
            {
                const uint32_t upperAddr = inst.immediate << 16;
                if ((upperAddr >= 0x10000000 && upperAddr < 0x14000000) || // I/O area
                    (upperAddr >= 0x1F800000 && upperAddr < 0x1F900000))   // Scratchpad RAM
                {
                    return true;
                }
            }
        }

        return false;
    }

    bool ElfAnalyzer::hasLargeComplexMMISignalForHeuristics(const std::vector<Instruction> &instructions,
                                                            size_t largeInstructionThreshold)
    {
        if (instructions.size() <= largeInstructionThreshold)
        {
            return false;
        }

        for (const auto &inst : instructions)
        {
            if (inst.isMMI &&
                inst.opcode == OPCODE_MMI &&
                (inst.function == MMI_MMI0 || inst.function == MMI_MMI1 ||
                 inst.function == MMI_MMI2 || inst.function == MMI_MMI3))
            {
                return true;
            }
        }

        return false;
    }

    bool ElfAnalyzer::hasSelfModifyingSignalForHeuristics(const std::vector<Instruction> &instructions,
                                                          const std::vector<Section> &sections)
    {
        for (size_t i = 0; i < instructions.size(); i++)
        {
            const auto &inst = instructions[i];
            if (!(inst.opcode == OPCODE_SW || inst.opcode == OPCODE_SH ||
                  inst.opcode == OPCODE_SB || inst.opcode == OPCODE_SQ))
            {
                continue;
            }

            uint32_t baseAddr = 0;
            for (int j = static_cast<int>(i) - 1; j >= 0 && j >= static_cast<int>(i) - 5; j--)
            {
                const auto &prevInst = instructions[static_cast<size_t>(j)];
                if (prevInst.opcode == OPCODE_LUI && prevInst.rt == inst.rs)
                {
                    baseAddr = prevInst.immediate << 16;
                    break;
                }
            }

            if (baseAddr == 0)
            {
                continue;
            }

            const uint32_t targetAddr = baseAddr + static_cast<int16_t>(inst.immediate);
            for (const auto &section : sections)
            {
                if (section.isCode &&
                    targetAddr >= section.address &&
                    targetAddr < section.address + section.size)
                {
                    return true;
                }
            }
        }

        return false;
    }

    bool ElfAnalyzer::shouldSkipForPatchDensityForHeuristics(const std::string &functionName,
                                                             uint32_t functionSizeBytes,
                                                             size_t patchCount,
                                                             bool isLibraryFunction)
    {
        if (patchCount <= 5 || functionSizeBytes < 4)
        {
            return false;
        }

        const double instructionCount = static_cast<double>(functionSizeBytes) / 4.0;
        if (instructionCount <= 0.0)
        {
            return false;
        }

        const double density = static_cast<double>(patchCount) / instructionCount;
        if (density <= 0.2)
        {
            return false;
        }

        if (isLibraryFunction || isDoNotSkipOrStub(functionName))
        {
            return false;
        }

        return shouldAutoSkipNameForHeuristics(functionName);
    }

    std::vector<Instruction> ElfAnalyzer::decodeFunction(const Function &function) const
    {
        std::vector<Instruction> instructions;

        for (uint32_t addr = function.start; addr < function.end; addr += 4)
        {
            uint32_t rawInstruction = 0;
            if (!tryReadWord(m_elfParser.get(), addr, rawInstruction))
            {
                continue;
            }

            try
            {
                Instruction inst = m_decoder->decodeInstruction(addr, rawInstruction);
                instructions.push_back(inst);
            }
            catch (const std::exception &e)
            {
                std::cerr << "Error decoding instruction at " << formatAddress(addr)
                          << ": " << e.what() << std::endl;
            }
        }

        return instructions;
    }

    std::string ElfAnalyzer::formatAddress(uint32_t address) const
    {
        std::stringstream ss;
        ss << "0x" << std::hex << std::setw(8) << std::setfill('0') << address;
        return ss.str();
    }

    bool ElfAnalyzer::hasMMIInstructions(const Function &function) const
    {
        std::vector<Instruction> instructions = decodeFunction(function);

        for (const auto &inst : instructions)
        {
            if (inst.isMMI || inst.opcode == OPCODE_MMI)
            {
                return true;
            }
        }

        return false;
    }

    bool ElfAnalyzer::hasVUInstructions(const Function &function) const
    {
        std::vector<Instruction> instructions = decodeFunction(function);

        for (const auto &inst : instructions)
        {
            if (inst.isVU || inst.opcode == OPCODE_COP2)
            {
                return true;
            }
        }

        return false;
    }

    bool ElfAnalyzer::shouldAutoSkipByHeuristic(const Function &function) const
    {
        if (m_forceRecompileStarts.contains(function.start))
        {
            return false;
        }
        return shouldAutoSkipNameForHeuristics(function.name);
    }

    bool ElfAnalyzer::identifyFunctionType(const Function &function)
    {
        if (isDoNotSkipOrStub(function.name))
        {
            return false;
        }
        if (hasPs2ApiPrefix(function.name))
        {
            return false;
        }

        std::vector<Instruction> instructions = decodeFunction(function);

        const bool hasHardwareIO = hasHardwareIOSignalForHeuristics(instructions);
        const bool hasLargeComplexMMI = hasLargeComplexMMISignalForHeuristics(instructions);

        if (hasHardwareIO)
        {
            if (shouldAutoSkipByHeuristic(function))
            {
                m_skipFunctions.insert(function.name);
                std::cout << "Skipping function " << function.name << " due to hardware I/O" << std::endl;
                return true;
            }

            std::cout << "Keeping function " << function.name
                      << " despite hardware I/O (reliable game symbol)" << std::endl;
        }

        if (hasLargeComplexMMI)
        {
            if (shouldAutoSkipByHeuristic(function))
            {
                m_skipFunctions.insert(function.name);
                std::cout << "Skipping large function " << function.name << " with complex MMI" << std::endl;
                return true;
            }

            std::cout << "Keeping large function " << function.name
                      << " with complex MMI (reliable game symbol)" << std::endl;
        }

        return false;
    }

    void ElfAnalyzer::categorizeFunction(Function &function)
    {
        identifyFunctionType(function);

        if (isSelfModifyingCode(function))
        {
            std::cout << "Function " << function.name << " contains self-modifying code" << std::endl;
            if (!isLibraryFunction(function.name) &&
                !isDoNotSkipOrStub(function.name) &&
                shouldAutoSkipByHeuristic(function))
            {
                m_skipFunctions.insert(function.name);
            }
        }

        if (isLoopHeavyFunction(function))
        {
            std::cout << "Function " << function.name << " is loop-heavy, may need optimization" << std::endl;
        }
    }

    bool ElfAnalyzer::isSelfModifyingCode(const Function &function) const
    {
        std::vector<Instruction> instructions = decodeFunction(function);
        return hasSelfModifyingSignalForHeuristics(instructions, m_sections);
    }

    bool ElfAnalyzer::isLoopHeavyFunction(const Function &function) const
    {
        std::vector<Instruction> instructions = decodeFunction(function);
        int loopCount = 0;

        for (const auto &inst : instructions)
        {
            if (inst.isBranch)
            {
                int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
                if (offset < 0)
                {
                    loopCount++;
                }
            }
        }

        // Consider it loop-heavy if it has more than 5 loops
        return loopCount > 5;
    }

    uint32_t ElfAnalyzer::getSuccessor(const Instruction &inst, uint32_t currentAddr)
    {
        if (inst.isBranch)
        {
            int32_t offset = static_cast<int16_t>(inst.immediate) << 2;
            return currentAddr + 4 + offset;
        }

        if (inst.opcode == OPCODE_J || inst.opcode == OPCODE_JAL)
        {
            return decodeAbsoluteJumpTarget(currentAddr, inst.target);
        }

        return currentAddr + 4;
    }

    static uint32_t decodeAbsoluteJumpTarget(uint32_t instructionAddress, uint32_t targetField)
    {
        return ((instructionAddress + 4) & 0xF0000000u) | (targetField << 2);
    }

    static bool tryReadWord(const ElfParser *parser, uint32_t address, uint32_t &outWord)
    {
        if (parser == nullptr)
        {
            return false;
        }

        if (address > (std::numeric_limits<uint32_t>::max() - 3))
        {
            return false;
        }

        if (!parser->isValidAddress(address) || !parser->isValidAddress(address + 3))
        {
            return false;
        }

        try
        {
            outWord = parser->readWord(address);
            return true;
        }
        catch (const std::exception &)
        {
            return false;
        }
    }
}
