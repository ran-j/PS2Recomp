#include "ps2recomp/elf_analyzer.h"
#include <iostream>
#include <sstream>
#include <algorithm>
#include <filesystem>

namespace fs = std::filesystem;

namespace ps2recomp
{
    ElfAnalyzer::ElfAnalyzer(const std::string &elfPath)
        : m_elfPath(elfPath)
    {
        m_elfParser = std::make_unique<ElfParser>(elfPath);
        m_decoder = std::make_unique<R5900Decoder>();

        initializeLibraryFunctions();
    }

    ElfAnalyzer::~ElfAnalyzer() = default;

    bool ElfAnalyzer::analyze()
    {
        std::cout << "Analyzing ELF file: " << m_elfPath << std::endl;

        if (!m_elfParser->parse())
        {
            std::cerr << "Failed to parse ELF file" << std::endl;
            return false;
        }

        m_functions = m_elfParser->extractFunctions();
        m_symbols = m_elfParser->extractSymbols();
        m_sections = m_elfParser->getSections();
        m_relocations = m_elfParser->getRelocations();

        std::cout << "Extracted " << m_functions.size() << " functions" << std::endl;
        std::cout << "Extracted " << m_symbols.size() << " symbols" << std::endl;
        std::cout << "Extracted " << m_sections.size() << " sections" << std::endl;
        std::cout << "Extracted " << m_relocations.size() << " relocations" << std::endl;

        analyzeEntryPoint();
        analyzeLibraryFunctions();
        analyzeCallGraph();
        analyzeDataUsage();
        identifyPotentialPatches();

        std::cout << "Analysis completed" << std::endl;
        std::cout << "- " << m_libFunctions.size() << " library functions to stub" << std::endl;
        std::cout << "- " << m_skipFunctions.size() << " functions to skip" << std::endl;
        std::cout << "- " << m_patches.size() << " potential patches identified" << std::endl;

        return true;
    }

    bool ElfAnalyzer::generateToml(const std::string &outputPath)
    {
        std::ofstream file(outputPath);
        if (!file)
        {
            std::cerr << "Failed to open output file: " << outputPath << std::endl;
            return false;
        }

        fs::path elfPathObj(m_elfPath);
        std::string elfFileName = elfPathObj.filename().string();

        fs::path outputPathObj(outputPath);
        fs::path outputDir = outputPathObj.parent_path();
        std::string outputDirStr = outputDir.string() + "\\output\\";

        file << "# PS2Recomp configuration for: " << elfFileName << "\n";
        file << "# Generated by ElfAnalyzer\n\n";

        file << "[general]\n";
        file << "# Path to input ELF file\n";
        file << "input = \"" << escapeBackslashes(m_elfPath) << "\"\n\n";

        file << "# Path to output directory\n";
        file << "output = \"" << escapeBackslashes(outputDirStr) << "\"\n\n";

        file << "# Single file output mode (false for one file per function)\n";
        file << "single_file_output = false\n\n";

        file << "# Functions to stub (these will generate empty implementations)\n";
        file << "stubs = [\n";
        for (const auto &func : m_libFunctions)
        {
            file << "  \"" << func << "\",\n";
        }
        file << "]\n\n";

        file << "# Functions to skip (these will not be recompiled)\n";
        file << "skip = [\n";
        for (const auto &func : m_skipFunctions)
        {
            file << "  \"" << func << "\",\n";
        }
        file << "]\n\n";

        if (!m_patches.empty())
        {
            file << "# Patches to apply during recompilation\n";
            file << "[patches]\n";
            file << "# Individual instruction patches\n";
            file << "instructions = [\n";
            for (const auto &[address, value] : m_patches)
            {
                file << "  { address = \"0x" << std::hex << address << "\", value = \"0x"
                     << std::hex << value << "\" },  # Identified potential patch\n";
            }
            file << "]\n\n";
        }

        // file << "# Function hook patches\n";
        // file << "#[[patches.hook]]\n";
        // file << "#function = \"printf\"\n";
        // file << "#code = '''\n";
        // file << "#// Custom printf implementation\n";
        // file << "#void printf(uint8_t* rdram, R5900Context* ctx) {\n";
        // file << "#    // Implementation here\n";
        // file << "#}\n";
        // file << "#'''\n\n";

        std::cout << "Generated TOML configuration: " << outputPath << std::endl;
        return true;
    }

    void ElfAnalyzer::initializeLibraryFunctions()
    {
        // Standard C library functions
        const std::vector<std::string> stdLibFuncs = {
            "printf", "sprintf", "snprintf", "fprintf", "vprintf", "vfprintf",
            "malloc", "free", "calloc", "realloc",
            "memcpy", "memset", "memmove", "memcmp",
            "strcpy", "strncpy", "strcat", "strncat",
            "strcmp", "strncmp", "strlen", "strstr",
            "fopen", "fclose", "fread", "fwrite", "fseek",
            "atoi", "atof", "rand", "srand"};

        // PS2-specific system functions
        const std::vector<std::string> ps2SysFuncs = {
            "FlushCache", "EI", "DI", "SYNC",
            "syscall", "ResetEE", "SetGsCrt", "Exit",
            "LoadExecPS2", "ExecPS2", "GetThreadId",
            "RFU009", "InitRCnt", "GetOsTick", "ResetRCnt",
            "DisableFPUExceptions", "EnableFPUExceptions"};

        // PS2-specific library functions
        const std::vector<std::string> ps2LibFuncs = {
            // GS
            "GsSetCrt", "GsGetIMR", "GsPutIMR", "GsSetIMR",
            "GsInit", "GsSyncV", "GsGetVideoMode", "GsSetVideoMode",

            // Pad
            "PadInit", "PadPortOpen", "PadGetState", "PadRead",
            "PadPortClose", "PadSetActAlign", "PadSetActDirect",

            // SIF
            "SifInitRpc", "SifExitRpc", "SifBindRpc", "SifCallRpc",
            "SifRegisterRpc", "SifCheckStatRpc", "SifSetRpcQueue",
            "SifRpcLoop", "SifGetOtherData",

            // IPU
            "sceSifAddCmdHandler", "sceSifRemoveCmdHandler", "sceSifSendCmd",
            "sceSifInitCmd", "sceSifExitCmd", "sceSifSetCmdBuffer"};

        // Add all to our library functions set
        m_libFunctions.insert(stdLibFuncs.begin(), stdLibFuncs.end());
        m_libFunctions.insert(ps2SysFuncs.begin(), ps2SysFuncs.end());
        m_libFunctions.insert(ps2LibFuncs.begin(), ps2LibFuncs.end());
    }

    void ElfAnalyzer::analyzeEntryPoint()
    {
        auto it = std::find_if(m_functions.begin(), m_functions.end(),
                               [](const Function &f)
                               { return f.name == "entry" || f.name == "_start"; });

        if (it != m_functions.end())
        {
            std::cout << "Found entry point: " << it->name << " at 0x" << std::hex << it->start << std::dec << std::endl;

            m_skipFunctions.insert(it->name);
            decodeFunction(*it);
        }
        else
        {
            std::cout << "Entry point not found" << std::endl;
        }
    }

    void ElfAnalyzer::analyzeLibraryFunctions()
    {
        for (const auto &symbol : m_symbols)
        {
            if (symbol.isFunction)
            {
                if (isLibraryFunction(symbol.name))
                {
                    m_libFunctions.insert(symbol.name);
                }

                if (isSystemFunction(symbol.name))
                {
                    m_skipFunctions.insert(symbol.name);
                }
            }
        }
    }

    void ElfAnalyzer::analyzeCallGraph()
    {
        // functions called by the entry point are likely initialization and should be skipped
        for (const auto &func : m_functions)
        {
            if (func.name.find("init") != std::string::npos ||
                func.name.find("Init") != std::string::npos ||
                func.name.find("start") != std::string::npos ||
                func.name.find("Start") != std::string::npos)
            {

                m_skipFunctions.insert(func.name);
            }
        }
    }

    void ElfAnalyzer::analyzeDataUsage()
    {
        // TODO
    }

    void ElfAnalyzer::identifyPotentialPatches()
    {
        // This is a very basic implementation that looks for potentially problematic instructions

        for (const auto &func : m_functions)
        {
            if (m_skipFunctions.find(func.name) != m_skipFunctions.end())
            {
                continue; // Skip functions that we're going to skip anyway
            }

            // Decode the function
            decodeFunction(func);
        }

        // Example: If we find syscall instructions, suggest patching them to NOP
        for (uint32_t addr = 0x100000; addr < 0x101000; addr += 4)
        {
            if (m_elfParser->isValidAddress(addr))
            {
                uint32_t instr = m_elfParser->readWord(addr);
                if ((instr & 0xFC00003F) == 0x0000000C)
                {                                 // syscall instruction
                    m_patches[addr] = 0x00000000; // NOP
                }
            }
        }
    }

    std::string ElfAnalyzer::escapeBackslashes(const std::string &path)
    {
        std::string result;
        for (char ch : path)
        {
            if (ch == '\\')
                result.append("\\\\");
            else
                result.push_back(ch);
        }
        return result;
    }

    bool ElfAnalyzer::isSystemFunction(const std::string &name) const
    {
        static const std::unordered_set<std::string> systemFuncs = {
            "entry", "_start", "_init", "_fini",
            "abort", "exit", "_exit",
            "_profiler_start", "_profiler_stop"};

        return systemFuncs.find(name) != systemFuncs.end();
    }

    bool ElfAnalyzer::isLibraryFunction(const std::string &name) const
    {
        if (name.empty())
            return false;

        if (name[0] == '_' && name.size() > 1 && std::isalpha(name[1]))
        {
            return true; // Many library functions start with underscore
        }

        // Check for common prefixes by Claude
        const std::vector<std::string> libraryPrefixes = {
            "sce", "Sce", "SCE", // Sony prefixes
            "sif", "Sif", "SIF", // SIF functions
            "pad", "Pad", "PAD", // Pad functions
            "gs", "Gs", "GS",    // Graphics Synthesizer
            "dma", "Dma", "DMA", // DMA functions
            "iop", "Iop", "IOP"  // IOP functions
        };

        for (const auto &prefix : libraryPrefixes)
        {
            if (name.rfind(prefix, 0) == 0)
            {
                return true;
            }
        }

        return false;
    }

    void ElfAnalyzer::decodeFunction(const Function &function)
    {
        for (uint32_t addr = function.start; addr < function.end; addr += 4)
        {
            if (!m_elfParser->isValidAddress(addr))
            {
                continue;
            }
            
            uint32_t rawInstruction = m_elfParser->readWord(addr);

            try
            {
                Instruction inst = m_decoder->decodeInstruction(addr, rawInstruction);

                // TODO Analyze instructions for potential issues

                // Example: Look for syscalls that might need to be patched
                if (inst.opcode == 0 && inst.function == 0xC)
                { // syscall
                    std::cout << "Found syscall at " << formatAddress(addr) << std::endl;
                }
            }
            catch (const std::exception &e)
            {
                std::cerr << "Error decoding instruction at " << formatAddress(addr)
                          << ": " << e.what() << std::endl;
            }
        }
    }

    std::string ElfAnalyzer::formatAddress(uint32_t address) const
    {
        std::stringstream ss;
        ss << "0x" << std::hex << std::setw(8) << std::setfill('0') << address;
        return ss.str();
    }

}