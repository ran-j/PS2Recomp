// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_1d0058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0058) {
        switch (ctx->pc) {
            case 0x1d0060: ctx->pc = 0; goto label_1d0060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0058: 0x1000000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D008C; return;
    }
label_1d0060:
    // 0x1d0060: 0x8e2423a8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9128)));
    // 0x1d0064: 0x10800005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D007C; return;
    }
    // 0x1d006c: 0xc05a8c8
    SET_GPR_U32(ctx, 31, 0x1d0074);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 160));
    FUN_0016a320(rdram, ctx, runtime); return;
}


// Function: entry_1d0074
// Address: 0x1d0074 - 0x1d0088

void entry_1d0074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0074) {
        switch (ctx->pc) {
            case 0x1d007c: ctx->pc = 0; goto label_1d007c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0074: 0x10000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D008C; return;
    }
label_1d007c:
    // 0x1d007c: 0x8e2423b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9136)));
    // 0x1d0080: 0xc05aa44
    SET_GPR_U32(ctx, 31, 0x1d0088);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 160));
    GetHbskClosestHidePos__FP4HBSKP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_1d0088
// Address: 0x1d0088 - 0x1d0144

void entry_1d0088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0088) {
        switch (ctx->pc) {
            case 0x1d008c: ctx->pc = 0; goto label_1d008c;
            case 0x1d00cc: ctx->pc = 0; goto label_1d00cc;
            case 0x1d00fc: ctx->pc = 0; goto label_1d00fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0088: 0x8e22239c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
label_1d008c:
    // 0x1d008c: 0x5440000f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 2944)));
        goto label_1d00cc;
    }
    // 0x1d0094: 0x8e222230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
    // 0x1d0098: 0xda210ab0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 2736)));
    // 0x1d009c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d00a0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d00a4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d00a8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d00ac: 0xc4410018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1d00b0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d00b4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d00b8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d00bc: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d00c0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d00c4: 0x1000000d
    ctx->f[22] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d00fc;
    }
label_1d00cc:
    // 0x1d00cc: 0x8e222230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
    // 0x1d00d0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d00d4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d00d8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d00dc: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d00e0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d00e4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d00e8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d00ec: 0xc4410018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1d00f0: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d00f4: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d00f8: 0x46010582
    ctx->f[22] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
label_1d00fc:
    // 0x1d00fc: 0xc6200108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 264)); ctx->f[0] = *(float*)&val; }
    // 0x1d0100: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d0104: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d0108: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d010c: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x1d0110: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1d0114: 0xc4604e48
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20040)); ctx->f[0] = *(float*)&val; }
    // 0x1d0118: 0x27a80010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d011c: 0xc44c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1d0120: 0x100302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1d0124: 0x7a240100
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x1d0128: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1d012c: 0x7ba50000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d0130: 0x100a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1d0134: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x1d0138: 0xe7b60010
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x1d013c: 0xc07aa06
    SET_GPR_U32(ctx, 31, 0x1d0144);
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 0));
    PosSmooth(rdram, ctx, runtime); return;
}


// Function: entry_1d0144
// Address: 0x1d0144 - 0x1d0190

void entry_1d0144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0144) {
        switch (ctx->pc) {
            case 0x1d0164: ctx->pc = 0; goto label_1d0164;
            case 0x1d0174: ctx->pc = 0; goto label_1d0174;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0144: 0x8e23239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x1d0148: 0x14600006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1d0164;
    }
    // 0x1d0150: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x1d0154: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1d0158: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d015c: 0x10000005
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d0174;
    }
label_1d0164:
    // 0x1d0164: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x1d0168: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1d016c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d0170: 0x46000b01
    ctx->f[12] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
label_1d0174:
    // 0x1d0174: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d0178: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1d017c: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d0180: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1d0184: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1d0188: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1d0190);
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1d0190
// Address: 0x1d0190 - 0x1d01a4

void entry_1d0190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0190: 0xc62c0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[12] = *(float*)&val; }
    // 0x1d0194: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1d0198: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d019c: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1d01a4);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1d01a4
// Address: 0x1d01a4 - 0x1d0290

void entry_1d01a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d01a4) {
        switch (ctx->pc) {
            case 0x1d01fc: ctx->pc = 0; goto label_1d01fc;
            case 0x1d0228: ctx->pc = 0; goto label_1d0228;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d01a4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d01a8: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d01ac: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d01b0: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d01b4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d01b8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d01bc: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d01c0: 0xc4414e50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20048)); ctx->f[1] = *(float*)&val; }
    // 0x1d01c4: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d01c8: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1d01cc: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1d01d0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d01d4: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1d01d8: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d01dc: 0x0
    // NOP
    // 0x1d01e0: 0x45010006
    ctx->f[3] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d01fc;
    }
    // 0x1d01e8: 0x4601a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d01ec: 0x0
    // NOP
    // 0x1d01f0: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d01fc;
    }
    // 0x1d01f8: 0x4600a8c6
    ctx->f[3] = FPU_MOV_S(ctx->f[21]);
label_1d01fc:
    // 0x1d01fc: 0xc6200634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[0] = *(float*)&val; }
    // 0x1d0200: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1d0204: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1d0208: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1d020c: 0x460018c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1d0210: 0x46001845
    ctx->f[1] = FPU_ABS_S(ctx->f[3]);
    // 0x1d0214: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0218: 0x0
    // NOP
    // 0x1d021c: 0x45000002
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d0228;
    }
    // 0x1d0224: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
label_1d0228:
    // 0x1d0228: 0x4616b082
    ctx->f[2] = FPU_MUL_S(ctx->f[22], ctx->f[22]);
    // 0x1d022c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d0230: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d0234: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d0238: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d023c: 0x46161d42
    ctx->f[21] = FPU_MUL_S(ctx->f[3], ctx->f[22]);
    // 0x1d0240: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d0244: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d0248: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1d024c: 0x46020044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x1d0250: 0x8e2223a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9120)));
    // 0x1d0254: 0x10400026
    ctx->f[21] = std::min(ctx->f[1], ctx->f[21]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D02F0; return;
    }
    // 0x1d025c: 0x8c420034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1d0260: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d0264: 0x14600023
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D02F4; return;
    }
    // 0x1d026c: 0x26101858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6232));
    // 0x1d0270: 0x3c0141f0
    SET_GPR_U32(ctx, 1, ((uint32_t)16880 << 16));
    // 0x1d0274: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1d0278: 0xc62c23a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9124)); ctx->f[12] = *(float*)&val; }
    // 0x1d027c: 0x27a500a4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 164));
    // 0x1d0280: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1d0284: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1d0288: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d0290);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d0290
// Address: 0x1d0290 - 0x1d02c4

void entry_1d0290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0290: 0x8e2223a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9120)));
    // 0x1d0294: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d0298: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1d029c: 0x27a500a8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 168));
    // 0x1d02a0: 0x8c430034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1d02a4: 0xc62c23a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9124)); ctx->f[12] = *(float*)&val; }
    // 0x1d02a8: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x1d02ac: 0x8c660014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x1d02b0: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1d02b4: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1d02b8: 0xc44dfffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[13] = *(float*)&val; }
    // 0x1d02bc: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d02c4);
    ctx->f[13] = FPU_SUB_S(ctx->f[13], ctx->f[20]);
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d02c4
// Address: 0x1d02c4 - 0x1d03f8

void entry_1d02c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d02c4) {
        switch (ctx->pc) {
            case 0x1d02f0: ctx->pc = 0; goto label_1d02f0;
            case 0x1d02f4: ctx->pc = 0; goto label_1d02f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d02c4: 0xc7a000a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 164)); ctx->f[0] = *(float*)&val; }
    // 0x1d02c8: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d02cc: 0x0
    // NOP
    // 0x1d02d0: 0x45010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[1] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d02f4;
    }
    // 0x1d02d8: 0x46150834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d02dc: 0x0
    // NOP
    // 0x1d02e0: 0x45000004
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d02f4;
    }
    // 0x1d02e8: 0x10000002
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d02f4;
    }
label_1d02f0:
    // 0x1d02f0: 0x4600a806
    ctx->f[0] = FPU_MOV_S(ctx->f[21]);
label_1d02f4:
    // 0x1d02f4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d02f8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d02fc: 0x48a23800
    ctx->vu0_vf[7] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d0300: 0xdba40030
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d0304: 0x4be72118
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[7]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1d0308: 0x26220660
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1632));
    // 0x1d030c: 0xfba40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d0310: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1d0314: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1d0318: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d031c: 0xdbac0020
    ctx->vu0_vf[12] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d0320: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1d0324: 0x4be46128
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[12] = _mm_blendv_ps(ctx->vu0_vf[12], res, _mm_castsi128_ps(mask)); }
    // 0x1d0328: 0xd8450020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1d032c: 0xda210660
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1632)));
    // 0x1d0330: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d0334: 0x4be40aaa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d0338: 0x4be002d3
    // Unhandled VU0 Special1 function: 0x13
    // 0x1d033c: 0x4be4126a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d0340: 0x4be42a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1d0344: 0x4b0a503d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); }
    // 0x1d0348: 0x4b0a58ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[10], ctx->vu0_vf[10], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[11] = _mm_blendv_ps(ctx->vu0_vf[11], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d034c: 0x4a89483c
    ctx->vu0_i = (float)ctx->vi[9];
    // 0x1d0350: 0x4a8958ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[9], ctx->vu0_vf[9], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[11] = _mm_blendv_ps(ctx->vu0_vf[11], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d0354: 0x4a48403c
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x1d0358: 0x4a4858c9
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[11] = _mm_blendv_ps(ctx->vu0_vf[11], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d035c: 0x48a23000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d0360: 0xc4614e4c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20044)); ctx->f[1] = *(float*)&val; }
    // 0x1d0364: 0x4be618d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d0368: 0xfba70060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1d036c: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d0370: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d0374: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d0378: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d037c: 0xfba60060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1d0380: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d0384: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d0388: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d038c: 0xfa230640
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d0390: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d0394: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d0398: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d039c: 0x0
    // NOP
    // 0x1d03a0: 0x4502002b
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_NEG_S(ctx->f[1]);
        ctx->pc = 0x1D0450; return;
    }
    // 0x1d03a8: 0x8e22239c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x1d03ac: 0x14400047
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 17));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1d04cc(rdram, ctx, runtime); return;
    }
    // 0x1d03b4: 0x4bcc606a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[12]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[12] = _mm_blendv_ps(ctx->vu0_vf[12], res, _mm_castsi128_ps(mask)); }
    // 0x1d03b8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d03bc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d03c0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d03c4: 0x3c014234
    SET_GPR_U32(ctx, 1, ((uint32_t)16948 << 16));
    // 0x1d03c8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d03cc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d03d0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d03d4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d03d8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d03dc: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d03e0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d03e4: 0x0
    // NOP
    // 0x1d03e8: 0x45000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D0400; return;
    }
    // 0x1d03f0: 0xc074480
    SET_GPR_U32(ctx, 31, 0x1d03f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetJtHfdk__FP2JT4HFDK(rdram, ctx, runtime); return;
}


// Function: entry_1d03f8
// Address: 0x1d03f8 - 0x1d0420

void entry_1d03f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d03f8) {
        switch (ctx->pc) {
            case 0x1d0400: ctx->pc = 0; goto label_1d0400;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d03f8: 0x10000035
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D04D0; return;
    }
label_1d0400:
    // 0x1d0400: 0xc6210644
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1604)); ctx->f[1] = *(float*)&val; }
    // 0x1d0404: 0x3c0141a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16800 << 16));
    // 0x1d0408: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d040c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0410: 0x45000005
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D0428; return;
    }
    // 0x1d0418: 0xc074480
    SET_GPR_U32(ctx, 31, 0x1d0420);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJtHfdk__FP2JT4HFDK(rdram, ctx, runtime); return;
}


// Function: entry_1d0420
// Address: 0x1d0420 - 0x1d0448

void entry_1d0420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0420) {
        switch (ctx->pc) {
            case 0x1d0428: ctx->pc = 0; goto label_1d0428;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0420: 0x1000002b
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D04D0; return;
    }
label_1d0428:
    // 0x1d0428: 0x3c01c1a0
    SET_GPR_U32(ctx, 1, ((uint32_t)49568 << 16));
    // 0x1d042c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d0430: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0434: 0x0
    // NOP
    // 0x1d0438: 0x45000024
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1d04cc(rdram, ctx, runtime); return;
    }
    // 0x1d0440: 0xc074480
    SET_GPR_U32(ctx, 31, 0x1d0448);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetJtHfdk__FP2JT4HFDK(rdram, ctx, runtime); return;
}


// Function: entry_1d0448
// Address: 0x1d0448 - 0x1d04cc

void entry_1d0448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0448) {
        switch (ctx->pc) {
            case 0x1d0450: ctx->pc = 0; goto label_1d0450;
            case 0x1d0488: ctx->pc = 0; goto label_1d0488;
            case 0x1d04b8: ctx->pc = 0; goto label_1d04b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0448: 0x10000021
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D04D0; return;
    }
label_1d0450:
    // 0x1d0450: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0454: 0x0
    // NOP
    // 0x1d0458: 0x4500000b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d0488;
    }
    // 0x1d0460: 0x8e2323a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9120)));
    // 0x1d0464: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x1d0468: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1d046c: 0x10400006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 19));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d0488;
    }
    // 0x1d0474: 0x8e23239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x1d0478: 0x24100012
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 18));
    // 0x1d047c: 0x43800a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 2));
    // 0x1d0480: 0x1000000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d04b8;
    }
label_1d0488:
    // 0x1d0488: 0xc4804e4c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 20044)); ctx->f[0] = *(float*)&val; }
    // 0x1d048c: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0490: 0x0
    // NOP
    // 0x1d0494: 0x45000008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d04b8;
    }
    // 0x1d049c: 0x8e2323a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9120)));
    // 0x1d04a0: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x1d04a4: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1d04a8: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 18));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d04b8;
    }
    // 0x1d04b0: 0x24100013
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 19));
    // 0x1d04b4: 0x44800a
    if (GPR_U32(ctx, 4) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 2));
label_1d04b8:
    // 0x1d04b8: 0x14800005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D04D0; return;
    }
    // 0x1d04c0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d04c4: 0xc074480
    SET_GPR_U32(ctx, 31, 0x1d04cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetJtHfdk__FP2JT4HFDK(rdram, ctx, runtime); return;
}


// Function: entry_1d04cc
// Address: 0x1d04cc - 0x1d04ec

void entry_1d04cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d04cc) {
        switch (ctx->pc) {
            case 0x1d04d0: ctx->pc = 0; goto label_1d04d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d04cc: 0xc7a000a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[0] = *(float*)&val; }
label_1d04d0:
    // 0x1d04d0: 0x24030015
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 21));
    // 0x1d04d4: 0x8e222228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x1d04d8: 0x1443017e
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1D0AD4; return;
    }
    // 0x1d04e0: 0xc62c00d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 212)); ctx->f[12] = *(float*)&val; }
    // 0x1d04e4: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1d04ec);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 208)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1d04ec
// Address: 0x1d04ec - 0x1d04f8

void entry_1d04ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d04ec: 0xc62c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1d04f0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1d04f8);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1d04f8
// Address: 0x1d04f8 - 0x1d0560

void entry_1d04f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d04f8) {
        switch (ctx->pc) {
            case 0x1d0534: ctx->pc = 0; goto label_1d0534;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d04f8: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1d04fc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d0500: 0xc4414e54
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20052)); ctx->f[1] = *(float*)&val; }
    // 0x1d0504: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0508: 0x0
    // NOP
    // 0x1d050c: 0x45030171
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 21));
        ctx->pc = 0x1D0AD4; return;
    }
    // 0x1d0514: 0x10000170
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0AD8; return;
    }
    // 0x1d051c: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x1d0520: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1d0524: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d0534;
    }
    // 0x1d052c: 0x1462016a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D0AD8; return;
    }
label_1d0534:
    // 0x1d0534: 0xc62d0634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[13] = *(float*)&val; }
    // 0x1d0538: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d053c: 0x460d0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0540: 0x0
    // NOP
    // 0x1d0544: 0x45000008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 20));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D0568; return;
    }
    // 0x1d054c: 0xc62c0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[12] = *(float*)&val; }
    // 0x1d0550: 0x8e260e20
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 3616)));
    // 0x1d0554: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d0558: 0xc075028
    SET_GPR_U32(ctx, 31, 0x1d0560);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 3136));
    SetStepRunTarget__FP4STEPffP5BLRUNP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_1d0560
// Address: 0x1d0560 - 0x1d057c

void entry_1d0560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0560) {
        switch (ctx->pc) {
            case 0x1d0568: ctx->pc = 0; goto label_1d0568;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0560: 0x1000015d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0AD8; return;
    }
label_1d0568:
    // 0x1d0568: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d056c: 0x10000158
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0AD0; return;
    }
    // 0x1d0574: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1d057c);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d057c
// Address: 0x1d057c - 0x1d05c0

void entry_1d057c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d057c: 0x30422000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8192));
    // 0x1d0580: 0x10400014
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D05D4; return;
    }
    // 0x1d0588: 0xc6210634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[1] = *(float*)&val; }
    // 0x1d058c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d0590: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0594: 0x0
    // NOP
    // 0x1d0598: 0x4500000b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D05C8; return;
    }
    // 0x1d05a0: 0xc62c0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[12] = *(float*)&val; }
    // 0x1d05a4: 0xc44d4e58
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20056)); ctx->f[13] = *(float*)&val; }
    // 0x1d05a8: 0x24100014
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1d05ac: 0x8e260900
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 2304)));
    // 0x1d05b0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d05b4: 0x460d0b42
    ctx->f[13] = FPU_MUL_S(ctx->f[1], ctx->f[13]);
    // 0x1d05b8: 0xc075028
    SET_GPR_U32(ctx, 31, 0x1d05c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1824));
    SetStepRunTarget__FP4STEPffP5BLRUNP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_1d05c0
// Address: 0x1d05c0 - 0x1d0614

void entry_1d05c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d05c0) {
        switch (ctx->pc) {
            case 0x1d05c8: ctx->pc = 0; goto label_1d05c8;
            case 0x1d05d4: ctx->pc = 0; goto label_1d05d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d05c0: 0x10000145
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0AD8; return;
    }
label_1d05c8:
    // 0x1d05c8: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d05cc: 0x10000140
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0AD0; return;
    }
label_1d05d4:
    // 0x1d05d4: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d05d8: 0x1000013d
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0AD0; return;
    }
    // 0x1d05e0: 0xc6200630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[0] = *(float*)&val; }
    // 0x1d05e4: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d05e8: 0xfa210640
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d05ec: 0x10000139
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0AD4; return;
    }
    // 0x1d05f4: 0x8e3523bc
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 17), 9148)));
    // 0x1d05f8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d05fc: 0x8e2606d4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1748)));
    // 0x1d0600: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d0604: 0x8eb20018
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 21), 24)));
    // 0x1d0608: 0x8eb30034
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 21), 52)));
    // 0x1d060c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d0614);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d0614
// Address: 0x1d0614 - 0x1d064c

void entry_1d0614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0614: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1d0618: 0x27b40010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d061c: 0x8c42002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 44)));
    // 0x1d0620: 0x1040000a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d064c(rdram, ctx, runtime); return;
    }
    // 0x1d0628: 0xc62c23c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9152)); ctx->f[12] = *(float*)&val; }
    // 0x1d062c: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d0630: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d0634: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d0638: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d063c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d0640: 0x262923c0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 9152));
    // 0x1d0644: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d064c);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 17), 9156));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d064c
// Address: 0x1d064c - 0x1d0660

void entry_1d064c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d064c: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d0650: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d0654: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d0658: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d0660);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d0660
// Address: 0x1d0660 - 0x1d0674

void entry_1d0660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0660: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d0664: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d0668: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d066c: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1d0674);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d0674
// Address: 0x1d0674 - 0x1d0748

void entry_1d0674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0674) {
        switch (ctx->pc) {
            case 0x1d06cc: ctx->pc = 0; goto label_1d06cc;
            case 0x1d06d4: ctx->pc = 0; goto label_1d06d4;
            case 0x1d072c: ctx->pc = 0; goto label_1d072c;
            case 0x1d0738: ctx->pc = 0; goto label_1d0738;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0674: 0x8ea20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 64)));
    // 0x1d0678: 0x50400016
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 0));
        goto label_1d06d4;
    }
    // 0x1d0680: 0x8e620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x1d0684: 0x54400013
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 0));
        goto label_1d06d4;
    }
    // 0x1d068c: 0xc62123c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9152)); ctx->f[1] = *(float*)&val; }
    // 0x1d0690: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d0694: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0698: 0x0
    // NOP
    // 0x1d069c: 0x4503000b
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 2));
        goto label_1d06cc;
    }
    // 0x1d06a4: 0x8e62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 12)));
    // 0x1d06a8: 0x8e630010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1d06ac: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1d06b0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1d06b4: 0xc440fffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[0] = *(float*)&val; }
    // 0x1d06b8: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d06bc: 0x0
    // NOP
    // 0x1d06c0: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 0));
        goto label_1d06d4;
    }
    // 0x1d06c8: 0x241e0002
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 2));
label_1d06cc:
    // 0x1d06cc: 0x10000101
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0AD4; return;
    }
label_1d06d4:
    // 0x1d06d4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d06d8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1d06dc: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1d06e0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d06e4: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d06e8: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d06ec: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1d06f0: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d06f4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d06f8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d06fc: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d0700: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d0704: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d0708: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d070c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d0710: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d0714: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d0718: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d071c: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d072c;
    }
    // 0x1d0724: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d0738;
    }
label_1d072c:
    // 0x1d072c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d0730: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d0734: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1d0738:
    // 0x1d0738: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d073c: 0xc7ac0044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 68)); ctx->f[12] = *(float*)&val; }
    // 0x1d0740: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1d0748);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1d0748
// Address: 0x1d0748 - 0x1d0764

void entry_1d0748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0748: 0xc62c0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[12] = *(float*)&val; }
    // 0x1d074c: 0x27a40070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1d0750: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d0754: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d0758: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x1d075c: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1d0764);
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1d0764
// Address: 0x1d0764 - 0x1d0794

void entry_1d0764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0764) {
        switch (ctx->pc) {
            case 0x1d077c: ctx->pc = 0; goto label_1d077c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0764: 0x8ea40058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 88)));
    // 0x1d0768: 0x54800004
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 4), 24)));
        goto label_1d077c;
    }
    // 0x1d0770: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d0774: 0x10000019
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1d07dc(rdram, ctx, runtime); return;
    }
label_1d077c:
    // 0x1d077c: 0x27b20080
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1d0780: 0x8e2606d4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1748)));
    // 0x1d0784: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d0788: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d078c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d0794);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d0794
// Address: 0x1d0794 - 0x1d07c8

void entry_1d0794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0794: 0x8ea30058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 88)));
    // 0x1d0798: 0x8c640034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x1d079c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d07a0: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x1d07a4: 0x10400008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 144));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d07c8(rdram, ctx, runtime); return;
    }
    // 0x1d07ac: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d07b0: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d07b4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d07b8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d07bc: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d07c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d07c8);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d07c8
// Address: 0x1d07c8 - 0x1d07dc

void entry_1d07c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d07c8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d07cc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d07d0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d07d4: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1d07dc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 80));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d07dc
// Address: 0x1d07dc - 0x1d09c8

void entry_1d07dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d07dc) {
        switch (ctx->pc) {
            case 0x1d0830: ctx->pc = 0; goto label_1d0830;
            case 0x1d083c: ctx->pc = 0; goto label_1d083c;
            case 0x1d0880: ctx->pc = 0; goto label_1d0880;
            case 0x1d0890: ctx->pc = 0; goto label_1d0890;
            case 0x1d08d0: ctx->pc = 0; goto label_1d08d0;
            case 0x1d090c: ctx->pc = 0; goto label_1d090c;
            case 0x1d0940: ctx->pc = 0; goto label_1d0940;
            case 0x1d0944: ctx->pc = 0; goto label_1d0944;
            case 0x1d0948: ctx->pc = 0; goto label_1d0948;
            case 0x1d0960: ctx->pc = 0; goto label_1d0960;
            case 0x1d0964: ctx->pc = 0; goto label_1d0964;
            case 0x1d0968: ctx->pc = 0; goto label_1d0968;
            case 0x1d09a4: ctx->pc = 0; goto label_1d09a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d07dc: 0xafa00058
    WRITE32(ADD32(GPR_U32(ctx, 29), 88), GPR_U32(ctx, 0));
    // 0x1d07e0: 0x26c28d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 22), 4294937856));
    // 0x1d07e4: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1d07e8: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1d07ec: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d07f0: 0xdba30050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d07f4: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d07f8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d07fc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d0800: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d0804: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d0808: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d080c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d0810: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d0814: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d0818: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d081c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0820: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d0830;
    }
    // 0x1d0828: 0x10000004
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d083c;
    }
label_1d0830:
    // 0x1d0830: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d0834: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d0838: 0x4be018dc
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1d083c:
    // 0x1d083c: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d0840: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d0844: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d0848: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d084c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d0850: 0x8e23241c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9244)));
    // 0x1d0854: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d0858: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x1d085c: 0x1060000c
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1d0890;
    }
    // 0x1d0864: 0x1c600006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 3) > 0) {
        goto label_1d0880;
    }
    // 0x1d086c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1d0870: 0x50620026
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 72)); ctx->f[1] = *(float*)&val; }
        goto label_1d090c;
    }
    // 0x1d0878: 0x10000033
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9244)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d0948;
    }
label_1d0880:
    // 0x1d0880: 0x50620013
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[1] = *(float*)&val; }
        goto label_1d08d0;
    }
    // 0x1d0888: 0x1000002f
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9244)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d0948;
    }
label_1d0890:
    // 0x1d0890: 0xc6210634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[1] = *(float*)&val; }
    // 0x1d0894: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1d0898: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d089c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d08a0: 0x0
    // NOP
    // 0x1d08a4: 0x45010026
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d0940;
    }
    // 0x1d08ac: 0x3c01bf33
    SET_GPR_U32(ctx, 1, ((uint32_t)48947 << 16));
    // 0x1d08b0: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1d08b4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d08b8: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d08bc: 0x0
    // NOP
    // 0x1d08c0: 0x45000020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d0944;
    }
    // 0x1d08c8: 0x1000001e
    WRITE32(ADD32(GPR_U32(ctx, 17), 9244), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d0944;
    }
label_1d08d0:
    // 0x1d08d0: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1d08d4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d08d8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d08dc: 0x0
    // NOP
    // 0x1d08e0: 0x45010017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d0940;
    }
    // 0x1d08e8: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1d08ec: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1d08f0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d08f4: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d08f8: 0x0
    // NOP
    // 0x1d08fc: 0x45020012
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9244)));
        goto label_1d0948;
    }
    // 0x1d0904: 0x1000000f
    WRITE32(ADD32(GPR_U32(ctx, 17), 9244), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d0944;
    }
label_1d090c:
    // 0x1d090c: 0x3c013eb3
    SET_GPR_U32(ctx, 1, ((uint32_t)16051 << 16));
    // 0x1d0910: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1d0914: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d0918: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d091c: 0x0
    // NOP
    // 0x1d0920: 0x45020009
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9244)));
        goto label_1d0948;
    }
    // 0x1d0928: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d092c: 0x46140036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0930: 0x0
    // NOP
    // 0x1d0934: 0x45030003
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 9244), GPR_U32(ctx, 0));
        goto label_1d0944;
    }
    // 0x1d093c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1d0940:
    // 0x1d0940: 0xae22241c
    WRITE32(ADD32(GPR_U32(ctx, 17), 9244), GPR_U32(ctx, 2));
label_1d0944:
    // 0x1d0944: 0x8e23241c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9244)));
label_1d0948:
    // 0x1d0948: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1d0960;
    }
    // 0x1d0950: 0x50620004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 9160), GPR_U32(ctx, 3));
        goto label_1d0964;
    }
    // 0x1d0958: 0x10000003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d0968;
    }
label_1d0960:
    // 0x1d0960: 0xae2023c8
    WRITE32(ADD32(GPR_U32(ctx, 17), 9160), GPR_U32(ctx, 0));
label_1d0964:
    // 0x1d0964: 0x8ea20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 64)));
label_1d0968:
    // 0x1d0968: 0x14400033
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0A38; return;
    }
    // 0x1d0970: 0xc6200e40
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3648)); ctx->f[0] = *(float*)&val; }
    // 0x1d0974: 0xc6220e90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3728)); ctx->f[2] = *(float*)&val; }
    // 0x1d0978: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1d097c: 0xc4414e5c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20060)); ctx->f[1] = *(float*)&val; }
    // 0x1d0980: 0x46001087
    ctx->f[2] = FPU_NEG_S(ctx->f[2]);
    // 0x1d0984: 0xe7a10088
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 136), *(uint32_t*)&val); }
    // 0x1d0988: 0xe7a00084
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 132), *(uint32_t*)&val); }
    // 0x1d098c: 0xe7a20080
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 128), *(uint32_t*)&val); }
    // 0x1d0990: 0x8e620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x1d0994: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9160)));
        goto label_1d09a4;
    }
    // 0x1d099c: 0x1000001b
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 172), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1d0a0c(rdram, ctx, runtime); return;
    }
label_1d09a4:
    // 0x1d09a4: 0x1040000c
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D09D8; return;
    }
    // 0x1d09ac: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d09b0: 0xc44d4e04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19972)); ctx->f[13] = *(float*)&val; }
    // 0x1d09b4: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1d09b8: 0xc46e1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6240)); ctx->f[14] = *(float*)&val; }
    // 0x1d09bc: 0x27a500ac
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 172));
    // 0x1d09c0: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d09c8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9156)); ctx->f[12] = *(float*)&val; }
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d09c8
// Address: 0x1d09c8 - 0x1d09e8

void entry_1d09c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d09c8) {
        switch (ctx->pc) {
            case 0x1d09d8: ctx->pc = 0; goto label_1d09d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d09c8: 0xc7a100ac
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 172)); ctx->f[1] = *(float*)&val; }
    // 0x1d09cc: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x1d09d0: 0x1000000e
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 172), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1d0a0c(rdram, ctx, runtime); return;
    }
label_1d09d8:
    // 0x1d09d8: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1d09dc: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1d09e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d09e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d09e8
// Address: 0x1d09e8 - 0x1d0a0c

void entry_1d09e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d09e8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d09ec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d09f0: 0xc46d4e04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 19972)); ctx->f[13] = *(float*)&val; }
    // 0x1d09f4: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1d09f8: 0xc44e1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[14] = *(float*)&val; }
    // 0x1d09fc: 0x27a500ac
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 172));
    // 0x1d0a00: 0x460d0341
    ctx->f[13] = FPU_SUB_S(ctx->f[0], ctx->f[13]);
    // 0x1d0a04: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d0a0c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9156)); ctx->f[12] = *(float*)&val; }
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d0a0c
// Address: 0x1d0a0c - 0x1d0a78

void entry_1d0a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0a0c) {
        switch (ctx->pc) {
            case 0x1d0a38: ctx->pc = 0; goto label_1d0a38;
            case 0x1d0a44: ctx->pc = 0; goto label_1d0a44;
            case 0x1d0a58: ctx->pc = 0; goto label_1d0a58;
            case 0x1d0a5c: ctx->pc = 0; goto label_1d0a5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0a0c: 0xc7a20084
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 132)); ctx->f[2] = *(float*)&val; }
    // 0x1d0a10: 0xc7a100ac
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 172)); ctx->f[1] = *(float*)&val; }
    // 0x1d0a14: 0xc7a00080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[0] = *(float*)&val; }
    // 0x1d0a18: 0xc62d0634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[13] = *(float*)&val; }
    // 0x1d0a1c: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x1d0a20: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1d0a24: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1d0a28: 0x46036834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0a2c: 0x0
    // NOP
    // 0x1d0a30: 0x45000004
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d0a44;
    }
label_1d0a38:
    // 0x1d0a38: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1d0a3c: 0x10000007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d0a5c;
    }
label_1d0a44:
    // 0x1d0a44: 0x460d0834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0a48: 0x0
    // NOP
    // 0x1d0a4c: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[13]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d0a58;
    }
    // 0x1d0a54: 0x46000d06
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
label_1d0a58:
    // 0x1d0a58: 0x8e2223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9160)));
label_1d0a5c:
    // 0x1d0a5c: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0A7C; return;
    }
    // 0x1d0a64: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1d0a68: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1d0a6c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d0a70: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1d0a78);
    ctx->f[12] = FPU_ADD_S(ctx->f[21], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1d0a78
// Address: 0x1d0a78 - 0x1d0aa8

void entry_1d0a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0a78) {
        switch (ctx->pc) {
            case 0x1d0a7c: ctx->pc = 0; goto label_1d0a7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0a78: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
label_1d0a7c:
    // 0x1d0a7c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d0a80: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0a84: 0x0
    // NOP
    // 0x1d0a88: 0x45000009
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D0AB0; return;
    }
    // 0x1d0a90: 0x8e261010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4112)));
    // 0x1d0a94: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1d0a98: 0x24100014
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1d0a9c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d0aa0: 0xc075028
    SET_GPR_U32(ctx, 31, 0x1d0aa8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 3632));
    SetStepRunTarget__FP4STEPffP5BLRUNP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_1d0aa8
// Address: 0x1d0aa8 - 0x1d0acc

void entry_1d0aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0aa8) {
        switch (ctx->pc) {
            case 0x1d0ab0: ctx->pc = 0; goto label_1d0ab0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0aa8: 0x1000000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0AD8; return;
    }
label_1d0ab0:
    // 0x1d0ab0: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d0ab4: 0xe6350638
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
    // 0x1d0ab8: 0xfa210640
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d0abc: 0x10000005
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0AD4; return;
    }
    // 0x1d0ac4: 0xc05c460
    SET_GPR_U32(ctx, 31, 0x1d0acc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FTurnJtToTarget__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1d0acc
// Address: 0x1d0acc - 0x1d0ae4

void entry_1d0acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0acc) {
        switch (ctx->pc) {
            case 0x1d0ad0: ctx->pc = 0; goto label_1d0ad0;
            case 0x1d0ad4: ctx->pc = 0; goto label_1d0ad4;
            case 0x1d0ad8: ctx->pc = 0; goto label_1d0ad8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0acc: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
label_1d0ad0:
    // 0x1d0ad0: 0xfa210640
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
label_1d0ad4:
    // 0x1d0ad4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1d0ad8:
    // 0x1d0ad8: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1d0adc: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d0ae4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d0ae4
// Address: 0x1d0ae4 - 0x1d0b20

void entry_1d0ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0ae4: 0x7bbf0140
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1d0ae8: 0x7bbe0130
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1d0aec: 0x7bb70120
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1d0af0: 0x7bb60110
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1d0af4: 0x7bb50100
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1d0af8: 0x7bb400f0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1d0afc: 0x7bb300e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d0b00: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d0b04: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d0b08: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d0b0c: 0xc7b60160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[22] = *(float*)&val; }
    // 0x1d0b10: 0xc7b50158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 344)); ctx->f[21] = *(float*)&val; }
    // 0x1d0b14: 0xc7b40150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[20] = *(float*)&val; }
    // 0x1d0b18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 368));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: MatchJtXmgRail__FP2JTP3XMGP6ACTADJ
// Address: 0x1d0b20 - 0x1d0b94

void entry_1d0b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0b94: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1d0b98: 0x10400006
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0BB4; return;
    }
    // 0x1d0ba0: 0xc62c23c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9156)); ctx->f[12] = *(float*)&val; }
    // 0x1d0ba4: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1d0bac);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[20]);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d0bac
// Address: 0x1d0bac - 0x1d0c08

void entry_1d0bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0bac) {
        switch (ctx->pc) {
            case 0x1d0bb4: ctx->pc = 0; goto label_1d0bb4;
            case 0x1d0bd8: ctx->pc = 0; goto label_1d0bd8;
            case 0x1d0be8: ctx->pc = 0; goto label_1d0be8;
            case 0x1d0bec: ctx->pc = 0; goto label_1d0bec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0bac: 0x1000000f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d0bec;
    }
label_1d0bb4:
    // 0x1d0bb4: 0xc62023c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9156)); ctx->f[0] = *(float*)&val; }
    // 0x1d0bb8: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1d0bbc: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1d0bc0: 0xc44c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    // 0x1d0bc4: 0x460c0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0bc8: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d0bd8;
    }
    // 0x1d0bd0: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d0be8;
    }
label_1d0bd8:
    // 0x1d0bd8: 0x46006834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d0bdc: 0x0
    // NOP
    // 0x1d0be0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[13]);
        goto label_1d0be8;
    }
label_1d0be8:
    // 0x1d0be8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1d0bec:
    // 0x1d0bec: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d0bf0: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d0c08(rdram, ctx, runtime); return;
    }
    // 0x1d0bf8: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1d0bfc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d0c00: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d0c08);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d0c08
// Address: 0x1d0c08 - 0x1d0c20

void entry_1d0c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0c08: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d0c0c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d0c10: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d0c14: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d0c18: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d0c20);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d0c20
// Address: 0x1d0c20 - 0x1d0c3c

void entry_1d0c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0c20: 0xc64c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1d0c24: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d0c28: 0x26440020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 32));
    // 0x1d0c2c: 0x26450010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 16));
    // 0x1d0c30: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d0c34: 0xc0507d2
    SET_GPR_U32(ctx, 31, 0x1d0c3c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1d0c3c
// Address: 0x1d0c3c - 0x1d0c78

void entry_1d0c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0c3c) {
        switch (ctx->pc) {
            case 0x1d0c50: ctx->pc = 0; goto label_1d0c50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0c3c: 0x18400004
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1d0c50;
    }
    // 0x1d0c44: 0xda420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1d0c48: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d0c4c: 0xfa810020
    WRITE128(ADD32(GPR_U32(ctx, 20), 32), _mm_castps_si128(ctx->vu0_vf[1]));
label_1d0c50:
    // 0x1d0c50: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d0c54: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d0c58: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d0c5c: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d0c60: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d0c64: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d0c68: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1d0c6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d0c74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d0c78; return;
}


// Function: UpdateJtHide__FP2JT
// Address: 0x1d0c78 - 0x1d0d34

void entry_1d0d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0d34: 0x8e432230
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x1d0d38: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d0d3c: 0xc4404b64
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19300)); ctx->f[0] = *(float*)&val; }
    // 0x1d0d40: 0xc4610018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1d0d44: 0xc46c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1d0d48: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d0d4c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1d0d50: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d0d54: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d0d58: 0xc4410034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1d0d5c: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x1d0d60: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1d0d68);
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[1];
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d0d68
// Address: 0x1d0d68 - 0x1d0db8

void entry_1d0d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0d68) {
        switch (ctx->pc) {
            case 0x1d0da0: ctx->pc = 0; goto label_1d0da0;
            case 0x1d0da4: ctx->pc = 0; goto label_1d0da4;
            case 0x1d0dac: ctx->pc = 0; goto label_1d0dac;
            case 0x1d0db0: ctx->pc = 0; goto label_1d0db0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0d68: 0x8e432674
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x1d0d6c: 0x8e422678
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9848)));
    // 0x1d0d70: 0x1462000e
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1d0dac;
    }
    // 0x1d0d78: 0x8e432684
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9860)));
    // 0x1d0d7c: 0x28620003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    // 0x1d0d80: 0x1040000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d0db0;
    }
    // 0x1d0d88: 0x18600009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_1d0db0;
    }
    // 0x1d0d90: 0x14620003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9888)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1d0da0;
    }
    // 0x1d0d98: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2624)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d0da4;
    }
label_1d0da0:
    // 0x1d0da0: 0xc6410a20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2592)); ctx->f[1] = *(float*)&val; }
label_1d0da4:
    // 0x1d0da4: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1d0da8: 0xe64026a0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9888), *(uint32_t*)&val); }
label_1d0dac:
    // 0x1d0dac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1d0db0:
    // 0x1d0db0: 0xc0712a0
    SET_GPR_U32(ctx, 31, 0x1d0db8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateStepFootfall__FP4STEPfP3SFF(rdram, ctx, runtime); return;
}


// Function: entry_1d0db8
// Address: 0x1d0db8 - 0x1d0e08

void entry_1d0db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0db8) {
        switch (ctx->pc) {
            case 0x1d0dc0: ctx->pc = 0; goto label_1d0dc0;
            case 0x1d0de8: ctx->pc = 0; goto label_1d0de8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0db8: 0x10000052
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0F04; return;
    }
label_1d0dc0:
    // 0x1d0dc0: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x1d0dc4: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1d0dc8: 0x10620017
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D0E28; return;
    }
    // 0x1d0dd0: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d0de8;
    }
    // 0x1d0dd8: 0x5062000d
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 3616)));
        ctx->pc = 0x1D0E10; return;
    }
    // 0x1d0de0: 0x10000017
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0E40; return;
    }
label_1d0de8:
    // 0x1d0de8: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d0dec: 0x54620014
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
        ctx->pc = 0x1D0E40; return;
    }
    // 0x1d0df4: 0x8e461010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 4112)));
    // 0x1d0df8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d0dfc: 0x8e472230
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x1d0e00: 0xc074f80
    SET_GPR_U32(ctx, 31, 0x1d0e08);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 3632));
    AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1d0e08
// Address: 0x1d0e08 - 0x1d0e20

void entry_1d0e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0e08) {
        switch (ctx->pc) {
            case 0x1d0e10: ctx->pc = 0; goto label_1d0e10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0e08: 0x1000000d
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0E40; return;
    }
label_1d0e10:
    // 0x1d0e10: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d0e14: 0x8e472230
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x1d0e18: 0xc074f80
    SET_GPR_U32(ctx, 31, 0x1d0e20);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 3136));
    AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1d0e20
// Address: 0x1d0e20 - 0x1d0e3c

void entry_1d0e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0e20) {
        switch (ctx->pc) {
            case 0x1d0e28: ctx->pc = 0; goto label_1d0e28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0e20: 0x10000007
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0E40; return;
    }
label_1d0e28:
    // 0x1d0e28: 0x8e460900
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 2304)));
    // 0x1d0e2c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d0e30: 0x8e472230
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x1d0e34: 0xc074f80
    SET_GPR_U32(ctx, 31, 0x1d0e3c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 1824));
    AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1d0e3c
// Address: 0x1d0e3c - 0x1d0e70

void entry_1d0e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0e3c) {
        switch (ctx->pc) {
            case 0x1d0e40: ctx->pc = 0; goto label_1d0e40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0e3c: 0x8e432230
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
label_1d0e40:
    // 0x1d0e40: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d0e44: 0xc4404b64
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19300)); ctx->f[0] = *(float*)&val; }
    // 0x1d0e48: 0xc4610018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1d0e4c: 0xc46c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1d0e50: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d0e54: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1d0e58: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d0e5c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d0e60: 0xc4410034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1d0e64: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x1d0e68: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1d0e70);
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[1];
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d0e70
// Address: 0x1d0e70 - 0x1d0e80

void entry_1d0e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0e70: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d0e74: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1d0e78: 0xc0712a0
    SET_GPR_U32(ctx, 31, 0x1d0e80);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 9280));
    UpdateStepFootfall__FP4STEPfP3SFF(rdram, ctx, runtime); return;
}


// Function: entry_1d0e80
// Address: 0x1d0e80 - 0x1d0ec4

void entry_1d0e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0e80) {
        switch (ctx->pc) {
            case 0x1d0e88: ctx->pc = 0; goto label_1d0e88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0e80: 0x10000020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D0F04; return;
    }
label_1d0e88:
    // 0x1d0e88: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x1d0e8c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d0e90: 0x5462001d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        ctx->pc = 0x1D0F08; return;
    }
    // 0x1d0e98: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1d0e9c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1d0ea0: 0x26511190
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 4496));
    // 0x1d0ea4: 0x8e450628
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1576)));
    // 0x1d0ea8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d0eac: 0x8e460620
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 1568)));
    // 0x1d0eb0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d0eb4: 0x8e47250c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 9484)));
    // 0x1d0eb8: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d0ebc: 0xc05c67a
    SET_GPR_U32(ctx, 31, 0x1d0ec4);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 4752));
    RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG(rdram, ctx, runtime); return;
}


// Function: entry_1d0ec4
// Address: 0x1d0ec4 - 0x1d0ee0

void entry_1d0ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0ec4: 0x8e45062c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1580)));
    // 0x1d0ec8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d0ecc: 0x8e460624
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 1572)));
    // 0x1d0ed0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d0ed4: 0x8e472510
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 9488)));
    // 0x1d0ed8: 0xc05c67a
    SET_GPR_U32(ctx, 31, 0x1d0ee0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG(rdram, ctx, runtime); return;
}


// Function: entry_1d0ee0
// Address: 0x1d0ee0 - 0x1d0ef0

void entry_1d0ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0ee0: 0x8e46250c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 9484)));
    // 0x1d0ee4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d0ee8: 0xc0742c8
    SET_GPR_U32(ctx, 31, 0x1d0ef0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    MatchJtXmgRail__FP2JTP3XMGP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_1d0ef0
// Address: 0x1d0ef0 - 0x1d0f00

void entry_1d0ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0ef0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d0ef4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d0ef8: 0xc0742c8
    SET_GPR_U32(ctx, 31, 0x1d0f00);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 9488)));
    MatchJtXmgRail__FP2JTP3XMGP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_1d0f00
// Address: 0x1d0f00 - 0x1d0f20

void entry_1d0f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0f00) {
        switch (ctx->pc) {
            case 0x1d0f04: ctx->pc = 0; goto label_1d0f04;
            case 0x1d0f08: ctx->pc = 0; goto label_1d0f08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0f00: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1d0f04:
    // 0x1d0f04: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1d0f08:
    // 0x1d0f08: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d0f0c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d0f10: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1d0f14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d0f1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d0f20; return;
}


// Function: UpdateJtInternalXpsHide__FP2JT
// Address: 0x1d0f20 - 0x1d0f68

void entry_1d0f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0f68: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d0f6c: 0x24050023
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 35));
    // 0x1d0f70: 0x8c8623b8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 9144)));
    // 0x1d0f74: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d0f78: 0x8c8906d4
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 4), 1748)));
    // 0x1d0f7c: 0xc07361c
    SET_GPR_U32(ctx, 31, 0x1d0f84);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddJtHookXps__FP2JTiP2LOP6VECTORN23(rdram, ctx, runtime); return;
}


// Function: entry_1d0f84
// Address: 0x1d0f84 - 0x1d0fac

void entry_1d0f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d0f84) {
        switch (ctx->pc) {
            case 0x1d0f8c: ctx->pc = 0; goto label_1d0f8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d0f84: 0x10000096
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D11E0; return;
    }
label_1d0f8c:
    // 0x1d0f8c: 0x8e0223bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9148)));
    // 0x1d0f90: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d0f94: 0x8e0606d4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1748)));
    // 0x1d0f98: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d0f9c: 0x8c540018
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1d0fa0: 0x8c520034
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1d0fa4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d0fac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d0fac
// Address: 0x1d0fac - 0x1d0fe4

void entry_1d0fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0fac: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d0fb0: 0x27b30010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d0fb4: 0x8c42002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 44)));
    // 0x1d0fb8: 0x1040000a
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d0fe4(rdram, ctx, runtime); return;
    }
    // 0x1d0fc0: 0xc60c23c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9152)); ctx->f[12] = *(float*)&val; }
    // 0x1d0fc4: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d0fc8: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d0fcc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d0fd0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d0fd4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d0fd8: 0x260923c0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 16), 9152));
    // 0x1d0fdc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d0fe4);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 16), 9156));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d0fe4
// Address: 0x1d0fe4 - 0x1d0ffc

void entry_1d0fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0fe4: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d0fe8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d0fec: 0xe0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1d0ff0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d0ff4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d0ffc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d0ffc
// Address: 0x1d0ffc - 0x1d1014

void entry_1d0ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d0ffc: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d1000: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1004: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1008: 0xe0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1d100c: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1d1014);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d1014
// Address: 0x1d1014 - 0x1d10f0

void entry_1d1014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1014) {
        switch (ctx->pc) {
            case 0x1d10b0: ctx->pc = 0; goto label_1d10b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1014: 0x8e0323bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9148)));
    // 0x1d1018: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1d101c: 0x14400069
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 34));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D11C4; return;
    }
    // 0x1d1024: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1d1028: 0x54400067
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x1D11C8; return;
    }
    // 0x1d1030: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d1034: 0x260200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1d1038: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1d103c: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d1040: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d1044: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d1048: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d104c: 0xd8450020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1d1050: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d1054: 0x3c01c000
    SET_GPR_U32(ctx, 1, ((uint32_t)49152 << 16));
    // 0x1d1058: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d105c: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1d1060: 0x44832000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 3);
    // 0x1d1064: 0xda020640
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1600)));
    // 0x1d1068: 0x46012034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d106c: 0xda0400d0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1d1070: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d1074: 0x4bc208bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d1078: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d107c: 0x4bc310aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d1080: 0x4b000183
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d1084: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d1088: 0x4b02308a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d108c: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d1090: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d1094: 0x45010006
    ctx->f[3] = FPU_NEG_S(ctx->f[0]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d10b0;
    }
    // 0x1d109c: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1d10a0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d10a4: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d10a8: 0x4500001a
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D1114; return;
    }
label_1d10b0:
    // 0x1d10b0: 0x8e430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1d10b4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d10b8: 0xc4424e04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19972)); ctx->f[2] = *(float*)&val; }
    // 0x1d10bc: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1d10c0: 0xc60123c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9156)); ctx->f[1] = *(float*)&val; }
    // 0x1d10c4: 0x46020300
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1d10c8: 0x460c0834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d10cc: 0x4500000f
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D110C; return;
    }
    // 0x1d10d4: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d10d8: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d10dc: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d10f0(rdram, ctx, runtime); return;
    }
    // 0x1d10e4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d10e8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d10f0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d10f0
// Address: 0x1d10f0 - 0x1d1104

void entry_1d10f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d10f0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d10f4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d10f8: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d10fc: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d1104);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d1104
// Address: 0x1d1104 - 0x1d118c

void entry_1d1104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1104) {
        switch (ctx->pc) {
            case 0x1d110c: ctx->pc = 0; goto label_1d110c;
            case 0x1d1114: ctx->pc = 0; goto label_1d1114;
            case 0x1d1140: ctx->pc = 0; goto label_1d1140;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1104: 0x1000002f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 42));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D11C4; return;
    }
label_1d110c:
    // 0x1d110c: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1d1110: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
label_1d1114:
    // 0x1d1114: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1118: 0x0
    // NOP
    // 0x1d111c: 0x45030008
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        goto label_1d1140;
    }
    // 0x1d1124: 0x3c01c000
    SET_GPR_U32(ctx, 1, ((uint32_t)49152 << 16));
    // 0x1d1128: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d112c: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1130: 0x0
    // NOP
    // 0x1d1134: 0x45000024
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D11C8; return;
    }
    // 0x1d113c: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
label_1d1140:
    // 0x1d1140: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d1144: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1d1148: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1d114c: 0xc4624e04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 19972)); ctx->f[2] = *(float*)&val; }
    // 0x1d1150: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1d1154: 0xc60123c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9156)); ctx->f[1] = *(float*)&val; }
    // 0x1d1158: 0xc440fffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[0] = *(float*)&val; }
    // 0x1d115c: 0x46020301
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1d1160: 0x46016034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1164: 0x0
    // NOP
    // 0x1d1168: 0x45000017
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D11C8; return;
    }
    // 0x1d1170: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d1174: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d1178: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d118c(rdram, ctx, runtime); return;
    }
    // 0x1d1180: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d1184: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d118c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d118c
// Address: 0x1d118c - 0x1d11a0

void entry_1d118c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d118c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1190: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d1194: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d1198: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d11a0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d11a0
// Address: 0x1d11a0 - 0x1d11dc

void entry_1d11a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d11a0) {
        switch (ctx->pc) {
            case 0x1d11c4: ctx->pc = 0; goto label_1d11c4;
            case 0x1d11c8: ctx->pc = 0; goto label_1d11c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d11a0: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1d11a4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d11a8: 0x2405002a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 42));
    // 0x1d11ac: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d11b0: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1d11b4: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1d11b8: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d11bc: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d11c0: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
label_1d11c4:
    // 0x1d11c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1d11c8:
    // 0x1d11c8: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1d11cc: 0x8c8623bc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 9148)));
    // 0x1d11d0: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d11d4: 0xc07361c
    SET_GPR_U32(ctx, 31, 0x1d11dc);
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 4), 1748)));
    AddJtHookXps__FP2JTiP2LOP6VECTORN23(rdram, ctx, runtime); return;
}


// Function: entry_1d11dc
// Address: 0x1d11dc - 0x1d1200

void entry_1d11dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d11dc) {
        switch (ctx->pc) {
            case 0x1d11e0: ctx->pc = 0; goto label_1d11e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d11dc: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
label_1d11e0:
    // 0x1d11e0: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d11e4: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d11e8: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d11ec: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d11f0: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d11f4: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d11f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetJtHfdk__FP2JT4HFDK
// Address: 0x1d1200 - 0x1d1260

void entry_1d12e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d12e4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d12e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PresetJtAccelHide__FP2JT
// Address: 0x1d12f0 - 0x1d1358

void entry_1d1358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1358) {
        switch (ctx->pc) {
            case 0x1d135c: ctx->pc = 0; goto label_1d135c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1358: 0x8e640018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 24)));
label_1d135c:
    // 0x1d135c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d1360: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d1364: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1d136c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d136c
// Address: 0x1d136c - 0x1d13d0

void entry_1d136c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d136c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d1370: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x1d1374: 0xda410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1d1378: 0x26311858
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 6232));
    // 0x1d137c: 0x4bc1106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d1380: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d1384: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d1388: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d138c: 0xda430350
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 848)));
    // 0x1d1390: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d1394: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1d1398: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x1d139c: 0x4bc310aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d13a0: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d13a4: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d13a8: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d13ac: 0x26104ef0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 20208));
    // 0x1d13b0: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d13b4: 0xc66d0044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 68)); ctx->f[13] = *(float*)&val; }
    // 0x1d13b8: 0x4482a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 2);
    // 0x1d13bc: 0xc62e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1d13c0: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d13c4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d13c8: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d13d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d13d0
// Address: 0x1d13d0 - 0x1d13ec

void entry_1d13d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d13d0: 0xc66d0044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 68)); ctx->f[13] = *(float*)&val; }
    // 0x1d13d4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d13d8: 0xc62e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1d13dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d13e0: 0x46006b47
    ctx->f[13] = FPU_NEG_S(ctx->f[13]);
    // 0x1d13e4: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d13ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 52));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d13ec
// Address: 0x1d13ec - 0x1d1448

void entry_1d13ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d13ec) {
        switch (ctx->pc) {
            case 0x1d1410: ctx->pc = 0; goto label_1d1410;
            case 0x1d1420: ctx->pc = 0; goto label_1d1420;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d13ec: 0xc6600048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 72)); ctx->f[0] = *(float*)&val; }
    // 0x1d13f0: 0xc7a10034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1d13f4: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1d13f8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d13fc: 0x0
    // NOP
    // 0x1d1400: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[2] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d1410;
    }
    // 0x1d1408: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d1420;
    }
label_1d1410:
    // 0x1d1410: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1414: 0x0
    // NOP
    // 0x1d1418: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[2]);
        goto label_1d1420;
    }
label_1d1420:
    // 0x1d1420: 0x46150001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[21]);
    // 0x1d1424: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d1428: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d142c: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d1430: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d1434: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d1438: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d143c: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d1440: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1d1448);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d1448
// Address: 0x1d1448 - 0x1d1450

void entry_1d1448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1448: 0xc05bf5c
    SET_GPR_U32(ctx, 31, 0x1d1450);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PresetJtAccelBase(rdram, ctx, runtime); return;
}


// Function: entry_1d1450
// Address: 0x1d1450 - 0x1d1478

void entry_1d1450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1450: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d1454: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d1458: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d145c: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d1460: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d1464: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1d1468: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1d146c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d1474: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d1478; return;
}


// Function: FUN_001d1478
// Address: 0x1d1478 - 0x1d149c

void FUN_001d1478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1478: 0x27bdfef0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967024));
    // 0x1d147c: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1d1480: 0x7fbf0100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 31));
    // 0x1d1484: 0x24060089
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 137));
    // 0x1d1488: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d148c: 0x24080040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1d1490: 0x8c840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x1d1494: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x1d149c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1d149c
// Address: 0x1d149c - 0x1d14f0

void entry_1d149c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d149c) {
        switch (ctx->pc) {
            case 0x1d14b0: ctx->pc = 0; goto label_1d14b0;
            case 0x1d14d0: ctx->pc = 0; goto label_1d14d0;
            case 0x1d14dc: ctx->pc = 0; goto label_1d14dc;
            case 0x1d14e0: ctx->pc = 0; goto label_1d14e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d149c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d14a0: 0x18c0000e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 6) <= 0) {
        goto label_1d14dc;
    }
    // 0x1d14a8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d14ac: 0x0
    // NOP
label_1d14b0:
    // 0x1d14b0: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d14b4: 0x8c420050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x1d14b8: 0x28430003
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), 3));
    // 0x1d14bc: 0x50600004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
        goto label_1d14d0;
    }
    // 0x1d14c4: 0x1c400006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) > 0) {
        goto label_1d14e0;
    }
    // 0x1d14cc: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
label_1d14d0:
    // 0x1d14d0: 0xa6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 6)));
    // 0x1d14d4: 0x1440fff6
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1d14b0;
    }
label_1d14dc:
    // 0x1d14dc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1d14e0:
    // 0x1d14e0: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1d14e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d14ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d14f0; return;
}


// Function: PostJtLoadPipe__FP2JT
// Address: 0x1d14f0 - 0x1d1548

void entry_1d1548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1548: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x1d154c: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1d1550: 0xe600000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x1d1554: 0x641fff0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x1D1518; return;
    }
    // 0x1d155c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1560: 0x2627103c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 4156));
    // 0x1d1564: 0x262b105c
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 17), 4188));
    // 0x1d1568: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1d156c: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d1570: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1574: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1578: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x1d1580);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_1d1580
// Address: 0x1d1580 - 0x1d15b8

void entry_1d1580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1580: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1d1584: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d1588: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1d158c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1590: 0x8e241064
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4196)));
    // 0x1d1594: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d1598: 0x8e250618
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1560)));
    // 0x1d159c: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1d15a0: 0x262823e0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 9184));
    // 0x1d15a4: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d15a8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d15ac: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d15b0: 0xc04b35e
    SET_GPR_U32(ctx, 31, 0x1d15b8);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime); return;
}


// Function: entry_1d15b8
// Address: 0x1d15b8 - 0x1d15e4

void entry_1d15b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d15b8: 0x8e241064
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4196)));
    // 0x1d15bc: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1d15c0: 0x8e250614
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1556)));
    // 0x1d15c4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d15c8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d15cc: 0x262823f0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 9200));
    // 0x1d15d0: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d15d4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d15d8: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d15dc: 0xc04b35e
    SET_GPR_U32(ctx, 31, 0x1d15e4);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime); return;
}


// Function: entry_1d15e4
// Address: 0x1d15e4 - 0x1d1630

void entry_1d15e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d15e4: 0xc62023e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9184)); ctx->f[0] = *(float*)&val; }
    // 0x1d15e8: 0xc62123f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9200)); ctx->f[1] = *(float*)&val; }
    // 0x1d15ec: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1d15f0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1d15f4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d15f8: 0xe63423e4
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 9188), *(uint32_t*)&val); }
    // 0x1d15fc: 0xe63423f4
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 9204), *(uint32_t*)&val); }
    // 0x1d1600: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d1604: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1d1608: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d160c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d1610: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x1d1614: 0xe62023e0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 9184), *(uint32_t*)&val); }
    // 0x1d1618: 0xe62023f0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 9200), *(uint32_t*)&val); }
    // 0x1d161c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d1620: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x1d1624: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d162c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d1630; return;
}


// Function: GetJtPipeGoalMat__FP2JTP4PIPEfP7MATRIX3
// Address: 0x1d1630 - 0x1d168c

void entry_1d168c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d168c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d1690: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1d1694: 0x10600007
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1d16b4(rdram, ctx, runtime); return;
    }
    // 0x1d169c: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1d16a0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d16a4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d16a8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d16ac: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1d16b4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1d16b4
// Address: 0x1d16b4 - 0x1d17c4

void entry_1d16b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d16b4) {
        switch (ctx->pc) {
            case 0x1d170c: ctx->pc = 0; goto label_1d170c;
            case 0x1d1718: ctx->pc = 0; goto label_1d1718;
            case 0x1d1748: ctx->pc = 0; goto label_1d1748;
            case 0x1d174c: ctx->pc = 0; goto label_1d174c;
            case 0x1d1768: ctx->pc = 0; goto label_1d1768;
            case 0x1d1778: ctx->pc = 0; goto label_1d1778;
            case 0x1d17b8: ctx->pc = 0; goto label_1d17b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d16b4: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d16b8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d16bc: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d16c0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d16c4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d16c8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d16cc: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1d16d0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1d16d4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d16d8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d16dc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d16e0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d16e4: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1d16e8: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d16ec: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d16f0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d16f4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d16f8: 0x0
    // NOP
    // 0x1d16fc: 0x45000003
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d170c;
    }
    // 0x1d1704: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d1718;
    }
label_1d170c:
    // 0x1d170c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d1710: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d1714: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1d1718:
    // 0x1d1718: 0xf8610000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d171c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1720: 0x3c140027
    SET_GPR_U32(ctx, 20, ((uint32_t)39 << 16));
    // 0x1d1724: 0x27a20050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1d1728: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d172c: 0x27b30030
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d1730: 0x3c170025
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    // 0x1d1734: 0x27be0020
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1d1738: 0xafa200b8
    WRITE32(ADD32(GPR_U32(ctx, 29), 184), GPR_U32(ctx, 2));
    // 0x1d173c: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 29), 180), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d174c;
    }
    // 0x1d1744: 0x0
    // NOP
label_1d1748:
    // 0x1d1748: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_1d174c:
    // 0x1d174c: 0x32420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 18), 1));
    // 0x1d1750: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d1768;
    }
    // 0x1d1758: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d175c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1d1760: 0x10000005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 20256)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d1778;
    }
label_1d1768:
    // 0x1d1768: 0xc6804f20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 20256)); ctx->f[0] = *(float*)&val; }
    // 0x1d176c: 0x44920800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 18);
    // 0x1d1770: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1d1774: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
label_1d1778:
    // 0x1d1778: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1d177c: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1d1780: 0x1440000d
    ctx->f[20] = FPU_ADD_S(ctx->f[22], ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1d17b8;
    }
    // 0x1d1788: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1d178c: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1d1790: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1794: 0x0
    // NOP
    // 0x1d1798: 0x4503ffec
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
        goto label_1d174c;
    }
    // 0x1d17a0: 0x4616a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d17a4: 0x0
    // NOP
    // 0x1d17a8: 0x4503ffe8
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
        goto label_1d174c;
    }
    // 0x1d17b0: 0x10000006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D17CC; return;
    }
label_1d17b8:
    // 0x1d17b8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d17bc: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1d17c4);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d17c4
// Address: 0x1d17c4 - 0x1d17f0

void entry_1d17c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d17c4) {
        switch (ctx->pc) {
            case 0x1d17cc: ctx->pc = 0; goto label_1d17cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d17c4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1d17c8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1d17cc:
    // 0x1d17cc: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d17d0: 0x10400010
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d1814(rdram, ctx, runtime); return;
    }
    // 0x1d17d8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d17dc: 0xc62c4f14
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 20244)); ctx->f[12] = *(float*)&val; }
    // 0x1d17e0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d17e4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d17e8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d17f0);
    ctx->f[12] = FPU_ADD_S(ctx->f[20], ctx->f[12]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d17f0
// Address: 0x1d17f0 - 0x1d1814

void entry_1d17f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d17f0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d17f4: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d17f8: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d1814(rdram, ctx, runtime); return;
    }
    // 0x1d1800: 0xc62c4f14
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 20244)); ctx->f[12] = *(float*)&val; }
    // 0x1d1804: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d1808: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d180c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d1814);
    ctx->f[12] = FPU_SUB_S(ctx->f[20], ctx->f[12]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d1814
// Address: 0x1d1814 - 0x1d18cc

void entry_1d1814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1814) {
        switch (ctx->pc) {
            case 0x1d186c: ctx->pc = 0; goto label_1d186c;
            case 0x1d1878: ctx->pc = 0; goto label_1d1878;
            case 0x1d1884: ctx->pc = 0; goto label_1d1884;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1814: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d1818: 0x26e28d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 4294937888));
    // 0x1d181c: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d1820: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d1824: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1d1828: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1d182c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d1830: 0x4bc318aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d1834: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d1838: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d183c: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d1840: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d1844: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d1848: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d184c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d1850: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d1854: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d1858: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d185c: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d186c;
    }
    // 0x1d1864: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d1878;
    }
label_1d186c:
    // 0x1d186c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d1870: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d1874: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1d1878:
    // 0x1d1878: 0x16400002
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        goto label_1d1884;
    }
    // 0x1d1880: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
label_1d1884:
    // 0x1d1884: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d1888: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d188c: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d1890: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d1894: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d1898: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d189c: 0x3c01bf66
    SET_GPR_U32(ctx, 1, ((uint32_t)48998 << 16));
    // 0x1d18a0: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x1d18a4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d18a8: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d18ac: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d18b0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d18b4: 0x0
    // NOP
    // 0x1d18b8: 0x4500ffa3
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 184)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D1748; return;
    }
    // 0x1d18c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d18c4: 0xc06274e
    SET_GPR_U32(ctx, 31, 0x1d18cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1d18cc
// Address: 0x1d18cc - 0x1d1900

void entry_1d18cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d18cc: 0x8fa600b4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x1d18d0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d18d4: 0xdba30060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d18d8: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d18dc: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1d18e0: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d18e4: 0xdaa10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 64)));
    // 0x1d18e8: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d18ec: 0x4bc118bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d18f0: 0x4bc1104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d18f4: 0x8ea40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 24)));
    // 0x1d18f8: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1d1900);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d1900
// Address: 0x1d1900 - 0x1d1914

void entry_1d1900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1900: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d1904: 0x8ea40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 24)));
    // 0x1d1908: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d190c: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1d1914);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d1914
// Address: 0x1d1914 - 0x1d1a80

void entry_1d1914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1914) {
        switch (ctx->pc) {
            case 0x1d196c: ctx->pc = 0; goto label_1d196c;
            case 0x1d19d0: ctx->pc = 0; goto label_1d19d0;
            case 0x1d19dc: ctx->pc = 0; goto label_1d19dc;
            case 0x1d1a24: ctx->pc = 0; goto label_1d1a24;
            case 0x1d1a40: ctx->pc = 0; goto label_1d1a40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1914: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d1918: 0x26e28d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 4294937888));
    // 0x1d191c: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d1920: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d1924: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d1928: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d192c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1d1930: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1d1934: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d1938: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d193c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d1940: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d1944: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d1948: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d194c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d1950: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1954: 0x0
    // NOP
    // 0x1d1958: 0x45010004
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d196c;
    }
    // 0x1d1960: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d1964: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d1968: 0x4be0191c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1d196c:
    // 0x1d196c: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d1970: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1d1974: 0x4bc122fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x1d1978: 0x4bc408ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d197c: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d1980: 0x24628d10
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294937872));
    // 0x1d1984: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d1988: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d198c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d1990: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d1994: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1d1998: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1d199c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d19a0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d19a4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d19a8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d19ac: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d19b0: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d19b4: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d19b8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d19bc: 0x0
    // NOP
    // 0x1d19c0: 0x45000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d19d0;
    }
    // 0x1d19c8: 0x10000004
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d19dc;
    }
label_1d19d0:
    // 0x1d19d0: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d19d4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d19d8: 0x4be0189c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1d19dc:
    // 0x1d19dc: 0x8fa300b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d19e0: 0xdba300a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d19e4: 0x8c62221c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8732)));
    // 0x1d19e8: 0x4bc312fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[3] = READ32(addr); }
    // 0x1d19ec: 0x4bc2186e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d19f0: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d19f4: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d19f8: 0x1040000a
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d1a24;
    }
    // 0x1d1a00: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1d1a04: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d1a08: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d1a0c: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d1a10: 0x4be118d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d1a14: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d1a18: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d1a1c: 0xfba20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d1a20: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
label_1d1a24:
    // 0x1d1a24: 0x12c00006
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_1d1a40;
    }
    // 0x1d1a2c: 0x7ba40090
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d1a30: 0x7ba300a0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d1a34: 0x7ec20000
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), GPR_VEC(ctx, 2));
    // 0x1d1a38: 0x7ec30020
    WRITE128(ADD32(GPR_U32(ctx, 22), 32), GPR_VEC(ctx, 3));
    // 0x1d1a3c: 0x7ec40010
    WRITE128(ADD32(GPR_U32(ctx, 22), 16), GPR_VEC(ctx, 4));
label_1d1a40:
    // 0x1d1a40: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1d1a44: 0x7bbe0140
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1d1a48: 0x7bb70130
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1d1a4c: 0x7bb60120
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1d1a50: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1d1a54: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1d1a58: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1d1a5c: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d1a60: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d1a64: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d1a68: 0xc7b60170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[22] = *(float*)&val; }
    // 0x1d1a6c: 0xc7b50168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 360)); ctx->f[21] = *(float*)&val; }
    // 0x1d1a70: 0xc7b40160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[20] = *(float*)&val; }
    // 0x1d1a74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d1a7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d1a80; return;
}


// Function: PresetJtAccelPipe__FP2JT
// Address: 0x1d1a80 - 0x1d1aac

void entry_1d1aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1aac) {
        switch (ctx->pc) {
            case 0x1d1ac4: ctx->pc = 0; goto label_1d1ac4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1aac: 0x8e632228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8744)));
    // 0x1d1ab0: 0x24020017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 23));
    // 0x1d1ab4: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 27));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d1ac4;
    }
    // 0x1d1abc: 0x1462001b
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D1B2C; return;
    }
label_1d1ac4:
    // 0x1d1ac4: 0x8e622230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8752)));
    // 0x1d1ac8: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x1d1acc: 0x26241858
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 6232));
    // 0x1d1ad0: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d1ad4: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d1ad8: 0x267000d0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 208));
    // 0x1d1adc: 0xc4410014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1d1ae0: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x1d1ae4: 0xc4600034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1d1ae8: 0x26650160
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 352));
    // 0x1d1aec: 0xc48c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1d1af0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d1af4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1d1af8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d1afc: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1d1b00: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1d1b04: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x1d1b08: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d1b0c: 0x240402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d1b10: 0x46006328
    ctx->f[12] = std::max(ctx->f[12], ctx->f[0]);
    // 0x1d1b14: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1b18: 0xc04c1d2
    SET_GPR_U32(ctx, 31, 0x1d1b20);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EvaluateBezierMat__FfffP7MATRIX3P6VECTORT3T4T3T4T4(rdram, ctx, runtime); return;
}


// Function: entry_1d1b20
// Address: 0x1d1b20 - 0x1d1b5c

void entry_1d1b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1b20) {
        switch (ctx->pc) {
            case 0x1d1b2c: ctx->pc = 0; goto label_1d1b2c;
            case 0x1d1b4c: ctx->pc = 0; goto label_1d1b4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1b20: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d1b24: 0x10000009
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d1b4c;
    }
label_1d1b2c:
    // 0x1d1b2c: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x1d1b30: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d1b34: 0x266600d0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 208));
    // 0x1d1b38: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d1b3c: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d1b40: 0x7fa40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 4));
    // 0x1d1b44: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x1d1b48: 0x7fa20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
label_1d1b4c:
    // 0x1d1b4c: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1d1b50: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1d1b54: 0xc062454
    SET_GPR_U32(ctx, 31, 0x1d1b5c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1d1b5c
// Address: 0x1d1b5c - 0x1d1b6c

void entry_1d1b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1b5c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d1b60: 0x27a500b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1d1b64: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x1d1b6c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d1b6c
// Address: 0x1d1b6c - 0x1d1bb0

void entry_1d1b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1b6c: 0x26221858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 6232));
    // 0x1d1b70: 0xc7a000b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[0] = *(float*)&val; }
    // 0x1d1b74: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d1b78: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d1b7c: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1d1b80: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1d1b84: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d1b88: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d1b8c: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d1b90: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d1b94: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d1b98: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d1b9c: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d1ba0: 0xfa610160
    WRITE128(ADD32(GPR_U32(ctx, 19), 352), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d1ba4: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1d1ba8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtActivePipe__FP2JTP3JOY
// Address: 0x1d1bb0 - 0x1d1c20

void entry_1d1c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1c20) {
        switch (ctx->pc) {
            case 0x1d1c3c: ctx->pc = 0; goto label_1d1c3c;
            case 0x1d1c48: ctx->pc = 0; goto label_1d1c48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1c20: 0x8e442228
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    // 0x1d1c24: 0x24030017
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 23));
    // 0x1d1c28: 0x10830004
    WRITE128(ADD32(GPR_U32(ctx, 18), 9216), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_1d1c3c;
    }
    // 0x1d1c30: 0x2402001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 27));
    // 0x1d1c34: 0x54820004
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
        goto label_1d1c48;
    }
label_1d1c3c:
    // 0x1d1c3c: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d1c40: 0x10000226
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1d24dc(rdram, ctx, runtime); return;
    }
label_1d1c48:
    // 0x1d1c48: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d1c4c: 0x10400013
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d1c9c(rdram, ctx, runtime); return;
    }
    // 0x1d1c54: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1d1c58: 0xc6402410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9232)); ctx->f[0] = *(float*)&val; }
    // 0x1d1c5c: 0xc60c4f14
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20244)); ctx->f[12] = *(float*)&val; }
    // 0x1d1c60: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1d1c64: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d1c68: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1c6c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d1c74);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d1c74
// Address: 0x1d1c74 - 0x1d1c9c

void entry_1d1c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1c74: 0x8ea20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1d1c78: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d1c7c: 0x10400007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20244)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d1c9c(rdram, ctx, runtime); return;
    }
    // 0x1d1c84: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1c88: 0xc64c2410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9232)); ctx->f[12] = *(float*)&val; }
    // 0x1d1c8c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1d1c90: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1c94: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d1c9c);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d1c9c
// Address: 0x1d1c9c - 0x1d1cb0

void entry_1d1c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1c9c: 0x8e640018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x1d1ca0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d1ca4: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d1ca8: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d1cb0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d1cb0
// Address: 0x1d1cb0 - 0x1d1cc4

void entry_1d1cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1cb0: 0x8e640018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x1d1cb4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1cb8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1cbc: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d1cc4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d1cc4
// Address: 0x1d1cc4 - 0x1d1e18

void entry_1d1cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1cc4) {
        switch (ctx->pc) {
            case 0x1d1d20: ctx->pc = 0; goto label_1d1d20;
            case 0x1d1d2c: ctx->pc = 0; goto label_1d1d2c;
            case 0x1d1d84: ctx->pc = 0; goto label_1d1d84;
            case 0x1d1d8c: ctx->pc = 0; goto label_1d1d8c;
            case 0x1d1d90: ctx->pc = 0; goto label_1d1d90;
            case 0x1d1dd0: ctx->pc = 0; goto label_1d1dd0;
            case 0x1d1e0c: ctx->pc = 0; goto label_1d1e0c;
            case 0x1d1e10: ctx->pc = 0; goto label_1d1e10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1cc4: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d1cc8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d1ccc: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d1cd0: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1d1cd4: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d1cd8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1d1cdc: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1d1ce0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d1ce4: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d1ce8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d1cec: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d1cf0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d1cf4: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d1cf8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d1cfc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d1d00: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d1d04: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d1d08: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d1d0c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1d10: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d1d20;
    }
    // 0x1d1d18: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d1d2c;
    }
label_1d1d20:
    // 0x1d1d20: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d1d24: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d1d28: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1d1d2c:
    // 0x1d1d2c: 0x8e432718
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 10008)));
    // 0x1d1d30: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1d1d34: 0x1462003a
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D1E20; return;
    }
    // 0x1d1d3c: 0xc7a00048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[0] = *(float*)&val; }
    // 0x1d1d40: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d1d44: 0xc4414f08
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20232)); ctx->f[1] = *(float*)&val; }
    // 0x1d1d48: 0x46000086
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    // 0x1d1d4c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1d1d50: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1d54: 0x0
    // NOP
    // 0x1d1d58: 0x4500000d
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d1d90;
    }
    // 0x1d1d60: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d1d64: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1d68: 0x0
    // NOP
    // 0x1d1d6c: 0x45000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d1d84;
    }
    // 0x1d1d74: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d1d8c;
    }
    // 0x1d1d7c: 0x10000024
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d1e10;
    }
label_1d1d84:
    // 0x1d1d84: 0x10400021
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d1e0c;
    }
label_1d1d8c:
    // 0x1d1d8c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1d1d90:
    // 0x1d1d90: 0xc6412418
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9240)); ctx->f[1] = *(float*)&val; }
    // 0x1d1d94: 0xc4404f1c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20252)); ctx->f[0] = *(float*)&val; }
    // 0x1d1d98: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d1d9c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1da0: 0x0
    // NOP
    // 0x1d1da4: 0x4500000a
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d1dd0;
    }
    // 0x1d1dac: 0x8e42221c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
    // 0x1d1db0: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d1dd0;
    }
    // 0x1d1db8: 0xc4404f0c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20236)); ctx->f[0] = *(float*)&val; }
    // 0x1d1dbc: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1d1dc0: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1dc4: 0x0
    // NOP
    // 0x1d1dc8: 0x45010010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d1e0c;
    }
label_1d1dd0:
    // 0x1d1dd0: 0xc4604f1c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20252)); ctx->f[0] = *(float*)&val; }
    // 0x1d1dd4: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1d1dd8: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1ddc: 0x0
    // NOP
    // 0x1d1de0: 0x45020010
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 104)));
        ctx->pc = 0x1D1E24; return;
    }
    // 0x1d1de8: 0x8e42221c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
    // 0x1d1dec: 0x5440000d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 104)));
        ctx->pc = 0x1D1E24; return;
    }
    // 0x1d1df4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d1df8: 0xc4404f0c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20236)); ctx->f[0] = *(float*)&val; }
    // 0x1d1dfc: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1e00: 0x0
    // NOP
    // 0x1d1e04: 0x45000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D1E20; return;
    }
label_1d1e0c:
    // 0x1d1e0c: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
label_1d1e10:
    // 0x1d1e10: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d1e18);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 27));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d1e18
// Address: 0x1d1e18 - 0x1d1e40

void entry_1d1e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1e18) {
        switch (ctx->pc) {
            case 0x1d1e20: ctx->pc = 0; goto label_1d1e20;
            case 0x1d1e24: ctx->pc = 0; goto label_1d1e24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1e18: 0x100001b1
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D24E0; return;
    }
label_1d1e20:
    // 0x1d1e20: 0x8e620068
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 104)));
label_1d1e24:
    // 0x1d1e24: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 2), 24)));
        ctx->pc = 0x1D1E58; return;
    }
    // 0x1d1e2c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1d1e30: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d1e34: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1d1e38: 0xc051070
    SET_GPR_U32(ctx, 31, 0x1d1e40);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_1d1e40
// Address: 0x1d1e40 - 0x1d1e50

void entry_1d1e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1e40: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1d1e44: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1e48: 0xc051070
    SET_GPR_U32(ctx, 31, 0x1d1e50);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_1d1e50
// Address: 0x1d1e50 - 0x1d1e74

void entry_1d1e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1e50) {
        switch (ctx->pc) {
            case 0x1d1e58: ctx->pc = 0; goto label_1d1e58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1e50: 0x1000004e
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D1F8C; return;
    }
label_1d1e58:
    // 0x1d1e58: 0x27a70050
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1d1e5c: 0x8c500034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1d1e60: 0xe0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1d1e64: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1e68: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d1e6c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d1e74);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 320));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d1e74
// Address: 0x1d1e74 - 0x1d1ea0

void entry_1d1e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1e74: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d1e78: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x1d1e7c: 0x10400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d1ea0(rdram, ctx, runtime); return;
    }
    // 0x1d1e84: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1e88: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1e8c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1e90: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1e94: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1e98: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d1ea0);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d1ea0
// Address: 0x1d1ea0 - 0x1d1eb0

void entry_1d1ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1ea0: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d1ea4: 0x8c430020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1d1ea8: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1d1eb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1d1eb0
// Address: 0x1d1eb0 - 0x1d1f10

void entry_1d1eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1eb0) {
        switch (ctx->pc) {
            case 0x1d1ed8: ctx->pc = 0; goto label_1d1ed8;
            case 0x1d1ee8: ctx->pc = 0; goto label_1d1ee8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1eb0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d1eb4: 0xc7a10070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[1] = *(float*)&val; }
    // 0x1d1eb8: 0xc44c4f14
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20244)); ctx->f[12] = *(float*)&val; }
    // 0x1d1ebc: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d1ec0: 0x460c0834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1ec4: 0x0
    // NOP
    // 0x1d1ec8: 0x45000003
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d1ed8;
    }
    // 0x1d1ed0: 0x10000005
    ctx->f[1] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d1ee8;
    }
label_1d1ed8:
    // 0x1d1ed8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1edc: 0x0
    // NOP
    // 0x1d1ee0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[0]);
        goto label_1d1ee8;
    }
label_1d1ee8:
    // 0x1d1ee8: 0xe7a10070
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
    // 0x1d1eec: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d1ef0: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d1ef4: 0x10400006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 20244)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d1f10(rdram, ctx, runtime); return;
    }
    // 0x1d1efc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d1f00: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1f04: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1f08: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d1f10);
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[12]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d1f10
// Address: 0x1d1f10 - 0x1d1f2c

void entry_1d1f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1f10: 0x27b30060
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1d1f14: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d1f18: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1f1c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1f20: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d1f24: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d1f2c);
    SET_GPR_U32(ctx, 23, ((uint32_t)38 << 16));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d1f2c
// Address: 0x1d1f2c - 0x1d1f3c

void entry_1d1f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1f2c: 0x8ee41990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 23), 6544)));
    // 0x1d1f30: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1f34: 0xc051070
    SET_GPR_U32(ctx, 31, 0x1d1f3c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_1d1f3c
// Address: 0x1d1f3c - 0x1d1f64

void entry_1d1f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1f3c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d1f40: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d1f44: 0x10400007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 20244)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d1f64(rdram, ctx, runtime); return;
    }
    // 0x1d1f4c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d1f50: 0xc7ac0070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[12] = *(float*)&val; }
    // 0x1d1f54: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1f58: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1f5c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d1f64);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d1f64
// Address: 0x1d1f64 - 0x1d1f78

void entry_1d1f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1f64: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d1f68: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d1f6c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1f70: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d1f78);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d1f78
// Address: 0x1d1f78 - 0x1d1f88

void entry_1d1f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d1f78: 0x8ee41990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 23), 6544)));
    // 0x1d1f7c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d1f80: 0xc051070
    SET_GPR_U32(ctx, 31, 0x1d1f88);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_1d1f88
// Address: 0x1d1f88 - 0x1d2388

void entry_1d1f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d1f88) {
        switch (ctx->pc) {
            case 0x1d1f8c: ctx->pc = 0; goto label_1d1f8c;
            case 0x1d1ff0: ctx->pc = 0; goto label_1d1ff0;
            case 0x1d1ffc: ctx->pc = 0; goto label_1d1ffc;
            case 0x1d201c: ctx->pc = 0; goto label_1d201c;
            case 0x1d2034: ctx->pc = 0; goto label_1d2034;
            case 0x1d204c: ctx->pc = 0; goto label_1d204c;
            case 0x1d20c4: ctx->pc = 0; goto label_1d20c4;
            case 0x1d20d4: ctx->pc = 0; goto label_1d20d4;
            case 0x1d2124: ctx->pc = 0; goto label_1d2124;
            case 0x1d2134: ctx->pc = 0; goto label_1d2134;
            case 0x1d2170: ctx->pc = 0; goto label_1d2170;
            case 0x1d21ac: ctx->pc = 0; goto label_1d21ac;
            case 0x1d21e0: ctx->pc = 0; goto label_1d21e0;
            case 0x1d21e4: ctx->pc = 0; goto label_1d21e4;
            case 0x1d21e8: ctx->pc = 0; goto label_1d21e8;
            case 0x1d220c: ctx->pc = 0; goto label_1d220c;
            case 0x1d221c: ctx->pc = 0; goto label_1d221c;
            case 0x1d2228: ctx->pc = 0; goto label_1d2228;
            case 0x1d2230: ctx->pc = 0; goto label_1d2230;
            case 0x1d2234: ctx->pc = 0; goto label_1d2234;
            case 0x1d2240: ctx->pc = 0; goto label_1d2240;
            case 0x1d2248: ctx->pc = 0; goto label_1d2248;
            case 0x1d2294: ctx->pc = 0; goto label_1d2294;
            case 0x1d22a0: ctx->pc = 0; goto label_1d22a0;
            case 0x1d22a8: ctx->pc = 0; goto label_1d22a8;
            case 0x1d2338: ctx->pc = 0; goto label_1d2338;
            case 0x1d2358: ctx->pc = 0; goto label_1d2358;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d1f88: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1d1f8c:
    // 0x1d1f8c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d1f90: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d1f94: 0x24428d10
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937872));
    // 0x1d1f98: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d1f9c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1d1fa0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1d1fa4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d1fa8: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d1fac: 0xafa00048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 0));
    // 0x1d1fb0: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d1fb4: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d1fb8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d1fbc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d1fc0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d1fc4: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d1fc8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d1fcc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d1fd0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d1fd4: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d1fd8: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1d1fdc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d1fe0: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d1ff0;
    }
    // 0x1d1fe8: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d1ffc;
    }
label_1d1ff0:
    // 0x1d1ff0: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d1ff4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d1ff8: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1d1ffc:
    // 0x1d1ffc: 0x8e432718
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 10008)));
    // 0x1d2000: 0x10600006
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1d201c;
    }
    // 0x1d2008: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d200c: 0x10620009
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 124)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d2034;
    }
    // 0x1d2014: 0x1000000d
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d204c;
    }
label_1d201c:
    // 0x1d201c: 0x8e43221c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
    // 0x1d2020: 0x24160019
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 25));
    // 0x1d2024: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d2028: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1d202c: 0x10000081
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 26));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2234;
    }
label_1d2034:
    // 0x1d2034: 0x8e43221c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
    // 0x1d2038: 0x2416001a
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 26));
    // 0x1d203c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d2040: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1d2044: 0x1000007b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 25));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2234;
    }
label_1d204c:
    // 0x1d204c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d2050: 0x24438d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1d2054: 0xc4a20044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 68)); ctx->f[2] = *(float*)&val; }
    // 0x1d2058: 0xc4a10040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 64)); ctx->f[1] = *(float*)&val; }
    // 0x1d205c: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1d2060: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x1d2064: 0x70442488
    SET_GPR_VEC(ctx, 4, PS2_PEXTLW(GPR_VEC(ctx, 2), GPR_VEC(ctx, 4)));
    // 0x1d2068: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d206c: 0x70442389
    SET_GPR_VEC(ctx, 4, _mm_unpacklo_epi64(GPR_VEC(ctx, 2), GPR_VEC(ctx, 4)));
    // 0x1d2070: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1d2074: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1d2078: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1d207c: 0x48a41800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1d2080: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d2084: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d2088: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d208c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d2090: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d2094: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d2098: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d209c: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d20a0: 0xfba30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d20a4: 0x48251000
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d20a8: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x1d20ac: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d20b0: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d20c4;
    }
    // 0x1d20b8: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d20bc: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d20d4;
    }
label_1d20c4:
    // 0x1d20c4: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d20c8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d20cc: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1d20d0: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
label_1d20d4:
    // 0x1d20d4: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d20d8: 0x8e43241c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9244)));
    // 0x1d20dc: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d20e0: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1d20e4: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d20e8: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d20ec: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d20f0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d20f4: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d20f8: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d20fc: 0x44841800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 4);
    // 0x1d2100: 0x1060000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1d2134;
    }
    // 0x1d2108: 0x1c600006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 3) > 0) {
        goto label_1d2124;
    }
    // 0x1d2110: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1d2114: 0x10620025
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d21ac;
    }
    // 0x1d211c: 0x10000032
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d21e8;
    }
label_1d2124:
    // 0x1d2124: 0x10620012
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d2170;
    }
    // 0x1d212c: 0x1000002e
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9244)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d21e8;
    }
label_1d2134:
    // 0x1d2134: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1d2138: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d213c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d2140: 0x0
    // NOP
    // 0x1d2144: 0x45010026
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d21e0;
    }
    // 0x1d214c: 0x3c01bf33
    SET_GPR_U32(ctx, 1, ((uint32_t)48947 << 16));
    // 0x1d2150: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1d2154: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d2158: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d215c: 0x0
    // NOP
    // 0x1d2160: 0x45000020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d21e4;
    }
    // 0x1d2168: 0x1000001e
    WRITE32(ADD32(GPR_U32(ctx, 18), 9244), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d21e4;
    }
label_1d2170:
    // 0x1d2170: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1d2174: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d2178: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d217c: 0x0
    // NOP
    // 0x1d2180: 0x45010017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d21e0;
    }
    // 0x1d2188: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1d218c: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1d2190: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d2194: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d2198: 0x0
    // NOP
    // 0x1d219c: 0x45020012
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9244)));
        goto label_1d21e8;
    }
    // 0x1d21a4: 0x1000000f
    WRITE32(ADD32(GPR_U32(ctx, 18), 9244), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d21e4;
    }
label_1d21ac:
    // 0x1d21ac: 0x3c013eb3
    SET_GPR_U32(ctx, 1, ((uint32_t)16051 << 16));
    // 0x1d21b0: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1d21b4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d21b8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d21bc: 0x0
    // NOP
    // 0x1d21c0: 0x45020009
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9244)));
        goto label_1d21e8;
    }
    // 0x1d21c8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d21cc: 0x46030036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d21d0: 0x0
    // NOP
    // 0x1d21d4: 0x45030003
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 9244), GPR_U32(ctx, 0));
        goto label_1d21e4;
    }
    // 0x1d21dc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1d21e0:
    // 0x1d21e0: 0xae42241c
    WRITE32(ADD32(GPR_U32(ctx, 18), 9244), GPR_U32(ctx, 2));
label_1d21e4:
    // 0x1d21e4: 0x8e43241c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9244)));
label_1d21e8:
    // 0x1d21e8: 0x5060000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
        goto label_1d221c;
    }
    // 0x1d21f0: 0x1c600006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 3) > 0) {
        goto label_1d220c;
    }
    // 0x1d21f8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1d21fc: 0x50620010
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 24));
        goto label_1d2240;
    }
    // 0x1d2204: 0x10000010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2248;
    }
label_1d220c:
    // 0x1d220c: 0x50620006
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
        goto label_1d2228;
    }
    // 0x1d2214: 0x1000000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2248;
    }
label_1d221c:
    // 0x1d221c: 0x24160019
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 25));
    // 0x1d2220: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 26));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2230;
    }
label_1d2228:
    // 0x1d2228: 0x2416001a
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 26));
    // 0x1d222c: 0x24020019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 25));
label_1d2230:
    // 0x1d2230: 0x460008c6
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
label_1d2234:
    // 0x1d2234: 0x43b00b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 22, GPR_U32(ctx, 2));
    // 0x1d2238: 0x10000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2248;
    }
label_1d2240:
    // 0x1d2240: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1d2244: 0x8e44221c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
label_1d2248:
    // 0x1d2248: 0x3c013c23
    SET_GPR_U32(ctx, 1, ((uint32_t)15395 << 16));
    // 0x1d224c: 0x3421d70a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55050));
    // 0x1d2250: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d2254: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d2258: 0x0
    // NOP
    // 0x1d225c: 0x4500000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 26));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d2294;
    }
    // 0x1d2264: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d2268: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d226c: 0xc6411058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4184)); ctx->f[1] = *(float*)&val; }
    // 0x1d2270: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1d2274: 0xc6421048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4168)); ctx->f[2] = *(float*)&val; }
    // 0x1d2278: 0x460118c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1d227c: 0x46000946
    ctx->f[5] = FPU_MOV_S(ctx->f[1]);
    // 0x1d2280: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1d2284: 0x16c20006
    ctx->f[20] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 2)) {
        goto label_1d22a0;
    }
    // 0x1d228c: 0x10000004
    ctx->f[20] = FPU_NEG_S(ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d22a0;
    }
label_1d2294:
    // 0x1d2294: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1d2298: 0x24160018
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1d229c: 0xc6451058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4184)); ctx->f[5] = *(float*)&val; }
label_1d22a0:
    // 0x1d22a0: 0x54800001
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->f[20] = FPU_NEG_S(ctx->f[20]);
        goto label_1d22a8;
    }
label_1d22a8:
    // 0x1d22a8: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x1d22ac: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d22b0: 0x24a31858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 6232));
    // 0x1d22b4: 0xc4414f18
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20248)); ctx->f[1] = *(float*)&val; }
    // 0x1d22b8: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1d22bc: 0x46002945
    ctx->f[5] = FPU_ABS_S(ctx->f[5]);
    // 0x1d22c0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d22c4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1d22c8: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1d22cc: 0xc6442418
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9240)); ctx->f[4] = *(float*)&val; }
    // 0x1d22d0: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1d22d4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1d22d8: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1d22dc: 0xe7a50050
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x1d22e0: 0x46000807
    ctx->f[0] = FPU_NEG_S(ctx->f[1]);
    // 0x1d22e4: 0xe7a30058
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 88), *(uint32_t*)&val); }
    // 0x1d22e8: 0x46011081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    // 0x1d22ec: 0xafa00054
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 0));
    // 0x1d22f0: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1d22f4: 0x46041082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x1d22f8: 0x46050003
    if (ctx->f[5] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[5];
    // 0x1d22fc: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1d2300: 0xe6402418
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9240), *(uint32_t*)&val); }
    // 0x1d2304: 0x8ea20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 8)));
    // 0x1d2308: 0x54400033
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_NEG_S(ctx->f[20]);
        ctx->pc = 0x1D23D8; return;
    }
    // 0x1d2310: 0x10800009
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1d2338;
    }
    // 0x1d2318: 0x8ea2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 12)));
    // 0x1d231c: 0x8ea50014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 21), 20)));
    // 0x1d2320: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d2324: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1d2328: 0xc4634f00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20224)); ctx->f[3] = *(float*)&val; }
    // 0x1d232c: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1d2330: 0x10000009
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 20228)); ctx->f[2] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2358;
    }
label_1d2338:
    // 0x1d2338: 0x8ea2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 12)));
    // 0x1d233c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d2340: 0x8ea50014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 21), 20)));
    // 0x1d2344: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d2348: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1d234c: 0xc4634f04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20228)); ctx->f[3] = *(float*)&val; }
    // 0x1d2350: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1d2354: 0xc4824f00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 20224)); ctx->f[2] = *(float*)&val; }
label_1d2358:
    // 0x1d2358: 0xc440fffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[0] = *(float*)&val; }
    // 0x1d235c: 0xc4a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1d2360: 0x46020541
    ctx->f[21] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1d2364: 0x46030b40
    ctx->f[13] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x1d2368: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d236c: 0x27b10050
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1d2370: 0x24501858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1d2374: 0xc64c2410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9232)); ctx->f[12] = *(float*)&val; }
    // 0x1d2378: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1d237c: 0x27a50074
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 116));
    // 0x1d2380: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d2388);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d2388
// Address: 0x1d2388 - 0x1d23a0

void entry_1d2388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2388: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1d238c: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1d2390: 0xc64c2410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9232)); ctx->f[12] = *(float*)&val; }
    // 0x1d2394: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d2398: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d23a0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 120));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d23a0
// Address: 0x1d23a0 - 0x1d2414

void entry_1d23a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d23a0) {
        switch (ctx->pc) {
            case 0x1d23c4: ctx->pc = 0; goto label_1d23c4;
            case 0x1d23d4: ctx->pc = 0; goto label_1d23d4;
            case 0x1d23d8: ctx->pc = 0; goto label_1d23d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d23a0: 0xc7a10078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[1] = *(float*)&val; }
    // 0x1d23a4: 0xc7a00074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 116)); ctx->f[0] = *(float*)&val; }
    // 0x1d23a8: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x1d23ac: 0x4601a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d23b0: 0x0
    // NOP
    // 0x1d23b4: 0x45000003
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d23c4;
    }
    // 0x1d23bc: 0x10000005
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d23d4;
    }
label_1d23c4:
    // 0x1d23c4: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d23c8: 0x0
    // NOP
    // 0x1d23cc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[20] = FPU_MOV_S(ctx->f[0]);
        goto label_1d23d4;
    }
label_1d23d4:
    // 0x1d23d4: 0x4600a047
    ctx->f[1] = FPU_NEG_S(ctx->f[20]);
label_1d23d8:
    // 0x1d23d8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d23dc: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1d23e0: 0xc6422410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9232)); ctx->f[2] = *(float*)&val; }
    // 0x1d23e4: 0xe6412414
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 9236), *(uint32_t*)&val); }
    // 0x1d23e8: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1d23ec: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1d23f0: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1d23f4: 0xe6422410
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 18), 9232), *(uint32_t*)&val); }
    // 0x1d23f8: 0x8ea20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 8)));
    // 0x1d23fc: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[2] = FPU_ABS_S(ctx->f[20]);
        ctx->pc = 0x1D2428; return;
    }
    // 0x1d2404: 0x8ea30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1d2408: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1d240c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d2414);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d2414
// Address: 0x1d2414 - 0x1d2420

void entry_1d2414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2414: 0xc64c2410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9232)); ctx->f[12] = *(float*)&val; }
    // 0x1d2418: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1d2420);
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d2420
// Address: 0x1d2420 - 0x1d2450

void entry_1d2420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2420) {
        switch (ctx->pc) {
            case 0x1d2428: ctx->pc = 0; goto label_1d2428;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2420: 0xe6402410
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9232), *(uint32_t*)&val); }
    // 0x1d2424: 0x4600a085
    ctx->f[2] = FPU_ABS_S(ctx->f[20]);
label_1d2428:
    // 0x1d2428: 0x3c013c23
    SET_GPR_U32(ctx, 1, ((uint32_t)15395 << 16));
    // 0x1d242c: 0x3421d70a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55050));
    // 0x1d2430: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d2434: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d2438: 0x0
    // NOP
    // 0x1d243c: 0x45000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D2458; return;
    }
    // 0x1d2444: 0x24160018
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 24));
    // 0x1d2448: 0xc0749f0
    SET_GPR_U32(ctx, 31, 0x1d2450);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtpdk__FP2JT5JTPDK(rdram, ctx, runtime); return;
}


// Function: entry_1d2450
// Address: 0x1d2450 - 0x1d24cc

void entry_1d2450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2450) {
        switch (ctx->pc) {
            case 0x1d2458: ctx->pc = 0; goto label_1d2458;
            case 0x1d2494: ctx->pc = 0; goto label_1d2494;
            case 0x1d24a4: ctx->pc = 0; goto label_1d24a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2450: 0x1000001f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D24D0; return;
    }
label_1d2458:
    // 0x1d2458: 0xc6401048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4168)); ctx->f[0] = *(float*)&val; }
    // 0x1d245c: 0xc6411058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4184)); ctx->f[1] = *(float*)&val; }
    // 0x1d2460: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1d2464: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d2468: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x1d246c: 0x46000845
    ctx->f[1] = FPU_ABS_S(ctx->f[1]);
    // 0x1d2470: 0x44802000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 0);
    // 0x1d2474: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1d2478: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1d247c: 0x460110c3
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[3] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[3] = ctx->f[2] / ctx->f[1];
    // 0x1d2480: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d2484: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d2494;
    }
    // 0x1d248c: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d24a4;
    }
label_1d2494:
    // 0x1d2494: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d2498: 0x0
    // NOP
    // 0x1d249c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_1d24a4;
    }
label_1d24a4:
    // 0x1d24a4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d24a8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d24ac: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1d24b0: 0x8e44105c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4188)));
    // 0x1d24b4: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d24b8: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1d24bc: 0xe643104c
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 18), 4172), *(uint32_t*)&val); }
    // 0x1d24c0: 0x2647103c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 4156));
    // 0x1d24c4: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x1d24cc);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 4156), *(uint32_t*)&val); }
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_1d24cc
// Address: 0x1d24cc - 0x1d24dc

void entry_1d24cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d24cc) {
        switch (ctx->pc) {
            case 0x1d24d0: ctx->pc = 0; goto label_1d24d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d24cc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1d24d0:
    // 0x1d24d0: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1d24d4: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d24dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d24dc
// Address: 0x1d24dc - 0x1d2518

void entry_1d24dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d24dc) {
        switch (ctx->pc) {
            case 0x1d24e0: ctx->pc = 0; goto label_1d24e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d24dc: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
label_1d24e0:
    // 0x1d24e0: 0x7bbe0100
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1d24e4: 0x7bb700f0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1d24e8: 0x7bb600e0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d24ec: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d24f0: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d24f4: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d24f8: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d24fc: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d2500: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d2504: 0xc7b50128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 296)); ctx->f[21] = *(float*)&val; }
    // 0x1d2508: 0xc7b40120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[20] = *(float*)&val; }
    // 0x1d250c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d2514: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d2518; return;
}


// Function: UpdateJtInternalXpsPipe__FP2JT
// Address: 0x1d2518 - 0x1d25e4

void entry_1d25e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d25e4: 0x8e022208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8712)));
    // 0x1d25e8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d25ec: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d25f0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d25f4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d25fc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d25fc
// Address: 0x1d25fc - 0x1d2614

void entry_1d25fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d25fc: 0x8e022208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8712)));
    // 0x1d2600: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d2604: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d2608: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d260c: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1d2614);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d2614
// Address: 0x1d2614 - 0x1d2694

void entry_1d2614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2614) {
        switch (ctx->pc) {
            case 0x1d2668: ctx->pc = 0; goto label_1d2668;
            case 0x1d2674: ctx->pc = 0; goto label_1d2674;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2614: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d2618: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1d261c: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d2620: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d2624: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d2628: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d262c: 0x24628d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294937888));
    // 0x1d2630: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d2634: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d2638: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d263c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1d2640: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1d2644: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d2648: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d264c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d2650: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d2654: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d2658: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d2668;
    }
    // 0x1d2660: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2674;
    }
label_1d2668:
    // 0x1d2668: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d266c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d2670: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1d2674:
    // 0x1d2674: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1d2678: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d267c: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d2680: 0x24678d20
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 3), 4294937888));
    // 0x1d2684: 0x24468d00
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1d2688: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d268c: 0xc07b5e0
    SET_GPR_U32(ctx, 31, 0x1d2694);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    GetNormalVectors__FP6VECTORN30(rdram, ctx, runtime); return;
}


// Function: entry_1d2694
// Address: 0x1d2694 - 0x1d26a8

void entry_1d2694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2694: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1d2698: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d269c: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d26a0: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d26a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d26a8
// Address: 0x1d26a8 - 0x1d2700

void entry_1d26a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d26a8: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d26ac: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d26b0: 0xda032400
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 9216)));
    // 0x1d26b4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d26b8: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d26bc: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d26c0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d26c4: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d26c8: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d26cc: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d26d0: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d26d4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d26d8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d26dc: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d26e0: 0x280582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d26e4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d26e8: 0x2408000b
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1d26ec: 0x8ec50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 22), 24)));
    // 0x1d26f0: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1d26f4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d26f8: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1d2700);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1d2700
// Address: 0x1d2700 - 0x1d2744

void entry_1d2700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2700: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d2704: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1d2708: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d270c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d2710: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d2714: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d2718: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d271c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d2720: 0x8ec50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 22), 24)));
    // 0x1d2724: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d2728: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d272c: 0x44836000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 3);
    // 0x1d2730: 0x280582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d2734: 0x2408000b
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1d2738: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d273c: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1d2744);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1d2744
// Address: 0x1d2744 - 0x1d2788

void entry_1d2744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2744: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d2748: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d274c: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d2750: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d2754: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d2758: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d275c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d2760: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d2764: 0x8ec50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 22), 24)));
    // 0x1d2768: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d276c: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d2770: 0x280582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d2774: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1d2778: 0x2408000b
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1d277c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d2780: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1d2788);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1d2788
// Address: 0x1d2788 - 0x1d27c0

void entry_1d2788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2788: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1d278c: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1d2790: 0xaee30000
    WRITE32(ADD32(GPR_U32(ctx, 23), 0), GPR_U32(ctx, 3));
    // 0x1d2794: 0x7bbe00e0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d2798: 0x7bb700d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d279c: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d27a0: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d27a4: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d27a8: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d27ac: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d27b0: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d27b4: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d27b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetJtJtpdk__FP2JT5JTPDK
// Address: 0x1d27c0 - 0x1d27f8

void entry_1d27f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d27f8: 0xc0776d6
    SET_GPR_U32(ctx, 31, 0x1d2800);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    FUN_001ddb58(rdram, ctx, runtime); return;
}


// Function: entry_1d2800
// Address: 0x1d2800 - 0x1d2810

void entry_1d2800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2800: 0x16320005
    WRITE32(ADD32(GPR_U32(ctx, 16), 10008), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 18)) {
        entry_1d2818(rdram, ctx, runtime); return;
    }
    // 0x1d2808: 0xc077694
    SET_GPR_U32(ctx, 31, 0x1d2810);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    DecrementSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1d2810
// Address: 0x1d2810 - 0x1d2818

void entry_1d2810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2810: 0xc0776ee
    SET_GPR_U32(ctx, 31, 0x1d2818);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    FUN_001ddbb8(rdram, ctx, runtime); return;
}


// Function: entry_1d2818
// Address: 0x1d2818 - 0x1d2830

void entry_1d2818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2818: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d281c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d2820: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d2824: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d2828: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PlaceJtOnPipe__FP2JTP4PIPE
// Address: 0x1d2830 - 0x1d2874

void entry_1d2874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2874: 0x8e442208
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x1d2878: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d287c: 0x8c620070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x1d2880: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d2888);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d2888
// Address: 0x1d2888 - 0x1d289c

void entry_1d2888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2888: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d288c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d2890: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d2894: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1d289c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1d289c
// Address: 0x1d289c - 0x1d28b0

void entry_1d289c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d289c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d28a0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d28a4: 0x8c62006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 108)));
    // 0x1d28a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d28b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d28b0
// Address: 0x1d28b0 - 0x1d28d0

void entry_1d28b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d28b0) {
        switch (ctx->pc) {
            case 0x1d28b4: ctx->pc = 0; goto label_1d28b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d28b0: 0xae512208
    WRITE32(ADD32(GPR_U32(ctx, 18), 8712), GPR_U32(ctx, 17));
label_1d28b4:
    // 0x1d28b4: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d28b8: 0xae402204
    WRITE32(ADD32(GPR_U32(ctx, 18), 8708), GPR_U32(ctx, 0));
    // 0x1d28bc: 0x26460140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 320));
    // 0x1d28c0: 0xae402200
    WRITE32(ADD32(GPR_U32(ctx, 18), 8704), GPR_U32(ctx, 0));
    // 0x1d28c4: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d28c8: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d28d0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d28d0
// Address: 0x1d28d0 - 0x1d28fc

void entry_1d28d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d28d0: 0x8e240034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1d28d4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d28d8: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x1d28dc: 0x10400007
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d28fc(rdram, ctx, runtime); return;
    }
    // 0x1d28e4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d28e8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d28ec: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d28f0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d28f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d28fc);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 18), 8716));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d28fc
// Address: 0x1d28fc - 0x1d2914

void entry_1d28fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d28fc: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d2900: 0xc64c220c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8716)); ctx->f[12] = *(float*)&val; }
    // 0x1d2904: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d2908: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d290c: 0xc07458c
    SET_GPR_U32(ctx, 31, 0x1d2914);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetJtPipeGoalMat__FP2JTP4PIPEfP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1d2914
// Address: 0x1d2914 - 0x1d2928

void entry_1d2914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2914: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d2918: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d291c: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1d2920: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d2928);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d2928
// Address: 0x1d2928 - 0x1d294c

void entry_1d2928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2928: 0x8e240034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1d292c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d2930: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d2934: 0x10400006
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2950; return;
    }
    // 0x1d293c: 0xc64c220c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8716)); ctx->f[12] = *(float*)&val; }
    // 0x1d2940: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d2944: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d294c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d294c
// Address: 0x1d294c - 0x1d2964

void entry_1d294c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d294c) {
        switch (ctx->pc) {
            case 0x1d2950: ctx->pc = 0; goto label_1d2950;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d294c: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
label_1d2950:
    // 0x1d2950: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1d2954: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d2958: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d295c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d2964);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d2964
// Address: 0x1d2964 - 0x1d298c

void entry_1d2964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2964: 0xda4223e0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 9184)));
    // 0x1d2968: 0x27b10050
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1d296c: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d2970: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d2974: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d2978: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d297c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d2980: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d2984: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d298c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d298c
// Address: 0x1d298c - 0x1d29a0

void entry_1d298c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d298c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d2990: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d2994: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1d2998: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d29a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d29a0
// Address: 0x1d29a0 - 0x1d29b0

void entry_1d29a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d29a0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d29a4: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1d29a8: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d29b0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 23));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d29b0
// Address: 0x1d29b0 - 0x1d29c8

void entry_1d29b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d29b0: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d29b4: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d29b8: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d29bc: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d29c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetFsp__F3FSP
// Address: 0x1d29c8 - 0x1d2a3c

void entry_1d2a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2a3c) {
        switch (ctx->pc) {
            case 0x1d2a44: ctx->pc = 0; goto label_1d2a44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2a3c: 0x10000011
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2A84; return;
    }
label_1d2a44:
    // 0x1d2a44: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d2a48: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1d2a4c: 0x10800026
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2AE8; return;
    }
    // 0x1d2a54: 0x8c841518
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 5400)));
    // 0x1d2a58: 0x5080000a
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
        ctx->pc = 0x1D2A84; return;
    }
    // 0x1d2a60: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1d2a68);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1d2a68
// Address: 0x1d2a68 - 0x1d2a80

void entry_1d2a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2a68: 0x10400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d2a80(rdram, ctx, runtime); return;
    }
    // 0x1d2a70: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1d2a74: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d2a78: 0xc049b58
    SET_GPR_U32(ctx, 31, 0x1d2a80);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 5400)));
    FadeAloOut__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_1d2a80
// Address: 0x1d2a80 - 0x1d2aa8

void entry_1d2a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2a80) {
        switch (ctx->pc) {
            case 0x1d2a84: ctx->pc = 0; goto label_1d2a84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2a80: 0x8e642e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
label_1d2a84:
    // 0x1d2a84: 0x10800018
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2AE8; return;
    }
    // 0x1d2a8c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d2a90: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d2a94: 0x8c842750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 10064)));
    // 0x1d2a98: 0x10800008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 6228), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1d2abc(rdram, ctx, runtime); return;
    }
    // 0x1d2aa0: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1d2aa8);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1d2aa8
// Address: 0x1d2aa8 - 0x1d2abc

void entry_1d2aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2aa8: 0x10400004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d2abc(rdram, ctx, runtime); return;
    }
    // 0x1d2ab0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d2ab4: 0xc074cb6
    SET_GPR_U32(ctx, 31, 0x1d2abc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 10064)));
    func_001D32D8__FiP2JTl(rdram, ctx, runtime); return;
}


// Function: entry_1d2abc
// Address: 0x1d2abc - 0x1d2ac8

void entry_1d2abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2abc: 0x8e642e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    // 0x1d2ac0: 0xc074c74
    SET_GPR_U32(ctx, 31, 0x1d2ac8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    func_001D31D0__FP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_1d2ac8
// Address: 0x1d2ac8 - 0x1d2adc

void entry_1d2ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2ac8: 0x8e622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    // 0x1d2acc: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2AEC; return;
    }
    // 0x1d2ad4: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1d2adc);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d2adc
// Address: 0x1d2adc - 0x1d2b20

void entry_1d2adc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2adc) {
        switch (ctx->pc) {
            case 0x1d2ae8: ctx->pc = 0; goto label_1d2ae8;
            case 0x1d2aec: ctx->pc = 0; goto label_1d2aec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2adc: 0x8e632e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    // 0x1d2ae0: 0x50620001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 20340), GPR_U32(ctx, 18));
        goto label_1d2ae8;
    }
label_1d2ae8:
    // 0x1d2ae8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1d2aec:
    // 0x1d2aec: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1d2af0: 0x8c6419fc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6652)));
    // 0x1d2af4: 0x12440028
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x1D2B98; return;
    }
    // 0x1d2afc: 0x2e420007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 7));
    // 0x1d2b00: 0x10400025
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2B98; return;
    }
    // 0x1d2b08: 0x8e632e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    // 0x1d2b0c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d2b10: 0x10600008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294962288));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2B34; return;
    }
    // 0x1d2b18: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1d2b20);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d2b20
// Address: 0x1d2b20 - 0x1d2b44

void entry_1d2b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2b20) {
        switch (ctx->pc) {
            case 0x1d2b34: ctx->pc = 0; goto label_1d2b34;
            case 0x1d2b3c: ctx->pc = 0; goto label_1d2b3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2b20: 0x8e632e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    // 0x1d2b24: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1d2b28: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d2b2c: 0x10620003
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d2b3c;
    }
label_1d2b34:
    // 0x1d2b34: 0x3c014100
    SET_GPR_U32(ctx, 1, ((uint32_t)16640 << 16));
    // 0x1d2b38: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
label_1d2b3c:
    // 0x1d2b3c: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1d2b44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1d2b44
// Address: 0x1d2b44 - 0x1d2b5c

void entry_1d2b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2b44: 0x2630ec70
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294962288));
    // 0x1d2b48: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x1d2b4c: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1d2b50: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d2b54: 0xc06a9e2
    SET_GPR_U32(ctx, 31, 0x1d2b5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotFontScale__FfP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1d2b5c
// Address: 0x1d2b5c - 0x1d2b80

void entry_1d2b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2b5c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d2b60: 0x8e24ec70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294962288)));
    // 0x1d2b64: 0x24634f58
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 20312));
    // 0x1d2b68: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x1d2b6c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1d2b70: 0x8c860020
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x1d2b74: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d2b78: 0xc0f809
    SET_GPR_U32(ctx, 31, 0x1d2b80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 6); return;
}


// Function: entry_1d2b80
// Address: 0x1d2b80 - 0x1d2b90

void entry_1d2b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2b80: 0x8e23ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294962288)));
    // 0x1d2b84: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1d2b88: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d2b90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d2b90
// Address: 0x1d2b90 - 0x1d2bb8

void entry_1d2b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2b90) {
        switch (ctx->pc) {
            case 0x1d2b98: ctx->pc = 0; goto label_1d2b98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2b90: 0x8e8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 9152)));
    // 0x1d2b94: 0xac7219fc
    WRITE32(ADD32(GPR_U32(ctx, 3), 6652), GPR_U32(ctx, 18));
label_1d2b98:
    // 0x1d2b98: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d2b9c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d2ba0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d2ba4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d2ba8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d2bac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d2bb0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtActivePowerUp__FP2JTP3JOY
// Address: 0x1d2bb8 - 0x1d2bf4

void entry_1d2bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2bf4: 0x8e654f74
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 20340)));
    // 0x1d2bf8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d2bfc: 0x24844f38
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 20280));
    // 0x1d2c00: 0x52880
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1d2c04: 0xa42821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x1d2c08: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1d2c0c: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1d2c10: 0x14600008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 20340)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2C34; return;
    }
    // 0x1d2c18: 0xc074a72
    SET_GPR_U32(ctx, 31, 0x1d2c20);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetFsp__F3FSP(rdram, ctx, runtime); return;
}


// Function: entry_1d2c20
// Address: 0x1d2c20 - 0x1d2c8c

void entry_1d2c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2c20) {
        switch (ctx->pc) {
            case 0x1d2c30: ctx->pc = 0; goto label_1d2c30;
            case 0x1d2c34: ctx->pc = 0; goto label_1d2c34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2c20: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d2c24: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1d2c28: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1d2c2c: 0xac6419fc
    WRITE32(ADD32(GPR_U32(ctx, 3), 6652), GPR_U32(ctx, 4));
label_1d2c30:
    // 0x1d2c30: 0x8e634f74
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 20340)));
label_1d2c34:
    // 0x1d2c34: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1d2c38: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x1d2c3c: 0x10400045
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2D54; return;
    }
    // 0x1d2c44: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d2c48: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1d2c4c: 0x2442db90
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294957968));
    // 0x1d2c50: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1d2c54: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d2c58: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1d2c60: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d2c64: 0x1000003b
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2D54; return;
    }
    // 0x1d2c6c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d2c70: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d2c74: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d2c78: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1d2c7c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1d2c80: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1d2c84: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1d2c8c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6228)); ctx->f[12] = *(float*)&val; }
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1d2c8c
// Address: 0x1d2c8c - 0x1d2dac

void entry_1d2c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2c8c) {
        switch (ctx->pc) {
            case 0x1d2cec: ctx->pc = 0; goto label_1d2cec;
            case 0x1d2cf4: ctx->pc = 0; goto label_1d2cf4;
            case 0x1d2d50: ctx->pc = 0; goto label_1d2d50;
            case 0x1d2d54: ctx->pc = 0; goto label_1d2d54;
            case 0x1d2d58: ctx->pc = 0; goto label_1d2d58;
            case 0x1d2d70: ctx->pc = 0; goto label_1d2d70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2c8c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d2c90: 0x10000030
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2d54;
    }
    // 0x1d2c98: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d2c9c: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d2ca0: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1d2ca4: 0x10600013
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1d2cf4;
    }
    // 0x1d2cac: 0x8c632220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 8736)));
    // 0x1d2cb0: 0x1000000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2cec;
    }
    // 0x1d2cb8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d2cbc: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d2cc0: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1d2cc4: 0x1060000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1d2cf4;
    }
    // 0x1d2ccc: 0x8c642220
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 8736)));
    // 0x1d2cd0: 0x2402000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1d2cd4: 0x1082001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_1d2d54;
    }
    // 0x1d2cdc: 0x5482001d
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1d2d54;
    }
    // 0x1d2ce4: 0x8c632228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 8744)));
    // 0x1d2ce8: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
label_1d2cec:
    // 0x1d2cec: 0x1062001a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 11792)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d2d58;
    }
label_1d2cf4:
    // 0x1d2cf4: 0x10000017
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2d54;
    }
    // 0x1d2cfc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d2d00: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1d2d04: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d2d08: 0x8c832220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x1d2d0c: 0x10000010
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), 14));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2d50;
    }
    // 0x1d2d14: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d2d18: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1d2d1c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d2d20: 0x2403000f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 15));
    // 0x1d2d24: 0x8c822220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x1d2d28: 0x1043000a
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_1d2d54;
    }
    // 0x1d2d30: 0x8c82275c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 10076)));
    // 0x1d2d34: 0x10000007
    SET_GPR_U32(ctx, 17, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2d54;
    }
    // 0x1d2d3c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d2d40: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1d2d44: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d2d48: 0x8c832220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x1d2d4c: 0x38630010
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), 16));
label_1d2d50:
    // 0x1d2d50: 0x3882b
    SET_GPR_U32(ctx, 17, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
label_1d2d54:
    // 0x1d2d54: 0x8ca22e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 11792)));
label_1d2d58:
    // 0x1d2d58: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
        goto label_1d2d70;
    }
    // 0x1d2d60: 0x8c422220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8736)));
    // 0x1d2d64: 0x38420004
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 4));
    // 0x1d2d68: 0x2880a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 0));
    // 0x1d2d6c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1d2d70:
    // 0x1d2d70: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d2d74: 0x244201f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 504));
    // 0x1d2d78: 0x8c430250
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 592)));
    // 0x1d2d7c: 0x3880b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 0));
    // 0x1d2d80: 0x12200011
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20340)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2DC8; return;
    }
    // 0x1d2d88: 0x964200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 170)));
    // 0x1d2d8c: 0x30420003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 3));
    // 0x1d2d90: 0x1040000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 20340)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d2dc4(rdram, ctx, runtime); return;
    }
    // 0x1d2d98: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x1d2d9c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d2da0: 0x24060007
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1d2da4: 0xc074c40
    SET_GPR_U32(ctx, 31, 0x1d2dac);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 20280));
    IRotatePowerUp__FP3JOYiiPi(rdram, ctx, runtime); return;
}


// Function: entry_1d2dac
// Address: 0x1d2dac - 0x1d2dc4

void entry_1d2dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2dac: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d2db0: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1d2db4: 0x8c6523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x1d2db8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d2dbc: 0xc074a72
    SET_GPR_U32(ctx, 31, 0x1d2dc4);
    WRITE32(ADD32(GPR_U32(ctx, 5), 6652), GPR_U32(ctx, 6));
    SetFsp__F3FSP(rdram, ctx, runtime); return;
}


// Function: entry_1d2dc4
// Address: 0x1d2dc4 - 0x1d2e44

void entry_1d2dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2dc4) {
        switch (ctx->pc) {
            case 0x1d2dc8: ctx->pc = 0; goto label_1d2dc8;
            case 0x1d2e0c: ctx->pc = 0; goto label_1d2e0c;
            case 0x1d2e28: ctx->pc = 0; goto label_1d2e28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2dc4: 0x8e624f74
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20340)));
label_1d2dc8:
    // 0x1d2dc8: 0x2444ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1d2dcc: 0x2c830006
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 6));
    // 0x1d2dd0: 0x106000c3
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1d30e0(rdram, ctx, runtime); return;
    }
    // 0x1d2dd8: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1d2ddc: 0x2442dbb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294958000));
    // 0x1d2de0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1d2de4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d2de8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1d2df0: 0x268201f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 504));
    // 0x1d2df4: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1d2df8: 0x8c430260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 608)));
    // 0x1d2dfc: 0x54640003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 168)));
        goto label_1d2e0c;
    }
    // 0x1d2e04: 0x10000010
    WRITE32(ADD32(GPR_U32(ctx, 16), 10056), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2E48; return;
    }
label_1d2e0c:
    // 0x1d2e0c: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x1d2e10: 0x10400005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d2e28;
    }
    // 0x1d2e18: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d2e1c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d2e20: 0x10000009
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 10056), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2E48; return;
    }
label_1d2e28:
    // 0x1d2e28: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d2e2c: 0xc44e186c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6252)); ctx->f[14] = *(float*)&val; }
    // 0x1d2e30: 0x24844f78
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 20344));
    // 0x1d2e34: 0xc60c2748
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 10056)); ctx->f[12] = *(float*)&val; }
    // 0x1d2e38: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1d2e3c: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d2e44);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d2e44
// Address: 0x1d2e44 - 0x1d2ec0

void entry_1d2e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2e44) {
        switch (ctx->pc) {
            case 0x1d2e48: ctx->pc = 0; goto label_1d2e48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2e44: 0xe6002748
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 10056), *(uint32_t*)&val); }
label_1d2e48:
    // 0x1d2e48: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d2e4c: 0xc6022748
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 10056)); ctx->f[2] = *(float*)&val; }
    // 0x1d2e50: 0xc4414f84
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20356)); ctx->f[1] = *(float*)&val; }
    // 0x1d2e54: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d2e58: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d2e5c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d2e60: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1d2e64: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1d2e68: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1d2e6c: 0x1000009c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 6228), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1d30e0(rdram, ctx, runtime); return;
    }
    // 0x1d2e74: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d2e78: 0x8c622c6c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11372)));
    // 0x1d2e7c: 0x30420003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 3));
    // 0x1d2e80: 0x5440001c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 10052), GPR_U32(ctx, 0));
        ctx->pc = 0x1D2EF4; return;
    }
    // 0x1d2e88: 0x268201f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 504));
    // 0x1d2e8c: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1d2e90: 0x8c430260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 608)));
    // 0x1d2e94: 0x10640016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x1D2EF0; return;
    }
    // 0x1d2e9c: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1d2ea0: 0x54620009
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 168)));
        ctx->pc = 0x1D2EC8; return;
    }
    // 0x1d2ea8: 0x964200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 170)));
    // 0x1d2eac: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x1d2eb0: 0x10400010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2EF4; return;
    }
    // 0x1d2eb8: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1d2ec0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1d2ec0
// Address: 0x1d2ec0 - 0x1d2edc

void entry_1d2ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2ec0) {
        switch (ctx->pc) {
            case 0x1d2ec8: ctx->pc = 0; goto label_1d2ec8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2ec0: 0x10000009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2EE8; return;
    }
label_1d2ec8:
    // 0x1d2ec8: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x1d2ecc: 0x50400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 10052), GPR_U32(ctx, 0));
        ctx->pc = 0x1D2EF4; return;
    }
    // 0x1d2ed4: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1d2edc);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d2edc
// Address: 0x1d2edc - 0x1d2f54

void entry_1d2edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2edc) {
        switch (ctx->pc) {
            case 0x1d2ee8: ctx->pc = 0; goto label_1d2ee8;
            case 0x1d2ef0: ctx->pc = 0; goto label_1d2ef0;
            case 0x1d2ef4: ctx->pc = 0; goto label_1d2ef4;
            case 0x1d2f10: ctx->pc = 0; goto label_1d2f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2edc: 0x30421000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4096));
    // 0x1d2ee0: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d2ef0;
    }
label_1d2ee8:
    // 0x1d2ee8: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 16), 10052), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d2ef4;
    }
label_1d2ef0:
    // 0x1d2ef0: 0xae002744
    WRITE32(ADD32(GPR_U32(ctx, 16), 10052), GPR_U32(ctx, 0));
label_1d2ef4:
    // 0x1d2ef4: 0x8e022744
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 10052)));
    // 0x1d2ef8: 0x10400005
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d2f10;
    }
    // 0x1d2f00: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d2f04: 0xc4404f88
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20360)); ctx->f[0] = *(float*)&val; }
    // 0x1d2f08: 0x10000075
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 6228), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1d30e0(rdram, ctx, runtime); return;
    }
label_1d2f10:
    // 0x1d2f10: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d2f14: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d2f18: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d2f1c: 0x10000070
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 6228), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1d30e0(rdram, ctx, runtime); return;
    }
    // 0x1d2f24: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1d2f28: 0x28620003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    // 0x1d2f2c: 0x1040006d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E4; return;
    }
    // 0x1d2f34: 0x460006c
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_S32(ctx, 3) < 0) {
        ctx->pc = 0x1D30E8; return;
    }
    // 0x1d2f3c: 0x964200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 170)));
    // 0x1d2f40: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x1d2f44: 0x10400068
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E8; return;
    }
    // 0x1d2f4c: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1d2f54);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1d2f54
// Address: 0x1d2f54 - 0x1d2f6c

void entry_1d2f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2f54: 0x8e020690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1680)));
    // 0x1d2f58: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D2F74; return;
    }
    // 0x1d2f60: 0x2405000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    // 0x1d2f64: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d2f6c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 55));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d2f6c
// Address: 0x1d2f6c - 0x1d2f80

void entry_1d2f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d2f6c) {
        switch (ctx->pc) {
            case 0x1d2f74: ctx->pc = 0; goto label_1d2f74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d2f6c: 0x1000005d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E4; return;
    }
label_1d2f74:
    // 0x1d2f74: 0x2405000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    // 0x1d2f78: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d2f80);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 54));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d2f80
// Address: 0x1d2f80 - 0x1d2fbc

void entry_1d2f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2f80: 0x10000058
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E4; return;
    }
    // 0x1d2f88: 0x8e022220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1d2f8c: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1d2f90: 0x10400054
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E4; return;
    }
    // 0x1d2f98: 0x964200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 170)));
    // 0x1d2f9c: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x1d2fa0: 0x10400051
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E8; return;
    }
    // 0x1d2fa8: 0x8e022750
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 10064)));
    // 0x1d2fac: 0x1040004e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E8; return;
    }
    // 0x1d2fb4: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1d2fbc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1d2fbc
// Address: 0x1d2fbc - 0x1d2fcc

void entry_1d2fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2fbc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d2fc0: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1d2fc4: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d2fcc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d2fcc
// Address: 0x1d2fcc - 0x1d2ffc

void entry_1d2fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2fcc: 0x10000045
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E4; return;
    }
    // 0x1d2fd4: 0x8e022220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1d2fd8: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1d2fdc: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 10076)));
        ctx->pc = 0x1D3010; return;
    }
    // 0x1d2fe4: 0x964200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 170)));
    // 0x1d2fe8: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x1d2fec: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d300c(rdram, ctx, runtime); return;
    }
    // 0x1d2ff4: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1d2ffc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1d2ffc
// Address: 0x1d2ffc - 0x1d300c

void entry_1d2ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d2ffc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d3000: 0x2405000f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    // 0x1d3004: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d300c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d300c
// Address: 0x1d300c - 0x1d3044

void entry_1d300c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d300c) {
        switch (ctx->pc) {
            case 0x1d3010: ctx->pc = 0; goto label_1d3010;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d300c: 0x8e02275c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 10076)));
label_1d3010:
    // 0x1d3010: 0x10400033
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d30e0(rdram, ctx, runtime); return;
    }
    // 0x1d3018: 0xc6022758
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 10072)); ctx->f[2] = *(float*)&val; }
    // 0x1d301c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1d3020: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1d3024: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d3028: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1d302c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d3030: 0x0
    // NOP
    // 0x1d3034: 0x4500002a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1d30e0(rdram, ctx, runtime); return;
    }
    // 0x1d303c: 0xc074c74
    SET_GPR_U32(ctx, 31, 0x1d3044);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    func_001D31D0__FP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_1d3044
// Address: 0x1d3044 - 0x1d3080

void entry_1d3044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3044: 0x10000027
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E4; return;
    }
    // 0x1d304c: 0x8e022220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1d3050: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1d3054: 0x10400023
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E4; return;
    }
    // 0x1d305c: 0x964200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 170)));
    // 0x1d3060: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x1d3064: 0x10400020
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E8; return;
    }
    // 0x1d306c: 0x8e021518
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 5400)));
    // 0x1d3070: 0x1040001d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E8; return;
    }
    // 0x1d3078: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1d3080);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1d3080
// Address: 0x1d3080 - 0x1d3088

void entry_1d3080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3080: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1d3088);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 5400)));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1d3088
// Address: 0x1d3088 - 0x1d30b0

void entry_1d3088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3088: 0x10400012
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30D4; return;
    }
    // 0x1d3090: 0x8e021518
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 5400)));
    // 0x1d3094: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1d3098: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1d309c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d30a0: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d30a4: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1d30a8: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1d30b0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1d30b0
// Address: 0x1d30b0 - 0x1d30bc

void entry_1d30b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d30b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d30b4: 0xc071756
    SET_GPR_U32(ctx, 31, 0x1d30bc);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    FixStepAngularVelocity__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1d30bc
// Address: 0x1d30bc - 0x1d30cc

void entry_1d30bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d30bc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d30c0: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1d30c4: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d30cc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 58));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d30cc
// Address: 0x1d30cc - 0x1d30e0

void entry_1d30cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d30cc) {
        switch (ctx->pc) {
            case 0x1d30d4: ctx->pc = 0; goto label_1d30d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d30cc: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D30E4; return;
    }
label_1d30d4:
    // 0x1d30d4: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1d30d8: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d30e0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 57));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d30e0
// Address: 0x1d30e0 - 0x1d3100

void entry_1d30e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d30e0) {
        switch (ctx->pc) {
            case 0x1d30e4: ctx->pc = 0; goto label_1d30e4;
            case 0x1d30e8: ctx->pc = 0; goto label_1d30e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d30e0: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_1d30e4:
    // 0x1d30e4: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1d30e8:
    // 0x1d30e8: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d30ec: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d30f0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d30f4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d30f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: IRotatePowerUp__FP3JOYiiPi
// Address: 0x1d3100 - 0x1d315c

void entry_1d315c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d315c) {
        switch (ctx->pc) {
            case 0x1d3168: ctx->pc = 0; goto label_1d3168;
            case 0x1d3180: ctx->pc = 0; goto label_1d3180;
            case 0x1d3184: ctx->pc = 0; goto label_1d3184;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d315c: 0x240882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d3160: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1d3164: 0x0
    // NOP
label_1d3168:
    // 0x1d3168: 0x620fff3
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 20)));
    if (GPR_S32(ctx, 17) < 0) {
        ctx->pc = 0x1D3138; return;
    }
    // 0x1d3170: 0x6010003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 18)));
    if (GPR_S32(ctx, 16) >= 0) {
        goto label_1d3180;
    }
    // 0x1d3178: 0x10000002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d3184;
    }
label_1d3180:
    // 0x1d3180: 0x2800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 0));
label_1d3184:
    // 0x1d3184: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1d318c);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d318c
// Address: 0x1d318c - 0x1d31d0

void entry_1d318c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d318c) {
        switch (ctx->pc) {
            case 0x1d31a8: ctx->pc = 0; goto label_1d31a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d318c: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1d3190: 0x751821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 21)));
    // 0x1d3194: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d3198: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1d319c: 0x1040fff2
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3168; return;
    }
    // 0x1d31a4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1d31a8:
    // 0x1d31a8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d31ac: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d31b0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d31b4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d31b8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d31bc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d31c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d31c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d31cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d31d0; return;
}


// Function: func_001D31D0__FP2LOi
// Address: 0x1d31d0 - 0x1d3214

void entry_1d3214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3214) {
        switch (ctx->pc) {
            case 0x1d3220: ctx->pc = 0; goto label_1d3220;
            case 0x1d3244: ctx->pc = 0; goto label_1d3244;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3214: 0x18400011
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1D325C; return;
    }
    // 0x1d321c: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1d3220:
    // 0x1d3220: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d3224: 0x8c4407e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 2016)));
    // 0x1d3228: 0x5080000a
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        ctx->pc = 0x1D3254; return;
    }
    // 0x1d3230: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d3234: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d3238: 0x12400002
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1d3244;
    }
    // 0x1d3240: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
label_1d3244:
    // 0x1d3244: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1d3248: 0xc04bc28
    SET_GPR_U32(ctx, 31, 0x1d3250);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime); return;
}


// Function: entry_1d3250
// Address: 0x1d3250 - 0x1d3290

void entry_1d3250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3250) {
        switch (ctx->pc) {
            case 0x1d3254: ctx->pc = 0; goto label_1d3254;
            case 0x1d325c: ctx->pc = 0; goto label_1d325c;
            case 0x1d3270: ctx->pc = 0; goto label_1d3270;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3250: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
label_1d3254:
    // 0x1d3254: 0x1620fff2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3220; return;
    }
label_1d325c:
    // 0x1d325c: 0xae72275c
    WRITE32(ADD32(GPR_U32(ctx, 19), 10076), GPR_U32(ctx, 18));
    // 0x1d3260: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d3264: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1d3268: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d326c: 0xe6602758
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 10072), *(uint32_t*)&val); }
label_1d3270:
    // 0x1d3270: 0x7bbf0440
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    // 0x1d3274: 0x7bb30430
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x1d3278: 0x7bb20420
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x1d327c: 0x7bb10410
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1040)));
    // 0x1d3280: 0x7bb00400
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1024)));
    // 0x1d3284: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1104));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d328c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d3290; return;
}


// Function: post_load_steprail
// Address: 0x1d3290 - 0x1d32a4

void entry_1d32a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d32a4: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1d32a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d32ac: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d32b0: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1d32b8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 20368));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1d32b8
// Address: 0x1d32b8 - 0x1d32c8

void entry_1d32b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d32b8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d32bc: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1d32c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d32c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d32c8
// Address: 0x1d32c8 - 0x1d32d8

void entry_1d32c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d32c8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d32cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d32d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: func_001D32D8__FiP2JTl
// Address: 0x1d32d8 - 0x1d3308

void entry_1d3308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3308) {
        switch (ctx->pc) {
            case 0x1d3318: ctx->pc = 0; goto label_1d3318;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3308: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x1d330c: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1d3310: 0x1c40001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 2) > 0) {
        entry_1d3384(rdram, ctx, runtime); return;
    }
label_1d3318:
    // 0x1d3318: 0xc0561cc
    SET_GPR_U32(ctx, 31, 0x1d3320);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    ExplodeExpl__FP4EXPL(rdram, ctx, runtime); return;
}


// Function: entry_1d3320
// Address: 0x1d3320 - 0x1d3360

void entry_1d3320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3320: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1d3324: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d3328: 0x3c01457a
    SET_GPR_U32(ctx, 1, ((uint32_t)17786 << 16));
    // 0x1d332c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d3330: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d3334: 0x3c01443b
    SET_GPR_U32(ctx, 1, ((uint32_t)17467 << 16));
    // 0x1d3338: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1d333c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d3340: 0x24040067
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 103));
    // 0x1d3344: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d3348: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1d334c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d3350: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d3354: 0x26070140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 320));
    // 0x1d3358: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1d3360);
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1d3360
// Address: 0x1d3360 - 0x1d3374

void entry_1d3360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3360: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d3364: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d3368: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d336c: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1d3374);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1d3374
// Address: 0x1d3374 - 0x1d3384

void entry_1d3374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3374: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d3378: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1d337c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d3384);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d3384
// Address: 0x1d3384 - 0x1d3398

void entry_1d3384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3384: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d3388: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d338c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d3394: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d3398; return;
}


// Function: update_steprail
// Address: 0x1d3398 - 0x1d33ac

void entry_1d33ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d33ac: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d33b0: 0x8c452e10
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1d33b4: 0x50a00018
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        ctx->pc = 0x1D3418; return;
    }
    // 0x1d33bc: 0xd8a20140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 320)));
    // 0x1d33c0: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1d33c4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d33c8: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x1d33cc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d33d0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d33d4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d33d8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d33dc: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d33e0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d33e4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d33e8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d33ec: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d33f0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d33f4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d33f8: 0x0
    // NOP
    // 0x1d33fc: 0x45000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D3414; return;
    }
    // 0x1d3404: 0xc074cb6
    SET_GPR_U32(ctx, 31, 0x1d340c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    func_001D32D8__FiP2JTl(rdram, ctx, runtime); return;
}


// Function: entry_1d340c
// Address: 0x1d340c - 0x1d3450

void entry_1d340c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d340c) {
        switch (ctx->pc) {
            case 0x1d3414: ctx->pc = 0; goto label_1d3414;
            case 0x1d3418: ctx->pc = 0; goto label_1d3418;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d340c: 0x10000011
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3454; return;
    }
label_1d3414:
    // 0x1d3414: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
label_1d3418:
    // 0x1d3418: 0x5440000e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        ctx->pc = 0x1D3454; return;
    }
    // 0x1d3420: 0x8e050554
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x1d3424: 0x10a0000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1d3450(rdram, ctx, runtime); return;
    }
    // 0x1d342c: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1d3430: 0x8e020050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1d3434: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d3438: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1d343c: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x1d3440: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1d3444: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1d3448: 0xc074cb6
    SET_GPR_U32(ctx, 31, 0x1d3450);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    func_001D32D8__FiP2JTl(rdram, ctx, runtime); return;
}


// Function: entry_1d3450
// Address: 0x1d3450 - 0x1d345c

void entry_1d3450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3450) {
        switch (ctx->pc) {
            case 0x1d3454: ctx->pc = 0; goto label_1d3454;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3450: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
label_1d3454:
    // 0x1d3454: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1d345c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1d345c
// Address: 0x1d345c - 0x1d3470

void entry_1d345c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d345c: 0xae000554
    WRITE32(ADD32(GPR_U32(ctx, 16), 1364), GPR_U32(ctx, 0));
    // 0x1d3460: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d3464: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d3468: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: preset_steprail_accel
// Address: 0x1d3470 - 0x1d348c

void entry_1d348c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d348c: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1d3490: 0x1440000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D34CC; return;
    }
    // 0x1d3498: 0x260400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1d349c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d34a0: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x1d34a8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1d34a8
// Address: 0x1d34a8 - 0x1d34c8

void entry_1d34a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d34a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d34ac: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x1d34b0: 0x8c860214
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 532)));
    // 0x1d34b4: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x1d34b8: 0x8c880218
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 4), 536)));
    // 0x1d34bc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d34c0: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x1d34c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_1d34c8
// Address: 0x1d34c8 - 0x1d34e0

void entry_1d34c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d34c8) {
        switch (ctx->pc) {
            case 0x1d34cc: ctx->pc = 0; goto label_1d34cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d34c8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1d34cc:
    // 0x1d34cc: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d34d0: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x1d34d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d34dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d34e0; return;
}


// Function: FUN_001d34e0
// Address: 0x1d34e0 - 0x1d34f0

void FUN_001d34e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d34e0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1d34e4: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1d34e8: 0xc06f136
    SET_GPR_U32(ctx, 31, 0x1d34f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 1364));
    FUN_001bc4d8(rdram, ctx, runtime); return;
}


// Function: entry_1d34f0
// Address: 0x1d34f0 - 0x1d3500

void entry_1d34f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d34f0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d34f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d34fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d3500; return;
}


// Function: FUN_001d3500
// Address: 0x1d3500 - 0x1d3520

void FUN_001d3500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3500: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1d3504: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1d3508: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1d350c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d3510: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1d3514: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1d3518: 0xc06f0c8
    SET_GPR_U32(ctx, 31, 0x1d3520);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    FAbsorbSoWkr__FP2SOP3WKR(rdram, ctx, runtime); return;
}


// Function: entry_1d3520
// Address: 0x1d3520 - 0x1d357c

void entry_1d3520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3520) {
        switch (ctx->pc) {
            case 0x1d355c: ctx->pc = 0; goto label_1d355c;
            case 0x1d3560: ctx->pc = 0; goto label_1d3560;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3520: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d3524: 0x1240001a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3590; return;
    }
    // 0x1d352c: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1d3530: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1d3534: 0x10400016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3590; return;
    }
    // 0x1d353c: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d3540: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1d3544: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1d3548: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1d354c: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 24)));
        goto label_1d355c;
    }
    // 0x1d3554: 0x10000002
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d3560;
    }
label_1d355c:
    // 0x1d355c: 0x8c430050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 80)));
label_1d3560:
    // 0x1d3560: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d3564: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d3568: 0x8c462e10
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1d356c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d3570: 0x663026
    SET_GPR_U32(ctx, 6, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1d3574: 0xc074cb6
    SET_GPR_U32(ctx, 31, 0x1d357c);
    SET_GPR_U32(ctx, 6, SLTU32(GPR_U32(ctx, 6), 1));
    func_001D32D8__FiP2JTl(rdram, ctx, runtime); return;
}


// Function: entry_1d357c
// Address: 0x1d357c - 0x1d3588

void entry_1d357c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d357c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1d3580: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1d3588);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1364)));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1d3588
// Address: 0x1d3588 - 0x1d35a8

void entry_1d3588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3588) {
        switch (ctx->pc) {
            case 0x1d3590: ctx->pc = 0; goto label_1d3590;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3588: 0xae200554
    WRITE32(ADD32(GPR_U32(ctx, 17), 1364), GPR_U32(ctx, 0));
    // 0x1d358c: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1d3590:
    // 0x1d3590: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d3594: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d3598: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d359c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d35a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d35a8
// Address: 0x1d35a8 - 0x1d35cc

void FUN_001d35a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d35a8: 0x27bdff20
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967072));
    // 0x1d35ac: 0x7fb000c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 16));
    // 0x1d35b0: 0x7fbf00d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 31));
    // 0x1d35b4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d35b8: 0x8e0201f4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 500)));
    // 0x1d35bc: 0x10400028
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3660; return;
    }
    // 0x1d35c4: 0xc04944e
    SET_GPR_U32(ctx, 31, 0x1d35cc);
    UpdateAloXfWorldHierarchy__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1d35cc
// Address: 0x1d35cc - 0x1d35e0

void entry_1d35cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d35cc: 0x8e0401f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 500)));
    // 0x1d35d0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d35d4: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1d35d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d35e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d35e0
// Address: 0x1d35e0 - 0x1d3658

void entry_1d35e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d35e0: 0x26030110
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1d35e4: 0xda010110
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 272)));
    // 0x1d35e8: 0xd8660020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1d35ec: 0x26040380
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 896));
    // 0x1d35f0: 0xd8620010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1d35f4: 0x260503a4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 932));
    // 0x1d35f8: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d35fc: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d3600: 0xdba40040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d3604: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1d3608: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d360c: 0x4bc330ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d3610: 0x4bc409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1d3614: 0x4bc410bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1d3618: 0x4bc4310a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d361c: 0xdba50050
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d3620: 0x7a060140
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1d3624: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1d3628: 0x4bc510bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1d362c: 0x4bc5304a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d3630: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d3634: 0xfba40010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d3638: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d363c: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d3640: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d3644: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d3648: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d364c: 0xfba100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d3650: 0xc06e208
    SET_GPR_U32(ctx, 31, 0x1d3658);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    UpdateGeomWorld__FP4GEOMT0G9VU_VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1d3658
// Address: 0x1d3658 - 0x1d3668

void entry_1d3658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3658) {
        switch (ctx->pc) {
            case 0x1d3660: ctx->pc = 0; goto label_1d3660;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3658: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D366C; return;
    }
label_1d3660:
    // 0x1d3660: 0xc06e258
    SET_GPR_U32(ctx, 31, 0x1d3668);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateSoXfWorldHierarchy__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1d3668
// Address: 0x1d3668 - 0x1d3678

void entry_1d3668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3668) {
        switch (ctx->pc) {
            case 0x1d366c: ctx->pc = 0; goto label_1d366c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3668: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
label_1d366c:
    // 0x1d366c: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d3670: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: update_steprail_message
// Address: 0x1d3678 - 0x1d369c

void entry_1d369c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d369c: 0x2402000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1d36a0: 0x1602000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D36D8; return;
    }
    // 0x1d36a8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d36ac: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x1d36b0: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d36b4: 0x24e78d20
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937888));
    // 0x1d36b8: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1d36bc: 0x24860140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 320));
    // 0x1d36c0: 0x2408000a
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1d36c4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d36c8: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d36cc: 0xc061748
    SET_GPR_U32(ctx, 31, 0x1d36d4);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 4), 1364));
    PxpAdd__FP2SOT0P6VECTORT2f3XPKPvT6PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1d36d4
// Address: 0x1d36d4 - 0x1d36f0

void entry_1d36d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d36d4) {
        switch (ctx->pc) {
            case 0x1d36d8: ctx->pc = 0; goto label_1d36d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d36d4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1d36d8:
    // 0x1d36d8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d36dc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d36e0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d36e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d36ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d36f0; return;
}


// Function: PostStepLoadRun__FP4STEPP5BLRUNPP6ASEGBL
// Address: 0x1d36f0 - 0x1d3768

void entry_1d3768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3768: 0x3c173f00
    SET_GPR_U32(ctx, 23, ((uint32_t)16128 << 16));
    // 0x1d376c: 0x3c090027
    SET_GPR_U32(ctx, 9, ((uint32_t)39 << 16));
    // 0x1d3770: 0x24040050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 80));
    // 0x1d3774: 0x25294fa8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 20392));
    // 0x1d3778: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1d377c: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d3780: 0x24070040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1d3784: 0x24080002
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d3788: 0xc04e580
    SET_GPR_U32(ctx, 31, 0x1d3790);
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FillBlAmrsg__FiiPviiP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d3790
// Address: 0x1d3790 - 0x1d37d4

void entry_1d3790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3790) {
        switch (ctx->pc) {
            case 0x1d3798: ctx->pc = 0; goto label_1d3798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3790: 0x27b60050
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1d3794: 0x24020050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
label_1d3798:
    // 0x1d3798: 0x2821818
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1d379c: 0x738821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 19)));
    // 0x1d37a0: 0x8e300004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1d37a4: 0x12000041
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D38AC; return;
    }
    // 0x1d37ac: 0x8e02009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 156)));
    // 0x1d37b0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1d37b4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d37b8: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1d37bc: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1d37c0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d37c4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d37c8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d37cc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d37d4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d37d4
// Address: 0x1d37d4 - 0x1d3800

void entry_1d37d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d37d4: 0x8e03009c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 156)));
    // 0x1d37d8: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d37dc: 0xc60c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1d37e0: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1d37e4: 0x8c640004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1d37e8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d37ec: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d37f0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d37f4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d37f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d3800);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d3800
// Address: 0x1d3800 - 0x1d3834

void entry_1d3800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3800: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d3804: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d3808: 0x8e100034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1d380c: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d3810: 0x48b01800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    // 0x1d3814: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1d3818: 0x4a6303bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1d381c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d3820: 0x4be0109c
    ctx->vu0_vf[2] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1d3824: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d3828: 0xfa220010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d382c: 0xc04b33a
    SET_GPR_U32(ctx, 31, 0x1d3834);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1552)));
    PchnFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1d3834
// Address: 0x1d3834 - 0x1d385c

void entry_1d3834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3834: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1d3838: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1d383c: 0xc62c0030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 48)); ctx->f[12] = *(float*)&val; }
    // 0x1d3840: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1d3844: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d3848: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d384c: 0x8e450610
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1552)));
    // 0x1d3850: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d3854: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d385c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d385c
// Address: 0x1d385c - 0x1d3868

void entry_1d385c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d385c: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1d3860: 0xc04b33a
    SET_GPR_U32(ctx, 31, 0x1d3868);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1556)));
    PchnFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1d3868
// Address: 0x1d3868 - 0x1d3890

void entry_1d3868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3868: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1d386c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1d3870: 0x8e450614
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1556)));
    // 0x1d3874: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d3878: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d387c: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d3880: 0xc62c0040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 64)); ctx->f[12] = *(float*)&val; }
    // 0x1d3884: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d3888: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d3890);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d3890
// Address: 0x1d3890 - 0x1d38e8

void entry_1d3890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3890) {
        switch (ctx->pc) {
            case 0x1d38ac: ctx->pc = 0; goto label_1d38ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3890: 0x48b71000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 23));
    // 0x1d3894: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d3898: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d389c: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d38a0: 0x4be208c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d38a4: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d38a8: 0xfa230020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), _mm_castps_si128(ctx->vu0_vf[3]));
label_1d38ac:
    // 0x1d38ac: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x1d38b0: 0x2a820006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), 6));
    // 0x1d38b4: 0x1440ffb8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3798; return;
    }
    // 0x1d38bc: 0x3c090027
    SET_GPR_U32(ctx, 9, ((uint32_t)39 << 16));
    // 0x1d38c0: 0x3c0a0027
    SET_GPR_U32(ctx, 10, ((uint32_t)39 << 16));
    // 0x1d38c4: 0x24050050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 80));
    // 0x1d38c8: 0x24060006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1d38cc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d38d0: 0x25294fb8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 20408));
    // 0x1d38d4: 0x254a4fb0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 20400));
    // 0x1d38d8: 0x2c0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1d38dc: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d38e0: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x1d38e8);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_1d38e8
// Address: 0x1d38e8 - 0x1d39a4

void entry_1d38e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d38e8) {
        switch (ctx->pc) {
            case 0x1d3900: ctx->pc = 0; goto label_1d3900;
            case 0x1d394c: ctx->pc = 0; goto label_1d394c;
            case 0x1d3964: ctx->pc = 0; goto label_1d3964;
            case 0x1d396c: ctx->pc = 0; goto label_1d396c;
            case 0x1d3978: ctx->pc = 0; goto label_1d3978;
            case 0x1d397c: ctx->pc = 0; goto label_1d397c;
            case 0x1d3990: ctx->pc = 0; goto label_1d3990;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d38e8: 0x8fa50050
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d38ec: 0x8ca20038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 56)));
    // 0x1d38f0: 0x18400027
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1d3990;
    }
    // 0x1d38f8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d38fc: 0x0
    // NOP
label_1d3900:
    // 0x1d3900: 0x8ca2003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 60)));
    // 0x1d3904: 0x472021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1d3908: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d390c: 0x28620037
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 55));
    // 0x1d3910: 0x54400014
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
        goto label_1d3964;
    }
    // 0x1d3918: 0x2862003a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 58));
    // 0x1d391c: 0x54400017
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 80)));
        goto label_1d397c;
    }
    // 0x1d3924: 0x2862003d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 61));
    // 0x1d3928: 0x5040000e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
        goto label_1d3964;
    }
    // 0x1d3930: 0x8c830004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x1d3934: 0x50600005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 8)));
        goto label_1d394c;
    }
    // 0x1d393c: 0x8ca200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 192)));
    // 0x1d3940: 0x2442000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 12));
    // 0x1d3944: 0xac620010
    WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 2));
    // 0x1d3948: 0x8c840008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 8)));
label_1d394c:
    // 0x1d394c: 0x1080000a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1d3978;
    }
    // 0x1d3954: 0x8c6200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 192)));
    // 0x1d3958: 0x2442000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 12));
    // 0x1d395c: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d3978;
    }
label_1d3964:
    // 0x1d3964: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 0));
        goto label_1d396c;
    }
label_1d396c:
    // 0x1d396c: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1d3970: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 0));
        goto label_1d3978;
    }
label_1d3978:
    // 0x1d3978: 0x8fa50050
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 80)));
label_1d397c:
    // 0x1d397c: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1d3980: 0x8ca20038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 56)));
    // 0x1d3984: 0xc2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 2)));
    // 0x1d3988: 0x1440ffdd
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 28));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1d3900;
    }
label_1d3990:
    // 0x1d3990: 0x8fa40050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d3994: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d3998: 0x24050050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 80));
    // 0x1d399c: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x1d39a4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_1d39a4
// Address: 0x1d39a4 - 0x1d39e0

void entry_1d39a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d39a4) {
        switch (ctx->pc) {
            case 0x1d39b0: ctx->pc = 0; goto label_1d39b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d39a4: 0x12a00002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_1d39b0;
    }
    // 0x1d39ac: 0xaea20000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 2));
label_1d39b0:
    // 0x1d39b0: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d39b4: 0x7bb700d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d39b8: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d39bc: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d39c0: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d39c4: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d39c8: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d39cc: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d39d0: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d39d4: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1d39d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateBlrunV__FiP5BLRUNP4MRSGP6VECTOR
// Address: 0x1d39e0 - 0x1d3a38

void entry_1d3b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3b88: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d3b8c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1d3b90: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d3b94: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d3b98: 0x27aa0090
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1d3b9c: 0x27ab0094
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 148));
    // 0x1d3ba0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d3ba4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d3ba8: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x1d3bb0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1d3bb0
// Address: 0x1d3bb0 - 0x1d3bcc

void entry_1d3bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3bb0: 0x8fa70090
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d3bb4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d3bb8: 0x8fa80094
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 148)));
    // 0x1d3bbc: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d3bc0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d3bc4: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x1d3bcc);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 32));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1d3bcc
// Address: 0x1d3bcc - 0x1d3c48

void entry_1d3bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3bcc) {
        switch (ctx->pc) {
            case 0x1d3c38: ctx->pc = 0; goto label_1d3c38;
            case 0x1d3c40: ctx->pc = 0; goto label_1d3c40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3bcc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d3bd0: 0x12000019
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1d3c38;
    }
    // 0x1d3bd8: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d3bdc: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d3be0: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d3be4: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d3be8: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d3bec: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d3bf0: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d3bf4: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d3bf8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d3bfc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d3c00: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d3c04: 0x4bc210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d3c08: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d3c0c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d3c10: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d3c14: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d3c18: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d3c1c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d3c20: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d3c24: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d3c28: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d3c2c: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1d3c30: 0x10000003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d3c40;
    }
label_1d3c38:
    // 0x1d3c38: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d3c3c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
label_1d3c40:
    // 0x1d3c40: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1d3c48);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d3c48
// Address: 0x1d3c48 - 0x1d3c68

void entry_1d3c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3c48: 0x10102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 16)));
    // 0x1d3c4c: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d3c50: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d3c54: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d3c58: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d3c5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d3c64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d3c68; return;
}


// Function: FReblendAbl2D__FiiiP2BLe
// Address: 0x1d3c68 - 0x1d3cf0

void entry_1d3cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3cf0) {
        switch (ctx->pc) {
            case 0x1d3d00: ctx->pc = 0; goto label_1d3d00;
            case 0x1d3d28: ctx->pc = 0; goto label_1d3d28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3cf0: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x1d3cf4: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1d3cf8: 0x1600fff9
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3CE0; return;
    }
label_1d3d00:
    // 0x1d3d00: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d3d04: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d3d08: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d3d0c: 0x213102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 19)));
    // 0x1d3d10: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1d3d14: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1d3d18: 0x1040000b
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3D48; return;
    }
    // 0x1d3d20: 0x27b10044
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 68));
    // 0x1d3d24: 0x2670ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 4294967295));
label_1d3d28:
    // 0x1d3d28: 0x26520008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 8));
    // 0x1d3d2c: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1d3d30: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x1d3d38);
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 18), 4294967288)));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_1d3d38
// Address: 0x1d3d38 - 0x1d3e00

void entry_1d3d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3d38) {
        switch (ctx->pc) {
            case 0x1d3d48: ctx->pc = 0; goto label_1d3d48;
            case 0x1d3d68: ctx->pc = 0; goto label_1d3d68;
            case 0x1d3d88: ctx->pc = 0; goto label_1d3d88;
            case 0x1d3db0: ctx->pc = 0; goto label_1d3db0;
            case 0x1d3dbc: ctx->pc = 0; goto label_1d3dbc;
            case 0x1d3dcc: ctx->pc = 0; goto label_1d3dcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3d38: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x1d3d3c: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1d3d40: 0x1600fff9
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3D28; return;
    }
label_1d3d48:
    // 0x1d3d48: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d3d4c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d3d50: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1d3d54: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d3d58: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d3d5c: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1d3d60: 0x1a80001a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    if (GPR_S32(ctx, 20) <= 0) {
        goto label_1d3dcc;
    }
label_1d3d68:
    // 0x1d3d68: 0x1a600014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1));
    if (GPR_S32(ctx, 19) <= 0) {
        goto label_1d3dbc;
    }
    // 0x1d3d70: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1d3d74: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d3d78: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x1d3d7c: 0x260802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d3d80: 0xc4620000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1d3d84: 0x0
    // NOP
label_1d3d88:
    // 0x1d3d88: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1d3d8c: 0xc4e10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1d3d90: 0x46001502
    ctx->f[20] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1d3d94: 0x4601a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d3d98: 0x0
    // NOP
    // 0x1d3d9c: 0x45030004
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 21)));
        goto label_1d3db0;
    }
    // 0x1d3da4: 0xe4f40000
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 7), 0), *(uint32_t*)&val); }
    // 0x1d3da8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d3dac: 0xf53821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 21)));
label_1d3db0:
    // 0x1d3db0: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1d3db4: 0x1600fff4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_1d3d88;
    }
label_1d3dbc:
    // 0x1d3dbc: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1d3dc0: 0x214102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 20)));
    // 0x1d3dc4: 0x1440ffe8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1d3d68;
    }
label_1d3dcc:
    // 0x1d3dcc: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1d3dd0: 0xc0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1d3dd4: 0x7bb600e0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d3dd8: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d3ddc: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d3de0: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d3de4: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d3de8: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d3dec: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d3df0: 0xc7b40100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[20] = *(float*)&val; }
    // 0x1d3df4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 368));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d3dfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d3e00; return;
}


// Function: AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA
// Address: 0x1d3e00 - 0x1d3f3c

void entry_1d3f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3f3c: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d3f40: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d3f44: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d3f48: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d3f4c: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d3f50: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d3f54: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1d3f58: 0xc074e8e
    SET_GPR_U32(ctx, 31, 0x1d3f60);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ProjectStepRunPlant__FP4STEPP5BLRUNffiiP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d3f60
// Address: 0x1d3f60 - 0x1d3f78

void entry_1d3f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3f60: 0x27b40030
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d3f64: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d3f68: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d3f6c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d3f70: 0xc074ed6
    SET_GPR_U32(ctx, 31, 0x1d3f78);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    FIntersectStepRunPlant__FP4STEPP6VECTORT1Pf(rdram, ctx, runtime); return;
}


// Function: entry_1d3f78
// Address: 0x1d3f78 - 0x1d3fc0

void entry_1d3f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3f78) {
        switch (ctx->pc) {
            case 0x1d3f94: ctx->pc = 0; goto label_1d3f94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3f78: 0x10400006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d3f94;
    }
    // 0x1d3f80: 0x4600b506
    ctx->f[20] = FPU_MOV_S(ctx->f[22]);
    // 0x1d3f84: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d3f88: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d3f8c: 0x1000001b
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3FFC; return;
    }
label_1d3f94:
    // 0x1d3f94: 0x8e420144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 324)));
    // 0x1d3f98: 0x10400016
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D3FF4; return;
    }
    // 0x1d3fa0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d3fa4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d3fa8: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d3fac: 0x24070005
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1d3fb0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d3fb4: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1d3fb8: 0xc074e8e
    SET_GPR_U32(ctx, 31, 0x1d3fc0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ProjectStepRunPlant__FP4STEPP5BLRUNffiiP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d3fc0
// Address: 0x1d3fc0 - 0x1d3fd4

void entry_1d3fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d3fc0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d3fc4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d3fc8: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d3fcc: 0xc074ed6
    SET_GPR_U32(ctx, 31, 0x1d3fd4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FIntersectStepRunPlant__FP4STEPP6VECTORT1Pf(rdram, ctx, runtime); return;
}


// Function: entry_1d3fd4
// Address: 0x1d3fd4 - 0x1d4004

void entry_1d3fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d3fd4) {
        switch (ctx->pc) {
            case 0x1d3fe4: ctx->pc = 0; goto label_1d3fe4;
            case 0x1d3ff4: ctx->pc = 0; goto label_1d3ff4;
            case 0x1d3ffc: ctx->pc = 0; goto label_1d3ffc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d3fd4: 0x10400003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d3fe4;
    }
    // 0x1d3fdc: 0x10000007
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d3ffc;
    }
label_1d3fe4:
    // 0x1d3fe4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d3fe8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1d3fec: 0x10000003
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d3ffc;
    }
label_1d3ff4:
    // 0x1d3ff4: 0x4600b506
    ctx->f[20] = FPU_MOV_S(ctx->f[22]);
    // 0x1d3ff8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
label_1d3ffc:
    // 0x1d3ffc: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x1d4004);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_1d4004
// Address: 0x1d4004 - 0x1d4010

void entry_1d4004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4004: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d4008: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x1d4010);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_1d4010
// Address: 0x1d4010 - 0x1d401c

void entry_1d4010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4010: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d4014: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x1d401c);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_1d401c
// Address: 0x1d401c - 0x1d403c

void entry_1d401c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d401c: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d4020: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d4024: 0x40502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d4028: 0x24040050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 80));
    // 0x1d402c: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1d4030: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d4034: 0xc074f1a
    SET_GPR_U32(ctx, 31, 0x1d403c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FReblendAbl2D__FiiiP2BLe(rdram, ctx, runtime); return;
}


// Function: entry_1d403c
// Address: 0x1d403c - 0x1d4054

void entry_1d403c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d403c: 0x1040000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d406c(rdram, ctx, runtime); return;
    }
    // 0x1d4044: 0x24050050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 80));
    // 0x1d4048: 0x24060006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1d404c: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x1d4054);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_1d4054
// Address: 0x1d4054 - 0x1d406c

void entry_1d4054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4054: 0x8ea200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 192)));
    // 0x1d4058: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d405c: 0x26670640
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 1600));
    // 0x1d4060: 0x24040006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1d4064: 0xc074e78
    SET_GPR_U32(ctx, 31, 0x1d406c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    CalculateBlrunV__FiP5BLRUNP4MRSGP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d406c
// Address: 0x1d406c - 0x1d40a0

void entry_1d406c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d406c: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d4070: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d4074: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d4078: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d407c: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d4080: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d4084: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d4088: 0xc7b600c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[22] = *(float*)&val; }
    // 0x1d408c: 0xc7b500b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[21] = *(float*)&val; }
    // 0x1d4090: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1d4094: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d409c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d40a0; return;
}


// Function: SetStepRunTarget__FP4STEPffP5BLRUNP6ASEGBL
// Address: 0x1d40a0 - 0x1d4114

void entry_1d4114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4114: 0x8e2200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 192)));
    // 0x1d4118: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d411c: 0x26470640
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 1600));
    // 0x1d4120: 0x24040006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1d4124: 0xc074e78
    SET_GPR_U32(ctx, 31, 0x1d412c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    CalculateBlrunV__FiP5BLRUNP4MRSGP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d412c
// Address: 0x1d412c - 0x1d4148

void entry_1d412c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d412c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d4130: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d4134: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d4138: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d413c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d4144: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d4148; return;
}


// Function: PostJtLoadSidestep__FP2JTP4BLSSPP6ASEGBL
// Address: 0x1d4148 - 0x1d41d8

void entry_1d41d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d41d8: 0x8e02009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 156)));
    // 0x1d41dc: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1d41e0: 0xc60c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1d41e4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d41e8: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1d41ec: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d41f0: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d41f4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d41f8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d41fc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d4204);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d4204
// Address: 0x1d4204 - 0x1d426c

void entry_1d4204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4204) {
        switch (ctx->pc) {
            case 0x1d423c: ctx->pc = 0; goto label_1d423c;
            case 0x1d4240: ctx->pc = 0; goto label_1d4240;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4204: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d4208: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d420c: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d4210: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1d4214: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d4218: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d421c: 0xc6000034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1d4220: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1d4224: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1d4228: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d422c: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d4230: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d4234: 0x10000028
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1d42d8(rdram, ctx, runtime); return;
    }
label_1d423c:
    // 0x1d423c: 0x2e620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 8));
label_1d4240:
    // 0x1d4240: 0x10400025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d42d8(rdram, ctx, runtime); return;
    }
    // 0x1d4248: 0x131880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 2));
    // 0x1d424c: 0x2442dbd0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294958032));
    // 0x1d4250: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1d4254: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d4258: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1d4260: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1d4264: 0xc04b33a
    SET_GPR_U32(ctx, 31, 0x1d426c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1552)));
    PchnFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1d426c
// Address: 0x1d426c - 0x1d4298

void entry_1d426c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d426c: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1d4270: 0x26280010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 16));
    // 0x1d4274: 0x8e450610
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1552)));
    // 0x1d4278: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d427c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d4280: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1d4284: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d4288: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d428c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d4290: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d4298);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d4298
// Address: 0x1d4298 - 0x1d42ac

void entry_1d4298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4298: 0x10000010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D42DC; return;
    }
    // 0x1d42a0: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1d42a4: 0xc04b33a
    SET_GPR_U32(ctx, 31, 0x1d42ac);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1556)));
    PchnFindAseg__FP4ASEGP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1d42ac
// Address: 0x1d42ac - 0x1d42d8

void entry_1d42ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d42ac: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1d42b0: 0x26280010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 16));
    // 0x1d42b4: 0x8e450614
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1556)));
    // 0x1d42b8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d42bc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d42c0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1d42c4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d42c8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d42cc: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d42d0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d42d8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d42d8
// Address: 0x1d42d8 - 0x1d430c

void entry_1d42d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d42d8) {
        switch (ctx->pc) {
            case 0x1d42dc: ctx->pc = 0; goto label_1d42dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d42d8: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_1d42dc:
    // 0x1d42dc: 0x2a620008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 8));
    // 0x1d42e0: 0x1440ffab
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 5));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4190; return;
    }
    // 0x1d42e8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d42ec: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d42f0: 0x2a0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1d42f4: 0x24050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1d42f8: 0x24060008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1d42fc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4300: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4304: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x1d430c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_1d430c
// Address: 0x1d430c - 0x1d4320

void entry_1d430c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d430c: 0x8ea40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1d4310: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d4314: 0x24050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1d4318: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x1d4320);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_1d4320
// Address: 0x1d4320 - 0x1d4348

void entry_1d4320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4320: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d4324: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d4328: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d432c: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d4330: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d4334: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d4338: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d433c: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1d4340: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL
// Address: 0x1d4348 - 0x1d468c

void entry_1d468c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d468c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d4690: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetJtSidestepTarget__FP2JTP4BLSSP6ASEGBLff
// Address: 0x1d4698 - 0x1d46cc

void entry_1d46cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d46cc) {
        switch (ctx->pc) {
            case 0x1d46f8: ctx->pc = 0; goto label_1d46f8;
            case 0x1d4720: ctx->pc = 0; goto label_1d4720;
            case 0x1d4730: ctx->pc = 0; goto label_1d4730;
            case 0x1d4748: ctx->pc = 0; goto label_1d4748;
            case 0x1d47b8: ctx->pc = 0; goto label_1d47b8;
            case 0x1d4810: ctx->pc = 0; goto label_1d4810;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d46cc: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d46d0: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1d46d4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d46d8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d46dc: 0x45000006
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d46f8;
    }
    // 0x1d46e4: 0x8e020a14
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2580)));
    // 0x1d46e8: 0x1440000d
    ctx->f[1] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1d4720;
    }
    // 0x1d46f0: 0x10000015
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d4748;
    }
label_1d46f8:
    // 0x1d46f8: 0x3c01c120
    SET_GPR_U32(ctx, 1, ((uint32_t)49440 << 16));
    // 0x1d46fc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d4700: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d4704: 0x0
    // NOP
    // 0x1d4708: 0x45000009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d4730;
    }
    // 0x1d4710: 0x8e030a14
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2580)));
    // 0x1d4714: 0x1462000c
    ctx->f[1] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1d4748;
    }
    // 0x1d471c: 0xe7b40004
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
label_1d4720:
    // 0x1d4720: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d4724: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d4728: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d4748;
    }
label_1d4730:
    // 0x1d4730: 0x8e030a14
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2580)));
    // 0x1d4734: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1d4738: 0x10620003
    ctx->f[1] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d4748;
    }
    // 0x1d4740: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x1d4744: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
label_1d4748:
    // 0x1d4748: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d474c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d4750: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d4754: 0x0
    // NOP
    // 0x1d4758: 0x45000017
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d47b8;
    }
    // 0x1d4760: 0xc7a30004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[3] = *(float*)&val; }
    // 0x1d4764: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d4768: 0x44021800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[3]);
    // 0x1d476c: 0x460100a9
    ctx->f[2] = std::min(ctx->f[0], ctx->f[1]);
    // 0x1d4770: 0xda2400b0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 176)));
    // 0x1d4774: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d4778: 0x46001087
    ctx->f[2] = FPU_NEG_S(ctx->f[2]);
    // 0x1d477c: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1d4780: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d4784: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d4788: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d478c: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x1d4790: 0xda220030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 48)));
    // 0x1d4794: 0x48a23000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d4798: 0xda210070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 112)));
    // 0x1d479c: 0xfba50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1d47a0: 0x4be311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1d47a4: 0x4be508bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1d47a8: 0x4be620c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d47ac: 0xfa030640
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d47b0: 0x10000017
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[6]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d4810;
    }
label_1d47b8:
    // 0x1d47b8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d47bc: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1d47c0: 0x460100e9
    ctx->f[3] = std::min(ctx->f[0], ctx->f[1]);
    // 0x1d47c4: 0xda240090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 144)));
    // 0x1d47c8: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1d47cc: 0x46001087
    ctx->f[2] = FPU_NEG_S(ctx->f[2]);
    // 0x1d47d0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d47d4: 0x48a23000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d47d8: 0x460018c7
    ctx->f[3] = FPU_NEG_S(ctx->f[3]);
    // 0x1d47dc: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x1d47e0: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d47e4: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d47e8: 0x44021800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[3]);
    // 0x1d47ec: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d47f0: 0xda230010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1d47f4: 0xda210050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1d47f8: 0xfba60010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1d47fc: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d4800: 0x4be608bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1d4804: 0x4be52088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d4808: 0xfa020640
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d480c: 0xfba50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
label_1d4810:
    // 0x1d4810: 0xae000648
    WRITE32(ADD32(GPR_U32(ctx, 16), 1608), GPR_U32(ctx, 0));
    // 0x1d4814: 0x8e022230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8752)));
    // 0x1d4818: 0xda010640
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1600)));
    // 0x1d481c: 0x8c420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1d4820: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d4824: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d4828: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d482c: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d4830: 0xfa010640
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d4834: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d4838: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d483c: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x1d4840: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostJtLoadZap__FP2JT
// Address: 0x1d4848 - 0x1d4880

void entry_1d4880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4880) {
        switch (ctx->pc) {
            case 0x1d4898: ctx->pc = 0; goto label_1d4898;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4880: 0x8e2326a8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9896)));
    // 0x1d4884: 0x18600011
    WRITE32(ADD32(GPR_U32(ctx, 17), 9900), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1D48CC; return;
    }
    // 0x1d488c: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4890: 0x8e3026ac
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 9900)));
    // 0x1d4894: 0x0
    // NOP
label_1d4898:
    // 0x1d4898: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d489c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1d48a0: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d48a4: 0x2138021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 19)));
    // 0x1d48a8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1d48ac: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d48b0: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1d48b8);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 12));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1d48b8
// Address: 0x1d48b8 - 0x1d48e8

void entry_1d48b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d48b8) {
        switch (ctx->pc) {
            case 0x1d48cc: ctx->pc = 0; goto label_1d48cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d48b8: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x1d48bc: 0x8e2226a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9896)));
    // 0x1d48c0: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1d48c4: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 9900)));
        ctx->pc = 0x1D4898; return;
    }
label_1d48cc:
    // 0x1d48cc: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d48d0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d48d4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d48d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d48dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d48e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PresetJtAccelZap__FP2JT
// Address: 0x1d48e8 - 0x1d4964

void entry_1d4964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4964: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d4968: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x1d496c: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1d4970: 0x3c080027
    SET_GPR_U32(ctx, 8, ((uint32_t)39 << 16));
    // 0x1d4974: 0xc44c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1d4978: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x1d497c: 0x25085020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 20512));
    // 0x1d4980: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d4984: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4988: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d498c: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x1d4994);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_1d4994
// Address: 0x1d4994 - 0x1d49cc

void entry_1d4994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4994: 0x10000033
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 6232));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4A64; return;
    }
    // 0x1d499c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1d49a0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d49a4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d49a8: 0xda010350
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 848)));
    // 0x1d49ac: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d49b0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d49b4: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d49b8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1d49bc: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d49c0: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d49c4: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1d49cc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d49cc
// Address: 0x1d49cc - 0x1d4a20

void entry_1d49cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d49cc) {
        switch (ctx->pc) {
            case 0x1d49f4: ctx->pc = 0; goto label_1d49f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d49cc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d49d0: 0xc6000648
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1608)); ctx->f[0] = *(float*)&val; }
    // 0x1d49d4: 0x24528d30
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1d49d8: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d49dc: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d49e0: 0x0
    // NOP
    // 0x1d49e4: 0x45010003
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d49f4;
    }
    // 0x1d49ec: 0xc6000158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 344)); ctx->f[0] = *(float*)&val; }
    // 0x1d49f0: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
label_1d49f4:
    // 0x1d49f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d49f8: 0x3c080027
    SET_GPR_U32(ctx, 8, ((uint32_t)39 << 16));
    // 0x1d49fc: 0x24511858
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1d4a00: 0x25085020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 20512));
    // 0x1d4a04: 0xc62c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1d4a08: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d4a0c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4a10: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4a14: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d4a18: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x1d4a20);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_1d4a20
// Address: 0x1d4a20 - 0x1d4a60

void entry_1d4a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4a20: 0xc6000648
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1608)); ctx->f[0] = *(float*)&val; }
    // 0x1d4a24: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d4a28: 0x0
    // NOP
    // 0x1d4a2c: 0x4501000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 6232));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D4A64; return;
    }
    // 0x1d4a34: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1d4a38: 0xc7a10018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1d4a3c: 0xc6220008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1d4a40: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d4a44: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d4a48: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d4a4c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1d4a50: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1d4a54: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x1d4a58: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1d4a60);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d4a60
// Address: 0x1d4a60 - 0x1d4a78

void entry_1d4a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4a60) {
        switch (ctx->pc) {
            case 0x1d4a64: ctx->pc = 0; goto label_1d4a64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4a60: 0x26621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 6232));
label_1d4a64:
    // 0x1d4a64: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d4a68: 0xc44c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1d4a6c: 0x24850660
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 1632));
    // 0x1d4a70: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x1d4a78);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1760));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_1d4a78
// Address: 0x1d4a78 - 0x1d4a98

void entry_1d4a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4a78: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d4a7c: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d4a80: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d4a84: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d4a88: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d4a8c: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x1d4a90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtZap__FP2JT
// Address: 0x1d4a98 - 0x1d4ad8

void entry_1d4ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4ad8: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1d4adc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1d4ae0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d4ae4: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1d4ae8: 0x26101858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6232));
    // 0x1d4aec: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d4af0: 0x460d0340
    ctx->f[13] = FPU_ADD_S(ctx->f[0], ctx->f[13]);
    // 0x1d4af4: 0xc62c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1d4af8: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1d4afc: 0x24845030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 20528));
    // 0x1d4b00: 0xc07a9ca
    SET_GPR_U32(ctx, 31, 0x1d4b08);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RadSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d4b08
// Address: 0x1d4b08 - 0x1d4b98

void entry_1d4b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4b08) {
        switch (ctx->pc) {
            case 0x1d4b44: ctx->pc = 0; goto label_1d4b44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4b08: 0xe6200638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
    // 0x1d4b0c: 0xc622222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x1d4b10: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d4b14: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1d4b18: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d4b1c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1d4b20: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d4b24: 0x0
    // NOP
    // 0x1d4b28: 0x45000055
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D4C80; return;
    }
    // 0x1d4b30: 0x8e220690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
    // 0x1d4b34: 0x50400053
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
        ctx->pc = 0x1D4C84; return;
    }
    // 0x1d4b3c: 0x10000034
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4C10; return;
    }
label_1d4b44:
    // 0x1d4b44: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d4b48: 0x8e232514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x1d4b4c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d4b50: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1d4b54: 0xc4620018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[2] = *(float*)&val; }
    // 0x1d4b58: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d4b5c: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d4b60: 0x4501002b
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D4C10; return;
    }
    // 0x1d4b68: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d4b6c: 0x50800039
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
        ctx->pc = 0x1D4C54; return;
    }
    // 0x1d4b74: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1d4b78: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d4b7c: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1d4b80: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d4b84: 0x0
    // NOP
    // 0x1d4b88: 0x45020032
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
        ctx->pc = 0x1D4C54; return;
    }
    // 0x1d4b90: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d4b98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 118));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d4b98
// Address: 0x1d4b98 - 0x1d4bac

void entry_1d4b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4b98: 0x5440001b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9904)));
        ctx->pc = 0x1D4C08; return;
    }
    // 0x1d4ba0: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d4ba4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d4bac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 112));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d4bac
// Address: 0x1d4bac - 0x1d4bc0

void entry_1d4bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4bac: 0x54400016
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9904)));
        ctx->pc = 0x1D4C08; return;
    }
    // 0x1d4bb4: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d4bb8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d4bc0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 113));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d4bc0
// Address: 0x1d4bc0 - 0x1d4bd4

void entry_1d4bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4bc0: 0x54400011
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9904)));
        ctx->pc = 0x1D4C08; return;
    }
    // 0x1d4bc8: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d4bcc: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d4bd4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 129));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d4bd4
// Address: 0x1d4bd4 - 0x1d4be8

void entry_1d4bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4bd4: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9904)));
        ctx->pc = 0x1D4C08; return;
    }
    // 0x1d4bdc: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d4be0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d4be8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 111));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d4be8
// Address: 0x1d4be8 - 0x1d4bfc

void entry_1d4be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4be8: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9904)));
        ctx->pc = 0x1D4C08; return;
    }
    // 0x1d4bf0: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d4bf4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d4bfc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 127));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d4bfc
// Address: 0x1d4bfc - 0x1d4c18

void entry_1d4bfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4bfc) {
        switch (ctx->pc) {
            case 0x1d4c08: ctx->pc = 0; goto label_1d4c08;
            case 0x1d4c10: ctx->pc = 0; goto label_1d4c10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4bfc: 0x50400015
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
        ctx->pc = 0x1D4C54; return;
    }
    // 0x1d4c04: 0x8e2226b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9904)));
label_1d4c08:
    // 0x1d4c08: 0x10400005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4C20; return;
    }
label_1d4c10:
    // 0x1d4c10: 0xc075326
    SET_GPR_U32(ctx, 31, 0x1d4c18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001d4c98(rdram, ctx, runtime); return;
}


// Function: entry_1d4c18
// Address: 0x1d4c18 - 0x1d4c30

void entry_1d4c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4c18) {
        switch (ctx->pc) {
            case 0x1d4c20: ctx->pc = 0; goto label_1d4c20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4c18: 0x10000019
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4C80; return;
    }
label_1d4c20:
    // 0x1d4c20: 0x8e302b70
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d4c24: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d4c28: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d4c30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d4c30
// Address: 0x1d4c30 - 0x1d4c3c

void entry_1d4c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4c30: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d4c34: 0xc073c56
    SET_GPR_U32(ctx, 31, 0x1d4c3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001cf158(rdram, ctx, runtime); return;
}


// Function: entry_1d4c3c
// Address: 0x1d4c3c - 0x1d4c4c

void entry_1d4c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4c3c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d4c40: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d4c44: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d4c4c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d4c4c
// Address: 0x1d4c4c - 0x1d4c7c

void entry_1d4c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4c4c) {
        switch (ctx->pc) {
            case 0x1d4c54: ctx->pc = 0; goto label_1d4c54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4c4c: 0x1000000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4C80; return;
    }
label_1d4c54:
    // 0x1d4c54: 0x26021858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 6232));
    // 0x1d4c58: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d4c5c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d4c60: 0xc4ec0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 24)); ctx->f[12] = *(float*)&val; }
    // 0x1d4c64: 0x24852b70
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 11120));
    // 0x1d4c68: 0x24e70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 32));
    // 0x1d4c6c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4c70: 0x46006301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x1d4c74: 0xc05e0b0
    SET_GPR_U32(ctx, 31, 0x1d4c7c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001782c0(rdram, ctx, runtime); return;
}


// Function: entry_1d4c7c
// Address: 0x1d4c7c - 0x1d4c90

void entry_1d4c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4c7c) {
        switch (ctx->pc) {
            case 0x1d4c80: ctx->pc = 0; goto label_1d4c80;
            case 0x1d4c84: ctx->pc = 0; goto label_1d4c84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4c7c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1d4c80:
    // 0x1d4c80: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1d4c84:
    // 0x1d4c84: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d4c88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d4c90
// Address: 0x1d4c90 - 0x1d4c98

void FUN_001d4c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4c90: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 9904), GPR_U32(ctx, 5));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d4c98
// Address: 0x1d4c98 - 0x1d4cc4

void FUN_001d4c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4c98: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1d4c9c: 0x2403ffef
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967279));
    // 0x1d4ca0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1d4ca4: 0x8c822254
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8788)));
    // 0x1d4ca8: 0x8c8526b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 9904)));
    // 0x1d4cac: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1d4cb0: 0xac8026b0
    WRITE32(ADD32(GPR_U32(ctx, 4), 9904), GPR_U32(ctx, 0));
    // 0x1d4cb4: 0x10a00005
    WRITE32(ADD32(GPR_U32(ctx, 4), 8788), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4CCC; return;
    }
    // 0x1d4cbc: 0xa0f809
    SET_GPR_U32(ctx, 31, 0x1d4cc4);
    ctx->pc = GPR_U32(ctx, 5); return;
}


// Function: entry_1d4cc4
// Address: 0x1d4cc4 - 0x1d4ce8

void entry_1d4cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4cc4) {
        switch (ctx->pc) {
            case 0x1d4ccc: ctx->pc = 0; goto label_1d4ccc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4cc4: 0x1000000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4CFC; return;
    }
label_1d4ccc:
    // 0x1d4ccc: 0x8c822228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8744)));
    // 0x1d4cd0: 0x2442ffd3
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967251));
    // 0x1d4cd4: 0x2c420005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 5));
    // 0x1d4cd8: 0x10400005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4CF0; return;
    }
    // 0x1d4ce0: 0xc075588
    SET_GPR_U32(ctx, 31, 0x1d4ce8);
    FUN_001d5620(rdram, ctx, runtime); return;
}


// Function: entry_1d4ce8
// Address: 0x1d4ce8 - 0x1d4cf8

void entry_1d4ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4ce8) {
        switch (ctx->pc) {
            case 0x1d4cf0: ctx->pc = 0; goto label_1d4cf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4ce8: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4CFC; return;
    }
label_1d4cf0:
    // 0x1d4cf0: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d4cf8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d4cf8
// Address: 0x1d4cf8 - 0x1d4d08

void entry_1d4cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4cf8) {
        switch (ctx->pc) {
            case 0x1d4cfc: ctx->pc = 0; goto label_1d4cfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4cf8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1d4cfc:
    // 0x1d4cfc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d4d04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d4d08; return;
}


// Function: FTakeJtDamage__FP2JTP3ZPR
// Address: 0x1d4d08 - 0x1d4d38

void entry_1d4d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4d38: 0x14400112
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5184; return;
    }
    // 0x1d4d40: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x1d4d44: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1d4d48: 0x1462000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D4D88; return;
    }
    // 0x1d4d50: 0x8e23239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x1d4d54: 0x1462000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 19));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D4D88; return;
    }
    // 0x1d4d5c: 0x8e2423b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9136)));
    // 0x1d4d60: 0xafb20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 18));
    // 0x1d4d64: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d4d68: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1d4d70);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1d4d70
// Address: 0x1d4d70 - 0x1d4d80

void entry_1d4d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4d70: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d4d74: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d4d78: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d4d80);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d4d80
// Address: 0x1d4d80 - 0x1d4de4

void entry_1d4d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4d80) {
        switch (ctx->pc) {
            case 0x1d4d88: ctx->pc = 0; goto label_1d4d88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4d80: 0x10000100
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5184; return;
    }
label_1d4d88:
    // 0x1d4d88: 0x6a420007
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1d4d8c: 0x6e420000
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1d4d90: 0x6a43000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1d4d94: 0x6e430008
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1d4d98: 0xb22226bb
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 9915); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1d4d9c: 0xb62226b4
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 9908); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1d4da0: 0xb22326c3
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 9923); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1d4da4: 0xb62326bc
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 9916); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1d4da8: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d4dac: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x1d4db0: 0x1062002d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D4E68; return;
    }
    // 0x1d4db8: 0x1062002c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D4E6C; return;
    }
    // 0x1d4dc0: 0x8e2226c4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9924)));
    // 0x1d4dc4: 0x14400029
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4E6C; return;
    }
    // 0x1d4dcc: 0x8c622c64
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11364)));
    // 0x1d4dd0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1d4dd4: 0x14400025
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4E6C; return;
    }
    // 0x1d4ddc: 0xc0776a0
    SET_GPR_U32(ctx, 31, 0x1d4de4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    IsSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1d4de4
// Address: 0x1d4de4 - 0x1d4e18

void entry_1d4de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4de4) {
        switch (ctx->pc) {
            case 0x1d4e10: ctx->pc = 0; goto label_1d4e10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4de4: 0x54400021
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1D4E6C; return;
    }
    // 0x1d4dec: 0x8e2326b4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9908)));
    // 0x1d4df0: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1d4df4: 0x10620006
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d4e10;
    }
    // 0x1d4dfc: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1d4e00: 0x10620007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D4E20; return;
    }
    // 0x1d4e08: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 10032), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4E3C; return;
    }
label_1d4e10:
    // 0x1d4e10: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1d4e18);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d4e18
// Address: 0x1d4e18 - 0x1d4e28

void entry_1d4e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4e18) {
        switch (ctx->pc) {
            case 0x1d4e20: ctx->pc = 0; goto label_1d4e20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4e18: 0x10000004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 256));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4E2C; return;
    }
label_1d4e20:
    // 0x1d4e20: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1d4e28);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d4e28
// Address: 0x1d4e28 - 0x1d4e50

void entry_1d4e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4e28) {
        switch (ctx->pc) {
            case 0x1d4e2c: ctx->pc = 0; goto label_1d4e2c;
            case 0x1d4e3c: ctx->pc = 0; goto label_1d4e3c;
            case 0x1d4e40: ctx->pc = 0; goto label_1d4e40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4e28: 0x30424000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16384));
label_1d4e2c:
    // 0x1d4e2c: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
        goto label_1d4e40;
    }
    // 0x1d4e34: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d4e38: 0xae222730
    WRITE32(ADD32(GPR_U32(ctx, 17), 10032), GPR_U32(ctx, 2));
label_1d4e3c:
    // 0x1d4e3c: 0x8e222730
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
label_1d4e40:
    // 0x1d4e40: 0x1040000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4E6C; return;
    }
    // 0x1d4e48: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1d4e50);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d4e50
// Address: 0x1d4e50 - 0x1d4e74

void entry_1d4e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4e50) {
        switch (ctx->pc) {
            case 0x1d4e68: ctx->pc = 0; goto label_1d4e68;
            case 0x1d4e6c: ctx->pc = 0; goto label_1d4e6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4e50: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d4e68;
    }
    // 0x1d4e58: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d4e5c: 0xae2226c4
    WRITE32(ADD32(GPR_U32(ctx, 17), 9924), GPR_U32(ctx, 2));
    // 0x1d4e60: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1d4e64: 0xe62026c8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 9928), *(uint32_t*)&val); }
label_1d4e68:
    // 0x1d4e68: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1d4e6c:
    // 0x1d4e6c: 0xc075324
    SET_GPR_U32(ctx, 31, 0x1d4e74);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001d4c90(rdram, ctx, runtime); return;
}


// Function: entry_1d4e74
// Address: 0x1d4e74 - 0x1d4edc

void entry_1d4e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4e74: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d4e78: 0x2c620007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 7));
    // 0x1d4e7c: 0x104000b5
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d5154(rdram, ctx, runtime); return;
    }
    // 0x1d4e84: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1d4e88: 0x2442dc20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294958112));
    // 0x1d4e8c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1d4e90: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d4e94: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1d4e9c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1d4ea0: 0x240400a3
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 163));
    // 0x1d4ea4: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1d4ea8: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1d4eac: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d4eb0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4eb4: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1d4eb8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d4ebc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4ec0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d4ec4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1d4ec8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4ecc: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1d4ed0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4ed4: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1d4edc);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1d4edc
// Address: 0x1d4edc - 0x1d4ef4

void entry_1d4edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4edc: 0x8e2226c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9920)));
    // 0x1d4ee0: 0x10400006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4EFC; return;
    }
    // 0x1d4ee8: 0xae2026c0
    WRITE32(ADD32(GPR_U32(ctx, 17), 9920), GPR_U32(ctx, 0));
    // 0x1d4eec: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d4ef4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9916)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d4ef4
// Address: 0x1d4ef4 - 0x1d4f0c

void entry_1d4ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4ef4) {
        switch (ctx->pc) {
            case 0x1d4efc: ctx->pc = 0; goto label_1d4efc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4ef4: 0x10000006
    SET_GPR_U32(ctx, 5, ((uint32_t)29 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4F10; return;
    }
label_1d4efc:
    // 0x1d4efc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d4f00: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d4f04: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d4f0c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 43));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d4f0c
// Address: 0x1d4f0c - 0x1d4f1c

void entry_1d4f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4f0c) {
        switch (ctx->pc) {
            case 0x1d4f10: ctx->pc = 0; goto label_1d4f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4f0c: 0x3c05001d
    SET_GPR_U32(ctx, 5, ((uint32_t)29 << 16));
label_1d4f10:
    // 0x1d4f10: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d4f14: 0xc075324
    SET_GPR_U32(ctx, 31, 0x1d4f1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 20896));
    FUN_001d4c90(rdram, ctx, runtime); return;
}


// Function: entry_1d4f1c
// Address: 0x1d4f1c - 0x1d4f3c

void entry_1d4f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4f1c: 0x1000008e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5158; return;
    }
    // 0x1d4f24: 0x8e2226c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9920)));
    // 0x1d4f28: 0x10400006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4F44; return;
    }
    // 0x1d4f30: 0xae2026c0
    WRITE32(ADD32(GPR_U32(ctx, 17), 9920), GPR_U32(ctx, 0));
    // 0x1d4f34: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d4f3c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9916)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d4f3c
// Address: 0x1d4f3c - 0x1d4f54

void entry_1d4f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4f3c) {
        switch (ctx->pc) {
            case 0x1d4f44: ctx->pc = 0; goto label_1d4f44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4f3c: 0x10000006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 344)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D4F58; return;
    }
label_1d4f44:
    // 0x1d4f44: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d4f48: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d4f4c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d4f54);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 43));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d4f54
// Address: 0x1d4f54 - 0x1d4fac

void entry_1d4f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4f54) {
        switch (ctx->pc) {
            case 0x1d4f58: ctx->pc = 0; goto label_1d4f58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4f54: 0xc6210158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 344)); ctx->f[1] = *(float*)&val; }
label_1d4f58:
    // 0x1d4f58: 0x3c0143c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17352 << 16));
    // 0x1d4f5c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d4f60: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d4f64: 0x0
    // NOP
    // 0x1d4f68: 0x45000010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 163));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1d4fac(rdram, ctx, runtime); return;
    }
    // 0x1d4f70: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1d4f74: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1d4f78: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1d4f7c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d4f80: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4f84: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1d4f88: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d4f8c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4f90: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d4f94: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1d4f98: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4f9c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1d4fa0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d4fa4: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1d4fac);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1d4fac
// Address: 0x1d4fac - 0x1d4fbc

void entry_1d4fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d4fac: 0x3c05001d
    SET_GPR_U32(ctx, 5, ((uint32_t)29 << 16));
    // 0x1d4fb0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d4fb4: 0xc075324
    SET_GPR_U32(ctx, 31, 0x1d4fbc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 21400));
    FUN_001d4c90(rdram, ctx, runtime); return;
}


// Function: entry_1d4fbc
// Address: 0x1d4fbc - 0x1d5018

void entry_1d4fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d4fbc) {
        switch (ctx->pc) {
            case 0x1d4ff0: ctx->pc = 0; goto label_1d4ff0;
            case 0x1d5000: ctx->pc = 0; goto label_1d5000;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d4fbc: 0x10000066
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5158; return;
    }
    // 0x1d4fc4: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x1d4fc8: 0x2402000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    // 0x1d4fcc: 0x54620008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 336)));
        goto label_1d4ff0;
    }
    // 0x1d4fd4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d4fd8: 0x24448d30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1d4fdc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d4fe0: 0x78830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d4fe4: 0x7e232bb0
    WRITE128(ADD32(GPR_U32(ctx, 17), 11184), GPR_VEC(ctx, 3));
    // 0x1d4fe8: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 17), 11200), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d5000;
    }
label_1d4ff0:
    // 0x1d4ff0: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x1d4ff4: 0x7a220160
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 352)));
    // 0x1d4ff8: 0x7e232bb0
    WRITE128(ADD32(GPR_U32(ctx, 17), 11184), GPR_VEC(ctx, 3));
    // 0x1d4ffc: 0x7e222bc0
    WRITE128(ADD32(GPR_U32(ctx, 17), 11200), GPR_VEC(ctx, 2));
label_1d5000:
    // 0x1d5000: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d5004: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x1d5008: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d500c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1d5010: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d5018);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d5018
// Address: 0x1d5018 - 0x1d502c

void entry_1d5018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5018: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d501c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d5020: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1d5024: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d502c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d502c
// Address: 0x1d502c - 0x1d5068

void entry_1d502c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d502c) {
        switch (ctx->pc) {
            case 0x1d504c: ctx->pc = 0; goto label_1d504c;
            case 0x1d5054: ctx->pc = 0; goto label_1d5054;
            case 0x1d5058: ctx->pc = 0; goto label_1d5058;
            case 0x1d5060: ctx->pc = 0; goto label_1d5060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d502c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d5030: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d5034: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d504c;
    }
    // 0x1d503c: 0x10620005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d5054;
    }
    // 0x1d5044: 0x10000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d5060;
    }
label_1d504c:
    // 0x1d504c: 0x10000002
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 37));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d5058;
    }
label_1d5054:
    // 0x1d5054: 0x24130026
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 38));
label_1d5058:
    // 0x1d5058: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d505c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1d5060:
    // 0x1d5060: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d5068);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d5068
// Address: 0x1d5068 - 0x1d5078

void entry_1d5068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5068: 0x3c05001d
    SET_GPR_U32(ctx, 5, ((uint32_t)29 << 16));
    // 0x1d506c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d5070: 0xc075324
    SET_GPR_U32(ctx, 31, 0x1d5078);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 21608));
    FUN_001d4c90(rdram, ctx, runtime); return;
}


// Function: entry_1d5078
// Address: 0x1d5078 - 0x1d5094

void entry_1d5078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5078: 0x10000037
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5158; return;
    }
    // 0x1d5080: 0x8e222730
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
    // 0x1d5084: 0x10400005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D509C; return;
    }
    // 0x1d508c: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1d5094);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d5094
// Address: 0x1d5094 - 0x1d50b4

void entry_1d5094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5094) {
        switch (ctx->pc) {
            case 0x1d509c: ctx->pc = 0; goto label_1d509c;
            case 0x1d50a8: ctx->pc = 0; goto label_1d50a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5094: 0x10400004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d50a8;
    }
label_1d509c:
    // 0x1d509c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d50a0: 0x10000021
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 39));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5128; return;
    }
label_1d50a8:
    // 0x1d50a8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d50ac: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d50b4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 47));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d50b4
// Address: 0x1d50b4 - 0x1d50d4

void entry_1d50b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d50b4: 0x10000028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5158; return;
    }
    // 0x1d50bc: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d50c0: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1d50c4: 0x24a55040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 20544));
    // 0x1d50c8: 0x8c430090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x1d50cc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1d50d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1d50d4
// Address: 0x1d50d4 - 0x1d50dc

void entry_1d50d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d50d4: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1d50dc);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d50dc
// Address: 0x1d50dc - 0x1d50fc

void entry_1d50dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d50dc) {
        switch (ctx->pc) {
            case 0x1d50f0: ctx->pc = 0; goto label_1d50f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d50dc: 0x10400004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d50f0;
    }
    // 0x1d50e4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d50e8: 0x1000000f
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 40));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5128; return;
    }
label_1d50f0:
    // 0x1d50f0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d50f4: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d50fc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 49));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d50fc
// Address: 0x1d50fc - 0x1d5118

void entry_1d50fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d50fc: 0x10000016
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5158; return;
    }
    // 0x1d5104: 0x8e222730
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
    // 0x1d5108: 0x10400005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5120; return;
    }
    // 0x1d5110: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1d5118);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d5118
// Address: 0x1d5118 - 0x1d5130

void entry_1d5118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5118) {
        switch (ctx->pc) {
            case 0x1d5120: ctx->pc = 0; goto label_1d5120;
            case 0x1d5128: ctx->pc = 0; goto label_1d5128;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5118: 0x1040000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5148; return;
    }
label_1d5120:
    // 0x1d5120: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d5124: 0x24060029
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 41));
label_1d5128:
    // 0x1d5128: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d5130);
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d5130
// Address: 0x1d5130 - 0x1d5140

void entry_1d5130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5130: 0x3c05001d
    SET_GPR_U32(ctx, 5, ((uint32_t)29 << 16));
    // 0x1d5134: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d5138: 0xc075324
    SET_GPR_U32(ctx, 31, 0x1d5140);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 26120));
    FUN_001d4c90(rdram, ctx, runtime); return;
}


// Function: entry_1d5140
// Address: 0x1d5140 - 0x1d5154

void entry_1d5140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5140) {
        switch (ctx->pc) {
            case 0x1d5148: ctx->pc = 0; goto label_1d5148;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5140: 0x10000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5158; return;
    }
label_1d5148:
    // 0x1d5148: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d514c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d5154);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d5154
// Address: 0x1d5154 - 0x1d5180

void entry_1d5154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5154) {
        switch (ctx->pc) {
            case 0x1d5158: ctx->pc = 0; goto label_1d5158;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5154: 0x8e222730
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
label_1d5158:
    // 0x1d5158: 0x10400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d5180(rdram, ctx, runtime); return;
    }
    // 0x1d5160: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1d5164: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    // 0x1d5168: 0x24050017
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 23));
    // 0x1d516c: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1d5170: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d5174: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1d5178: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1d5180);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1d5180
// Address: 0x1d5180 - 0x1d51a0

void entry_1d5180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5180) {
        switch (ctx->pc) {
            case 0x1d5184: ctx->pc = 0; goto label_1d5184;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5180: 0x8e222730
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10032)));
label_1d5184:
    // 0x1d5184: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d5188: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d518c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d5190: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d5194: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d5198: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d51a0
// Address: 0x1d51a0 - 0x1d51d8

void FUN_001d51a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d51a0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1d51a4: 0x2403002c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 44));
    // 0x1d51a8: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1d51ac: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1d51b0: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d51b4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1d51b8: 0x8e222228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x1d51bc: 0x1443003a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1D52A8; return;
    }
    // 0x1d51c4: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d51c8: 0x10800037
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D52A8; return;
    }
    // 0x1d51d0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d51d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 112));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d51d8
// Address: 0x1d51d8 - 0x1d51ec

void entry_1d51d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d51d8: 0x1440001a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5244; return;
    }
    // 0x1d51e0: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d51e4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d51ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 113));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d51ec
// Address: 0x1d51ec - 0x1d5200

void entry_1d51ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d51ec: 0x14400015
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5244; return;
    }
    // 0x1d51f4: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d51f8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d5200);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 129));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d5200
// Address: 0x1d5200 - 0x1d5214

void entry_1d5200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5200: 0x14400010
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5244; return;
    }
    // 0x1d5208: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d520c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d5214);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 111));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d5214
// Address: 0x1d5214 - 0x1d5228

void entry_1d5214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5214: 0x1440000b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5244; return;
    }
    // 0x1d521c: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d5220: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d5228);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 127));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d5228
// Address: 0x1d5228 - 0x1d523c

void entry_1d5228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5228: 0x14400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5244; return;
    }
    // 0x1d5230: 0x8e242b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d5234: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d523c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 118));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d523c
// Address: 0x1d523c - 0x1d524c

void entry_1d523c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d523c) {
        switch (ctx->pc) {
            case 0x1d5244: ctx->pc = 0; goto label_1d5244;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d523c: 0x1040001a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D52A8; return;
    }
label_1d5244:
    // 0x1d5244: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1d524c);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d524c
// Address: 0x1d524c - 0x1d525c

void entry_1d524c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d524c: 0x10400011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5294; return;
    }
    // 0x1d5254: 0xc064b16
    SET_GPR_U32(ctx, 31, 0x1d525c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UsePoCharm__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1d525c
// Address: 0x1d525c - 0x1d5270

void entry_1d525c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d525c: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d5260: 0x8e302b70
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 11120)));
    // 0x1d5264: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d5268: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d5270);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d5270
// Address: 0x1d5270 - 0x1d527c

void entry_1d5270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5270: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d5274: 0xc073c56
    SET_GPR_U32(ctx, 31, 0x1d527c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001cf158(rdram, ctx, runtime); return;
}


// Function: entry_1d527c
// Address: 0x1d527c - 0x1d528c

void entry_1d527c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d527c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d5280: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d5284: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d528c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d528c
// Address: 0x1d528c - 0x1d52a0

void entry_1d528c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d528c) {
        switch (ctx->pc) {
            case 0x1d5294: ctx->pc = 0; goto label_1d5294;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d528c: 0x10000017
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D52EC; return;
    }
label_1d5294:
    // 0x1d5294: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d5298: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d52a0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 45));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d52a0
// Address: 0x1d52a0 - 0x1d52b0

void entry_1d52a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d52a0) {
        switch (ctx->pc) {
            case 0x1d52a8: ctx->pc = 0; goto label_1d52a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d52a0: 0x10000012
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D52EC; return;
    }
label_1d52a8:
    // 0x1d52a8: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1d52b0);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d52b0
// Address: 0x1d52b0 - 0x1d52c4

void entry_1d52b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d52b0: 0x1040000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D52DC; return;
    }
    // 0x1d52b8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d52bc: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d52c4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 36));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d52c4
// Address: 0x1d52c4 - 0x1d52d4

void entry_1d52c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d52c4: 0x3c05001d
    SET_GPR_U32(ctx, 5, ((uint32_t)29 << 16));
    // 0x1d52c8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d52cc: 0xc075324
    SET_GPR_U32(ctx, 31, 0x1d52d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 26120));
    FUN_001d4c90(rdram, ctx, runtime); return;
}


// Function: entry_1d52d4
// Address: 0x1d52d4 - 0x1d52e8

void entry_1d52d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d52d4) {
        switch (ctx->pc) {
            case 0x1d52dc: ctx->pc = 0; goto label_1d52dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d52d4: 0x10000005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D52EC; return;
    }
label_1d52dc:
    // 0x1d52dc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d52e0: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d52e8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 45));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d52e8
// Address: 0x1d52e8 - 0x1d5384

void entry_1d52e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d52e8) {
        switch (ctx->pc) {
            case 0x1d52ec: ctx->pc = 0; goto label_1d52ec;
            case 0x1d5344: ctx->pc = 0; goto label_1d5344;
            case 0x1d5354: ctx->pc = 0; goto label_1d5354;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d52e8: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
label_1d52ec:
    // 0x1d52ec: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d52f0: 0x14620025
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D5388; return;
    }
    // 0x1d52f8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d52fc: 0xc6220158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 344)); ctx->f[2] = *(float*)&val; }
    // 0x1d5300: 0x24435050
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 20560));
    // 0x1d5304: 0xc4435050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20560)); ctx->f[3] = *(float*)&val; }
    // 0x1d5308: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d530c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d5310: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d5314: 0x24445060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 20576));
    // 0x1d5318: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1d531c: 0xc4445060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20576)); ctx->f[4] = *(float*)&val; }
    // 0x1d5320: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d5324: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1d5328: 0x46021b80
    ctx->f[14] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1d532c: 0x46047034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[14], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d5330: 0x0
    // NOP
    // 0x1d5334: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d5344;
    }
    // 0x1d533c: 0x10000005
    ctx->f[14] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d5354;
    }
label_1d5344:
    // 0x1d5344: 0x460e2834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[14])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d5348: 0x0
    // NOP
    // 0x1d534c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[14] = FPU_MOV_S(ctx->f[5]);
        goto label_1d5354;
    }
label_1d5354:
    // 0x1d5354: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1d5358: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d535c: 0xc44f5068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20584)); ctx->f[15] = *(float*)&val; }
    // 0x1d5360: 0x24040049
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 73));
    // 0x1d5364: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d5368: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d536c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d5370: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1d5374: 0x46006406
    ctx->f[16] = FPU_MOV_S(ctx->f[12]);
    // 0x1d5378: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d537c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1d5384);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1d5384
// Address: 0x1d5384 - 0x1d5398

void entry_1d5384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5384) {
        switch (ctx->pc) {
            case 0x1d5388: ctx->pc = 0; goto label_1d5388;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5384: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1d5388:
    // 0x1d5388: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d538c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d5390: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d5398
// Address: 0x1d5398 - 0x1d53e8

void FUN_001d5398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5398: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1d539c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1d53a0: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1d53a4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d53a8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d53ac: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1d53b0: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1d53b4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d53b8: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1d53bc: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d53c0: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1d53c4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d53c8: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1d53cc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d53d0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1d53d4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d53d8: 0x240400a6
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 166));
    // 0x1d53dc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d53e0: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1d53e8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1d53e8
// Address: 0x1d53e8 - 0x1d53f8

void entry_1d53e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d53e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d53ec: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d53f0: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d53f8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 42));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d53f8
// Address: 0x1d53f8 - 0x1d5408

void entry_1d53f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d53f8: 0x3c05001d
    SET_GPR_U32(ctx, 5, ((uint32_t)29 << 16));
    // 0x1d53fc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d5400: 0xc075324
    SET_GPR_U32(ctx, 31, 0x1d5408);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 21528));
    FUN_001d4c90(rdram, ctx, runtime); return;
}


// Function: entry_1d5408
// Address: 0x1d5408 - 0x1d5418

void entry_1d5408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5408: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d540c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d5410: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d5418
// Address: 0x1d5418 - 0x1d542c

void FUN_001d5418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5418: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1d541c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1d5420: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1d5424: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1d542c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d542c
// Address: 0x1d542c - 0x1d5444

void entry_1d542c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d542c: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D544C; return;
    }
    // 0x1d5434: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d5438: 0x8c620150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x1d543c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d5444);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d5444
// Address: 0x1d5444 - 0x1d5458

void entry_1d5444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5444) {
        switch (ctx->pc) {
            case 0x1d544c: ctx->pc = 0; goto label_1d544c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5444: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D545C; return;
    }
label_1d544c:
    // 0x1d544c: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d5450: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d5458);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 45));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d5458
// Address: 0x1d5458 - 0x1d5468

void entry_1d5458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5458) {
        switch (ctx->pc) {
            case 0x1d545c: ctx->pc = 0; goto label_1d545c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5458: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1d545c:
    // 0x1d545c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d5460: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d5468
// Address: 0x1d5468 - 0x1d5488

void FUN_001d5468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5468: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1d546c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1d5470: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1d5474: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d5478: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d547c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1d5480: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d5488);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 11184));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d5488
// Address: 0x1d5488 - 0x1d549c

void entry_1d5488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5488: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d548c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d5490: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1d5494: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d549c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 11200));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d549c
// Address: 0x1d549c - 0x1d54a4

void entry_1d549c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d549c: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1d54a4);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d54a4
// Address: 0x1d54a4 - 0x1d54bc

void entry_1d54a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d54a4: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D54C4; return;
    }
    // 0x1d54ac: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d54b0: 0x8c620150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x1d54b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d54bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d54bc
// Address: 0x1d54bc - 0x1d54d0

void entry_1d54bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d54bc) {
        switch (ctx->pc) {
            case 0x1d54c4: ctx->pc = 0; goto label_1d54c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d54bc: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D54D4; return;
    }
label_1d54c4:
    // 0x1d54c4: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d54c8: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d54d0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 45));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d54d0
// Address: 0x1d54d0 - 0x1d54e0

void entry_1d54d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d54d0) {
        switch (ctx->pc) {
            case 0x1d54d4: ctx->pc = 0; goto label_1d54d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d54d0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1d54d4:
    // 0x1d54d4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d54d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d54e0
// Address: 0x1d54e0 - 0x1d55ac

void FUN_001d54e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d54e0) {
        switch (ctx->pc) {
            case 0x1d5504: ctx->pc = 0; goto label_1d5504;
            case 0x1d5598: ctx->pc = 0; goto label_1d5598;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d54e0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1d54e4: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d54e8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1d54ec: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1d54f0: 0x10a20004
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_1d5504;
    }
    // 0x1d54f8: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1d54fc: 0x54a20030
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 8736)));
        ctx->pc = 0x1D55C0; return;
    }
label_1d5504:
    // 0x1d5504: 0x8cc32220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 8736)));
    // 0x1d5508: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1d550c: 0x2463fffe
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967294));
    // 0x1d5510: 0x2c620007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 7));
    // 0x1d5514: 0x10400020
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d5598;
    }
    // 0x1d551c: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1d5520: 0x2442dc40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294958144));
    // 0x1d5524: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1d5528: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d552c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1d5534: 0x8cc22228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 8744)));
    // 0x1d5538: 0x2444ffd9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967257));
    // 0x1d553c: 0x2c83000a
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 10));
    // 0x1d5540: 0x10600032
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D560C; return;
    }
    // 0x1d5548: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1d554c: 0x2442dc60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294958176));
    // 0x1d5550: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1d5554: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d5558: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1d5560: 0x8cc4239c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 9116)));
    // 0x1d5564: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1d5568: 0x10820028
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D560C; return;
    }
    // 0x1d5570: 0x14830027
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1D5610; return;
    }
    // 0x1d5578: 0x10000025
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5610; return;
    }
    // 0x1d5580: 0x8cc32228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 8744)));
    // 0x1d5584: 0x28620010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 16));
    // 0x1d5588: 0x10400003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 9));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d5598;
    }
    // 0x1d5590: 0x1040001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5610; return;
    }
label_1d5598:
    // 0x1d5598: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1d559c: 0x10a20005
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D55B4; return;
    }
    // 0x1d55a4: 0xc0776a0
    SET_GPR_U32(ctx, 31, 0x1d55ac);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 20)));
    IsSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1d55ac
// Address: 0x1d55ac - 0x1d55fc

void entry_1d55ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d55ac) {
        switch (ctx->pc) {
            case 0x1d55b4: ctx->pc = 0; goto label_1d55b4;
            case 0x1d55c0: ctx->pc = 0; goto label_1d55c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d55ac: 0x10400018
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5610; return;
    }
label_1d55b4:
    // 0x1d55b4: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d55b8: 0x10000015
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5610; return;
    }
label_1d55c0:
    // 0x1d55c0: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d55c4: 0x1062000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D5604; return;
    }
    // 0x1d55cc: 0x10620010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D5610; return;
    }
    // 0x1d55d4: 0x8cc226c4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 9924)));
    // 0x1d55d8: 0x1440000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5610; return;
    }
    // 0x1d55e0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d55e4: 0x8c622c64
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11364)));
    // 0x1d55e8: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1d55ec: 0x14400008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5610; return;
    }
    // 0x1d55f4: 0xc0776a0
    SET_GPR_U32(ctx, 31, 0x1d55fc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 20)));
    IsSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1d55fc
// Address: 0x1d55fc - 0x1d5620

void entry_1d55fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d55fc) {
        switch (ctx->pc) {
            case 0x1d5604: ctx->pc = 0; goto label_1d5604;
            case 0x1d560c: ctx->pc = 0; goto label_1d560c;
            case 0x1d5610: ctx->pc = 0; goto label_1d5610;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d55fc: 0x10400004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d5610;
    }
label_1d5604:
    // 0x1d5604: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d5610;
    }
label_1d560c:
    // 0x1d560c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1d5610:
    // 0x1d5610: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d5614: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d5618: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d5620
// Address: 0x1d5620 - 0x1d5638

void FUN_001d5620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5620: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1d5624: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d5628: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d562c: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1d5630: 0xc04aaba
    SET_GPR_U32(ctx, 31, 0x1d5638);
    SetAloEyesClosed__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_1d5638
// Address: 0x1d5638 - 0x1d5640

void entry_1d5638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5638: 0xc058368
    SET_GPR_U32(ctx, 31, 0x1d5640);
    reload_post_death(rdram, ctx, runtime); return;
}


// Function: entry_1d5640
// Address: 0x1d5640 - 0x1d5650

void entry_1d5640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5640: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d5644: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d564c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d5650; return;
}


// Function: SgnCmpSpkn__FPCvT0
// Address: 0x1d5650 - 0x1d5678

void entry_1d56ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d56ec) {
        switch (ctx->pc) {
            case 0x1d5720: ctx->pc = 0; goto label_1d5720;
            case 0x1d5748: ctx->pc = 0; goto label_1d5748;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d56ec: 0x27a32060
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 8288));
    // 0x1d56f0: 0x27a20020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1d56f4: 0xafa33928
    WRITE32(ADD32(GPR_U32(ctx, 29), 14632), GPR_U32(ctx, 3));
    // 0x1d56f8: 0x27a438b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 14512));
    // 0x1d56fc: 0x8fa638f4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 14580)));
    // 0x1d5700: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d5704: 0xafa23924
    WRITE32(ADD32(GPR_U32(ctx, 29), 14628), GPR_U32(ctx, 2));
    // 0x1d5708: 0x18c0003c
    WRITE32(ADD32(GPR_U32(ctx, 29), 14640), GPR_U32(ctx, 4));
    if (GPR_S32(ctx, 6) <= 0) {
        ctx->pc = 0x1D57FC; return;
    }
    // 0x1d5710: 0x27a7ffe0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1d5714: 0xafa73938
    WRITE32(ADD32(GPR_U32(ctx, 29), 14648), GPR_U32(ctx, 7));
    // 0x1d5718: 0x8fa238f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 14584)));
    // 0x1d571c: 0x0
    // NOP
label_1d5720:
    // 0x1d5720: 0x24760001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1d5724: 0x400013
    ctx->lo = GPR_U32(ctx, 2);
    // 0x1d5728: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1d572c: 0x1bc0002e
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_S32(ctx, 30) <= 0) {
        ctx->pc = 0x1D57E8; return;
    }
    // 0x1d5734: 0x8fa33938
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 14648)));
    // 0x1d5738: 0x151140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 21), 5));
    // 0x1d573c: 0x8fb238f0
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 14576)));
    // 0x1d5740: 0x3c0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1d5744: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1d5748:
    // 0x1d5748: 0xc6820004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1d574c: 0x151140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 21), 5));
    // 0x1d5750: 0xc6410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1d5754: 0x3a28821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x1d5758: 0x8e830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x1d575c: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1d5760: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1d5764: 0xc6400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d5768: 0xd8630140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1d576c: 0x27a52000
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 8192));
    // 0x1d5770: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1d5774: 0x8cc21990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 6544)));
    // 0x1d5778: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1d577c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d5780: 0x48a42800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1d5784: 0x26100020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    // 0x1d5788: 0xfba52020
    WRITE128(ADD32(GPR_U32(ctx, 29), 8224), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1d578c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d5790: 0x44070000
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[0]);
    // 0x1d5794: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1d5798: 0x48a71000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 7));
    // 0x1d579c: 0xd8440090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x1d57a0: 0xfba22020
    WRITE128(ADD32(GPR_U32(ctx, 29), 8224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d57a4: 0xd84100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 160)));
    // 0x1d57a8: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1d57ac: 0x4be520bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1d57b0: 0x4be208c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d57b4: 0xc051070
    SET_GPR_U32(ctx, 31, 0x1d57bc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 8192), _mm_castps_si128(ctx->vu0_vf[3]));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_1d57bc
// Address: 0x1d57bc - 0x1d5874

void entry_1d57bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d57bc) {
        switch (ctx->pc) {
            case 0x1d57dc: ctx->pc = 0; goto label_1d57dc;
            case 0x1d57e8: ctx->pc = 0; goto label_1d57e8;
            case 0x1d57fc: ctx->pc = 0; goto label_1d57fc;
            case 0x1d5850: ctx->pc = 0; goto label_1d5850;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d57bc: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d57c0: 0xc7a02018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8216)); ctx->f[0] = *(float*)&val; }
    // 0x1d57c4: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d57c8: 0x0
    // NOP
    // 0x1d57cc: 0x45000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d57dc;
    }
    // 0x1d57d4: 0x46000d06
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
    // 0x1d57d8: 0x200b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1d57dc:
    // 0x1d57dc: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x1d57e0: 0x1660ffd9
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 8));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5748; return;
    }
label_1d57e8:
    // 0x1d57e8: 0x8fa438f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 14580)));
    // 0x1d57ec: 0x2c0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1d57f0: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x1d57f4: 0x1440ffca
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 14584)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5720; return;
    }
label_1d57fc:
    // 0x1d57fc: 0x8fa638fc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 14588)));
    // 0x1d5800: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d5804: 0x7ae20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 23), 0)));
    // 0x1d5808: 0x215202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 21)));
    // 0x1d580c: 0x24c60070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 112));
    // 0x1d5810: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d5814: 0x7fa22030
    WRITE128(ADD32(GPR_U32(ctx, 29), 8240), GPR_VEC(ctx, 2));
    // 0x1d5818: 0x26b3ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 21), 4294967295));
    // 0x1d581c: 0xafa6392c
    WRITE32(ADD32(GPR_U32(ctx, 29), 14636), GPR_U32(ctx, 6));
    // 0x1d5820: 0x7ae20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 23), 16)));
    // 0x1d5824: 0x7fa22040
    WRITE128(ADD32(GPR_U32(ctx, 29), 8256), GPR_VEC(ctx, 2));
    // 0x1d5828: 0x7ee30000
    WRITE128(ADD32(GPR_U32(ctx, 23), 0), GPR_VEC(ctx, 3));
    // 0x1d582c: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d5830: 0x7ee20010
    WRITE128(ADD32(GPR_U32(ctx, 23), 16), GPR_VEC(ctx, 2));
    // 0x1d5834: 0x7ba32030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 8240)));
    // 0x1d5838: 0x7ba22040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 8256)));
    // 0x1d583c: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x1d5840: 0x10800010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5884; return;
    }
    // 0x1d5848: 0x27a30020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1d584c: 0x0
    // NOP
label_1d5850:
    // 0x1d5850: 0x60882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1d5854: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d5858: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d585c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1d5860: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d5864: 0xfba22020
    WRITE128(ADD32(GPR_U32(ctx, 29), 8224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d5868: 0xc7ac2024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8228)); ctx->f[12] = *(float*)&val; }
    // 0x1d586c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1d5874);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8224)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1d5874
// Address: 0x1d5874 - 0x1d58a0

void entry_1d5874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5874) {
        switch (ctx->pc) {
            case 0x1d5884: ctx->pc = 0; goto label_1d5884;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5874: 0xe6200010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 16), *(uint32_t*)&val); }
    // 0x1d5878: 0x215102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 21)));
    // 0x1d587c: 0x1440fff4
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5850; return;
    }
label_1d5884:
    // 0x1d5884: 0x3c02001d
    SET_GPR_U32(ctx, 2, ((uint32_t)29 << 16));
    // 0x1d5888: 0x8fa43924
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 14628)));
    // 0x1d588c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d5890: 0x24060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1d5894: 0x24475650
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 22096));
    // 0x1d5898: 0xc07d734
    SET_GPR_U32(ctx, 31, 0x1d58a0);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    qsort(rdram, ctx, runtime); return;
}


// Function: entry_1d58a0
// Address: 0x1d58a0 - 0x1d5acc

void entry_1d58a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d58a0) {
        switch (ctx->pc) {
            case 0x1d58b8: ctx->pc = 0; goto label_1d58b8;
            case 0x1d58e0: ctx->pc = 0; goto label_1d58e0;
            case 0x1d5934: ctx->pc = 0; goto label_1d5934;
            case 0x1d5938: ctx->pc = 0; goto label_1d5938;
            case 0x1d5954: ctx->pc = 0; goto label_1d5954;
            case 0x1d5990: ctx->pc = 0; goto label_1d5990;
            case 0x1d59c0: ctx->pc = 0; goto label_1d59c0;
            case 0x1d5a10: ctx->pc = 0; goto label_1d5a10;
            case 0x1d5a84: ctx->pc = 0; goto label_1d5a84;
            case 0x1d5a90: ctx->pc = 0; goto label_1d5a90;
            case 0x1d5aa8: ctx->pc = 0; goto label_1d5aa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d58a0: 0x1aa0002c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        goto label_1d5954;
    }
    // 0x1d58a8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d58ac: 0x27a60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d58b0: 0x24478d20
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1d58b4: 0x0
    // NOP
label_1d58b8:
    // 0x1d58b8: 0x101940
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 5));
    // 0x1d58bc: 0x261e0001
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1d58c0: 0xa6102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x1d58c4: 0x1440001b
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1d5934;
    }
    // 0x1d58cc: 0xd8e50000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1d58d0: 0xda240000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d58d4: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1d58d8: 0xd8a3ffc0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 4294967232)));
    // 0x1d58dc: 0x0
    // NOP
label_1d58e0:
    // 0x1d58e0: 0x24a2ffe0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4294967264));
    // 0x1d58e4: 0xd8a1ffe0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 4294967264)));
    // 0x1d58e8: 0x4be320ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1d58ec: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d58f0: 0x4bc50afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[5] = READ32(addr); }
    // 0x1d58f4: 0x4bc1286e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d58f8: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d58fc: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d5900: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d5904: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d5908: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d590c: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d5910: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d5914: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d5918: 0x0
    // NOP
    // 0x1d591c: 0x45030006
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
        goto label_1d5938;
    }
    // 0x1d5924: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d5928: 0xa6102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x1d592c: 0x5040ffec
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 4294967232)));
        goto label_1d58e0;
    }
label_1d5934:
    // 0x1d5934: 0x7a220000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 0)));
label_1d5938:
    // 0x1d5938: 0x3c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1d593c: 0x215202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 21)));
    // 0x1d5940: 0x7ca20000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 2));
    // 0x1d5944: 0x7a230010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1d5948: 0x7ca30010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 3));
    // 0x1d594c: 0x1480ffda
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 32));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1d58b8;
    }
label_1d5954:
    // 0x1d5954: 0xbd1023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 29)));
    // 0x1d5958: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d595c: 0x2a943
    SET_GPR_S32(ctx, 21, SRA32(GPR_S32(ctx, 2), 5));
    // 0x1d5960: 0x152140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 21), 5));
    // 0x1d5964: 0x26b0ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 4294967295));
    // 0x1d5968: 0x9d2021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 29)));
    // 0x1d596c: 0x7c830000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 3));
    // 0x1d5970: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d5974: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x1d5978: 0x7ba32010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 8208)));
    // 0x1d597c: 0x7fa32020
    WRITE128(ADD32(GPR_U32(ctx, 29), 8224), GPR_VEC(ctx, 3));
    // 0x1d5980: 0x600000f
    WRITE128(ADD32(GPR_U32(ctx, 29), 8240), GPR_VEC(ctx, 3));
    if (GPR_S32(ctx, 16) < 0) {
        goto label_1d59c0;
    }
    // 0x1d5988: 0x101140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 5));
    // 0x1d598c: 0x5d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
label_1d5990:
    // 0x1d5990: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d5994: 0xdba12020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 8224)));
    // 0x1d5998: 0xda230000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d599c: 0x2622ffe0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294967264));
    // 0x1d59a0: 0x4bc3086f
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d59a4: 0xdba22030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 8240)));
    // 0x1d59a8: 0xfba12020
    WRITE128(ADD32(GPR_U32(ctx, 29), 8224), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d59ac: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1d59b0: 0xda210000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d59b4: 0x4bc110ab
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d59b8: 0x601fff5
    WRITE128(ADD32(GPR_U32(ctx, 29), 8240), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_S32(ctx, 16) >= 0) {
        goto label_1d5990;
    }
label_1d59c0:
    // 0x1d59c0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1d59c4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d59c8: 0x26b0ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 4294967295));
    // 0x1d59cc: 0xdba22020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 8224)));
    // 0x1d59d0: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1d59d4: 0x48a40800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1d59d8: 0xdba32030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 8240)));
    // 0x1d59dc: 0x4be111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d59e0: 0x4be11888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d59e4: 0xfba12040
    WRITE128(ADD32(GPR_U32(ctx, 29), 8256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d59e8: 0x6000029
    WRITE128(ADD32(GPR_U32(ctx, 29), 8208), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_S32(ctx, 16) < 0) {
        goto label_1d5a90;
    }
    // 0x1d59f0: 0x102140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 16), 5));
    // 0x1d59f4: 0x27a3ffe0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1d59f8: 0x151140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 21), 5));
    // 0x1d59fc: 0x44803000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 0);
    // 0x1d5a00: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d5a04: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x1d5a08: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1d5a0c: 0x9d2021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 29)));
label_1d5a10:
    // 0x1d5a10: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d5a14: 0xc7a32010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8208)); ctx->f[3] = *(float*)&val; }
    // 0x1d5a18: 0xc6220000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1d5a1c: 0xc6240020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 32)); ctx->f[4] = *(float*)&val; }
    // 0x1d5a20: 0x46031001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[3]);
    // 0x1d5a24: 0x46032041
    ctx->f[1] = FPU_SUB_S(ctx->f[4], ctx->f[3]);
    // 0x1d5a28: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d5a2c: 0x46060034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[6])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d5a30: 0x0
    // NOP
    // 0x1d5a34: 0x45020013
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
        goto label_1d5a84;
    }
    // 0x1d5a3c: 0x46022041
    ctx->f[1] = FPU_SUB_S(ctx->f[4], ctx->f[2]);
    // 0x1d5a40: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1d5a44: 0x46021801
    ctx->f[0] = FPU_SUB_S(ctx->f[3], ctx->f[2]);
    // 0x1d5a48: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1d5a4c: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1d5a50: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1d5a54: 0x46002801
    ctx->f[0] = FPU_SUB_S(ctx->f[5], ctx->f[0]);
    // 0x1d5a58: 0x48a62000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 6));
    // 0x1d5a5c: 0x44070000
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[0]);
    // 0x1d5a60: 0x48a71000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 7));
    // 0x1d5a64: 0xfba22040
    WRITE128(ADD32(GPR_U32(ctx, 29), 8256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d5a68: 0xda230000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d5a6c: 0xfba42040
    WRITE128(ADD32(GPR_U32(ctx, 29), 8256), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d5a70: 0xda210020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1d5a74: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d5a78: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d5a7c: 0xf8620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d5a80: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
label_1d5a84:
    // 0x1d5a84: 0x601ffe2
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4294967264));
    if (GPR_S32(ctx, 16) >= 0) {
        goto label_1d5a10;
    }
    // 0x1d5a8c: 0x26b0ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 4294967295));
label_1d5a90:
    // 0x1d5a90: 0x159140
    SET_GPR_U32(ctx, 18, SLL32(GPR_U32(ctx, 21), 5));
    // 0x1d5a94: 0x6000012
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) < 0) {
        ctx->pc = 0x1D5AE0; return;
    }
    // 0x1d5a9c: 0x101140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 5));
    // 0x1d5aa0: 0x5d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x1d5aa4: 0x0
    // NOP
label_1d5aa8:
    // 0x1d5aa8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d5aac: 0xdba22010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 8208)));
    // 0x1d5ab0: 0xda210000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d5ab4: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1d5ab8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d5abc: 0xfba12040
    WRITE128(ADD32(GPR_U32(ctx, 29), 8256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d5ac0: 0xc7ac2044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8260)); ctx->f[12] = *(float*)&val; }
    // 0x1d5ac4: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1d5acc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8256)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1d5acc
// Address: 0x1d5acc - 0x1d5ad4

void entry_1d5acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5acc: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1d5ad4);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1d5ad4
// Address: 0x1d5ad4 - 0x1d5afc

void entry_1d5ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5ad4) {
        switch (ctx->pc) {
            case 0x1d5ae0: ctx->pc = 0; goto label_1d5ae0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5ad4: 0xe6200010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 16), *(uint32_t*)&val); }
    // 0x1d5ad8: 0x601fff3
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294967264));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x1D5AA8; return;
    }
label_1d5ae0:
    // 0x1d5ae0: 0x3c02001d
    SET_GPR_U32(ctx, 2, ((uint32_t)29 << 16));
    // 0x1d5ae4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d5ae8: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1d5aec: 0x24475650
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 22096));
    // 0x1d5af0: 0x24060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1d5af4: 0xc07d734
    SET_GPR_U32(ctx, 31, 0x1d5afc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    qsort(rdram, ctx, runtime); return;
}


// Function: entry_1d5afc
// Address: 0x1d5afc - 0x1d5b54

void entry_1d5afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5afc) {
        switch (ctx->pc) {
            case 0x1d5b28: ctx->pc = 0; goto label_1d5b28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5afc: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d5b00: 0x25d2021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 29)));
    // 0x1d5b04: 0x2512821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 17)));
    // 0x1d5b08: 0x7c830000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 3));
    // 0x1d5b0c: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d5b10: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x1d5b14: 0xc4b50010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 16)); ctx->f[21] = *(float*)&val; }
    // 0x1d5b18: 0x600003e
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    if (GPR_S32(ctx, 16) < 0) {
        ctx->pc = 0x1D5C14; return;
    }
    // 0x1d5b20: 0x240982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d5b24: 0x3c170027
    SET_GPR_U32(ctx, 23, ((uint32_t)39 << 16));
label_1d5b28:
    // 0x1d5b28: 0x7fb43900
    WRITE128(ADD32(GPR_U32(ctx, 29), 14592), GPR_VEC(ctx, 20));
    // 0x1d5b2c: 0x101140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 5));
    // 0x1d5b30: 0x5d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x1d5b34: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1d5b38: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d5b3c: 0x2616ffff
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1d5b40: 0x7fa33910
    WRITE128(ADD32(GPR_U32(ctx, 29), 14608), GPR_VEC(ctx, 3));
    // 0x1d5b44: 0x7003a4a9
    SET_GPR_VEC(ctx, 20, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 3)));
    // 0x1d5b48: 0xc4550010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[21] = *(float*)&val; }
    // 0x1d5b4c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1d5b54);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[21]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1d5b54
// Address: 0x1d5b54 - 0x1d5bfc

void entry_1d5b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5b54) {
        switch (ctx->pc) {
            case 0x1d5b98: ctx->pc = 0; goto label_1d5b98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5b54: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1d5b58: 0xc6e1506c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 20588)); ctx->f[1] = *(float*)&val; }
    // 0x1d5b5c: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1d5b60: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1d5b64: 0x44120800
    SET_GPR_U32(ctx, 18, *(uint32_t*)&ctx->f[1]);
    // 0x1d5b68: 0x0
    // NOP
    // 0x1d5b6c: 0x1a400027
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 18) <= 0) {
        ctx->pc = 0x1D5C0C; return;
    }
    // 0x1d5b74: 0x1a400024
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 18) <= 0) {
        ctx->pc = 0x1D5C08; return;
    }
    // 0x1d5b7c: 0x26420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1d5b80: 0x151940
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 21), 5));
    // 0x1d5b84: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x1d5b88: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x1d5b8c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d5b90: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1d5b94: 0x7d8821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 29)));
label_1d5b98:
    // 0x1d5b98: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1d5b9c: 0xdba33910
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 14608)));
    // 0x1d5ba0: 0x44900000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 16);
    // 0x1d5ba4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1d5ba8: 0xdba43900
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 14592)));
    // 0x1d5bac: 0x26310020
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 32));
    // 0x1d5bb0: 0x26730020
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 32));
    // 0x1d5bb4: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1d5bb8: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x1d5bbc: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d5bc0: 0x4600b001
    ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[0]);
    // 0x1d5bc4: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d5bc8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1d5bcc: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1d5bd0: 0xfba12050
    WRITE128(ADD32(GPR_U32(ctx, 29), 8272), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d5bd4: 0x4be119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d5bd8: 0x4be22048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d5bdc: 0xfba22050
    WRITE128(ADD32(GPR_U32(ctx, 29), 8272), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d5be0: 0xfa21ffe0
    WRITE128(ADD32(GPR_U32(ctx, 17), 4294967264), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d5be4: 0xdba22010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 8208)));
    // 0x1d5be8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d5bec: 0xfba12040
    WRITE128(ADD32(GPR_U32(ctx, 29), 8256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d5bf0: 0xc7ac2044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8260)); ctx->f[12] = *(float*)&val; }
    // 0x1d5bf4: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1d5bfc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8256)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1d5bfc
// Address: 0x1d5bfc - 0x1d5c30

void entry_1d5bfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5bfc) {
        switch (ctx->pc) {
            case 0x1d5c08: ctx->pc = 0; goto label_1d5c08;
            case 0x1d5c0c: ctx->pc = 0; goto label_1d5c0c;
            case 0x1d5c14: ctx->pc = 0; goto label_1d5c14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5bfc: 0x212102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 18)));
    // 0x1d5c00: 0x1440ffe5
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 4294967280), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5B98; return;
    }
label_1d5c08:
    // 0x1d5c08: 0x2c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_1d5c0c:
    // 0x1d5c0c: 0x601ffc6
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x1D5B28; return;
    }
label_1d5c14:
    // 0x1d5c14: 0x3c02001d
    SET_GPR_U32(ctx, 2, ((uint32_t)29 << 16));
    // 0x1d5c18: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d5c1c: 0x24475650
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 22096));
    // 0x1d5c20: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1d5c24: 0x24060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1d5c28: 0xc07d734
    SET_GPR_U32(ctx, 31, 0x1d5c30);
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 2));
    qsort(rdram, ctx, runtime); return;
}


// Function: entry_1d5c30
// Address: 0x1d5c30 - 0x1d5c4c

void entry_1d5c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5c30: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d5c34: 0x25d2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 29)));
    // 0x1d5c38: 0x8fa43928
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 14632)));
    // 0x1d5c3c: 0x7ca30000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 3));
    // 0x1d5c40: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d5c44: 0xc058670
    SET_GPR_U32(ctx, 31, 0x1d5c4c);
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 2));
    fn___4GLBS(rdram, ctx, runtime); return;
}


// Function: entry_1d5c4c
// Address: 0x1d5c4c - 0x1d5c58

void entry_1d5c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5c4c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d5c50: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x1d5c58);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 8872));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1d5c58
// Address: 0x1d5c58 - 0x1d5c70

void entry_1d5c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5c58: 0x8fa43928
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 14632)));
    // 0x1d5c5c: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1d5c60: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1d5c64: 0x24a58d30
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937904));
    // 0x1d5c68: 0xc0586ac
    SET_GPR_U32(ctx, 31, 0x1d5c70);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294935504));
    SetTransform__4GLBSP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1d5c70
// Address: 0x1d5c70 - 0x1d5cfc

void entry_1d5c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5c70) {
        switch (ctx->pc) {
            case 0x1d5c80: ctx->pc = 0; goto label_1d5c80;
            case 0x1d5cd0: ctx->pc = 0; goto label_1d5cd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5c70: 0x8fa638fc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 14588)));
    // 0x1d5c74: 0x27a538b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 14512));
    // 0x1d5c78: 0x8fa33930
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 14640)));
    // 0x1d5c7c: 0x24c40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 16));
label_1d5c80:
    // 0x1d5c80: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d5c84: 0x2694ffff
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
    // 0x1d5c88: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1d5c8c: 0x7ca20000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 2));
    // 0x1d5c90: 0x24a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 16));
    // 0x1d5c94: 0xc7a02018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8216)); ctx->f[0] = *(float*)&val; }
    // 0x1d5c98: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1d5c9c: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1d5ca0: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1d5ca4: 0xe4610000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1d5ca8: 0xc7a02018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8216)); ctx->f[0] = *(float*)&val; }
    // 0x1d5cac: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1d5cb0: 0xe4620008
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 3), 8), *(uint32_t*)&val); }
    // 0x1d5cb4: 0x681fff2
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    if (GPR_S32(ctx, 20) >= 0) {
        goto label_1d5c80;
    }
    // 0x1d5cbc: 0x2aa70000
    SET_GPR_U32(ctx, 7, SLT32(GPR_S32(ctx, 21), 0));
    // 0x1d5cc0: 0xb02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d5cc4: 0xafa73920
    WRITE32(ADD32(GPR_U32(ctx, 29), 14624), GPR_U32(ctx, 7));
    // 0x1d5cc8: 0x8fa3392c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 14636)));
    // 0x1d5ccc: 0x0
    // NOP
label_1d5cd0:
    // 0x1d5cd0: 0x161080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
    // 0x1d5cd4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1d5cd8: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d5cdc: 0x10a00098
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1d5f40(rdram, ctx, runtime); return;
    }
    // 0x1d5ce4: 0x8fa43928
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 14632)));
    // 0x1d5ce8: 0x3c01c049
    SET_GPR_U32(ctx, 1, ((uint32_t)49225 << 16));
    // 0x1d5cec: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1d5cf0: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1d5cf4: 0xc0586ec
    SET_GPR_U32(ctx, 31, 0x1d5cfc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    BeginStrip__4GLBSP3SHD(rdram, ctx, runtime); return;
}


// Function: entry_1d5cfc
// Address: 0x1d5cfc - 0x1d5d20

void entry_1d5cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5cfc: 0x8fa638fc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 14588)));
    // 0x1d5d00: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1d5d04: 0x24841858
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6232));
    // 0x1d5d08: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d5d0c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d5d10: 0xc4800004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d5d14: 0xc4cc0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1d5d18: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1d5d20);
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d5d20
// Address: 0x1d5d20 - 0x1d5de8

void entry_1d5d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5d20) {
        switch (ctx->pc) {
            case 0x1d5d48: ctx->pc = 0; goto label_1d5d48;
            case 0x1d5d88: ctx->pc = 0; goto label_1d5d88;
            case 0x1d5da0: ctx->pc = 0; goto label_1d5da0;
            case 0x1d5db8: ctx->pc = 0; goto label_1d5db8;
            case 0x1d5dd4: ctx->pc = 0; goto label_1d5dd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5d20: 0x8fa73920
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 14624)));
    // 0x1d5d24: 0x14e00084
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 7) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5F38; return;
    }
    // 0x1d5d2c: 0x27a238b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 14512));
    // 0x1d5d30: 0x3c013e22
    SET_GPR_U32(ctx, 1, ((uint32_t)15906 << 16));
    // 0x1d5d34: 0x3421f983
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 63875));
    // 0x1d5d38: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1d5d3c: 0xafa23934
    WRITE32(ADD32(GPR_U32(ctx, 29), 14644), GPR_U32(ctx, 2));
    // 0x1d5d40: 0x101140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 5));
    // 0x1d5d44: 0x0
    // NOP
label_1d5d48:
    // 0x1d5d48: 0xdba22010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 8208)));
    // 0x1d5d4c: 0x3a28821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x1d5d50: 0x261e0001
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1d5d54: 0xda210000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1d5d58: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d5d5c: 0xfba12040
    WRITE128(ADD32(GPR_U32(ctx, 29), 8256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d5d60: 0xc6210010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1d5d64: 0x46150834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d5d68: 0x0
    // NOP
    // 0x1d5d6c: 0x4500000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 14588)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d5da0;
    }
    // 0x1d5d74: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1d5d78: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1d5d7c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d5d80: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1d5d84: 0x0
    // NOP
label_1d5d88:
    // 0x1d5d88: 0x46150834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d5d8c: 0x0
    // NOP
    // 0x1d5d90: 0x0
    // NOP
    // 0x1d5d94: 0x4503fffc
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
        goto label_1d5d88;
    }
    // 0x1d5d9c: 0x8fa438fc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 14588)));
label_1d5da0:
    // 0x1d5da0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d5da4: 0x10600004
    ctx->f[21] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1d5db8;
    }
    // 0x1d5dac: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d5db0: 0x10620008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d5dd4;
    }
label_1d5db8:
    // 0x1d5db8: 0x8fa638fc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 14588)));
    // 0x1d5dbc: 0xc4c00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d5dc0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d5dc4: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1d5dc8: 0x4600a000
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1d5dcc: 0x1000000d
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8272), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5E04; return;
    }
label_1d5dd4:
    // 0x1d5dd4: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x1d5dd8: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1d5ddc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d5de0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1d5de8);
    ctx->f[12] = FPU_SUB_S(ctx->f[1], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1d5de8
// Address: 0x1d5de8 - 0x1d5ed8

void entry_1d5de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5de8) {
        switch (ctx->pc) {
            case 0x1d5e04: ctx->pc = 0; goto label_1d5e04;
            case 0x1d5e38: ctx->pc = 0; goto label_1d5e38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5de8: 0x8fa738fc
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 14588)));
    // 0x1d5dec: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1d5df0: 0xc4e10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d5df4: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1d5df8: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
    // 0x1d5dfc: 0x4601a040
    ctx->f[1] = FPU_ADD_S(ctx->f[20], ctx->f[1]);
    // 0x1d5e00: 0xe7a12050
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 8272), *(uint32_t*)&val); }
label_1d5e04:
    // 0x1d5e04: 0x2f6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 23), GPR_S32(ctx, 22)));
    // 0x1d5e08: 0x14400047
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5F28; return;
    }
    // 0x1d5e10: 0x8fa23934
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 14644)));
    // 0x1d5e14: 0x162100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 22), 4));
    // 0x1d5e18: 0x161940
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 22), 5));
    // 0x1d5e1c: 0x8fb23928
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 14632)));
    // 0x1d5e20: 0x448821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1d5e24: 0x27b32000
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 8192));
    // 0x1d5e28: 0x8fa438fc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 14588)));
    // 0x1d5e2c: 0x648021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1d5e30: 0xc6000020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[0] = *(float*)&val; }
    // 0x1d5e34: 0x0
    // NOP
label_1d5e38:
    // 0x1d5e38: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1d5e3c: 0xdba32040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 8256)));
    // 0x1d5e40: 0x24638d20
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937888));
    // 0x1d5e44: 0xe7a02054
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8276), *(uint32_t*)&val); }
    // 0x1d5e48: 0x4bc318aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d5e4c: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d5e50: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d5e54: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d5e58: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d5e5c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d5e60: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d5e64: 0xdba42010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 8208)));
    // 0x1d5e68: 0xc6220008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1d5e6c: 0x48271000
    SET_GPR_VEC(ctx, 7, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d5e70: 0x44871800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 7);
    // 0x1d5e74: 0xc6210004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d5e78: 0x46021882
    ctx->f[2] = FPU_MUL_S(ctx->f[3], ctx->f[2]);
    // 0x1d5e7c: 0xc6200000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1d5e80: 0x8e020024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x1d5e84: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x1d5e88: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d5e8c: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d5e90: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1d5e94: 0x8ce41990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 6544)));
    // 0x1d5e98: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d5e9c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d5ea0: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x1d5ea4: 0x26310010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    // 0x1d5ea8: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1d5eac: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d5eb0: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x1d5eb4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d5eb8: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d5ebc: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1d5ec0: 0x4be118bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d5ec4: 0x4be51108
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d5ec8: 0xfba138e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 14560), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d5ecc: 0xfba42000
    WRITE128(ADD32(GPR_U32(ctx, 29), 8192), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d5ed0: 0xc05104a
    SET_GPR_U32(ctx, 31, 0x1d5ed8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 14560), _mm_castps_si128(ctx->vu0_vf[5]));
    ConvertCmScreenToWorld(rdram, ctx, runtime); return;
}


// Function: entry_1d5ed8
// Address: 0x1d5ed8 - 0x1d5ee4

void entry_1d5ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5ed8: 0x27a52050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 8272));
    // 0x1d5edc: 0xc0589b0
    SET_GPR_U32(ctx, 31, 0x1d5ee4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetUv__4GLBSP3UVF(rdram, ctx, runtime); return;
}


// Function: entry_1d5ee4
// Address: 0x1d5ee4 - 0x1d5f04

void entry_1d5ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5ee4: 0x8a03002b
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 43); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1d5ee8: 0x9a030028
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 40); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x1d5eec: 0xaba338e3
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 14563); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1d5ef0: 0xbba338e0
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 14560); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1d5ef4: 0x27a538e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 14560));
    // 0x1d5ef8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d5efc: 0xc0589aa
    SET_GPR_U32(ctx, 31, 0x1d5f04);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    SetRgba__4GLBSG4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1d5f04
// Address: 0x1d5f04 - 0x1d5f10

void entry_1d5f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5f04: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d5f08: 0xc0589a0
    SET_GPR_U32(ctx, 31, 0x1d5f10);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetNormal__4GLBSP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d5f10
// Address: 0x1d5f10 - 0x1d5f1c

void entry_1d5f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5f10: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d5f14: 0xc0589b6
    SET_GPR_U32(ctx, 31, 0x1d5f1c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVtx__4GLBSi(rdram, ctx, runtime); return;
}


// Function: entry_1d5f1c
// Address: 0x1d5f1c - 0x1d5f40

void entry_1d5f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5f1c) {
        switch (ctx->pc) {
            case 0x1d5f28: ctx->pc = 0; goto label_1d5f28;
            case 0x1d5f38: ctx->pc = 0; goto label_1d5f38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5f1c: 0x2f4102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 23), GPR_S32(ctx, 20)));
    // 0x1d5f20: 0x5040ffc5
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1D5E38; return;
    }
label_1d5f28:
    // 0x1d5f28: 0x3c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1d5f2c: 0x2b0102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 16)));
    // 0x1d5f30: 0x1040ff85
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5D48; return;
    }
label_1d5f38:
    // 0x1d5f38: 0xc058942
    SET_GPR_U32(ctx, 31, 0x1d5f40);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 14632)));
    EndStrip__4GLBS(rdram, ctx, runtime); return;
}


// Function: entry_1d5f40
// Address: 0x1d5f40 - 0x1d5f5c

void entry_1d5f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5f40: 0x2e0b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1d5f44: 0x2ac20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), 2));
    // 0x1d5f48: 0x1440ff61
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 14636)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D5CD0; return;
    }
    // 0x1d5f50: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d5f54: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1d5f5c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 8872));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1d5f5c
// Address: 0x1d5f5c - 0x1d5f68

void entry_1d5f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5f5c: 0x8fa43928
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 14632)));
    // 0x1d5f60: 0xc0586a2
    SET_GPR_U32(ctx, 31, 0x1d5f68);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FUN_00161a88(rdram, ctx, runtime); return;
}


// Function: entry_1d5f68
// Address: 0x1d5f68 - 0x1d5fa8

void entry_1d5f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d5f68: 0x7bbf39d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 14800)));
    // 0x1d5f6c: 0x7bbe39c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 14784)));
    // 0x1d5f70: 0x7bb739b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 14768)));
    // 0x1d5f74: 0x7bb639a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 14752)));
    // 0x1d5f78: 0x7bb53990
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 14736)));
    // 0x1d5f7c: 0x7bb43980
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 14720)));
    // 0x1d5f80: 0x7bb33970
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 14704)));
    // 0x1d5f84: 0x7bb23960
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 14688)));
    // 0x1d5f88: 0x7bb13950
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 14672)));
    // 0x1d5f8c: 0x7bb03940
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 14656)));
    // 0x1d5f90: 0xc7b639f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 14832)); ctx->f[22] = *(float*)&val; }
    // 0x1d5f94: 0xc7b539e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 14824)); ctx->f[21] = *(float*)&val; }
    // 0x1d5f98: 0xc7b439e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 14816)); ctx->f[20] = *(float*)&val; }
    // 0x1d5f9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 14848));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d5fa4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d5fa8; return;
}


// Function: DrawJtHaloElectric__FP3RPL
// Address: 0x1d5fa8 - 0x1d5ff0

void entry_1d5ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d5ff0) {
        switch (ctx->pc) {
            case 0x1d6054: ctx->pc = 0; goto label_1d6054;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d5ff0: 0x3c01c2c8
    SET_GPR_U32(ctx, 1, ((uint32_t)49864 << 16));
    // 0x1d5ff4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d5ff8: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1d5ffc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d6000: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d6004: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1d6008: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1d600c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1d6010: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d6014: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1d6018: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1d601c: 0xe6000044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x1d6020: 0xe6030004
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x1d6024: 0xe6020040
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 64), *(uint32_t*)&val); }
    // 0x1d6028: 0xe6010008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1d602c: 0xae000028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 0));
    // 0x1d6030: 0xe6010034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1d6034: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x1d6038: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x1d603c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d6040: 0xae020068
    WRITE32(ADD32(GPR_U32(ctx, 16), 104), GPR_U32(ctx, 2));
    // 0x1d6044: 0xae835130
    WRITE32(ADD32(GPR_U32(ctx, 20), 20784), GPR_U32(ctx, 3));
    // 0x1d6048: 0xe6000050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 80), *(uint32_t*)&val); }
    // 0x1d604c: 0xe6010060
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 96), *(uint32_t*)&val); }
    // 0x1d6050: 0xe6010054
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 84), *(uint32_t*)&val); }
label_1d6054:
    // 0x1d6054: 0x26505550
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 21840));
    // 0x1d6058: 0x2404015c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 348));
    // 0x1d605c: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x1d6064);
    WRITE32(ADD32(GPR_U32(ctx, 16), 112), GPR_U32(ctx, 0));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d6064
// Address: 0x1d6064 - 0x1d608c

void entry_1d6064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6064: 0xae020074
    WRITE32(ADD32(GPR_U32(ctx, 16), 116), GPR_U32(ctx, 2));
    // 0x1d6068: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1d606c: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d6070: 0x260502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d6074: 0x8e2826ac
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 9900)));
    // 0x1d6078: 0x26240140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1d607c: 0x8e2726a8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9896)));
    // 0x1d6080: 0x24c65070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 20592));
    // 0x1d6084: 0xc07559e
    SET_GPR_U32(ctx, 31, 0x1d608c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    DrawHaloSpks__FP6VECTORiP4SPKSP4SPKDP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1d608c
// Address: 0x1d608c - 0x1d60b0

void entry_1d608c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d608c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d6090: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d6094: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d6098: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d609c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d60a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d60a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d60ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d60b0; return;
}


// Function: DrawJtHaloFire__FP3RPL
// Address: 0x1d60b0 - 0x1d60f8

void entry_1d60f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d60f8) {
        switch (ctx->pc) {
            case 0x1d6174: ctx->pc = 0; goto label_1d6174;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d60f8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1d60fc: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1d6100: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d6104: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1d6108: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1d610c: 0x3c0280ff
    SET_GPR_U32(ctx, 2, ((uint32_t)33023 << 16));
    // 0x1d6110: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1d6114: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d6118: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1d611c: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1d6120: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d6124: 0xe6020004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x1d6128: 0xe6000024
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    // 0x1d612c: 0xe6010044
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x1d6130: 0xe6030034
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1d6134: 0xae4355d0
    WRITE32(ADD32(GPR_U32(ctx, 18), 21968), GPR_U32(ctx, 3));
    // 0x1d6138: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d613c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1d6140: 0xe6030008
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1d6144: 0xae020028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 2));
    // 0x1d6148: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x1d614c: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x1d6150: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d6154: 0x3c01c2c8
    SET_GPR_U32(ctx, 1, ((uint32_t)49864 << 16));
    // 0x1d6158: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d615c: 0xae020068
    WRITE32(ADD32(GPR_U32(ctx, 16), 104), GPR_U32(ctx, 2));
    // 0x1d6160: 0xae835134
    WRITE32(ADD32(GPR_U32(ctx, 20), 20788), GPR_U32(ctx, 3));
    // 0x1d6164: 0xe6000050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 80), *(uint32_t*)&val); }
    // 0x1d6168: 0xe6020060
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 96), *(uint32_t*)&val); }
    // 0x1d616c: 0xe6010064
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 100), *(uint32_t*)&val); }
    // 0x1d6170: 0xe6020054
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 84), *(uint32_t*)&val); }
label_1d6174:
    // 0x1d6174: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x1d617c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 349));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d617c
// Address: 0x1d617c - 0x1d61a8

void entry_1d617c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d617c: 0x264955d0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 18), 21968));
    // 0x1d6180: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1d6184: 0xad220070
    WRITE32(ADD32(GPR_U32(ctx, 9), 112), GPR_U32(ctx, 2));
    // 0x1d6188: 0x260502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d618c: 0xad220074
    WRITE32(ADD32(GPR_U32(ctx, 9), 116), GPR_U32(ctx, 2));
    // 0x1d6190: 0x26240140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1d6194: 0x24c65070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 20592));
    // 0x1d6198: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1d619c: 0x8e2826ac
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 9900)));
    // 0x1d61a0: 0xc07559e
    SET_GPR_U32(ctx, 31, 0x1d61a8);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9896)));
    DrawHaloSpks__FP6VECTORiP4SPKSP4SPKDP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1d61a8
// Address: 0x1d61a8 - 0x1d61c8

void entry_1d61a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d61a8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d61ac: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d61b0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d61b4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d61b8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d61bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d61c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d61c8
// Address: 0x1d61c8 - 0x1d6210

void FUN_001d61c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d61c8: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x1d61cc: 0x7fb40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 20));
    // 0x1d61d0: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x1d61d4: 0x3c140027
    SET_GPR_U32(ctx, 20, ((uint32_t)39 << 16));
    // 0x1d61d8: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x1d61dc: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d61e0: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x1d61e4: 0x3c110060
    SET_GPR_U32(ctx, 17, ((uint32_t)96 << 16));
    // 0x1d61e8: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1d61ec: 0x7fb30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 19));
    // 0x1d61f0: 0x8e825138
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20792)));
    // 0x1d61f4: 0x1440001f
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 18), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D6274; return;
    }
    // 0x1d61fc: 0x26305650
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 22096));
    // 0x1d6200: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d6204: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d6208: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1d6210);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1d6210
// Address: 0x1d6210 - 0x1d6284

void entry_1d6210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6210) {
        switch (ctx->pc) {
            case 0x1d6274: ctx->pc = 0; goto label_1d6274;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6210: 0x3c01c2c8
    SET_GPR_U32(ctx, 1, ((uint32_t)49864 << 16));
    // 0x1d6214: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d6218: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x1d621c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d6220: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d6224: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1d6228: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1d622c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1d6230: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d6234: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1d6238: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1d623c: 0xe6000044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x1d6240: 0xe6030004
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x1d6244: 0xe6020040
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 64), *(uint32_t*)&val); }
    // 0x1d6248: 0xe6010008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1d624c: 0xae000028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 0));
    // 0x1d6250: 0xe6010034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1d6254: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x1d6258: 0x3c0141c8
    SET_GPR_U32(ctx, 1, ((uint32_t)16840 << 16));
    // 0x1d625c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d6260: 0xae020068
    WRITE32(ADD32(GPR_U32(ctx, 16), 104), GPR_U32(ctx, 2));
    // 0x1d6264: 0xae835138
    WRITE32(ADD32(GPR_U32(ctx, 20), 20792), GPR_U32(ctx, 3));
    // 0x1d6268: 0xe6000050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 80), *(uint32_t*)&val); }
    // 0x1d626c: 0xe6010060
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 96), *(uint32_t*)&val); }
    // 0x1d6270: 0xe6010054
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 84), *(uint32_t*)&val); }
label_1d6274:
    // 0x1d6274: 0x26305650
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 22096));
    // 0x1d6278: 0x2404015c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 348));
    // 0x1d627c: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x1d6284);
    WRITE32(ADD32(GPR_U32(ctx, 16), 112), GPR_U32(ctx, 0));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d6284
// Address: 0x1d6284 - 0x1d62bc

void entry_1d6284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6284: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x1d6288: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d628c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1d6290: 0xae020074
    WRITE32(ADD32(GPR_U32(ctx, 16), 116), GPR_U32(ctx, 2));
    // 0x1d6294: 0x26640140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 320));
    // 0x1d6298: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d629c: 0x240502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d62a0: 0xafb30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 19));
    // 0x1d62a4: 0x24c650a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 20648));
    // 0x1d62a8: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x1d62ac: 0x24050011
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 17));
    // 0x1d62b0: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d62b4: 0xc07559e
    SET_GPR_U32(ctx, 31, 0x1d62bc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    DrawHaloSpks__FP6VECTORiP4SPKSP4SPKDP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1d62bc
// Address: 0x1d62bc - 0x1d62e0

void entry_1d62bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d62bc: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d62c0: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d62c4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d62c8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d62cc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d62d0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d62d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d62dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d62e0; return;
}


// Function: RenderJtSelfZap__FP2JTP2CMP2RO
// Address: 0x1d62e0 - 0x1d6328

void entry_1d6328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6328) {
        switch (ctx->pc) {
            case 0x1d6338: ctx->pc = 0; goto label_1d6338;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6328: 0x30420400
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1024));
    // 0x1d632c: 0x10400029
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d63d4(rdram, ctx, runtime); return;
    }
    // 0x1d6334: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1d6338:
    // 0x1d6338: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d633c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1d6344);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1d6344
// Address: 0x1d6344 - 0x1d63d4

void entry_1d6344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6344) {
        switch (ctx->pc) {
            case 0x1d63a4: ctx->pc = 0; goto label_1d63a4;
            case 0x1d63b8: ctx->pc = 0; goto label_1d63b8;
            case 0x1d63c0: ctx->pc = 0; goto label_1d63c0;
            case 0x1d63c8: ctx->pc = 0; goto label_1d63c8;
            case 0x1d63cc: ctx->pc = 0; goto label_1d63cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6344: 0xda230040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x1d6348: 0x2402000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    // 0x1d634c: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1d6350: 0x24030026
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 38));
    // 0x1d6354: 0xda210080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 128)));
    // 0x1d6358: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d635c: 0x8e042228
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8744)));
    // 0x1d6360: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d6364: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d6368: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d636c: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d6370: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1d6374: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d6378: 0xafb00060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 16));
    // 0x1d637c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d6380: 0x1083000f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_1d63c0;
    }
    // 0x1d6388: 0x28820027
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 39));
    // 0x1d638c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 37));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d63a4;
    }
    // 0x1d6394: 0x10820008
    SET_GPR_U32(ctx, 2, ((uint32_t)29 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_1d63b8;
    }
    // 0x1d639c: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d63cc;
    }
label_1d63a4:
    // 0x1d63a4: 0x24020037
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 55));
    // 0x1d63a8: 0x14820008
    SET_GPR_U32(ctx, 2, ((uint32_t)29 << 16));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_1d63cc;
    }
    // 0x1d63b0: 0x10000005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 25032));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d63c8;
    }
label_1d63b8:
    // 0x1d63b8: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 24488));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d63c8;
    }
label_1d63c0:
    // 0x1d63c0: 0x3c02001d
    SET_GPR_U32(ctx, 2, ((uint32_t)29 << 16));
    // 0x1d63c4: 0x244260b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 24752));
label_1d63c8:
    // 0x1d63c8: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
label_1d63cc:
    // 0x1d63cc: 0xc067504
    SET_GPR_U32(ctx, 31, 0x1d63d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1d63d4
// Address: 0x1d63d4 - 0x1d6438

void entry_1d63d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d63d4) {
        switch (ctx->pc) {
            case 0x1d6414: ctx->pc = 0; goto label_1d6414;
            case 0x1d641c: ctx->pc = 0; goto label_1d641c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d63d4: 0x3c028000
    SET_GPR_U32(ctx, 2, ((uint32_t)32768 << 16));
    // 0x1d63d8: 0x8e0326c4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9924)));
    // 0x1d63dc: 0x344200a0
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 160));
    // 0x1d63e0: 0x1060006e
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D659C; return;
    }
    // 0x1d63e8: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1d63ec: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d63f0: 0x10620008
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d6414;
    }
    // 0x1d63f8: 0xc60226cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9932)); ctx->f[2] = *(float*)&val; }
    // 0x1d63fc: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1d6400: 0xc60126d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9936)); ctx->f[1] = *(float*)&val; }
    // 0x1d6404: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d6408: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1d640c: 0x10000003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[20] = ctx->f[0] / ctx->f[1];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d641c;
    }
label_1d6414:
    // 0x1d6414: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1d6418: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
label_1d641c:
    // 0x1d641c: 0xc60126c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9928)); ctx->f[1] = *(float*)&val; }
    // 0x1d6420: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1d6424: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1d6428: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d642c: 0x46016301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
    // 0x1d6430: 0xc081484
    SET_GPR_U32(ctx, 31, 0x1d6438);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_1d6438
// Address: 0x1d6438 - 0x1d65c0

void entry_1d6438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6438) {
        switch (ctx->pc) {
            case 0x1d6494: ctx->pc = 0; goto label_1d6494;
            case 0x1d64d8: ctx->pc = 0; goto label_1d64d8;
            case 0x1d64e8: ctx->pc = 0; goto label_1d64e8;
            case 0x1d659c: ctx->pc = 0; goto label_1d659c;
            case 0x1d65b4: ctx->pc = 0; goto label_1d65b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6438: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d643c: 0x46000186
    ctx->f[6] = FPU_MOV_S(ctx->f[0]);
    // 0x1d6440: 0x24435140
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 20800));
    // 0x1d6444: 0xc4425140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20800)); ctx->f[2] = *(float*)&val; }
    // 0x1d6448: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d644c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d6450: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d6454: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d6458: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1d645c: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1d6460: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1d6464: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d6468: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1d646c: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1d6470: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d6474: 0x0
    // NOP
    // 0x1d6478: 0x45010006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d6494;
    }
    // 0x1d6480: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d6484: 0x0
    // NOP
    // 0x1d6488: 0x45000002
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d6494;
    }
    // 0x1d6490: 0x46001906
    ctx->f[4] = FPU_MOV_S(ctx->f[3]);
label_1d6494:
    // 0x1d6494: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d6498: 0xc4855c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x1d649c: 0x24435150
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 20816));
    // 0x1d64a0: 0xc4425150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20816)); ctx->f[2] = *(float*)&val; }
    // 0x1d64a4: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d64a8: 0x24825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x1d64ac: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d64b0: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x1d64b4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d64b8: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x1d64bc: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1d64c0: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d64c4: 0x0
    // NOP
    // 0x1d64c8: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d64d8;
    }
    // 0x1d64d0: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d64e8;
    }
label_1d64d8:
    // 0x1d64d8: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d64dc: 0x0
    // NOP
    // 0x1d64e0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[3]);
        goto label_1d64e8;
    }
label_1d64e8:
    // 0x1d64e8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d64ec: 0x46002102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1d64f0: 0x904323e0
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 9184)));
    // 0x1d64f4: 0x244423e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 9184));
    // 0x1d64f8: 0x93a20010
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d64fc: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1d6500: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1d6504: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d6508: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d650c: 0x90830002
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 2)));
    // 0x1d6510: 0x44822800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 2);
    // 0x1d6514: 0x46802960
    ctx->f[5] = FPU_CVT_S_W(*(int32_t*)&ctx->f[5]);
    // 0x1d6518: 0x93a50012
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 18)));
    // 0x1d651c: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x1d6520: 0x90860001
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 1)));
    // 0x1d6524: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x1d6528: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1d652c: 0x93a70011
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 17)));
    // 0x1d6530: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x1d6534: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1d6538: 0x44863800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 6);
    // 0x1d653c: 0x468039e0
    ctx->f[7] = FPU_CVT_S_W(*(int32_t*)&ctx->f[7]);
    // 0x1d6540: 0x90820003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 3)));
    // 0x1d6544: 0x44873000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 7);
    // 0x1d6548: 0x468031a0
    ctx->f[6] = FPU_CVT_S_W(*(int32_t*)&ctx->f[6]);
    // 0x1d654c: 0x460300c2
    ctx->f[3] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1d6550: 0xa3a20003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 2));
    // 0x1d6554: 0x46052142
    ctx->f[5] = FPU_MUL_S(ctx->f[4], ctx->f[5]);
    // 0x1d6558: 0x46012042
    ctx->f[1] = FPU_MUL_S(ctx->f[4], ctx->f[1]);
    // 0x1d655c: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1d6560: 0x46070002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[7]);
    // 0x1d6564: 0x46062102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[6]);
    // 0x1d6568: 0x460518c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[5]);
    // 0x1d656c: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1d6570: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x1d6574: 0x46001864
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[3]);
    // 0x1d6578: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1d657c: 0x46001064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[2]);
    // 0x1d6580: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1d6584: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1d6588: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1d658c: 0xa3a20000
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1d6590: 0xa3a30002
    WRITE8(ADD32(GPR_U32(ctx, 29), 2), (uint8_t)GPR_U32(ctx, 3));
    // 0x1d6594: 0x10000007
    WRITE8(ADD32(GPR_U32(ctx, 29), 1), (uint8_t)GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d65b4;
    }
label_1d659c:
    // 0x1d659c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d65a0: 0x244623e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 9184));
    // 0x1d65a4: 0x88c30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1d65a8: 0x98c30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x1d65ac: 0xaba30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1d65b0: 0xbba30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
label_1d65b4:
    // 0x1d65b4: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d65b8: 0xc049a92
    SET_GPR_U32(ctx, 31, 0x1d65c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetAloOverrideCel__FP3ALOG4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1d65c0
// Address: 0x1d65c0 - 0x1d65d8

void entry_1d65c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d65c0: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d65c4: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d65c8: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d65cc: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1d65d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: JthsCurrentJt__FP2JT
// Address: 0x1d65d8 - 0x1d6608

void entry_1d662c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d662c) {
        switch (ctx->pc) {
            case 0x1d6634: ctx->pc = 0; goto label_1d6634;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d662c: 0xae002730
    WRITE32(ADD32(GPR_U32(ctx, 16), 10032), GPR_U32(ctx, 0));
    // 0x1d6630: 0x8e0226c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9920)));
label_1d6634:
    // 0x1d6634: 0x10400006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D6650; return;
    }
    // 0x1d663c: 0xae0026c0
    WRITE32(ADD32(GPR_U32(ctx, 16), 9920), GPR_U32(ctx, 0));
    // 0x1d6640: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d6648);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9916)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d6648
// Address: 0x1d6648 - 0x1d6680

void entry_1d6648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6648) {
        switch (ctx->pc) {
            case 0x1d6650: ctx->pc = 0; goto label_1d6650;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6648: 0x10000012
    WRITE32(ADD32(GPR_U32(ctx, 16), 9368), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D6694; return;
    }
label_1d6650:
    // 0x1d6650: 0x7a030150
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1d6654: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d6658: 0xc4415160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20832)); ctx->f[1] = *(float*)&val; }
    // 0x1d665c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d6660: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x1d6664: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d6668: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1d666c: 0x46000868
    ctx->f[1] = std::max(ctx->f[1], ctx->f[0]);
    // 0x1d6670: 0xe7a10008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x1d6674: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1d6678: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d6680);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d6680
// Address: 0x1d6680 - 0x1d6690

void entry_1d6680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6680: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d6684: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d6688: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1d6690);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1d6690
// Address: 0x1d6690 - 0x1d66a8

void entry_1d6690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6690) {
        switch (ctx->pc) {
            case 0x1d6694: ctx->pc = 0; goto label_1d6694;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6690: 0xae002498
    WRITE32(ADD32(GPR_U32(ctx, 16), 9368), GPR_U32(ctx, 0));
label_1d6694:
    // 0x1d6694: 0xae00226c
    WRITE32(ADD32(GPR_U32(ctx, 16), 8812), GPR_U32(ctx, 0));
    // 0x1d6698: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d669c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d66a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtWater__FP2JT
// Address: 0x1d66a8 - 0x1d6764

void entry_1d6764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6764) {
        switch (ctx->pc) {
            case 0x1d67a0: ctx->pc = 0; goto label_1d67a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6764: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1d6768: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d676c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1d6770: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d6774: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d6778: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1d677c: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d6780: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1d6784: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d6788: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d678c: 0x4be309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1d6790: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d6794: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d6798: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d679c: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
label_1d67a0:
    // 0x1d67a0: 0x8ea22438
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 9272)));
    // 0x1d67a4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d67a8: 0xc04f996
    SET_GPR_U32(ctx, 31, 0x1d67b0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 1016)));
    PbspPointInBspQuick__FP6VECTORP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_1d67b0
// Address: 0x1d67b0 - 0x1d6808

void entry_1d67b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d67b0) {
        switch (ctx->pc) {
            case 0x1d67b4: ctx->pc = 0; goto label_1d67b4;
            case 0x1d67fc: ctx->pc = 0; goto label_1d67fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d67b0: 0x2802b
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1d67b4:
    // 0x1d67b4: 0x1200008b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D69E4; return;
    }
    // 0x1d67bc: 0xc6a10158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 344)); ctx->f[1] = *(float*)&val; }
    // 0x1d67c0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d67c4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d67c8: 0x0
    // NOP
    // 0x1d67cc: 0x4503000b
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 21), 9272)));
        goto label_1d67fc;
    }
    // 0x1d67d4: 0x8ea32220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 8736)));
    // 0x1d67d8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d67dc: 0x10620016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 44));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        entry_1d6838(rdram, ctx, runtime); return;
    }
    // 0x1d67e4: 0x8ea32228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 8744)));
    // 0x1d67e8: 0x10620013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 43));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        entry_1d6838(rdram, ctx, runtime); return;
    }
    // 0x1d67f0: 0x10620011
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        entry_1d6838(rdram, ctx, runtime); return;
    }
    // 0x1d67f8: 0x8ea62438
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 21), 9272)));
label_1d67fc:
    // 0x1d67fc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d6800: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x1d6808);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1d6808
// Address: 0x1d6808 - 0x1d6820

void entry_1d6808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6808: 0x8ea42438
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 9272)));
    // 0x1d680c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d6810: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d6814: 0x8c62012c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 300)));
    // 0x1d6818: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d6820);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d6820
// Address: 0x1d6820 - 0x1d6838

void entry_1d6820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6820: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d6838(rdram, ctx, runtime); return;
    }
    // 0x1d6828: 0x8ea30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1d682c: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1d6830: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d6838);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d6838
// Address: 0x1d6838 - 0x1d684c

void entry_1d6838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6838: 0x12000069
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D69E0; return;
    }
    // 0x1d6840: 0x8ea52438
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 21), 9272)));
    // 0x1d6844: 0xc075a86
    SET_GPR_U32(ctx, 31, 0x1d684c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FFindJtWaterSurface__FP2JTP5WATERP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d684c
// Address: 0x1d684c - 0x1d68ac

void entry_1d684c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d684c) {
        switch (ctx->pc) {
            case 0x1d6868: ctx->pc = 0; goto label_1d6868;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d684c: 0x10400064
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D69E0; return;
    }
    // 0x1d6854: 0x3c013d4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15692 << 16));
    // 0x1d6858: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1d685c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1d6860: 0x1010c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 3));
    // 0x1d6864: 0x0
    // NOP
label_1d6868:
    // 0x1d6868: 0x244226d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 9944));
    // 0x1d686c: 0x2a2b021
    SET_GPR_U32(ctx, 22, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x1d6870: 0x8ed40000
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1d6874: 0x12800056
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D69D0; return;
    }
    // 0x1d687c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1d6880: 0xc6c10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d6884: 0x24841858
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6232));
    // 0x1d6888: 0xc4800004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d688c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1d6890: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d6894: 0x0
    // NOP
    // 0x1d6898: 0x4503004e
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 16, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
        ctx->pc = 0x1D69D4; return;
    }
    // 0x1d68a0: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d68a4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d68ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 120));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d68ac
// Address: 0x1d68ac - 0x1d68c0

void entry_1d68ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d68ac: 0x10400006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D68C8; return;
    }
    // 0x1d68b4: 0x26850094
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 148));
    // 0x1d68b8: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1d68c0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1d68c0
// Address: 0x1d68c0 - 0x1d68fc

void entry_1d68c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d68c0) {
        switch (ctx->pc) {
            case 0x1d68c8: ctx->pc = 0; goto label_1d68c8;
            case 0x1d68d0: ctx->pc = 0; goto label_1d68d0;
            case 0x1d68e8: ctx->pc = 0; goto label_1d68e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d68c0: 0x10000003
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d68d0;
    }
label_1d68c8:
    // 0x1d68c8: 0xafb40010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 20));
    // 0x1d68cc: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
label_1d68d0:
    // 0x1d68d0: 0x1860003f
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 16), 1));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1D69D0; return;
    }
    // 0x1d68d8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d68dc: 0x60982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1d68e0: 0x24571858
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1d68e4: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
label_1d68e8:
    // 0x1d68e8: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d68ec: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d68f0: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d68f4: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1d68fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d68fc
// Address: 0x1d68fc - 0x1d6924

void entry_1d68fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d68fc: 0x7a020040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1d6900: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d6904: 0xc6ec0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1d6908: 0x27a60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d690c: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x1d6910: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d6914: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d6918: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d691c: 0xc049676
    SET_GPR_U32(ctx, 31, 0x1d6924);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1d6924
// Address: 0x1d6924 - 0x1d69bc

void entry_1d6924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6924) {
        switch (ctx->pc) {
            case 0x1d6948: ctx->pc = 0; goto label_1d6948;
            case 0x1d6950: ctx->pc = 0; goto label_1d6950;
            case 0x1d6958: ctx->pc = 0; goto label_1d6958;
            case 0x1d69ac: ctx->pc = 0; goto label_1d69ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6924: 0xc7a10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d6928: 0xc7a00038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[0] = *(float*)&val; }
    // 0x1d692c: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d6930: 0x0
    // NOP
    // 0x1d6934: 0x45000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[0] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d6948;
    }
    // 0x1d693c: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d6940: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d6950;
    }
label_1d6948:
    // 0x1d6948: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d694c: 0x0
    // NOP
label_1d6950:
    // 0x1d6950: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1d6958;
    }
label_1d6958:
    // 0x1d6958: 0x1220001a
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D69C4; return;
    }
    // 0x1d6960: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d6964: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1d6968: 0x7fa20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 2));
    // 0x1d696c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d6970: 0xe7a00078
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 120), *(uint32_t*)&val); }
    // 0x1d6974: 0xafa20050
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 2));
    // 0x1d6978: 0x8e030090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x1d697c: 0x8c620120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 288)));
    // 0x1d6980: 0x5444000a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1d69ac;
    }
    // 0x1d6988: 0x8c6201b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 432)));
    // 0x1d698c: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d6990: 0x54430006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1d69ac;
    }
    // 0x1d6998: 0x8ea22438
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 9272)));
    // 0x1d699c: 0x24040024
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 36));
    // 0x1d69a0: 0xafa40050
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 4));
    // 0x1d69a4: 0xafa20088
    WRITE32(ADD32(GPR_U32(ctx, 29), 136), GPR_U32(ctx, 2));
    // 0x1d69a8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1d69ac:
    // 0x1d69ac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d69b0: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x1d69b4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1d69bc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1d69bc
// Address: 0x1d69bc - 0x1d6a18

void entry_1d69bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d69bc) {
        switch (ctx->pc) {
            case 0x1d69c4: ctx->pc = 0; goto label_1d69c4;
            case 0x1d69d0: ctx->pc = 0; goto label_1d69d0;
            case 0x1d69d4: ctx->pc = 0; goto label_1d69d4;
            case 0x1d69e0: ctx->pc = 0; goto label_1d69e0;
            case 0x1d69e4: ctx->pc = 0; goto label_1d69e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d69bc: 0xc6e00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d69c0: 0xe6c00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 22), 4), *(uint32_t*)&val); }
label_1d69c4:
    // 0x1d69c4: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x1d69c8: 0x1660ffc7
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D68E8; return;
    }
label_1d69d0:
    // 0x1d69d0: 0x3c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
label_1d69d4:
    // 0x1d69d4: 0x2e020008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), 8));
    // 0x1d69d8: 0x1440ffa3
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D6868; return;
    }
label_1d69e0:
    // 0x1d69e0: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
label_1d69e4:
    // 0x1d69e4: 0x7bbe0120
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1d69e8: 0x7bb70110
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1d69ec: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1d69f0: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1d69f4: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d69f8: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d69fc: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d6a00: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d6a04: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d6a08: 0xc7b40140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[20] = *(float*)&val; }
    // 0x1d6a0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 336));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d6a14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d6a18; return;
}


// Function: FFindJtWaterSurface__FP2JTP5WATERP6VECTOR
// Address: 0x1d6a18 - 0x1d6a64

void entry_1d6a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6a64) {
        switch (ctx->pc) {
            case 0x1d6a78: ctx->pc = 0; goto label_1d6a78;
            case 0x1d6a88: ctx->pc = 0; goto label_1d6a88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6a64: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1d6a68: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d6a6c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d6a70: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d6a88;
    }
label_1d6a78:
    // 0x1d6a78: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d6a7c: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1d6a80: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d6a84: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
label_1d6a88:
    // 0x1d6a88: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1d6a8c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d6a90: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d6a94: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d6a98: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d6a9c: 0xc4435164
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20836)); ctx->f[3] = *(float*)&val; }
    // 0x1d6aa0: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d6aa4: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d6aa8: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d6aac: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1d6ab0: 0xc4625168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20840)); ctx->f[2] = *(float*)&val; }
    // 0x1d6ab4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d6ab8: 0xc7a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1d6abc: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d6ac0: 0xc7a10038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[1] = *(float*)&val; }
    // 0x1d6ac4: 0x27a90040
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d6ac8: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1d6acc: 0x8e2403f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1016)));
    // 0x1d6ad0: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x1d6ad4: 0xe7a00028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
    // 0x1d6ad8: 0xc04f7f6
    SET_GPR_U32(ctx, 31, 0x1d6ae0);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1d6ae0
// Address: 0x1d6ae0 - 0x1d6b18

void entry_1d6ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6ae0) {
        switch (ctx->pc) {
            case 0x1d6afc: ctx->pc = 0; goto label_1d6afc;
            case 0x1d6b00: ctx->pc = 0; goto label_1d6b00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6ae0: 0x10400006
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d6afc;
    }
    // 0x1d6ae8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d6aec: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d6af0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d6af4: 0x10000002
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d6b00;
    }
label_1d6afc:
    // 0x1d6afc: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1d6b00:
    // 0x1d6b00: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d6b04: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d6b08: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d6b0c: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d6b10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddJtWaterAcceleration__FP2JTP5WATERf
// Address: 0x1d6b18 - 0x1d6ba0

void entry_1d6ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6ba0) {
        switch (ctx->pc) {
            case 0x1d6ba8: ctx->pc = 0; goto label_1d6ba8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6ba0: 0x1000003d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D6C98; return;
    }
label_1d6ba8:
    // 0x1d6ba8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d6bac: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d6bb0: 0xc075a86
    SET_GPR_U32(ctx, 31, 0x1d6bb8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FFindJtWaterSurface__FP2JTP5WATERP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d6bb8
// Address: 0x1d6bb8 - 0x1d6bf4

void entry_1d6bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6bb8: 0x10400036
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 1632));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d6c94(rdram, ctx, runtime); return;
    }
    // 0x1d6bc0: 0xda010660
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1632)));
    // 0x1d6bc4: 0xd8440020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1d6bc8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d6bcc: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1d6bd0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d6bd4: 0xda020640
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1600)));
    // 0x1d6bd8: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1d6bdc: 0x4bc209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d6be0: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d6be4: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d6be8: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d6bec: 0xc07bb5a
    SET_GPR_U32(ctx, 31, 0x1d6bf4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    CalculateWaterCurrent__FP5WATERP6VECTORN21(rdram, ctx, runtime); return;
}


// Function: entry_1d6bf4
// Address: 0x1d6bf4 - 0x1d6c54

void entry_1d6bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6bf4: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1d6bf8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d6bfc: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d6c00: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d6c04: 0xc60c0148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 328)); ctx->f[12] = *(float*)&val; }
    // 0x1d6c08: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d6c0c: 0xc6000158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 344)); ctx->f[0] = *(float*)&val; }
    // 0x1d6c10: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d6c14: 0xc441516c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20844)); ctx->f[1] = *(float*)&val; }
    // 0x1d6c18: 0x24845178
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 20856));
    // 0x1d6c1c: 0xc7ad0028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[13] = *(float*)&val; }
    // 0x1d6c20: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1d6c24: 0x8c635170
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 20848)));
    // 0x1d6c28: 0x46016300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[1]);
    // 0x1d6c2c: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d6c30: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1d6c34: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d6c38: 0x460d0341
    ctx->f[13] = FPU_SUB_S(ctx->f[0], ctx->f[13]);
    // 0x1d6c3c: 0x4be30858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d6c40: 0xc7ae0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1d6c44: 0x4600a3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[20]);
    // 0x1d6c48: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d6c4c: 0xc07a988
    SET_GPR_U32(ctx, 31, 0x1d6c54);
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    GSmoothA__FffffP4SMPAPf(rdram, ctx, runtime); return;
}


// Function: entry_1d6c54
// Address: 0x1d6c54 - 0x1d6c84

void entry_1d6c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6c54: 0xc6020158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 344)); ctx->f[2] = *(float*)&val; }
    // 0x1d6c58: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d6c5c: 0xc7a10060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[1] = *(float*)&val; }
    // 0x1d6c60: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d6c64: 0xc6030358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 856)); ctx->f[3] = *(float*)&val; }
    // 0x1d6c68: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x1d6c6c: 0xc7a00048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[0] = *(float*)&val; }
    // 0x1d6c70: 0x46140843
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[20];
    // 0x1d6c74: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1d6c78: 0x46000868
    ctx->f[1] = std::max(ctx->f[1], ctx->f[0]);
    // 0x1d6c7c: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1d6c84);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 72), *(uint32_t*)&val); }
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d6c84
// Address: 0x1d6c84 - 0x1d6c94

void entry_1d6c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6c84) {
        switch (ctx->pc) {
            case 0x1d6c8c: ctx->pc = 0; goto label_1d6c8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6c84: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D6C98; return;
    }
label_1d6c8c:
    // 0x1d6c8c: 0xc06e96c
    SET_GPR_U32(ctx, 31, 0x1d6c94);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    AddSoWaterAcceleration__FP2SOP5WATERf(rdram, ctx, runtime); return;
}


// Function: entry_1d6c94
// Address: 0x1d6c94 - 0x1d6cb0

void entry_1d6c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6c94) {
        switch (ctx->pc) {
            case 0x1d6c98: ctx->pc = 0; goto label_1d6c98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6c94: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_1d6c98:
    // 0x1d6c98: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d6c9c: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d6ca0: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x1d6ca4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d6cac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d6cb0; return;
}


// Function: FUN_001d6cb0
// Address: 0x1d6cb0 - 0x1d6d04

void FUN_001d6cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6cb0) {
        switch (ctx->pc) {
            case 0x1d6ce0: ctx->pc = 0; goto label_1d6ce0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6cb0: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x1d6cb4: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x1d6cb8: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x1d6cbc: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d6cc0: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x1d6cc4: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1d6cc8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1d6ccc: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1d6cd0: 0x8e721518
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 19), 5400)));
    // 0x1d6cd4: 0x1240002a
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_1d6d80(rdram, ctx, runtime); return;
    }
    // 0x1d6cdc: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
label_1d6ce0:
    // 0x1d6ce0: 0x2e220004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 4));
    // 0x1d6ce4: 0x1040000b
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D6D14; return;
    }
    // 0x1d6cec: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1d6cf0: 0x8c501508
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 5384)));
    // 0x1d6cf4: 0x5200fffa
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        goto label_1d6ce0;
    }
    // 0x1d6cfc: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1d6d04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1d6d04
// Address: 0x1d6d04 - 0x1d6d28

void entry_1d6d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6d04) {
        switch (ctx->pc) {
            case 0x1d6d14: ctx->pc = 0; goto label_1d6d14;
            case 0x1d6d1c: ctx->pc = 0; goto label_1d6d1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6d04: 0x1040fff6
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D6CE0; return;
    }
    // 0x1d6d0c: 0x10000003
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d6d1c;
    }
label_1d6d14:
    // 0x1d6d14: 0x8e701504
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 5380)));
    // 0x1d6d18: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_1d6d1c:
    // 0x1d6d1c: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1d6d20: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d6d28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d6d28
// Address: 0x1d6d28 - 0x1d6d3c

void entry_1d6d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6d28: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d6d2c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d6d30: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x1d6d34: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d6d3c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d6d3c
// Address: 0x1d6d3c - 0x1d6d50

void entry_1d6d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6d3c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d6d40: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d6d44: 0x8c62008c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 140)));
    // 0x1d6d48: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d6d50);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d6d50
// Address: 0x1d6d50 - 0x1d6d80

void entry_1d6d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6d50: 0x26831858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x1d6d54: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d6d58: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d6d5c: 0xae420694
    WRITE32(ADD32(GPR_U32(ctx, 18), 1684), GPR_U32(ctx, 2));
    // 0x1d6d60: 0xe6400690
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1680), *(uint32_t*)&val); }
    // 0x1d6d64: 0x8e621504
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 5380)));
    // 0x1d6d68: 0x12020006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D6D84; return;
    }
    // 0x1d6d70: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d6d74: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1d6d78: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d6d80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d6d80
// Address: 0x1d6d80 - 0x1d6da0

void entry_1d6d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6d80) {
        switch (ctx->pc) {
            case 0x1d6d84: ctx->pc = 0; goto label_1d6d84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6d80: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1d6d84:
    // 0x1d6d84: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d6d88: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d6d8c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d6d90: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d6d94: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d6d98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d6da0
// Address: 0x1d6da0 - 0x1d6dbc

void FUN_001d6da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6da0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d6da4: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1d6da8: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1d6dac: 0x10a30005
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x1D6DC4; return;
    }
    // 0x1d6db4: 0xc06e282
    SET_GPR_U32(ctx, 31, 0x1d6dbc);
    FIgnoreSoIntersection__FP2SOT0(rdram, ctx, runtime); return;
}


// Function: entry_1d6dbc
// Address: 0x1d6dbc - 0x1d6dd8

void entry_1d6dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6dbc) {
        switch (ctx->pc) {
            case 0x1d6dc4: ctx->pc = 0; goto label_1d6dc4;
            case 0x1d6dcc: ctx->pc = 0; goto label_1d6dcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6dbc: 0x10000003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d6dcc;
    }
label_1d6dc4:
    // 0x1d6dc4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d6dc8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1d6dcc:
    // 0x1d6dcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d6dd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d6dd8; return;
}


// Function: FUN_001d6dd8
// Address: 0x1d6dd8 - 0x1d6e04

void FUN_001d6dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6dd8: 0x27bdfec0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966976));
    // 0x1d6ddc: 0x7fb20100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 18));
    // 0x1d6de0: 0xe7b50138
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 312), *(uint32_t*)&val); }
    // 0x1d6de4: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d6de8: 0x46006546
    ctx->f[21] = FPU_MOV_S(ctx->f[12]);
    // 0x1d6dec: 0x7fbf0120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 31));
    // 0x1d6df0: 0x7fb30110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 19));
    // 0x1d6df4: 0x7fb100f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 17));
    // 0x1d6df8: 0x7fb000e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 16));
    // 0x1d6dfc: 0xc06e4ce
    SET_GPR_U32(ctx, 31, 0x1d6e04);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 304), *(uint32_t*)&val); }
    PresetSoAccel__FP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_1d6e04
// Address: 0x1d6e04 - 0x1d6e80

void entry_1d6e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6e04) {
        switch (ctx->pc) {
            case 0x1d6e5c: ctx->pc = 0; goto label_1d6e5c;
            case 0x1d6e70: ctx->pc = 0; goto label_1d6e70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6e04: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d6e08: 0xc6410690
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1680)); ctx->f[1] = *(float*)&val; }
    // 0x1d6e0c: 0xc462185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[2] = *(float*)&val; }
    // 0x1d6e10: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d6e14: 0x244351c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 20928));
    // 0x1d6e18: 0xc44351c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20928)); ctx->f[3] = *(float*)&val; }
    // 0x1d6e1c: 0x46011081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    // 0x1d6e20: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1d6e24: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d6e28: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d6e2c: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1d6e30: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1d6e34: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1d6e38: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1d6e3c: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1d6e40: 0x46021b00
    ctx->f[12] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1d6e44: 0x46046034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d6e48: 0x0
    // NOP
    // 0x1d6e4c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d6e5c;
    }
    // 0x1d6e54: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d6e70;
    }
label_1d6e5c:
    // 0x1d6e5c: 0x460c2834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d6e60: 0x0
    // NOP
    // 0x1d6e64: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d6e70;
    }
    // 0x1d6e6c: 0x46002d06
    ctx->f[20] = FPU_MOV_S(ctx->f[5]);
label_1d6e70:
    // 0x1d6e70: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d6e74: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d6e78: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x1d6e80);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 208));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1d6e80
// Address: 0x1d6e80 - 0x1d6e94

void entry_1d6e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6e80: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1d6e84: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1d6e88: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d6e8c: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1d6e94);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 20880));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1d6e94
// Address: 0x1d6e94 - 0x1d6ea4

void entry_1d6e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6e94: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d6e98: 0x27a40090
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1d6e9c: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1d6ea4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d6ea4
// Address: 0x1d6ea4 - 0x1d6eb0

void entry_1d6ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6ea4: 0x7ba50090
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d6ea8: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1d6eb0);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d6eb0
// Address: 0x1d6eb0 - 0x1d6ebc

void entry_1d6eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6eb0: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1d6eb4: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1d6ebc);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d6ebc
// Address: 0x1d6ebc - 0x1d6ed0

void entry_1d6ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6ebc: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1d6ec0: 0x27a400a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1d6ec4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d6ec8: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1d6ed0);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 20896));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1d6ed0
// Address: 0x1d6ed0 - 0x1d6ee0

void entry_1d6ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6ed0: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d6ed4: 0x27a400b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1d6ed8: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1d6ee0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d6ee0
// Address: 0x1d6ee0 - 0x1d6eec

void entry_1d6ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6ee0: 0x7ba500b0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d6ee4: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1d6eec);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d6eec
// Address: 0x1d6eec - 0x1d6ef8

void entry_1d6eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6eec: 0x70022ca9
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1d6ef0: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1d6ef8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d6ef8
// Address: 0x1d6ef8 - 0x1d6f60

void entry_1d6ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6ef8) {
        switch (ctx->pc) {
            case 0x1d6f20: ctx->pc = 0; goto label_1d6f20;
            case 0x1d6f40: ctx->pc = 0; goto label_1d6f40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6ef8: 0x8e430694
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1684)));
    // 0x1d6efc: 0x10600008
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1d6f20;
    }
    // 0x1d6f04: 0xda4100f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 240)));
    // 0x1d6f08: 0x8c425188
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 20872)));
    // 0x1d6f0c: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d6f10: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d6f14: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d6f18: 0x10000009
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d6f40;
    }
label_1d6f20:
    // 0x1d6f20: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d6f24: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d6f28: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1d6f2c: 0x24635c40
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 23616));
    // 0x1d6f30: 0x78440000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d6f34: 0x78650000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d6f38: 0x7fa40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 4));
    // 0x1d6f3c: 0x7fa50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 5));
label_1d6f40:
    // 0x1d6f40: 0x27a80060
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1d6f44: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d6f48: 0x100982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1d6f4c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d6f50: 0x27a60050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1d6f54: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d6f58: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x1d6f60);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_1d6f60
// Address: 0x1d6f60 - 0x1d6fac

void entry_1d6f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d6f60) {
        switch (ctx->pc) {
            case 0x1d6f88: ctx->pc = 0; goto label_1d6f88;
            case 0x1d6f98: ctx->pc = 0; goto label_1d6f98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d6f60: 0x8e420694
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1684)));
    // 0x1d6f64: 0x10400008
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d6f88;
    }
    // 0x1d6f6c: 0xda4100d0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
    // 0x1d6f70: 0x8c42518c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 20876)));
    // 0x1d6f74: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d6f78: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d6f7c: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d6f80: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d6f98;
    }
label_1d6f88:
    // 0x1d6f88: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d6f8c: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1d6f90: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d6f94: 0x7fa30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 3));
label_1d6f98:
    // 0x1d6f98: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1d6f9c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1d6fa0: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1d6fa4: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1d6fac);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 20912));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1d6fac
// Address: 0x1d6fac - 0x1d6fbc

void entry_1d6fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6fac: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d6fb0: 0x27a400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1d6fb4: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1d6fbc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d6fbc
// Address: 0x1d6fbc - 0x1d6fc8

void entry_1d6fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6fbc: 0x7ba500d0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d6fc0: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1d6fc8);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d6fc8
// Address: 0x1d6fc8 - 0x1d6fd4

void entry_1d6fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6fc8: 0x27a40060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1d6fcc: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1d6fd4);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d6fd4
// Address: 0x1d6fd4 - 0x1d6ff0

void entry_1d6fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6fd4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d6fd8: 0x260402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d6fdc: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1d6fe0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d6fe4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d6fe8: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x1d6ff0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_1d6ff0
// Address: 0x1d6ff0 - 0x1d7018

void entry_1d6ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d6ff0: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1d6ff4: 0x7bb30110
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1d6ff8: 0x7bb20100
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1d6ffc: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1d7000: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d7004: 0xc7b50138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[21] = *(float*)&val; }
    // 0x1d7008: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x1d700c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d7014: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d7018; return;
}


// Function: FUN_001d7018
// Address: 0x1d7018 - 0x1d702c

void FUN_001d7018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7018: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1d701c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1d7020: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1d7024: 0xc04ee9c
    SET_GPR_U32(ctx, 31, 0x1d702c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    FUN_0013ba70(rdram, ctx, runtime); return;
}


// Function: entry_1d702c
// Address: 0x1d702c - 0x1d7040

void entry_1d702c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d702c: 0xae000694
    WRITE32(ADD32(GPR_U32(ctx, 16), 1684), GPR_U32(ctx, 0));
    // 0x1d7030: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d7034: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d7038: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001d7040
// Address: 0x1d7040 - 0x1d7064

void FUN_001d7040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7040: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1d7044: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1d7048: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1d704c: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d7050: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1d7054: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1d7058: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1d705c: 0xc04edc2
    SET_GPR_U32(ctx, 31, 0x1d7064);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    HandleBombMessage__FP4BOMB5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_1d7064
// Address: 0x1d7064 - 0x1d7098

void entry_1d7064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d7064) {
        switch (ctx->pc) {
            case 0x1d7080: ctx->pc = 0; goto label_1d7080;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d7064: 0x2402000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1d7068: 0x16020005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1d7080;
    }
    // 0x1d7070: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1d7074: 0x50d20002
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 18)) {
        WRITE32(ADD32(GPR_U32(ctx, 6), 1684), GPR_U32(ctx, 0));
        goto label_1d7080;
    }
    // 0x1d707c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1d7080:
    // 0x1d7080: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d7084: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d7088: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d708c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d7094: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d7098; return;
}


// Function: InitZpr__FP3ZPR3ZPKP2LO
// Address: 0x1d7098 - 0x1d70c4

void entry_1d70c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d70c4: 0xae110008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 17));
    // 0x1d70c8: 0xae120000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 18));
    // 0x1d70cc: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x1d70d0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d70d4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d70d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d70dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d70e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d70e8: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d70ec: 0x0
    // NOP
    // 0x1d70f0: 0x7c450000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 5));
    // 0x1d70f4: 0x0
    // NOP
    // 0x1d70f8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d70fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d7100; return;
}


// Function: fn___5OSTRMi
// Address: 0x1d7100 - 0x1d7120

void entry_1d7164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7164: 0x32100001
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 1));
    // 0x1d7168: 0x12000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D717C; return;
    }
    // 0x1d7170: 0xc0635de
    SET_GPR_U32(ctx, 31, 0x1d7178);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___builtin_delete(rdram, ctx, runtime); return;
}


// Function: entry_1d7178
// Address: 0x1d7178 - 0x1d7190

void entry_1d7178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d7178) {
        switch (ctx->pc) {
            case 0x1d717c: ctx->pc = 0; goto label_1d717c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d7178: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1d717c:
    // 0x1d717c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d7180: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d7184: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d718c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d7190; return;
}


// Function: CbWrite__5OSTRMPvi
// Address: 0x1d7190 - 0x1d721c

void entry_1d721c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d721c) {
        switch (ctx->pc) {
            case 0x1d722c: ctx->pc = 0; goto label_1d722c;
            case 0x1d7238: ctx->pc = 0; goto label_1d7238;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d721c: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1d7220: 0x521021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1d7224: 0x1000001b
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D7294; return;
    }
label_1d722c:
    // 0x1d722c: 0x1a400019
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1024));
    if (GPR_S32(ctx, 18) <= 0) {
        ctx->pc = 0x1D7294; return;
    }
    // 0x1d7234: 0x8e250014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_1d7238:
    // 0x1d7238: 0x2532023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 19)));
    // 0x1d723c: 0x2851823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 5)));
    // 0x1d7240: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x1d7244: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1d7248: 0x82800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 4));
    // 0x1d724c: 0x12000009
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D7274; return;
    }
    // 0x1d7254: 0x24a40018
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 24));
    // 0x1d7258: 0x2b32821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 19)));
    // 0x1d725c: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1d7264);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1d7264
// Address: 0x1d7264 - 0x1d7288

void entry_1d7264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d7264) {
        switch (ctx->pc) {
            case 0x1d7274: ctx->pc = 0; goto label_1d7274;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d7264: 0x2709821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 16)));
    // 0x1d7268: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1d726c: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1d7270: 0xae220014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 2));
label_1d7274:
    // 0x1d7274: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1d7278: 0x14540004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 18)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        ctx->pc = 0x1D728C; return;
    }
    // 0x1d7280: 0xc075cb2
    SET_GPR_U32(ctx, 31, 0x1d7288);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Flush__5OSTRM(rdram, ctx, runtime); return;
}


// Function: entry_1d7288
// Address: 0x1d7288 - 0x1d72c8

void entry_1d7288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d7288) {
        switch (ctx->pc) {
            case 0x1d728c: ctx->pc = 0; goto label_1d728c;
            case 0x1d7294: ctx->pc = 0; goto label_1d7294;
            case 0x1d72a4: ctx->pc = 0; goto label_1d72a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d7288: 0x272102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 18)));
label_1d728c:
    // 0x1d728c: 0x5440ffea
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x1D7238; return;
    }
label_1d7294:
    // 0x1d7294: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1d7298: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d729c: 0x731821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 19)));
    // 0x1d72a0: 0xae230010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 3));
label_1d72a4:
    // 0x1d72a4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d72a8: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d72ac: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d72b0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d72b4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d72b8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d72bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d72c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Flush__5OSTRM
// Address: 0x1d72c8 - 0x1d7348

void entry_1d7348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7348: 0x2709821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 16)));
    // 0x1d734c: 0x3b01021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 16)));
    // 0x1d7350: 0x2684dc90
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 4294958224));
    // 0x1d7354: 0xa0400000
    WRITE8(ADD32(GPR_U32(ctx, 2), 0), (uint8_t)GPR_U32(ctx, 0));
    // 0x1d7358: 0xc07dee2
    SET_GPR_U32(ctx, 31, 0x1d7360);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    printf_2(rdram, ctx, runtime); return;
}


// Function: entry_1d7360
// Address: 0x1d7360 - 0x1d7380

void entry_1d7360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d7360) {
        switch (ctx->pc) {
            case 0x1d7378: ctx->pc = 0; goto label_1d7378;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d7360: 0x8e430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1d7364: 0x223102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 3)));
    // 0x1d7368: 0x1440ffef
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D7328; return;
    }
    // 0x1d7370: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 18), 20), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D7384; return;
    }
label_1d7378:
    // 0x1d7378: 0xc07e40a
    SET_GPR_U32(ctx, 31, 0x1d7380);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 24));
    FUN_001f9028(rdram, ctx, runtime); return;
}


// Function: entry_1d7380
// Address: 0x1d7380 - 0x1d73a8

void entry_1d7380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d7380) {
        switch (ctx->pc) {
            case 0x1d7384: ctx->pc = 0; goto label_1d7384;
            case 0x1d7388: ctx->pc = 0; goto label_1d7388;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d7380: 0xae400014
    WRITE32(ADD32(GPR_U32(ctx, 18), 20), GPR_U32(ctx, 0));
label_1d7384:
    // 0x1d7384: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
label_1d7388:
    // 0x1d7388: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d738c: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d7390: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d7394: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d7398: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d739c: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d73a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSuv__FP3SUV
// Address: 0x1d73a8 - 0x1d73bc

void entry_1d73bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d73bc: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1d73c0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1d73c4: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1d73c8: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1d73cc: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1d73d0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d73d4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d73d8: 0x3c0144a2
    SET_GPR_U32(ctx, 1, ((uint32_t)17570 << 16));
    // 0x1d73dc: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1d73e0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d73e4: 0x24635290
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 21136));
    // 0x1d73e8: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1d73ec: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1d73f0: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1d73f4: 0xe6030610
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 1552), *(uint32_t*)&val); }
    // 0x1d73f8: 0x26040630
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1584));
    // 0x1d73fc: 0xe6000618
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1560), *(uint32_t*)&val); }
    // 0x1d7400: 0x24060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1d7404: 0xe601061c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1564), *(uint32_t*)&val); }
    // 0x1d7408: 0x24a55250
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 21072));
    // 0x1d740c: 0xe6020868
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 2152), *(uint32_t*)&val); }
    // 0x1d7410: 0xe6030614
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 1556), *(uint32_t*)&val); }
    // 0x1d7414: 0xae020b04
    WRITE32(ADD32(GPR_U32(ctx, 16), 2820), GPR_U32(ctx, 2));
    // 0x1d7418: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1d741c: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1d7424);
    WRITE128(ADD32(GPR_U32(ctx, 16), 1568), GPR_VEC(ctx, 2));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1d7424
// Address: 0x1d7424 - 0x1d742c

void entry_1d7424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7424: 0xc076ca4
    SET_GPR_U32(ctx, 31, 0x1d742c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResetSuv__FP3SUV(rdram, ctx, runtime); return;
}


// Function: entry_1d742c
// Address: 0x1d742c - 0x1d7440

void entry_1d742c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d742c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d7430: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d7434: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d743c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d7440; return;
}


// Function: PostSuvLoad__FP3SUV
// Address: 0x1d7440 - 0x1d7474

void entry_1d7474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7474: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1d7478: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d747c: 0x24c652a0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 21152));
    // 0x1d7480: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1d7488);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1d7488
// Address: 0x1d7488 - 0x1d7494

void entry_1d7488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7488: 0xc64c00d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 212)); ctx->f[12] = *(float*)&val; }
    // 0x1d748c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1d7494);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 208)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1d7494
// Address: 0x1d7494 - 0x1d74b0

void entry_1d7494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7494: 0x8e440b44
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 2884)));
    // 0x1d7498: 0x1080000d
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1684), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1d74d0(rdram, ctx, runtime); return;
    }
    // 0x1d74a0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d74a4: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1d74a8: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1d74b0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1d74b0
// Address: 0x1d74b0 - 0x1d74d0

void entry_1d74b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d74b0: 0x8e430b30
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2864)));
    // 0x1d74b4: 0x24060384
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 900));
    // 0x1d74b8: 0x24050484
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1156));
    // 0x1d74bc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d74c0: 0x38630001
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), 1));
    // 0x1d74c4: 0xae420b48
    WRITE32(ADD32(GPR_U32(ctx, 18), 2888), GPR_U32(ctx, 2));
    // 0x1d74c8: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1d74d0);
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 6));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d74d0
// Address: 0x1d74d0 - 0x1d75bc

void entry_1d74d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d74d0) {
        switch (ctx->pc) {
            case 0x1d7504: ctx->pc = 0; goto label_1d7504;
            case 0x1d7518: ctx->pc = 0; goto label_1d7518;
            case 0x1d7534: ctx->pc = 0; goto label_1d7534;
            case 0x1d7550: ctx->pc = 0; goto label_1d7550;
            case 0x1d7568: ctx->pc = 0; goto label_1d7568;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d74d0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d74d4: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1d74d8: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1d74dc: 0x8c631d70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 7536)));
    // 0x1d74e0: 0x10640014
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_1d7534;
    }
    // 0x1d74e8: 0x28620006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 6));
    // 0x1d74ec: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d7504;
    }
    // 0x1d74f4: 0x10620008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 22288)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d7518;
    }
    // 0x1d74fc: 0x10000055
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D7654; return;
    }
label_1d7504:
    // 0x1d7504: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1d7508: 0x10620011
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 22288)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d7550;
    }
    // 0x1d7510: 0x10000050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D7654; return;
    }
label_1d7518:
    // 0x1d7518: 0x8e430550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1360)));
    // 0x1d751c: 0x240401ad
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 429));
    // 0x1d7520: 0x240201d2
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 466));
    // 0x1d7524: 0x241001bb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 443));
    // 0x1d7528: 0x43200b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 2));
    // 0x1d752c: 0x1000000e
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 431));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d7568;
    }
label_1d7534:
    // 0x1d7534: 0x8e430550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1360)));
    // 0x1d7538: 0x24040280
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 640));
    // 0x1d753c: 0x240202a6
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 678));
    // 0x1d7540: 0x2410027f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 639));
    // 0x1d7544: 0x43200b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 2));
    // 0x1d7548: 0x10000007
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 637));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d7568;
    }
label_1d7550:
    // 0x1d7550: 0x8e430550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1360)));
    // 0x1d7554: 0x240402dc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 732));
    // 0x1d7558: 0x240202de
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 734));
    // 0x1d755c: 0x241002db
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 731));
    // 0x1d7560: 0x43200b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 2));
    // 0x1d7564: 0x241102dd
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 733));
label_1d7568:
    // 0x1d7568: 0x3c0145bb
    SET_GPR_U32(ctx, 1, ((uint32_t)17851 << 16));
    // 0x1d756c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1d7570: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x1d7574: 0x26450b80
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 2944));
    // 0x1d7578: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x1d757c: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1d7580: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d7584: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d7588: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1d758c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d7590: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1d7594: 0x4600c306
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    // 0x1d7598: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1d759c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1d75a0: 0x4600bb46
    ctx->f[13] = FPU_MOV_S(ctx->f[23]);
    // 0x1d75a4: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x1d75a8: 0x4600abc6
    ctx->f[15] = FPU_MOV_S(ctx->f[21]);
    // 0x1d75ac: 0x4600a406
    ctx->f[16] = FPU_MOV_S(ctx->f[20]);
    // 0x1d75b0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d75b4: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1d75bc);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1d75bc
// Address: 0x1d75bc - 0x1d75ec

void entry_1d75bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d75bc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d75c0: 0x26450b84
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 2948));
    // 0x1d75c4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d75c8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d75cc: 0x4600c306
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    // 0x1d75d0: 0x4600bb46
    ctx->f[13] = FPU_MOV_S(ctx->f[23]);
    // 0x1d75d4: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x1d75d8: 0x4600abc6
    ctx->f[15] = FPU_MOV_S(ctx->f[21]);
    // 0x1d75dc: 0x4600a406
    ctx->f[16] = FPU_MOV_S(ctx->f[20]);
    // 0x1d75e0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d75e4: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1d75ec);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1d75ec
// Address: 0x1d75ec - 0x1d761c

void entry_1d75ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d75ec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d75f0: 0x4600c306
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    // 0x1d75f4: 0x4600bb46
    ctx->f[13] = FPU_MOV_S(ctx->f[23]);
    // 0x1d75f8: 0x4600b386
    ctx->f[14] = FPU_MOV_S(ctx->f[22]);
    // 0x1d75fc: 0x4600abc6
    ctx->f[15] = FPU_MOV_S(ctx->f[21]);
    // 0x1d7600: 0x4600a406
    ctx->f[16] = FPU_MOV_S(ctx->f[20]);
    // 0x1d7604: 0x26450b7c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 2940));
    // 0x1d7608: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d760c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d7610: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d7614: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1d761c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1d761c
// Address: 0x1d761c - 0x1d763c

void entry_1d761c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d761c: 0x3c01bdcc
    SET_GPR_U32(ctx, 1, ((uint32_t)48588 << 16));
    // 0x1d7620: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1d7624: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d7628: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1d762c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1d7630: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d7634: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1d763c);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d763c
// Address: 0x1d763c - 0x1d7660

void entry_1d763c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d763c) {
        switch (ctx->pc) {
            case 0x1d7654: ctx->pc = 0; goto label_1d7654;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d763c: 0xe6400b8c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 2956), *(uint32_t*)&val); }
    // 0x1d7640: 0xe6400b98
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 2968), *(uint32_t*)&val); }
    // 0x1d7644: 0xe6400b94
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 2964), *(uint32_t*)&val); }
    // 0x1d7648: 0xe6400b90
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 2960), *(uint32_t*)&val); }
    // 0x1d764c: 0x8e645710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 22288)));
    // 0x1d7650: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
label_1d7654:
    // 0x1d7654: 0x24060007
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1d7658: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1d7660);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1d7660
// Address: 0x1d7660 - 0x1d76a8

void entry_1d7660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d7660) {
        switch (ctx->pc) {
            case 0x1d7680: ctx->pc = 0; goto label_1d7680;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d7660: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2864)));
        goto label_1d7680;
    }
    // 0x1d7668: 0x3c014348
    SET_GPR_U32(ctx, 1, ((uint32_t)17224 << 16));
    // 0x1d766c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d7670: 0xae420598
    WRITE32(ADD32(GPR_U32(ctx, 18), 1432), GPR_U32(ctx, 2));
    // 0x1d7674: 0xe6400594
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1428), *(uint32_t*)&val); }
    // 0x1d7678: 0xae420b78
    WRITE32(ADD32(GPR_U32(ctx, 18), 2936), GPR_U32(ctx, 2));
    // 0x1d767c: 0x8e430b30
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2864)));
label_1d7680:
    // 0x1d7680: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d7684: 0x14620024
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 1712));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D7718; return;
    }
    // 0x1d768c: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1d7690: 0x24050105
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 261));
    // 0x1d7694: 0x24060426
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1062));
    // 0x1d7698: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d769c: 0x24080010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1d76a0: 0xc056866
    SET_GPR_U32(ctx, 31, 0x1d76a8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CploFindSwObjects__FP2SWi3OIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1d76a8
// Address: 0x1d76a8 - 0x1d76d8

void entry_1d76a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d76a8) {
        switch (ctx->pc) {
            case 0x1d76c0: ctx->pc = 0; goto label_1d76c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d76a8: 0x5840000e
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
        ctx->pc = 0x1D76E4; return;
    }
    // 0x1d76b0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d76b4: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d76b8: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d76bc: 0x0
    // NOP
label_1d76c0:
    // 0x1d76c0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d76c4: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x1d76c8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d76cc: 0x8c62006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 108)));
    // 0x1d76d0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d76d8);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d76d8
// Address: 0x1d76d8 - 0x1d7744

void entry_1d76d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d76d8) {
        switch (ctx->pc) {
            case 0x1d76e4: ctx->pc = 0; goto label_1d76e4;
            case 0x1d7718: ctx->pc = 0; goto label_1d7718;
            case 0x1d7720: ctx->pc = 0; goto label_1d7720;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d76d8: 0x5620fff9
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1D76C0; return;
    }
    // 0x1d76e0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1d76e4:
    // 0x1d76e4: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d76e8: 0x244226b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 9904));
    // 0x1d76ec: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d76f0: 0x24632430
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 9264));
    // 0x1d76f4: 0xa844027f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 639); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1d76f8: 0xb844027c
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 636); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1d76fc: 0xa864027f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 639); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1d7700: 0xb864027c
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 636); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1d7704: 0x2466027c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 636));
    // 0x1d7708: 0x2445027c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 636));
    // 0x1d770c: 0xac660264
    WRITE32(ADD32(GPR_U32(ctx, 3), 612), GPR_U32(ctx, 6));
    // 0x1d7710: 0xac450264
    WRITE32(ADD32(GPR_U32(ctx, 2), 612), GPR_U32(ctx, 5));
    // 0x1d7714: 0x264406b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 1712));
label_1d7718:
    // 0x1d7718: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1d771c: 0x0
    // NOP
label_1d7720:
    // 0x1d7720: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d7724: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1d7728: 0x78620100
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 256)));
    // 0x1d772c: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x1d7730: 0x0
    // NOP
    // 0x1d7734: 0x4a1fffa
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 96));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_1d7720;
    }
    // 0x1d773c: 0xc076ca4
    SET_GPR_U32(ctx, 31, 0x1d7744);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ResetSuv__FP3SUV(rdram, ctx, runtime); return;
}


// Function: entry_1d7744
// Address: 0x1d7744 - 0x1d7778

void entry_1d7744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7744: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d7748: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d774c: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d7750: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d7754: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d7758: 0xc7b800b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[24] = *(float*)&val; }
    // 0x1d775c: 0xc7b700a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[23] = *(float*)&val; }
    // 0x1d7760: 0xc7b600a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[22] = *(float*)&val; }
    // 0x1d7764: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1d7768: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1d776c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d7774: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d7778; return;
}


// Function: PresetSuvAccel__FP3SUVf
// Address: 0x1d7778 - 0x1d77c4

void entry_1d77c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d77c4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d77c8: 0xc6400850
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2128)); ctx->f[0] = *(float*)&val; }
    // 0x1d77cc: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1d77d0: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d77d4: 0xc4420004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1d77d8: 0xc4615390
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 21392)); ctx->f[1] = *(float*)&val; }
    // 0x1d77dc: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1d77e0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d77e4: 0x0
    // NOP
    // 0x1d77e8: 0x45000013
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1d7838(rdram, ctx, runtime); return;
    }
    // 0x1d77f0: 0xc640086c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2156)); ctx->f[0] = *(float*)&val; }
    // 0x1d77f4: 0xc4415394
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21396)); ctx->f[1] = *(float*)&val; }
    // 0x1d77f8: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1d77fc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7800: 0x0
    // NOP
    // 0x1d7804: 0x4500000c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1d7838(rdram, ctx, runtime); return;
    }
    // 0x1d780c: 0x264400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 208));
    // 0x1d7810: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x1d7818);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1d7818
// Address: 0x1d7818 - 0x1d7838

void entry_1d7818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7818: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1d781c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d7820: 0x24c653a0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 21408));
    // 0x1d7824: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d7828: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d782c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d7830: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x1d7838);
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_1d7838
// Address: 0x1d7838 - 0x1d7904

void entry_1d7838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d7838) {
        switch (ctx->pc) {
            case 0x1d78a8: ctx->pc = 0; goto label_1d78a8;
            case 0x1d78e4: ctx->pc = 0; goto label_1d78e4;
            case 0x1d78e8: ctx->pc = 0; goto label_1d78e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d7838: 0x27a20070
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1d783c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d7840: 0xafa2011c
    WRITE32(ADD32(GPR_U32(ctx, 29), 284), GPR_U32(ctx, 2));
    // 0x1d7844: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d7848: 0x247753d0
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 3), 21456));
    // 0x1d784c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d7850: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1d7854: 0x4402c000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[24]);
    // 0x1d7858: 0x27a30040
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d785c: 0x249653e0
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 4), 21472));
    // 0x1d7860: 0xafa50118
    WRITE32(ADD32(GPR_U32(ctx, 29), 280), GPR_U32(ctx, 5));
    // 0x1d7864: 0x27a40090
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1d7868: 0x7fa20130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 2));
    // 0x1d786c: 0x27a500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1d7870: 0xafa30114
    WRITE32(ADD32(GPR_U32(ctx, 29), 276), GPR_U32(ctx, 3));
    // 0x1d7874: 0x27a20080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1d7878: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1d787c: 0x27a300d0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1d7880: 0xafa40124
    WRITE32(ADD32(GPR_U32(ctx, 29), 292), GPR_U32(ctx, 4));
    // 0x1d7884: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d7888: 0xafa50128
    WRITE32(ADD32(GPR_U32(ctx, 29), 296), GPR_U32(ctx, 5));
    // 0x1d788c: 0x4600ad86
    ctx->f[22] = FPU_MOV_S(ctx->f[21]);
    // 0x1d7890: 0xafa20120
    WRITE32(ADD32(GPR_U32(ctx, 29), 288), GPR_U32(ctx, 2));
    // 0x1d7894: 0x265500d0
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 18), 208));
    // 0x1d7898: 0xafa3012c
    WRITE32(ADD32(GPR_U32(ctx, 29), 300), GPR_U32(ctx, 3));
    // 0x1d789c: 0x27b40010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d78a0: 0x24020060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 96));
    // 0x1d78a4: 0x0
    // NOP
label_1d78a8:
    // 0x1d78a8: 0x8e4406a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1696)));
    // 0x1d78ac: 0x2621018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1d78b0: 0x244206b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1712));
    // 0x1d78b4: 0x2428021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1d78b8: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1d78bc: 0x546400d8
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        ctx->pc = 0x1D7C20; return;
    }
    // 0x1d78c4: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1d78c8: 0x2a710002
    SET_GPR_U32(ctx, 17, SLT32(GPR_S32(ctx, 19), 2));
    // 0x1d78cc: 0x78620040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1d78d0: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1d78d4: 0x12200003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1d78e4;
    }
    // 0x1d78dc: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1552)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d78e8;
    }
label_1d78e4:
    // 0x1d78e4: 0xc6400614
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1556)); ctx->f[0] = *(float*)&val; }
label_1d78e8:
    // 0x1d78e8: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1d78ec: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x1d78f0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d78f4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d78f8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d78fc: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d7904);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d7904
// Address: 0x1d7904 - 0x1d7940

void entry_1d7904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d7904) {
        switch (ctx->pc) {
            case 0x1d7920: ctx->pc = 0; goto label_1d7920;
            case 0x1d7924: ctx->pc = 0; goto label_1d7924;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d7904: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d7908: 0x78620190
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 400)));
    // 0x1d790c: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x1d7910: 0x12200003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1d7920;
    }
    // 0x1d7918: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1552)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d7924;
    }
label_1d7920:
    // 0x1d7920: 0xc6400614
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1556)); ctx->f[0] = *(float*)&val; }
label_1d7924:
    // 0x1d7924: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1d7928: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x1d792c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d7930: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d7934: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d7938: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d7940);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d7940
// Address: 0x1d7940 - 0x1d79a8

void entry_1d7940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7940: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d7944: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d7948: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d794c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d7950: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d7954: 0x26060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 32));
    // 0x1d7958: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d795c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d7960: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d7964: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7968: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d796c: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d7970: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d7974: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d7978: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d797c: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d7980: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1d7984: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d7988: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d798c: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1d7990: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x1d7994: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d7998: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d799c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d79a0: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1d79a8);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1d79a8
// Address: 0x1d79a8 - 0x1d7be0

void entry_1d79a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d79a8) {
        switch (ctx->pc) {
            case 0x1d7a3c: ctx->pc = 0; goto label_1d7a3c;
            case 0x1d7a4c: ctx->pc = 0; goto label_1d7a4c;
            case 0x1d7aa8: ctx->pc = 0; goto label_1d7aa8;
            case 0x1d7abc: ctx->pc = 0; goto label_1d7abc;
            case 0x1d7ac0: ctx->pc = 0; goto label_1d7ac0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d79a8: 0xda020030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1d79ac: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d79b0: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d79b4: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1d79b8: 0x4bc208ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d79bc: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d79c0: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d79c4: 0x4b0320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d79c8: 0xc46453c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 21440)); ctx->f[4] = *(float*)&val; }
    // 0x1d79cc: 0x4be310d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d79d0: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1d79d4: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d79d8: 0x24a553b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 21424));
    // 0x1d79dc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d79e0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d79e4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d79e8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d79ec: 0xc4a20008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1d79f0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d79f4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d79f8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d79fc: 0xc4a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d7a00: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d7a04: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d7a08: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d7a0c: 0xc44353b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21424)); ctx->f[3] = *(float*)&val; }
    // 0x1d7a10: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1d7a14: 0x248453c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 21440));
    // 0x1d7a18: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1d7a1c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d7a20: 0x46001880
    ctx->f[2] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1d7a24: 0x46041034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7a28: 0x0
    // NOP
    // 0x1d7a2c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d7a3c;
    }
    // 0x1d7a34: 0x10000005
    ctx->f[2] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d7a4c;
    }
label_1d7a3c:
    // 0x1d7a3c: 0x46022834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7a40: 0x0
    // NOP
    // 0x1d7a44: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_MOV_S(ctx->f[5]);
        goto label_1d7a4c;
    }
label_1d7a4c:
    // 0x1d7a4c: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d7a50: 0x46181082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[24]);
    // 0x1d7a54: 0xda030020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1d7a58: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d7a5c: 0x4be218ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d7a60: 0x4bc118ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d7a64: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d7a68: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d7a6c: 0x4b0310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7a70: 0xc600005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 92)); ctx->f[0] = *(float*)&val; }
    // 0x1d7a74: 0x48241800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d7a78: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d7a7c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1d7a80: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1d7a84: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1d7a88: 0x46140843
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[20];
    // 0x1d7a8c: 0x46160834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7a90: 0x0
    // NOP
    // 0x1d7a94: 0x45000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 92), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d7aa8;
    }
    // 0x1d7a9c: 0x44803000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 0);
    // 0x1d7aa0: 0x10000007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 8)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d7ac0;
    }
label_1d7aa8:
    // 0x1d7aa8: 0x46011834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7aac: 0x0
    // NOP
    // 0x1d7ab0: 0x45000002
    ctx->f[6] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d7abc;
    }
    // 0x1d7ab8: 0x46001986
    ctx->f[6] = FPU_MOV_S(ctx->f[3]);
label_1d7abc:
    // 0x1d7abc: 0xc6e00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 8)); ctx->f[0] = *(float*)&val; }
label_1d7ac0:
    // 0x1d7ac0: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1d7ac4: 0xc6c10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d7ac8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d7acc: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x1d7ad0: 0xc6e20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1d7ad4: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x1d7ad8: 0xc6c30004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 4)); ctx->f[3] = *(float*)&val; }
    // 0x1d7adc: 0xc4a553d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 21456)); ctx->f[5] = *(float*)&val; }
    // 0x1d7ae0: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d7ae4: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1d7ae8: 0xc48453e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 21472)); ctx->f[4] = *(float*)&val; }
    // 0x1d7aec: 0x460118c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x1d7af0: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d7af4: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d7af8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d7afc: 0x46023082
    ctx->f[2] = FPU_MUL_S(ctx->f[6], ctx->f[2]);
    // 0x1d7b00: 0xda040040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1d7b04: 0x460330c2
    ctx->f[3] = FPU_MUL_S(ctx->f[6], ctx->f[3]);
    // 0x1d7b08: 0xda030020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1d7b0c: 0x4be2212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1d7b10: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d7b14: 0xdba60020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d7b18: 0x46022940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[2]);
    // 0x1d7b1c: 0x46032100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[3]);
    // 0x1d7b20: 0x4bc6212a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1d7b24: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d7b28: 0x4b04203d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1d7b2c: 0x4b04090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7b30: 0x4bc618ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d7b34: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d7b38: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d7b3c: 0x4b0310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7b40: 0x48252000
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d7b44: 0x48241800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d7b48: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x1d7b4c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1d7b50: 0x46050842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[5]);
    // 0x1d7b54: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x1d7b58: 0xc46253c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 21448)); ctx->f[2] = *(float*)&val; }
    // 0x1d7b5c: 0xc44353cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21452)); ctx->f[3] = *(float*)&val; }
    // 0x1d7b60: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1d7b64: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1d7b68: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1d7b6c: 0x46160834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7b70: 0x0
    // NOP
    // 0x1d7b74: 0x4503002a
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        ctx->pc = 0x1D7C20; return;
    }
    // 0x1d7b7c: 0xc6400368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 872)); ctx->f[0] = *(float*)&val; }
    // 0x1d7b80: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1d7b84: 0xda410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1d7b88: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d7b8c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1d7b90: 0xda030020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1d7b94: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x1d7b98: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d7b9c: 0x48a52800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x1d7ba0: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1d7ba4: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d7ba8: 0x8fa50118
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 280)));
    // 0x1d7bac: 0x4be23118
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1d7bb0: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d7bb4: 0x4a6503bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1d7bb8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d7bbc: 0x4be0205c
    ctx->vu0_vf[4] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1d7bc0: 0x4bc41afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[4] = READ32(addr); }
    // 0x1d7bc4: 0x4bc320ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7bc8: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d7bcc: 0xfba30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d7bd0: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d7bd4: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d7bd8: 0xc06e3fa
    SET_GPR_U32(ctx, 31, 0x1d7be0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[5]));
    CalculateSoAngularEffectWorld__FP2SOP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_1d7be0
// Address: 0x1d7be0 - 0x1d7bec

void entry_1d7be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7be0: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1d7be4: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1d7bec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d7bec
// Address: 0x1d7bec - 0x1d7bf8

void entry_1d7bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7bec: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d7bf0: 0xc06e6b2
    SET_GPR_U32(ctx, 31, 0x1d7bf8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    AddSoAngularAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d7bf8
// Address: 0x1d7bf8 - 0x1d7cc4

void entry_1d7bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d7bf8) {
        switch (ctx->pc) {
            case 0x1d7c20: ctx->pc = 0; goto label_1d7c20;
            case 0x1d7ca4: ctx->pc = 0; goto label_1d7ca4;
            case 0x1d7cb4: ctx->pc = 0; goto label_1d7cb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d7bf8: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d7bfc: 0xda4100f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 240)));
    // 0x1d7c00: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d7c04: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d7c08: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d7c0c: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7c10: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d7c14: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d7c18: 0x4600ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    // 0x1d7c1c: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_1d7c20:
    // 0x1d7c20: 0x2e620004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 4));
    // 0x1d7c24: 0x1440ff20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 96));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D78A8; return;
    }
    // 0x1d7c2c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d7c30: 0x4600a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7c34: 0x0
    // NOP
    // 0x1d7c38: 0x45000034
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1d7d0c(rdram, ctx, runtime); return;
    }
    // 0x1d7c40: 0xc641086c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2156)); ctx->f[1] = *(float*)&val; }
    // 0x1d7c44: 0x24831858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 6232));
    // 0x1d7c48: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d7c4c: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d7c50: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1d7c54: 0xc4445394
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21396)); ctx->f[4] = *(float*)&val; }
    // 0x1d7c58: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d7c5c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1d7c60: 0x246253f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 21488));
    // 0x1d7c64: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1d7c68: 0x24a45c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 23648));
    // 0x1d7c6c: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d7c70: 0x46040003
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[4];
    // 0x1d7c74: 0xc46353f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 21488)); ctx->f[3] = *(float*)&val; }
    // 0x1d7c78: 0xc4a45c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1d7c7c: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1d7c80: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1d7c84: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d7c88: 0x46001b00
    ctx->f[12] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1d7c8c: 0x46046034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7c90: 0x0
    // NOP
    // 0x1d7c94: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d7ca4;
    }
    // 0x1d7c9c: 0x10000005
    ctx->f[12] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d7cb4;
    }
label_1d7ca4:
    // 0x1d7ca4: 0x460c2834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7ca8: 0x0
    // NOP
    // 0x1d7cac: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[5]);
        goto label_1d7cb4;
    }
label_1d7cb4:
    // 0x1d7cb4: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1d7cb8: 0x27a400f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 240));
    // 0x1d7cbc: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1d7cc4);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 21504));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1d7cc4
// Address: 0x1d7cc4 - 0x1d7cd4

void entry_1d7cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7cc4: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1d7cc8: 0x27a40100
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 256));
    // 0x1d7ccc: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1d7cd4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d7cd4
// Address: 0x1d7cd4 - 0x1d7ce0

void entry_1d7cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7cd4: 0x7ba50100
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1d7cd8: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1d7ce0);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d7ce0
// Address: 0x1d7ce0 - 0x1d7cec

void entry_1d7ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7ce0: 0x70022ca9
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1d7ce4: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1d7cec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d7cec
// Address: 0x1d7cec - 0x1d7d0c

void entry_1d7cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7cec: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x1d7cf0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d7cf4: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x1d7cf8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d7cfc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d7d00: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d7d04: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x1d7d0c);
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_1d7d0c
// Address: 0x1d7d0c - 0x1d7fd4

void entry_1d7d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d7d0c) {
        switch (ctx->pc) {
            case 0x1d7d40: ctx->pc = 0; goto label_1d7d40;
            case 0x1d7d50: ctx->pc = 0; goto label_1d7d50;
            case 0x1d7d64: ctx->pc = 0; goto label_1d7d64;
            case 0x1d7d68: ctx->pc = 0; goto label_1d7d68;
            case 0x1d7dec: ctx->pc = 0; goto label_1d7dec;
            case 0x1d7dfc: ctx->pc = 0; goto label_1d7dfc;
            case 0x1d7e20: ctx->pc = 0; goto label_1d7e20;
            case 0x1d7eac: ctx->pc = 0; goto label_1d7eac;
            case 0x1d7ec0: ctx->pc = 0; goto label_1d7ec0;
            case 0x1d7f1c: ctx->pc = 0; goto label_1d7f1c;
            case 0x1d7f2c: ctx->pc = 0; goto label_1d7f2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d7d0c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d7d10: 0xc6400368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 872)); ctx->f[0] = *(float*)&val; }
    // 0x1d7d14: 0xc4415410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21520)); ctx->f[1] = *(float*)&val; }
    // 0x1d7d18: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1d7d1c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d7d20: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d7d24: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d7d28: 0x4600a803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[0] = ctx->f[21] / ctx->f[0];
    // 0x1d7d2c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7d30: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d7d40;
    }
    // 0x1d7d38: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d7d50;
    }
label_1d7d40:
    // 0x1d7d40: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7d44: 0x0
    // NOP
    // 0x1d7d48: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[1]);
        goto label_1d7d50;
    }
label_1d7d50:
    // 0x1d7d50: 0x8e420afc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2812)));
    // 0x1d7d54: 0x10400003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 2972), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d7d64;
    }
    // 0x1d7d5c: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[2] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d7d68;
    }
label_1d7d64:
    // 0x1d7d64: 0xc6420868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2152)); ctx->f[2] = *(float*)&val; }
label_1d7d68:
    // 0x1d7d68: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1d7d6c: 0xc6410854
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2132)); ctx->f[1] = *(float*)&val; }
    // 0x1d7d70: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1d7d74: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d7d78: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d7d7c: 0x24835200
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 20992));
    // 0x1d7d80: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d7d84: 0xc4640008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[4] = *(float*)&val; }
    // 0x1d7d88: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1d7d8c: 0xc44551d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20952)); ctx->f[5] = *(float*)&val; }
    // 0x1d7d90: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d7d94: 0x46151082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[21]);
    // 0x1d7d98: 0xc6430368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 872)); ctx->f[3] = *(float*)&val; }
    // 0x1d7d9c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d7da0: 0x460505c3
    if (ctx->f[5] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[23] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[23] = ctx->f[0] / ctx->f[5];
    // 0x1d7da4: 0xc4465200
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20992)); ctx->f[6] = *(float*)&val; }
    // 0x1d7da8: 0x46031083
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[3];
    // 0x1d7dac: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1d7db0: 0xc4a35210
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 21008)); ctx->f[3] = *(float*)&val; }
    // 0x1d7db4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d7db8: 0xc4405414
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21524)); ctx->f[0] = *(float*)&val; }
    // 0x1d7dbc: 0x24a45210
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 21008));
    // 0x1d7dc0: 0xc4850004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    // 0x1d7dc4: 0x4604b902
    ctx->f[4] = FPU_MUL_S(ctx->f[23], ctx->f[4]);
    // 0x1d7dc8: 0x46040840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[4]);
    // 0x1d7dcc: 0x4601b842
    ctx->f[1] = FPU_MUL_S(ctx->f[23], ctx->f[1]);
    // 0x1d7dd0: 0x46013180
    ctx->f[6] = FPU_ADD_S(ctx->f[6], ctx->f[1]);
    // 0x1d7dd4: 0x46033034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7dd8: 0x0
    // NOP
    // 0x1d7ddc: 0x45000003
    ctx->f[22] = std::min(ctx->f[0], ctx->f[2]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d7dec;
    }
    // 0x1d7de4: 0x10000005
    ctx->f[6] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d7dfc;
    }
label_1d7dec:
    // 0x1d7dec: 0x46062834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[6])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7df0: 0x0
    // NOP
    // 0x1d7df4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[6] = FPU_MOV_S(ctx->f[5]);
        goto label_1d7dfc;
    }
label_1d7dfc:
    // 0x1d7dfc: 0xc640085c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2140)); ctx->f[0] = *(float*)&val; }
    // 0x1d7e00: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d7e04: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1d7e08: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7e0c: 0x0
    // NOP
    // 0x1d7e10: 0x45000003
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 368)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d7e20;
    }
    // 0x1d7e18: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x1d7e1c: 0x46003182
    ctx->f[6] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
label_1d7e20:
    // 0x1d7e20: 0x4606b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[6]);
    // 0x1d7e24: 0xda440150
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1d7e28: 0xdba20130
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1d7e2c: 0xc6410698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1688)); ctx->f[1] = *(float*)&val; }
    // 0x1d7e30: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1d7e34: 0x4be20908
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7e38: 0xc6400618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1560)); ctx->f[0] = *(float*)&val; }
    // 0x1d7e3c: 0x7ba20130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1d7e40: 0xda4300d0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
    // 0x1d7e44: 0x46000883
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[2] = ctx->f[1] / ctx->f[0];
    // 0x1d7e48: 0xdaa20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 16)));
    // 0x1d7e4c: 0xdaa10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 32)));
    // 0x1d7e50: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x1d7e54: 0x4be41a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d7e58: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x1d7e5c: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d7e60: 0x4be409aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d7e64: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1d7e68: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7e6c: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1d7e70: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7e74: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1d7e78: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7e7c: 0xfba50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1d7e80: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d7e84: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1d7e88: 0x8e4206b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1712)));
    // 0x1d7e8c: 0x46031034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7e90: 0x8e430770
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1904)));
    // 0x1d7e94: 0xc4410190
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 400)); ctx->f[1] = *(float*)&val; }
    // 0x1d7e98: 0xc4600190
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 400)); ctx->f[0] = *(float*)&val; }
    // 0x1d7e9c: 0x45000003
    ctx->f[8] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d7eac;
    }
    // 0x1d7ea4: 0x10000006
    ctx->f[6] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d7ec0;
    }
label_1d7eac:
    // 0x1d7eac: 0x46022034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7eb0: 0x0
    // NOP
    // 0x1d7eb4: 0x45000002
    ctx->f[6] = FPU_MOV_S(ctx->f[2]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d7ec0;
    }
    // 0x1d7ebc: 0x46002186
    ctx->f[6] = FPU_MOV_S(ctx->f[4]);
label_1d7ec0:
    // 0x1d7ec0: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1d7ec4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d7ec8: 0xc6430618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1560)); ctx->f[3] = *(float*)&val; }
    // 0x1d7ecc: 0x24625420
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 21536));
    // 0x1d7ed0: 0x460001c6
    ctx->f[7] = FPU_MOV_S(ctx->f[0]);
    // 0x1d7ed4: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1d7ed8: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x1d7edc: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d7ee0: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1d7ee4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d7ee8: 0xc4a35420
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 21536)); ctx->f[3] = *(float*)&val; }
    // 0x1d7eec: 0x24835c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x1d7ef0: 0xc4845c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1d7ef4: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1d7ef8: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1d7efc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d7f00: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1d7f04: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7f08: 0x0
    // NOP
    // 0x1d7f0c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d7f1c;
    }
    // 0x1d7f14: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d7f2c;
    }
label_1d7f1c:
    // 0x1d7f1c: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d7f20: 0x0
    // NOP
    // 0x1d7f24: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_1d7f2c;
    }
label_1d7f2c:
    // 0x1d7f2c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d7f30: 0xc642069c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1692)); ctx->f[2] = *(float*)&val; }
    // 0x1d7f34: 0xc44c541c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21532)); ctx->f[12] = *(float*)&val; }
    // 0x1d7f38: 0x46033182
    ctx->f[6] = FPU_MUL_S(ctx->f[6], ctx->f[3]);
    // 0x1d7f3c: 0xda440160
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x1d7f40: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d7f44: 0xda4300d0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
    // 0x1d7f48: 0x460c3b29
    ctx->f[12] = std::min(ctx->f[7], ctx->f[12]);
    // 0x1d7f4c: 0xdaa20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 16)));
    // 0x1d7f50: 0x46026302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[2]);
    // 0x1d7f54: 0xdaa10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 32)));
    // 0x1d7f58: 0x46023082
    ctx->f[2] = FPU_MUL_S(ctx->f[6], ctx->f[2]);
    // 0x1d7f5c: 0x4be41a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d7f60: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x1d7f64: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d7f68: 0x4be409aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d7f6c: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1d7f70: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7f74: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1d7f78: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7f7c: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1d7f80: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d7f84: 0x8e4306b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1712)));
    // 0x1d7f88: 0xfba50020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1d7f8c: 0x46086303
    if (ctx->f[8] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[8];
    // 0x1d7f90: 0xc4415418
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21528)); ctx->f[1] = *(float*)&val; }
    // 0x1d7f94: 0xc4600190
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 400)); ctx->f[0] = *(float*)&val; }
    // 0x1d7f98: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1d7f9c: 0xc6540368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 872)); ctx->f[20] = *(float*)&val; }
    // 0x1d7fa0: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1d7fa4: 0xc6440318
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 792)); ctx->f[4] = *(float*)&val; }
    // 0x1d7fa8: 0x46026300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[2]);
    // 0x1d7fac: 0xc7a30028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[3] = *(float*)&val; }
    // 0x1d7fb0: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1d7fb4: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1d7fb8: 0x46036301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[3]);
    // 0x1d7fbc: 0xe7a10030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    // 0x1d7fc0: 0xe7a10034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 52), *(uint32_t*)&val); }
    // 0x1d7fc4: 0x4604a503
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[20] = ctx->f[20] / ctx->f[4];
    // 0x1d7fc8: 0x46186303
    if (ctx->f[24] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[24];
    // 0x1d7fcc: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x1d7fd4);
    ctx->f[13] = FPU_MUL_S(ctx->f[20], ctx->f[22]);
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d7fd4
// Address: 0x1d7fd4 - 0x1d8010

void entry_1d7fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d7fd4: 0x46140503
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[20] = ctx->f[0] / ctx->f[20];
    // 0x1d7fd8: 0xda4400d0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
    // 0x1d7fdc: 0xe7a00038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    // 0x1d7fe0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d7fe4: 0x8fa50114
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 276)));
    // 0x1d7fe8: 0xdaa30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 16)));
    // 0x1d7fec: 0xdaa20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 32)));
    // 0x1d7ff0: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d7ff4: 0x4600a505
    ctx->f[20] = FPU_ABS_S(ctx->f[20]);
    // 0x1d7ff8: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d7ffc: 0x4bc118bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d8000: 0x4bc1104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d8004: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d8008: 0xc06e6b2
    SET_GPR_U32(ctx, 31, 0x1d8010);
    ctx->f[22] = FPU_SUB_S(ctx->f[22], ctx->f[20]);
    AddSoAngularAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d8010
// Address: 0x1d8010 - 0x1d80a4

void entry_1d8010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d8010) {
        switch (ctx->pc) {
            case 0x1d8060: ctx->pc = 0; goto label_1d8060;
            case 0x1d8070: ctx->pc = 0; goto label_1d8070;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d8010: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d8014: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d8018: 0xc44451f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20976)); ctx->f[4] = *(float*)&val; }
    // 0x1d801c: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1d8020: 0x246251e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 20960));
    // 0x1d8024: 0xc4a251e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 20960)); ctx->f[2] = *(float*)&val; }
    // 0x1d8028: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d802c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d8030: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d8034: 0x248351f0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 20976));
    // 0x1d8038: 0x4601b842
    ctx->f[1] = FPU_MUL_S(ctx->f[23], ctx->f[1]);
    // 0x1d803c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d8040: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x1d8044: 0x46001040
    ctx->f[1] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1d8048: 0x46040834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d804c: 0x0
    // NOP
    // 0x1d8050: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d8060;
    }
    // 0x1d8058: 0x10000005
    ctx->f[1] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d8070;
    }
label_1d8060:
    // 0x1d8060: 0x46011834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8064: 0x0
    // NOP
    // 0x1d8068: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[3]);
        goto label_1d8070;
    }
label_1d8070:
    // 0x1d8070: 0xc642085c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2140)); ctx->f[2] = *(float*)&val; }
    // 0x1d8074: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d8078: 0x246251f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 20976));
    // 0x1d807c: 0x8fa40118
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 280)));
    // 0x1d8080: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1d8084: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d8088: 0xc64c0694
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1684)); ctx->f[12] = *(float*)&val; }
    // 0x1d808c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d8090: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d8094: 0x46010029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[1]);
    // 0x1d8098: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x1d809c: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1d80a4);
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[21] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[21] = ctx->f[0] / ctx->f[2];
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1d80a4
// Address: 0x1d80a4 - 0x1d8150

void entry_1d80a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d80a4) {
        switch (ctx->pc) {
            case 0x1d810c: ctx->pc = 0; goto label_1d810c;
            case 0x1d8120: ctx->pc = 0; goto label_1d8120;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d80a4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d80a8: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1d80ac: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d80b0: 0x24a25430
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 21552));
    // 0x1d80b4: 0xda4100d0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
    // 0x1d80b8: 0x24835440
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 21568));
    // 0x1d80bc: 0xc4855440
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 21568)); ctx->f[5] = *(float*)&val; }
    // 0x1d80c0: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d80c4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d80c8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d80cc: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d80d0: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1d80d4: 0x48241000
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d80d8: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1d80dc: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d80e0: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1d80e4: 0xc4a35430
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 21552)); ctx->f[3] = *(float*)&val; }
    // 0x1d80e8: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1d80ec: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1d80f0: 0x460118c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x1d80f4: 0x46051834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d80f8: 0x0
    // NOP
    // 0x1d80fc: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d810c;
    }
    // 0x1d8104: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d8120;
    }
label_1d810c:
    // 0x1d810c: 0x46032034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8110: 0x0
    // NOP
    // 0x1d8114: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d8120;
    }
    // 0x1d811c: 0x46002506
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
label_1d8120:
    // 0x1d8120: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1d8124: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d8128: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1d812c: 0xc7a00038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[0] = *(float*)&val; }
    // 0x1d8130: 0x24848d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    // 0x1d8134: 0x4601c042
    ctx->f[1] = FPU_MUL_S(ctx->f[24], ctx->f[1]);
    // 0x1d8138: 0xc7ac0028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[12] = *(float*)&val; }
    // 0x1d813c: 0x8fa50124
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 292)));
    // 0x1d8140: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d8144: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x1d8148: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1d8150);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[24]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1d8150
// Address: 0x1d8150 - 0x1d8254

void entry_1d8150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d8150) {
        switch (ctx->pc) {
            case 0x1d8174: ctx->pc = 0; goto label_1d8174;
            case 0x1d817c: ctx->pc = 0; goto label_1d817c;
            case 0x1d8204: ctx->pc = 0; goto label_1d8204;
            case 0x1d8218: ctx->pc = 0; goto label_1d8218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d8150: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d8154: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d8158: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d815c: 0x0
    // NOP
    // 0x1d8160: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[20]);
        goto label_1d8174;
    }
    // 0x1d8168: 0xc6400618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1560)); ctx->f[0] = *(float*)&val; }
    // 0x1d816c: 0x10000003
    ctx->f[4] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d817c;
    }
label_1d8174:
    // 0x1d8174: 0xc6400698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1688)); ctx->f[0] = *(float*)&val; }
    // 0x1d8178: 0x46000902
    ctx->f[4] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
label_1d817c:
    // 0x1d817c: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1d8180: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d8184: 0x24a25220
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 21024));
    // 0x1d8188: 0x24835230
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 21040));
    // 0x1d818c: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d8190: 0xc4420004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1d8194: 0x4601b842
    ctx->f[1] = FPU_MUL_S(ctx->f[23], ctx->f[1]);
    // 0x1d8198: 0xc4855230
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 21040)); ctx->f[5] = *(float*)&val; }
    // 0x1d819c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d81a0: 0xc4a35220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 21024)); ctx->f[3] = *(float*)&val; }
    // 0x1d81a4: 0x44022000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[4]);
    // 0x1d81a8: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1d81ac: 0x70821488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 4), GPR_VEC(ctx, 2)));
    // 0x1d81b0: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1d81b4: 0x70821389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 4), GPR_VEC(ctx, 2)));
    // 0x1d81b8: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1d81bc: 0xdba20090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d81c0: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d81c4: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d81c8: 0xdba300a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d81cc: 0x4602b882
    ctx->f[2] = FPU_MUL_S(ctx->f[23], ctx->f[2]);
    // 0x1d81d0: 0xdba100b0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d81d4: 0x4bc411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1d81d8: 0x4bc418bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1d81dc: 0x4bc4088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d81e0: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x1d81e4: 0xfba20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d81e8: 0x46021800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1d81ec: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d81f0: 0x0
    // NOP
    // 0x1d81f4: 0x45000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 2));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d8204;
    }
    // 0x1d81fc: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d8218;
    }
label_1d8204:
    // 0x1d8204: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8208: 0x0
    // NOP
    // 0x1d820c: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d8218;
    }
    // 0x1d8214: 0x46000d06
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
label_1d8218:
    // 0x1d8218: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d821c: 0x4614b328
    ctx->f[12] = std::max(ctx->f[22], ctx->f[20]);
    // 0x1d8220: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d8224: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d8228: 0x8fa4011c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 284)));
    // 0x1d822c: 0xdba20130
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1d8230: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d8234: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d8238: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1d823c: 0x8fa50128
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    // 0x1d8240: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d8244: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d8248: 0xafa00078
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 0));
    // 0x1d824c: 0xc07b8ac
    SET_GPR_U32(ctx, 31, 0x1d8254);
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 2));
    LimitVectorLength(rdram, ctx, runtime); return;
}


// Function: entry_1d8254
// Address: 0x1d8254 - 0x1d829c

void entry_1d8254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8254: 0xc64d0698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1688)); ctx->f[13] = *(float*)&val; }
    // 0x1d8258: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d825c: 0x46006832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[13], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8260: 0x0
    // NOP
    // 0x1d8264: 0x4503001d
    if ((ctx->fcr31 & 0x800000)) {
        ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
        ctx->pc = 0x1D82DC; return;
    }
    // 0x1d826c: 0x8e420b30
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2864)));
    // 0x1d8270: 0x5440001a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
        ctx->pc = 0x1D82DC; return;
    }
    // 0x1d8278: 0xc7ac0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    // 0x1d827c: 0x460d6034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8280: 0x0
    // NOP
    // 0x1d8284: 0x4500000b
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D82B4; return;
    }
    // 0x1d828c: 0x4600c386
    ctx->f[14] = FPU_MOV_S(ctx->f[24]);
    // 0x1d8290: 0x24845448
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 21576));
    // 0x1d8294: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d829c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 272));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d829c
// Address: 0x1d829c - 0x1d82c8

void entry_1d829c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d829c) {
        switch (ctx->pc) {
            case 0x1d82b4: ctx->pc = 0; goto label_1d82b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d829c: 0xc7a10110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[1] = *(float*)&val; }
    // 0x1d82a0: 0xc7a000c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[0] = *(float*)&val; }
    // 0x1d82a4: 0x46140868
    ctx->f[1] = std::max(ctx->f[1], ctx->f[20]);
    // 0x1d82a8: 0x46000869
    ctx->f[1] = std::min(ctx->f[1], ctx->f[0]);
    // 0x1d82ac: 0x1000000a
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 192), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D82D8; return;
    }
label_1d82b4:
    // 0x1d82b4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d82b8: 0x4600c386
    ctx->f[14] = FPU_MOV_S(ctx->f[24]);
    // 0x1d82bc: 0x24845458
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 21592));
    // 0x1d82c0: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d82c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 272));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d82c8
// Address: 0x1d82c8 - 0x1d8308

void entry_1d82c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d82c8) {
        switch (ctx->pc) {
            case 0x1d82d8: ctx->pc = 0; goto label_1d82d8;
            case 0x1d82dc: ctx->pc = 0; goto label_1d82dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d82c8: 0xc7a100c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[1] = *(float*)&val; }
    // 0x1d82cc: 0xc7a00110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[0] = *(float*)&val; }
    // 0x1d82d0: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1d82d4: 0xe7a000c0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 192), *(uint32_t*)&val); }
label_1d82d8:
    // 0x1d82d8: 0xda4300d0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
label_1d82dc:
    // 0x1d82dc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d82e0: 0xdaa40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 32)));
    // 0x1d82e4: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d82e8: 0xdaa10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 16)));
    // 0x1d82ec: 0xdba200c0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d82f0: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d82f4: 0x4bc208bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d82f8: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d82fc: 0x8fa50120
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1d8300: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1d8308);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d8308
// Address: 0x1d8308 - 0x1d841c

void entry_1d8308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d8308) {
        switch (ctx->pc) {
            case 0x1d8328: ctx->pc = 0; goto label_1d8328;
            case 0x1d8398: ctx->pc = 0; goto label_1d8398;
            case 0x1d83ac: ctx->pc = 0; goto label_1d83ac;
            case 0x1d83c4: ctx->pc = 0; goto label_1d83c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d8308: 0xdba30070
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d830c: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x1d8310: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1d8314: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d8318: 0x24e55470
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 7), 21616));
    // 0x1d831c: 0x24c95480
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 6), 21632));
    // 0x1d8320: 0x24481858
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1d8324: 0x264406b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 1712));
label_1d8328:
    // 0x1d8328: 0x8c83000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x1d832c: 0x8e4206a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1696)));
    // 0x1d8330: 0x54620024
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        goto label_1d83c4;
    }
    // 0x1d8338: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d833c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d8340: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d8344: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d8348: 0xc4a20008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1d834c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d8350: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d8354: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d8358: 0xc4a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d835c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d8360: 0xc4e35470
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 21616)); ctx->f[3] = *(float*)&val; }
    // 0x1d8364: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1d8368: 0xc4c45480
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 21632)); ctx->f[4] = *(float*)&val; }
    // 0x1d836c: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x1d8370: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1d8374: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1d8378: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d837c: 0x46001800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1d8380: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8384: 0x0
    // NOP
    // 0x1d8388: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d8398;
    }
    // 0x1d8390: 0x10000006
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d83ac;
    }
label_1d8398:
    // 0x1d8398: 0x46002834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d839c: 0x0
    // NOP
    // 0x1d83a0: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d83ac;
    }
    // 0x1d83a8: 0x460028c6
    ctx->f[3] = FPU_MOV_S(ctx->f[5]);
label_1d83ac:
    // 0x1d83ac: 0xc5000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1d83b0: 0xc4810058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 88)); ctx->f[1] = *(float*)&val; }
    // 0x1d83b4: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1d83b8: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1d83bc: 0xe4810058
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 88), *(uint32_t*)&val); }
    // 0x1d83c0: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_1d83c4:
    // 0x1d83c4: 0x2e620004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 4));
    // 0x1d83c8: 0x1440ffd7
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 96));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1d8328;
    }
    // 0x1d83d0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d83d4: 0x8e440368
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 872)));
    // 0x1d83d8: 0x8c425488
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 21640)));
    // 0x1d83dc: 0x48a42000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1d83e0: 0xda4200f0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 240)));
    // 0x1d83e4: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d83e8: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d83ec: 0x4be31098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d83f0: 0x4be40858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d83f4: 0x8fa5012c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 300)));
    // 0x1d83f8: 0xfba300e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d83fc: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x1d8400: 0x4bc208ae
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d8404: 0x4a2210ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d8408: 0x8fa60114
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 276)));
    // 0x1d840c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d8410: 0xfba200d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d8414: 0xc06e3fa
    SET_GPR_U32(ctx, 31, 0x1d841c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    CalculateSoAngularEffectWorld__FP2SOP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_1d841c
// Address: 0x1d841c - 0x1d8428

void entry_1d841c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d841c: 0x8fa50114
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 276)));
    // 0x1d8420: 0xc06e6b2
    SET_GPR_U32(ctx, 31, 0x1d8428);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AddSoAngularAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1d8428
// Address: 0x1d8428 - 0x1d8470

void entry_1d8428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8428: 0x7bbf01d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x1d842c: 0x7bbe01c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1d8430: 0x7bb701b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1d8434: 0x7bb601a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1d8438: 0x7bb50190
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1d843c: 0x7bb40180
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1d8440: 0x7bb30170
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1d8444: 0x7bb20160
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1d8448: 0x7bb10150
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1d844c: 0x7bb00140
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1d8450: 0xc7b80200
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 512)); ctx->f[24] = *(float*)&val; }
    // 0x1d8454: 0xc7b701f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 504)); ctx->f[23] = *(float*)&val; }
    // 0x1d8458: 0xc7b601f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 496)); ctx->f[22] = *(float*)&val; }
    // 0x1d845c: 0xc7b501e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 488)); ctx->f[21] = *(float*)&val; }
    // 0x1d8460: 0xc7b401e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 480)); ctx->f[20] = *(float*)&val; }
    // 0x1d8464: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 528));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d846c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d8470; return;
}


// Function: GExcludeAlm__FiP2LMf
// Address: 0x1d8470 - 0x1d84a8

void entry_1d84a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d84a8) {
        switch (ctx->pc) {
            case 0x1d84b8: ctx->pc = 0; goto label_1d84b8;
            case 0x1d84d0: ctx->pc = 0; goto label_1d84d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d84a8: 0x14400003
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1d84b8;
    }
    // 0x1d84b0: 0x10000025
    ctx->f[0] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D8548; return;
    }
label_1d84b8:
    // 0x1d84b8: 0xc457dc94
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294958228)); ctx->f[23] = *(float*)&val; }
    // 0x1d84bc: 0x1a200021
    ctx->f[21] = FPU_MOV_S(ctx->f[23]);
    if (GPR_S32(ctx, 17) <= 0) {
        ctx->pc = 0x1D8544; return;
    }
    // 0x1d84c4: 0x260802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1d84c8: 0x220902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d84cc: 0x0
    // NOP
label_1d84d0:
    // 0x1d84d0: 0xc60c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[12] = *(float*)&val; }
    // 0x1d84d4: 0x460cb001
    ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[12]);
    // 0x1d84d8: 0x46000505
    ctx->f[20] = FPU_ABS_S(ctx->f[0]);
    // 0x1d84dc: 0x4615a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d84e0: 0x0
    // NOP
    // 0x1d84e4: 0x45000007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D8504; return;
    }
    // 0x1d84ec: 0xc07ac20
    SET_GPR_U32(ctx, 31, 0x1d84f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FCheckAlm__FiP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_1d84f4
// Address: 0x1d84f4 - 0x1d8528

void entry_1d84f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d84f4) {
        switch (ctx->pc) {
            case 0x1d8504: ctx->pc = 0; goto label_1d8504;
            case 0x1d8508: ctx->pc = 0; goto label_1d8508;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d84f4: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
        goto label_1d8508;
    }
    // 0x1d84fc: 0xc6170000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[23] = *(float*)&val; }
    // 0x1d8500: 0x4600a546
    ctx->f[21] = FPU_MOV_S(ctx->f[20]);
label_1d8504:
    // 0x1d8504: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
label_1d8508:
    // 0x1d8508: 0x460cb001
    ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[12]);
    // 0x1d850c: 0x46000505
    ctx->f[20] = FPU_ABS_S(ctx->f[0]);
    // 0x1d8510: 0x4615a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8514: 0x0
    // NOP
    // 0x1d8518: 0x45000007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D8538; return;
    }
    // 0x1d8520: 0xc07ac20
    SET_GPR_U32(ctx, 31, 0x1d8528);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FCheckAlm__FiP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_1d8528
// Address: 0x1d8528 - 0x1d8578

void entry_1d8528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d8528) {
        switch (ctx->pc) {
            case 0x1d8538: ctx->pc = 0; goto label_1d8538;
            case 0x1d853c: ctx->pc = 0; goto label_1d853c;
            case 0x1d8544: ctx->pc = 0; goto label_1d8544;
            case 0x1d8548: ctx->pc = 0; goto label_1d8548;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d8528: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
        goto label_1d853c;
    }
    // 0x1d8530: 0xc6170004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[23] = *(float*)&val; }
    // 0x1d8534: 0x4600a546
    ctx->f[21] = FPU_MOV_S(ctx->f[20]);
label_1d8538:
    // 0x1d8538: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
label_1d853c:
    // 0x1d853c: 0x1640ffe4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D84D0; return;
    }
label_1d8544:
    // 0x1d8544: 0x4600b806
    ctx->f[0] = FPU_MOV_S(ctx->f[23]);
label_1d8548:
    // 0x1d8548: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d854c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d8550: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d8554: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d8558: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d855c: 0xc7b70068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[23] = *(float*)&val; }
    // 0x1d8560: 0xc7b60060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[22] = *(float*)&val; }
    // 0x1d8564: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x1d8568: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x1d856c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d8574: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d8578; return;
}


// Function: UpdateSuvBalance__FP3SUV
// Address: 0x1d8578 - 0x1d8594

void entry_1d8594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8594: 0x12220051
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D86DC; return;
    }
    // 0x1d859c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d85a0: 0x200902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d85a4: 0xc62c085c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 2140)); ctx->f[12] = *(float*)&val; }
    // 0x1d85a8: 0x26101858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6232));
    // 0x1d85ac: 0xc62d0860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 2144)); ctx->f[13] = *(float*)&val; }
    // 0x1d85b0: 0xc60e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1d85b4: 0x24845490
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 21648));
    // 0x1d85b8: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d85c0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d85c0
// Address: 0x1d85c0 - 0x1d86ac

void entry_1d85c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d85c0) {
        switch (ctx->pc) {
            case 0x1d8640: ctx->pc = 0; goto label_1d8640;
            case 0x1d867c: ctx->pc = 0; goto label_1d867c;
            case 0x1d868c: ctx->pc = 0; goto label_1d868c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d85c0: 0xe620085c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 2140), *(uint32_t*)&val); }
    // 0x1d85c4: 0xc6210864
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 2148)); ctx->f[1] = *(float*)&val; }
    // 0x1d85c8: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d85cc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d85d0: 0x0
    // NOP
    // 0x1d85d4: 0x45010042
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D86E0; return;
    }
    // 0x1d85dc: 0x8e230b00
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 2816)));
    // 0x1d85e0: 0x8e240af8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2808)));
    // 0x1d85e4: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1d85e8: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1d85ec: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1d85f0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d85f4: 0x8c85000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x1d85f8: 0x31040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 1));
    // 0x1d85fc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1d8600: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1d8604: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1d8608: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d860c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1d8610: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d8614: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1d8618: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d861c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8620: 0x0
    // NOP
    // 0x1d8624: 0x45010006
    ctx->f[4] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d8640;
    }
    // 0x1d862c: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8630: 0x0
    // NOP
    // 0x1d8634: 0x45000002
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d8640;
    }
    // 0x1d863c: 0x46001906
    ctx->f[4] = FPU_MOV_S(ctx->f[3]);
label_1d8640:
    // 0x1d8640: 0x26220670
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1648));
    // 0x1d8644: 0xc6220670
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1648)); ctx->f[2] = *(float*)&val; }
    // 0x1d8648: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d864c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d8650: 0x46012042
    ctx->f[1] = FPU_MUL_S(ctx->f[4], ctx->f[1]);
    // 0x1d8654: 0xc6230680
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1664)); ctx->f[3] = *(float*)&val; }
    // 0x1d8658: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d865c: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1d8660: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1d8664: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8668: 0x0
    // NOP
    // 0x1d866c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1668)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d867c;
    }
    // 0x1d8674: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d868c;
    }
label_1d867c:
    // 0x1d867c: 0x46002834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8680: 0x0
    // NOP
    // 0x1d8684: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[5]);
        goto label_1d868c;
    }
label_1d868c:
    // 0x1d868c: 0x3c01bd4c
    SET_GPR_U32(ctx, 1, ((uint32_t)48460 << 16));
    // 0x1d8690: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1d8694: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d8698: 0x3c013d4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15692 << 16));
    // 0x1d869c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1d86a0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d86a4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1d86ac);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 2144), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d86ac
// Address: 0x1d86ac - 0x1d86cc

void entry_1d86ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d86ac: 0xc6210860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 2144)); ctx->f[1] = *(float*)&val; }
    // 0x1d86b0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d86b4: 0x244354a0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 21664));
    // 0x1d86b8: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1d86bc: 0xe6210860
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 2144), *(uint32_t*)&val); }
    // 0x1d86c0: 0xc44c54a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21664)); ctx->f[12] = *(float*)&val; }
    // 0x1d86c4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1d86cc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d86cc
// Address: 0x1d86cc - 0x1d86f8

void entry_1d86cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d86cc) {
        switch (ctx->pc) {
            case 0x1d86dc: ctx->pc = 0; goto label_1d86dc;
            case 0x1d86e0: ctx->pc = 0; goto label_1d86e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d86cc: 0x26421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    // 0x1d86d0: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d86d4: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1d86d8: 0xe6210864
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 2148), *(uint32_t*)&val); }
label_1d86dc:
    // 0x1d86dc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1d86e0:
    // 0x1d86e0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d86e4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d86e8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d86ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d86f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d86f8; return;
}


// Function: DsGetTrackRelative__Ffff
// Address: 0x1d86f8 - 0x1d8740

void entry_1d87a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d87a4) {
        switch (ctx->pc) {
            case 0x1d87bc: ctx->pc = 0; goto label_1d87bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d87a4: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1d87a8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d87ac: 0x0
    // NOP
    // 0x1d87b0: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d87bc;
    }
    // 0x1d87b8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1d87bc:
    // 0x1d87bc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d87c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSuvLine__FP3SUVPi
// Address: 0x1d87c8 - 0x1d8828

void entry_1d8828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d8828) {
        switch (ctx->pc) {
            case 0x1d8860: ctx->pc = 0; goto label_1d8860;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d8828: 0x27a300f0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 240));
    // 0x1d882c: 0x27a40100
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 256));
    // 0x1d8830: 0xafa30134
    WRITE32(ADD32(GPR_U32(ctx, 29), 308), GPR_U32(ctx, 3));
    // 0x1d8834: 0x27be0040
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d8838: 0x27a30110
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 272));
    // 0x1d883c: 0xafa40138
    WRITE32(ADD32(GPR_U32(ctx, 29), 312), GPR_U32(ctx, 4));
    // 0x1d8840: 0x1840003d
    WRITE32(ADD32(GPR_U32(ctx, 29), 316), GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1D8938; return;
    }
    // 0x1d8848: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d884c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1d8850: 0x249654b0
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 4), 21680));
    // 0x1d8854: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d8858: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d885c: 0x3c0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
label_1d8860:
    // 0x1d8860: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d8864: 0x52110032
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 17)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
        ctx->pc = 0x1D8930; return;
    }
    // 0x1d886c: 0x8e030830
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2096)));
    // 0x1d8870: 0x8e220830
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2096)));
    // 0x1d8874: 0x5462002e
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
        ctx->pc = 0x1D8930; return;
    }
    // 0x1d887c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d8880: 0xc0761d0
    SET_GPR_U32(ctx, 31, 0x1d8888);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsSuvAheadOf__FP3SUVT0(rdram, ctx, runtime); return;
}


// Function: entry_1d8888
// Address: 0x1d8888 - 0x1d88a8

void entry_1d8888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8888: 0x54400029
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
        ctx->pc = 0x1D8930; return;
    }
    // 0x1d8890: 0xc600083c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2108)); ctx->f[0] = *(float*)&val; }
    // 0x1d8894: 0x26f70001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 1));
    // 0x1d8898: 0xc62c083c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 2108)); ctx->f[12] = *(float*)&val; }
    // 0x1d889c: 0xc60d0834
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2100)); ctx->f[13] = *(float*)&val; }
    // 0x1d88a0: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x1d88a8);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d88a8
// Address: 0x1d88a8 - 0x1d89b0

void entry_1d88a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d88a8) {
        switch (ctx->pc) {
            case 0x1d88f0: ctx->pc = 0; goto label_1d88f0;
            case 0x1d8900: ctx->pc = 0; goto label_1d8900;
            case 0x1d8930: ctx->pc = 0; goto label_1d8930;
            case 0x1d8938: ctx->pc = 0; goto label_1d8938;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d88a8: 0xc6c10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d88ac: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d88b0: 0xc6c20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1d88b4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d88b8: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d88bc: 0xc48354b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 21680)); ctx->f[3] = *(float*)&val; }
    // 0x1d88c0: 0xc44454c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21696)); ctx->f[4] = *(float*)&val; }
    // 0x1d88c4: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d88c8: 0x246354c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 21696));
    // 0x1d88cc: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1d88d0: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1d88d4: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1d88d8: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d88dc: 0x0
    // NOP
    // 0x1d88e0: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d88f0;
    }
    // 0x1d88e8: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d8900;
    }
label_1d88f0:
    // 0x1d88f0: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d88f4: 0x0
    // NOP
    // 0x1d88f8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_1d8900;
    }
label_1d8900:
    // 0x1d8900: 0x46141836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[3], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8904: 0x0
    // NOP
    // 0x1d8908: 0x45010009
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 4294967295));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d8930;
    }
    // 0x1d8910: 0xc6010840
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2112)); ctx->f[1] = *(float*)&val; }
    // 0x1d8914: 0x26730008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 8));
    // 0x1d8918: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1d891c: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1d8920: 0xe661fff8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 19), 4294967288), *(uint32_t*)&val); }
    // 0x1d8924: 0xc6000840
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2112)); ctx->f[0] = *(float*)&val; }
    // 0x1d8928: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x1d892c: 0xe660fffc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 4294967292), *(uint32_t*)&val); }
label_1d8930:
    // 0x1d8930: 0x1680ffcb
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D8860; return;
    }
label_1d8938:
    // 0x1d8938: 0x8fa30130
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1d893c: 0x1510c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 21), 3));
    // 0x1d8940: 0x3c01c974
    SET_GPR_U32(ctx, 1, ((uint32_t)51572 << 16));
    // 0x1d8944: 0x34212400
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 9216));
    // 0x1d8948: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d894c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d8950: 0xac770000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 23));
    // 0x1d8954: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1d8958: 0x3c21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 2)));
    // 0x1d895c: 0x3c014974
    SET_GPR_U32(ctx, 1, ((uint32_t)18804 << 16));
    // 0x1d8960: 0x34212400
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 9216));
    // 0x1d8964: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d8968: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1d896c: 0x1510c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 21), 3));
    // 0x1d8970: 0xc48251d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 20944)); ctx->f[2] = *(float*)&val; }
    // 0x1d8974: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x1d8978: 0xc620061c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1564)); ctx->f[0] = *(float*)&val; }
    // 0x1d897c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1d8980: 0xe4600004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
    // 0x1d8984: 0x3c21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 2)));
    // 0x1d8988: 0xc620061c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1564)); ctx->f[0] = *(float*)&val; }
    // 0x1d898c: 0xe4610004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
    // 0x1d8990: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1d8994: 0x8e220830
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2096)));
    // 0x1d8998: 0xc62c083c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 2108)); ctx->f[12] = *(float*)&val; }
    // 0x1d899c: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1d89a0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d89a4: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1d89a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d89b0);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[2]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d89b0
// Address: 0x1d89b0 - 0x1d89e0

void entry_1d89b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d89b0: 0x8e230830
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 2096)));
    // 0x1d89b4: 0x8c640034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x1d89b8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d89bc: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1d89c0: 0x10400007
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d89e0(rdram, ctx, runtime); return;
    }
    // 0x1d89c8: 0xc62c083c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 2108)); ctx->f[12] = *(float*)&val; }
    // 0x1d89cc: 0xc46051d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20944)); ctx->f[0] = *(float*)&val; }
    // 0x1d89d0: 0x27a500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1d89d4: 0x27a600d0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1d89d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d89e0);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d89e0
// Address: 0x1d89e0 - 0x1d8a8c

void entry_1d89e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d89e0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d89e4: 0xdba200d0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d89e8: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1d89ec: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d89f0: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d89f4: 0x249054c8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 4), 21704));
    // 0x1d89f8: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1d89fc: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d8a00: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d8a04: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1d8a08: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d8a0c: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d8a10: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d8a14: 0x4b02288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d8a18: 0xdba300c0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d8a1c: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d8a20: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d8a24: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d8a28: 0x48a32800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1d8a2c: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d8a30: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d8a34: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1d8a38: 0x8c8254c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 21704)));
    // 0x1d8a3c: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1d8a40: 0x4be51048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d8a44: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d8a48: 0x8e220848
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2120)));
    // 0x1d8a4c: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1d8a50: 0x4be410c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d8a54: 0xfba300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d8a58: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d8a5c: 0xfba10100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d8a60: 0x2629084c
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 2124));
    // 0x1d8a64: 0xfba200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d8a68: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d8a6c: 0xfba40120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d8a70: 0x8fa50134
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 308)));
    // 0x1d8a74: 0x8fa60138
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 312)));
    // 0x1d8a78: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1d8a7c: 0x8fa7013c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 316)));
    // 0x1d8a80: 0xc62c084c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 2124)); ctx->f[12] = *(float*)&val; }
    // 0x1d8a84: 0xc0536f4
    SET_GPR_U32(ctx, 31, 0x1d8a8c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[5]));
    FindCrvClosestPointOnLineSegmentFromU__FP3CRVP6VECTORT1fT1T1PfT6(rdram, ctx, runtime); return;
}


// Function: entry_1d8a8c
// Address: 0x1d8a8c - 0x1d8ad8

void entry_1d8a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8a8c: 0xdba100c0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d8a90: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d8a94: 0xdba20110
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1d8a98: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1d8a9c: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d8aa0: 0xc44e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1d8aa4: 0xdba100e0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1d8aa8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d8aac: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d8ab0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d8ab4: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d8ab8: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d8abc: 0xc62c0844
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 2116)); ctx->f[12] = *(float*)&val; }
    // 0x1d8ac0: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d8ac4: 0x248454d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 21712));
    // 0x1d8ac8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d8acc: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1d8ad0: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1d8ad8);
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d8ad8
// Address: 0x1d8ad8 - 0x1d8aec

void entry_1d8ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8ad8: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1d8adc: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1d8ae0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1d8ae4: 0xc07611c
    SET_GPR_U32(ctx, 31, 0x1d8aec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    GExcludeAlm__FiP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_1d8aec
// Address: 0x1d8aec - 0x1d8afc

void entry_1d8aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8aec: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1d8af0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d8af4: 0xc07ac14
    SET_GPR_U32(ctx, 31, 0x1d8afc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    FCheckLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_1d8afc
// Address: 0x1d8afc - 0x1d8bd0

void entry_1d8afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d8afc) {
        switch (ctx->pc) {
            case 0x1d8b0c: ctx->pc = 0; goto label_1d8b0c;
            case 0x1d8b20: ctx->pc = 0; goto label_1d8b20;
            case 0x1d8b50: ctx->pc = 0; goto label_1d8b50;
            case 0x1d8b88: ctx->pc = 0; goto label_1d8b88;
            case 0x1d8b8c: ctx->pc = 0; goto label_1d8b8c;
            case 0x1d8b94: ctx->pc = 0; goto label_1d8b94;
            case 0x1d8b98: ctx->pc = 0; goto label_1d8b98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d8afc: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1d8b0c;
    }
    // 0x1d8b04: 0x10000023
    ctx->f[20] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d8b94;
    }
label_1d8b0c:
    // 0x1d8b0c: 0x5aa00022
    if (GPR_S32(ctx, 21) <= 0) {
        { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 2116), *(uint32_t*)&val); }
        goto label_1d8b98;
    }
    // 0x1d8b14: 0xc6220840
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 2112)); ctx->f[2] = *(float*)&val; }
    // 0x1d8b18: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1d8b1c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_1d8b20:
    // 0x1d8b20: 0x46141034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8b24: 0x4500000a
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d8b50;
    }
    // 0x1d8b2c: 0xc4a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1d8b30: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8b34: 0x45000006
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d8b50;
    }
    // 0x1d8b3c: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8b40: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d8b50;
    }
    // 0x1d8b48: 0x1000000f
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d8b88;
    }
label_1d8b50:
    // 0x1d8b50: 0x4602a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8b54: 0x0
    // NOP
    // 0x1d8b58: 0x4502000c
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
        goto label_1d8b8c;
    }
    // 0x1d8b60: 0xc4a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1d8b64: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8b68: 0x0
    // NOP
    // 0x1d8b6c: 0x45020007
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
        goto label_1d8b8c;
    }
    // 0x1d8b74: 0xc4a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1d8b78: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8b7c: 0x0
    // NOP
    // 0x1d8b80: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[20] = FPU_MOV_S(ctx->f[1]);
        goto label_1d8b88;
    }
label_1d8b88:
    // 0x1d8b88: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
label_1d8b8c:
    // 0x1d8b8c: 0x1480ffe4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1d8b20;
    }
label_1d8b94:
    // 0x1d8b94: 0xe6340844
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 2116), *(uint32_t*)&val); }
label_1d8b98:
    // 0x1d8b98: 0x7bbf01d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x1d8b9c: 0x7bbe01c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1d8ba0: 0x7bb701b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1d8ba4: 0x7bb601a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1d8ba8: 0x7bb50190
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1d8bac: 0x7bb40180
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1d8bb0: 0x7bb30170
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1d8bb4: 0x7bb20160
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1d8bb8: 0x7bb10150
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1d8bbc: 0x7bb00140
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1d8bc0: 0xc7b501e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 488)); ctx->f[21] = *(float*)&val; }
    // 0x1d8bc4: 0xc7b401e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 480)); ctx->f[20] = *(float*)&val; }
    // 0x1d8bc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 496));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSuvHeading__FP3SUV
// Address: 0x1d8bd0 - 0x1d8c24

void entry_1d8c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8c24: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d8c28: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d8c2c: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1d8c30: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d8c34: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d8c38: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1d8c3c: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d8c40: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d8c44: 0x8e020844
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2116)));
    // 0x1d8c48: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d8c4c: 0x4b000183
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d8c50: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d8c54: 0x4b02308a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d8c58: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d8c5c: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d8c60: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d8c64: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d8c68: 0xda030100
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x1d8c6c: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d8c70: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d8c74: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1d8c78: 0xfba50040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1d8c7c: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1d8c80: 0x4be51108
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d8c84: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d8c88: 0x4be320ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1d8c8c: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d8c90: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d8c94: 0xc7ac0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1d8c98: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1d8ca0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1d8ca0
// Address: 0x1d8ca0 - 0x1d8ce4

void entry_1d8ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8ca0: 0xe6000694
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1684), *(uint32_t*)&val); }
    // 0x1d8ca4: 0x8e020830
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2096)));
    // 0x1d8ca8: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1d8cac: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d8cb0: 0x8c670008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1d8cb4: 0x10e0000b
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_1d8ce4(rdram, ctx, runtime); return;
    }
    // 0x1d8cbc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d8cc0: 0xc60c083c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2108)); ctx->f[12] = *(float*)&val; }
    // 0x1d8cc4: 0xc46051d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20944)); ctx->f[0] = *(float*)&val; }
    // 0x1d8cc8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d8ccc: 0xc44154dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21724)); ctx->f[1] = *(float*)&val; }
    // 0x1d8cd0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d8cd4: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x1d8cd8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d8cdc: 0xe0f809
    SET_GPR_U32(ctx, 31, 0x1d8ce4);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[1]);
    ctx->pc = GPR_U32(ctx, 7); return;
}


// Function: entry_1d8ce4
// Address: 0x1d8ce4 - 0x1d8cf4

void entry_1d8ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8ce4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1d8ce8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d8cec: 0xc07b642
    SET_GPR_U32(ctx, 31, 0x1d8cf4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RadBetweenVectors__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_1d8cf4
// Address: 0x1d8cf4 - 0x1d8d90

void entry_1d8cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d8cf4) {
        switch (ctx->pc) {
            case 0x1d8d1c: ctx->pc = 0; goto label_1d8d1c;
            case 0x1d8d74: ctx->pc = 0; goto label_1d8d74;
            case 0x1d8d78: ctx->pc = 0; goto label_1d8d78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d8cf4: 0x460000c6
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    // 0x1d8cf8: 0xc601085c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2140)); ctx->f[1] = *(float*)&val; }
    // 0x1d8cfc: 0xc6000618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1560)); ctx->f[0] = *(float*)&val; }
    // 0x1d8d00: 0x8e020afc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2812)));
    // 0x1d8d04: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1d8d08: 0x10400004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1688), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d8d1c;
    }
    // 0x1d8d10: 0xc440001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 28)); ctx->f[0] = *(float*)&val; }
    // 0x1d8d14: 0x46010029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[1]);
    // 0x1d8d18: 0xe6000698
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1688), *(uint32_t*)&val); }
label_1d8d1c:
    // 0x1d8d1c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1d8d20: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8d24: 0x0
    // NOP
    // 0x1d8d28: 0x45000012
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d8d74;
    }
    // 0x1d8d30: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d8d34: 0xc44254dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21724)); ctx->f[2] = *(float*)&val; }
    // 0x1d8d38: 0xc46054e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 21728)); ctx->f[0] = *(float*)&val; }
    // 0x1d8d3c: 0x46031083
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[3];
    // 0x1d8d40: 0xc6010358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 856)); ctx->f[1] = *(float*)&val; }
    // 0x1d8d44: 0xc6030868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2152)); ctx->f[3] = *(float*)&val; }
    // 0x1d8d48: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x1d8d4c: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1d8d50: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1d8d54: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d8d58: 0x46000044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x1d8d5c: 0x46000806
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    // 0x1d8d60: 0xc6010698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1688)); ctx->f[1] = *(float*)&val; }
    // 0x1d8d64: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8d68: 0x0
    // NOP
    // 0x1d8d6c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1688), *(uint32_t*)&val); }
        goto label_1d8d74;
    }
label_1d8d74:
    // 0x1d8d74: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1d8d78:
    // 0x1d8d78: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d8d7c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d8d80: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d8d84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d8d8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d8d90; return;
}


// Function: UpdateSuvWheels__FP3SUV
// Address: 0x1d8d90 - 0x1d8dac

void entry_1d8dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8dac: 0xc60c0694
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1684)); ctx->f[12] = *(float*)&val; }
    // 0x1d8db0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1d8db8);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1d8db8
// Address: 0x1d8db8 - 0x1d8dd0

void entry_1d8db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8db8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d8dbc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d8dc0: 0xc44c54f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21752)); ctx->f[12] = *(float*)&val; }
    // 0x1d8dc4: 0xc46d54f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 21748)); ctx->f[13] = *(float*)&val; }
    // 0x1d8dc8: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x1d8dd0);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d8dd0
// Address: 0x1d8dd0 - 0x1d8df0

void entry_1d8dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8dd0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d8dd4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d8dd8: 0xc44e1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[14] = *(float*)&val; }
    // 0x1d8ddc: 0x248454e8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 21736));
    // 0x1d8de0: 0xc60c069c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1692)); ctx->f[12] = *(float*)&val; }
    // 0x1d8de4: 0x46000346
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    // 0x1d8de8: 0xc07a9ca
    SET_GPR_U32(ctx, 31, 0x1d8df0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RadSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1d8df0
// Address: 0x1d8df0 - 0x1d8e40

void entry_1d8df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d8df0) {
        switch (ctx->pc) {
            case 0x1d8e00: ctx->pc = 0; goto label_1d8e00;
            case 0x1d8e14: ctx->pc = 0; goto label_1d8e14;
            case 0x1d8e18: ctx->pc = 0; goto label_1d8e18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d8df0: 0xe600069c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1692), *(uint32_t*)&val); }
    // 0x1d8df4: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d8df8: 0x260306b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 1712));
    // 0x1d8dfc: 0x0
    // NOP
label_1d8e00:
    // 0x1d8e00: 0x28820002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 2));
    // 0x1d8e04: 0x10400003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1688)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d8e14;
    }
    // 0x1d8e0c: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1552)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d8e18;
    }
label_1d8e14:
    // 0x1d8e14: 0xc6010614
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1556)); ctx->f[1] = *(float*)&val; }
label_1d8e18:
    // 0x1d8e18: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1d8e1c: 0xe4600050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 80), *(uint32_t*)&val); }
    // 0x1d8e20: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1d8e24: 0x2c820004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 4));
    // 0x1d8e28: 0x1440fff5
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 96));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1d8e00;
    }
    // 0x1d8e30: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d8e34: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d8e38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSuvExpls__FP3SUV
// Address: 0x1d8e40 - 0x1d8f24

void entry_1d8f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d8f24) {
        switch (ctx->pc) {
            case 0x1d8f50: ctx->pc = 0; goto label_1d8f50;
            case 0x1d8fa8: ctx->pc = 0; goto label_1d8fa8;
            case 0x1d8fac: ctx->pc = 0; goto label_1d8fac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d8f24: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d8f28: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1d8f2c: 0x3c1e0027
    SET_GPR_U32(ctx, 30, ((uint32_t)39 << 16));
    // 0x1d8f30: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1d8f34: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d8f38: 0x24170003
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1d8f3c: 0x27b50070
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1d8f40: 0x241600c0
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 192));
    // 0x1d8f44: 0x27b40060
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1d8f48: 0x24020060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 96));
    // 0x1d8f4c: 0x0
    // NOP
label_1d8f50:
    // 0x1d8f50: 0x2621018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1d8f54: 0x244206b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1712));
    // 0x1d8f58: 0x2229021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1d8f5c: 0xc6400058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 88)); ctx->f[0] = *(float*)&val; }
    // 0x1d8f60: 0x4600a836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8f64: 0x0
    // NOP
    // 0x1d8f68: 0x450200a5
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 92)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1D9200; return;
    }
    // 0x1d8f70: 0xc6210698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1688)); ctx->f[1] = *(float*)&val; }
    // 0x1d8f74: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x1d8f78: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d8f7c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d8f80: 0x0
    // NOP
    // 0x1d8f84: 0x45000096
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1d91e0(rdram, ctx, runtime); return;
    }
    // 0x1d8f8c: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1d8f90: 0x8c641d70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 7536)));
    // 0x1d8f94: 0x54970004
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 23)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
        goto label_1d8fa8;
    }
    // 0x1d8f9c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d8fa0: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 21768));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d8fac;
    }
label_1d8fa8:
    // 0x1d8fa8: 0x24425500
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 21760));
label_1d8fac:
    // 0x1d8fac: 0xc44d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[13] = *(float*)&val; }
    // 0x1d8fb0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1d8fb8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[12] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d8fb8
// Address: 0x1d8fb8 - 0x1d8fcc

void entry_1d8fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8fb8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d8fbc: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1d8fc0: 0x24448d10
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294937872));
    // 0x1d8fc4: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1d8fcc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1d8fcc
// Address: 0x1d8fcc - 0x1d8fe0

void entry_1d8fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d8fcc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d8fd0: 0xc7cc5510
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 21776)); ctx->f[12] = *(float*)&val; }
    // 0x1d8fd4: 0x24635510
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 21776));
    // 0x1d8fd8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1d8fe0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1d8fe0
// Address: 0x1d8fe0 - 0x1d9048

void entry_1d8fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d8fe0) {
        switch (ctx->pc) {
            case 0x1d9008: ctx->pc = 0; goto label_1d9008;
            case 0x1d9020: ctx->pc = 0; goto label_1d9020;
            case 0x1d902c: ctx->pc = 0; goto label_1d902c;
            case 0x1d9038: ctx->pc = 0; goto label_1d9038;
            case 0x1d903c: ctx->pc = 0; goto label_1d903c;
            case 0x1d9040: ctx->pc = 0; goto label_1d9040;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d8fe0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d8fe4: 0x12620011
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        goto label_1d902c;
    }
    // 0x1d8fec: 0x2a700002
    SET_GPR_U32(ctx, 16, SLT32(GPR_S32(ctx, 19), 2));
    // 0x1d8ff0: 0x12000005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1d9008;
    }
    // 0x1d8ff8: 0x12600009
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1d9020;
    }
    // 0x1d9000: 0x1000000f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d9040;
    }
label_1d9008:
    // 0x1d9008: 0x1262000c
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        goto label_1d903c;
    }
    // 0x1d9010: 0x5277000a
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 23)) {
        ctx->f[12] = FPU_NEG_S(ctx->f[12]);
        goto label_1d903c;
    }
    // 0x1d9018: 0x10000009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d9040;
    }
label_1d9020:
    // 0x1d9020: 0xc620069c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1692)); ctx->f[0] = *(float*)&val; }
    // 0x1d9024: 0x10000004
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d9038;
    }
label_1d902c:
    // 0x1d902c: 0xc620069c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1692)); ctx->f[0] = *(float*)&val; }
    // 0x1d9030: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d9034: 0x460c0301
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
label_1d9038:
    // 0x1d9038: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
label_1d903c:
    // 0x1d903c: 0x27a500b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
label_1d9040:
    // 0x1d9040: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1d9048);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294937888));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1d9048
// Address: 0x1d9048 - 0x1d90bc

void entry_1d9048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9048: 0xdba400b0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1d904c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d9050: 0xdba600c0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1d9054: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d9058: 0xdba500d0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1d905c: 0x26460020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 32));
    // 0x1d9060: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d9064: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d9068: 0xdba30090
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d906c: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d9070: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d9074: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d9078: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1d907c: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d9080: 0x4bc328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d9084: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d9088: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d908c: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d9090: 0x4bc1290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d9094: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d9098: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d909c: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d90a0: 0xfba20110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d90a4: 0xfba200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d90a8: 0xfba30120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d90ac: 0xfba300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d90b0: 0xfba40130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d90b4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d90bc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[4]));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d90bc
// Address: 0x1d90bc - 0x1d9124

void entry_1d90bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d90bc) {
        switch (ctx->pc) {
            case 0x1d90c8: ctx->pc = 0; goto label_1d90c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d90bc: 0x52000002
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1556)); ctx->f[0] = *(float*)&val; }
        goto label_1d90c8;
    }
    // 0x1d90c4: 0xc6200610
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1552)); ctx->f[0] = *(float*)&val; }
label_1d90c8:
    // 0x1d90c8: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1d90cc: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1d90d0: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1d90d4: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1d90d8: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1d90dc: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x1d90e0: 0x7fa200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 2));
    // 0x1d90e4: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d90e8: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1d90ec: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d90f0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d90f4: 0xdba40090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d90f8: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d90fc: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d9100: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d9104: 0xdba50080
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d9108: 0x26460030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 48));
    // 0x1d910c: 0x4bc229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1d9110: 0x4bc220bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d9114: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d9118: 0x4be218ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1d911c: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1d9124);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d9124
// Address: 0x1d9124 - 0x1d9130

void entry_1d9124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9124: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1d9128: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x1d9130);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1d9130
// Address: 0x1d9130 - 0x1d91cc

void entry_1d9130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9130) {
        switch (ctx->pc) {
            case 0x1d919c: ctx->pc = 0; goto label_1d919c;
            case 0x1d91a0: ctx->pc = 0; goto label_1d91a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9130: 0xc6200698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1688)); ctx->f[0] = *(float*)&val; }
    // 0x1d9134: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1d9138: 0x8e240afc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2812)));
    // 0x1d913c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1d9140: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d9144: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d9148: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1d914c: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1d9150: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x1d9154: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1d9158: 0xdba30090
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d915c: 0xc6400058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 88)); ctx->f[0] = *(float*)&val; }
    // 0x1d9160: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d9164: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d9168: 0x7fa200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 2));
    // 0x1d916c: 0x4bc411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1d9170: 0x4bc418bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1d9174: 0x4bc4088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d9178: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x1d917c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1d9180: 0xe7a10120
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 288), *(uint32_t*)&val); }
    // 0x1d9184: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d9188: 0xafb600e0
    WRITE32(ADD32(GPR_U32(ctx, 29), 224), GPR_U32(ctx, 22));
    // 0x1d918c: 0x10800003
    WRITE32(ADD32(GPR_U32(ctx, 29), 284), GPR_U32(ctx, 29));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1d919c;
    }
    // 0x1d9194: 0x10000002
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d91a0;
    }
label_1d919c:
    // 0x1d919c: 0x8e300b18
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 2840)));
label_1d91a0:
    // 0x1d91a0: 0x52000010
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 88)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1D91E4; return;
    }
    // 0x1d91a8: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1d91ac: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1D91D0; return;
    }
    // 0x1d91b4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d91b8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d91bc: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d91c0: 0x27a80040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1d91c4: 0xc049f98
    SET_GPR_U32(ctx, 31, 0x1d91cc);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2(rdram, ctx, runtime); return;
}


// Function: entry_1d91cc
// Address: 0x1d91cc - 0x1d91e0

void entry_1d91cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d91cc) {
        switch (ctx->pc) {
            case 0x1d91d0: ctx->pc = 0; goto label_1d91d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d91cc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1d91d0:
    // 0x1d91d0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d91d4: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x1d91d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d91e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d91e0
// Address: 0x1d91e0 - 0x1d921c

void entry_1d91e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d91e0) {
        switch (ctx->pc) {
            case 0x1d91e4: ctx->pc = 0; goto label_1d91e4;
            case 0x1d9200: ctx->pc = 0; goto label_1d9200;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d91e0: 0xc6400058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 88)); ctx->f[0] = *(float*)&val; }
label_1d91e4:
    // 0x1d91e4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1d91e8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1d91ec: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1d91f0: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1d91f4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1d91f8: 0xe6400058
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 88), *(uint32_t*)&val); }
    // 0x1d91fc: 0xc640005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 92)); ctx->f[0] = *(float*)&val; }
label_1d9200:
    // 0x1d9200: 0x4600a836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d9204: 0x0
    // NOP
    // 0x1d9208: 0x45000026
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D92A4; return;
    }
    // 0x1d9210: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d9214: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1d921c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 96));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1d921c
// Address: 0x1d921c - 0x1d9230

void entry_1d921c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d921c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d9220: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d9224: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d9228: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1d9230);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 32));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d9230
// Address: 0x1d9230 - 0x1d9244

void entry_1d9230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9230: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d9234: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d9238: 0x26460030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 48));
    // 0x1d923c: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1d9244);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d9244
// Address: 0x1d9244 - 0x1d9250

void entry_1d9244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9244: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1d9248: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x1d9250);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1d9250
// Address: 0x1d9250 - 0x1d9290

void entry_1d9250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9250) {
        switch (ctx->pc) {
            case 0x1d9274: ctx->pc = 0; goto label_1d9274;
            case 0x1d9278: ctx->pc = 0; goto label_1d9278;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9250: 0xc640005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 92)); ctx->f[0] = *(float*)&val; }
    // 0x1d9254: 0x8e230afc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 2812)));
    // 0x1d9258: 0xafb60070
    WRITE32(ADD32(GPR_U32(ctx, 29), 112), GPR_U32(ctx, 22));
    // 0x1d925c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1d9260: 0xe7a100b0
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 176), *(uint32_t*)&val); }
    // 0x1d9264: 0x10600003
    WRITE32(ADD32(GPR_U32(ctx, 29), 172), GPR_U32(ctx, 29));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1d9274;
    }
    // 0x1d926c: 0x10000002
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 36)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d9278;
    }
label_1d9274:
    // 0x1d9274: 0x8e240b1c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2844)));
label_1d9278:
    // 0x1d9278: 0x10800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1d9290(rdram, ctx, runtime); return;
    }
    // 0x1d9280: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d9284: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x1d9288: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d9290);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d9290
// Address: 0x1d9290 - 0x1d92f0

void entry_1d9290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9290) {
        switch (ctx->pc) {
            case 0x1d92a4: ctx->pc = 0; goto label_1d92a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9290: 0xc7a100b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[1] = *(float*)&val; }
    // 0x1d9294: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1d9298: 0xc640005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 92)); ctx->f[0] = *(float*)&val; }
    // 0x1d929c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1d92a0: 0xe640005c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 92), *(uint32_t*)&val); }
label_1d92a4:
    // 0x1d92a4: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1d92a8: 0x2e620004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), 4));
    // 0x1d92ac: 0x5440ff28
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 96));
        ctx->pc = 0x1D8F50; return;
    }
    // 0x1d92b4: 0x7bbf01d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x1d92b8: 0x7bbe01c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1d92bc: 0x7bb701b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1d92c0: 0x7bb601a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1d92c4: 0x7bb50190
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1d92c8: 0x7bb40180
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1d92cc: 0x7bb30170
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1d92d0: 0x7bb20160
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1d92d4: 0x7bb10150
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1d92d8: 0x7bb00140
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1d92dc: 0xc7b501e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 488)); ctx->f[21] = *(float*)&val; }
    // 0x1d92e0: 0xc7b401e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 480)); ctx->f[20] = *(float*)&val; }
    // 0x1d92e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 496));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d92ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d92f0; return;
}


// Function: BoostSuv__FP3SUV
// Address: 0x1d92f0 - 0x1d9328

void entry_1d9328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9328: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d932c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d9334: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d9338; return;
}


// Function: FUN_001d9338
// Address: 0x1d9338 - 0x1d940c

void FUN_001d9338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9338) {
        switch (ctx->pc) {
            case 0x1d939c: ctx->pc = 0; goto label_1d939c;
            case 0x1d93ac: ctx->pc = 0; goto label_1d93ac;
            case 0x1d9404: ctx->pc = 0; goto label_1d9404;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9338: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1d933c: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1d9340: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1d9344: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1d9348: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1d934c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1d9350: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d9354: 0x8cc30b00
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 2816)));
    // 0x1d9358: 0x8cc40af8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 2808)));
    // 0x1d935c: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1d9360: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1d9364: 0x8c85000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x1d9368: 0x31040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 1));
    // 0x1d936c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1d9370: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d9374: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1d9378: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1d937c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d9380: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1d9384: 0x46010302
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d9388: 0x46036034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d938c: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d939c;
    }
    // 0x1d9394: 0x10000005
    ctx->f[12] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d93ac;
    }
label_1d939c:
    // 0x1d939c: 0x460c1034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d93a0: 0x0
    // NOP
    // 0x1d93a4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[2]);
        goto label_1d93ac;
    }
label_1d93ac:
    // 0x1d93ac: 0x8cc20b08
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 2824)));
    // 0x1d93b0: 0x8cc30b0c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 2828)));
    // 0x1d93b4: 0x628023
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1d93b8: 0x2a040003
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 16), 3));
    // 0x1d93bc: 0x14800011
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1d9404;
    }
    // 0x1d93c4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1d93c8: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x1d93cc: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x1d93d0: 0x26030007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 7));
    // 0x1d93d4: 0x8ca423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 9160)));
    // 0x1d93d8: 0x202180b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 16));
    // 0x1d93dc: 0x318c3
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 3));
    // 0x1d93e0: 0x32050007
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 16), 7));
    // 0x1d93e4: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1d93e8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d93ec: 0x90830074
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 116)));
    // 0x1d93f0: 0xa21004
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), GPR_U32(ctx, 5) & 0x1F));
    // 0x1d93f4: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1d93f8: 0x10600004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1d940c(rdram, ctx, runtime); return;
    }
    // 0x1d9400: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
label_1d9404:
    // 0x1d9404: 0xc054788
    SET_GPR_U32(ctx, 31, 0x1d940c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    OnDifficultyPlayerDeath(rdram, ctx, runtime); return;
}


// Function: entry_1d940c
// Address: 0x1d940c - 0x1d9488

void entry_1d940c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d940c) {
        switch (ctx->pc) {
            case 0x1d9428: ctx->pc = 0; goto label_1d9428;
            case 0x1d946c: ctx->pc = 0; goto label_1d946c;
            case 0x1d9478: ctx->pc = 0; goto label_1d9478;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d940c: 0x600001a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_S32(ctx, 16) < 0) {
        goto label_1d9478;
    }
    // 0x1d9414: 0x3c090026
    SET_GPR_U32(ctx, 9, ((uint32_t)38 << 16));
    // 0x1d9418: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1d941c: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d9420: 0x110182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 16)));
    // 0x1d9424: 0x0
    // NOP
label_1d9428:
    // 0x1d9428: 0x8d2623c8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 9), 9160)));
    // 0x1d942c: 0x26020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 7));
    // 0x1d9430: 0x32050007
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 16), 7));
    // 0x1d9434: 0x203100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 16));
    // 0x1d9438: 0x24c40074
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 116));
    // 0x1d943c: 0x210c3
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 3));
    // 0x1d9440: 0xa72804
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 7), GPR_U32(ctx, 5) & 0x1F));
    // 0x1d9444: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1d9448: 0x90830000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1d944c: 0x651024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1d9450: 0x14400006
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1d946c;
    }
    // 0x1d9458: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1d945c: 0xa0830000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x1d9460: 0x8cc20070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 112)));
    // 0x1d9464: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1d9468: 0xacc20070
    WRITE32(ADD32(GPR_U32(ctx, 6), 112), GPR_U32(ctx, 2));
label_1d946c:
    // 0x1d946c: 0x601ffee
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 16)));
    if (GPR_S32(ctx, 16) >= 0) {
        goto label_1d9428;
    }
    // 0x1d9474: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1d9478:
    // 0x1d9478: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d947c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d9484: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d9488; return;
}


// Function: UpdateSuvVolumes__FP3SUVi
// Address: 0x1d9488 - 0x1d94ec

void entry_1d94ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d94ec) {
        switch (ctx->pc) {
            case 0x1d9518: ctx->pc = 0; goto label_1d9518;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d94ec: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d94f0: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1d94f4: 0x5062004f
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
        ctx->pc = 0x1D9634; return;
    }
    // 0x1d94fc: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1d9500: 0x10400005
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d9518;
    }
    // 0x1d9508: 0x105e0046
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 30)) {
        ctx->pc = 0x1D9624; return;
    }
    // 0x1d9510: 0x10000048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9634; return;
    }
label_1d9518:
    // 0x1d9518: 0x50600046
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
        ctx->pc = 0x1D9634; return;
    }
    // 0x1d9520: 0x8e430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1d9524: 0x8e020af8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2808)));
    // 0x1d9528: 0x54620042
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
        ctx->pc = 0x1D9634; return;
    }
    // 0x1d9530: 0x8e020af4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2804)));
    // 0x1d9534: 0x1642003e
    WRITE32(ADD32(GPR_U32(ctx, 16), 2808), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D9630; return;
    }
    // 0x1d953c: 0x8e020b00
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2816)));
    // 0x1d9540: 0x8e030b04
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2820)));
    // 0x1d9544: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1d9548: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1d954c: 0x10600038
    WRITE32(ADD32(GPR_U32(ctx, 16), 2816), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9630; return;
    }
    // 0x1d9554: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1d9558: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1d955c: 0x2406042c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1068));
    // 0x1d9560: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1d9568);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1d9568
// Address: 0x1d9568 - 0x1d9578

void entry_1d9568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9568: 0x8c510048
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1d956c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d9570: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x1d9578);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d9578
// Address: 0x1d9578 - 0x1d958c

void entry_1d9578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9578: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d957c: 0x14570003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 23)) {
        entry_1d958c(rdram, ctx, runtime); return;
    }
    // 0x1d9584: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1d958c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d958c
// Address: 0x1d958c - 0x1d9594

void entry_1d958c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d958c: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1d9594);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d9594
// Address: 0x1d9594 - 0x1d95c8

void entry_1d9594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9594) {
        switch (ctx->pc) {
            case 0x1d95a8: ctx->pc = 0; goto label_1d95a8;
            case 0x1d95c0: ctx->pc = 0; goto label_1d95c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9594: 0x16020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1d95a8;
    }
    // 0x1d959c: 0x8e020b04
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2820)));
    // 0x1d95a0: 0xae020b00
    WRITE32(ADD32(GPR_U32(ctx, 16), 2816), GPR_U32(ctx, 2));
    // 0x1d95a4: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_1d95a8:
    // 0x1d95a8: 0x10560005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 22)) {
        goto label_1d95c0;
    }
    // 0x1d95b0: 0x10550011
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1D95F8; return;
    }
    // 0x1d95b8: 0x1000001e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9634; return;
    }
label_1d95c0:
    // 0x1d95c0: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1d95c8);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d95c8
// Address: 0x1d95c8 - 0x1d95d8

void entry_1d95c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d95c8: 0x16020007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D95E8; return;
    }
    // 0x1d95d0: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1d95d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1074));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d95d8
// Address: 0x1d95d8 - 0x1d95e0

void entry_1d95d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d95d8: 0xc0547f2
    SET_GPR_U32(ctx, 31, 0x1d95e0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 7920));
    OnDifficultyCollectKey__FP10DIFFICULTY(rdram, ctx, runtime); return;
}


// Function: entry_1d95e0
// Address: 0x1d95e0 - 0x1d95f0

void entry_1d95e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d95e0) {
        switch (ctx->pc) {
            case 0x1d95e8: ctx->pc = 0; goto label_1d95e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d95e0: 0x10000014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9634; return;
    }
label_1d95e8:
    // 0x1d95e8: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1d95f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1072));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d95f0
// Address: 0x1d95f0 - 0x1d9600

void entry_1d95f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d95f0) {
        switch (ctx->pc) {
            case 0x1d95f8: ctx->pc = 0; goto label_1d95f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d95f0: 0x10000010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9634; return;
    }
label_1d95f8:
    // 0x1d95f8: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1d9600);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1d9600
// Address: 0x1d9600 - 0x1d9614

void entry_1d9600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9600: 0x5602000c
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
        ctx->pc = 0x1D9634; return;
    }
    // 0x1d9608: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d960c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1d9614);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1073));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d9614
// Address: 0x1d9614 - 0x1d961c

void entry_1d9614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9614: 0xc0764ce
    SET_GPR_U32(ctx, 31, 0x1d961c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001d9338(rdram, ctx, runtime); return;
}


// Function: entry_1d961c
// Address: 0x1d961c - 0x1d9678

void entry_1d961c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d961c) {
        switch (ctx->pc) {
            case 0x1d9624: ctx->pc = 0; goto label_1d9624;
            case 0x1d9630: ctx->pc = 0; goto label_1d9630;
            case 0x1d9634: ctx->pc = 0; goto label_1d9634;
            case 0x1d9644: ctx->pc = 0; goto label_1d9644;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d961c: 0x10000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d9634;
    }
label_1d9624:
    // 0x1d9624: 0x50600002
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 2812), GPR_U32(ctx, 0));
        goto label_1d9630;
    }
    // 0x1d962c: 0xae120afc
    WRITE32(ADD32(GPR_U32(ctx, 16), 2812), GPR_U32(ctx, 18));
label_1d9630:
    // 0x1d9630: 0x8e020870
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
label_1d9634:
    // 0x1d9634: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1d9638: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1d963c: 0x1440ffa8
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 40));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D94E0; return;
    }
label_1d9644:
    // 0x1d9644: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1d9648: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d964c: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d9650: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d9654: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d9658: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d965c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d9660: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d9664: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1d9668: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d966c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1d9674: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1d9678; return;
}


// Function: UpdateSuvSounds__FP3SUVf
// Address: 0x1d9678 - 0x1d96f4

void entry_1d96f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d96f4) {
        switch (ctx->pc) {
            case 0x1d9740: ctx->pc = 0; goto label_1d9740;
            case 0x1d9754: ctx->pc = 0; goto label_1d9754;
            case 0x1d97a0: ctx->pc = 0; goto label_1d97a0;
            case 0x1d97b4: ctx->pc = 0; goto label_1d97b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d96f4: 0xda020150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1d96f8: 0xda010110
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 272)));
    // 0x1d96fc: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d9700: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1d9704: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d9708: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d970c: 0xc6225524
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 21796)); ctx->f[2] = *(float*)&val; }
    // 0x1d9710: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d9714: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1d9718: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1d971c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d9720: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1d9724: 0x46020843
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[2];
    // 0x1d9728: 0x46030834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d972c: 0x0
    // NOP
    // 0x1d9730: 0x45000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2976), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d9740;
    }
    // 0x1d9738: 0x10000006
    ctx->f[6] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d9754;
    }
label_1d9740:
    // 0x1d9740: 0x46012034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d9744: 0x0
    // NOP
    // 0x1d9748: 0x45000002
    ctx->f[6] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d9754;
    }
    // 0x1d9750: 0x46002186
    ctx->f[6] = FPU_MOV_S(ctx->f[4]);
label_1d9754:
    // 0x1d9754: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d9758: 0xc6020b9c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2972)); ctx->f[2] = *(float*)&val; }
    // 0x1d975c: 0x24435590
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 21904));
    // 0x1d9760: 0xc4435590
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21904)); ctx->f[3] = *(float*)&val; }
    // 0x1d9764: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d9768: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d976c: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d9770: 0x244455a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 21920));
    // 0x1d9774: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1d9778: 0xc44455a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21920)); ctx->f[4] = *(float*)&val; }
    // 0x1d977c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d9780: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1d9784: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1d9788: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d978c: 0x0
    // NOP
    // 0x1d9790: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d97a0;
    }
    // 0x1d9798: 0x10000006
    ctx->f[0] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d97b4;
    }
label_1d97a0:
    // 0x1d97a0: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d97a4: 0x0
    // NOP
    // 0x1d97a8: 0x45000002
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d97b4;
    }
    // 0x1d97b0: 0x46002806
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
label_1d97b4:
    // 0x1d97b4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d97b8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d97bc: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1d97c0: 0xc44255a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21928)); ctx->f[2] = *(float*)&val; }
    // 0x1d97c4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1d97c8: 0x461418c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[20]);
    // 0x1d97cc: 0xc6040ba0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2976)); ctx->f[4] = *(float*)&val; }
    // 0x1d97d0: 0x4602a082
    ctx->f[2] = FPU_MUL_S(ctx->f[20], ctx->f[2]);
    // 0x1d97d4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d97d8: 0x24435530
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 21808));
    // 0x1d97dc: 0xc44c5530
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21808)); ctx->f[12] = *(float*)&val; }
    // 0x1d97e0: 0x460618c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[6]);
    // 0x1d97e4: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d97e8: 0x46041082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x1d97ec: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d97f0: 0xc6040b94
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2964)); ctx->f[4] = *(float*)&val; }
    // 0x1d97f4: 0x8e040b84
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2948)));
    // 0x1d97f8: 0x46021d00
    ctx->f[20] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1d97fc: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1d9800: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d9804: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1d9808: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x1d980c: 0xc06fdfe
    SET_GPR_U32(ctx, 31, 0x1d9814);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[4]);
    SetPambFrq__FP3AMBf(rdram, ctx, runtime); return;
}


// Function: entry_1d9814
// Address: 0x1d9814 - 0x1d9874

void entry_1d9814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9814) {
        switch (ctx->pc) {
            case 0x1d985c: ctx->pc = 0; goto label_1d985c;
            case 0x1d986c: ctx->pc = 0; goto label_1d986c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9814: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d9818: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d981c: 0x24435540
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 21824));
    // 0x1d9820: 0xc4425540
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21824)); ctx->f[2] = *(float*)&val; }
    // 0x1d9824: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d9828: 0x24825550
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 21840));
    // 0x1d982c: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d9830: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1d9834: 0xc4835550
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 21840)); ctx->f[3] = *(float*)&val; }
    // 0x1d9838: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d983c: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1d9840: 0x46001300
    ctx->f[12] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1d9844: 0x46036034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d9848: 0x0
    // NOP
    // 0x1d984c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d985c;
    }
    // 0x1d9854: 0x10000005
    ctx->f[12] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d986c;
    }
label_1d985c:
    // 0x1d985c: 0x460c2034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d9860: 0x0
    // NOP
    // 0x1d9864: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[4]);
        goto label_1d986c;
    }
label_1d986c:
    // 0x1d986c: 0xc06fe3a
    SET_GPR_U32(ctx, 31, 0x1d9874);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2948)));
    SetPambVol__FP3AMBf(rdram, ctx, runtime); return;
}


// Function: entry_1d9874
// Address: 0x1d9874 - 0x1d98a8

void entry_1d9874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9874: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d9878: 0xc6020b90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2960)); ctx->f[2] = *(float*)&val; }
    // 0x1d987c: 0x24435560
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 21856));
    // 0x1d9880: 0xc44c5560
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21856)); ctx->f[12] = *(float*)&val; }
    // 0x1d9884: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d9888: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d988c: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1d9890: 0x8e040b80
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2944)));
    // 0x1d9894: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d9898: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1d989c: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x1d98a0: 0xc06fdfe
    SET_GPR_U32(ctx, 31, 0x1d98a8);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[2]);
    SetPambFrq__FP3AMBf(rdram, ctx, runtime); return;
}


// Function: entry_1d98a8
// Address: 0x1d98a8 - 0x1d9908

void entry_1d98a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d98a8) {
        switch (ctx->pc) {
            case 0x1d98f0: ctx->pc = 0; goto label_1d98f0;
            case 0x1d9900: ctx->pc = 0; goto label_1d9900;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d98a8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d98ac: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d98b0: 0x24435570
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 21872));
    // 0x1d98b4: 0xc4425570
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21872)); ctx->f[2] = *(float*)&val; }
    // 0x1d98b8: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d98bc: 0x24825580
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 21888));
    // 0x1d98c0: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d98c4: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1d98c8: 0xc4835580
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 21888)); ctx->f[3] = *(float*)&val; }
    // 0x1d98cc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d98d0: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1d98d4: 0x46001300
    ctx->f[12] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1d98d8: 0x46036034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d98dc: 0x0
    // NOP
    // 0x1d98e0: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d98f0;
    }
    // 0x1d98e8: 0x10000005
    ctx->f[12] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d9900;
    }
label_1d98f0:
    // 0x1d98f0: 0x460c2034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d98f4: 0x0
    // NOP
    // 0x1d98f8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[4]);
        goto label_1d9900;
    }
label_1d9900:
    // 0x1d9900: 0xc06fe3a
    SET_GPR_U32(ctx, 31, 0x1d9908);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2944)));
    SetPambVol__FP3AMBf(rdram, ctx, runtime); return;
}


// Function: entry_1d9908
// Address: 0x1d9908 - 0x1d991c

void entry_1d9908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9908: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d990c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d9910: 0x26060150
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 336));
    // 0x1d9914: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1d991c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1d991c
// Address: 0x1d991c - 0x1d9a50

void entry_1d991c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d991c) {
        switch (ctx->pc) {
            case 0x1d99bc: ctx->pc = 0; goto label_1d99bc;
            case 0x1d9a08: ctx->pc = 0; goto label_1d9a08;
            case 0x1d9a18: ctx->pc = 0; goto label_1d9a18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d991c: 0xc6000698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1688)); ctx->f[0] = *(float*)&val; }
    // 0x1d9920: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1d9924: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1d9928: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d992c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1d9930: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1d9934: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1d9938: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d993c: 0xc46155f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 22008)); ctx->f[1] = *(float*)&val; }
    // 0x1d9940: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1d9944: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d9948: 0xc48255ac
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 21932)); ctx->f[2] = *(float*)&val; }
    // 0x1d994c: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1d9950: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d9954: 0x44801800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 0);
    // 0x1d9958: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d995c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d9960: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1d9964: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d9968: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1d996c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d9970: 0xe7a00010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x1d9974: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d9978: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d997c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d9980: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1d9984: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1d9988: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1d998c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d9990: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1d9994: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x1d9998: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d999c: 0x0
    // NOP
    // 0x1d99a0: 0x45010006
    ctx->f[20] = FPU_MOV_S(ctx->f[3]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1d99bc;
    }
    // 0x1d99a8: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d99ac: 0x0
    // NOP
    // 0x1d99b0: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d99bc;
    }
    // 0x1d99b8: 0x46002506
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
label_1d99bc:
    // 0x1d99bc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d99c0: 0xc6020b9c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2972)); ctx->f[2] = *(float*)&val; }
    // 0x1d99c4: 0x244355e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 21984));
    // 0x1d99c8: 0xc44355e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21984)); ctx->f[3] = *(float*)&val; }
    // 0x1d99cc: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d99d0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d99d4: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d99d8: 0x244455f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 22000));
    // 0x1d99dc: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1d99e0: 0xc44455f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22000)); ctx->f[4] = *(float*)&val; }
    // 0x1d99e4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d99e8: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1d99ec: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1d99f0: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d99f4: 0x0
    // NOP
    // 0x1d99f8: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d9a08;
    }
    // 0x1d9a00: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d9a18;
    }
label_1d9a08:
    // 0x1d9a08: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d9a0c: 0x0
    // NOP
    // 0x1d9a10: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_1d9a18;
    }
label_1d9a18:
    // 0x1d9a18: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d9a1c: 0x4603a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[3]);
    // 0x1d9a20: 0x244355b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 21936));
    // 0x1d9a24: 0xc44c55b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21936)); ctx->f[12] = *(float*)&val; }
    // 0x1d9a28: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d9a2c: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d9a30: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1d9a34: 0xc6020b8c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2956)); ctx->f[2] = *(float*)&val; }
    // 0x1d9a38: 0x8e040b7c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2940)));
    // 0x1d9a3c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d9a40: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1d9a44: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x1d9a48: 0xc06fdfe
    SET_GPR_U32(ctx, 31, 0x1d9a50);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[2]);
    SetPambFrq__FP3AMBf(rdram, ctx, runtime); return;
}


// Function: entry_1d9a50
// Address: 0x1d9a50 - 0x1d9ab0

void entry_1d9a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9a50) {
        switch (ctx->pc) {
            case 0x1d9a98: ctx->pc = 0; goto label_1d9a98;
            case 0x1d9aa8: ctx->pc = 0; goto label_1d9aa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9a50: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d9a54: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1d9a58: 0x244355c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 21952));
    // 0x1d9a5c: 0xc44255c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 21952)); ctx->f[2] = *(float*)&val; }
    // 0x1d9a60: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1d9a64: 0x248255d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 21968));
    // 0x1d9a68: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d9a6c: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1d9a70: 0xc48355d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 21968)); ctx->f[3] = *(float*)&val; }
    // 0x1d9a74: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1d9a78: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1d9a7c: 0x46001300
    ctx->f[12] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1d9a80: 0x46036034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d9a84: 0x0
    // NOP
    // 0x1d9a88: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d9a98;
    }
    // 0x1d9a90: 0x10000005
    ctx->f[12] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d9aa8;
    }
label_1d9a98:
    // 0x1d9a98: 0x460c2034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d9a9c: 0x0
    // NOP
    // 0x1d9aa0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[4]);
        goto label_1d9aa8;
    }
label_1d9aa8:
    // 0x1d9aa8: 0xc06fe3a
    SET_GPR_U32(ctx, 31, 0x1d9ab0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2940)));
    SetPambVol__FP3AMBf(rdram, ctx, runtime); return;
}


// Function: entry_1d9ab0
// Address: 0x1d9ab0 - 0x1d9ac8

void entry_1d9ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9ab0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d9ab4: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d9ab8: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d9abc: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1d9ac0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSuvPuncher__FP3SUV
// Address: 0x1d9ac8 - 0x1d9b88

void entry_1d9b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9b88: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d9b8c: 0xda210150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x1d9b90: 0x8c425610
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 22032)));
    // 0x1d9b94: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1d9b98: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d9b9c: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d9ba0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d9ba4: 0xdaa20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1d9ba8: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1d9bac: 0x4be408c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d9bb0: 0x8c425614
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 22036)));
    // 0x1d9bb4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1d9bb8: 0x4bc312fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[3] = READ32(addr); }
    // 0x1d9bbc: 0x4bc218ae
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1d9bc0: 0x4a2210ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d9bc4: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1d9bc8: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1d9bcc: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1d9bd0: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1d9bd4: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1d9bd8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d9bdc: 0x8c430090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x1d9be0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1d9be8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1d9be8
// Address: 0x1d9be8 - 0x1d9bfc

void entry_1d9be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9be8: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1d9bec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d9bf0: 0x8cc20094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 148)));
    // 0x1d9bf4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1d9bfc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1d9bfc
// Address: 0x1d9bfc - 0x1d9c28

void entry_1d9bfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9bfc) {
        switch (ctx->pc) {
            case 0x1d9c1c: ctx->pc = 0; goto label_1d9c1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9bfc: 0x8e230b50
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 2896)));
    // 0x1d9c00: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x1d9c04: 0x10400005
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d9c1c;
    }
    // 0x1d9c0c: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1d9c10: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1d9c14: 0xac500b54
    WRITE32(ADD32(GPR_U32(ctx, 2), 2900), GPR_U32(ctx, 16));
    // 0x1d9c18: 0xae230b50
    WRITE32(ADD32(GPR_U32(ctx, 17), 2896), GPR_U32(ctx, 3));
label_1d9c1c:
    // 0x1d9c1c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d9c20: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d9c28);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 25));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d9c28
// Address: 0x1d9c28 - 0x1d9c44

void entry_1d9c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9c28) {
        switch (ctx->pc) {
            case 0x1d9c3c: ctx->pc = 0; goto label_1d9c3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9c28: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1d9c3c;
    }
    // 0x1d9c30: 0xc6800004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d9c34: 0x10000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2156), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1d9c58(rdram, ctx, runtime); return;
    }
label_1d9c3c:
    // 0x1d9c3c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1d9c44);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1d9c44
// Address: 0x1d9c44 - 0x1d9c58

void entry_1d9c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9c44: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1d9c58(rdram, ctx, runtime); return;
    }
    // 0x1d9c4c: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1d9c50: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x1d9c58);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1d9c58
// Address: 0x1d9c58 - 0x1d9c70

void entry_1d9c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9c58) {
        switch (ctx->pc) {
            case 0x1d9c5c: ctx->pc = 0; goto label_1d9c5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9c58: 0x8e5200d0
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 208)));
label_1d9c5c:
    // 0x1d9c5c: 0x5640ffac
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1D9B10; return;
    }
    // 0x1d9c64: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1d9c68: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1d9c70);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 2932)));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1d9c70
// Address: 0x1d9c70 - 0x1d9c98

void entry_1d9c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9c70) {
        switch (ctx->pc) {
            case 0x1d9c74: ctx->pc = 0; goto label_1d9c74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9c70: 0xae200b74
    WRITE32(ADD32(GPR_U32(ctx, 17), 2932), GPR_U32(ctx, 0));
label_1d9c74:
    // 0x1d9c74: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1d9c78: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1d9c7c: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1d9c80: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1d9c84: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1d9c88: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d9c8c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1d9c90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSuv__FP3SUVf
// Address: 0x1d9c98 - 0x1d9cb8

void entry_1d9cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9cb8) {
        switch (ctx->pc) {
            case 0x1d9ce0: ctx->pc = 0; goto label_1d9ce0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9cb8: 0x8e030b34
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2868)));
    // 0x1d9cbc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d9cc0: 0x10620007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1d9ce0;
    }
    // 0x1d9cc8: 0x1040000d
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9D00; return;
    }
    // 0x1d9cd0: 0x5060000b
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1688), GPR_U32(ctx, 0));
        ctx->pc = 0x1D9D00; return;
    }
    // 0x1d9cd8: 0x10000009
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9D00; return;
    }
label_1d9ce0:
    // 0x1d9ce0: 0xc07615e
    SET_GPR_U32(ctx, 31, 0x1d9ce8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateSuvBalance__FP3SUV(rdram, ctx, runtime); return;
}


// Function: entry_1d9ce8
// Address: 0x1d9ce8 - 0x1d9cf4

void entry_1d9ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9ce8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d9cec: 0xc0761f2
    SET_GPR_U32(ctx, 31, 0x1d9cf4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    UpdateSuvLine__FP3SUVPi(rdram, ctx, runtime); return;
}


// Function: entry_1d9cf4
// Address: 0x1d9cf4 - 0x1d9cfc

void entry_1d9cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9cf4: 0xc0762f4
    SET_GPR_U32(ctx, 31, 0x1d9cfc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateSuvHeading__FP3SUV(rdram, ctx, runtime); return;
}


// Function: entry_1d9cfc
// Address: 0x1d9cfc - 0x1d9d08

void entry_1d9cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9cfc) {
        switch (ctx->pc) {
            case 0x1d9d00: ctx->pc = 0; goto label_1d9d00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9cfc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
label_1d9d00:
    // 0x1d9d00: 0xc07659e
    SET_GPR_U32(ctx, 31, 0x1d9d08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateSuvSounds__FP3SUVf(rdram, ctx, runtime); return;
}


// Function: entry_1d9d08
// Address: 0x1d9d08 - 0x1d9d10

void entry_1d9d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9d08: 0xc076364
    SET_GPR_U32(ctx, 31, 0x1d9d10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateSuvWheels__FP3SUV(rdram, ctx, runtime); return;
}


// Function: entry_1d9d10
// Address: 0x1d9d10 - 0x1d9d18

void entry_1d9d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9d10: 0xc076390
    SET_GPR_U32(ctx, 31, 0x1d9d18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateSuvExpls__FP3SUV(rdram, ctx, runtime); return;
}


// Function: entry_1d9d18
// Address: 0x1d9d18 - 0x1d9d24

void entry_1d9d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9d18: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1d9d1c: 0xc076522
    SET_GPR_U32(ctx, 31, 0x1d9d24);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateSuvVolumes__FP3SUVi(rdram, ctx, runtime); return;
}


// Function: entry_1d9d24
// Address: 0x1d9d24 - 0x1d9d2c

void entry_1d9d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9d24: 0xc0766b2
    SET_GPR_U32(ctx, 31, 0x1d9d2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateSuvPuncher__FP3SUV(rdram, ctx, runtime); return;
}


// Function: entry_1d9d2c
// Address: 0x1d9d2c - 0x1d9d64

void entry_1d9d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9d2c) {
        switch (ctx->pc) {
            case 0x1d9d50: ctx->pc = 0; goto label_1d9d50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9d2c: 0xc60100f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 248)); ctx->f[1] = *(float*)&val; }
    // 0x1d9d30: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1d9d34: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d9d38: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d9d3c: 0x0
    // NOP
    // 0x1d9d40: 0x45000003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1d9d50;
    }
    // 0x1d9d48: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1d9d4c: 0xe6000850
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2128), *(uint32_t*)&val); }
label_1d9d50:
    // 0x1d9d50: 0x8e020b34
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2868)));
    // 0x1d9d54: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9D68; return;
    }
    // 0x1d9d5c: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1d9d64);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1d9d64
// Address: 0x1d9d64 - 0x1d9d78

void entry_1d9d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9d64) {
        switch (ctx->pc) {
            case 0x1d9d68: ctx->pc = 0; goto label_1d9d68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9d64: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1d9d68:
    // 0x1d9d68: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1d9d6c: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1d9d70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSuvActive__FP3SUVP3JOYf
// Address: 0x1d9d78 - 0x1d9dd4

void entry_1d9dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9dd4) {
        switch (ctx->pc) {
            case 0x1d9ddc: ctx->pc = 0; goto label_1d9ddc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9dd4: 0x10000006
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2868)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9DF0; return;
    }
label_1d9ddc:
    // 0x1d9ddc: 0xc64c00d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 212)); ctx->f[12] = *(float*)&val; }
    // 0x1d9de0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1d9de8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 208)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1d9de8
// Address: 0x1d9de8 - 0x1d9e44

void entry_1d9de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9de8) {
        switch (ctx->pc) {
            case 0x1d9df0: ctx->pc = 0; goto label_1d9df0;
            case 0x1d9e2c: ctx->pc = 0; goto label_1d9e2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9de8: 0xe6400694
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1684), *(uint32_t*)&val); }
    // 0x1d9dec: 0x8e430b34
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2868)));
label_1d9df0:
    // 0x1d9df0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1d9df4: 0x1462004d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D9F2C; return;
    }
    // 0x1d9dfc: 0xc6010048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[1] = *(float*)&val; }
    // 0x1d9e00: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d9e04: 0xc6400618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1560)); ctx->f[0] = *(float*)&val; }
    // 0x1d9e08: 0x8c439b48
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294941512)));
    // 0x1d9e0c: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1d9e10: 0x10600006
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 1688), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1d9e2c;
    }
    // 0x1d9e18: 0x3c013ecc
    SET_GPR_U32(ctx, 1, ((uint32_t)16076 << 16));
    // 0x1d9e1c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1d9e20: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1d9e24: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1d9e28: 0xe6400698
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1688), *(uint32_t*)&val); }
label_1d9e2c:
    // 0x1d9e2c: 0x960200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
    // 0x1d9e30: 0x30420080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 128));
    // 0x1d9e34: 0x1040003c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9F28; return;
    }
    // 0x1d9e3c: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1d9e44);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 128));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1d9e44
// Address: 0x1d9e44 - 0x1d9e98

void entry_1d9e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9e44: 0x8e430b30
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2864)));
    // 0x1d9e48: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d9e4c: 0x1062002f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D9F0C; return;
    }
    // 0x1d9e54: 0x50400035
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x1D9F2C; return;
    }
    // 0x1d9e5c: 0x54600033
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x1D9F2C; return;
    }
    // 0x1d9e64: 0x8e420858
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2136)));
    // 0x1d9e68: 0x18400016
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1D9EC4; return;
    }
    // 0x1d9e70: 0xc6420854
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2132)); ctx->f[2] = *(float*)&val; }
    // 0x1d9e74: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1d9e78: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1d9e7c: 0xc44151dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20956)); ctx->f[1] = *(float*)&val; }
    // 0x1d9e80: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1d9e84: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d9e88: 0x4500000e
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1D9EC4; return;
    }
    // 0x1d9e90: 0xc0764bc
    SET_GPR_U32(ctx, 31, 0x1d9e98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    BoostSuv__FP3SUV(rdram, ctx, runtime); return;
}


// Function: entry_1d9e98
// Address: 0x1d9e98 - 0x1d9f04

void entry_1d9e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9e98) {
        switch (ctx->pc) {
            case 0x1d9ec4: ctx->pc = 0; goto label_1d9ec4;
            case 0x1d9ef4: ctx->pc = 0; goto label_1d9ef4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9e98: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1d9e9c: 0x2404005a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 90));
    // 0x1d9ea0: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1d9ea4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1d9ea8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d9eac: 0x3c01be80
    SET_GPR_U32(ctx, 1, ((uint32_t)48768 << 16));
    // 0x1d9eb0: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
    // 0x1d9eb4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d9eb8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d9ebc: 0x1000000d
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1d9ef4;
    }
label_1d9ec4:
    // 0x1d9ec4: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1d9ec8: 0x24040073
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 115));
    // 0x1d9ecc: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1d9ed0: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1d9ed4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1d9ed8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d9edc: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1d9ee0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1d9ee4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d9ee8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1d9eec: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1d9ef0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1d9ef4:
    // 0x1d9ef4: 0x44808000
    *(uint32_t*)&ctx->f[16] = GPR_U32(ctx, 0);
    // 0x1d9ef8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1d9efc: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1d9f04);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1d9f04
// Address: 0x1d9f04 - 0x1d9f24

void entry_1d9f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9f04) {
        switch (ctx->pc) {
            case 0x1d9f0c: ctx->pc = 0; goto label_1d9f0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9f04: 0x10000009
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9F2C; return;
    }
label_1d9f0c:
    // 0x1d9f0c: 0x8e420b44
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2884)));
    // 0x1d9f10: 0x10400006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1D9F2C; return;
    }
    // 0x1d9f18: 0x8e440b48
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 2888)));
    // 0x1d9f1c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1d9f24);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1157));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d9f24
// Address: 0x1d9f24 - 0x1d9f34

void entry_1d9f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9f24) {
        switch (ctx->pc) {
            case 0x1d9f28: ctx->pc = 0; goto label_1d9f28;
            case 0x1d9f2c: ctx->pc = 0; goto label_1d9f2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9f24: 0xae400b50
    WRITE32(ADD32(GPR_U32(ctx, 18), 2896), GPR_U32(ctx, 0));
label_1d9f28:
    // 0x1d9f28: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1d9f2c:
    // 0x1d9f2c: 0xc064a9c
    SET_GPR_U32(ctx, 31, 0x1d9f34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_00192a70(rdram, ctx, runtime); return;
}


// Function: entry_1d9f34
// Address: 0x1d9f34 - 0x1d9f84

void entry_1d9f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9f34) {
        switch (ctx->pc) {
            case 0x1d9f54: ctx->pc = 0; goto label_1d9f54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9f34: 0x8e420afc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2812)));
    // 0x1d9f38: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2864)));
        goto label_1d9f54;
    }
    // 0x1d9f40: 0xc440001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 28)); ctx->f[0] = *(float*)&val; }
    // 0x1d9f44: 0xc6410698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1688)); ctx->f[1] = *(float*)&val; }
    // 0x1d9f48: 0x46010029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[1]);
    // 0x1d9f4c: 0xe6400698
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1688), *(uint32_t*)&val); }
    // 0x1d9f50: 0x8e430b30
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2864)));
label_1d9f54:
    // 0x1d9f54: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1d9f58: 0x1062004d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DA090; return;
    }
    // 0x1d9f60: 0x1040007a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA14C; return;
    }
    // 0x1d9f68: 0x14600079
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA150; return;
    }
    // 0x1d9f70: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1d9f74: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1d9f78: 0x2406042c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1068));
    // 0x1d9f7c: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1d9f84);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1d9f84
// Address: 0x1d9f84 - 0x1d9f9c

void entry_1d9f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9f84: 0x10400070
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1da148(rdram, ctx, runtime); return;
    }
    // 0x1d9f8c: 0x8c500048
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1d9f90: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1d9f94: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x1d9f9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d9f9c
// Address: 0x1d9f9c - 0x1d9fb8

void entry_1d9f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1d9f9c: 0x8fa30040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d9fa0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1d9fa4: 0x14620006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1073));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1D9FC0; return;
    }
    // 0x1d9fac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1d9fb0: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1d9fb8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1d9fb8
// Address: 0x1d9fb8 - 0x1da024

void entry_1d9fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1d9fb8) {
        switch (ctx->pc) {
            case 0x1d9fc0: ctx->pc = 0; goto label_1d9fc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1d9fb8: 0x8fa30040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1d9fbc: 0x28620431
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1073));
label_1d9fc0:
    // 0x1d9fc0: 0x10400061
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1071));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1da148(rdram, ctx, runtime); return;
    }
    // 0x1d9fc8: 0x14400060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA14C; return;
    }
    // 0x1d9fd0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1d9fd4: 0xc6420b10
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 2832)); ctx->f[2] = *(float*)&val; }
    // 0x1d9fd8: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1d9fdc: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1d9fe0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1d9fe4: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1d9fe8: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1d9fec: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1d9ff0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1d9ff4: 0x0
    // NOP
    // 0x1d9ff8: 0x45020055
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
        ctx->pc = 0x1DA150; return;
    }
    // 0x1da000: 0x8e420830
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2096)));
    // 0x1da004: 0x10400051
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA14C; return;
    }
    // 0x1da00c: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1da010: 0x24060019
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 25));
    // 0x1da014: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1da018: 0x24080010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1da01c: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x1da024);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1da024
// Address: 0x1da024 - 0x1da04c

void entry_1da024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da024) {
        switch (ctx->pc) {
            case 0x1da038: ctx->pc = 0; goto label_1da038;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da024: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1da028: 0x1a80000d
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x1DA060; return;
    }
    // 0x1da030: 0x3a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1da034: 0x280802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_1da038:
    // 0x1da038: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1da03c: 0x52440006
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 4)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
        ctx->pc = 0x1DA058; return;
    }
    // 0x1da044: 0xc0761d0
    SET_GPR_U32(ctx, 31, 0x1da04c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FIsSuvAheadOf__FP3SUVT0(rdram, ctx, runtime); return;
}


// Function: entry_1da04c
// Address: 0x1da04c - 0x1da0a4

void entry_1da04c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da04c) {
        switch (ctx->pc) {
            case 0x1da058: ctx->pc = 0; goto label_1da058;
            case 0x1da060: ctx->pc = 0; goto label_1da060;
            case 0x1da07c: ctx->pc = 0; goto label_1da07c;
            case 0x1da090: ctx->pc = 0; goto label_1da090;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da04c: 0x26630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1da050: 0x62980b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 3));
    // 0x1da054: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
label_1da058:
    // 0x1da058: 0x1600fff7
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA038; return;
    }
label_1da060:
    // 0x1da060: 0x8e420b08
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2824)));
    // 0x1da064: 0x56620005
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 2824), GPR_U32(ctx, 19));
        goto label_1da07c;
    }
    // 0x1da06c: 0x8e420b0c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2828)));
    // 0x1da070: 0x12820036
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DA14C; return;
    }
    // 0x1da078: 0xae530b08
    WRITE32(ADD32(GPR_U32(ctx, 18), 2824), GPR_U32(ctx, 19));
label_1da07c:
    // 0x1da07c: 0x26a21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x1da080: 0xae540b0c
    WRITE32(ADD32(GPR_U32(ctx, 18), 2828), GPR_U32(ctx, 20));
    // 0x1da084: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1da088: 0x1000002f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 2832), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1da148(rdram, ctx, runtime); return;
    }
label_1da090:
    // 0x1da090: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1da094: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1da098: 0x2406042c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1068));
    // 0x1da09c: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1da0a4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1da0a4
// Address: 0x1da0a4 - 0x1da0bc

void entry_1da0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da0a4: 0x10400028
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 68));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1da148(rdram, ctx, runtime); return;
    }
    // 0x1da0ac: 0x8c510048
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1da0b0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1da0b4: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x1da0bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1da0bc
// Address: 0x1da0bc - 0x1da0d8

void entry_1da0bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da0bc: 0x8fa30044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1da0c0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1da0c4: 0x14620006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1071));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DA0E0; return;
    }
    // 0x1da0cc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1da0d0: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1da0d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1da0d8
// Address: 0x1da0d8 - 0x1da110

void entry_1da0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da0d8) {
        switch (ctx->pc) {
            case 0x1da0e0: ctx->pc = 0; goto label_1da0e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da0d8: 0x8fa30044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1da0dc: 0x2402042f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1071));
label_1da0e0:
    // 0x1da0e0: 0x1462001a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DA14C; return;
    }
    // 0x1da0e8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1da0ec: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1da0f0: 0x8c6551d4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 20948)));
    // 0x1da0f4: 0x8c8226ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 9900)));
    // 0x1da0f8: 0x45102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 5)));
    // 0x1da0fc: 0x14400006
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA118; return;
    }
    // 0x1da104: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1da108: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1da110);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1074));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1da110
// Address: 0x1da110 - 0x1da134

void entry_1da110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da110) {
        switch (ctx->pc) {
            case 0x1da118: ctx->pc = 0; goto label_1da118;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da110: 0x1000000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA14C; return;
    }
label_1da118:
    // 0x1da118: 0x8c62292c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 10540)));
    // 0x1da11c: 0x45102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 5)));
    // 0x1da120: 0x1440000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA14C; return;
    }
    // 0x1da128: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1da12c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1da134);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1073));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1da134
// Address: 0x1da134 - 0x1da148

void entry_1da134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da134: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1da138: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1da13c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1da140: 0xc054788
    SET_GPR_U32(ctx, 31, 0x1da148);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    OnDifficultyPlayerDeath(rdram, ctx, runtime); return;
}


// Function: entry_1da148
// Address: 0x1da148 - 0x1da170

void entry_1da148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da148) {
        switch (ctx->pc) {
            case 0x1da14c: ctx->pc = 0; goto label_1da14c;
            case 0x1da150: ctx->pc = 0; goto label_1da150;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da148: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_1da14c:
    // 0x1da14c: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_1da150:
    // 0x1da150: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1da154: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1da158: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1da15c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1da160: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1da164: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1da16c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1da170; return;
}


// Function: FUN_001da170
// Address: 0x1da170 - 0x1da1bc

void FUN_001da170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da170) {
        switch (ctx->pc) {
            case 0x1da1a8: ctx->pc = 0; goto label_1da1a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da170: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x1da174: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x1da178: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x1da17c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1da180: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x1da184: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1da188: 0x8c830b30
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 2864)));
    // 0x1da18c: 0x10600006
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1da1a8;
    }
    // 0x1da194: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1da198: 0x1062001e
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DA214; return;
    }
    // 0x1da1a0: 0x1000001f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA220; return;
    }
label_1da1a8:
    // 0x1da1a8: 0x8c840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x1da1ac: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1da1b0: 0x2406042c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1068));
    // 0x1da1b4: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1da1bc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1da1bc
// Address: 0x1da1bc - 0x1da1d0

void entry_1da1bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da1bc: 0x10400018
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA220; return;
    }
    // 0x1da1c4: 0x8c500048
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1da1c8: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x1da1d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1da1d0
// Address: 0x1da1d0 - 0x1da1ec

void entry_1da1d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da1d0: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1da1d4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1da1d8: 0x14620006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1073));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DA1F4; return;
    }
    // 0x1da1e0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1da1e4: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1da1ec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1da1ec
// Address: 0x1da1ec - 0x1da20c

void entry_1da1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da1ec) {
        switch (ctx->pc) {
            case 0x1da1f4: ctx->pc = 0; goto label_1da1f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da1ec: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1da1f0: 0x28620431
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1073));
label_1da1f4:
    // 0x1da1f4: 0x1040000a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1071));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA220; return;
    }
    // 0x1da1fc: 0x14400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA220; return;
    }
    // 0x1da204: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x1da20c);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1da20c
// Address: 0x1da20c - 0x1da21c

void entry_1da20c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da20c) {
        switch (ctx->pc) {
            case 0x1da214: ctx->pc = 0; goto label_1da214;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da20c: 0x10000004
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA220; return;
    }
label_1da214:
    // 0x1da214: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x1da21c);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1da21c
// Address: 0x1da21c - 0x1da238

void entry_1da21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da21c) {
        switch (ctx->pc) {
            case 0x1da220: ctx->pc = 0; goto label_1da220;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da21c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1da220:
    // 0x1da220: 0x12200011
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA268; return;
    }
    // 0x1da228: 0x8c83d848
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294957128)));
    // 0x1da22c: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1da230: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da238);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294957128));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da238
// Address: 0x1da238 - 0x1da24c

void entry_1da238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da238: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1da23c: 0x8c83d5c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294956488)));
    // 0x1da240: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1da244: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da24c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294956488));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da24c
// Address: 0x1da24c - 0x1da260

void entry_1da24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da24c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1da250: 0x8c83dac8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294957768)));
    // 0x1da254: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1da258: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da260);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294957768));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da260
// Address: 0x1da260 - 0x1da278

void entry_1da260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da260) {
        switch (ctx->pc) {
            case 0x1da268: ctx->pc = 0; goto label_1da268;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da260: 0x1000000f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1da2a0(rdram, ctx, runtime); return;
    }
label_1da268:
    // 0x1da268: 0x8c83d848
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294957128)));
    // 0x1da26c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1da270: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da278);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294957128));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da278
// Address: 0x1da278 - 0x1da28c

void entry_1da278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da278: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1da27c: 0x8c83d5c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294956488)));
    // 0x1da280: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1da284: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da28c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294956488));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da28c
// Address: 0x1da28c - 0x1da2a0

void entry_1da28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da28c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1da290: 0x8c83dac8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294957768)));
    // 0x1da294: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1da298: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da2a0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294957768));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da2a0
// Address: 0x1da2a0 - 0x1da2b8

void entry_1da2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da2a0: 0x1240000c
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA2D4; return;
    }
    // 0x1da2a8: 0x8c832430
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9264)));
    // 0x1da2ac: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1da2b0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da2b8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9264));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da2b8
// Address: 0x1da2b8 - 0x1da2cc

void entry_1da2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da2b8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1da2bc: 0x8c8326b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9904)));
    // 0x1da2c0: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1da2c4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da2cc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9904));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da2cc
// Address: 0x1da2cc - 0x1da2e4

void entry_1da2cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da2cc) {
        switch (ctx->pc) {
            case 0x1da2d4: ctx->pc = 0; goto label_1da2d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da2cc: 0x1000000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA2FC; return;
    }
label_1da2d4:
    // 0x1da2d4: 0x8c832430
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9264)));
    // 0x1da2d8: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1da2dc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da2e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9264));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da2e4
// Address: 0x1da2e4 - 0x1da2f8

void entry_1da2e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da2e4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1da2e8: 0x8c8326b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9904)));
    // 0x1da2ec: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1da2f0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da2f8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9904));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da2f8
// Address: 0x1da2f8 - 0x1da310

void entry_1da2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da2f8) {
        switch (ctx->pc) {
            case 0x1da2fc: ctx->pc = 0; goto label_1da2fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da2f8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1da2fc:
    // 0x1da2fc: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1da300: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1da304: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1da308: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSuvInternalXps__FP3SUV
// Address: 0x1da310 - 0x1da320

void entry_1da3ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da3ec) {
        switch (ctx->pc) {
            case 0x1da408: ctx->pc = 0; goto label_1da408;
            case 0x1da40c: ctx->pc = 0; goto label_1da40c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da3ec: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1da3f0: 0x78620190
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 400)));
    // 0x1da3f4: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x1da3f8: 0x12600003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1da408;
    }
    // 0x1da400: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1552)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1da40c;
    }
label_1da408:
    // 0x1da408: 0xc6200614
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1556)); ctx->f[0] = *(float*)&val; }
label_1da40c:
    // 0x1da40c: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1da410: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x1da414: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1da418: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1da41c: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1da420: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1da428);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1da428
// Address: 0x1da428 - 0x1da4a8

void entry_1da428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da428) {
        switch (ctx->pc) {
            case 0x1da43c: ctx->pc = 0; goto label_1da43c;
            case 0x1da440: ctx->pc = 0; goto label_1da440;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da428: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1da42c: 0x12600003
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1da43c;
    }
    // 0x1da434: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1552)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1da440;
    }
label_1da43c:
    // 0x1da43c: 0xc6200614
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1556)); ctx->f[0] = *(float*)&val; }
label_1da440:
    // 0x1da440: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1da444: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1da448: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1da44c: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1da450: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1da454: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1da458: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1da45c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1da460: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1da464: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1da468: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1da46c: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1da470: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1da474: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1da478: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1da47c: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1da480: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1da484: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1da488: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1da48c: 0x4be502bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1da490: 0x4be41108
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1da494: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1da498: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1da49c: 0xf8440000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1da4a0: 0xc050724
    SET_GPR_U32(ctx, 31, 0x1da4a8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    ClsgClipEdgeToObjectPruned__FP2SOP3BSPP6VECTORT2iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1da4a8
// Address: 0x1da4a8 - 0x1da568

void entry_1da4a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da4a8) {
        switch (ctx->pc) {
            case 0x1da52c: ctx->pc = 0; goto label_1da52c;
            case 0x1da534: ctx->pc = 0; goto label_1da534;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da4a8: 0x1840005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[1] = *(float*)&val; }
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1DA61C; return;
    }
    // 0x1da4b0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1da4b4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1da4b8: 0x0
    // NOP
    // 0x1da4bc: 0x45020058
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
        ctx->pc = 0x1DA620; return;
    }
    // 0x1da4c4: 0x8e2206a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1696)));
    // 0x1da4c8: 0x8e43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1da4cc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1da4d0: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1da4d4: 0x14620017
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1da534;
    }
    // 0x1da4dc: 0xda2300f0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 240)));
    // 0x1da4e0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1da4e4: 0xda410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x1da4e8: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1da4ec: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1da4f0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1da4f4: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1da4f8: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1da4fc: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1da500: 0x4bc310aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1da504: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1da508: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1da50c: 0x4b02288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1da510: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x1da514: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1da518: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1da51c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1da520: 0x0
    // NOP
    // 0x1da524: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1da52c;
    }
label_1da52c:
    // 0x1da52c: 0x1040000e
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1da568(rdram, ctx, runtime); return;
    }
label_1da534:
    // 0x1da534: 0x24830001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1da538: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1da53c: 0x26470040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 64));
    // 0x1da540: 0x7e460030
    WRITE128(ADD32(GPR_U32(ctx, 18), 48), GPR_VEC(ctx, 6));
    // 0x1da544: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1da548: 0xae43000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 3));
    // 0x1da54c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1da550: 0x7e420020
    WRITE128(ADD32(GPR_U32(ctx, 18), 32), GPR_VEC(ctx, 2));
    // 0x1da554: 0x26460020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 32));
    // 0x1da558: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1da55c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1da560: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1da568);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1da568
// Address: 0x1da568 - 0x1da5a4

void entry_1da568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da568: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1da56c: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1da570: 0x5053002b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 19)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
        ctx->pc = 0x1DA620; return;
    }
    // 0x1da578: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1da57c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1da580: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1da584: 0x10400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA5AC; return;
    }
    // 0x1da58c: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x1da590: 0x54400023
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
        ctx->pc = 0x1DA620; return;
    }
    // 0x1da598: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1da59c: 0xc04ef80
    SET_GPR_U32(ctx, 31, 0x1da5a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PrimeBomb__FP4BOMBf(rdram, ctx, runtime); return;
}


// Function: entry_1da5a4
// Address: 0x1da5a4 - 0x1da5b4

void entry_1da5a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da5a4) {
        switch (ctx->pc) {
            case 0x1da5ac: ctx->pc = 0; goto label_1da5ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da5a4: 0x1000001e
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA620; return;
    }
label_1da5ac:
    // 0x1da5ac: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1da5b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 37));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1da5b4
// Address: 0x1da5b4 - 0x1da5d4

void entry_1da5b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da5b4: 0x5040001a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
        ctx->pc = 0x1DA620; return;
    }
    // 0x1da5bc: 0x8e020678
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1656)));
    // 0x1da5c0: 0x54400017
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
        ctx->pc = 0x1DA620; return;
    }
    // 0x1da5c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1da5cc: 0xc04f6ca
    SET_GPR_U32(ctx, 31, 0x1da5d4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FCheckBrkTouchObject__FP3BRKP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1da5d4
// Address: 0x1da5d4 - 0x1da5f0

void entry_1da5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da5d4: 0x10400011
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA61C; return;
    }
    // 0x1da5dc: 0x8e0506c4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1732)));
    // 0x1da5e0: 0x50b20004
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1736)));
        ctx->pc = 0x1DA5F4; return;
    }
    // 0x1da5e8: 0xc06ec16
    SET_GPR_U32(ctx, 31, 0x1da5f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetSoCnstrForce__FP2SO5CNSTR(rdram, ctx, runtime); return;
}


// Function: entry_1da5f0
// Address: 0x1da5f0 - 0x1da604

void entry_1da5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da5f0) {
        switch (ctx->pc) {
            case 0x1da5f4: ctx->pc = 0; goto label_1da5f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da5f0: 0x8e0506c8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1736)));
label_1da5f4:
    // 0x1da5f4: 0x50b20004
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 18)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 872)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1DA608; return;
    }
    // 0x1da5fc: 0xc06ec32
    SET_GPR_U32(ctx, 31, 0x1da604);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetSoCnstrTorque__FP2SO5CNSTR(rdram, ctx, runtime); return;
}


// Function: entry_1da604
// Address: 0x1da604 - 0x1da644

void entry_1da604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da604) {
        switch (ctx->pc) {
            case 0x1da608: ctx->pc = 0; goto label_1da608;
            case 0x1da61c: ctx->pc = 0; goto label_1da61c;
            case 0x1da620: ctx->pc = 0; goto label_1da620;
            case 0x1da634: ctx->pc = 0; goto label_1da634;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da604: 0xc6000368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 872)); ctx->f[0] = *(float*)&val; }
label_1da608:
    // 0x1da608: 0xc60106c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1728)); ctx->f[1] = *(float*)&val; }
    // 0x1da60c: 0xae130678
    WRITE32(ADD32(GPR_U32(ctx, 16), 1656), GPR_U32(ctx, 19));
    // 0x1da610: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1da614: 0xae1106cc
    WRITE32(ADD32(GPR_U32(ctx, 16), 1740), GPR_U32(ctx, 17));
    // 0x1da618: 0xe6000368
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 872), *(uint32_t*)&val); }
label_1da61c:
    // 0x1da61c: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
label_1da620:
    // 0x1da620: 0x2e820004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), 4));
    // 0x1da624: 0x1440ff5e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 96));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA3A0; return;
    }
    // 0x1da62c: 0x10000020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA6B0; return;
    }
label_1da634:
    // 0x1da634: 0x1080001e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA6B0; return;
    }
    // 0x1da63c: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1da644);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1da644
// Address: 0x1da644 - 0x1da684

void entry_1da644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da644: 0x1040001a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA6B0; return;
    }
    // 0x1da64c: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1da650: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1da654: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x1da658: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1da65c: 0x1040000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA68C; return;
    }
    // 0x1da664: 0x8e260b4c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 2892)));
    // 0x1da668: 0xc48c03cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 972)); ctx->f[12] = *(float*)&val; }
    // 0x1da66c: 0x262a0b74
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 17), 2932));
    // 0x1da670: 0x8cc703f0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 6), 1008)));
    // 0x1da674: 0x24850140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 320));
    // 0x1da678: 0x8cc803f8
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 6), 1016)));
    // 0x1da67c: 0xc061e70
    SET_GPR_U32(ctx, 31, 0x1da684);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    MarkSoContactsSphereBsp__FP2SOP6VECTORfT0iP3BSPT5PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1da684
// Address: 0x1da684 - 0x1da6ac

void entry_1da684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da684) {
        switch (ctx->pc) {
            case 0x1da68c: ctx->pc = 0; goto label_1da68c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da684: 0x1000000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA6B0; return;
    }
label_1da68c:
    // 0x1da68c: 0x12400007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_1da6ac(rdram, ctx, runtime); return;
    }
    // 0x1da694: 0x8e240b4c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 2892)));
    // 0x1da698: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1da69c: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1da6a0: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1da6a4: 0xc061aea
    SET_GPR_U32(ctx, 31, 0x1da6ac);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 2932));
    MarkSoContactsBspBsp__FP2SOT0iP3BSPT3PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1da6ac
// Address: 0x1da6ac - 0x1da6e0

void entry_1da6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da6ac) {
        switch (ctx->pc) {
            case 0x1da6b0: ctx->pc = 0; goto label_1da6b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da6ac: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
label_1da6b0:
    // 0x1da6b0: 0x7bbe0120
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1da6b4: 0x7bb70110
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1da6b8: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1da6bc: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1da6c0: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1da6c4: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1da6c8: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1da6cc: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1da6d0: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1da6d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1da6dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1da6e0; return;
}


// Function: AdjustSuvNewXp__FP3SUVP2XPi
// Address: 0x1da6e0 - 0x1da7e0

void entry_1da81c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da81c) {
        switch (ctx->pc) {
            case 0x1da838: ctx->pc = 0; goto label_1da838;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da81c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1da820: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1da824: 0x27b70060
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1da828: 0x27b40090
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1da82c: 0x24561858
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1da830: 0x247583d0
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 3), 4294935504));
    // 0x1da834: 0x24020060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 96));
label_1da838:
    // 0x1da838: 0xc6c20008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1da83c: 0x2621018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1da840: 0x244206b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1712));
    // 0x1da844: 0x2228021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1da848: 0xc6000050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 80)); ctx->f[0] = *(float*)&val; }
    // 0x1da84c: 0xc6010054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 84)); ctx->f[1] = *(float*)&val; }
    // 0x1da850: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1da854: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1da858: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1da85c: 0xe6010054
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 84), *(uint32_t*)&val); }
    // 0x1da860: 0x8e2206a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1696)));
    // 0x1da864: 0x54620011
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1DA8AC; return;
    }
    // 0x1da86c: 0x26020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1da870: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1da874: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1da878: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1da87c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1da880: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1da888);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 32));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1da888
// Address: 0x1da888 - 0x1da8cc

void entry_1da888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da888) {
        switch (ctx->pc) {
            case 0x1da89c: ctx->pc = 0; goto label_1da89c;
            case 0x1da8a0: ctx->pc = 0; goto label_1da8a0;
            case 0x1da8ac: ctx->pc = 0; goto label_1da8ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da888: 0x2a620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 2));
    // 0x1da88c: 0x10400003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1da89c;
    }
    // 0x1da894: 0x10000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1552)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1da8a0;
    }
label_1da89c:
    // 0x1da89c: 0xc6200614
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1556)); ctx->f[0] = *(float*)&val; }
label_1da8a0:
    // 0x1da8a0: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1da8a4: 0x1000000b
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 24), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA8D4; return;
    }
label_1da8ac:
    // 0x1da8ac: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1da8b0: 0x7a040010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1da8b4: 0x24665620
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 22048));
    // 0x1da8b8: 0x78450190
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 400)));
    // 0x1da8bc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1da8c0: 0xc6cc0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1da8c4: 0xc07aa06
    SET_GPR_U32(ctx, 31, 0x1da8cc);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 16));
    PosSmooth(rdram, ctx, runtime); return;
}


// Function: entry_1da8cc
// Address: 0x1da8cc - 0x1da8e8

void entry_1da8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da8cc) {
        switch (ctx->pc) {
            case 0x1da8d4: ctx->pc = 0; goto label_1da8d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da8cc: 0x7e020010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 2));
    // 0x1da8d0: 0x2a620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 2));
label_1da8d4:
    // 0x1da8d4: 0x10400006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 4294937888));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA8F0; return;
    }
    // 0x1da8dc: 0xc62c069c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1692)); ctx->f[12] = *(float*)&val; }
    // 0x1da8e0: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1da8e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1da8e8
// Address: 0x1da8e8 - 0x1da91c

void entry_1da8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1da8e8) {
        switch (ctx->pc) {
            case 0x1da8f0: ctx->pc = 0; goto label_1da8f0;
            case 0x1da90c: ctx->pc = 0; goto label_1da90c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1da8e8: 0x10000008
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1da90c;
    }
label_1da8f0:
    // 0x1da8f0: 0x7aa20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1da8f4: 0x7aa30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 21), 16)));
    // 0x1da8f8: 0x7aa40020
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 21), 32)));
    // 0x1da8fc: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x1da900: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    // 0x1da904: 0x7fa40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 4));
    // 0x1da908: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
label_1da90c:
    // 0x1da90c: 0xc60c0054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 84)); ctx->f[12] = *(float*)&val; }
    // 0x1da910: 0x24448d10
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294937872));
    // 0x1da914: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1da91c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1da91c
// Address: 0x1da91c - 0x1da99c

void entry_1da91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da91c: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1da920: 0xdba50040
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1da924: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1da928: 0xdba40060
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1da92c: 0xdba60070
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1da930: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1da934: 0x4bc428bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1da938: 0x4bc4090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1da93c: 0x4bc619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1da940: 0x4bc628bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1da944: 0x4bc6098a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1da948: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1da94c: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1da950: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1da954: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1da958: 0x4bc208ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1da95c: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1da960: 0xfba60010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1da964: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1da968: 0xfba400c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1da96c: 0xfba40090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1da970: 0xfba600d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1da974: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1da978: 0xfba300e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1da97c: 0x1060000c
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1da9b0(rdram, ctx, runtime); return;
    }
    // 0x1da984: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1da988: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1da98c: 0x8c650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1da990: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1da994: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1da99c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1da99c
// Address: 0x1da99c - 0x1da9b0

void entry_1da99c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da99c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1da9a0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1da9a4: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1da9a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da9b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da9b0
// Address: 0x1da9b0 - 0x1da9c8

void entry_1da9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da9b0: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1da9b4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1da9b8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1da9bc: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1da9c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da9c8);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da9c8
// Address: 0x1da9c8 - 0x1da9dc

void entry_1da9c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da9c8: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1da9cc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1da9d0: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1da9d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1da9dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1da9dc
// Address: 0x1da9dc - 0x1daa18

void entry_1da9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1da9dc: 0x2e630004
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 19), 4));
    // 0x1da9e0: 0x1460ff95
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 96));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DA838; return;
    }
    // 0x1da9e8: 0x7bbf0180
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1da9ec: 0x7bbe0170
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1da9f0: 0x7bb70160
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1da9f4: 0x7bb60150
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1da9f8: 0x7bb50140
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1da9fc: 0x7bb40130
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1daa00: 0x7bb30120
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1daa04: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1daa08: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1daa0c: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1daa10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 400));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderSuvSelf__FP3SUVP2CMP2RO
// Address: 0x1daa18 - 0x1daa4c

void entry_1daa4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1daa4c) {
        switch (ctx->pc) {
            case 0x1daa70: ctx->pc = 0; goto label_1daa70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1daa4c: 0x8e620690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1680)));
    // 0x1daa50: 0x10400041
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 19), 272));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1dab58(rdram, ctx, runtime); return;
    }
    // 0x1daa58: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1daa5c: 0x27b20070
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1daa60: 0x27b60060
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1daa64: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1daa68: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1daa6c: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
label_1daa70:
    // 0x1daa70: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1daa74: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1daa78: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1daa7c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1daa80: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1daa84: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1daa88: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1daa8c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1daa90: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1daa94: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1daa98: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1daa9c: 0xac650000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 5));
    // 0x1daaa0: 0x481fff3
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_1daa70;
    }
    // 0x1daaa8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1daaac: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1daab0: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x1daab8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_1daab8
// Address: 0x1daab8 - 0x1daac8

void entry_1daab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1daab8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1daabc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1daac0: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x1daac8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_1daac8
// Address: 0x1daac8 - 0x1dab40

void entry_1daac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1daac8: 0xc7a10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1daacc: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1daad0: 0xc7a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1daad4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1daad8: 0xc7a20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1daadc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1daae0: 0x46000828
    ctx->f[0] = std::max(ctx->f[1], ctx->f[0]);
    // 0x1daae4: 0xdba50070
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1daae8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1daaec: 0x46020868
    ctx->f[1] = std::max(ctx->f[1], ctx->f[2]);
    // 0x1daaf0: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1daaf4: 0xdba30080
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1daaf8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1daafc: 0x4be12958
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1dab00: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1dab04: 0xfba100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1dab08: 0x4be218d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1dab0c: 0xfba50070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1dab10: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1dab14: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1dab18: 0xdba40090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1dab1c: 0x8e620690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1680)));
    // 0x1dab20: 0xda610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 320)));
    // 0x1dab24: 0xd8420100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 256)));
    // 0x1dab28: 0x4bc229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1dab2c: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1dab30: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1dab34: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1dab38: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x1dab40);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1dab40
// Address: 0x1dab40 - 0x1dab58

void entry_1dab40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dab40: 0x8e640690
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1680)));
    // 0x1dab44: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dab48: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1dab4c: 0x8c6200a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 168)));
    // 0x1dab50: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dab58);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dab58
// Address: 0x1dab58 - 0x1dab8c

void entry_1dab58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dab58) {
        switch (ctx->pc) {
            case 0x1dab70: ctx->pc = 0; goto label_1dab70;
            case 0x1dab78: ctx->pc = 0; goto label_1dab78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dab58: 0x8e620b28
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2856)));
    // 0x1dab5c: 0x14400004
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1dab70;
    }
    // 0x1dab64: 0x8e620b2c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2860)));
    // 0x1dab68: 0x10400023
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DABF8; return;
    }
label_1dab70:
    // 0x1dab70: 0x267006c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 1728));
    // 0x1dab74: 0x24120003
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
label_1dab78:
    // 0x1dab78: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dab7c: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1dab80: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1dab84: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1dab8c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1dab8c
// Address: 0x1dab8c - 0x1dabc8

void entry_1dab8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dab8c) {
        switch (ctx->pc) {
            case 0x1dabbc: ctx->pc = 0; goto label_1dabbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dab8c: 0x26310010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    // 0x1dab90: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x1dab94: 0x641fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 96));
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x1DAB78; return;
    }
    // 0x1dab9c: 0x8e640b28
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 2856)));
    // 0x1daba0: 0x10800009
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1dabc8(rdram, ctx, runtime); return;
    }
    // 0x1daba8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1dabac: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1dabb0: 0x12800002
    ctx->f[12] = FPU_MOV_S(ctx->f[13]);
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1dabbc;
    }
    // 0x1dabb8: 0xc68d0040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 64)); ctx->f[13] = *(float*)&val; }
label_1dabbc:
    // 0x1dabbc: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1dabc0: 0xc049a2e
    SET_GPR_U32(ctx, 31, 0x1dabc8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    RenderAloLine__FP3ALOP2CMP6VECTORT2ff(rdram, ctx, runtime); return;
}


// Function: entry_1dabc8
// Address: 0x1dabc8 - 0x1dabf4

void entry_1dabc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dabc8) {
        switch (ctx->pc) {
            case 0x1dabec: ctx->pc = 0; goto label_1dabec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dabc8: 0x8e640b2c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 2860)));
    // 0x1dabcc: 0x10800009
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1dabf4(rdram, ctx, runtime); return;
    }
    // 0x1dabd4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1dabd8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1dabdc: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1dabe0: 0x12800002
    ctx->f[12] = FPU_MOV_S(ctx->f[13]);
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1dabec;
    }
    // 0x1dabe8: 0xc68d0040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 64)); ctx->f[13] = *(float*)&val; }
label_1dabec:
    // 0x1dabec: 0xc049a2e
    SET_GPR_U32(ctx, 31, 0x1dabf4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    RenderAloLine__FP3ALOP2CMP6VECTORT2ff(rdram, ctx, runtime); return;
}


// Function: entry_1dabf4
// Address: 0x1dabf4 - 0x1dac20

void entry_1dabf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dabf4) {
        switch (ctx->pc) {
            case 0x1dabf8: ctx->pc = 0; goto label_1dabf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dabf4: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
label_1dabf8:
    // 0x1dabf8: 0x7bb60110
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1dabfc: 0x7bb50100
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1dac00: 0x7bb400f0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1dac04: 0x7bb300e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1dac08: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1dac0c: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1dac10: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1dac14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dac1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dac20; return;
}


// Function: UpdateSuvBounds__FP3SUV
// Address: 0x1dac20 - 0x1dac44

void entry_1dac44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dac44) {
        switch (ctx->pc) {
            case 0x1dac48: ctx->pc = 0; goto label_1dac48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dac44: 0x0
    // NOP
label_1dac48:
    // 0x1dac48: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1dac4c: 0x1040000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1dac88(rdram, ctx, runtime); return;
    }
    // 0x1dac54: 0x78420190
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 400)));
    // 0x1dac58: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dac5c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1dac60: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1dac64: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1dac6c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1dac6c
// Address: 0x1dac6c - 0x1dac88

void entry_1dac6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dac6c) {
        switch (ctx->pc) {
            case 0x1dac7c: ctx->pc = 0; goto label_1dac7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dac6c: 0x2a420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 2));
    // 0x1dac70: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1556)); ctx->f[12] = *(float*)&val; }
        goto label_1dac7c;
    }
    // 0x1dac78: 0xc60c0610
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1552)); ctx->f[12] = *(float*)&val; }
label_1dac7c:
    // 0x1dac7c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dac80: 0xc06e108
    SET_GPR_U32(ctx, 31, 0x1dac88);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ExtendSoBounds__FP2SOP6VECTORf(rdram, ctx, runtime); return;
}


// Function: entry_1dac88
// Address: 0x1dac88 - 0x1dacb0

void entry_1dac88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dac88: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1dac8c: 0x2e420004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 4));
    // 0x1dac90: 0x1440ffed
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 96));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DAC48; return;
    }
    // 0x1dac98: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dac9c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1daca0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1daca4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1daca8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CollectSuvPrize__FP3SUV3PCKP3ALO
// Address: 0x1dacb0 - 0x1dace0

void entry_1dace0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dace0: 0x8e040b78
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2936)));
    // 0x1dace4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1dace8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1dacec: 0x8c620148
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 328)));
    // 0x1dacf0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dacf8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dacf8
// Address: 0x1dacf8 - 0x1dad10

void entry_1dacf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dacf8) {
        switch (ctx->pc) {
            case 0x1dad00: ctx->pc = 0; goto label_1dad00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dacf8: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DAD14; return;
    }
label_1dad00:
    // 0x1dad00: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dad04: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1dad08: 0xc064932
    SET_GPR_U32(ctx, 31, 0x1dad10);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    CollectPoPrize__FP2PO3PCKP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1dad10
// Address: 0x1dad10 - 0x1dad28

void entry_1dad10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dad10) {
        switch (ctx->pc) {
            case 0x1dad14: ctx->pc = 0; goto label_1dad14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dad10: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1dad14:
    // 0x1dad14: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dad18: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dad1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dad20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSuvShapes__FP3SUV
// Address: 0x1dad28 - 0x1dad74

void entry_1dad74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dad74: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1dad78: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dad7c: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1dad80: 0x8e050830
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 2096)));
    // 0x1dad84: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1dad88: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1dad8c: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1dad90: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1dad94: 0xc60c0838
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2104)); ctx->f[12] = *(float*)&val; }
    // 0x1dad98: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1dad9c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1dada0: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1dada4: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1dada8: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1dadac: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1dadb0: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1dadb4: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1dadb8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1dadbc: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1dadc0: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1dadc4: 0x8ca40034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 52)));
    // 0x1dadc8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1dadcc: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x1dadd0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dadd8);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dadd8
// Address: 0x1dadd8 - 0x1dae18

void entry_1dadd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dadd8) {
        switch (ctx->pc) {
            case 0x1dae08: ctx->pc = 0; goto label_1dae08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dadd8: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1daddc: 0xda020100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x1dade0: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dade4: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1dade8: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1dadec: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1dadf0: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1dadf4: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1dadf8: 0xe600083c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2108), *(uint32_t*)&val); }
    // 0x1dadfc: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1dae00: 0xae020840
    WRITE32(ADD32(GPR_U32(ctx, 16), 2112), GPR_U32(ctx, 2));
    // 0x1dae04: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1dae08:
    // 0x1dae08: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dae0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dae14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dae18; return;
}


// Function: UpdateSuvXfWorld__FP3SUV
// Address: 0x1dae18 - 0x1dae2c

void entry_1dae2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dae2c: 0xc076b4a
    SET_GPR_U32(ctx, 31, 0x1dae34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateSuvShapes__FP3SUV(rdram, ctx, runtime); return;
}


// Function: entry_1dae34
// Address: 0x1dae34 - 0x1dae48

void entry_1dae34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dae34: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dae38: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dae3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dae44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dae48; return;
}


// Function: GetSuvCpdefi__FP3SUVfP6CPDEFI
// Address: 0x1dae48 - 0x1dae58

void entry_1dae58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dae58: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dae5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dae64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dae68; return;
}


// Function: OnSuvActive__FP3SUViP2PO
// Address: 0x1dae68 - 0x1dae84

void entry_1dae84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dae84: 0x12000014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 2136));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DAED8; return;
    }
    // 0x1dae8c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dae90: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x1dae94: 0x2442d5c8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294956488));
    // 0x1dae98: 0xace5daac
    WRITE32(ADD32(GPR_U32(ctx, 7), 4294957740), GPR_U32(ctx, 5));
    // 0x1dae9c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1daea0: 0x26260b04
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 2820));
    // 0x1daea4: 0x2463dac8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294957768));
    // 0x1daea8: 0xac460268
    WRITE32(ADD32(GPR_U32(ctx, 2), 616), GPR_U32(ctx, 6));
    // 0x1daeac: 0x26240b0c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 2828));
    // 0x1daeb0: 0xac640268
    WRITE32(ADD32(GPR_U32(ctx, 3), 616), GPR_U32(ctx, 4));
    // 0x1daeb4: 0x26290b00
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 2816));
    // 0x1daeb8: 0xac490264
    WRITE32(ADD32(GPR_U32(ctx, 2), 612), GPR_U32(ctx, 9));
    // 0x1daebc: 0x26280b08
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 2824));
    // 0x1daec0: 0xac680264
    WRITE32(ADD32(GPR_U32(ctx, 3), 612), GPR_U32(ctx, 8));
    // 0x1daec4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1daec8: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x1daed0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_1daed0
// Address: 0x1daed0 - 0x1daef4

void entry_1daed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1daed0) {
        switch (ctx->pc) {
            case 0x1daed8: ctx->pc = 0; goto label_1daed8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1daed0: 0x10000009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DAEF8; return;
    }
label_1daed8:
    // 0x1daed8: 0x8e230b34
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 2868)));
    // 0x1daedc: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1daee0: 0x14620005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DAEF8; return;
    }
    // 0x1daee8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1daeec: 0xc076c8e
    SET_GPR_U32(ctx, 31, 0x1daef4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSuvSuvs__FP3SUV4SUVS(rdram, ctx, runtime); return;
}


// Function: entry_1daef4
// Address: 0x1daef4 - 0x1daf08

void entry_1daef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1daef4) {
        switch (ctx->pc) {
            case 0x1daef8: ctx->pc = 0; goto label_1daef8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1daef4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1daef8:
    // 0x1daef8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1daefc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1daf00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleSuvMessage__FP3SUV5MSGIDPv
// Address: 0x1daf08 - 0x1daf2c

void entry_1daf2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1daf2c) {
        switch (ctx->pc) {
            case 0x1daf98: ctx->pc = 0; goto label_1daf98;
            case 0x1dafa0: ctx->pc = 0; goto label_1dafa0;
            case 0x1dafa4: ctx->pc = 0; goto label_1dafa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1daf2c: 0x2402000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1daf30: 0x1602001b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1dafa0;
    }
    // 0x1daf38: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1daf3c: 0x24020426
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1062));
    // 0x1daf40: 0x54620018
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        goto label_1dafa4;
    }
    // 0x1daf48: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1daf4c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1daf50: 0x24472430
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 9264));
    // 0x1daf54: 0x8c6351d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 20948)));
    // 0x1daf58: 0x8ce5027c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 636)));
    // 0x1daf5c: 0xa3102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 3)));
    // 0x1daf60: 0x1040000f
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1dafa0;
    }
    // 0x1daf68: 0x244626b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 9904));
    // 0x1daf6c: 0x8cc4027c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 636)));
    // 0x1daf70: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1daf74: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        goto label_1dafa4;
    }
    // 0x1daf7c: 0x8e2206cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1740)));
    // 0x1daf80: 0x8c430050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x1daf84: 0x14720004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 18)) {
        goto label_1daf98;
    }
    // 0x1daf8c: 0x24a20001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1daf90: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 7), 636), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dafa0;
    }
label_1daf98:
    // 0x1daf98: 0xacc2027c
    WRITE32(ADD32(GPR_U32(ctx, 6), 636), GPR_U32(ctx, 2));
    // 0x1daf9c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1dafa0:
    // 0x1dafa0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1dafa4:
    // 0x1dafa4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dafa8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dafac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dafb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dafb8; return;
}


// Function: SetSuvTrack__FP3SUVP5SHAPE
// Address: 0x1dafb8 - 0x1db004

void entry_1db004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db004: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1db008: 0xc076b4a
    SET_GPR_U32(ctx, 31, 0x1db010);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UpdateSuvShapes__FP3SUV(rdram, ctx, runtime); return;
}


// Function: entry_1db010
// Address: 0x1db010 - 0x1db030

void entry_1db010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db010: 0xc6000840
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 2112)); ctx->f[0] = *(float*)&val; }
    // 0x1db014: 0x8e020830
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2096)));
    // 0x1db018: 0xe6000844
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2116), *(uint32_t*)&val); }
    // 0x1db01c: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1db020: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1db024: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1db028: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1db030);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1db030
// Address: 0x1db030 - 0x1db060

void entry_1db030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1db030) {
        switch (ctx->pc) {
            case 0x1db048: ctx->pc = 0; goto label_1db048;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1db030: 0x8e030870
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
    // 0x1db034: 0x1860001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 2100), *(uint32_t*)&val); }
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1DB0A8; return;
    }
    // 0x1db03c: 0x26120884
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 2180));
    // 0x1db040: 0x26110874
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 2164));
    // 0x1db044: 0x0
    // NOP
label_1db048:
    // 0x1db048: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1db04c: 0x54400011
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
        ctx->pc = 0x1DB094; return;
    }
    // 0x1db054: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1db058: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1db060);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1db060
// Address: 0x1db060 - 0x1db090

void entry_1db060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db060: 0x8e020830
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2096)));
    // 0x1db064: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1db068: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1db06c: 0x8c620028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 40)));
    // 0x1db070: 0x10400007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1db090(rdram, ctx, runtime); return;
    }
    // 0x1db078: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1db07c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1db080: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1db084: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1db088: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1db090);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1db090
// Address: 0x1db090 - 0x1db0c8

void entry_1db090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1db090) {
        switch (ctx->pc) {
            case 0x1db094: ctx->pc = 0; goto label_1db094;
            case 0x1db0a8: ctx->pc = 0; goto label_1db0a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1db090: 0x8e020870
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2160)));
label_1db094:
    // 0x1db094: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1db098: 0x26520028
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 40));
    // 0x1db09c: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1db0a0: 0x1440ffe9
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 40));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DB048; return;
    }
label_1db0a8:
    // 0x1db0a8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1db0ac: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1db0b0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1db0b4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1db0b8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1db0bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1db0c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1db0c8; return;
}


// Function: SetSuvLine__FP3SUVP5SHAPE
// Address: 0x1db0c8 - 0x1db104

void entry_1db104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db104: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1db108: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddSuvCheckPoint__FP3SUVP3VOL
// Address: 0x1db110 - 0x1db1a0

void entry_1db1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db1a0: 0x8e220830
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 2096)));
    // 0x1db1a4: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1db1a8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1db1ac: 0x8c620028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 40)));
    // 0x1db1b0: 0x10400007
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1db1d0(rdram, ctx, runtime); return;
    }
    // 0x1db1b8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1db1bc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1db1c0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1db1c4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1db1c8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1db1d0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1db1d0
// Address: 0x1db1d0 - 0x1db1e8

void entry_1db1d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db1d0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1db1d4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1db1d8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1db1dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1db1e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1db1e8; return;
}


// Function: AddSuvFeature__FP3SUVP3VOLffP4EXPLT4
// Address: 0x1db1e8 - 0x1db238

void entry_1db270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db270: 0x12020004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DB284; return;
    }
    // 0x1db278: 0xc064a74
    SET_GPR_U32(ctx, 31, 0x1db280);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SwitchToPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1db280
// Address: 0x1db280 - 0x1db290

void entry_1db280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1db280) {
        switch (ctx->pc) {
            case 0x1db284: ctx->pc = 0; goto label_1db284;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1db280: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1db284:
    // 0x1db284: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1db288: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ResetSuv__FP3SUV
// Address: 0x1db290 - 0x1db370

void entry_1db370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db370: 0x7bb20000
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1db374: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1db378: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1db380);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1db380
// Address: 0x1db380 - 0x1db390

void entry_1db380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db380: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1db384: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1db388: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1db390);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1db390
// Address: 0x1db390 - 0x1db3a0

void entry_1db390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db390: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1db394: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1db398: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1db3a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1db3a0
// Address: 0x1db3a0 - 0x1db3b4

void entry_1db3a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db3a0: 0x7ba70030
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1db3a4: 0x701034a9
    SET_GPR_VEC(ctx, 6, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
    // 0x1db3a8: 0x701224a9
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 18)));
    // 0x1db3ac: 0xc076d18
    SET_GPR_U32(ctx, 31, 0x1db3b4);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    VecCombo__FG8VU_FLOATG9VU_VECTORT0T1(rdram, ctx, runtime); return;
}


// Function: entry_1db3b4
// Address: 0x1db3b4 - 0x1db3c0

void entry_1db3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db3b4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1db3b8: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1db3c0);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1db3c0
// Address: 0x1db3c0 - 0x1db448

void entry_1db3c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1db3c0) {
        switch (ctx->pc) {
            case 0x1db410: ctx->pc = 0; goto label_1db410;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1db3c0: 0xc6a10640
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 1600)); ctx->f[1] = *(float*)&val; }
    // 0x1db3c4: 0xc6a20660
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 1632)); ctx->f[2] = *(float*)&val; }
    // 0x1db3c8: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1db3cc: 0xc6a30644
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 1604)); ctx->f[3] = *(float*)&val; }
    // 0x1db3d0: 0x4602a882
    ctx->f[2] = FPU_MUL_S(ctx->f[21], ctx->f[2]);
    // 0x1db3d4: 0xc6a00664
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 1636)); ctx->f[0] = *(float*)&val; }
    // 0x1db3d8: 0x4603a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[3]);
    // 0x1db3dc: 0xc6a40670
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 1648)); ctx->f[4] = *(float*)&val; }
    // 0x1db3e0: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x1db3e4: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1db3e8: 0x4600a000
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1db3ec: 0x46012034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1db3f0: 0xe6a10680
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 21), 1664), *(uint32_t*)&val); }
    // 0x1db3f4: 0x45010006
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 21), 1668), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1db410;
    }
    // 0x1db3fc: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1db400: 0x0
    // NOP
    // 0x1db404: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[4]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1db410;
    }
    // 0x1db40c: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
label_1db410:
    // 0x1db410: 0xe6a1085c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 21), 2140), *(uint32_t*)&val); }
    // 0x1db414: 0xe6a10860
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 21), 2144), *(uint32_t*)&val); }
    // 0x1db418: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1db41c: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1db420: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1db424: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1db428: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1db42c: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1db430: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1db434: 0xc7b500b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[21] = *(float*)&val; }
    // 0x1db438: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1db43c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1db444: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1db448; return;
}


// Function: junk_001DB448
// Address: 0x1db448 - 0x1db460

void entry_1db4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db4a4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1db4a8: 0x2e220200
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 512));
    // 0x1db4ac: 0x1440fffa
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DB498; return;
    }
    // 0x1db4b4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1db4b8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1db4bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1db4c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSw__FP2SW
// Address: 0x1db4c8 - 0x1db4dc

void entry_1db4dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db4dc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1db4e0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1db4e4: 0xc070276
    SET_GPR_U32(ctx, 31, 0x1db4ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetSwDefaultReverb__FP2SW7REVERBKi(rdram, ctx, runtime); return;
}


// Function: entry_1db4ec
// Address: 0x1db4ec - 0x1db4f4

void entry_1db4ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db4ec: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1db4f4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 18432));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1db4f4
// Address: 0x1db4f4 - 0x1db500

void entry_1db4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db4f4: 0x3c040001
    SET_GPR_U32(ctx, 4, ((uint32_t)1 << 16));
    // 0x1db4f8: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1db500);
    WRITE32(ADD32(GPR_U32(ctx, 16), 6872), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1db500
// Address: 0x1db500 - 0x1db50c

void entry_1db500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db500: 0xae021adc
    WRITE32(ADD32(GPR_U32(ctx, 16), 6876), GPR_U32(ctx, 2));
    // 0x1db504: 0xc0771d0
    SET_GPR_U32(ctx, 31, 0x1db50c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitSwAoxa__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1db50c
// Address: 0x1db50c - 0x1db51c

void entry_1db50c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db50c: 0x26041af0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 6896));
    // 0x1db510: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1db514: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db51c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1024));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db51c
// Address: 0x1db51c - 0x1db52c

void entry_1db51c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db51c: 0x26041afc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 6908));
    // 0x1db520: 0x240500e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 224));
    // 0x1db524: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db52c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 256));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db52c
// Address: 0x1db52c - 0x1db53c

void entry_1db52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db52c: 0x26041b08
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 6920));
    // 0x1db530: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1db534: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db53c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db53c
// Address: 0x1db53c - 0x1db54c

void entry_1db53c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db53c: 0x26041b14
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 6932));
    // 0x1db540: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1db544: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db54c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1024));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db54c
// Address: 0x1db54c - 0x1db55c

void entry_1db54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db54c: 0x26041b2c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 6956));
    // 0x1db550: 0x24050140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 320));
    // 0x1db554: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db55c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 384));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db55c
// Address: 0x1db55c - 0x1db56c

void entry_1db55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db55c: 0x26041b40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 6976));
    // 0x1db560: 0x240510c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4288));
    // 0x1db564: 0xc06d78c
    SET_GPR_U32(ctx, 31, 0x1db56c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    CreateSlotheapSwAlign64__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db56c
// Address: 0x1db56c - 0x1db57c

void entry_1db56c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db56c: 0x26041b4c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 6988));
    // 0x1db570: 0x24050580
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1408));
    // 0x1db574: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db57c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db57c
// Address: 0x1db57c - 0x1db58c

void entry_1db57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db57c: 0x26041b58
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7000));
    // 0x1db580: 0x240500ec
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 236));
    // 0x1db584: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db58c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 256));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db58c
// Address: 0x1db58c - 0x1db59c

void entry_1db58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db58c: 0x26041b20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 6944));
    // 0x1db590: 0x240500d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 208));
    // 0x1db594: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db59c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1024));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db59c
// Address: 0x1db59c - 0x1db5ac

void entry_1db59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db59c: 0x26041ba0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7072));
    // 0x1db5a0: 0x24050090
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 144));
    // 0x1db5a4: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db5ac);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db5ac
// Address: 0x1db5ac - 0x1db5bc

void entry_1db5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db5ac: 0x26041bb8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7096));
    // 0x1db5b0: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1db5b4: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db5bc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db5bc
// Address: 0x1db5bc - 0x1db5cc

void entry_1db5bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db5bc: 0x26041b88
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7048));
    // 0x1db5c0: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1db5c4: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db5cc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 256));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db5cc
// Address: 0x1db5cc - 0x1db5dc

void entry_1db5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db5cc: 0x26041bf4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7156));
    // 0x1db5d0: 0x240502e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 736));
    // 0x1db5d4: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db5dc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db5dc
// Address: 0x1db5dc - 0x1db5ec

void entry_1db5dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db5dc: 0x26041bd0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7120));
    // 0x1db5e0: 0x24050070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 112));
    // 0x1db5e4: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db5ec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db5ec
// Address: 0x1db5ec - 0x1db5fc

void entry_1db5ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db5ec: 0x26041c0c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7180));
    // 0x1db5f0: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1db5f4: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db5fc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db5fc
// Address: 0x1db5fc - 0x1db60c

void entry_1db5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db5fc: 0x24060100
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 256));
    // 0x1db600: 0x24050014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1db604: 0xc06d774
    SET_GPR_U32(ctx, 31, 0x1db60c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7192));
    CreateSlotheapSw__FP8SLOTHEAPii(rdram, ctx, runtime); return;
}


// Function: entry_1db60c
// Address: 0x1db60c - 0x1db614

void entry_1db60c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db60c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1db614);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4096));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1db614
// Address: 0x1db614 - 0x1db624

void entry_1db614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db614: 0xae021ed4
    WRITE32(ADD32(GPR_U32(ctx, 16), 7892), GPR_U32(ctx, 2));
    // 0x1db618: 0x26040048
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 72));
    // 0x1db61c: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db624);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 28));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db624
// Address: 0x1db624 - 0x1db630

void entry_1db624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db624: 0x26040054
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 84));
    // 0x1db628: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db630);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 72));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db630
// Address: 0x1db630 - 0x1db63c

void entry_1db630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db630: 0x26040078
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 120));
    // 0x1db634: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db63c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 72));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db63c
// Address: 0x1db63c - 0x1db648

void entry_1db63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db63c: 0x26040060
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 96));
    // 0x1db640: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db648);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db648
// Address: 0x1db648 - 0x1db654

void entry_1db648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db648: 0x2604006c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 108));
    // 0x1db64c: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db654);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1044));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db654
// Address: 0x1db654 - 0x1db660

void entry_1db654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db654: 0x2604003c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 60));
    // 0x1db658: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db660);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 720));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db660
// Address: 0x1db660 - 0x1db66c

void entry_1db660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db660: 0x26041b64
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7012));
    // 0x1db664: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db66c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 52));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db66c
// Address: 0x1db66c - 0x1db678

void entry_1db66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db66c: 0x26041b70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7024));
    // 0x1db670: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db678);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 52));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db678
// Address: 0x1db678 - 0x1db684

void entry_1db678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db678: 0x26041b7c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7036));
    // 0x1db67c: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db684);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 52));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db684
// Address: 0x1db684 - 0x1db690

void entry_1db684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db684: 0x26041b94
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7060));
    // 0x1db688: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db690);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db690
// Address: 0x1db690 - 0x1db69c

void entry_1db690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db690: 0x26041bac
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7084));
    // 0x1db694: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db69c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 100));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db69c
// Address: 0x1db69c - 0x1db6a8

void entry_1db69c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db69c: 0x26041bc4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7108));
    // 0x1db6a0: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db6a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db6a8
// Address: 0x1db6a8 - 0x1db6b4

void entry_1db6a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db6a8: 0x26041be8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7144));
    // 0x1db6ac: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db6b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1040));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db6b4
// Address: 0x1db6b4 - 0x1db6c0

void entry_1db6b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db6b4: 0x26041c00
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7168));
    // 0x1db6b8: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db6c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 184));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db6c0
// Address: 0x1db6c0 - 0x1db6cc

void entry_1db6c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db6c0: 0x26041bdc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7132));
    // 0x1db6c4: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db6cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 100));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db6cc
// Address: 0x1db6cc - 0x1db6d8

void entry_1db6cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db6cc: 0x26041c3c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7228));
    // 0x1db6d0: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db6d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 732));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db6d8
// Address: 0x1db6d8 - 0x1db6e4

void entry_1db6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db6d8: 0x26041c48
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7240));
    // 0x1db6dc: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db6e4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1500));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db6e4
// Address: 0x1db6e4 - 0x1db6f0

void entry_1db6e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db6e4: 0x26041c54
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7252));
    // 0x1db6e8: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db6f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 884));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db6f0
// Address: 0x1db6f0 - 0x1db6fc

void entry_1db6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db6f0: 0x26041c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7264));
    // 0x1db6f4: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db6fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1536));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db6fc
// Address: 0x1db6fc - 0x1db708

void entry_1db6fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db6fc: 0x26041c6c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7276));
    // 0x1db700: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db708);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 144));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db708
// Address: 0x1db708 - 0x1db714

void entry_1db708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db708: 0x26041c78
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7288));
    // 0x1db70c: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db714);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1388));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db714
// Address: 0x1db714 - 0x1db720

void entry_1db714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db714: 0x26041c84
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7300));
    // 0x1db718: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db720);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 80));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db720
// Address: 0x1db720 - 0x1db72c

void entry_1db720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db720: 0x26041c90
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7312));
    // 0x1db724: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db72c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 56));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db72c
// Address: 0x1db72c - 0x1db738

void entry_1db72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db72c: 0x26041c9c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7324));
    // 0x1db730: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db738);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 56));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db738
// Address: 0x1db738 - 0x1db744

void entry_1db738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db738: 0x26041ca8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7336));
    // 0x1db73c: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db744);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2800));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db744
// Address: 0x1db744 - 0x1db750

void entry_1db744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db744: 0x26041cb4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7348));
    // 0x1db748: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db750);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1584));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db750
// Address: 0x1db750 - 0x1db75c

void entry_1db750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db750: 0x26041cc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7360));
    // 0x1db754: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db75c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1584));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db75c
// Address: 0x1db75c - 0x1db768

void entry_1db75c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db75c: 0x26041c24
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7204));
    // 0x1db760: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db768);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db768
// Address: 0x1db768 - 0x1db774

void entry_1db768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db768: 0x26041c30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7216));
    // 0x1db76c: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db774);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db774
// Address: 0x1db774 - 0x1db780

void entry_1db774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db774: 0x26041ccc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7372));
    // 0x1db778: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db780);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3088));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db780
// Address: 0x1db780 - 0x1db78c

void entry_1db780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db780: 0x26041cd8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 7384));
    // 0x1db784: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1db78c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 52));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1db78c
// Address: 0x1db78c - 0x1db7bc

void entry_1db78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1db78c) {
        switch (ctx->pc) {
            case 0x1db7b4: ctx->pc = 0; goto label_1db7b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1db78c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1db790: 0x3c01c4bb
    SET_GPR_U32(ctx, 1, ((uint32_t)50363 << 16));
    // 0x1db794: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1db798: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1db79c: 0x8c622c64
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11364)));
    // 0x1db7a0: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x1db7a4: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1db7b4;
    }
    // 0x1db7ac: 0x3c01c461
    SET_GPR_U32(ctx, 1, ((uint32_t)50273 << 16));
    // 0x1db7b0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
label_1db7b4:
    // 0x1db7b4: 0xc076ea4
    SET_GPR_U32(ctx, 31, 0x1db7bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetSwGravity__FP2SWf(rdram, ctx, runtime); return;
}


// Function: entry_1db7bc
// Address: 0x1db7bc - 0x1db838

void entry_1db7bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db7bc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1db7c0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1db7c4: 0x3c02f03f
    SET_GPR_U32(ctx, 2, ((uint32_t)61503 << 16));
    // 0x1db7c8: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1db7cc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1db7d0: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1db7d4: 0x3c014170
    SET_GPR_U32(ctx, 1, ((uint32_t)16752 << 16));
    // 0x1db7d8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1db7dc: 0x24030040
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1db7e0: 0x3c014334
    SET_GPR_U32(ctx, 1, ((uint32_t)17204 << 16));
    // 0x1db7e4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1db7e8: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1db7ec: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1db7f0: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1db7f4: 0xae02235c
    WRITE32(ADD32(GPR_U32(ctx, 16), 9052), GPR_U32(ctx, 2));
    // 0x1db7f8: 0xa2061d65
    WRITE8(ADD32(GPR_U32(ctx, 16), 7525), (uint8_t)GPR_U32(ctx, 6));
    // 0x1db7fc: 0xa2031d66
    WRITE8(ADD32(GPR_U32(ctx, 16), 7526), (uint8_t)GPR_U32(ctx, 3));
    // 0x1db800: 0xe6011d68
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 7528), *(uint32_t*)&val); }
    // 0x1db804: 0xae041d70
    WRITE32(ADD32(GPR_U32(ctx, 16), 7536), GPR_U32(ctx, 4));
    // 0x1db808: 0xe6022308
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 8968), *(uint32_t*)&val); }
    // 0x1db80c: 0xe600230c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8972), *(uint32_t*)&val); }
    // 0x1db810: 0xe6032350
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 9040), *(uint32_t*)&val); }
    // 0x1db814: 0xae052354
    WRITE32(ADD32(GPR_U32(ctx, 16), 9044), GPR_U32(ctx, 5));
    // 0x1db818: 0xa2061d64
    WRITE8(ADD32(GPR_U32(ctx, 16), 7524), (uint8_t)GPR_U32(ctx, 6));
    // 0x1db81c: 0xae001d74
    WRITE32(ADD32(GPR_U32(ctx, 16), 7540), GPR_U32(ctx, 0));
    // 0x1db820: 0xe603234c
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 9036), *(uint32_t*)&val); }
    // 0x1db824: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1db828: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1db82c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1db834: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1db838; return;
}


// Function: DeleteSw__FP2SW
// Address: 0x1db838 - 0x1db854

void entry_1db854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db854: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1db858: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1db85c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1db860: 0xac409c90
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294941840), GPR_U32(ctx, 0));
    // 0x1db864: 0xac602e10
    WRITE32(ADD32(GPR_U32(ctx, 3), 11792), GPR_U32(ctx, 0));
    // 0x1db868: 0xc05b852
    SET_GPR_U32(ctx, 31, 0x1db870);
    WRITE32(ADD32(GPR_U32(ctx, 4), 11372), GPR_U32(ctx, 0));
    UpdateGrfjoytFromGrfusr__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1db870
// Address: 0x1db870 - 0x1db878

void entry_1db870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db870: 0xc050ebc
    SET_GPR_U32(ctx, 31, 0x1db878);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    ClearCmFadeObjects__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_1db878
// Address: 0x1db878 - 0x1db880

void entry_1db878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db878: 0xc077f5c
    SET_GPR_U32(ctx, 31, 0x1db880);
    ResetTargetList__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1db880
// Address: 0x1db880 - 0x1db888

void entry_1db880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db880: 0xc05ff5c
    SET_GPR_U32(ctx, 31, 0x1db888);
    ResetJmtList__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1db888
// Address: 0x1db888 - 0x1db890

void entry_1db888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db888: 0xc0647ba
    SET_GPR_U32(ctx, 31, 0x1db890);
    ResetPipeList__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1db890
// Address: 0x1db890 - 0x1db898

void entry_1db890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db890: 0xc05a728
    SET_GPR_U32(ctx, 31, 0x1db898);
    ResetHideList__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1db898
// Address: 0x1db898 - 0x1db8a0

void entry_1db898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db898: 0xc0701ec
    SET_GPR_U32(ctx, 31, 0x1db8a0);
    KillSoundSystem__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1db8a0
// Address: 0x1db8a0 - 0x1db8a8

void entry_1db8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db8a0: 0xc06d032
    SET_GPR_U32(ctx, 31, 0x1db8a8);
    UnloadShaders__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1db8a8
// Address: 0x1db8a8 - 0x1db8b0

void entry_1db8a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db8a8: 0xc047010
    SET_GPR_U32(ctx, 31, 0x1db8b0);
    ShutdownSplice__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1db8b0
// Address: 0x1db8b0 - 0x1db8bc

void entry_1db8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db8b0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1db8b4: 0xc07a5a2
    SET_GPR_U32(ctx, 31, 0x1db8bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    ResetUi__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_1db8bc
// Address: 0x1db8bc - 0x1db8c4

void entry_1db8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db8bc: 0xc063554
    SET_GPR_U32(ctx, 31, 0x1db8c4);
    FreeSw__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1db8c4
// Address: 0x1db8c4 - 0x1db928

void entry_1db8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1db8c4) {
        switch (ctx->pc) {
            case 0x1db914: ctx->pc = 0; goto label_1db914;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1db8c4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1db8c8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1db8cc: 0x2463e760
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294960992));
    // 0x1db8d0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1db8d4: 0xa8650283
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 643); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1db8d8: 0xb8650280
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 640); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1db8dc: 0x2442ce48
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294954568));
    // 0x1db8e0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1db8e4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1db8e8: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x1db8ec: 0xa8450277
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 631); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1db8f0: 0xb8450274
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 628); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1db8f4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1db8f8: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1db8fc: 0xe4801854
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 6228), *(uint32_t*)&val); }
    // 0x1db900: 0xae001990
    WRITE32(ADD32(GPR_U32(ctx, 16), 6544), GPR_U32(ctx, 0));
    // 0x1db904: 0xace040a4
    WRITE32(ADD32(GPR_U32(ctx, 7), 16548), GPR_U32(ctx, 0));
    // 0x1db908: 0xacc01d38
    WRITE32(ADD32(GPR_U32(ctx, 6), 7480), GPR_U32(ctx, 0));
    // 0x1db90c: 0xac400278
    WRITE32(ADD32(GPR_U32(ctx, 2), 632), GPR_U32(ctx, 0));
    // 0x1db910: 0xac60028c
    WRITE32(ADD32(GPR_U32(ctx, 3), 652), GPR_U32(ctx, 0));
label_1db914:
    // 0x1db914: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1db918: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1db91c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1db924: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1db928; return;
}


// Function: SetupBulkDataFromBrx__FiP18CBinaryInputStream
// Address: 0x1db928 - 0x1db970

void entry_1db970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1db970) {
        switch (ctx->pc) {
            case 0x1db984: ctx->pc = 0; goto label_1db984;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1db970: 0x8e035728
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 22312)));
    // 0x1db974: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1db978: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1db97c: 0xae220014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 2));
    // 0x1db980: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1db984:
    // 0x1db984: 0xc04df5e
    SET_GPR_U32(ctx, 31, 0x1db98c);
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    S32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1db98c
// Address: 0x1db98c - 0x1db998

void entry_1db98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db98c: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1db990: 0xc04df5e
    SET_GPR_U32(ctx, 31, 0x1db998);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1db998
// Address: 0x1db998 - 0x1db9a8

void entry_1db998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1db998) {
        switch (ctx->pc) {
            case 0x1db9a0: ctx->pc = 0; goto label_1db9a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1db998: 0x10000014
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DB9EC; return;
    }
label_1db9a0:
    // 0x1db9a0: 0xc04df5e
    SET_GPR_U32(ctx, 31, 0x1db9a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1db9a8
// Address: 0x1db9a8 - 0x1db9b4

void entry_1db9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db9a8: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1db9ac: 0xc04df5e
    SET_GPR_U32(ctx, 31, 0x1db9b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1db9b4
// Address: 0x1db9b4 - 0x1db9f4

void entry_1db9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1db9b4) {
        switch (ctx->pc) {
            case 0x1db9ec: ctx->pc = 0; goto label_1db9ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1db9b4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1db9b8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1db9bc: 0x8c625724
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 22308)));
    // 0x1db9c0: 0x2021026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1db9c4: 0x282900b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 20));
    // 0x1db9c8: 0x16400008
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        goto label_1db9ec;
    }
    // 0x1db9d0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1db9d4: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1db9d8: 0x8c835728
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 22312)));
    // 0x1db9dc: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1db9e0: 0x242202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1db9e4: 0x4100a
    if (GPR_U32(ctx, 4) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
    // 0x1db9e8: 0xae220014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 2));
label_1db9ec:
    // 0x1db9ec: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1db9f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1db9f4
// Address: 0x1db9f4 - 0x1dba38

void entry_1db9f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1db9f4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1db9f8: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1db9fc: 0xaeb05724
    WRITE32(ADD32(GPR_U32(ctx, 21), 22308), GPR_U32(ctx, 16));
    // 0x1dba00: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1dba04: 0xac735720
    WRITE32(ADD32(GPR_U32(ctx, 3), 22304), GPR_U32(ctx, 19));
    // 0x1dba08: 0xacb2571c
    WRITE32(ADD32(GPR_U32(ctx, 5), 22300), GPR_U32(ctx, 18));
    // 0x1dba0c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1dba10: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1dba14: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dba18: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dba1c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dba20: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dba24: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dba28: 0xac825718
    WRITE32(ADD32(GPR_U32(ctx, 4), 22296), GPR_U32(ctx, 2));
    // 0x1dba2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dba34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dba38; return;
}


// Function: LoadBulkDataFromBrx__FP18CBinaryInputStream
// Address: 0x1dba38 - 0x1dba68

void entry_1dba68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dba68: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dba6c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1dba70: 0x8c455720
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 22304)));
    // 0x1dba74: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dba78: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x1dba80);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 22296)));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_1dba80
// Address: 0x1dba80 - 0x1dba90

void entry_1dba80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dba80: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dba84: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dba88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSwGravity__FP2SWf
// Address: 0x1dba90 - 0x1dbac0

void FUN_001dbac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbac0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1dbac4: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1dbac8: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1dbacc: 0xc070302
    SET_GPR_U32(ctx, 31, 0x1dbad4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    FUN_001c0c08(rdram, ctx, runtime); return;
}


// Function: entry_1dbad4
// Address: 0x1dbad4 - 0x1dbae0

void entry_1dbad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbad4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dbad8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001dbae0
// Address: 0x1dbae0 - 0x1dbaf0

void FUN_001dbae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbae0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1dbae4: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1dbae8: 0xc070314
    SET_GPR_U32(ctx, 31, 0x1dbaf0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    FUN_001c0c50(rdram, ctx, runtime); return;
}


// Function: entry_1dbaf0
// Address: 0x1dbaf0 - 0x1dbb00

void entry_1dbaf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbaf0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dbaf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dbafc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dbb00; return;
}


// Function: FUN_001dbb00
// Address: 0x1dbb00 - 0x1dbb14

void FUN_001dbb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbb00: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1dbb04: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1dbb08: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1dbb0c: 0xc07031a
    SET_GPR_U32(ctx, 31, 0x1dbb14);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    FUN_001c0c68(rdram, ctx, runtime); return;
}


// Function: entry_1dbb14
// Address: 0x1dbb14 - 0x1dbb20

void entry_1dbb14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbb14: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dbb18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FOverflowSwLo__FP2SWP2LOi
// Address: 0x1dbb20 - 0x1dbb50

void entry_1dbb64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbb64: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dbb68: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dbb6c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dbb70: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1dbb78);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1dbb78
// Address: 0x1dbb78 - 0x1dbb90

void entry_1dbb78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbb78: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dbb7c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dbb80: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dbb84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dbb8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dbb90; return;
}


// Function: FreeSwXaList__FP2SWP2XA
// Address: 0x1dbb90 - 0x1dbbbc

void entry_1dbbbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dbbbc) {
        switch (ctx->pc) {
            case 0x1dbbc4: ctx->pc = 0; goto label_1dbbc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dbbbc: 0x1600fffc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DBBB0; return;
    }
label_1dbbc4:
    // 0x1dbbc4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dbbc8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dbbcc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dbbd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PmqAllocSw__FP2SW
// Address: 0x1dbbd8 - 0x1dbbec

void entry_1dbbec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbbec: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dbbf0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dbbf4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dbbf8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1dbc00);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 20));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1dbc00
// Address: 0x1dbc00 - 0x1dbc18

void entry_1dbc00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbc00: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dbc04: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dbc08: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dbc0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dbc14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dbc18; return;
}


// Function: FreeSwMqList__FP2SWP2MQ
// Address: 0x1dbc18 - 0x1dbc44

void entry_1dbc44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dbc44) {
        switch (ctx->pc) {
            case 0x1dbc4c: ctx->pc = 0; goto label_1dbc4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dbc44: 0x1600fffc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DBC38; return;
    }
label_1dbc4c:
    // 0x1dbc4c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dbc50: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dbc54: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dbc58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnsureSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2
// Address: 0x1dbc60 - 0x1dbcb8

void entry_1dbcb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dbcb8) {
        switch (ctx->pc) {
            case 0x1dbcbc: ctx->pc = 0; goto label_1dbcbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dbcb8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1dbcbc:
    // 0x1dbcbc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dbcc4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dbcc8; return;
}


// Function: PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2
// Address: 0x1dbcc8 - 0x1dbcfc

void entry_1dbcfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dbcfc) {
        switch (ctx->pc) {
            case 0x1dbd1c: ctx->pc = 0; goto label_1dbd1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dbcfc: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x1dbd00: 0xac510004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 17));
    // 0x1dbd04: 0xac520008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 18));
    // 0x1dbd08: 0xac53000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 12), GPR_U32(ctx, 19));
    // 0x1dbd0c: 0x8e831ecc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 7884)));
    // 0x1dbd10: 0x50600002
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 20), 7880), GPR_U32(ctx, 2));
        goto label_1dbd1c;
    }
    // 0x1dbd18: 0xac620010
    WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 2));
label_1dbd1c:
    // 0x1dbd1c: 0xae821ecc
    WRITE32(ADD32(GPR_U32(ctx, 20), 7884), GPR_U32(ctx, 2));
    // 0x1dbd20: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1dbd24: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dbd28: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dbd2c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dbd30: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dbd34: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dbd38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3
// Address: 0x1dbd40 - 0x1dbe38

void entry_1dbe38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbe38: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dbe3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dbe44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dbe48; return;
}


// Function: ProcessSwCallbacks__FP2SW
// Address: 0x1dbe48 - 0x1dbe9c

void entry_1dbe9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbe9c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dbea0: 0xc076f06
    SET_GPR_U32(ctx, 31, 0x1dbea8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FreeSwMqList__FP2SWP2MQ(rdram, ctx, runtime); return;
}


// Function: entry_1dbea8
// Address: 0x1dbea8 - 0x1dbec8

void entry_1dbea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dbea8) {
        switch (ctx->pc) {
            case 0x1dbeb8: ctx->pc = 0; goto label_1dbeb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dbea8: 0x8e221ec8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 7880)));
    // 0x1dbeac: 0x5440fff0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 7880)));
        ctx->pc = 0x1DBE70; return;
    }
    // 0x1dbeb4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1dbeb8:
    // 0x1dbeb8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dbebc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dbec0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ProcessSwSpliceScheduledCallbacks__FP2SWf
// Address: 0x1dbec8 - 0x1dbefc

void entry_1dbefc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbefc: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1dbf00: 0xc046c02
    SET_GPR_U32(ctx, 31, 0x1dbf08);
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    fn___4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1dbf08
// Address: 0x1dbf08 - 0x1dbf14

void entry_1dbf08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbf08: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1dbf0c: 0xc046a00
    SET_GPR_U32(ctx, 31, 0x1dbf14);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294942520));
    UpdateRecyclable__3CGc(rdram, ctx, runtime); return;
}


// Function: entry_1dbf14
// Address: 0x1dbf14 - 0x1dbf28

void entry_1dbf14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbf14: 0x8e44002c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 44)));
    // 0x1dbf18: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dbf1c: 0x8e451ef8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 7928)));
    // 0x1dbf20: 0xc046926
    SET_GPR_U32(ctx, 31, 0x1dbf28);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FFindBinding__6CFrameUiiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1dbf28
// Address: 0x1dbf28 - 0x1dbf78

void entry_1dbf28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dbf28) {
        switch (ctx->pc) {
            case 0x1dbf50: ctx->pc = 0; goto label_1dbf50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dbf28: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dbf2c: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x1dbf30: 0x14620024
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DBFC4; return;
    }
    // 0x1dbf38: 0x8fb00004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1dbf3c: 0x1200001e
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DBFB8; return;
    }
    // 0x1dbf44: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x1dbf48: 0x27b10020
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1dbf4c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
label_1dbf50:
    // 0x1dbf50: 0xc4800004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1dbf54: 0x46140301
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1dbf58: 0x46156036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[12], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dbf5c: 0x45000011
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1DBFA4; return;
    }
    // 0x1dbf64: 0x8c850008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1dbf68: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1dbf6c: 0x8e46002c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 44)));
    // 0x1dbf70: 0xc046820
    SET_GPR_U32(ctx, 31, 0x1dbf78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RefEval__FP5CPairP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_1dbf78
// Address: 0x1dbf78 - 0x1dbf84

void entry_1dbf78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbf78: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1dbf7c: 0xc046c2a
    SET_GPR_U32(ctx, 31, 0x1dbf84);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___as__4CRefRC4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1dbf84
// Address: 0x1dbf84 - 0x1dbf90

void entry_1dbf84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbf84: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1dbf88: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1dbf90);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1dbf90
// Address: 0x1dbf90 - 0x1dbf9c

void entry_1dbf90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbf90: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dbf94: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1dbf9c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1dbf9c
// Address: 0x1dbf9c - 0x1dbfac

void entry_1dbf9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dbf9c) {
        switch (ctx->pc) {
            case 0x1dbfa4: ctx->pc = 0; goto label_1dbfa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dbf9c: 0x10000004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DBFB0; return;
    }
label_1dbfa4:
    // 0x1dbfa4: 0xc046d6c
    SET_GPR_U32(ctx, 31, 0x1dbfac);
    SetF32__4CReff(rdram, ctx, runtime); return;
}


// Function: entry_1dbfac
// Address: 0x1dbfac - 0x1dbfcc

void entry_1dbfac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dbfac) {
        switch (ctx->pc) {
            case 0x1dbfb0: ctx->pc = 0; goto label_1dbfb0;
            case 0x1dbfb8: ctx->pc = 0; goto label_1dbfb8;
            case 0x1dbfc4: ctx->pc = 0; goto label_1dbfc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dbfac: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_1dbfb0:
    // 0x1dbfb0: 0x5600ffe7
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x1DBF50; return;
    }
label_1dbfb8:
    // 0x1dbfb8: 0x56600009
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 7928)));
        ctx->pc = 0x1DBFE0; return;
    }
    // 0x1dbfc0: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_1dbfc4:
    // 0x1dbfc4: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1dbfcc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1dbfcc
// Address: 0x1dbfcc - 0x1dbfd8

void entry_1dbfcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dbfcc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1dbfd0: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1dbfd8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1dbfd8
// Address: 0x1dbfd8 - 0x1dbff0

void entry_1dbfd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dbfd8) {
        switch (ctx->pc) {
            case 0x1dbfe0: ctx->pc = 0; goto label_1dbfe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dbfd8: 0x10000031
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC0A0; return;
    }
label_1dbfe0:
    // 0x1dbfe0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dbfe4: 0x8e44002c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 44)));
    // 0x1dbfe8: 0xc046926
    SET_GPR_U32(ctx, 31, 0x1dbff0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FFindBinding__6CFrameUiiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1dbff0
// Address: 0x1dbff0 - 0x1dc050

void entry_1dbff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dbff0) {
        switch (ctx->pc) {
            case 0x1dc008: ctx->pc = 0; goto label_1dc008;
            case 0x1dc018: ctx->pc = 0; goto label_1dc018;
            case 0x1dc028: ctx->pc = 0; goto label_1dc028;
            case 0x1dc034: ctx->pc = 0; goto label_1dc034;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dbff0: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1dbff4: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dbff8: 0x10a0000e
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1dc034;
    }
    // 0x1dc000: 0x2404001e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 30));
    // 0x1dc004: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1dc008:
    // 0x1dc008: 0x14440003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_1dc018;
    }
    // 0x1dc010: 0x10000005
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dc028;
    }
label_1dc018:
    // 0x1dc018: 0x50600003
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        goto label_1dc028;
    }
    // 0x1dc020: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1dc024: 0xac620008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 2));
label_1dc028:
    // 0x1dc028: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1dc02c: 0x5600fff6
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1dc008;
    }
label_1dc034:
    // 0x1dc034: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1dc038: 0x10a20013
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DC088; return;
    }
    // 0x1dc040: 0x10a00005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC058; return;
    }
    // 0x1dc048: 0xc046db0
    SET_GPR_U32(ctx, 31, 0x1dc050);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetPair__4CRefP5CPair(rdram, ctx, runtime); return;
}


// Function: entry_1dc050
// Address: 0x1dc050 - 0x1dc060

void entry_1dc050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc050) {
        switch (ctx->pc) {
            case 0x1dc058: ctx->pc = 0; goto label_1dc058;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc050: 0x10000004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC064; return;
    }
label_1dc058:
    // 0x1dc058: 0xc046d4e
    SET_GPR_U32(ctx, 31, 0x1dc060);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTag__4CRef4TAGK(rdram, ctx, runtime); return;
}


// Function: entry_1dc060
// Address: 0x1dc060 - 0x1dc078

void entry_1dc060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc060) {
        switch (ctx->pc) {
            case 0x1dc064: ctx->pc = 0; goto label_1dc064;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc060: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
label_1dc064:
    // 0x1dc064: 0x8e45002c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 44)));
    // 0x1dc068: 0x8e461ef8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 7928)));
    // 0x1dc06c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dc070: 0xc046900
    SET_GPR_U32(ctx, 31, 0x1dc078);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    RefSetBinding__6CFrameUiP4CRef(rdram, ctx, runtime); return;
}


// Function: entry_1dc078
// Address: 0x1dc078 - 0x1dc084

void entry_1dc078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc078: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dc07c: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1dc084);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1dc084
// Address: 0x1dc084 - 0x1dc090

void entry_1dc084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc084) {
        switch (ctx->pc) {
            case 0x1dc088: ctx->pc = 0; goto label_1dc088;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc084: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_1dc088:
    // 0x1dc088: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1dc090);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1dc090
// Address: 0x1dc090 - 0x1dc09c

void entry_1dc090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc090: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1dc094: 0xc046c18
    SET_GPR_U32(ctx, 31, 0x1dc09c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x11b060; return;
}


// Function: entry_1dc09c
// Address: 0x1dc09c - 0x1dc0c8

void entry_1dc09c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc09c) {
        switch (ctx->pc) {
            case 0x1dc0a0: ctx->pc = 0; goto label_1dc0a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc09c: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1dc0a0:
    // 0x1dc0a0: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1dc0a4: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1dc0a8: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1dc0ac: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dc0b0: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dc0b4: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1dc0b8: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1dc0bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dc0c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dc0c8; return;
}


// Function: PstsoAllocSw__FP2SW
// Address: 0x1dc0c8 - 0x1dc0dc

void entry_1dc0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc0dc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dc0e0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dc0e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dc0e8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1dc0f0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1dc0f0
// Address: 0x1dc0f0 - 0x1dc108

void entry_1dc0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc0f0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dc0f4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dc0f8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dc0fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dc104: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dc108; return;
}


// Function: FreeSwStsoList__FP2SWP4STSO
// Address: 0x1dc108 - 0x1dc134

void entry_1dc134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc134) {
        switch (ctx->pc) {
            case 0x1dc13c: ctx->pc = 0; goto label_1dc13c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc134: 0x1600fffc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC128; return;
    }
label_1dc13c:
    // 0x1dc13c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dc140: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dc144: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dc148: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddSwProxySource__FP2SWP2LOi
// Address: 0x1dc150 - 0x1dc184

void entry_1dc184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc184) {
        switch (ctx->pc) {
            case 0x1dc198: ctx->pc = 0; goto label_1dc198;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc184: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dc188: 0x1860000f
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1DC1C8; return;
    }
    // 0x1dc190: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dc194: 0x0
    // NOP
label_1dc198:
    // 0x1dc198: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1dc19c: 0xc060c16
    SET_GPR_U32(ctx, 31, 0x1dc1a4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloCloneLo__FP2LOP2SWP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1dc1a4
// Address: 0x1dc1a4 - 0x1dc208

void entry_1dc1a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc1a4) {
        switch (ctx->pc) {
            case 0x1dc1c8: ctx->pc = 0; goto label_1dc1c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc1a4: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1dc1a8: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1dc1ac: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1dc1b0: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1dc1b4: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1dc1b8: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dc1bc: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1dc1c0: 0x1440fff5
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC198; return;
    }
label_1dc1c8:
    // 0x1dc1c8: 0x8e231efc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 7932)));
    // 0x1dc1cc: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dc1d0: 0x310c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 3));
    // 0x1dc1d4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dc1d8: 0x511021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1dc1dc: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1dc1e0: 0x6ba40007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1dc1e4: 0x6fa40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1dc1e8: 0xb0441f07
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7943); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1dc1ec: 0xb4441f00
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7936); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1dc1f0: 0xae231efc
    WRITE32(ADD32(GPR_U32(ctx, 17), 7932), GPR_U32(ctx, 3));
    // 0x1dc1f4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dc1f8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dc1fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dc204: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dc208; return;
}


// Function: PloGetSwProxySource__FP2SWi
// Address: 0x1dc208 - 0x1dc238

void entry_1dc2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc2b0) {
        switch (ctx->pc) {
            case 0x1dc2f0: ctx->pc = 0; goto label_1dc2f0;
            case 0x1dc330: ctx->pc = 0; goto label_1dc330;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc2b0: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dc2b4: 0x1220000e
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1dc2f0;
    }
    // 0x1dc2bc: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1dc2c0: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1dc2c4: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x1dc2c8: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1dc2cc: 0x5440006d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 0)));
        ctx->pc = 0x1DC484; return;
    }
    // 0x1dc2d4: 0x8e220050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1dc2d8: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1dc2dc: 0x426f8
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 27);
    // 0x1dc2e0: 0xdc430538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 2), 1336)));
    // 0x1dc2e4: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1dc2e8: 0x54600066
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 0)));
        ctx->pc = 0x1DC484; return;
    }
label_1dc2f0:
    // 0x1dc2f0: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1dc2f4: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1dc2f8: 0x4bc208eb
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1dc2fc: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1dc300: 0x4bc2086f
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1dc304: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1dc308: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1dc30c: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1dc310: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1dc314: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1dc318: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1dc31c: 0x12000058
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC480; return;
    }
    // 0x1dc324: 0x34178000
    SET_GPR_U32(ctx, 23, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1dc328: 0x17bef8
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 23) << 27);
    // 0x1dc32c: 0x0
    // NOP
label_1dc330:
    // 0x1dc330: 0x1211004c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1DC464; return;
    }
    // 0x1dc338: 0xc6010420
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1056)); ctx->f[1] = *(float*)&val; }
    // 0x1dc33c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dc340: 0x0
    // NOP
    // 0x1dc344: 0x45030048
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
        ctx->pc = 0x1DC468; return;
    }
    // 0x1dc34c: 0xc6010430
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1072)); ctx->f[1] = *(float*)&val; }
    // 0x1dc350: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1dc354: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dc358: 0x0
    // NOP
    // 0x1dc35c: 0x45030042
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
        ctx->pc = 0x1DC468; return;
    }
    // 0x1dc364: 0xc6010424
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1060)); ctx->f[1] = *(float*)&val; }
    // 0x1dc368: 0xc7a00024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[0] = *(float*)&val; }
    // 0x1dc36c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dc370: 0x0
    // NOP
    // 0x1dc374: 0x4501003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1DC468; return;
    }
    // 0x1dc37c: 0xc6010434
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1076)); ctx->f[1] = *(float*)&val; }
    // 0x1dc380: 0xc7a00014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[0] = *(float*)&val; }
    // 0x1dc384: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dc388: 0x45010037
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1DC468; return;
    }
    // 0x1dc390: 0xc6010428
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1064)); ctx->f[1] = *(float*)&val; }
    // 0x1dc394: 0xc7a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[0] = *(float*)&val; }
    // 0x1dc398: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dc39c: 0x0
    // NOP
    // 0x1dc3a0: 0x45010032
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1DC46C; return;
    }
    // 0x1dc3a8: 0xc6010438
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1080)); ctx->f[1] = *(float*)&val; }
    // 0x1dc3ac: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1dc3b0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dc3b4: 0x4501002d
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1DC46C; return;
    }
    // 0x1dc3bc: 0x8e030050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1dc3c0: 0xdc620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 1336)));
    // 0x1dc3c4: 0x571024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x1dc3c8: 0x14400027
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC468; return;
    }
    // 0x1dc3d0: 0x1220000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC40C; return;
    }
    // 0x1dc3d8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1dc3dc: 0x8c6200f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 240)));
    // 0x1dc3e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dc3e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dc3e8
// Address: 0x1dc3e8 - 0x1dc404

void entry_1dc3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc3e8: 0x1440001f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC468; return;
    }
    // 0x1dc3f0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1dc3f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dc3f8: 0x8c6200f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 240)));
    // 0x1dc3fc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dc404);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dc404
// Address: 0x1dc404 - 0x1dc430

void entry_1dc404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc404) {
        switch (ctx->pc) {
            case 0x1dc40c: ctx->pc = 0; goto label_1dc40c;
            case 0x1dc420: ctx->pc = 0; goto label_1dc420;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc404: 0x14400018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC468; return;
    }
label_1dc40c:
    // 0x1dc40c: 0x8e1002d8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 728)));
    // 0x1dc410: 0x12000015
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC468; return;
    }
    // 0x1dc418: 0x34128000
    SET_GPR_U32(ctx, 18, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1dc41c: 0x129738
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 18) << 28);
label_1dc420:
    // 0x1dc420: 0x12800007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC440; return;
    }
    // 0x1dc428: 0x280f809
    SET_GPR_U32(ctx, 31, 0x1dc430);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 20); return;
}


// Function: entry_1dc430
// Address: 0x1dc430 - 0x1dc4d0

void entry_1dc430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc430) {
        switch (ctx->pc) {
            case 0x1dc440: ctx->pc = 0; goto label_1dc440;
            case 0x1dc454: ctx->pc = 0; goto label_1dc454;
            case 0x1dc45c: ctx->pc = 0; goto label_1dc45c;
            case 0x1dc464: ctx->pc = 0; goto label_1dc464;
            case 0x1dc468: ctx->pc = 0; goto label_1dc468;
            case 0x1dc46c: ctx->pc = 0; goto label_1dc46c;
            case 0x1dc480: ctx->pc = 0; goto label_1dc480;
            case 0x1dc484: ctx->pc = 0; goto label_1dc484;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc430: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        goto label_1dc45c;
    }
    // 0x1dc438: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dc454;
    }
label_1dc440:
    // 0x1dc440: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1dc444: 0x521024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1dc448: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        goto label_1dc45c;
    }
    // 0x1dc450: 0xae700000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 16));
label_1dc454:
    // 0x1dc454: 0x26730004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    // 0x1dc458: 0x8e1002e4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_1dc45c:
    // 0x1dc45c: 0x1600fff0
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC420; return;
    }
label_1dc464:
    // 0x1dc464: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1dc468:
    // 0x1dc468: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
label_1dc46c:
    // 0x1dc46c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1dc470: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1dc474: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1dc478: 0x1600ffad
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC330; return;
    }
label_1dc480:
    // 0x1dc480: 0x8ec20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 0)));
label_1dc484:
    // 0x1dc484: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1dc488: 0x2621023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1dc48c: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1dc490: 0x21083
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 2));
    // 0x1dc494: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1dc498: 0xafc20000
    WRITE32(ADD32(GPR_U32(ctx, 30), 0), GPR_U32(ctx, 2));
    // 0x1dc49c: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x1dc4a0: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1dc4a4: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1dc4a8: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1dc4ac: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1dc4b0: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1dc4b4: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1dc4b8: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1dc4bc: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dc4c0: 0xac43b314
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294947604), GPR_U32(ctx, 3));
    // 0x1dc4c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dc4cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dc4d0; return;
}


// Function: IntersectSwBoundingSphere__FP2SWP2SOP6VECTORfPFPvP2SO_iPvPiPPP2SO
// Address: 0x1dc4d0 - 0x1dc54c

void entry_1dc54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc54c) {
        switch (ctx->pc) {
            case 0x1dc58c: ctx->pc = 0; goto label_1dc58c;
            case 0x1dc5b0: ctx->pc = 0; goto label_1dc5b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc54c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dc550: 0x1220000e
    WRITE32(ADD32(GPR_U32(ctx, 23), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1dc58c;
    }
    // 0x1dc558: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1dc55c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1dc560: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x1dc564: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1dc568: 0x54400055
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 0)));
        ctx->pc = 0x1DC6C0; return;
    }
    // 0x1dc570: 0x8e220050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x1dc574: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1dc578: 0x426f8
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 27);
    // 0x1dc57c: 0xdc430538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 2), 1336)));
    // 0x1dc580: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1dc584: 0x5460004e
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 0)));
        ctx->pc = 0x1DC6C0; return;
    }
label_1dc58c:
    // 0x1dc58c: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1dc590: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1dc594: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1dc598: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1dc59c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1dc5a0: 0x12000046
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC6BC; return;
    }
    // 0x1dc5a8: 0x341e8000
    SET_GPR_U32(ctx, 30, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1dc5ac: 0x1ef6f8
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 30) << 27);
label_1dc5b0:
    // 0x1dc5b0: 0x1211003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1DC6A4; return;
    }
    // 0x1dc5b8: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1dc5bc: 0xdac10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1dc5c0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1dc5c4: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1dc5c8: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1dc5cc: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1dc5d0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1dc5d4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1dc5d8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1dc5dc: 0xc60003d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 976)); ctx->f[0] = *(float*)&val; }
    // 0x1dc5e0: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1dc5e4: 0x4600a000
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1dc5e8: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x1dc5ec: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dc5f0: 0x0
    // NOP
    // 0x1dc5f4: 0x4501002b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1DC6A4; return;
    }
    // 0x1dc5fc: 0x8e030050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1dc600: 0xdc620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 1336)));
    // 0x1dc604: 0x5e1024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 30)));
    // 0x1dc608: 0x14400026
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC6A4; return;
    }
    // 0x1dc610: 0x1220000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC64C; return;
    }
    // 0x1dc618: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1dc61c: 0x8c6200f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 240)));
    // 0x1dc620: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dc628);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dc628
// Address: 0x1dc628 - 0x1dc644

void entry_1dc628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc628: 0x1440001e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC6A4; return;
    }
    // 0x1dc630: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1dc634: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dc638: 0x8c6200f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 240)));
    // 0x1dc63c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dc644);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dc644
// Address: 0x1dc644 - 0x1dc670

void entry_1dc644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc644) {
        switch (ctx->pc) {
            case 0x1dc64c: ctx->pc = 0; goto label_1dc64c;
            case 0x1dc660: ctx->pc = 0; goto label_1dc660;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc644: 0x14400017
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC6A4; return;
    }
label_1dc64c:
    // 0x1dc64c: 0x8e1002d8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 728)));
    // 0x1dc650: 0x12000014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC6A4; return;
    }
    // 0x1dc658: 0x34138000
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1dc65c: 0x139f38
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) << 28);
label_1dc660:
    // 0x1dc660: 0x12800007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC680; return;
    }
    // 0x1dc668: 0x280f809
    SET_GPR_U32(ctx, 31, 0x1dc670);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 20); return;
}


// Function: entry_1dc670
// Address: 0x1dc670 - 0x1dc710

void entry_1dc670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc670) {
        switch (ctx->pc) {
            case 0x1dc680: ctx->pc = 0; goto label_1dc680;
            case 0x1dc694: ctx->pc = 0; goto label_1dc694;
            case 0x1dc69c: ctx->pc = 0; goto label_1dc69c;
            case 0x1dc6a4: ctx->pc = 0; goto label_1dc6a4;
            case 0x1dc6bc: ctx->pc = 0; goto label_1dc6bc;
            case 0x1dc6c0: ctx->pc = 0; goto label_1dc6c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc670: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        goto label_1dc69c;
    }
    // 0x1dc678: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dc694;
    }
label_1dc680:
    // 0x1dc680: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1dc684: 0x531024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1dc688: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        goto label_1dc69c;
    }
    // 0x1dc690: 0xae500000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 16));
label_1dc694:
    // 0x1dc694: 0x26520004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    // 0x1dc698: 0x8e1002e4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_1dc69c:
    // 0x1dc69c: 0x1600fff0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC660; return;
    }
label_1dc6a4:
    // 0x1dc6a4: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1dc6a8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1dc6ac: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1dc6b0: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1dc6b4: 0x1600ffbe
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DC5B0; return;
    }
label_1dc6bc:
    // 0x1dc6bc: 0x8ee20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 0)));
label_1dc6c0:
    // 0x1dc6c0: 0x8fa40024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1dc6c4: 0x2421023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1dc6c8: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1dc6cc: 0x21083
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 2));
    // 0x1dc6d0: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1dc6d4: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    // 0x1dc6d8: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x1dc6dc: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1dc6e0: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1dc6e4: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1dc6e8: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1dc6ec: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1dc6f0: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1dc6f4: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1dc6f8: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dc6fc: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dc700: 0xc7b400d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    // 0x1dc704: 0xac43b314
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294947604), GPR_U32(ctx, 3));
    // 0x1dc708: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemoveOxa__FP3OXAPP3OXA
// Address: 0x1dc710 - 0x1dc740

void entry_1dc758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc758) {
        switch (ctx->pc) {
            case 0x1dc768: ctx->pc = 0; goto label_1dc768;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc758: 0xae021ae4
    WRITE32(ADD32(GPR_U32(ctx, 16), 6884), GPR_U32(ctx, 2));
    // 0x1dc75c: 0x240800fe
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 254));
    // 0x1dc760: 0xae021ae0
    WRITE32(ADD32(GPR_U32(ctx, 16), 6880), GPR_U32(ctx, 2));
    // 0x1dc764: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1dc768:
    // 0x1dc768: 0x8e051ae0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 6880)));
    // 0x1dc76c: 0x71100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 7), 4));
    // 0x1dc770: 0x28e40001
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 7), 1));
    // 0x1dc774: 0x107302a
    SET_GPR_U32(ctx, 6, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 7)));
    // 0x1dc778: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1dc77c: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1dc780: 0x24a3fff0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 4294967280));
    // 0x1dc784: 0x24a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 16));
    // 0x1dc788: 0x4180b
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 0));
    // 0x1dc78c: 0x6100b
    if (GPR_U32(ctx, 6) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
    // 0x1dc790: 0xaca20008
    WRITE32(ADD32(GPR_U32(ctx, 5), 8), GPR_U32(ctx, 2));
    // 0x1dc794: 0x28e40100
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 7), 256));
    // 0x1dc798: 0x1480fff3
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1dc768;
    }
    // 0x1dc7a0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dc7a4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dc7a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddOxa__FP3OXAPP3OXA
// Address: 0x1dc7b0 - 0x1dc7d0

void entry_1dc7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc7fc: 0x26051ae8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 6888));
    // 0x1dc800: 0xc0771ec
    SET_GPR_U32(ctx, 31, 0x1dc808);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddOxa__FP3OXAPP3OXA(rdram, ctx, runtime); return;
}


// Function: entry_1dc808
// Address: 0x1dc808 - 0x1dc828

void entry_1dc808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc808: 0xae320004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 18));
    // 0x1dc80c: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1dc810: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dc814: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dc818: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dc81c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dc820: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FreeSwPoxa__FP2SWP3OXA
// Address: 0x1dc828 - 0x1dc87c

void entry_1dc87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc87c: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1dc880: 0x10a00013
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1dc8d0(rdram, ctx, runtime); return;
    }
    // 0x1dc888: 0x34138000
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1dc88c: 0x139a3c
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) << (32 + 8));
    // 0x1dc890: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1dc898);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1dc898
// Address: 0x1dc898 - 0x1dc8b4

void entry_1dc898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc898: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1dc89c: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x1dc8a0: 0x531024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1dc8a4: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x1DC8B8; return;
    }
    // 0x1dc8ac: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1dc8b4);
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1dc8b4
// Address: 0x1dc8b4 - 0x1dc8d0

void entry_1dc8b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc8b4) {
        switch (ctx->pc) {
            case 0x1dc8b8: ctx->pc = 0; goto label_1dc8b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc8b4: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
label_1dc8b8:
    // 0x1dc8b8: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x1dc8bc: 0x531024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1dc8c0: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
        ctx->pc = 0x1DC8D4; return;
    }
    // 0x1dc8c8: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1dc8d0);
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1dc8d0
// Address: 0x1dc8d0 - 0x1dc8e8

void entry_1dc8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc8d0) {
        switch (ctx->pc) {
            case 0x1dc8d4: ctx->pc = 0; goto label_1dc8d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc8d0: 0xae200000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
label_1dc8d4:
    // 0x1dc8d4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dc8d8: 0xae000000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 0));
    // 0x1dc8dc: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1dc8e0: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x1dc8e8);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_1dc8e8
// Address: 0x1dc8e8 - 0x1dc8f4

void entry_1dc8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc8e8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1dc8ec: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x1dc8f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_1dc8f4
// Address: 0x1dc8f4 - 0x1dc96c

void entry_1dc8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dc8f4) {
        switch (ctx->pc) {
            case 0x1dc8fc: ctx->pc = 0; goto label_1dc8fc;
            case 0x1dc928: ctx->pc = 0; goto label_1dc928;
            case 0x1dc95c: ctx->pc = 0; goto label_1dc95c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dc8f4: 0x5600ffdc
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        ctx->pc = 0x1DC868; return;
    }
label_1dc8fc:
    // 0x1dc8fc: 0xae800000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 0));
    // 0x1dc900: 0x26491ae8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 18), 6888));
    // 0x1dc904: 0x26501ae4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 6884));
    // 0x1dc908: 0x8e421ae0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 6880)));
    // 0x1dc90c: 0x8e461ae8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 6888)));
    // 0x1dc910: 0x2821023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x1dc914: 0x10c00011
    SET_GPR_S32(ctx, 7, SRA32(GPR_S32(ctx, 2), 4));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_1dc95c;
    }
    // 0x1dc91c: 0x74200
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 7), 8));
    // 0x1dc920: 0x8e421ae0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 6880)));
    // 0x1dc924: 0x0
    // NOP
label_1dc928:
    // 0x1dc928: 0x8e431adc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 6876)));
    // 0x1dc92c: 0xc21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1dc930: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x1dc934: 0x682021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1dc938: 0x22a00
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 2), 8));
    // 0x1dc93c: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1dc940: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1dc944: 0x671821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1dc948: 0xa0600000
    WRITE8(ADD32(GPR_U32(ctx, 3), 0), (uint8_t)GPR_U32(ctx, 0));
    // 0x1dc94c: 0xa0800000
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 0));
    // 0x1dc950: 0x8cc60008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1dc954: 0x54c0fff4
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 6880)));
        goto label_1dc928;
    }
label_1dc95c:
    // 0x1dc95c: 0xae800004
    WRITE32(ADD32(GPR_U32(ctx, 20), 4), GPR_U32(ctx, 0));
    // 0x1dc960: 0x120282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1dc964: 0xc0771c4
    SET_GPR_U32(ctx, 31, 0x1dc96c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    RemoveOxa__FP3OXAPP3OXA(rdram, ctx, runtime); return;
}


// Function: entry_1dc96c
// Address: 0x1dc96c - 0x1dc978

void entry_1dc96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc96c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1dc970: 0xc0771ec
    SET_GPR_U32(ctx, 31, 0x1dc978);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddOxa__FP3OXAPP3OXA(rdram, ctx, runtime); return;
}


// Function: entry_1dc978
// Address: 0x1dc978 - 0x1dc9a0

void entry_1dc978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc978: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1dc97c: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1dc980: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1dc984: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dc988: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dc98c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dc990: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dc994: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dc998: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CreateSwDefaultLights__FP2SW
// Address: 0x1dc9a0 - 0x1dc9e0

void entry_1dc9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc9e0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dc9e4: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dc9e8: 0x24a55640
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22080));
    // 0x1dc9ec: 0xc0611fc
    SET_GPR_U32(ctx, 31, 0x1dc9f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetLightHighlightColor__FP5LIGHTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1dc9f4
// Address: 0x1dc9f4 - 0x1dca04

void entry_1dc9f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dc9f4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dc9f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dc9fc: 0xc061216
    SET_GPR_U32(ctx, 31, 0x1dca04);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22096)); ctx->f[12] = *(float*)&val; }
    SetLightHighlightAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dca04
// Address: 0x1dca04 - 0x1dca14

void entry_1dca04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dca04: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dca08: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dca0c: 0xc061206
    SET_GPR_U32(ctx, 31, 0x1dca14);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22100)); ctx->f[12] = *(float*)&val; }
    SetLightMidtoneStrength__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dca14
// Address: 0x1dca14 - 0x1dca24

void entry_1dca14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dca14: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dca18: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dca1c: 0xc06121e
    SET_GPR_U32(ctx, 31, 0x1dca24);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22104)); ctx->f[12] = *(float*)&val; }
    SetLightMidtoneAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dca24
// Address: 0x1dca24 - 0x1dca34

void entry_1dca24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dca24: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dca28: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dca2c: 0xc06120e
    SET_GPR_U32(ctx, 31, 0x1dca34);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22108)); ctx->f[12] = *(float*)&val; }
    SetLightShadowStrength__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dca34
// Address: 0x1dca34 - 0x1dca44

void entry_1dca34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dca34: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dca38: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dca3c: 0xc061226
    SET_GPR_U32(ctx, 31, 0x1dca44);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22112)); ctx->f[12] = *(float*)&val; }
    SetLightShadowAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dca44
// Address: 0x1dca44 - 0x1dca54

void entry_1dca44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dca44: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dca48: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dca4c: 0xc06122e
    SET_GPR_U32(ctx, 31, 0x1dca54);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22128));
    SetLightDirection__FP5LIGHTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1dca54
// Address: 0x1dca54 - 0x1dca78

void entry_1dca54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dca54: 0x8e425630
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 22064)));
    // 0x1dca58: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1dca5c: 0x1040002c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1dcb10(rdram, ctx, runtime); return;
    }
    // 0x1dca64: 0x24070201
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 513));
    // 0x1dca68: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1dca6c: 0x24040051
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 81));
    // 0x1dca70: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1dca78);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1dca78
// Address: 0x1dca78 - 0x1dca88

void entry_1dca78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dca78: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dca7c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1dca80: 0xc0611da
    SET_GPR_U32(ctx, 31, 0x1dca88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetLightKind__FP5LIGHT6LIGHTK(rdram, ctx, runtime); return;
}


// Function: entry_1dca88
// Address: 0x1dca88 - 0x1dca98

void entry_1dca88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dca88: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dca8c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dca90: 0xc0611fc
    SET_GPR_U32(ctx, 31, 0x1dca98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22080));
    SetLightHighlightColor__FP5LIGHTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1dca98
// Address: 0x1dca98 - 0x1dcaa8

void entry_1dca98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dca98: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dca9c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcaa0: 0xc061216
    SET_GPR_U32(ctx, 31, 0x1dcaa8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22096)); ctx->f[12] = *(float*)&val; }
    SetLightHighlightAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcaa8
// Address: 0x1dcaa8 - 0x1dcab8

void entry_1dcaa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcaa8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcaac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcab0: 0xc061206
    SET_GPR_U32(ctx, 31, 0x1dcab8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22100)); ctx->f[12] = *(float*)&val; }
    SetLightMidtoneStrength__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcab8
// Address: 0x1dcab8 - 0x1dcac8

void entry_1dcab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcab8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcabc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcac0: 0xc06121e
    SET_GPR_U32(ctx, 31, 0x1dcac8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22104)); ctx->f[12] = *(float*)&val; }
    SetLightMidtoneAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcac8
// Address: 0x1dcac8 - 0x1dcad8

void entry_1dcac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcac8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcacc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcad0: 0xc06120e
    SET_GPR_U32(ctx, 31, 0x1dcad8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22108)); ctx->f[12] = *(float*)&val; }
    SetLightShadowStrength__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcad8
// Address: 0x1dcad8 - 0x1dcae8

void entry_1dcad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcad8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcadc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcae0: 0xc061226
    SET_GPR_U32(ctx, 31, 0x1dcae8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22112)); ctx->f[12] = *(float*)&val; }
    SetLightShadowAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcae8
// Address: 0x1dcae8 - 0x1dcaf8

void entry_1dcae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcae8: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dcaec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcaf0: 0xc061264
    SET_GPR_U32(ctx, 31, 0x1dcaf8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22160));
    SetLightFallOff__FP5LIGHTP2LM(rdram, ctx, runtime); return;
}


// Function: entry_1dcaf8
// Address: 0x1dcaf8 - 0x1dcb10

void entry_1dcaf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcaf8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1dcafc: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dcb00: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcb04: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1dcb08: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dcb10);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22144));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dcb10
// Address: 0x1dcb10 - 0x1dcb34

void entry_1dcb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcb10: 0x8e425630
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 22064)));
    // 0x1dcb14: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x1dcb18: 0x10400030
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1dcbdc(rdram, ctx, runtime); return;
    }
    // 0x1dcb20: 0x24070201
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 513));
    // 0x1dcb24: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1dcb28: 0x24040051
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 81));
    // 0x1dcb2c: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1dcb34);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1dcb34
// Address: 0x1dcb34 - 0x1dcb44

void entry_1dcb34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcb34: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dcb38: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1dcb3c: 0xc0611da
    SET_GPR_U32(ctx, 31, 0x1dcb44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetLightKind__FP5LIGHT6LIGHTK(rdram, ctx, runtime); return;
}


// Function: entry_1dcb44
// Address: 0x1dcb44 - 0x1dcb54

void entry_1dcb44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcb44: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dcb48: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcb4c: 0xc0611fc
    SET_GPR_U32(ctx, 31, 0x1dcb54);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22080));
    SetLightHighlightColor__FP5LIGHTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1dcb54
// Address: 0x1dcb54 - 0x1dcb64

void entry_1dcb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcb54: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcb58: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcb5c: 0xc061216
    SET_GPR_U32(ctx, 31, 0x1dcb64);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22096)); ctx->f[12] = *(float*)&val; }
    SetLightHighlightAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcb64
// Address: 0x1dcb64 - 0x1dcb74

void entry_1dcb64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcb64: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcb68: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcb6c: 0xc061206
    SET_GPR_U32(ctx, 31, 0x1dcb74);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22100)); ctx->f[12] = *(float*)&val; }
    SetLightMidtoneStrength__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcb74
// Address: 0x1dcb74 - 0x1dcb84

void entry_1dcb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcb74: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcb78: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcb7c: 0xc06121e
    SET_GPR_U32(ctx, 31, 0x1dcb84);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22104)); ctx->f[12] = *(float*)&val; }
    SetLightMidtoneAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcb84
// Address: 0x1dcb84 - 0x1dcb94

void entry_1dcb84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcb84: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcb88: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcb8c: 0xc06120e
    SET_GPR_U32(ctx, 31, 0x1dcb94);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22108)); ctx->f[12] = *(float*)&val; }
    SetLightShadowStrength__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcb94
// Address: 0x1dcb94 - 0x1dcba4

void entry_1dcb94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcb94: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcb98: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcb9c: 0xc061226
    SET_GPR_U32(ctx, 31, 0x1dcba4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22112)); ctx->f[12] = *(float*)&val; }
    SetLightShadowAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcba4
// Address: 0x1dcba4 - 0x1dcbb4

void entry_1dcba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcba4: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dcba8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcbac: 0xc06122e
    SET_GPR_U32(ctx, 31, 0x1dcbb4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22128));
    SetLightDirection__FP5LIGHTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1dcbb4
// Address: 0x1dcbb4 - 0x1dcbc4

void entry_1dcbb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcbb4: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dcbb8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcbbc: 0xc061264
    SET_GPR_U32(ctx, 31, 0x1dcbc4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22168));
    SetLightFallOff__FP5LIGHTP2LM(rdram, ctx, runtime); return;
}


// Function: entry_1dcbc4
// Address: 0x1dcbc4 - 0x1dcbdc

void entry_1dcbc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcbc4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1dcbc8: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dcbcc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcbd0: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1dcbd4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dcbdc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22144));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dcbdc
// Address: 0x1dcbdc - 0x1dcc00

void entry_1dcbdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcbdc: 0x8e425630
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 22064)));
    // 0x1dcbe0: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1dcbe4: 0x10400030
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1dcca8(rdram, ctx, runtime); return;
    }
    // 0x1dcbec: 0x24070201
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 513));
    // 0x1dcbf0: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1dcbf4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1dcbf8: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1dcc00);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 81));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1dcc00
// Address: 0x1dcc00 - 0x1dcc10

void entry_1dcc00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcc00: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dcc04: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1dcc08: 0xc0611da
    SET_GPR_U32(ctx, 31, 0x1dcc10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetLightKind__FP5LIGHT6LIGHTK(rdram, ctx, runtime); return;
}


// Function: entry_1dcc10
// Address: 0x1dcc10 - 0x1dcc20

void entry_1dcc10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcc10: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dcc14: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcc18: 0xc0611fc
    SET_GPR_U32(ctx, 31, 0x1dcc20);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22080));
    SetLightHighlightColor__FP5LIGHTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1dcc20
// Address: 0x1dcc20 - 0x1dcc30

void entry_1dcc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcc20: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcc24: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcc28: 0xc061216
    SET_GPR_U32(ctx, 31, 0x1dcc30);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22096)); ctx->f[12] = *(float*)&val; }
    SetLightHighlightAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcc30
// Address: 0x1dcc30 - 0x1dcc40

void entry_1dcc30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcc30: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcc34: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcc38: 0xc061206
    SET_GPR_U32(ctx, 31, 0x1dcc40);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22100)); ctx->f[12] = *(float*)&val; }
    SetLightMidtoneStrength__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcc40
// Address: 0x1dcc40 - 0x1dcc50

void entry_1dcc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcc40: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcc44: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcc48: 0xc06121e
    SET_GPR_U32(ctx, 31, 0x1dcc50);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22104)); ctx->f[12] = *(float*)&val; }
    SetLightMidtoneAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcc50
// Address: 0x1dcc50 - 0x1dcc60

void entry_1dcc50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcc50: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcc54: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcc58: 0xc06120e
    SET_GPR_U32(ctx, 31, 0x1dcc60);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22108)); ctx->f[12] = *(float*)&val; }
    SetLightShadowStrength__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcc60
// Address: 0x1dcc60 - 0x1dcc70

void entry_1dcc60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcc60: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcc64: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcc68: 0xc061226
    SET_GPR_U32(ctx, 31, 0x1dcc70);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22112)); ctx->f[12] = *(float*)&val; }
    SetLightShadowAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1dcc70
// Address: 0x1dcc70 - 0x1dcc80

void entry_1dcc70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcc70: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dcc74: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcc78: 0xc06122e
    SET_GPR_U32(ctx, 31, 0x1dcc80);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22128));
    SetLightDirection__FP5LIGHTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1dcc80
// Address: 0x1dcc80 - 0x1dcc90

void entry_1dcc80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcc80: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dcc84: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcc88: 0xc061264
    SET_GPR_U32(ctx, 31, 0x1dcc90);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22176));
    SetLightFallOff__FP5LIGHTP2LM(rdram, ctx, runtime); return;
}


// Function: entry_1dcc90
// Address: 0x1dcc90 - 0x1dcca8

void entry_1dcc90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcc90: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1dcc94: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1dcc98: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dcc9c: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1dcca0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dcca8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22144));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dcca8
// Address: 0x1dcca8 - 0x1dccc0

void entry_1dcca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcca8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dccac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dccb0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dccb4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dccb8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001dccc0
// Address: 0x1dccc0 - 0x1dccd8

void FUN_001dccc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dccc0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1dccc4: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1dccc8: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1dcccc: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1dccd0: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x1dccd8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1dccd8
// Address: 0x1dccd8 - 0x1dcd08

void entry_1dccd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dccd8) {
        switch (ctx->pc) {
            case 0x1dcd00: ctx->pc = 0; goto label_1dcd00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dccd8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dccdc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dcce0: 0x8c435714
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22292)));
    // 0x1dcce4: 0x1060000a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DCD10; return;
    }
    // 0x1dccec: 0x204102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 4)));
    // 0x1dccf0: 0x10400007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 4), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DCD10; return;
    }
    // 0x1dccf8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1dccfc: 0x0
    // NOP
label_1dcd00:
    // 0x1dcd00: 0xc04e146
    SET_GPR_U32(ctx, 31, 0x1dcd08);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    Unknown1__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1dcd08
// Address: 0x1dcd08 - 0x1dcd28

void entry_1dcd08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dcd08) {
        switch (ctx->pc) {
            case 0x1dcd10: ctx->pc = 0; goto label_1dcd10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dcd08: 0x1600fffd
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DCD00; return;
    }
label_1dcd10:
    // 0x1dcd10: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dcd14: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dcd18: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dcd1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dcd24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dcd28; return;
}


// Function: CreateSwPrizes__FP2SW
// Address: 0x1dcd28 - 0x1dce20

void entry_1dce20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dce20: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dce24: 0xae1402d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 728), GPR_U32(ctx, 20));
    // 0x1dce28: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1dce2c: 0x8c42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1dce30: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1dce40(rdram, ctx, runtime); return;
    }
    // 0x1dce38: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dce40);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dce40
// Address: 0x1dce40 - 0x1dce50

void entry_1dce40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dce40: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1dce44: 0x8c430050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x1dce48: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1dce50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1dce50
// Address: 0x1dce50 - 0x1dcea0

void entry_1dce50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dce50) {
        switch (ctx->pc) {
            case 0x1dce60: ctx->pc = 0; goto label_1dce60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dce50: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1dce54: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1dce58: 0x5440ffed
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1DCE10; return;
    }
label_1dce60:
    // 0x1dce60: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1dce64: 0x2ce20002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 7), 2));
    // 0x1dce68: 0x5440ffc7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 21), 7252)));
        ctx->pc = 0x1DCD88; return;
    }
    // 0x1dce70: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1dce74: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1dce78: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1dce7c: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1dce80: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1dce84: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dce88: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dce8c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dce90: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dce94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dce9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dcea0; return;
}


// Function: LoadSwFromBrx__FP2SWP18CBinaryInputStream
// Address: 0x1dcea0 - 0x1dceec

void entry_1dceec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dceec: 0xc046fdc
    SET_GPR_U32(ctx, 31, 0x1dcef4);
    StartupSplice__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1dcef4
// Address: 0x1dcef4 - 0x1dcefc

void entry_1dcef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcef4: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x1dcefc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1dcefc
// Address: 0x1dcefc - 0x1dcf08

void entry_1dcefc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcefc: 0xae025714
    WRITE32(ADD32(GPR_U32(ctx, 16), 22292), GPR_U32(ctx, 2));
    // 0x1dcf00: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1dcf08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1dcf08
// Address: 0x1dcf08 - 0x1dcf18

void entry_1dcf08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcf08: 0x24100009
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 9));
    // 0x1dcf0c: 0xae421d70
    WRITE32(ADD32(GPR_U32(ctx, 18), 7536), GPR_U32(ctx, 2));
    // 0x1dcf10: 0xc077330
    SET_GPR_U32(ctx, 31, 0x1dcf18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FUN_001dccc0(rdram, ctx, runtime); return;
}


// Function: entry_1dcf18
// Address: 0x1dcf18 - 0x1dcf30

void entry_1dcf18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcf18: 0x2404006d
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 109));
    // 0x1dcf1c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dcf20: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dcf24: 0x24070004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1dcf28: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1dcf30);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1dcf30
// Address: 0x1dcf30 - 0x1dcf58

void entry_1dcf30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dcf30) {
        switch (ctx->pc) {
            case 0x1dcf40: ctx->pc = 0; goto label_1dcf40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dcf30: 0x27a30020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1dcf34: 0xae221990
    WRITE32(ADD32(GPR_U32(ctx, 17), 6544), GPR_U32(ctx, 2));
    // 0x1dcf38: 0xafa30030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 3));
    // 0x1dcf3c: 0x2404001e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 30));
label_1dcf40:
    // 0x1dcf40: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dcf44: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dcf48: 0x2407000a
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1dcf4c: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1dcf50: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1dcf58);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1dcf58
// Address: 0x1dcf58 - 0x1dcf6c

void entry_1dcf58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcf58: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1dcf5c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dcf60: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1dcf64: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dcf6c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dcf6c
// Address: 0x1dcf6c - 0x1dcfa8

void entry_1dcf6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dcf6c) {
        switch (ctx->pc) {
            case 0x1dcf90: ctx->pc = 0; goto label_1dcf90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dcf6c: 0x601fff4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 30));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x1DCF40; return;
    }
    // 0x1dcf74: 0x26512310
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 8976));
    // 0x1dcf78: 0x26542314
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 18), 8980));
    // 0x1dcf7c: 0x26551d74
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 18), 7540));
    // 0x1dcf80: 0x26561be8
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 18), 7144));
    // 0x1dcf84: 0x26570048
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 18), 72));
    // 0x1dcf88: 0x24100027
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 39));
    // 0x1dcf8c: 0x2404004d
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 77));
label_1dcf90:
    // 0x1dcf90: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dcf94: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dcf98: 0x2407000b
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1dcf9c: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1dcfa0: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1dcfa8);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1dcfa8
// Address: 0x1dcfa8 - 0x1dcfbc

void entry_1dcfa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcfa8: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1dcfac: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dcfb0: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1dcfb4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dcfbc);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dcfbc
// Address: 0x1dcfbc - 0x1dcfd0

void entry_1dcfbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcfbc: 0x603fff4
    if (GPR_S32(ctx, 16) >= 0) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 77));
        ctx->pc = 0x1DCF90; return;
    }
    // 0x1dcfc4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dcfc8: 0xc070464
    SET_GPR_U32(ctx, 31, 0x1dcfd0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadSwSpliceFromBrx__FP2SWP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1dcfd0
// Address: 0x1dcfd0 - 0x1dcfdc

void entry_1dcfd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcfd0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dcfd4: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x1dcfdc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1dcfdc
// Address: 0x1dcfdc - 0x1dcfe8

void entry_1dcfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcfdc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1dcfe0: 0xc04e154
    SET_GPR_U32(ctx, 31, 0x1dcfe8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    Unknown2__18CBinaryInputStreamPPv(rdram, ctx, runtime); return;
}


// Function: entry_1dcfe8
// Address: 0x1dcfe8 - 0x1dcff4

void entry_1dcfe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcfe8: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1dcfec: 0xc04e128
    SET_GPR_U32(ctx, 31, 0x1dcff4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ReadStringSw__18CBinaryInputStreamPPc(rdram, ctx, runtime); return;
}


// Function: entry_1dcff4
// Address: 0x1dcff4 - 0x1dd000

void entry_1dcff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dcff4: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1dcff8: 0xc04e154
    SET_GPR_U32(ctx, 31, 0x1dd000);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    Unknown2__18CBinaryInputStreamPPv(rdram, ctx, runtime); return;
}


// Function: entry_1dd000
// Address: 0x1dd000 - 0x1dd008

void entry_1dd000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd000: 0xc06cc10
    SET_GPR_U32(ctx, 31, 0x1dd008);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadShadersFromBrx__FP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1dd008
// Address: 0x1dd008 - 0x1dd018

void entry_1dd008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd008: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dd00c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dd010: 0xc047b2e
    SET_GPR_U32(ctx, 31, 0x1dd018);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadSwObjectsFromBrx__FP2SWP3ALOP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1dd018
// Address: 0x1dd018 - 0x1dd020

void entry_1dd018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd018: 0xc076e8e
    SET_GPR_U32(ctx, 31, 0x1dd020);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    LoadBulkDataFromBrx__FP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1dd020
// Address: 0x1dd020 - 0x1dd034

void entry_1dd020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd020: 0x8e441d70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 7536)));
    // 0x1dd024: 0x4820004
    if (GPR_S32(ctx, 4) < 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 7544)));
        ctx->pc = 0x1DD038; return;
    }
    // 0x1dd02c: 0xc06f89a
    SET_GPR_U32(ctx, 31, 0x1dd034);
    SbpEnsureBank__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1dd034
// Address: 0x1dd034 - 0x1dd048

void entry_1dd034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd034) {
        switch (ctx->pc) {
            case 0x1dd038: ctx->pc = 0; goto label_1dd038;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd034: 0x8e421d78
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 7544)));
label_1dd038:
    // 0x1dd038: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1dd048(rdram, ctx, runtime); return;
    }
    // 0x1dd040: 0xc06fb3e
    SET_GPR_U32(ctx, 31, 0x1dd048);
    PauseMusic__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1dd048
// Address: 0x1dd048 - 0x1dd050

void entry_1dd048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd048: 0xc06fac4
    SET_GPR_U32(ctx, 31, 0x1dd050);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 7540)));
    PreloadMusidSong__F5MUSID(rdram, ctx, runtime); return;
}


// Function: entry_1dd050
// Address: 0x1dd050 - 0x1dd058

void entry_1dd050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd050: 0xc06cd14
    SET_GPR_U32(ctx, 31, 0x1dd058);
    UploadPermShaders__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1dd058
// Address: 0x1dd058 - 0x1dd060

void entry_1dd058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd058: 0xc0549c8
    SET_GPR_U32(ctx, 31, 0x1dd060);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    FIsDlEmpty__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_1dd060
// Address: 0x1dd060 - 0x1dd070

void entry_1dd060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd060: 0x10400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 128));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DD074; return;
    }
    // 0x1dd068: 0xc077268
    SET_GPR_U32(ctx, 31, 0x1dd070);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    CreateSwDefaultLights__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1dd070
// Address: 0x1dd070 - 0x1dd09c

void entry_1dd070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd070) {
        switch (ctx->pc) {
            case 0x1dd074: ctx->pc = 0; goto label_1dd074;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd070: 0x24020080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 128));
label_1dd074:
    // 0x1dd074: 0x3c04002c
    SET_GPR_U32(ctx, 4, ((uint32_t)44 << 16));
    // 0x1dd078: 0xa2421d67
    WRITE8(ADD32(GPR_U32(ctx, 18), 7527), (uint8_t)GPR_U32(ctx, 2));
    // 0x1dd07c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1dd080: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dd084: 0x8a471d67
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 7527); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | ((word >> shift) & mask)); }
    // 0x1dd088: 0x9a471d64
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 7524); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | (word << shift)); }
    // 0x1dd08c: 0xaba70003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1dd090: 0xbba70000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1dd094: 0xc05a1dc
    SET_GPR_U32(ctx, 31, 0x1dd09c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294958112));
    BuildClearGifs__FP2QWG4RGBAi(rdram, ctx, runtime); return;
}


// Function: entry_1dd09c
// Address: 0x1dd09c - 0x1dd0c8

void entry_1dd09c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd09c: 0x3c013b80
    SET_GPR_U32(ctx, 1, ((uint32_t)15232 << 16));
    // 0x1dd0a0: 0x34218081
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32897));
    // 0x1dd0a4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1dd0a8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dd0ac: 0xc6421d68
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 7528)); ctx->f[2] = *(float*)&val; }
    // 0x1dd0b0: 0xc6401d6c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 7532)); ctx->f[0] = *(float*)&val; }
    // 0x1dd0b4: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1dd0b8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1dd0bc: 0xe6421d68
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 18), 7528), *(uint32_t*)&val); }
    // 0x1dd0c0: 0xc07734a
    SET_GPR_U32(ctx, 31, 0x1dd0c8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 7532), *(uint32_t*)&val); }
    CreateSwPrizes__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1dd0c8
// Address: 0x1dd0c8 - 0x1dd0d0

void entry_1dd0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd0c8: 0xc076f92
    SET_GPR_U32(ctx, 31, 0x1dd0d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ProcessSwCallbacks__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1dd0d0
// Address: 0x1dd0d0 - 0x1dd0f4

void entry_1dd0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd0d0) {
        switch (ctx->pc) {
            case 0x1dd0e0: ctx->pc = 0; goto label_1dd0e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd0d0: 0x8e500048
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 72)));
    // 0x1dd0d4: 0x1200000a
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DD100; return;
    }
    // 0x1dd0dc: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1dd0e0:
    // 0x1dd0e0: 0x8c42004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1dd0e4: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x1DD0F8; return;
    }
    // 0x1dd0ec: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dd0f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dd0f4
// Address: 0x1dd0f4 - 0x1dd108

void entry_1dd0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd0f4) {
        switch (ctx->pc) {
            case 0x1dd0f8: ctx->pc = 0; goto label_1dd0f8;
            case 0x1dd100: ctx->pc = 0; goto label_1dd100;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd0f4: 0x8e10001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
label_1dd0f8:
    // 0x1dd0f8: 0x5600fff9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1DD0E0; return;
    }
label_1dd100:
    // 0x1dd100: 0xc076f92
    SET_GPR_U32(ctx, 31, 0x1dd108);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ProcessSwCallbacks__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1dd108
// Address: 0x1dd108 - 0x1dd148

void entry_1dd108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd108) {
        switch (ctx->pc) {
            case 0x1dd138: ctx->pc = 0; goto label_1dd138;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd108: 0x8fa70030
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dd10c: 0x8ee40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 23), 8)));
    // 0x1dd110: 0x8fc2b314
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 4294947604)));
    // 0x1dd114: 0xafc7b314
    WRITE32(ADD32(GPR_U32(ctx, 30), 4294947604), GPR_U32(ctx, 7));
    // 0x1dd118: 0xafa2002c
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 2));
    // 0x1dd11c: 0x8e430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 72)));
    // 0x1dd120: 0xafb70020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 23));
    // 0x1dd124: 0x641021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1dd128: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1dd12c: 0xafa20024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    // 0x1dd130: 0x10a0000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DD164; return;
    }
label_1dd138:
    // 0x1dd138: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1dd13c: 0x8c620050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 80)));
    // 0x1dd140: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dd148);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dd148
// Address: 0x1dd148 - 0x1dd174

void entry_1dd148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd148) {
        switch (ctx->pc) {
            case 0x1dd164: ctx->pc = 0; goto label_1dd164;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd148: 0x8fa40024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1dd14c: 0x8fa20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1dd150: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1dd154: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1dd158: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1dd15c: 0x14a0fff6
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DD138; return;
    }
label_1dd164:
    // 0x1dd164: 0x8fa2002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x1dd168: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dd16c: 0xc076f92
    SET_GPR_U32(ctx, 31, 0x1dd174);
    WRITE32(ADD32(GPR_U32(ctx, 30), 4294947604), GPR_U32(ctx, 2));
    ProcessSwCallbacks__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1dd174
// Address: 0x1dd174 - 0x1dd180

void entry_1dd174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd174: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x1dd178: 0xc05474a
    SET_GPR_U32(ctx, 31, 0x1dd180);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 8), 7920));
    OnDifficultyWorldPostLoad(rdram, ctx, runtime); return;
}


// Function: entry_1dd180
// Address: 0x1dd180 - 0x1dd18c

void entry_1dd180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd180: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1dd184: 0xc07a43a
    SET_GPR_U32(ctx, 31, 0x1dd18c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PostUiLoad__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_1dd18c
// Address: 0x1dd18c - 0x1dd1bc

void entry_1dd18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd18c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dd190: 0x2442f808
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965256));
    // 0x1dd194: 0x8c430260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 608)));
    // 0x1dd198: 0x14600009
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DD1C0; return;
    }
    // 0x1dd1a0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1dd1a4: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1dd1a8: 0x8c6419d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x1dd1ac: 0x10800004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DD1C0; return;
    }
    // 0x1dd1b4: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1dd1bc);
    SET_GPR_U32(ctx, 4, ((uint32_t)8 << 16));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1dd1bc
// Address: 0x1dd1bc - 0x1dd1c8

void entry_1dd1bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd1bc) {
        switch (ctx->pc) {
            case 0x1dd1c0: ctx->pc = 0; goto label_1dd1c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd1bc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1dd1c0:
    // 0x1dd1c0: 0xc05109c
    SET_GPR_U32(ctx, 31, 0x1dd1c8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    SetupCm__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_1dd1c8
// Address: 0x1dd1c8 - 0x1dd1d4

void entry_1dd1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd1c8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dd1cc: 0xc04e300
    SET_GPR_U32(ctx, 31, 0x1dd1d4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RecalcSwXpAll__FP2SWi(rdram, ctx, runtime); return;
}


// Function: entry_1dd1d4
// Address: 0x1dd1d4 - 0x1dd1dc

void entry_1dd1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd1d4: 0xc06fb16
    SET_GPR_U32(ctx, 31, 0x1dd1dc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 7540)));
    StartMusidSong__F5MUSID(rdram, ctx, runtime); return;
}


// Function: entry_1dd1dc
// Address: 0x1dd1dc - 0x1dd1e4

void entry_1dd1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd1dc: 0xc0702ce
    SET_GPR_U32(ctx, 31, 0x1dd1e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    StartSwIntermittentSounds__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1dd1e4
// Address: 0x1dd1e4 - 0x1dd218

void entry_1dd1e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd1e4: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1dd1e8: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1dd1ec: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1dd1f0: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1dd1f4: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1dd1f8: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1dd1fc: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1dd200: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1dd204: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1dd208: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dd20c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dd214: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dd218; return;
}


// Function: FClipLineHomogeneous__FP7VECTOR4
// Address: 0x1dd218 - 0x1dd3e0

void entry_1dd448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd448: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    // 0x1dd44c: 0x621fffa
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x1DD438; return;
    }
    // 0x1dd454: 0xc077486
    SET_GPR_U32(ctx, 31, 0x1dd45c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FClipLineHomogeneous__FP7VECTOR4(rdram, ctx, runtime); return;
}


// Function: entry_1dd45c
// Address: 0x1dd45c - 0x1dd520

void entry_1dd45c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd45c) {
        switch (ctx->pc) {
            case 0x1dd4a0: ctx->pc = 0; goto label_1dd4a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd45c: 0x10400030
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1dd520(rdram, ctx, runtime); return;
    }
    // 0x1dd464: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1dd468: 0xc449abf0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294945776)); ctx->f[9] = *(float*)&val; }
    // 0x1dd46c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dd470: 0xc468ac00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294945792)); ctx->f[8] = *(float*)&val; }
    // 0x1dd474: 0x2442abf0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945776));
    // 0x1dd478: 0x2463ac00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294945792));
    // 0x1dd47c: 0xc4470008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[7] = *(float*)&val; }
    // 0x1dd480: 0xc4660008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[6] = *(float*)&val; }
    // 0x1dd484: 0x27aa0040
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1dd488: 0xc4450004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    // 0x1dd48c: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1dd490: 0xc4640004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[4] = *(float*)&val; }
    // 0x1dd494: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1dd498: 0x44815000
    *(uint32_t*)&ctx->f[10] = GPR_U32(ctx, 1);
    // 0x1dd49c: 0x0
    // NOP
label_1dd4a0:
    // 0x1dd4a0: 0xc483000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 12)); ctx->f[3] = *(float*)&val; }
    // 0x1dd4a4: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1dd4a8: 0xc4820000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1dd4ac: 0x460350c3
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[3] = copysignf(INFINITY, ctx->f[10] * 0.0f); } else ctx->f[3] = ctx->f[10] / ctx->f[3];
    // 0x1dd4b0: 0xc4810004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1dd4b4: 0xc4800008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1dd4b8: 0x46031082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x1dd4bc: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1dd4c0: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1dd4c4: 0x46091082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[9]);
    // 0x1dd4c8: 0x46070002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[7]);
    // 0x1dd4cc: 0x46050842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[5]);
    // 0x1dd4d0: 0x46081080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[8]);
    // 0x1dd4d4: 0x46060000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[6]);
    // 0x1dd4d8: 0x46040840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[4]);
    // 0x1dd4dc: 0xe4820000
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x1dd4e0: 0xe4800008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 8), *(uint32_t*)&val); }
    // 0x1dd4e4: 0xe4810004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 4), *(uint32_t*)&val); }
    // 0x1dd4e8: 0x621ffed
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16));
    if (GPR_S32(ctx, 17) >= 0) {
        goto label_1dd4a0;
    }
    // 0x1dd4f0: 0x8aa20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 21), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1dd4f4: 0x9aa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 21), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1dd4f8: 0xaba20043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1dd4fc: 0xbba20040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1dd500: 0x280582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1dd504: 0x8fa40020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dd508: 0x8fa50024
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1dd50c: 0x8fa60028
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1dd510: 0x8fa70030
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dd514: 0x8fa80034
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x1dd518: 0xc06b8ee
    SET_GPR_U32(ctx, 31, 0x1dd520);
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    DrawLineScreen__FUiUiUiUiUiUiG4RGBAi(rdram, ctx, runtime); return;
}


// Function: entry_1dd520
// Address: 0x1dd520 - 0x1dd548

void entry_1dd520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd520: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1dd524: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1dd528: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1dd52c: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1dd530: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1dd534: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1dd538: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1dd53c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dd544: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dd548; return;
}


// Function: DrawAxesWorld__FP6VECTORP7MATRIX3fP2CMi
// Address: 0x1dd548 - 0x1dd588

void entry_1dd588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd588) {
        switch (ctx->pc) {
            case 0x1dd598: ctx->pc = 0; goto label_1dd598;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd588: 0x27b300a0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1dd58c: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1dd590: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1dd594: 0x0
    // NOP
label_1dd598:
    // 0x1dd598: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dd59c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1dd5a0: 0x8aa20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 21), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1dd5a4: 0x9aa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 21), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1dd5a8: 0xaba200a3
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 163); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1dd5ac: 0xbba200a0
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 160); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1dd5b0: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1dd5b4: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1dd5b8: 0xc0774f8
    SET_GPR_U32(ctx, 31, 0x1dd5c0);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    DrawLineWorld__FP6VECTORT0G4RGBAP2CMi(rdram, ctx, runtime); return;
}


// Function: entry_1dd5c0
// Address: 0x1dd5c0 - 0x1dd5f8

void entry_1dd5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd5c0: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1dd5c4: 0x26310010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    // 0x1dd5c8: 0x2e42000a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 10));
    // 0x1dd5cc: 0x1440fff2
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DD598; return;
    }
    // 0x1dd5d4: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1dd5d8: 0x7bb50100
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1dd5dc: 0x7bb400f0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1dd5e0: 0x7bb300e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1dd5e4: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1dd5e8: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1dd5ec: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1dd5f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSwIllum__FP2SWf
// Address: 0x1dd5f8 - 0x1dd610

void entry_1dd65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd65c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1dd660: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1dd664: 0xc6002318
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8984)); ctx->f[0] = *(float*)&val; }
    // 0x1dd668: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1dd66c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1dd670: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1dd674: 0xc04764a
    SET_GPR_U32(ctx, 31, 0x1dd67c);
    snd_SetGlobalExcite(rdram, ctx, runtime); return;
}


// Function: entry_1dd67c
// Address: 0x1dd67c - 0x1dd690

void entry_1dd67c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd67c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dd680: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd684: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dd68c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dd690; return;
}


// Function: FLevelSwVisited__FP2SW3WID
// Address: 0x1dd690 - 0x1dd6a0

void entry_1dd6a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd6a0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd6a4: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1dd6a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FLevelSwPrimary__FP2SW3WID
// Address: 0x1dd6b0 - 0x1dd6c0

void entry_1dd6c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd6c0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd6c4: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1dd6c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FLevelSwSecondary__FP2SW3WID
// Address: 0x1dd6d0 - 0x1dd6e0

void entry_1dd6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd6e0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd6e4: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x1dd6e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FLevelSwTertiary__FP2SW3WID
// Address: 0x1dd6f0 - 0x1dd700

void entry_1dd700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd700: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd704: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1dd708: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001dd710
// Address: 0x1dd710 - 0x1dd720

void FUN_001dd710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd710: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1dd714: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1dd718: 0xc058076
    SET_GPR_U32(ctx, 31, 0x1dd720);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    get_level_completion_by_id(rdram, ctx, runtime); return;
}


// Function: entry_1dd720
// Address: 0x1dd720 - 0x1dd758

void entry_1dd720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd720) {
        switch (ctx->pc) {
            case 0x1dd744: ctx->pc = 0; goto label_1dd744;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd720: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1dd724: 0x10400007
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1dd744;
    }
    // 0x1dd72c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1dd730: 0x8c6423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 9160)));
    // 0x1dd734: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1dd738: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1dd73c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1dd740: 0x2180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 0));
label_1dd744:
    // 0x1dd744: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd748: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1dd74c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dd754: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dd758; return;
}


// Function: FUN_001dd758
// Address: 0x1dd758 - 0x1dd768

void FUN_001dd758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd758: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1dd75c: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1dd760: 0xc058076
    SET_GPR_U32(ctx, 31, 0x1dd768);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    get_level_completion_by_id(rdram, ctx, runtime); return;
}


// Function: entry_1dd768
// Address: 0x1dd768 - 0x1dd7a0

void entry_1dd768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd768) {
        switch (ctx->pc) {
            case 0x1dd790: ctx->pc = 0; goto label_1dd790;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd768: 0x30450003
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 2), 3));
    // 0x1dd76c: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x1dd770: 0x10400007
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1dd790;
    }
    // 0x1dd778: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1dd77c: 0x8c4423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1dd780: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1dd784: 0xa31824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x1dd788: 0x651826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1dd78c: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
label_1dd790:
    // 0x1dd790: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd794: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1dd798: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001dd7a0
// Address: 0x1dd7a0 - 0x1dd7b0

void FUN_001dd7a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd7a0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1dd7a4: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1dd7a8: 0xc058076
    SET_GPR_U32(ctx, 31, 0x1dd7b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    get_level_completion_by_id(rdram, ctx, runtime); return;
}


// Function: entry_1dd7b0
// Address: 0x1dd7b0 - 0x1dd7e8

void entry_1dd7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd7b0) {
        switch (ctx->pc) {
            case 0x1dd7d8: ctx->pc = 0; goto label_1dd7d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd7b0: 0x30450007
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 2), 7));
    // 0x1dd7b4: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1dd7b8: 0x10400007
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1dd7d8;
    }
    // 0x1dd7c0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1dd7c4: 0x8c4423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1dd7c8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1dd7cc: 0xa31824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x1dd7d0: 0x651826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1dd7d4: 0x2c630001
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 1));
label_1dd7d8:
    // 0x1dd7d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd7dc: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1dd7e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001dd7e8
// Address: 0x1dd7e8 - 0x1dd808

void FUN_001dd7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd7e8: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1dd7ec: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1dd7f0: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1dd7f4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1dd7f8: 0xe0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1dd7fc: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1dd800: 0xc058204
    SET_GPR_U32(ctx, 31, 0x1dd808);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    LsFromWid(rdram, ctx, runtime); return;
}


// Function: entry_1dd808
// Address: 0x1dd808 - 0x1dd888

void entry_1dd808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd808) {
        switch (ctx->pc) {
            case 0x1dd820: ctx->pc = 0; goto label_1dd820;
            case 0x1dd824: ctx->pc = 0; goto label_1dd824;
            case 0x1dd828: ctx->pc = 0; goto label_1dd828;
            case 0x1dd850: ctx->pc = 0; goto label_1dd850;
            case 0x1dd854: ctx->pc = 0; goto label_1dd854;
            case 0x1dd860: ctx->pc = 0; goto label_1dd860;
            case 0x1dd870: ctx->pc = 0; goto label_1dd870;
            case 0x1dd874: ctx->pc = 0; goto label_1dd874;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd808: 0x10400019
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1dd870;
    }
    // 0x1dd810: 0x24440044
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 68));
    // 0x1dd814: 0x10000004
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dd828;
    }
    // 0x1dd81c: 0x0
    // NOP
label_1dd820:
    // 0x1dd820: 0x24840008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
label_1dd824:
    // 0x1dd824: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
label_1dd828:
    // 0x1dd828: 0x2cc20004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 4));
    // 0x1dd82c: 0x1040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1dd860;
    }
    // 0x1dd834: 0x14a00006
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1dd850;
    }
    // 0x1dd83c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1dd840: 0x14400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1dd854;
    }
    // 0x1dd848: 0x1000fff5
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dd820;
    }
label_1dd850:
    // 0x1dd850: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
label_1dd854:
    // 0x1dd854: 0x5450fff3
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
        goto label_1dd824;
    }
    // 0x1dd85c: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_1dd860:
    // 0x1dd860: 0x10a00004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1dd874;
    }
    // 0x1dd868: 0xacb10004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 17));
    // 0x1dd86c: 0xacb00000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 16));
label_1dd870:
    // 0x1dd870: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1dd874:
    // 0x1dd874: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dd878: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd87c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dd884: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dd888; return;
}


// Function: FUN_001dd888
// Address: 0x1dd888 - 0x1dd8a0

void FUN_001dd888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd888: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1dd88c: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1dd890: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1dd894: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1dd898: 0xc058204
    SET_GPR_U32(ctx, 31, 0x1dd8a0);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    LsFromWid(rdram, ctx, runtime); return;
}


// Function: entry_1dd8a0
// Address: 0x1dd8a0 - 0x1dd8e8

void entry_1dd8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dd8a0) {
        switch (ctx->pc) {
            case 0x1dd8b0: ctx->pc = 0; goto label_1dd8b0;
            case 0x1dd8c4: ctx->pc = 0; goto label_1dd8c4;
            case 0x1dd8d4: ctx->pc = 0; goto label_1dd8d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dd8a0: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1dd8d4;
    }
    // 0x1dd8a8: 0x24430044
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 68));
    // 0x1dd8ac: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1dd8b0:
    // 0x1dd8b0: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1dd8b4: 0x54500003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_1dd8c4;
    }
    // 0x1dd8bc: 0x10000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dd8d4;
    }
label_1dd8c4:
    // 0x1dd8c4: 0x2c820004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 4));
    // 0x1dd8c8: 0x1440fff9
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1dd8b0;
    }
    // 0x1dd8d0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1dd8d4:
    // 0x1dd8d4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dd8d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd8dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dd8e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dd8e8; return;
}


// Function: FUN_001dd8e8
// Address: 0x1dd8e8 - 0x1dd908

void FUN_001dd8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd8e8: 0x2402044c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x1dd8ec: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1dd8f0: 0xa22818
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1dd8f4: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1dd8f8: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1dd8fc: 0x8c620458
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1112)));
    // 0x1dd900: 0x3e00008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001dd908
// Address: 0x1dd908 - 0x1dd928

void FUN_001dd908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd908: 0x2402044c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x1dd90c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1dd910: 0xa22818
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1dd914: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1dd918: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1dd91c: 0x8c620458
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1112)));
    // 0x1dd920: 0x3e00008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001dd928
// Address: 0x1dd928 - 0x1dd940

void FUN_001dd928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd928: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1dd92c: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1dd930: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1dd934: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1dd938: 0xc0582ca
    SET_GPR_U32(ctx, 31, 0x1dd940);
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime); return;
}


// Function: entry_1dd940
// Address: 0x1dd940 - 0x1dd950

void entry_1dd940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd940: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd944: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dd94c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dd950; return;
}


// Function: FUN_001dd950
// Address: 0x1dd950 - 0x1dd96c

void FUN_001dd950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd950: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1dd954: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1dd958: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1dd95c: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1dd960: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1dd964: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x1dd96c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_1dd96c
// Address: 0x1dd96c - 0x1dd98c

void entry_1dd96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd96c: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dd970: 0x10e00006
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_1dd98c(rdram, ctx, runtime); return;
    }
    // 0x1dd978: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dd97c: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1dd980: 0x24050058
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 88));
    // 0x1dd984: 0xc0522b0
    SET_GPR_U32(ctx, 31, 0x1dd98c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CpdprizeAttractSwDprizes__FP2SW3CIDP6VECTORiPP6DPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_1dd98c
// Address: 0x1dd98c - 0x1dd9a0

void entry_1dd98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd98c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dd990: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd994: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dd99c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dd9a0; return;
}


// Function: FUN_001dd9a0
// Address: 0x1dd9a0 - 0x1dd9b4

void FUN_001dd9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd9a0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1dd9a4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1dd9a8: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1dd9ac: 0xc054904
    SET_GPR_U32(ctx, 31, 0x1dd9b4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    ChangeSuck__FfP10DIFFICULTY(rdram, ctx, runtime); return;
}


// Function: entry_1dd9b4
// Address: 0x1dd9b4 - 0x1dd9c0

void entry_1dd9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd9b4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd9b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001dd9c0
// Address: 0x1dd9c0 - 0x1dd9d8

void FUN_001dd9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd9c0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1dd9c4: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1dd9c8: 0xc460000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1dd9cc: 0x3e00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 0), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dd9d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dd9d8; return;
}


// Function: SetSwPlayerSuck__FP2SWf
// Address: 0x1dd9d8 - 0x1dd9ec

void entry_1dd9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dd9ec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1dd9f0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dd9f4: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1dd9f8: 0xe4600010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 16), *(uint32_t*)&val); }
    // 0x1dd9fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dda04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dda08; return;
}


// Function: GetSwPlayerSuck__FP2SWPf
// Address: 0x1dda08 - 0x1dda20

void entry_1dda44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dda44: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dda48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DecrementSwHandsOff__FP2SW
// Address: 0x1dda50 - 0x1dda70

void entry_1dda70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dda70: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dda74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dda7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dda80; return;
}


// Function: IsSwHandsOff__FP2SW
// Address: 0x1dda80 - 0x1dda90

void entry_1ddaa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddaa4: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1ddaa8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ddaac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ddab0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetSwDarken__FP2SWf
// Address: 0x1ddab8 - 0x1ddac8

void entry_1ddb14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ddb14) {
        switch (ctx->pc) {
            case 0x1ddb18: ctx->pc = 0; goto label_1ddb18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ddb14: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1ddb18:
    // 0x1ddb18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ddb20
// Address: 0x1ddb20 - 0x1ddb48

void FUN_001ddb20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddb20: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ddb24: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1ddb28: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ddb2c: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x1ddb30: 0xa0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ddb34: 0xa8860283
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 643); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ddb38: 0xb8860280
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 640); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1ddb3c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ddb40: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1ddb48);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1ddb48
// Address: 0x1ddb48 - 0x1ddb58

void entry_1ddb48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddb48: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ddb4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ddb54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ddb58; return;
}


// Function: FUN_001ddb58
// Address: 0x1ddb58 - 0x1ddb90

void FUN_001ddb58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddb58: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1ddb5c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ddb60: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1ddb64: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1ddb68: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ddb6c: 0x8c822320
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8992)));
    // 0x1ddb70: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1ddb74: 0x1443000a
    WRITE32(ADD32(GPR_U32(ctx, 4), 8992), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        entry_1ddba0(rdram, ctx, runtime); return;
    }
    // 0x1ddb7c: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    // 0x1ddb80: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ddb84: 0x263021d0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 8656));
    // 0x1ddb88: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1ddb90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1ddb90
// Address: 0x1ddb90 - 0x1ddba0

void entry_1ddb90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddb90: 0x8e2321d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8656)));
    // 0x1ddb94: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1ddb98: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ddba0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ddba0
// Address: 0x1ddba0 - 0x1ddbb8

void entry_1ddba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddba0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ddba4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ddba8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ddbac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ddbb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ddbb8; return;
}


// Function: FUN_001ddbb8
// Address: 0x1ddbb8 - 0x1ddbe4

void FUN_001ddbb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddbb8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ddbbc: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ddbc0: 0x8c822320
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8992)));
    // 0x1ddbc4: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1ddbc8: 0x14400006
    WRITE32(ADD32(GPR_U32(ctx, 4), 8992), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1ddbe4(rdram, ctx, runtime); return;
    }
    // 0x1ddbd0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1ddbd4: 0x8c8321d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8656)));
    // 0x1ddbd8: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1ddbdc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ddbe4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8656));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ddbe4
// Address: 0x1ddbe4 - 0x1ddbf8

void entry_1ddbe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddbe4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ddbe8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ddbf0: 0x2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 0), GPR_S32(ctx, 2)));
    // 0x1ddbf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ddbf8; return;
}


// Function: FUN_001ddbf8
// Address: 0x1ddbf8 - 0x1ddc08

void FUN_001ddbf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddbf8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ddbfc: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ddc00: 0xc06fbbe
    SET_GPR_U32(ctx, 31, 0x1ddc08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    PexcSetExcitement__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1ddc08
// Address: 0x1ddc08 - 0x1ddc18

void entry_1ddc08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddc08: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ddc0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ddc14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ddc18; return;
}


// Function: FUN_001ddc18
// Address: 0x1ddc18 - 0x1ddc28

void FUN_001ddc18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddc18: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ddc1c: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ddc20: 0xc06fc36
    SET_GPR_U32(ctx, 31, 0x1ddc28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    UnsetExcitementHyst__FP3EXC(rdram, ctx, runtime); return;
}


// Function: entry_1ddc28
// Address: 0x1ddc28 - 0x1ddc38

void entry_1ddc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddc28: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ddc2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ddc34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ddc38; return;
}


// Function: FUN_001ddc38
// Address: 0x1ddc38 - 0x1ddc40

void FUN_001ddc38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddc38: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8996), GPR_U32(ctx, 5));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ddc40
// Address: 0x1ddc40 - 0x1ddc6c

void FUN_001ddc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddc40: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ddc44: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ddc48: 0x8c842324
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 8996)));
    // 0x1ddc4c: 0x10800008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDC70; return;
    }
    // 0x1ddc54: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ddc58: 0x8c4200c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 200)));
    // 0x1ddc5c: 0x10400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDC70; return;
    }
    // 0x1ddc64: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ddc6c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ddc6c
// Address: 0x1ddc6c - 0x1ddc78

void entry_1ddc6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ddc6c) {
        switch (ctx->pc) {
            case 0x1ddc70: ctx->pc = 0; goto label_1ddc70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ddc6c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1ddc70:
    // 0x1ddc70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ddc78
// Address: 0x1ddc78 - 0x1ddc90

void FUN_001ddc78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddc78: 0x8c83235c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9052)));
    // 0x1ddc7c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ddc80: 0xa21004
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), GPR_U32(ctx, 5) & 0x1F));
    // 0x1ddc84: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ddc88: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 9052), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ddc90
// Address: 0x1ddc90 - 0x1ddcb0

void FUN_001ddc90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddc90: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ddc94: 0x8c83235c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9052)));
    // 0x1ddc98: 0xa21004
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), GPR_U32(ctx, 5) & 0x1F));
    // 0x1ddc9c: 0x21027
    SET_GPR_U32(ctx, 2, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1ddca0: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ddca4: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 9052), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ddcac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ddcb0; return;
}


// Function: FUN_001ddcb0
// Address: 0x1ddcb0 - 0x1ddcc8

void FUN_001ddcb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddcb0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ddcb4: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1ddcb8: 0x8c6419e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6628)));
    // 0x1ddcbc: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 4));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ddcc4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ddcc8; return;
}


// Function: FUN_001ddcc8
// Address: 0x1ddcc8 - 0x1ddce0

void FUN_001ddcc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddcc8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ddccc: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1ddcd0: 0x8c6419e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6624)));
    // 0x1ddcd4: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 4));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ddcdc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ddce0; return;
}


// Function: InitTail__FP4TAIL
// Address: 0x1ddce0 - 0x1ddcf4

void entry_1ddcf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddcf4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ddcf8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ddcfc: 0x24425730
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 22320));
    // 0x1ddd00: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ddd04: 0x7e030320
    WRITE128(ADD32(GPR_U32(ctx, 16), 800), GPR_VEC(ctx, 3));
    // 0x1ddd08: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ddd0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ddd14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ddd18; return;
}


// Function: PostTailLoad__FP4TAIL
// Address: 0x1ddd18 - 0x1ddd38

void entry_1ddd38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ddd38: 0x8e440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1ddd3c: 0x10800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDD54; return;
    }
    // 0x1ddd44: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1ddd4c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 94));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1ddd4c
// Address: 0x1ddd4c - 0x1ddd80

void entry_1ddd4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ddd4c) {
        switch (ctx->pc) {
            case 0x1ddd54: ctx->pc = 0; goto label_1ddd54;
            case 0x1ddd60: ctx->pc = 0; goto label_1ddd60;
            case 0x1ddd70: ctx->pc = 0; goto label_1ddd70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ddd4c: 0x14400049
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDE74; return;
    }
label_1ddd54:
    // 0x1ddd54: 0x1240000e
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDD90; return;
    }
    // 0x1ddd5c: 0x0
    // NOP
label_1ddd60:
    // 0x1ddd60: 0x8e4202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 724)));
    // 0x1ddd64: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1ddd68: 0xae4202d4
    WRITE32(ADD32(GPR_U32(ctx, 18), 724), GPR_U32(ctx, 2));
    // 0x1ddd6c: 0x8c700034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 52)));
label_1ddd70:
    // 0x1ddd70: 0x12000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDD88; return;
    }
    // 0x1ddd78: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1ddd80);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 94));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1ddd80
// Address: 0x1ddd80 - 0x1dddc4

void entry_1ddd80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ddd80) {
        switch (ctx->pc) {
            case 0x1ddd88: ctx->pc = 0; goto label_1ddd88;
            case 0x1ddd90: ctx->pc = 0; goto label_1ddd90;
            case 0x1dddb8: ctx->pc = 0; goto label_1dddb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ddd80: 0x5040fffb
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x1DDD70; return;
    }
label_1ddd88:
    // 0x1ddd88: 0x1600fff5
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDD60; return;
    }
label_1ddd90:
    // 0x1ddd90: 0x8e4202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 724)));
    // 0x1ddd94: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ddd98: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1ddd9c: 0x10400006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1dddb8;
    }
    // 0x1ddda4: 0x8e420310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 784)));
    // 0x1ddda8: 0x14400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1dddb8;
    }
    // 0x1dddb0: 0x1000002f
    WRITE32(ADD32(GPR_U32(ctx, 18), 724), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDE70; return;
    }
label_1dddb8:
    // 0x1dddb8: 0x22180
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1dddbc: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1dddc4);
    WRITE32(ADD32(GPR_U32(ctx, 18), 724), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1dddc4
// Address: 0x1dddc4 - 0x1dde28

void entry_1dddc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dddc4) {
        switch (ctx->pc) {
            case 0x1dddd8: ctx->pc = 0; goto label_1dddd8;
            case 0x1dde18: ctx->pc = 0; goto label_1dde18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dddc4: 0x240182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dddc8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dddcc: 0x12400020
    WRITE32(ADD32(GPR_U32(ctx, 18), 728), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDE50; return;
    }
    // 0x1dddd4: 0x0
    // NOP
label_1dddd8:
    // 0x1dddd8: 0xac7202d0
    WRITE32(ADD32(GPR_U32(ctx, 3), 720), GPR_U32(ctx, 18));
    // 0x1ddddc: 0xae230034
    WRITE32(ADD32(GPR_U32(ctx, 17), 52), GPR_U32(ctx, 3));
    // 0x1ddde0: 0x78620140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1ddde4: 0x7e220000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    // 0x1ddde8: 0xd8610100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 256)));
    // 0x1dddec: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1dddf0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1dddf4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1dddf8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1dddfc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1dde00: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1dde04: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1dde08: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1dde0c: 0xae220030
    WRITE32(ADD32(GPR_U32(ctx, 17), 48), GPR_U32(ctx, 2));
    // 0x1dde10: 0x8c700034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x1dde14: 0x26330040
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 64));
label_1dde18:
    // 0x1dde18: 0x12000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDE30; return;
    }
    // 0x1dde20: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1dde28);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 94));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1dde28
// Address: 0x1dde28 - 0x1dde68

void entry_1dde28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dde28) {
        switch (ctx->pc) {
            case 0x1dde30: ctx->pc = 0; goto label_1dde30;
            case 0x1dde40: ctx->pc = 0; goto label_1dde40;
            case 0x1dde44: ctx->pc = 0; goto label_1dde44;
            case 0x1dde50: ctx->pc = 0; goto label_1dde50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dde28: 0x5040fffb
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        ctx->pc = 0x1DDE18; return;
    }
label_1dde30:
    // 0x1dde30: 0x12000003
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1dde40;
    }
    // 0x1dde38: 0x10000002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 256)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dde44;
    }
label_1dde40:
    // 0x1dde40: 0x7a420320
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 800)));
label_1dde44:
    // 0x1dde44: 0x7e220020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), GPR_VEC(ctx, 2));
    // 0x1dde48: 0x1600ffe3
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDDD8; return;
    }
label_1dde50:
    // 0x1dde50: 0x26308000
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294934528));
    // 0x1dde54: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dde58: 0x8e047ff4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 32756)));
    // 0x1dde5c: 0x2626ffe0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 4294967264));
    // 0x1dde60: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1dde68);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1dde68
// Address: 0x1dde68 - 0x1dde90

void entry_1dde68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dde68) {
        switch (ctx->pc) {
            case 0x1dde70: ctx->pc = 0; goto label_1dde70;
            case 0x1dde74: ctx->pc = 0; goto label_1dde74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dde68: 0xc6007ff0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 32752)); ctx->f[0] = *(float*)&val; }
    // 0x1dde6c: 0xe6200030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 48), *(uint32_t*)&val); }
label_1dde70:
    // 0x1dde70: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1dde74:
    // 0x1dde74: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dde78: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dde7c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dde80: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dde84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dde8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dde90; return;
}


// Function: UpdateTailConstraints__FP4TAIL
// Address: 0x1dde90 - 0x1ddee8

void entry_1ddee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ddee8) {
        switch (ctx->pc) {
            case 0x1ddf24: ctx->pc = 0; goto label_1ddf24;
            case 0x1ddf50: ctx->pc = 0; goto label_1ddf50;
            case 0x1ddf7c: ctx->pc = 0; goto label_1ddf7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ddee8: 0x8e6302d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 728)));
    // 0x1ddeec: 0x1060020e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1de728(rdram, ctx, runtime); return;
    }
    // 0x1ddef4: 0x8e620310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 784)));
    // 0x1ddef8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ddefc: 0xc2200b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 6));
    // 0x1ddf00: 0xafa401b0
    WRITE32(ADD32(GPR_U32(ctx, 29), 432), GPR_U32(ctx, 4));
    // 0x1ddf04: 0x42980
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 4), 6));
    // 0x1ddf08: 0xa31021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x1ddf0c: 0x8c43fff4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294967284)));
    // 0x1ddf10: 0x8c6401f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 496)));
    // 0x1ddf14: 0x50800003
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 732)));
        goto label_1ddf24;
    }
    // 0x1ddf1c: 0x10000202
    WRITE32(ADD32(GPR_U32(ctx, 19), 732), GPR_U32(ctx, 6));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1de728(rdram, ctx, runtime); return;
    }
label_1ddf24:
    // 0x1ddf24: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1ddf28: 0xafa501bc
    WRITE32(ADD32(GPR_U32(ctx, 29), 444), GPR_U32(ctx, 5));
    // 0x1ddf2c: 0x8fa501b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1ddf30: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1ddf34: 0x1040002a
    WRITE32(ADD32(GPR_U32(ctx, 29), 440), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DDFE0; return;
    }
    // 0x1ddf3c: 0x8e6202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 724)));
    // 0x1ddf40: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1ddf44: 0x1840000d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1ddf7c;
    }
    // 0x1ddf4c: 0x8e6402d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 728)));
label_1ddf50:
    // 0x1ddf50: 0x121180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 6));
    // 0x1ddf54: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1ddf58: 0x828821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1ddf5c: 0x8e230034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1ddf60: 0x78620140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1ddf64: 0x7e220000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    // 0x1ddf68: 0x8e6302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 724)));
    // 0x1ddf6c: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1ddf70: 0x243182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 3)));
    // 0x1ddf74: 0x5460fff6
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 728)));
        goto label_1ddf50;
    }
label_1ddf7c:
    // 0x1ddf7c: 0x8e24fff4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4294967284)));
    // 0x1ddf80: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ddf84: 0x2626ffe0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 4294967264));
    // 0x1ddf88: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1ddf90);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1ddf90
// Address: 0x1ddf90 - 0x1ddfc8

void entry_1ddf90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ddf90) {
        switch (ctx->pc) {
            case 0x1ddfa8: ctx->pc = 0; goto label_1ddfa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ddf90: 0x8e6202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 724)));
    // 0x1ddf94: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1ddf98: 0x18400010
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1DDFDC; return;
    }
    // 0x1ddfa0: 0x8e240034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1ddfa4: 0x0
    // NOP
label_1ddfa8:
    // 0x1ddfa8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ddfac: 0x26260040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 64));
    // 0x1ddfb0: 0x26270050
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 80));
    // 0x1ddfb4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ddfb8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ddfbc: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ddfc0: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1ddfc8);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1ddfc8
// Address: 0x1ddfc8 - 0x1de00c

void entry_1ddfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ddfc8) {
        switch (ctx->pc) {
            case 0x1ddfdc: ctx->pc = 0; goto label_1ddfdc;
            case 0x1ddfe0: ctx->pc = 0; goto label_1ddfe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ddfc8: 0x8e6202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 724)));
    // 0x1ddfcc: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1ddfd0: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1ddfd4: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
        ctx->pc = 0x1DDFA8; return;
    }
label_1ddfdc:
    // 0x1ddfdc: 0xae6002dc
    WRITE32(ADD32(GPR_U32(ctx, 19), 732), GPR_U32(ctx, 0));
label_1ddfe0:
    // 0x1ddfe0: 0x8e7102d8
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 728)));
    // 0x1ddfe4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ddfe8: 0x7a620140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 320)));
    // 0x1ddfec: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ddff0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ddff4: 0x26270010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 16));
    // 0x1ddff8: 0x7e220000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    // 0x1ddffc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1de000: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1de004: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1de00c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1de00c
// Address: 0x1de00c - 0x1de030

void entry_1de00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de00c: 0x8e620310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 784)));
    // 0x1de010: 0x54400010
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 724)));
        ctx->pc = 0x1DE054; return;
    }
    // 0x1de018: 0x26310040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 64));
    // 0x1de01c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1de020: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1de024: 0x2626ffe0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 4294967264));
    // 0x1de028: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1de030);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1de030
// Address: 0x1de030 - 0x1de050

void entry_1de030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de030: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1de034: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1de038: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1de03c: 0x24c70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 16));
    // 0x1de040: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1de044: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1de048: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x1de050);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_1de050
// Address: 0x1de050 - 0x1de1b0

void entry_1de050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1de050) {
        switch (ctx->pc) {
            case 0x1de054: ctx->pc = 0; goto label_1de054;
            case 0x1de070: ctx->pc = 0; goto label_1de070;
            case 0x1de0ac: ctx->pc = 0; goto label_1de0ac;
            case 0x1de0e0: ctx->pc = 0; goto label_1de0e0;
            case 0x1de134: ctx->pc = 0; goto label_1de134;
            case 0x1de144: ctx->pc = 0; goto label_1de144;
            case 0x1de170: ctx->pc = 0; goto label_1de170;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1de050: 0x8e6202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 724)));
label_1de054:
    // 0x1de054: 0x8fb201b0
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1de058: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1de05c: 0x10400013
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1de0ac;
    }
    // 0x1de064: 0x24441858
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1de068: 0x8e6302d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 728)));
    // 0x1de06c: 0x0
    // NOP
label_1de070:
    // 0x1de070: 0x121180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 6));
    // 0x1de074: 0x8c850008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1de078: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1de07c: 0x628821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1de080: 0x48a51000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x1de084: 0xda630300
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 768)));
    // 0x1de088: 0xda210010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1de08c: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de090: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1de094: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de098: 0xfa210010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1de09c: 0x8e6202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 724)));
    // 0x1de0a0: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1de0a4: 0x5440fff2
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 728)));
        goto label_1de070;
    }
label_1de0ac:
    // 0x1de0ac: 0x8e6302f0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 752)));
    // 0x1de0b0: 0x26021858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 6232));
    // 0x1de0b4: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1de0b8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1de0bc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1de0c0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1de0c4: 0x186000c5
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[22] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[22] = ctx->f[1] / ctx->f[0];
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1DE3DC; return;
    }
    // 0x1de0cc: 0x8fa201b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1de0d0: 0x267e01a0
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 19), 416));
    // 0x1de0d4: 0x2b980
    SET_GPR_U32(ctx, 23, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1de0d8: 0x8e620310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 784)));
    // 0x1de0dc: 0x0
    // NOP
label_1de0e0:
    // 0x1de0e0: 0x10400014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 728)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1de134;
    }
    // 0x1de0e8: 0xdbc40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 30), 16)));
    // 0x1de0ec: 0xd8430020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1de0f0: 0xdbc20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 30), 32)));
    // 0x1de0f4: 0xda6101a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 416)));
    // 0x1de0f8: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1de0fc: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1de100: 0x4bc3110a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de104: 0x8e630018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x1de108: 0x1060000e
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1de144;
    }
    // 0x1de110: 0x24620110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 272));
    // 0x1de114: 0xd8620110
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 272)));
    // 0x1de118: 0xd8430020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1de11c: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1de120: 0x4bc411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1de124: 0x4bc408bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1de128: 0x4bc4188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de12c: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1de144;
    }
label_1de134:
    // 0x1de134: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1de138: 0xd8410040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1de13c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1de140: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
label_1de144:
    // 0x1de144: 0x8e6202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 724)));
    // 0x1de148: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1de14c: 0x8fb201b0
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1de150: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1de154: 0x1040005a
    WRITE32(ADD32(GPR_U32(ctx, 29), 436), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DE2C0; return;
    }
    // 0x1de15c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1de160: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1de164: 0x27b50020
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1de168: 0x26f4ffc0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 23), 4294967232));
    // 0x1de16c: 0x0
    // NOP
label_1de170:
    // 0x1de170: 0x8e6202d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 728)));
    // 0x1de174: 0x121980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 6));
    // 0x1de178: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1de17c: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1de180: 0x438821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1de184: 0x548021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1de188: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1de18c: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1de190: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1de194: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1de198: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de19c: 0xda210010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1de1a0: 0xda020010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1de1a4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1de1a8: 0xc07b642
    SET_GPR_U32(ctx, 31, 0x1de1b0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    RadBetweenVectors__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_1de1b0
// Address: 0x1de1b0 - 0x1de1d4

void entry_1de1b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de1b0: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1de1b4: 0xc66002ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 748)); ctx->f[0] = *(float*)&val; }
    // 0x1de1b8: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1de1bc: 0x0
    // NOP
    // 0x1de1c0: 0x4500000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1DE200; return;
    }
    // 0x1de1c8: 0x4600a301
    ctx->f[12] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x1de1cc: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1de1d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1de1d4
// Address: 0x1de1d4 - 0x1de394

void entry_1de1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1de1d4) {
        switch (ctx->pc) {
            case 0x1de200: ctx->pc = 0; goto label_1de200;
            case 0x1de2c0: ctx->pc = 0; goto label_1de2c0;
            case 0x1de2e8: ctx->pc = 0; goto label_1de2e8;
            case 0x1de358: ctx->pc = 0; goto label_1de358;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1de1d4: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1de1d8: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1de1dc: 0xdba40060
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1de1e0: 0xdba30070
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1de1e4: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1de1e8: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1de1ec: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de1f0: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de1f4: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1de1f8: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1de1fc: 0xfa210000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_1de200:
    // 0x1de200: 0xc66002e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 744)); ctx->f[0] = *(float*)&val; }
    // 0x1de204: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1de208: 0xc66102e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 740)); ctx->f[1] = *(float*)&val; }
    // 0x1de20c: 0x26940040
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 64));
    // 0x1de210: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1de214: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1de218: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x1de21c: 0xdba60020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1de220: 0xc66202e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 736)); ctx->f[2] = *(float*)&val; }
    // 0x1de224: 0x4bc132fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x1de228: 0x4bc609ae
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[6]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de22c: 0x4a2631ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1de230: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1de234: 0xfba60040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1de238: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
    // 0x1de23c: 0xdba80030
    ctx->vu0_vf[8] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1de240: 0x46141082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[20]);
    // 0x1de244: 0x4600a829
    ctx->f[0] = std::min(ctx->f[21], ctx->f[0]);
    // 0x1de248: 0xda240010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1de24c: 0x4601a869
    ctx->f[1] = std::min(ctx->f[21], ctx->f[1]);
    // 0x1de250: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1de254: 0x48a42800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1de258: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1de25c: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1de260: 0x48a51800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x1de264: 0x46161082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[22]);
    // 0x1de268: 0xfba30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1de26c: 0x4403b000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[22]);
    // 0x1de270: 0x48a33800
    ctx->vu0_vf[7] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1de274: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x1de278: 0xda220010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1de27c: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1de280: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1de284: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1de288: 0x4be540bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1de28c: 0x4be310bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1de290: 0x4be13108
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de294: 0xfa240010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1de298: 0xda210000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1de29c: 0xfba70050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1de2a0: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1de2a4: 0x4be72048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de2a8: 0xfa210000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1de2ac: 0x8e6302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 724)));
    // 0x1de2b0: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1de2b4: 0x243182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 3)));
    // 0x1de2b8: 0x1460ffad
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DE170; return;
    }
label_1de2c0:
    // 0x1de2c0: 0x8e6202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 724)));
    // 0x1de2c4: 0x8fb201b0
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1de2c8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1de2cc: 0x1040003e
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DE3C8; return;
    }
    // 0x1de2d4: 0x27b50020
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1de2d8: 0x24568d00
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1de2dc: 0x26f4ffc0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 23), 4294967232));
    // 0x1de2e0: 0x8e6202d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 728)));
    // 0x1de2e4: 0x0
    // NOP
label_1de2e8:
    // 0x1de2e8: 0x121980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 6));
    // 0x1de2ec: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1de2f0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1de2f4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1de2f8: 0x438821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1de2fc: 0x548021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1de300: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1de304: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1de308: 0x4be1112c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1de30c: 0x7ac20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x1de310: 0x4be1233c
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1de314: 0x4bc108ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1de318: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1de31c: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1de320: 0x4b0310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de324: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1de328: 0x4a0303bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1de32c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1de330: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1de334: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1de338: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1de33c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1de340: 0x0
    // NOP
    // 0x1de344: 0x45010004
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1de358;
    }
    // 0x1de34c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1de350: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1de354: 0x4be020dc
    ctx->vu0_vf[4] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1de358:
    // 0x1de358: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1de35c: 0x27a60050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1de360: 0x26040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1de364: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1de368: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1de36c: 0x26940040
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 64));
    // 0x1de370: 0x8e250030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 48)));
    // 0x1de374: 0x48a51000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x1de378: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1de37c: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1de380: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de384: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de388: 0xfa210000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1de38c: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x1de394);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_1de394
// Address: 0x1de394 - 0x1de3a8

void entry_1de394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de394: 0x26240010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 16));
    // 0x1de398: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1de39c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1de3a0: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x1de3a8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_1de3a8
// Address: 0x1de3a8 - 0x1de628

void entry_1de3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1de3a8) {
        switch (ctx->pc) {
            case 0x1de3c8: ctx->pc = 0; goto label_1de3c8;
            case 0x1de3dc: ctx->pc = 0; goto label_1de3dc;
            case 0x1de410: ctx->pc = 0; goto label_1de410;
            case 0x1de430: ctx->pc = 0; goto label_1de430;
            case 0x1de444: ctx->pc = 0; goto label_1de444;
            case 0x1de460: ctx->pc = 0; goto label_1de460;
            case 0x1de590: ctx->pc = 0; goto label_1de590;
            case 0x1de5f4: ctx->pc = 0; goto label_1de5f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1de3a8: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1de3ac: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1de3b0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1de3b4: 0xfa210010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1de3b8: 0x8e6202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 724)));
    // 0x1de3bc: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1de3c0: 0x5440ffc9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 728)));
        ctx->pc = 0x1DE2E8; return;
    }
label_1de3c8:
    // 0x1de3c8: 0x8e6202f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 752)));
    // 0x1de3cc: 0x8fa401b4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 436)));
    // 0x1de3d0: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1de3d4: 0x5440ff42
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 784)));
        ctx->pc = 0x1DE0E0; return;
    }
label_1de3dc:
    // 0x1de3dc: 0x8e620310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 784)));
    // 0x1de3e0: 0x50400013
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 272)));
        goto label_1de430;
    }
    // 0x1de3e8: 0x8e640018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x1de3ec: 0x10800008
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1de410;
    }
    // 0x1de3f4: 0x78820110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 272)));
    // 0x1de3f8: 0x7fa200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 2));
    // 0x1de3fc: 0x78830120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 288)));
    // 0x1de400: 0x7fa300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 3));
    // 0x1de404: 0x78820130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 304)));
    // 0x1de408: 0x1000000e
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1de444;
    }
label_1de410:
    // 0x1de410: 0x244283d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935504));
    // 0x1de414: 0x78450020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1de418: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1de41c: 0x78440010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1de420: 0x7fa300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 3));
    // 0x1de424: 0x7fa400d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 4));
    // 0x1de428: 0x10000006
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1de444;
    }
label_1de430:
    // 0x1de430: 0x7a630120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 19), 288)));
    // 0x1de434: 0x7a640130
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 19), 304)));
    // 0x1de438: 0x7fa200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 2));
    // 0x1de43c: 0x7fa300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 3));
    // 0x1de440: 0x7fa400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 4));
label_1de444:
    // 0x1de444: 0x8e6202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 724)));
    // 0x1de448: 0x8fb201b8
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 440)));
    // 0x1de44c: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1de450: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1de454: 0x104000aa
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 144));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DE700; return;
    }
    // 0x1de45c: 0x0
    // NOP
label_1de460:
    // 0x1de460: 0x8e6302d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 728)));
    // 0x1de464: 0x121180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 6));
    // 0x1de468: 0x628821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1de46c: 0xda210040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x1de470: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1de474: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1de478: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1de47c: 0x8e230034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1de480: 0x8c620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    // 0x1de484: 0x10400042
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1de590;
    }
    // 0x1de48c: 0xd8460030
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x1de490: 0x24420030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 48));
    // 0x1de494: 0xdba300e0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1de498: 0xdba500c0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1de49c: 0x4bc629bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1de4a0: 0x4bc620bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1de4a4: 0x4bc6198a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de4a8: 0xfba60180
    WRITE128(ADD32(GPR_U32(ctx, 29), 384), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1de4ac: 0xfba60150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1de4b0: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1de4b4: 0x4bc229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1de4b8: 0x4bc220bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1de4bc: 0x4bc2188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de4c0: 0xfba20190
    WRITE128(ADD32(GPR_U32(ctx, 29), 400), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de4c4: 0xfba20160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de4c8: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1de4cc: 0x4bc129bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1de4d0: 0x4bc120bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1de4d4: 0x4bc1194a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de4d8: 0xfba501a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1de4dc: 0xfba50170
    WRITE128(ADD32(GPR_U32(ctx, 29), 368), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1de4e0: 0x8e220034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1de4e4: 0xd84401a0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 416)));
    // 0x1de4e8: 0x4bc431bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1de4ec: 0x4bc410bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1de4f0: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de4f4: 0x244201a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 416));
    // 0x1de4f8: 0xfba40180
    WRITE128(ADD32(GPR_U32(ctx, 29), 384), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1de4fc: 0xfba40120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1de500: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1de504: 0x4bc331bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1de508: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1de50c: 0x4bc328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de510: 0xfba30190
    WRITE128(ADD32(GPR_U32(ctx, 29), 400), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1de514: 0xfba30130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1de518: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1de51c: 0x4bc131bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1de520: 0x4bc110bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1de524: 0x4bc1298a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de528: 0xfba601a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1de52c: 0xfba60140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1de530: 0x8e220034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1de534: 0x8c430224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 548)));
    // 0x1de538: 0xd8650000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1de53c: 0x4bc521bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1de540: 0x4bc518bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1de544: 0x4bc5314a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de548: 0xfba500f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1de54c: 0xfba50180
    WRITE128(ADD32(GPR_U32(ctx, 29), 384), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1de550: 0xd8620010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1de554: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1de558: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1de55c: 0x4bc2308a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de560: 0xfba20100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de564: 0xfba20190
    WRITE128(ADD32(GPR_U32(ctx, 29), 400), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de568: 0xd8610020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1de56c: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1de570: 0x4bc118bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1de574: 0x4bc1310a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de578: 0xfba401a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1de57c: 0xfba40110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1de580: 0xfba50090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1de584: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de588: 0x1000001a
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1de5f4;
    }
label_1de590:
    // 0x1de590: 0xd86501a0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 416)));
    // 0x1de594: 0x246201a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 416));
    // 0x1de598: 0xdba300c0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1de59c: 0xdba600d0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1de5a0: 0xdba400e0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1de5a4: 0x4bc519bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1de5a8: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1de5ac: 0x4bc5214a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de5b0: 0xfba500f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1de5b4: 0xfba50120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1de5b8: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1de5bc: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1de5c0: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1de5c4: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de5c8: 0xfba20100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de5cc: 0xfba20130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de5d0: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1de5d4: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1de5d8: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1de5dc: 0x4bc120ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de5e0: 0xfba50090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1de5e4: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1de5e8: 0xfba300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1de5ec: 0xfba30140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1de5f0: 0xfba30110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[3]));
label_1de5f4:
    // 0x1de5f4: 0xdba40090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1de5f8: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1de5fc: 0xdba300a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1de600: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1de604: 0xdba200b0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1de608: 0x27a60060
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1de60c: 0xda210020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1de610: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1de614: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1de618: 0x4bc118bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1de61c: 0x4bc1104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de620: 0xc062858
    SET_GPR_U32(ctx, 31, 0x1de628);
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1de628
// Address: 0x1de628 - 0x1de690

void entry_1de628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de628: 0xdba40060
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1de62c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1de630: 0xdba50070
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1de634: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1de638: 0xdba30090
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1de63c: 0xdba600a0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1de640: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1de644: 0x4bc328bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1de648: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de64c: 0x4bc621bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1de650: 0x4bc628bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1de654: 0x4bc6098a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de658: 0xdba200b0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1de65c: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1de660: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1de664: 0x4bc2090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1de668: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1de66c: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1de670: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1de674: 0xfba30120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1de678: 0xfba300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1de67c: 0xfba60130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1de680: 0xfba60100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1de684: 0xfba40140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1de688: 0xc062428
    SET_GPR_U32(ctx, 31, 0x1de690);
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[4]));
    NormalizeRotateMatrix3__FP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1de690
// Address: 0x1de690 - 0x1de6c0

void entry_1de690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de690: 0x7ba30090
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1de694: 0x27a400f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 240));
    // 0x1de698: 0x8e270034
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x1de69c: 0x27a500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1de6a0: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1de6a4: 0x7ce30110
    WRITE128(ADD32(GPR_U32(ctx, 7), 272), GPR_VEC(ctx, 3));
    // 0x1de6a8: 0x7ba200a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1de6ac: 0x7ce20120
    WRITE128(ADD32(GPR_U32(ctx, 7), 288), GPR_VEC(ctx, 2));
    // 0x1de6b0: 0x7ba300b0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1de6b4: 0x7ce30130
    WRITE128(ADD32(GPR_U32(ctx, 7), 304), GPR_VEC(ctx, 3));
    // 0x1de6b8: 0xc062148
    SET_GPR_U32(ctx, 31, 0x1de6c0);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    MatMulMatTransMat__FRC7MATRIX3T0(rdram, ctx, runtime); return;
}


// Function: entry_1de6c0
// Address: 0x1de6c0 - 0x1de728

void entry_1de6c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1de6c0) {
        switch (ctx->pc) {
            case 0x1de700: ctx->pc = 0; goto label_1de700;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1de6c0: 0x7ba200f0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1de6c4: 0x7e0200d0
    WRITE128(ADD32(GPR_U32(ctx, 16), 208), GPR_VEC(ctx, 2));
    // 0x1de6c8: 0x7ba30100
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1de6cc: 0x7e0300e0
    WRITE128(ADD32(GPR_U32(ctx, 16), 224), GPR_VEC(ctx, 3));
    // 0x1de6d0: 0x7ba20110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1de6d4: 0x7e0200f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 240), GPR_VEC(ctx, 2));
    // 0x1de6d8: 0x8e6302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 724)));
    // 0x1de6dc: 0x7ba40090
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1de6e0: 0x7ba500a0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1de6e4: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1de6e8: 0x7ba200b0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1de6ec: 0x243182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 3)));
    // 0x1de6f0: 0x7fa400c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 4));
    // 0x1de6f4: 0x7fa500d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 5));
    // 0x1de6f8: 0x1460ff59
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DE460; return;
    }
label_1de700:
    // 0x1de700: 0x8fa301bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 444)));
    // 0x1de704: 0x8e6202d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 728)));
    // 0x1de708: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1de70c: 0x8c44fff4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294967284)));
    // 0x1de710: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1de714: 0x8c630058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 88)));
    // 0x1de718: 0x10600004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 592)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DE72C; return;
    }
    // 0x1de720: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1de728);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1de728
// Address: 0x1de728 - 0x1de768

void entry_1de728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1de728) {
        switch (ctx->pc) {
            case 0x1de72c: ctx->pc = 0; goto label_1de72c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1de728: 0x7bbf0250
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 592)));
label_1de72c:
    // 0x1de72c: 0x7bbe0240
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x1de730: 0x7bb70230
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x1de734: 0x7bb60220
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x1de738: 0x7bb50210
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x1de73c: 0x7bb40200
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x1de740: 0x7bb301f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x1de744: 0x7bb201e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x1de748: 0x7bb101d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x1de74c: 0x7bb001c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1de750: 0xc7b60270
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 624)); ctx->f[22] = *(float*)&val; }
    // 0x1de754: 0xc7b50268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 616)); ctx->f[21] = *(float*)&val; }
    // 0x1de758: 0xc7b40260
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 608)); ctx->f[20] = *(float*)&val; }
    // 0x1de75c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 640));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1de764: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1de768; return;
}


// Function: MatchTailOtherObject__FP4TAILP3ALO
// Address: 0x1de768 - 0x1de788

void entry_1de788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de788: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1de78c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1de794: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1de798; return;
}


// Function: InitTank__FP4TANK
// Address: 0x1de798 - 0x1de7ac

void entry_1de7ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de7ac: 0xc60d00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 208)); ctx->f[13] = *(float*)&val; }
    // 0x1de7b0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1de7b8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 212)); ctx->f[12] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1de7b8
// Address: 0x1de7b8 - 0x1de7d0

void entry_1de7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de7b8: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1de7bc: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1de7c0: 0xe6000638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    // 0x1de7c4: 0x26050660
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1632));
    // 0x1de7c8: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1de7d0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1de7d0
// Address: 0x1de7d0 - 0x1de808

void entry_1de7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de7d0: 0x3c01c120
    SET_GPR_U32(ctx, 1, ((uint32_t)49440 << 16));
    // 0x1de7d4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1de7d8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1de7dc: 0xae020720
    WRITE32(ADD32(GPR_U32(ctx, 16), 1824), GPR_U32(ctx, 2));
    // 0x1de7e0: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1de7e4: 0xe600072c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1836), *(uint32_t*)&val); }
    // 0x1de7e8: 0x24635740
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 22336));
    // 0x1de7ec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1de7f0: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1de7f4: 0x7e0206f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 1776), GPR_VEC(ctx, 2));
    // 0x1de7f8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1de7fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1de804: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1de808; return;
}


// Function: PostTankLoad__FP4TANK
// Address: 0x1de808 - 0x1de820

void entry_1de820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de820: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1de824: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1de828: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1de82c: 0x24c65750
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 22352));
    // 0x1de830: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1de838);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1de838
// Address: 0x1de838 - 0x1de850

void entry_1de838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de838: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1de83c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1de840: 0x8e2506dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1756)));
    // 0x1de844: 0x8c6200e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 224)));
    // 0x1de848: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1de850);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1de850
// Address: 0x1de850 - 0x1de860

void entry_1de850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de850: 0x8e240748
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1864)));
    // 0x1de854: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1de858: 0xc04a740
    SET_GPR_U32(ctx, 31, 0x1de860);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 1868));
    CreateAloActadj__FP3ALOiPP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_1de860
// Address: 0x1de860 - 0x1de884

void entry_1de860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de860: 0x8e22074c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1868)));
    // 0x1de864: 0xa0500010
    WRITE8(ADD32(GPR_U32(ctx, 2), 16), (uint8_t)GPR_U32(ctx, 16));
    // 0x1de868: 0x8e23074c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1868)));
    // 0x1de86c: 0xa0700011
    WRITE8(ADD32(GPR_U32(ctx, 3), 17), (uint8_t)GPR_U32(ctx, 16));
    // 0x1de870: 0x8e240748
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1864)));
    // 0x1de874: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1de878: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x1de87c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1de884);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1de884
// Address: 0x1de884 - 0x1de894

void entry_1de884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de884: 0x8e240750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1872)));
    // 0x1de888: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1de88c: 0xc04a740
    SET_GPR_U32(ctx, 31, 0x1de894);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 1876));
    CreateAloActadj__FP3ALOiPP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_1de894
// Address: 0x1de894 - 0x1de8b0

void entry_1de894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de894: 0x8e220754
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1876)));
    // 0x1de898: 0xa0500011
    WRITE8(ADD32(GPR_U32(ctx, 2), 17), (uint8_t)GPR_U32(ctx, 16));
    // 0x1de89c: 0x8e240750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1872)));
    // 0x1de8a0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1de8a4: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x1de8a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1de8b0);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1de8b0
// Address: 0x1de8b0 - 0x1de8c4

void entry_1de8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de8b0: 0x8e240758
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1880)));
    // 0x1de8b4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1de8b8: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1de8bc: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1de8c4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1de8c4
// Address: 0x1de8c4 - 0x1de8ec

void entry_1de8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1de8c4) {
        switch (ctx->pc) {
            case 0x1de8e0: ctx->pc = 0; goto label_1de8e0;
            case 0x1de8e4: ctx->pc = 0; goto label_1de8e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1de8c4: 0x8e23073c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1852)));
    // 0x1de8c8: 0x10600005
    WRITE32(ADD32(GPR_U32(ctx, 17), 1884), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1de8e0;
    }
    // 0x1de8d0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1de8d4: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1de8d8: 0x14600002
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1de8e4;
    }
label_1de8e0:
    // 0x1de8e0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
label_1de8e4:
    // 0x1de8e4: 0xc077ef8
    SET_GPR_U32(ctx, 31, 0x1de8ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetTankTanks__FP4TANK5TANKS(rdram, ctx, runtime); return;
}


// Function: entry_1de8ec
// Address: 0x1de8ec - 0x1de910

void entry_1de8ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de8ec: 0x3c014316
    SET_GPR_U32(ctx, 1, ((uint32_t)17174 << 16));
    // 0x1de8f0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1de8f4: 0xae310598
    WRITE32(ADD32(GPR_U32(ctx, 17), 1432), GPR_U32(ctx, 17));
    // 0x1de8f8: 0xe6200594
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1428), *(uint32_t*)&val); }
    // 0x1de8fc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1de900: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1de904: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1de908: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateTank__FP4TANKf
// Address: 0x1de910 - 0x1de948

void entry_1de948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de948: 0xc04a08c
    SET_GPR_U32(ctx, 31, 0x1de950);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FDrivenAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1de950
// Address: 0x1de950 - 0x1de960

void entry_1de950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1de950: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1856)));
        ctx->pc = 0x1DE964; return;
    }
    // 0x1de958: 0xc077acc
    SET_GPR_U32(ctx, 31, 0x1de960);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_001deb30(rdram, ctx, runtime); return;
}


// Function: entry_1de960
// Address: 0x1de960 - 0x1de9dc

void entry_1de960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1de960) {
        switch (ctx->pc) {
            case 0x1de964: ctx->pc = 0; goto label_1de964;
            case 0x1de988: ctx->pc = 0; goto label_1de988;
            case 0x1de9a0: ctx->pc = 0; goto label_1de9a0;
            case 0x1de9d0: ctx->pc = 0; goto label_1de9d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1de960: 0x8e450740
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1856)));
label_1de964:
    // 0x1de964: 0x3c170026
    SET_GPR_U32(ctx, 23, ((uint32_t)38 << 16));
    // 0x1de968: 0x3c140027
    SET_GPR_U32(ctx, 20, ((uint32_t)39 << 16));
    // 0x1de96c: 0x3c150027
    SET_GPR_U32(ctx, 21, ((uint32_t)39 << 16));
    // 0x1de970: 0x10a00030
    SET_GPR_U32(ctx, 30, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DEA34; return;
    }
    // 0x1de978: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1de97c: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1de980: 0x24160004
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1de984: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1de988:
    // 0x1de988: 0x521026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1de98c: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1de990: 0x2621023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x1de994: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x1de998: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1de99c: 0x8c500004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 4)));
label_1de9a0:
    // 0x1de9a0: 0x5200001e
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
        ctx->pc = 0x1DEA1C; return;
    }
    // 0x1de9a8: 0x8e0204e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1248)));
    // 0x1de9ac: 0x5040fffc
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        goto label_1de9a0;
    }
    // 0x1de9b4: 0x52000019
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
        ctx->pc = 0x1DEA1C; return;
    }
    // 0x1de9bc: 0x10530004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 19)) {
        goto label_1de9d0;
    }
    // 0x1de9c4: 0x54560015
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 22)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
        ctx->pc = 0x1DEA1C; return;
    }
    // 0x1de9cc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1de9d0:
    // 0x1de9d0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1de9d4: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x1de9dc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1de9dc
// Address: 0x1de9dc - 0x1de9fc

void entry_1de9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1de9dc) {
        switch (ctx->pc) {
            case 0x1de9e0: ctx->pc = 0; goto label_1de9e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1de9dc: 0x0
    // NOP
label_1de9e0:
    // 0x1de9e0: 0x12000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DEA04; return;
    }
    // 0x1de9e8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1de9ec: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1de9f0: 0x8c62012c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 300)));
    // 0x1de9f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1de9fc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1de9fc
// Address: 0x1de9fc - 0x1dea18

void entry_1de9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1de9fc) {
        switch (ctx->pc) {
            case 0x1dea04: ctx->pc = 0; goto label_1dea04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1de9fc: 0x5040fff8
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        ctx->pc = 0x1DE9E0; return;
    }
label_1dea04:
    // 0x1dea04: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1dea08: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dea0c: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1dea10: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dea18);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dea18
// Address: 0x1dea18 - 0x1dea30

void entry_1dea18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dea18) {
        switch (ctx->pc) {
            case 0x1dea1c: ctx->pc = 0; goto label_1dea1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dea18: 0x8e3100d0
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
label_1dea1c:
    // 0x1dea1c: 0x5620ffda
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1DE988; return;
    }
    // 0x1dea24: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1dea28: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x1dea30);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1856)));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_1dea30
// Address: 0x1dea30 - 0x1deaa8

void entry_1dea30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dea30) {
        switch (ctx->pc) {
            case 0x1dea34: ctx->pc = 0; goto label_1dea34;
            case 0x1dea84: ctx->pc = 0; goto label_1dea84;
            case 0x1dea98: ctx->pc = 0; goto label_1dea98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dea30: 0xae400740
    WRITE32(ADD32(GPR_U32(ctx, 18), 1856), GPR_U32(ctx, 0));
label_1dea34:
    // 0x1dea34: 0x26e21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 6232));
    // 0x1dea38: 0xc643072c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1836)); ctx->f[3] = *(float*)&val; }
    // 0x1dea3c: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1dea40: 0x268357c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 20), 22464));
    // 0x1dea44: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1dea48: 0x26a25c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 23648));
    // 0x1dea4c: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1dea50: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1dea54: 0xc68357c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 22464)); ctx->f[3] = *(float*)&val; }
    // 0x1dea58: 0xc6ac5c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 23648)); ctx->f[12] = *(float*)&val; }
    // 0x1dea5c: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1dea60: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1dea64: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1dea68: 0x460118c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x1dea6c: 0x460c1834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dea70: 0x0
    // NOP
    // 0x1dea74: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1dea84;
    }
    // 0x1dea7c: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dea98;
    }
label_1dea84:
    // 0x1dea84: 0x46032034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dea88: 0x0
    // NOP
    // 0x1dea8c: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1dea98;
    }
    // 0x1dea94: 0x46002506
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
label_1dea98:
    // 0x1dea98: 0xc7cc57d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 22480)); ctx->f[12] = *(float*)&val; }
    // 0x1dea9c: 0x8e440748
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1864)));
    // 0x1deaa0: 0xc04a784
    SET_GPR_U32(ctx, 31, 0x1deaa8);
    ctx->f[12] = FPU_MUL_S(ctx->f[20], ctx->f[12]);
    SetAloPositionSpring__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_1deaa8
// Address: 0x1deaa8 - 0x1deabc

void entry_1deaa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1deaa8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1deaac: 0x8e440748
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1864)));
    // 0x1deab0: 0xc44c57d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22484)); ctx->f[12] = *(float*)&val; }
    // 0x1deab4: 0xc04a7ec
    SET_GPR_U32(ctx, 31, 0x1deabc);
    ctx->f[12] = FPU_MUL_S(ctx->f[20], ctx->f[12]);
    SetAloRotationSpring__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_1deabc
// Address: 0x1deabc - 0x1deb30

void entry_1deabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1deabc) {
        switch (ctx->pc) {
            case 0x1deaf8: ctx->pc = 0; goto label_1deaf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1deabc: 0x8e420728
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1832)));
    // 0x1deac0: 0x1040000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1deaf8;
    }
    // 0x1deac8: 0x8e430720
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1824)));
    // 0x1deacc: 0x1062000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 6232));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1deaf8;
    }
    // 0x1dead4: 0xc6420730
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1840)); ctx->f[2] = *(float*)&val; }
    // 0x1dead8: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1deadc: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1deae0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1deae4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1deae8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1deaec: 0x0
    // NOP
    // 0x1deaf0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 1832), GPR_U32(ctx, 0));
        goto label_1deaf8;
    }
label_1deaf8:
    // 0x1deaf8: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1deafc: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1deb00: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1deb04: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1deb08: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1deb0c: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1deb10: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1deb14: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1deb18: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1deb1c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1deb20: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1deb24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1deb2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1deb30; return;
}


// Function: FUN_001deb30
// Address: 0x1deb30 - 0x1deb64

void FUN_001deb30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1deb30: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1deb34: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1deb38: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1deb3c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1deb40: 0x7fb00020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 16));
    // 0x1deb44: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1deb48: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1deb4c: 0xc44c1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[12] = *(float*)&val; }
    // 0x1deb50: 0xc60d0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[13] = *(float*)&val; }
    // 0x1deb54: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1deb58: 0x27a80014
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 20));
    // 0x1deb5c: 0xc04a166
    SET_GPR_U32(ctx, 31, 0x1deb64);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 24));
    CalculateAloDrive__FP3ALOP3CLQP2LMffPfN25(rdram, ctx, runtime); return;
}


// Function: entry_1deb64
// Address: 0x1deb64 - 0x1deb7c

void entry_1deb64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1deb64: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1deb68: 0x26040660
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1632));
    // 0x1deb6c: 0xc7ad0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[13] = *(float*)&val; }
    // 0x1deb70: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1deb74: 0xc0624a8
    SET_GPR_U32(ctx, 31, 0x1deb7c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    LoadRotateMatrixPanTilt__FffP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1deb7c
// Address: 0x1deb7c - 0x1debb8

void entry_1deb7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1deb7c: 0xc7a10018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1deb80: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1deb84: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x1deb88: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1deb8c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1deb90: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1deb94: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1deb98: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1deb9c: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1deba0: 0x7e020640
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), GPR_VEC(ctx, 2));
    // 0x1deba4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1deba8: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1debac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1debb4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1debb8; return;
}


// Function: UseTankCharm__FP4TANK
// Address: 0x1debb8 - 0x1debcc

void entry_1debcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1debcc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1debd0: 0xc077ef8
    SET_GPR_U32(ctx, 31, 0x1debd8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetTankTanks__FP4TANK5TANKS(rdram, ctx, runtime); return;
}


// Function: entry_1debd8
// Address: 0x1debd8 - 0x1debe8

void entry_1debd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1debd8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1debdc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1debe0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateTankActive__FP4TANKP3JOYf
// Address: 0x1debe8 - 0x1dec1c

void entry_1dec1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dec1c: 0x14400191
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DF264; return;
    }
    // 0x1dec24: 0x27b30170
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 368));
    // 0x1dec28: 0x8e04075c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
    // 0x1dec2c: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1dec34);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1dec34
// Address: 0x1dec34 - 0x1dec44

void entry_1dec34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dec34: 0x27b10174
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 372));
    // 0x1dec38: 0x8e04075c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
    // 0x1dec3c: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x1dec44);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1dec44
// Address: 0x1dec44 - 0x1dec74

void entry_1dec44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dec44: 0x8e030720
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1824)));
    // 0x1dec48: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1dec4c: 0x14620023
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 368)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DECDC; return;
    }
    // 0x1dec54: 0x8fa30170
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1dec58: 0x24020352
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 850));
    // 0x1dec5c: 0x54620007
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1848)));
        ctx->pc = 0x1DEC7C; return;
    }
    // 0x1dec64: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1dec68: 0x8c620150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x1dec6c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1dec74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1dec74
// Address: 0x1dec74 - 0x1decb4

void entry_1dec74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dec74) {
        switch (ctx->pc) {
            case 0x1dec7c: ctx->pc = 0; goto label_1dec7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dec74: 0x10000019
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 368)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DECDC; return;
    }
label_1dec7c:
    // 0x1dec7c: 0x10400017
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 368)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DECDC; return;
    }
    // 0x1dec84: 0xc641007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 124)); ctx->f[1] = *(float*)&val; }
    // 0x1dec88: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1dec8c: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1dec90: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1dec94: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dec98: 0x0
    // NOP
    // 0x1dec9c: 0x45000010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294966446));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1DECE0; return;
    }
    // 0x1deca4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1deca8: 0x8c620150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x1decac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1decb4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1decb4
// Address: 0x1decb4 - 0x1decc0

void entry_1decb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1decb4: 0x8e04075c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
    // 0x1decb8: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x1decc0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 850));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1decc0
// Address: 0x1decc0 - 0x1deccc

void entry_1decc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1decc0: 0x8e04075c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
    // 0x1decc4: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1deccc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1deccc
// Address: 0x1deccc - 0x1decd8

void entry_1deccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1deccc: 0x8e04075c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
    // 0x1decd0: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x1decd8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1decd8
// Address: 0x1decd8 - 0x1ded14

void entry_1decd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1decd8) {
        switch (ctx->pc) {
            case 0x1decdc: ctx->pc = 0; goto label_1decdc;
            case 0x1dece0: ctx->pc = 0; goto label_1dece0;
            case 0x1ded08: ctx->pc = 0; goto label_1ded08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1decd8: 0x8fa20170
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 368)));
label_1decdc:
    // 0x1decdc: 0x2442fcae
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294966446));
label_1dece0:
    // 0x1dece0: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1dece4: 0x1040015e
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 372)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1df260(rdram, ctx, runtime); return;
    }
    // 0x1decec: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1decf0: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 850));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ded08;
    }
    // 0x1decf8: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 851));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ded08;
    }
    // 0x1ded00: 0x14620158
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1DF264; return;
    }
label_1ded08:
    // 0x1ded08: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ded0c: 0xc064a9c
    SET_GPR_U32(ctx, 31, 0x1ded14);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_00192a70(rdram, ctx, runtime); return;
}


// Function: entry_1ded14
// Address: 0x1ded14 - 0x1ded28

void entry_1ded14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ded14: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ded18: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1ded1c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ded20: 0xc0524e8
    SET_GPR_U32(ctx, 31, 0x1ded28);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1108));
    FActiveCplcy(rdram, ctx, runtime); return;
}


// Function: entry_1ded28
// Address: 0x1ded28 - 0x1ded60

void entry_1ded28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ded28: 0x54400023
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
        ctx->pc = 0x1DEDB8; return;
    }
    // 0x1ded30: 0xc641007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 124)); ctx->f[1] = *(float*)&val; }
    // 0x1ded34: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1ded38: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1ded3c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ded40: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ded44: 0x0
    // NOP
    // 0x1ded48: 0x4500001a
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 6544)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1DEDB4; return;
    }
    // 0x1ded50: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ded54: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ded58: 0xc0513fe
    SET_GPR_U32(ctx, 31, 0x1ded60);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1592));
    AdjustCmJoy__FP2CMP3JOY5JOYIDPf(rdram, ctx, runtime); return;
}


// Function: entry_1ded60
// Address: 0x1ded60 - 0x1ded6c

void entry_1ded60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ded60: 0xc60c00d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 212)); ctx->f[12] = *(float*)&val; }
    // 0x1ded64: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1ded6c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 208)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1ded6c
// Address: 0x1ded6c - 0x1ded78

void entry_1ded6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ded6c: 0xc60c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1ded70: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1ded78);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1ded78
// Address: 0x1ded78 - 0x1dedac

void entry_1ded78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ded78: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1ded7c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ded80: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ded84: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ded88: 0x0
    // NOP
    // 0x1ded8c: 0x4500000c
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1dedc0(rdram, ctx, runtime); return;
    }
    // 0x1ded94: 0x8c439b48
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294941512)));
    // 0x1ded98: 0x1460000a
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 6544)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DEDC4; return;
    }
    // 0x1deda0: 0x8e04075c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
    // 0x1deda4: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1dedac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 851));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1dedac
// Address: 0x1dedac - 0x1dedc0

void entry_1dedac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dedac) {
        switch (ctx->pc) {
            case 0x1dedb4: ctx->pc = 0; goto label_1dedb4;
            case 0x1dedb8: ctx->pc = 0; goto label_1dedb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dedac: 0x10000005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 6544)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DEDC4; return;
    }
label_1dedb4:
    // 0x1dedb4: 0x8e04075c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
label_1dedb8:
    // 0x1dedb8: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1dedc0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 850));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1dedc0
// Address: 0x1dedc0 - 0x1dedd4

void entry_1dedc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dedc0) {
        switch (ctx->pc) {
            case 0x1dedc4: ctx->pc = 0; goto label_1dedc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dedc0: 0x8e241990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 6544)));
label_1dedc4:
    // 0x1dedc4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1dedc8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1dedcc: 0xc0513fe
    SET_GPR_U32(ctx, 31, 0x1dedd4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 376));
    AdjustCmJoy__FP2CMP3JOY5JOYIDPf(rdram, ctx, runtime); return;
}


// Function: entry_1dedd4
// Address: 0x1dedd4 - 0x1dee54

void entry_1dedd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dedd4) {
        switch (ctx->pc) {
            case 0x1dee20: ctx->pc = 0; goto label_1dee20;
            case 0x1dee30: ctx->pc = 0; goto label_1dee30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dedd4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dedd8: 0xc6420048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 72)); ctx->f[2] = *(float*)&val; }
    // 0x1deddc: 0x244357e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 22496));
    // 0x1dede0: 0xc44357e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22496)); ctx->f[3] = *(float*)&val; }
    // 0x1dede4: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1dede8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dedec: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1dedf0: 0x244457f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 22512));
    // 0x1dedf4: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1dedf8: 0xc44457f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22512)); ctx->f[4] = *(float*)&val; }
    // 0x1dedfc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1dee00: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1dee04: 0x46021b40
    ctx->f[13] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1dee08: 0x46046834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dee0c: 0x0
    // NOP
    // 0x1dee10: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1dee20;
    }
    // 0x1dee18: 0x10000005
    ctx->f[13] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dee30;
    }
label_1dee20:
    // 0x1dee20: 0x460d2834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dee24: 0x0
    // NOP
    // 0x1dee28: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[13] = FPU_MOV_S(ctx->f[5]);
        goto label_1dee30;
    }
label_1dee30:
    // 0x1dee30: 0xc7a00178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[0] = *(float*)&val; }
    // 0x1dee34: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1dee38: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1dee3c: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1dee40: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1dee44: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1dee48: 0x460c0300
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    // 0x1dee4c: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1dee54);
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1dee54
// Address: 0x1dee54 - 0x1dee70

void entry_1dee54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dee54: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1dee58: 0xc7ac0178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[12] = *(float*)&val; }
    // 0x1dee5c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1dee60: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1dee64: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1dee68: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1dee70);
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1dee70
// Address: 0x1dee70 - 0x1def14

void entry_1dee70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dee70) {
        switch (ctx->pc) {
            case 0x1deee4: ctx->pc = 0; goto label_1deee4;
            case 0x1deef8: ctx->pc = 0; goto label_1deef8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dee70: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dee74: 0xc6420048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 72)); ctx->f[2] = *(float*)&val; }
    // 0x1dee78: 0x24445800
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 22528));
    // 0x1dee7c: 0xc4435800
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22528)); ctx->f[3] = *(float*)&val; }
    // 0x1dee80: 0xc4800008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1dee84: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1dee88: 0xc4810004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1dee8c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1dee90: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1dee94: 0xc4645c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1dee98: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dee9c: 0x60882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1deea0: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1deea4: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1deea8: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1deeac: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1deeb0: 0x24635c60
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 23648));
    // 0x1deeb4: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1deeb8: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1deebc: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1deec0: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1deec4: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1deec8: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1deecc: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1deed0: 0x0
    // NOP
    // 0x1deed4: 0x45000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1deee4;
    }
    // 0x1deedc: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1deef8;
    }
label_1deee4:
    // 0x1deee4: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1deee8: 0x0
    // NOP
    // 0x1deeec: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1deef8;
    }
    // 0x1deef4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
label_1deef8:
    // 0x1deef8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1deefc: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1def00: 0xc44c5810
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22544)); ctx->f[12] = *(float*)&val; }
    // 0x1def04: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1def08: 0x26355c60
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 17), 23648));
    // 0x1def0c: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1def14);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1def14
// Address: 0x1def14 - 0x1def24

void entry_1def14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1def14: 0xc60c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1def18: 0x26648d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 4294937888));
    // 0x1def1c: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1def24);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1def24
// Address: 0x1def24 - 0x1defd8

void entry_1def24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1def24: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1def28: 0x26020660
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 1632));
    // 0x1def2c: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1def30: 0xdba60020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1def34: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1def38: 0xdba70060
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1def3c: 0x4bc431bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1def40: 0x4bc418bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1def44: 0x4bc4090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1def48: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1def4c: 0x4bc731bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1def50: 0x4bc718bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x1def54: 0x4bc709ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1def58: 0x4bc231bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1def5c: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1def60: 0x4bc2098a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1def64: 0xfa070670
    WRITE128(ADD32(GPR_U32(ctx, 16), 1648), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1def68: 0xfa060680
    WRITE128(ADD32(GPR_U32(ctx, 16), 1664), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1def6c: 0xfa040660
    WRITE128(ADD32(GPR_U32(ctx, 16), 1632), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1def70: 0xfba40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1def74: 0xfba70090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1def78: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1def7c: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1def80: 0xd8420020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1def84: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1def88: 0x4be322aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1def8c: 0x4be002d3
    // Unhandled VU0 Special1 function: 0x13
    // 0x1def90: 0x4be30a6a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1def94: 0x4be3122a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1def98: 0x4b0a503d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); }
    // 0x1def9c: 0x4b0a594a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[10], ctx->vu0_vf[10], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[11] = _mm_blendv_ps(ctx->vu0_vf[11], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1defa0: 0x4a89483c
    ctx->vu0_i = (float)ctx->vi[9];
    // 0x1defa4: 0x4a89594a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[9], ctx->vu0_vf[9], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[11] = _mm_blendv_ps(ctx->vu0_vf[11], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1defa8: 0x4a48403c
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x1defac: 0x4a485949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[11] = _mm_blendv_ps(ctx->vu0_vf[11], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1defb0: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1defb4: 0xfa050640
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1defb8: 0xfba700c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1defbc: 0xfba600d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1defc0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1defc4: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1defc8: 0xc44c5830
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22576)); ctx->f[12] = *(float*)&val; }
    // 0x1defcc: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1defd0: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1defd8);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1defd8
// Address: 0x1defd8 - 0x1df048

void entry_1defd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1defd8: 0x8e030748
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1864)));
    // 0x1defdc: 0x27a400e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 224));
    // 0x1defe0: 0xdba40080
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1defe4: 0x27a60110
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 272));
    // 0x1defe8: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1defec: 0xdba50090
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1deff0: 0xd8420110
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 272)));
    // 0x1deff4: 0xdba300a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1deff8: 0x24420110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 272));
    // 0x1deffc: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1df000: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1df004: 0x4bc2188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1df008: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1df00c: 0xfba20110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1df010: 0xfba20140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1df014: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1df018: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1df01c: 0x4bc128bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1df020: 0x4bc1184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1df024: 0xfba10120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1df028: 0xfba10150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1df02c: 0xd8420020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1df030: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1df034: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1df038: 0x4bc2190a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1df03c: 0xfba40130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1df040: 0xc062148
    SET_GPR_U32(ctx, 31, 0x1df048);
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), _mm_castps_si128(ctx->vu0_vf[4]));
    MatMulMatTransMat__FRC7MATRIX3T0(rdram, ctx, runtime); return;
}


// Function: entry_1df048
// Address: 0x1df048 - 0x1df1b0

void entry_1df048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df048) {
        switch (ctx->pc) {
            case 0x1df10c: ctx->pc = 0; goto label_1df10c;
            case 0x1df11c: ctx->pc = 0; goto label_1df11c;
            case 0x1df130: ctx->pc = 0; goto label_1df130;
            case 0x1df134: ctx->pc = 0; goto label_1df134;
            case 0x1df17c: ctx->pc = 0; goto label_1df17c;
            case 0x1df18c: ctx->pc = 0; goto label_1df18c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df048: 0x7ba400e0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1df04c: 0x7ba200f0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1df050: 0x7ba30100
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1df054: 0x8e05074c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1868)));
    // 0x1df058: 0x7fa200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 2));
    // 0x1df05c: 0x7fa300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 3));
    // 0x1df060: 0x7fa400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 4));
    // 0x1df064: 0x7ca40040
    WRITE128(ADD32(GPR_U32(ctx, 5), 64), GPR_VEC(ctx, 4));
    // 0x1df068: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1df06c: 0x7ba200c0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1df070: 0x7ca20050
    WRITE128(ADD32(GPR_U32(ctx, 5), 80), GPR_VEC(ctx, 2));
    // 0x1df074: 0x7ba300d0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1df078: 0x7ca30060
    WRITE128(ADD32(GPR_U32(ctx, 5), 96), GPR_VEC(ctx, 3));
    // 0x1df07c: 0x7ba200b0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1df080: 0x8e040754
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    // 0x1df084: 0x7c820040
    WRITE128(ADD32(GPR_U32(ctx, 4), 64), GPR_VEC(ctx, 2));
    // 0x1df088: 0x7ba300c0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1df08c: 0x7c830050
    WRITE128(ADD32(GPR_U32(ctx, 4), 80), GPR_VEC(ctx, 3));
    // 0x1df090: 0x7ba200d0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1df094: 0x7c820060
    WRITE128(ADD32(GPR_U32(ctx, 4), 96), GPR_VEC(ctx, 2));
    // 0x1df098: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1df09c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1df0a0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1df0a4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1df0a8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1df0ac: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1df0b0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1df0b4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1df0b8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1df0bc: 0x44821800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 2);
    // 0x1df0c0: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1df0c4: 0x0
    // NOP
    // 0x1df0c8: 0x45000019
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1df130;
    }
    // 0x1df0d0: 0xc6255c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x1df0d4: 0x24435840
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 22592));
    // 0x1df0d8: 0xc4425840
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22592)); ctx->f[2] = *(float*)&val; }
    // 0x1df0dc: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1df0e0: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1df0e4: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1df0e8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1df0ec: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1df0f0: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1df0f4: 0x46051034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1df0f8: 0x0
    // NOP
    // 0x1df0fc: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1df10c;
    }
    // 0x1df104: 0x10000005
    ctx->f[2] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1df11c;
    }
label_1df10c:
    // 0x1df10c: 0x46022034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1df110: 0x0
    // NOP
    // 0x1df114: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_MOV_S(ctx->f[4]);
        goto label_1df11c;
    }
label_1df11c:
    // 0x1df11c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1df120: 0xc4405860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22624)); ctx->f[0] = *(float*)&val; }
    // 0x1df124: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1df128: 0x10000002
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[21] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[21] = ctx->f[0] / ctx->f[3];
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1df134;
    }
label_1df130:
    // 0x1df130: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
label_1df134:
    // 0x1df134: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1df138: 0xc6420048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 72)); ctx->f[2] = *(float*)&val; }
    // 0x1df13c: 0x24435850
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 22608));
    // 0x1df140: 0xc4435850
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22608)); ctx->f[3] = *(float*)&val; }
    // 0x1df144: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1df148: 0x26225c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 23648));
    // 0x1df14c: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1df150: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1df154: 0xc6245c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1df158: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1df15c: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1df160: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1df164: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1df168: 0x0
    // NOP
    // 0x1df16c: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1df17c;
    }
    // 0x1df174: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1df18c;
    }
label_1df17c:
    // 0x1df17c: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1df180: 0x0
    // NOP
    // 0x1df184: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_1df18c;
    }
label_1df18c:
    // 0x1df18c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1df190: 0xc7ac0178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[12] = *(float*)&val; }
    // 0x1df194: 0xc4545864
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22628)); ctx->f[20] = *(float*)&val; }
    // 0x1df198: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1df19c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1df1a0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1df1a4: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x1df1a8: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1df1b0);
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[3]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1df1b0
// Address: 0x1df1b0 - 0x1df254

void entry_1df1b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df1b0: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x1df1b4: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1df1b8: 0xda040150
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1df1bc: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1df1c0: 0x48a23000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1df1c4: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1df1c8: 0x8e030748
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1864)));
    // 0x1df1cc: 0x4be221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1df1d0: 0x4be60908
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1df1d4: 0xfba200f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1df1d8: 0xfba400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1df1dc: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1df1e0: 0x8e04074c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1868)));
    // 0x1df1e4: 0x24430110
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 272));
    // 0x1df1e8: 0xd8430110
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 272)));
    // 0x1df1ec: 0xd8620020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1df1f0: 0xd8610010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1df1f4: 0xfba600f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1df1f8: 0x4be41a6a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1df1fc: 0x4be00293
    // Unhandled VU0 Special1 function: 0x13
    // 0x1df200: 0x4be40a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1df204: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1df208: 0x4b09483d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); }
    // 0x1df20c: 0x4b09514a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[9], ctx->vu0_vf[9], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1df210: 0x4a88403c
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x1df214: 0x4a88514a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1df218: 0x4a47383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1df21c: 0x4a475149
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1df220: 0xf8850020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1df224: 0x8e02073c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1852)));
    // 0x1df228: 0x1040000d
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1df260(rdram, ctx, runtime); return;
    }
    // 0x1df230: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1df234: 0x1060000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DF264; return;
    }
    // 0x1df23c: 0x964200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 170)));
    // 0x1df240: 0x30420040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64));
    // 0x1df244: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DF264; return;
    }
    // 0x1df24c: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1df254);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1df254
// Address: 0x1df254 - 0x1df260

void entry_1df254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df254: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1df258: 0xc077ef8
    SET_GPR_U32(ctx, 31, 0x1df260);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTankTanks__FP4TANK5TANKS(rdram, ctx, runtime); return;
}


// Function: entry_1df260
// Address: 0x1df260 - 0x1df290

void entry_1df260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df260) {
        switch (ctx->pc) {
            case 0x1df264: ctx->pc = 0; goto label_1df264;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df260: 0x7bbf01e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 480)));
label_1df264:
    // 0x1df264: 0x7bb501d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x1df268: 0x7bb401c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1df26c: 0x7bb301b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1df270: 0x7bb201a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1df274: 0x7bb10190
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1df278: 0x7bb00180
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1df27c: 0xc7b501f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 504)); ctx->f[21] = *(float*)&val; }
    // 0x1df280: 0xc7b401f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 496)); ctx->f[20] = *(float*)&val; }
    // 0x1df284: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 512));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1df28c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1df290; return;
}


// Function: OnTankActive__FP4TANKiP2PO
// Address: 0x1df290 - 0x1df2ac

void entry_1df2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df2ac) {
        switch (ctx->pc) {
            case 0x1df2b4: ctx->pc = 0; goto label_1df2b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df2ac: 0x52000001
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1832), GPR_U32(ctx, 0));
        goto label_1df2b4;
    }
label_1df2b4:
    // 0x1df2b4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1df2b8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1df2bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1df2c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderTankAll__FP4TANKP2CMP2RO
// Address: 0x1df2c8 - 0x1df368

void entry_1df368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df368) {
        switch (ctx->pc) {
            case 0x1df3c4: ctx->pc = 0; goto label_1df3c4;
            case 0x1df408: ctx->pc = 0; goto label_1df408;
            case 0x1df418: ctx->pc = 0; goto label_1df418;
            case 0x1df4cc: ctx->pc = 0; goto label_1df4cc;
            case 0x1df4e4: ctx->pc = 0; goto label_1df4e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df368: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1df36c: 0x46000186
    ctx->f[6] = FPU_MOV_S(ctx->f[0]);
    // 0x1df370: 0x24435870
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 22640));
    // 0x1df374: 0xc4425870
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22640)); ctx->f[2] = *(float*)&val; }
    // 0x1df378: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1df37c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1df380: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1df384: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1df388: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1df38c: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1df390: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1df394: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1df398: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1df39c: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1df3a0: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1df3a4: 0x0
    // NOP
    // 0x1df3a8: 0x45010006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1df3c4;
    }
    // 0x1df3b0: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1df3b4: 0x0
    // NOP
    // 0x1df3b8: 0x45000002
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1df3c4;
    }
    // 0x1df3c0: 0x46001906
    ctx->f[4] = FPU_MOV_S(ctx->f[3]);
label_1df3c4:
    // 0x1df3c4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1df3c8: 0xc4855c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x1df3cc: 0x24435880
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 22656));
    // 0x1df3d0: 0xc4425880
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22656)); ctx->f[2] = *(float*)&val; }
    // 0x1df3d4: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1df3d8: 0x24825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x1df3dc: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1df3e0: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x1df3e4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1df3e8: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x1df3ec: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1df3f0: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1df3f4: 0x0
    // NOP
    // 0x1df3f8: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1df408;
    }
    // 0x1df400: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1df418;
    }
label_1df408:
    // 0x1df408: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1df40c: 0x0
    // NOP
    // 0x1df410: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[3]);
        goto label_1df418;
    }
label_1df418:
    // 0x1df418: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1df41c: 0x46002102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1df420: 0x904323e0
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 9184)));
    // 0x1df424: 0x244423e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 9184));
    // 0x1df428: 0x93a20010
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1df42c: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1df430: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1df434: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1df438: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1df43c: 0x90830002
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 2)));
    // 0x1df440: 0x44822800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 2);
    // 0x1df444: 0x46802960
    ctx->f[5] = FPU_CVT_S_W(*(int32_t*)&ctx->f[5]);
    // 0x1df448: 0x93a50012
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 18)));
    // 0x1df44c: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x1df450: 0x90860001
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 1)));
    // 0x1df454: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x1df458: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1df45c: 0x93a70011
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 17)));
    // 0x1df460: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x1df464: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1df468: 0x44863800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 6);
    // 0x1df46c: 0x468039e0
    ctx->f[7] = FPU_CVT_S_W(*(int32_t*)&ctx->f[7]);
    // 0x1df470: 0x90820003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 3)));
    // 0x1df474: 0x44873000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 7);
    // 0x1df478: 0x468031a0
    ctx->f[6] = FPU_CVT_S_W(*(int32_t*)&ctx->f[6]);
    // 0x1df47c: 0x460300c2
    ctx->f[3] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1df480: 0xa3a20003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 2));
    // 0x1df484: 0x46052142
    ctx->f[5] = FPU_MUL_S(ctx->f[4], ctx->f[5]);
    // 0x1df488: 0x46012042
    ctx->f[1] = FPU_MUL_S(ctx->f[4], ctx->f[1]);
    // 0x1df48c: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1df490: 0x46070002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[7]);
    // 0x1df494: 0x46062102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[6]);
    // 0x1df498: 0x460518c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[5]);
    // 0x1df49c: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1df4a0: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x1df4a4: 0x46001864
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[3]);
    // 0x1df4a8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1df4ac: 0x46001064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[2]);
    // 0x1df4b0: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1df4b4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1df4b8: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1df4bc: 0xa3a20000
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1df4c0: 0xa3a30002
    WRITE8(ADD32(GPR_U32(ctx, 29), 2), (uint8_t)GPR_U32(ctx, 3));
    // 0x1df4c4: 0x10000007
    WRITE8(ADD32(GPR_U32(ctx, 29), 1), (uint8_t)GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1df4e4;
    }
label_1df4cc:
    // 0x1df4cc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1df4d0: 0x244623e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 9184));
    // 0x1df4d4: 0x88c30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1df4d8: 0x98c30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x1df4dc: 0xaba30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1df4e0: 0xbba30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
label_1df4e4:
    // 0x1df4e4: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1df4e8: 0xc049a92
    SET_GPR_U32(ctx, 31, 0x1df4f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetAloOverrideCel__FP3ALOG4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1df4f0
// Address: 0x1df4f0 - 0x1df500

void entry_1df4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df4f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1df4f4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1df4f8: 0xc049724
    SET_GPR_U32(ctx, 31, 0x1df500);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RenderAloAll__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_1df500
// Address: 0x1df500 - 0x1df520

void entry_1df500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df500: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1df504: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1df508: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1df50c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1df510: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1df514: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1df51c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1df520; return;
}


// Function: ImpactTank__FP4TANKi
// Address: 0x1df520 - 0x1df594

void entry_1df594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df594: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1df598: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FInvulnerableTank__FP4TANK3ZPK
// Address: 0x1df5a0 - 0x1df5e4

void entry_1df5e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df5e4) {
        switch (ctx->pc) {
            case 0x1df5ec: ctx->pc = 0; goto label_1df5ec;
            case 0x1df5f0: ctx->pc = 0; goto label_1df5f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df5e4: 0x10400002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1df5f0;
    }
label_1df5ec:
    // 0x1df5ec: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1df5f0:
    // 0x1df5f0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1df5f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1df5fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1df600; return;
}


// Function: ApplyTankThrow__FP4TANKP2PO
// Address: 0x1df600 - 0x1df6b4

void entry_1df6b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df6b4: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1df6b8: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1df6c0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1df6c0
// Address: 0x1df6c0 - 0x1df6d4

void entry_1df6c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df6c0: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1df6c4: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1df6c8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1df6cc: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1df6d4);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1df6d4
// Address: 0x1df6d4 - 0x1df6e0

void entry_1df6d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df6d4: 0xe6000638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    // 0x1df6d8: 0xc071756
    SET_GPR_U32(ctx, 31, 0x1df6e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FixStepAngularVelocity__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1df6e0
// Address: 0x1df6e0 - 0x1df6f0

void entry_1df6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df6e0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1df6e4: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1df6e8: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1df6f0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 43));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1df6f0
// Address: 0x1df6f0 - 0x1df700

void entry_1df6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df6f0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1df6f4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1df6f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FTakeTankDamage__FP4TANKP3ZPR
// Address: 0x1df700 - 0x1df72c

void entry_1df72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df72c: 0x144000b1
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DF9F4; return;
    }
    // 0x1df734: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1df73c);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1df73c
// Address: 0x1df73c - 0x1df764

void entry_1df73c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df73c) {
        switch (ctx->pc) {
            case 0x1df748: ctx->pc = 0; goto label_1df748;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df73c: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1df748;
    }
    // 0x1df744: 0xae220728
    WRITE32(ADD32(GPR_U32(ctx, 17), 1832), GPR_U32(ctx, 2));
label_1df748:
    // 0x1df748: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1df74c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1df750: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1df754: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1df758: 0x24060007
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1df75c: 0xc04e2f8
    SET_GPR_U32(ctx, 31, 0x1df764);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1836), *(uint32_t*)&val); }
    InvalidateSwXpForObject__FP2SWP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1df764
// Address: 0x1df764 - 0x1df788

void entry_1df764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df764: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1df768: 0x1440006a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1df914(rdram, ctx, runtime); return;
    }
    // 0x1df770: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1df774: 0x10400067
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1df914(rdram, ctx, runtime); return;
    }
    // 0x1df77c: 0x8e440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1df780: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1df788);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1df788
// Address: 0x1df788 - 0x1df800

void entry_1df788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df788) {
        switch (ctx->pc) {
            case 0x1df7e8: ctx->pc = 0; goto label_1df7e8;
            case 0x1df7f8: ctx->pc = 0; goto label_1df7f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df788: 0x7a220150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x1df78c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1df790: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1df794: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1df798: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1df79c: 0x24638d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x1df7a0: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1df7a4: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x1df7a8: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1df7ac: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1df7b0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1df7b4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1df7b8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1df7bc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1df7c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1df7c4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1df7c8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1df7cc: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1df7d0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1df7d4: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1df7e8;
    }
    // 0x1df7dc: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1df7e0: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1df7f8;
    }
label_1df7e8:
    // 0x1df7e8: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1df7ec: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1df7f0: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1df7f4: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_1df7f8:
    // 0x1df7f8: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1df800);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1df800
// Address: 0x1df800 - 0x1df848

void entry_1df800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df800) {
        switch (ctx->pc) {
            case 0x1df814: ctx->pc = 0; goto label_1df814;
            case 0x1df820: ctx->pc = 0; goto label_1df820;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df800: 0x10400004
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1df814;
    }
    // 0x1df808: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1df80c: 0x10000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 22684)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1df820;
    }
label_1df814:
    // 0x1df814: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1df818: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1df81c: 0x8c4258a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 22688)));
label_1df820:
    // 0x1df820: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1df824: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1df828: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1df82c: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1df830: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1df834: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1df838: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1df83c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1df840: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1df848);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1df848
// Address: 0x1df848 - 0x1df888

void entry_1df848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df848: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1df84c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1df850: 0x8c6358a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 22692)));
    // 0x1df854: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1df858: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1df85c: 0xc44058a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22696)); ctx->f[0] = *(float*)&val; }
    // 0x1df860: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1df864: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1df868: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1df86c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1df870: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x1df874: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1df878: 0x8e220748
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1864)));
    // 0x1df87c: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1df880: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1df888);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1df888
// Address: 0x1df888 - 0x1df89c

void entry_1df888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df888: 0x8e240748
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1864)));
    // 0x1df88c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1df890: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1df894: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1df89c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1df89c
// Address: 0x1df89c - 0x1df900

void entry_1df89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df89c: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1df8a0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1df8a4: 0x8c4258ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 22700)));
    // 0x1df8a8: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1df8ac: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1df8b0: 0xc7a20000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1df8b4: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x1df8b8: 0x8e230748
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1864)));
    // 0x1df8bc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1df8c0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1df8c4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1df8c8: 0x44041000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[2]);
    // 0x1df8cc: 0x70821488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 4), GPR_VEC(ctx, 2)));
    // 0x1df8d0: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1df8d4: 0x70821389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 4), GPR_VEC(ctx, 2)));
    // 0x1df8d8: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1df8dc: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1df8e0: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x1df8e4: 0x4be21858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1df8e8: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1df8ec: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1df8f0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1df8f4: 0x8c650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1df8f8: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1df900);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1df900
// Address: 0x1df900 - 0x1df914

void entry_1df900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df900: 0x8e240748
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1864)));
    // 0x1df904: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1df908: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1df90c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1df914);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1df914
// Address: 0x1df914 - 0x1df91c

void entry_1df914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df914: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1df91c);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1df91c
// Address: 0x1df91c - 0x1df940

void entry_1df91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df91c) {
        switch (ctx->pc) {
            case 0x1df938: ctx->pc = 0; goto label_1df938;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df91c: 0x14400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1df938;
    }
    // 0x1df924: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1df928: 0x8e042e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    // 0x1df92c: 0x54800006
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
        ctx->pc = 0x1DF948; return;
    }
    // 0x1df934: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1df938:
    // 0x1df938: 0xc077ef8
    SET_GPR_U32(ctx, 31, 0x1df940);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetTankTanks__FP4TANK5TANKS(rdram, ctx, runtime); return;
}


// Function: entry_1df940
// Address: 0x1df940 - 0x1df954

void entry_1df940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df940) {
        switch (ctx->pc) {
            case 0x1df948: ctx->pc = 0; goto label_1df948;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df940: 0x10000023
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DF9D0; return;
    }
label_1df948:
    // 0x1df948: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1df94c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1df954);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1df954
// Address: 0x1df954 - 0x1df968

void entry_1df954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df954: 0x8e042e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    // 0x1df958: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1df95c: 0x8c62008c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 140)));
    // 0x1df960: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1df968);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1860)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1df968
// Address: 0x1df968 - 0x1df97c

void entry_1df968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df968: 0x8e240744
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1860)));
    // 0x1df96c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1df970: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1df974: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1df97c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1df97c
// Address: 0x1df97c - 0x1df984

void entry_1df97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df97c: 0xc064a74
    SET_GPR_U32(ctx, 31, 0x1df984);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    SwitchToPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1df984
// Address: 0x1df984 - 0x1df990

void entry_1df984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df984: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1df988: 0xc077ef8
    SET_GPR_U32(ctx, 31, 0x1df990);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetTankTanks__FP4TANK5TANKS(rdram, ctx, runtime); return;
}


// Function: entry_1df990
// Address: 0x1df990 - 0x1df9a0

void entry_1df990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df990: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1df994: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1df998: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x1df9a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1df9a0
// Address: 0x1df9a0 - 0x1df9c4

void entry_1df9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1df9a0: 0x3c02001e
    SET_GPR_U32(ctx, 2, ((uint32_t)30 << 16));
    // 0x1df9a4: 0x8e062e10
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    // 0x1df9a8: 0x2442f600
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294964736));
    // 0x1df9ac: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1df9b0: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x1df9b4: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1df9b8: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1df9bc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1df9c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1df9c4
// Address: 0x1df9c4 - 0x1df9f0

void entry_1df9c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df9c4) {
        switch (ctx->pc) {
            case 0x1df9d0: ctx->pc = 0; goto label_1df9d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df9c4: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1df9c8: 0xae2304e0
    WRITE32(ADD32(GPR_U32(ctx, 17), 1248), GPR_U32(ctx, 3));
    // 0x1df9cc: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_1df9d0:
    // 0x1df9d0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1df9d4: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    // 0x1df9d8: 0x24050017
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 23));
    // 0x1df9dc: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1df9e0: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1df9e4: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1df9e8: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1df9f0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1df9f0
// Address: 0x1df9f0 - 0x1dfa10

void entry_1df9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1df9f0) {
        switch (ctx->pc) {
            case 0x1df9f4: ctx->pc = 0; goto label_1df9f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1df9f0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1df9f4:
    // 0x1df9f4: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1df9f8: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1df9fc: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1dfa00: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dfa04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dfa0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dfa10; return;
}


// Function: FUN_001dfa10
// Address: 0x1dfa10 - 0x1dfa28

void FUN_001dfa10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfa10: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1dfa14: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1dfa18: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1dfa1c: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1dfa20: 0xc06f136
    SET_GPR_U32(ctx, 31, 0x1dfa28);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1856));
    FUN_001bc4d8(rdram, ctx, runtime); return;
}


// Function: entry_1dfa28
// Address: 0x1dfa28 - 0x1dfa30

void entry_1dfa28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfa28: 0xc0715f2
    SET_GPR_U32(ctx, 31, 0x1dfa30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AdjustStepXps__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1dfa30
// Address: 0x1dfa30 - 0x1dfa40

void entry_1dfa30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfa30: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dfa34: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dfa38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AdjustTankNewXp__FP4TANKP2XPi
// Address: 0x1dfa40 - 0x1dfa64

void entry_1dfa64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dfa64) {
        switch (ctx->pc) {
            case 0x1dfac0: ctx->pc = 0; goto label_1dfac0;
            case 0x1dfad4: ctx->pc = 0; goto label_1dfad4;
            case 0x1dfaec: ctx->pc = 0; goto label_1dfaec;
            case 0x1dfaf4: ctx->pc = 0; goto label_1dfaf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dfa64: 0x10400021
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1dfaec;
    }
    // 0x1dfa6c: 0xc601072c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1836)); ctx->f[1] = *(float*)&val; }
    // 0x1dfa70: 0xc462185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[2] = *(float*)&val; }
    // 0x1dfa74: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dfa78: 0x244358c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 22720));
    // 0x1dfa7c: 0xc44358c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22720)); ctx->f[3] = *(float*)&val; }
    // 0x1dfa80: 0x46011081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    // 0x1dfa84: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1dfa88: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1dfa8c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dfa90: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1dfa94: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1dfa98: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1dfa9c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1dfaa0: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1dfaa4: 0x46021800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1dfaa8: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dfaac: 0x0
    // NOP
    // 0x1dfab0: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1dfac0;
    }
    // 0x1dfab8: 0x10000006
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dfad4;
    }
label_1dfac0:
    // 0x1dfac0: 0x46002834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dfac4: 0x0
    // NOP
    // 0x1dfac8: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1dfad4;
    }
    // 0x1dfad0: 0x460028c6
    ctx->f[3] = FPU_MOV_S(ctx->f[5]);
label_1dfad4:
    // 0x1dfad4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1dfad8: 0xc44058b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22704)); ctx->f[0] = *(float*)&val; }
    // 0x1dfadc: 0xae200098
    WRITE32(ADD32(GPR_U32(ctx, 17), 152), GPR_U32(ctx, 0));
    // 0x1dfae0: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1dfae4: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 148), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dfaf4;
    }
label_1dfaec:
    // 0x1dfaec: 0xae200098
    WRITE32(ADD32(GPR_U32(ctx, 17), 152), GPR_U32(ctx, 0));
    // 0x1dfaf0: 0xae200094
    WRITE32(ADD32(GPR_U32(ctx, 17), 148), GPR_U32(ctx, 0));
label_1dfaf4:
    // 0x1dfaf4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dfaf8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dfafc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dfb00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleTankMessage__FP4TANK5MSGIDPv
// Address: 0x1dfb08 - 0x1dfb54

void entry_1dfb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfb54: 0x8e04075c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
    // 0x1dfb58: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x1dfb60);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1dfb60
// Address: 0x1dfb60 - 0x1dfbb8

void entry_1dfb60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dfb60) {
        switch (ctx->pc) {
            case 0x1dfb68: ctx->pc = 0; goto label_1dfb68;
            case 0x1dfba0: ctx->pc = 0; goto label_1dfba0;
            case 0x1dfba8: ctx->pc = 0; goto label_1dfba8;
            case 0x1dfbac: ctx->pc = 0; goto label_1dfbac;
            case 0x1dfbb0: ctx->pc = 0; goto label_1dfbb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dfb60: 0x10000012
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dfbac;
    }
label_1dfb68:
    // 0x1dfb68: 0x8e02075c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
    // 0x1dfb6c: 0x1040000e
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1dfba8;
    }
    // 0x1dfb74: 0x8c420024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x1dfb78: 0x1462000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1dfbac;
    }
    // 0x1dfb80: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1dfb84: 0x2402015e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 350));
    // 0x1dfb88: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 351));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1dfba0;
    }
    // 0x1dfb90: 0x50620006
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1848), GPR_U32(ctx, 0));
        goto label_1dfbac;
    }
    // 0x1dfb98: 0x10000005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dfbb0;
    }
label_1dfba0:
    // 0x1dfba0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1dfba4: 0xae020738
    WRITE32(ADD32(GPR_U32(ctx, 16), 1848), GPR_U32(ctx, 2));
label_1dfba8:
    // 0x1dfba8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1dfbac:
    // 0x1dfbac: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1dfbb0:
    // 0x1dfbb0: 0xc06488c
    SET_GPR_U32(ctx, 31, 0x1dfbb8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    HandlePoMessage__FP2PO5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_1dfbb8
// Address: 0x1dfbb8 - 0x1dfbd0

void entry_1dfbb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfbb8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1dfbbc: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dfbc0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dfbc4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dfbc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: JthsCurrentTank__FP4TANK
// Address: 0x1dfbd0 - 0x1dfbe0

void entry_1dfc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dfc84) {
        switch (ctx->pc) {
            case 0x1dfc8c: ctx->pc = 0; goto label_1dfc8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dfc84: 0x10000011
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DFCCC; return;
    }
label_1dfc8c:
    // 0x1dfc8c: 0x8e04075c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
    // 0x1dfc90: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1dfc98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 850));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1dfc98
// Address: 0x1dfc98 - 0x1dfcac

void entry_1dfc98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dfc98) {
        switch (ctx->pc) {
            case 0x1dfca0: ctx->pc = 0; goto label_1dfca0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dfc98: 0x1000000c
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DFCCC; return;
    }
label_1dfca0:
    // 0x1dfca0: 0x8e04075c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1884)));
    // 0x1dfca4: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x1dfcac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 852));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1dfcac
// Address: 0x1dfcac - 0x1dfcbc

void entry_1dfcac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dfcac) {
        switch (ctx->pc) {
            case 0x1dfcb4: ctx->pc = 0; goto label_1dfcb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dfcac: 0x10000005
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DFCC4; return;
    }
label_1dfcb4:
    // 0x1dfcb4: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x1dfcbc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 853));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1dfcbc
// Address: 0x1dfcbc - 0x1dfd10

void entry_1dfcbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dfcbc) {
        switch (ctx->pc) {
            case 0x1dfcc4: ctx->pc = 0; goto label_1dfcc4;
            case 0x1dfccc: ctx->pc = 0; goto label_1dfccc;
            case 0x1dfcf0: ctx->pc = 0; goto label_1dfcf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dfcbc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1dfcc0: 0xae1104e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1248), GPR_U32(ctx, 17));
label_1dfcc4:
    // 0x1dfcc4: 0xc440dca8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294958248)); ctx->f[0] = *(float*)&val; }
    // 0x1dfcc8: 0xe6000730
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1840), *(uint32_t*)&val); }
label_1dfccc:
    // 0x1dfccc: 0x12200008
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1dfcf0;
    }
    // 0x1dfcd4: 0x6200010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 4));
    if (GPR_S32(ctx, 17) < 0) {
        ctx->pc = 0x1DFD18; return;
    }
    // 0x1dfcdc: 0x1040000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DFD18; return;
    }
    // 0x1dfce4: 0x1440000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DFD1C; return;
    }
    // 0x1dfcec: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
label_1dfcf0:
    // 0x1dfcf0: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1dfcf4: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1dfcf8: 0xc60c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1dfcfc: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1dfd00: 0x24848d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    // 0x1dfd04: 0x26050660
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 1632));
    // 0x1dfd08: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1dfd10);
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), GPR_VEC(ctx, 3));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1dfd10
// Address: 0x1dfd10 - 0x1dfd48

void entry_1dfd10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dfd10) {
        switch (ctx->pc) {
            case 0x1dfd18: ctx->pc = 0; goto label_1dfd18;
            case 0x1dfd1c: ctx->pc = 0; goto label_1dfd1c;
            case 0x1dfd20: ctx->pc = 0; goto label_1dfd20;
            case 0x1dfd30: ctx->pc = 0; goto label_1dfd30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dfd10: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 1408), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dfd20;
    }
label_1dfd18:
    // 0x1dfd18: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_1dfd1c:
    // 0x1dfd1c: 0xae020580
    WRITE32(ADD32(GPR_U32(ctx, 16), 1408), GPR_U32(ctx, 2));
label_1dfd20:
    // 0x1dfd20: 0xae110720
    WRITE32(ADD32(GPR_U32(ctx, 16), 1824), GPR_U32(ctx, 17));
    // 0x1dfd24: 0x26421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    // 0x1dfd28: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1dfd2c: 0xe6000724
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1828), *(uint32_t*)&val); }
label_1dfd30:
    // 0x1dfd30: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1dfd34: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dfd38: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dfd3c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dfd40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StartupTarget__Fv
// Address: 0x1dfd48 - 0x1dfd60

void entry_1dfd60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfd60: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dfd64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dfd6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dfd70; return;
}


// Function: ResetTargetList__Fv
// Address: 0x1dfd70 - 0x1dfd84

void entry_1dfd84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfd84: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dfd88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitTarget__FP6TARGET
// Address: 0x1dfd90 - 0x1dfda4

void entry_1dfda4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfda4: 0x3c0141c8
    SET_GPR_U32(ctx, 1, ((uint32_t)16840 << 16));
    // 0x1dfda8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1dfdac: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x1dfdb0: 0xae020088
    WRITE32(ADD32(GPR_U32(ctx, 16), 136), GPR_U32(ctx, 2));
    // 0x1dfdb4: 0xe600008c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 140), *(uint32_t*)&val); }
    // 0x1dfdb8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dfdbc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dfdc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnTargetAdd__FP6TARGET
// Address: 0x1dfdc8 - 0x1dfddc

void entry_1dfddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfddc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1dfde0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dfde4: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1dfdec);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 22736));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1dfdec
// Address: 0x1dfdec - 0x1dfe00

void entry_1dfdec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfdec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dfdf0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dfdf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dfdfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dfe00; return;
}


// Function: OnTargetRemove__FP6TARGET
// Address: 0x1dfe00 - 0x1dfe14

void entry_1dfe14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfe14: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1dfe18: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dfe1c: 0xc054980
    SET_GPR_U32(ctx, 31, 0x1dfe24);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 22736));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1dfe24
// Address: 0x1dfe24 - 0x1dfe38

void entry_1dfe24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfe24: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dfe28: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1dfe2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1dfe34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1dfe38; return;
}


// Function: CloneTarget__FP6TARGETT0
// Address: 0x1dfe38 - 0x1dfe60

void entry_1dfe60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfe60: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1dfe64: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1dfe68: 0xb2020087
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 135); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1dfe6c: 0xb6020080
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 128); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1dfe70: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1dfe74: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1dfe78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: get_commentary_data_by_level_id
// Address: 0x1dfe80 - 0x1dfeb8

void entry_1dfee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dfee0: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1dfee4: 0x8e0223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9152)));
    // 0x1dfee8: 0x8c4419d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6616)));
    // 0x1dfeec: 0x8c4319dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6620)));
    // 0x1dfef0: 0x42200
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 8));
    // 0x1dfef4: 0xc077fa0
    SET_GPR_U32(ctx, 31, 0x1dfefc);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    get_commentary_data_by_level_id(rdram, ctx, runtime); return;
}


// Function: entry_1dfefc
// Address: 0x1dfefc - 0x1dff74

void entry_1dfefc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dfefc) {
        switch (ctx->pc) {
            case 0x1dff28: ctx->pc = 0; goto label_1dff28;
            case 0x1dff3c: ctx->pc = 0; goto label_1dff3c;
            case 0x1dff48: ctx->pc = 0; goto label_1dff48;
            case 0x1dff60: ctx->pc = 0; goto label_1dff60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dfefc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1dff00: 0x12000021
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DFF88; return;
    }
    // 0x1dff08: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1dff0c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1dff10: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1dff14: 0x0
    // NOP
    // 0x1dff18: 0x45010003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1dff28;
    }
    // 0x1dff20: 0xe441230c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 8972), *(uint32_t*)&val); }
    // 0x1dff24: 0x8e425710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
label_1dff28:
    // 0x1dff28: 0x8c422310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8976)));
    // 0x1dff2c: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
        goto label_1dff3c;
    }
    // 0x1dff34: 0x10000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1dff48;
    }
label_1dff3c:
    // 0x1dff3c: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1dff40: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1dff44: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1dff48:
    // 0x1dff48: 0x14400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1dff60;
    }
    // 0x1dff50: 0x8e435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    // 0x1dff54: 0x26020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 8));
    // 0x1dff58: 0xac622310
    WRITE32(ADD32(GPR_U32(ctx, 3), 8976), GPR_U32(ctx, 2));
    // 0x1dff5c: 0x8e425710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
label_1dff60:
    // 0x1dff60: 0x8c442314
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 8980)));
    // 0x1dff64: 0x50800006
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 40)));
        ctx->pc = 0x1DFF80; return;
    }
    // 0x1dff6c: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1dff74);
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1dff74
// Address: 0x1dff74 - 0x1dff90

void entry_1dff74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dff74) {
        switch (ctx->pc) {
            case 0x1dff80: ctx->pc = 0; goto label_1dff80;
            case 0x1dff88: ctx->pc = 0; goto label_1dff88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dff74: 0x14400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1dff88;
    }
    // 0x1dff7c: 0x8e030028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 40)));
label_1dff80:
    // 0x1dff80: 0x8e425710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    // 0x1dff84: 0xac432314
    WRITE32(ADD32(GPR_U32(ctx, 2), 8980), GPR_U32(ctx, 3));
label_1dff88:
    // 0x1dff88: 0xc057062
    SET_GPR_U32(ctx, 31, 0x1dff90);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c188(rdram, ctx, runtime); return;
}


// Function: entry_1dff90
// Address: 0x1dff90 - 0x1dffa8

void entry_1dff90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dff90: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1DFFB0; return;
    }
    // 0x1dff98: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1dff9c: 0x244258e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 22752));
    // 0x1dffa0: 0xc057070
    SET_GPR_U32(ctx, 31, 0x1dffa8);
    WRITE32(ADD32(GPR_U32(ctx, 17), 528), GPR_U32(ctx, 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_1dffa8
// Address: 0x1dffa8 - 0x1dffc4

void entry_1dffa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dffa8) {
        switch (ctx->pc) {
            case 0x1dffb0: ctx->pc = 0; goto label_1dffb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dffa8: 0x8e230210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1dffac: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_1dffb0:
    // 0x1dffb0: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x1dffb4: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1dffb8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1dffbc: 0xc06a9e2
    SET_GPR_U32(ctx, 31, 0x1dffc4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetBlotFontScale__FfP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1dffc4
// Address: 0x1dffc4 - 0x1dffec

void entry_1dffc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dffc4: 0x3c02df7f
    SET_GPR_U32(ctx, 2, ((uint32_t)57215 << 16));
    // 0x1dffc8: 0x34427f7f
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32639));
    // 0x1dffcc: 0xae220208
    WRITE32(ADD32(GPR_U32(ctx, 17), 520), GPR_U32(ctx, 2));
    // 0x1dffd0: 0x8e6323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 9152)));
    // 0x1dffd4: 0x8e445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    // 0x1dffd8: 0x8c6519d8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x1dffdc: 0x8c6219dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x1dffe0: 0x52a00
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 8));
    // 0x1dffe4: 0xc0775e8
    SET_GPR_U32(ctx, 31, 0x1dffec);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    FUN_001dd7a0(rdram, ctx, runtime); return;
}


// Function: entry_1dffec
// Address: 0x1dffec - 0x1dfffc

void entry_1dffec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1dffec: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0004; return;
    }
    // 0x1dfff4: 0xc0780b2
    SET_GPR_U32(ctx, 31, 0x1dfffc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    gui_set_widget_modeQMARK(rdram, ctx, runtime); return;
}


// Function: entry_1dfffc
// Address: 0x1dfffc - 0x1e000c

void entry_1dfffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1dfffc) {
        switch (ctx->pc) {
            case 0x1e0004: ctx->pc = 0; goto label_1e0004;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1dfffc: 0x10000004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0010; return;
    }
label_1e0004:
    // 0x1e0004: 0xc0780b2
    SET_GPR_U32(ctx, 31, 0x1e000c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    gui_set_widget_modeQMARK(rdram, ctx, runtime); return;
}


// Function: entry_1e000c
// Address: 0x1e000c - 0x1e0060

void entry_1d0060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0060 inside entry_1d0058 (0x1d0058 - 0x1d0074)
    ctx->pc = 0x1d0060;
    entry_1d0058(rdram, ctx, runtime);
}

void entry_1d007c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d007c inside entry_1d0074 (0x1d0074 - 0x1d0088)
    ctx->pc = 0x1d007c;
    entry_1d0074(rdram, ctx, runtime);
}

void entry_1d008c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d008c inside entry_1d0088 (0x1d0088 - 0x1d0144)
    ctx->pc = 0x1d008c;
    entry_1d0088(rdram, ctx, runtime);
}

void entry_1d00cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d00cc inside entry_1d0088 (0x1d0088 - 0x1d0144)
    ctx->pc = 0x1d00cc;
    entry_1d0088(rdram, ctx, runtime);
}

void entry_1d00fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d00fc inside entry_1d0088 (0x1d0088 - 0x1d0144)
    ctx->pc = 0x1d00fc;
    entry_1d0088(rdram, ctx, runtime);
}

void entry_1d0164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0164 inside entry_1d0144 (0x1d0144 - 0x1d0190)
    ctx->pc = 0x1d0164;
    entry_1d0144(rdram, ctx, runtime);
}

void entry_1d0174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0174 inside entry_1d0144 (0x1d0144 - 0x1d0190)
    ctx->pc = 0x1d0174;
    entry_1d0144(rdram, ctx, runtime);
}

void entry_1d01fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d01fc inside entry_1d01a4 (0x1d01a4 - 0x1d0290)
    ctx->pc = 0x1d01fc;
    entry_1d01a4(rdram, ctx, runtime);
}

void entry_1d0228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0228 inside entry_1d01a4 (0x1d01a4 - 0x1d0290)
    ctx->pc = 0x1d0228;
    entry_1d01a4(rdram, ctx, runtime);
}

void entry_1d02f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d02f0 inside entry_1d02c4 (0x1d02c4 - 0x1d03f8)
    ctx->pc = 0x1d02f0;
    entry_1d02c4(rdram, ctx, runtime);
}

void entry_1d02f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d02f4 inside entry_1d02c4 (0x1d02c4 - 0x1d03f8)
    ctx->pc = 0x1d02f4;
    entry_1d02c4(rdram, ctx, runtime);
}

void entry_1d0400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0400 inside entry_1d03f8 (0x1d03f8 - 0x1d0420)
    ctx->pc = 0x1d0400;
    entry_1d03f8(rdram, ctx, runtime);
}

void entry_1d0428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0428 inside entry_1d0420 (0x1d0420 - 0x1d0448)
    ctx->pc = 0x1d0428;
    entry_1d0420(rdram, ctx, runtime);
}

void entry_1d0450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0450 inside entry_1d0448 (0x1d0448 - 0x1d04cc)
    ctx->pc = 0x1d0450;
    entry_1d0448(rdram, ctx, runtime);
}

void entry_1d0488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0488 inside entry_1d0448 (0x1d0448 - 0x1d04cc)
    ctx->pc = 0x1d0488;
    entry_1d0448(rdram, ctx, runtime);
}

void entry_1d04b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d04b8 inside entry_1d0448 (0x1d0448 - 0x1d04cc)
    ctx->pc = 0x1d04b8;
    entry_1d0448(rdram, ctx, runtime);
}

void entry_1d04d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d04d0 inside entry_1d04cc (0x1d04cc - 0x1d04ec)
    ctx->pc = 0x1d04d0;
    entry_1d04cc(rdram, ctx, runtime);
}

void entry_1d0534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0534 inside entry_1d04f8 (0x1d04f8 - 0x1d0560)
    ctx->pc = 0x1d0534;
    entry_1d04f8(rdram, ctx, runtime);
}

void entry_1d0568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0568 inside entry_1d0560 (0x1d0560 - 0x1d057c)
    ctx->pc = 0x1d0568;
    entry_1d0560(rdram, ctx, runtime);
}

void entry_1d05c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d05c8 inside entry_1d05c0 (0x1d05c0 - 0x1d0614)
    ctx->pc = 0x1d05c8;
    entry_1d05c0(rdram, ctx, runtime);
}

void entry_1d05d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d05d4 inside entry_1d05c0 (0x1d05c0 - 0x1d0614)
    ctx->pc = 0x1d05d4;
    entry_1d05c0(rdram, ctx, runtime);
}

void entry_1d06cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d06cc inside entry_1d0674 (0x1d0674 - 0x1d0748)
    ctx->pc = 0x1d06cc;
    entry_1d0674(rdram, ctx, runtime);
}

void entry_1d06d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d06d4 inside entry_1d0674 (0x1d0674 - 0x1d0748)
    ctx->pc = 0x1d06d4;
    entry_1d0674(rdram, ctx, runtime);
}

void entry_1d072c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d072c inside entry_1d0674 (0x1d0674 - 0x1d0748)
    ctx->pc = 0x1d072c;
    entry_1d0674(rdram, ctx, runtime);
}

void entry_1d0738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0738 inside entry_1d0674 (0x1d0674 - 0x1d0748)
    ctx->pc = 0x1d0738;
    entry_1d0674(rdram, ctx, runtime);
}

void entry_1d077c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d077c inside entry_1d0764 (0x1d0764 - 0x1d0794)
    ctx->pc = 0x1d077c;
    entry_1d0764(rdram, ctx, runtime);
}

void entry_1d0830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0830 inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d0830;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d083c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d083c inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d083c;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d0880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0880 inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d0880;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d0890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0890 inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d0890;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d08d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d08d0 inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d08d0;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d090c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d090c inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d090c;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d0940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0940 inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d0940;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d0944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0944 inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d0944;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d0948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0948 inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d0948;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d0960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0960 inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d0960;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d0964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0964 inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d0964;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d0968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0968 inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d0968;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d09a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d09a4 inside entry_1d07dc (0x1d07dc - 0x1d09c8)
    ctx->pc = 0x1d09a4;
    entry_1d07dc(rdram, ctx, runtime);
}

void entry_1d09d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d09d8 inside entry_1d09c8 (0x1d09c8 - 0x1d09e8)
    ctx->pc = 0x1d09d8;
    entry_1d09c8(rdram, ctx, runtime);
}

void entry_1d0a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0a38 inside entry_1d0a0c (0x1d0a0c - 0x1d0a78)
    ctx->pc = 0x1d0a38;
    entry_1d0a0c(rdram, ctx, runtime);
}

void entry_1d0a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0a44 inside entry_1d0a0c (0x1d0a0c - 0x1d0a78)
    ctx->pc = 0x1d0a44;
    entry_1d0a0c(rdram, ctx, runtime);
}

void entry_1d0a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0a58 inside entry_1d0a0c (0x1d0a0c - 0x1d0a78)
    ctx->pc = 0x1d0a58;
    entry_1d0a0c(rdram, ctx, runtime);
}

void entry_1d0a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0a5c inside entry_1d0a0c (0x1d0a0c - 0x1d0a78)
    ctx->pc = 0x1d0a5c;
    entry_1d0a0c(rdram, ctx, runtime);
}

void entry_1d0a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0a7c inside entry_1d0a78 (0x1d0a78 - 0x1d0aa8)
    ctx->pc = 0x1d0a7c;
    entry_1d0a78(rdram, ctx, runtime);
}

void entry_1d0ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0ab0 inside entry_1d0aa8 (0x1d0aa8 - 0x1d0acc)
    ctx->pc = 0x1d0ab0;
    entry_1d0aa8(rdram, ctx, runtime);
}

void entry_1d0ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0ad0 inside entry_1d0acc (0x1d0acc - 0x1d0ae4)
    ctx->pc = 0x1d0ad0;
    entry_1d0acc(rdram, ctx, runtime);
}

void entry_1d0ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0ad4 inside entry_1d0acc (0x1d0acc - 0x1d0ae4)
    ctx->pc = 0x1d0ad4;
    entry_1d0acc(rdram, ctx, runtime);
}

void entry_1d0ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0ad8 inside entry_1d0acc (0x1d0acc - 0x1d0ae4)
    ctx->pc = 0x1d0ad8;
    entry_1d0acc(rdram, ctx, runtime);
}

void entry_1d0b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0b68 inside MatchJtXmgRail__FP2JTP3XMGP6ACTADJ (0x1d0b20 - 0x1d0b94)
    ctx->pc = 0x1d0b68;
    MatchJtXmgRail__FP2JTP3XMGP6ACTADJ(rdram, ctx, runtime);
}

void entry_1d0b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0b84 inside MatchJtXmgRail__FP2JTP3XMGP6ACTADJ (0x1d0b20 - 0x1d0b94)
    ctx->pc = 0x1d0b84;
    MatchJtXmgRail__FP2JTP3XMGP6ACTADJ(rdram, ctx, runtime);
}

void entry_1d0bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0bb4 inside entry_1d0bac (0x1d0bac - 0x1d0c08)
    ctx->pc = 0x1d0bb4;
    entry_1d0bac(rdram, ctx, runtime);
}

void entry_1d0bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0bd8 inside entry_1d0bac (0x1d0bac - 0x1d0c08)
    ctx->pc = 0x1d0bd8;
    entry_1d0bac(rdram, ctx, runtime);
}

void entry_1d0be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0be8 inside entry_1d0bac (0x1d0bac - 0x1d0c08)
    ctx->pc = 0x1d0be8;
    entry_1d0bac(rdram, ctx, runtime);
}

void entry_1d0bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0bec inside entry_1d0bac (0x1d0bac - 0x1d0c08)
    ctx->pc = 0x1d0bec;
    entry_1d0bac(rdram, ctx, runtime);
}

void entry_1d0c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0c50 inside entry_1d0c3c (0x1d0c3c - 0x1d0c78)
    ctx->pc = 0x1d0c50;
    entry_1d0c3c(rdram, ctx, runtime);
}

void entry_1d0cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0cbc inside UpdateJtHide__FP2JT (0x1d0c78 - 0x1d0d34)
    ctx->pc = 0x1d0cbc;
    UpdateJtHide__FP2JT(rdram, ctx, runtime);
}

void entry_1d0cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0cd0 inside UpdateJtHide__FP2JT (0x1d0c78 - 0x1d0d34)
    ctx->pc = 0x1d0cd0;
    UpdateJtHide__FP2JT(rdram, ctx, runtime);
}

void entry_1d0cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0cf8 inside UpdateJtHide__FP2JT (0x1d0c78 - 0x1d0d34)
    ctx->pc = 0x1d0cf8;
    UpdateJtHide__FP2JT(rdram, ctx, runtime);
}

void entry_1d0d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0d08 inside UpdateJtHide__FP2JT (0x1d0c78 - 0x1d0d34)
    ctx->pc = 0x1d0d08;
    UpdateJtHide__FP2JT(rdram, ctx, runtime);
}

void entry_1d0d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0d14 inside UpdateJtHide__FP2JT (0x1d0c78 - 0x1d0d34)
    ctx->pc = 0x1d0d14;
    UpdateJtHide__FP2JT(rdram, ctx, runtime);
}

void entry_1d0d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0d24 inside UpdateJtHide__FP2JT (0x1d0c78 - 0x1d0d34)
    ctx->pc = 0x1d0d24;
    UpdateJtHide__FP2JT(rdram, ctx, runtime);
}

void entry_1d0d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0d2c inside UpdateJtHide__FP2JT (0x1d0c78 - 0x1d0d34)
    ctx->pc = 0x1d0d2c;
    UpdateJtHide__FP2JT(rdram, ctx, runtime);
}

void entry_1d0da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0da0 inside entry_1d0d68 (0x1d0d68 - 0x1d0db8)
    ctx->pc = 0x1d0da0;
    entry_1d0d68(rdram, ctx, runtime);
}

void entry_1d0da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0da4 inside entry_1d0d68 (0x1d0d68 - 0x1d0db8)
    ctx->pc = 0x1d0da4;
    entry_1d0d68(rdram, ctx, runtime);
}

void entry_1d0dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0dac inside entry_1d0d68 (0x1d0d68 - 0x1d0db8)
    ctx->pc = 0x1d0dac;
    entry_1d0d68(rdram, ctx, runtime);
}

void entry_1d0db0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0db0 inside entry_1d0d68 (0x1d0d68 - 0x1d0db8)
    ctx->pc = 0x1d0db0;
    entry_1d0d68(rdram, ctx, runtime);
}

void entry_1d0dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0dc0 inside entry_1d0db8 (0x1d0db8 - 0x1d0e08)
    ctx->pc = 0x1d0dc0;
    entry_1d0db8(rdram, ctx, runtime);
}

void entry_1d0de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0de8 inside entry_1d0db8 (0x1d0db8 - 0x1d0e08)
    ctx->pc = 0x1d0de8;
    entry_1d0db8(rdram, ctx, runtime);
}

void entry_1d0e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0e10 inside entry_1d0e08 (0x1d0e08 - 0x1d0e20)
    ctx->pc = 0x1d0e10;
    entry_1d0e08(rdram, ctx, runtime);
}

void entry_1d0e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0e28 inside entry_1d0e20 (0x1d0e20 - 0x1d0e3c)
    ctx->pc = 0x1d0e28;
    entry_1d0e20(rdram, ctx, runtime);
}

void entry_1d0e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0e40 inside entry_1d0e3c (0x1d0e3c - 0x1d0e70)
    ctx->pc = 0x1d0e40;
    entry_1d0e3c(rdram, ctx, runtime);
}

void entry_1d0e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0e88 inside entry_1d0e80 (0x1d0e80 - 0x1d0ec4)
    ctx->pc = 0x1d0e88;
    entry_1d0e80(rdram, ctx, runtime);
}

void entry_1d0f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0f04 inside entry_1d0f00 (0x1d0f00 - 0x1d0f20)
    ctx->pc = 0x1d0f04;
    entry_1d0f00(rdram, ctx, runtime);
}

void entry_1d0f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0f08 inside entry_1d0f00 (0x1d0f00 - 0x1d0f20)
    ctx->pc = 0x1d0f08;
    entry_1d0f00(rdram, ctx, runtime);
}

void entry_1d0f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d0f8c inside entry_1d0f84 (0x1d0f84 - 0x1d0fac)
    ctx->pc = 0x1d0f8c;
    entry_1d0f84(rdram, ctx, runtime);
}

void entry_1d10b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d10b0 inside entry_1d1014 (0x1d1014 - 0x1d10f0)
    ctx->pc = 0x1d10b0;
    entry_1d1014(rdram, ctx, runtime);
}

void entry_1d110c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d110c inside entry_1d1104 (0x1d1104 - 0x1d118c)
    ctx->pc = 0x1d110c;
    entry_1d1104(rdram, ctx, runtime);
}

void entry_1d1114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1114 inside entry_1d1104 (0x1d1104 - 0x1d118c)
    ctx->pc = 0x1d1114;
    entry_1d1104(rdram, ctx, runtime);
}

void entry_1d1140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1140 inside entry_1d1104 (0x1d1104 - 0x1d118c)
    ctx->pc = 0x1d1140;
    entry_1d1104(rdram, ctx, runtime);
}

void entry_1d11c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d11c4 inside entry_1d11a0 (0x1d11a0 - 0x1d11dc)
    ctx->pc = 0x1d11c4;
    entry_1d11a0(rdram, ctx, runtime);
}

void entry_1d11c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d11c8 inside entry_1d11a0 (0x1d11a0 - 0x1d11dc)
    ctx->pc = 0x1d11c8;
    entry_1d11a0(rdram, ctx, runtime);
}

void entry_1d11e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d11e0 inside entry_1d11dc (0x1d11dc - 0x1d1200)
    ctx->pc = 0x1d11e0;
    entry_1d11dc(rdram, ctx, runtime);
}

void entry_1d1240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1240 inside SetJtHfdk__FP2JT4HFDK (0x1d1200 - 0x1d1260)
    ctx->pc = 0x1d1240;
    SetJtHfdk__FP2JT4HFDK(rdram, ctx, runtime);
}

void entry_1d1258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1258 inside SetJtHfdk__FP2JT4HFDK (0x1d1200 - 0x1d1260)
    ctx->pc = 0x1d1258;
    SetJtHfdk__FP2JT4HFDK(rdram, ctx, runtime);
}

void entry_1d1290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1290 inside ResetJtDynamicTunnel__FP2JT (0x1d1260 - 0x1d12e4)
    ctx->pc = 0x1d1290;
    ResetJtDynamicTunnel__FP2JT(rdram, ctx, runtime);
}

void entry_1d135c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d135c inside entry_1d1358 (0x1d1358 - 0x1d136c)
    ctx->pc = 0x1d135c;
    entry_1d1358(rdram, ctx, runtime);
}

void entry_1d1410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1410 inside entry_1d13ec (0x1d13ec - 0x1d1448)
    ctx->pc = 0x1d1410;
    entry_1d13ec(rdram, ctx, runtime);
}

void entry_1d1420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1420 inside entry_1d13ec (0x1d13ec - 0x1d1448)
    ctx->pc = 0x1d1420;
    entry_1d13ec(rdram, ctx, runtime);
}

void entry_1d14b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d14b0 inside entry_1d149c (0x1d149c - 0x1d14f0)
    ctx->pc = 0x1d14b0;
    entry_1d149c(rdram, ctx, runtime);
}

void entry_1d14d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d14d0 inside entry_1d149c (0x1d149c - 0x1d14f0)
    ctx->pc = 0x1d14d0;
    entry_1d149c(rdram, ctx, runtime);
}

void entry_1d14dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d14dc inside entry_1d149c (0x1d149c - 0x1d14f0)
    ctx->pc = 0x1d14dc;
    entry_1d149c(rdram, ctx, runtime);
}

void entry_1d14e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d14e0 inside entry_1d149c (0x1d149c - 0x1d14f0)
    ctx->pc = 0x1d14e0;
    entry_1d149c(rdram, ctx, runtime);
}

void entry_1d1518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1518 inside PostJtLoadPipe__FP2JT (0x1d14f0 - 0x1d1548)
    ctx->pc = 0x1d1518;
    PostJtLoadPipe__FP2JT(rdram, ctx, runtime);
}

void entry_1d170c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d170c inside entry_1d16b4 (0x1d16b4 - 0x1d17c4)
    ctx->pc = 0x1d170c;
    entry_1d16b4(rdram, ctx, runtime);
}

void entry_1d1718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1718 inside entry_1d16b4 (0x1d16b4 - 0x1d17c4)
    ctx->pc = 0x1d1718;
    entry_1d16b4(rdram, ctx, runtime);
}

void entry_1d1748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1748 inside entry_1d16b4 (0x1d16b4 - 0x1d17c4)
    ctx->pc = 0x1d1748;
    entry_1d16b4(rdram, ctx, runtime);
}

void entry_1d174c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d174c inside entry_1d16b4 (0x1d16b4 - 0x1d17c4)
    ctx->pc = 0x1d174c;
    entry_1d16b4(rdram, ctx, runtime);
}

void entry_1d1768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1768 inside entry_1d16b4 (0x1d16b4 - 0x1d17c4)
    ctx->pc = 0x1d1768;
    entry_1d16b4(rdram, ctx, runtime);
}

void entry_1d1778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1778 inside entry_1d16b4 (0x1d16b4 - 0x1d17c4)
    ctx->pc = 0x1d1778;
    entry_1d16b4(rdram, ctx, runtime);
}

void entry_1d17b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d17b8 inside entry_1d16b4 (0x1d16b4 - 0x1d17c4)
    ctx->pc = 0x1d17b8;
    entry_1d16b4(rdram, ctx, runtime);
}

void entry_1d17cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d17cc inside entry_1d17c4 (0x1d17c4 - 0x1d17f0)
    ctx->pc = 0x1d17cc;
    entry_1d17c4(rdram, ctx, runtime);
}

void entry_1d186c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d186c inside entry_1d1814 (0x1d1814 - 0x1d18cc)
    ctx->pc = 0x1d186c;
    entry_1d1814(rdram, ctx, runtime);
}

void entry_1d1878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1878 inside entry_1d1814 (0x1d1814 - 0x1d18cc)
    ctx->pc = 0x1d1878;
    entry_1d1814(rdram, ctx, runtime);
}

void entry_1d1884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1884 inside entry_1d1814 (0x1d1814 - 0x1d18cc)
    ctx->pc = 0x1d1884;
    entry_1d1814(rdram, ctx, runtime);
}

void entry_1d196c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d196c inside entry_1d1914 (0x1d1914 - 0x1d1a80)
    ctx->pc = 0x1d196c;
    entry_1d1914(rdram, ctx, runtime);
}

void entry_1d19d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d19d0 inside entry_1d1914 (0x1d1914 - 0x1d1a80)
    ctx->pc = 0x1d19d0;
    entry_1d1914(rdram, ctx, runtime);
}

void entry_1d19dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d19dc inside entry_1d1914 (0x1d1914 - 0x1d1a80)
    ctx->pc = 0x1d19dc;
    entry_1d1914(rdram, ctx, runtime);
}

void entry_1d1a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1a24 inside entry_1d1914 (0x1d1914 - 0x1d1a80)
    ctx->pc = 0x1d1a24;
    entry_1d1914(rdram, ctx, runtime);
}

void entry_1d1a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1a40 inside entry_1d1914 (0x1d1914 - 0x1d1a80)
    ctx->pc = 0x1d1a40;
    entry_1d1914(rdram, ctx, runtime);
}

void entry_1d1ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1ac4 inside entry_1d1aac (0x1d1aac - 0x1d1b20)
    ctx->pc = 0x1d1ac4;
    entry_1d1aac(rdram, ctx, runtime);
}

void entry_1d1b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1b2c inside entry_1d1b20 (0x1d1b20 - 0x1d1b5c)
    ctx->pc = 0x1d1b2c;
    entry_1d1b20(rdram, ctx, runtime);
}

void entry_1d1b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1b4c inside entry_1d1b20 (0x1d1b20 - 0x1d1b5c)
    ctx->pc = 0x1d1b4c;
    entry_1d1b20(rdram, ctx, runtime);
}

void entry_1d1c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1c3c inside entry_1d1c20 (0x1d1c20 - 0x1d1c74)
    ctx->pc = 0x1d1c3c;
    entry_1d1c20(rdram, ctx, runtime);
}

void entry_1d1c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1c48 inside entry_1d1c20 (0x1d1c20 - 0x1d1c74)
    ctx->pc = 0x1d1c48;
    entry_1d1c20(rdram, ctx, runtime);
}

void entry_1d1d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1d20 inside entry_1d1cc4 (0x1d1cc4 - 0x1d1e18)
    ctx->pc = 0x1d1d20;
    entry_1d1cc4(rdram, ctx, runtime);
}

void entry_1d1d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1d2c inside entry_1d1cc4 (0x1d1cc4 - 0x1d1e18)
    ctx->pc = 0x1d1d2c;
    entry_1d1cc4(rdram, ctx, runtime);
}

void entry_1d1d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1d84 inside entry_1d1cc4 (0x1d1cc4 - 0x1d1e18)
    ctx->pc = 0x1d1d84;
    entry_1d1cc4(rdram, ctx, runtime);
}

void entry_1d1d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1d8c inside entry_1d1cc4 (0x1d1cc4 - 0x1d1e18)
    ctx->pc = 0x1d1d8c;
    entry_1d1cc4(rdram, ctx, runtime);
}

void entry_1d1d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1d90 inside entry_1d1cc4 (0x1d1cc4 - 0x1d1e18)
    ctx->pc = 0x1d1d90;
    entry_1d1cc4(rdram, ctx, runtime);
}

void entry_1d1dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1dd0 inside entry_1d1cc4 (0x1d1cc4 - 0x1d1e18)
    ctx->pc = 0x1d1dd0;
    entry_1d1cc4(rdram, ctx, runtime);
}

void entry_1d1e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1e0c inside entry_1d1cc4 (0x1d1cc4 - 0x1d1e18)
    ctx->pc = 0x1d1e0c;
    entry_1d1cc4(rdram, ctx, runtime);
}

void entry_1d1e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1e10 inside entry_1d1cc4 (0x1d1cc4 - 0x1d1e18)
    ctx->pc = 0x1d1e10;
    entry_1d1cc4(rdram, ctx, runtime);
}

void entry_1d1e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1e20 inside entry_1d1e18 (0x1d1e18 - 0x1d1e40)
    ctx->pc = 0x1d1e20;
    entry_1d1e18(rdram, ctx, runtime);
}

void entry_1d1e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1e24 inside entry_1d1e18 (0x1d1e18 - 0x1d1e40)
    ctx->pc = 0x1d1e24;
    entry_1d1e18(rdram, ctx, runtime);
}

void entry_1d1e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1e58 inside entry_1d1e50 (0x1d1e50 - 0x1d1e74)
    ctx->pc = 0x1d1e58;
    entry_1d1e50(rdram, ctx, runtime);
}

void entry_1d1ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1ed8 inside entry_1d1eb0 (0x1d1eb0 - 0x1d1f10)
    ctx->pc = 0x1d1ed8;
    entry_1d1eb0(rdram, ctx, runtime);
}

void entry_1d1ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1ee8 inside entry_1d1eb0 (0x1d1eb0 - 0x1d1f10)
    ctx->pc = 0x1d1ee8;
    entry_1d1eb0(rdram, ctx, runtime);
}

void entry_1d1f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1f8c inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d1f8c;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d1ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1ff0 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d1ff0;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d1ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d1ffc inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d1ffc;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d201c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d201c inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d201c;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2034 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2034;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d204c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d204c inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d204c;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d20c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d20c4 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d20c4;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d20d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d20d4 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d20d4;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2124 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2124;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2134 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2134;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2170 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2170;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d21ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d21ac inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d21ac;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d21e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d21e0 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d21e0;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d21e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d21e4 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d21e4;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d21e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d21e8 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d21e8;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d220c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d220c inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d220c;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d221c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d221c inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d221c;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2228 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2228;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2230 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2230;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2234 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2234;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2240 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2240;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2248 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2248;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2294 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2294;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d22a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d22a0 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d22a0;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d22a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d22a8 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d22a8;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2338 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2338;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d2358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2358 inside entry_1d1f88 (0x1d1f88 - 0x1d2388)
    ctx->pc = 0x1d2358;
    entry_1d1f88(rdram, ctx, runtime);
}

void entry_1d23c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d23c4 inside entry_1d23a0 (0x1d23a0 - 0x1d2414)
    ctx->pc = 0x1d23c4;
    entry_1d23a0(rdram, ctx, runtime);
}

void entry_1d23d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d23d4 inside entry_1d23a0 (0x1d23a0 - 0x1d2414)
    ctx->pc = 0x1d23d4;
    entry_1d23a0(rdram, ctx, runtime);
}

void entry_1d23d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d23d8 inside entry_1d23a0 (0x1d23a0 - 0x1d2414)
    ctx->pc = 0x1d23d8;
    entry_1d23a0(rdram, ctx, runtime);
}

void entry_1d2428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2428 inside entry_1d2420 (0x1d2420 - 0x1d2450)
    ctx->pc = 0x1d2428;
    entry_1d2420(rdram, ctx, runtime);
}

void entry_1d2458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2458 inside entry_1d2450 (0x1d2450 - 0x1d24cc)
    ctx->pc = 0x1d2458;
    entry_1d2450(rdram, ctx, runtime);
}

void entry_1d2494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2494 inside entry_1d2450 (0x1d2450 - 0x1d24cc)
    ctx->pc = 0x1d2494;
    entry_1d2450(rdram, ctx, runtime);
}

void entry_1d24a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d24a4 inside entry_1d2450 (0x1d2450 - 0x1d24cc)
    ctx->pc = 0x1d24a4;
    entry_1d2450(rdram, ctx, runtime);
}

void entry_1d24d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d24d0 inside entry_1d24cc (0x1d24cc - 0x1d24dc)
    ctx->pc = 0x1d24d0;
    entry_1d24cc(rdram, ctx, runtime);
}

void entry_1d24e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d24e0 inside entry_1d24dc (0x1d24dc - 0x1d2518)
    ctx->pc = 0x1d24e0;
    entry_1d24dc(rdram, ctx, runtime);
}

void entry_1d2588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2588 inside UpdateJtInternalXpsPipe__FP2JT (0x1d2518 - 0x1d25e4)
    ctx->pc = 0x1d2588;
    UpdateJtInternalXpsPipe__FP2JT(rdram, ctx, runtime);
}

void entry_1d25a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d25a0 inside UpdateJtInternalXpsPipe__FP2JT (0x1d2518 - 0x1d25e4)
    ctx->pc = 0x1d25a0;
    UpdateJtInternalXpsPipe__FP2JT(rdram, ctx, runtime);
}

void entry_1d25a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d25a8 inside UpdateJtInternalXpsPipe__FP2JT (0x1d2518 - 0x1d25e4)
    ctx->pc = 0x1d25a8;
    UpdateJtInternalXpsPipe__FP2JT(rdram, ctx, runtime);
}

void entry_1d25c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d25c0 inside UpdateJtInternalXpsPipe__FP2JT (0x1d2518 - 0x1d25e4)
    ctx->pc = 0x1d25c0;
    UpdateJtInternalXpsPipe__FP2JT(rdram, ctx, runtime);
}

void entry_1d2668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2668 inside entry_1d2614 (0x1d2614 - 0x1d2694)
    ctx->pc = 0x1d2668;
    entry_1d2614(rdram, ctx, runtime);
}

void entry_1d2674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2674 inside entry_1d2614 (0x1d2614 - 0x1d2694)
    ctx->pc = 0x1d2674;
    entry_1d2614(rdram, ctx, runtime);
}

void entry_1d28b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d28b4 inside entry_1d28b0 (0x1d28b0 - 0x1d28d0)
    ctx->pc = 0x1d28b4;
    entry_1d28b0(rdram, ctx, runtime);
}

void entry_1d2950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2950 inside entry_1d294c (0x1d294c - 0x1d2964)
    ctx->pc = 0x1d2950;
    entry_1d294c(rdram, ctx, runtime);
}

void entry_1d2a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2a10 inside SetFsp__F3FSP (0x1d29c8 - 0x1d2a3c)
    ctx->pc = 0x1d2a10;
    SetFsp__F3FSP(rdram, ctx, runtime);
}

void entry_1d2a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2a44 inside entry_1d2a3c (0x1d2a3c - 0x1d2a68)
    ctx->pc = 0x1d2a44;
    entry_1d2a3c(rdram, ctx, runtime);
}

void entry_1d2a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2a84 inside entry_1d2a80 (0x1d2a80 - 0x1d2aa8)
    ctx->pc = 0x1d2a84;
    entry_1d2a80(rdram, ctx, runtime);
}

void entry_1d2ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2ae8 inside entry_1d2adc (0x1d2adc - 0x1d2b20)
    ctx->pc = 0x1d2ae8;
    entry_1d2adc(rdram, ctx, runtime);
}

void entry_1d2aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2aec inside entry_1d2adc (0x1d2adc - 0x1d2b20)
    ctx->pc = 0x1d2aec;
    entry_1d2adc(rdram, ctx, runtime);
}

void entry_1d2b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2b34 inside entry_1d2b20 (0x1d2b20 - 0x1d2b44)
    ctx->pc = 0x1d2b34;
    entry_1d2b20(rdram, ctx, runtime);
}

void entry_1d2b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2b3c inside entry_1d2b20 (0x1d2b20 - 0x1d2b44)
    ctx->pc = 0x1d2b3c;
    entry_1d2b20(rdram, ctx, runtime);
}

void entry_1d2b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2b98 inside entry_1d2b90 (0x1d2b90 - 0x1d2bb8)
    ctx->pc = 0x1d2b98;
    entry_1d2b90(rdram, ctx, runtime);
}

void entry_1d2c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2c30 inside entry_1d2c20 (0x1d2c20 - 0x1d2c8c)
    ctx->pc = 0x1d2c30;
    entry_1d2c20(rdram, ctx, runtime);
}

void entry_1d2c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2c34 inside entry_1d2c20 (0x1d2c20 - 0x1d2c8c)
    ctx->pc = 0x1d2c34;
    entry_1d2c20(rdram, ctx, runtime);
}

void entry_1d2cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2cec inside entry_1d2c8c (0x1d2c8c - 0x1d2dac)
    ctx->pc = 0x1d2cec;
    entry_1d2c8c(rdram, ctx, runtime);
}

void entry_1d2cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2cf4 inside entry_1d2c8c (0x1d2c8c - 0x1d2dac)
    ctx->pc = 0x1d2cf4;
    entry_1d2c8c(rdram, ctx, runtime);
}

void entry_1d2d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2d50 inside entry_1d2c8c (0x1d2c8c - 0x1d2dac)
    ctx->pc = 0x1d2d50;
    entry_1d2c8c(rdram, ctx, runtime);
}

void entry_1d2d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2d54 inside entry_1d2c8c (0x1d2c8c - 0x1d2dac)
    ctx->pc = 0x1d2d54;
    entry_1d2c8c(rdram, ctx, runtime);
}

void entry_1d2d58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2d58 inside entry_1d2c8c (0x1d2c8c - 0x1d2dac)
    ctx->pc = 0x1d2d58;
    entry_1d2c8c(rdram, ctx, runtime);
}

void entry_1d2d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2d70 inside entry_1d2c8c (0x1d2c8c - 0x1d2dac)
    ctx->pc = 0x1d2d70;
    entry_1d2c8c(rdram, ctx, runtime);
}

void entry_1d2dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2dc8 inside entry_1d2dc4 (0x1d2dc4 - 0x1d2e44)
    ctx->pc = 0x1d2dc8;
    entry_1d2dc4(rdram, ctx, runtime);
}

void entry_1d2e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2e0c inside entry_1d2dc4 (0x1d2dc4 - 0x1d2e44)
    ctx->pc = 0x1d2e0c;
    entry_1d2dc4(rdram, ctx, runtime);
}

void entry_1d2e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2e28 inside entry_1d2dc4 (0x1d2dc4 - 0x1d2e44)
    ctx->pc = 0x1d2e28;
    entry_1d2dc4(rdram, ctx, runtime);
}

void entry_1d2e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2e48 inside entry_1d2e44 (0x1d2e44 - 0x1d2ec0)
    ctx->pc = 0x1d2e48;
    entry_1d2e44(rdram, ctx, runtime);
}

void entry_1d2ec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2ec8 inside entry_1d2ec0 (0x1d2ec0 - 0x1d2edc)
    ctx->pc = 0x1d2ec8;
    entry_1d2ec0(rdram, ctx, runtime);
}

void entry_1d2ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2ee8 inside entry_1d2edc (0x1d2edc - 0x1d2f54)
    ctx->pc = 0x1d2ee8;
    entry_1d2edc(rdram, ctx, runtime);
}

void entry_1d2ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2ef0 inside entry_1d2edc (0x1d2edc - 0x1d2f54)
    ctx->pc = 0x1d2ef0;
    entry_1d2edc(rdram, ctx, runtime);
}

void entry_1d2ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2ef4 inside entry_1d2edc (0x1d2edc - 0x1d2f54)
    ctx->pc = 0x1d2ef4;
    entry_1d2edc(rdram, ctx, runtime);
}

void entry_1d2f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2f10 inside entry_1d2edc (0x1d2edc - 0x1d2f54)
    ctx->pc = 0x1d2f10;
    entry_1d2edc(rdram, ctx, runtime);
}

void entry_1d2f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d2f74 inside entry_1d2f6c (0x1d2f6c - 0x1d2f80)
    ctx->pc = 0x1d2f74;
    entry_1d2f6c(rdram, ctx, runtime);
}

void entry_1d3010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3010 inside entry_1d300c (0x1d300c - 0x1d3044)
    ctx->pc = 0x1d3010;
    entry_1d300c(rdram, ctx, runtime);
}

void entry_1d30d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d30d4 inside entry_1d30cc (0x1d30cc - 0x1d30e0)
    ctx->pc = 0x1d30d4;
    entry_1d30cc(rdram, ctx, runtime);
}

void entry_1d30e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d30e4 inside entry_1d30e0 (0x1d30e0 - 0x1d3100)
    ctx->pc = 0x1d30e4;
    entry_1d30e0(rdram, ctx, runtime);
}

void entry_1d30e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d30e8 inside entry_1d30e0 (0x1d30e0 - 0x1d3100)
    ctx->pc = 0x1d30e8;
    entry_1d30e0(rdram, ctx, runtime);
}

void entry_1d3138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3138 inside IRotatePowerUp__FP3JOYiiPi (0x1d3100 - 0x1d315c)
    ctx->pc = 0x1d3138;
    IRotatePowerUp__FP3JOYiiPi(rdram, ctx, runtime);
}

void entry_1d3140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3140 inside IRotatePowerUp__FP3JOYiiPi (0x1d3100 - 0x1d315c)
    ctx->pc = 0x1d3140;
    IRotatePowerUp__FP3JOYiiPi(rdram, ctx, runtime);
}

void entry_1d3168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3168 inside entry_1d315c (0x1d315c - 0x1d318c)
    ctx->pc = 0x1d3168;
    entry_1d315c(rdram, ctx, runtime);
}

void entry_1d3180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3180 inside entry_1d315c (0x1d315c - 0x1d318c)
    ctx->pc = 0x1d3180;
    entry_1d315c(rdram, ctx, runtime);
}

void entry_1d3184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3184 inside entry_1d315c (0x1d315c - 0x1d318c)
    ctx->pc = 0x1d3184;
    entry_1d315c(rdram, ctx, runtime);
}

void entry_1d31a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d31a8 inside entry_1d318c (0x1d318c - 0x1d31d0)
    ctx->pc = 0x1d31a8;
    entry_1d318c(rdram, ctx, runtime);
}

void entry_1d3220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3220 inside entry_1d3214 (0x1d3214 - 0x1d3250)
    ctx->pc = 0x1d3220;
    entry_1d3214(rdram, ctx, runtime);
}

void entry_1d3244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3244 inside entry_1d3214 (0x1d3214 - 0x1d3250)
    ctx->pc = 0x1d3244;
    entry_1d3214(rdram, ctx, runtime);
}

void entry_1d3254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3254 inside entry_1d3250 (0x1d3250 - 0x1d3290)
    ctx->pc = 0x1d3254;
    entry_1d3250(rdram, ctx, runtime);
}

void entry_1d325c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d325c inside entry_1d3250 (0x1d3250 - 0x1d3290)
    ctx->pc = 0x1d325c;
    entry_1d3250(rdram, ctx, runtime);
}

void entry_1d3270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3270 inside entry_1d3250 (0x1d3250 - 0x1d3290)
    ctx->pc = 0x1d3270;
    entry_1d3250(rdram, ctx, runtime);
}

void entry_1d3318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3318 inside entry_1d3308 (0x1d3308 - 0x1d3320)
    ctx->pc = 0x1d3318;
    entry_1d3308(rdram, ctx, runtime);
}

void entry_1d3414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3414 inside entry_1d340c (0x1d340c - 0x1d3450)
    ctx->pc = 0x1d3414;
    entry_1d340c(rdram, ctx, runtime);
}

void entry_1d3418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3418 inside entry_1d340c (0x1d340c - 0x1d3450)
    ctx->pc = 0x1d3418;
    entry_1d340c(rdram, ctx, runtime);
}

void entry_1d3454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3454 inside entry_1d3450 (0x1d3450 - 0x1d345c)
    ctx->pc = 0x1d3454;
    entry_1d3450(rdram, ctx, runtime);
}

void entry_1d34cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d34cc inside entry_1d34c8 (0x1d34c8 - 0x1d34e0)
    ctx->pc = 0x1d34cc;
    entry_1d34c8(rdram, ctx, runtime);
}

void entry_1d355c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d355c inside entry_1d3520 (0x1d3520 - 0x1d357c)
    ctx->pc = 0x1d355c;
    entry_1d3520(rdram, ctx, runtime);
}

void entry_1d3560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3560 inside entry_1d3520 (0x1d3520 - 0x1d357c)
    ctx->pc = 0x1d3560;
    entry_1d3520(rdram, ctx, runtime);
}

void entry_1d3590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3590 inside entry_1d3588 (0x1d3588 - 0x1d35a8)
    ctx->pc = 0x1d3590;
    entry_1d3588(rdram, ctx, runtime);
}

void entry_1d3660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3660 inside entry_1d3658 (0x1d3658 - 0x1d3668)
    ctx->pc = 0x1d3660;
    entry_1d3658(rdram, ctx, runtime);
}

void entry_1d366c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d366c inside entry_1d3668 (0x1d3668 - 0x1d3678)
    ctx->pc = 0x1d366c;
    entry_1d3668(rdram, ctx, runtime);
}

void entry_1d36d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d36d8 inside entry_1d36d4 (0x1d36d4 - 0x1d36f0)
    ctx->pc = 0x1d36d8;
    entry_1d36d4(rdram, ctx, runtime);
}

void entry_1d3738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3738 inside PostStepLoadRun__FP4STEPP5BLRUNPP6ASEGBL (0x1d36f0 - 0x1d3768)
    ctx->pc = 0x1d3738;
    PostStepLoadRun__FP4STEPP5BLRUNPP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d3798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3798 inside entry_1d3790 (0x1d3790 - 0x1d37d4)
    ctx->pc = 0x1d3798;
    entry_1d3790(rdram, ctx, runtime);
}

void entry_1d38ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d38ac inside entry_1d3890 (0x1d3890 - 0x1d38e8)
    ctx->pc = 0x1d38ac;
    entry_1d3890(rdram, ctx, runtime);
}

void entry_1d3900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3900 inside entry_1d38e8 (0x1d38e8 - 0x1d39a4)
    ctx->pc = 0x1d3900;
    entry_1d38e8(rdram, ctx, runtime);
}

void entry_1d394c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d394c inside entry_1d38e8 (0x1d38e8 - 0x1d39a4)
    ctx->pc = 0x1d394c;
    entry_1d38e8(rdram, ctx, runtime);
}

void entry_1d3964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3964 inside entry_1d38e8 (0x1d38e8 - 0x1d39a4)
    ctx->pc = 0x1d3964;
    entry_1d38e8(rdram, ctx, runtime);
}

void entry_1d396c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d396c inside entry_1d38e8 (0x1d38e8 - 0x1d39a4)
    ctx->pc = 0x1d396c;
    entry_1d38e8(rdram, ctx, runtime);
}

void entry_1d3978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3978 inside entry_1d38e8 (0x1d38e8 - 0x1d39a4)
    ctx->pc = 0x1d3978;
    entry_1d38e8(rdram, ctx, runtime);
}

void entry_1d397c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d397c inside entry_1d38e8 (0x1d38e8 - 0x1d39a4)
    ctx->pc = 0x1d397c;
    entry_1d38e8(rdram, ctx, runtime);
}

void entry_1d3990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3990 inside entry_1d38e8 (0x1d38e8 - 0x1d39a4)
    ctx->pc = 0x1d3990;
    entry_1d38e8(rdram, ctx, runtime);
}

void entry_1d39b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d39b0 inside entry_1d39a4 (0x1d39a4 - 0x1d39e0)
    ctx->pc = 0x1d39b0;
    entry_1d39a4(rdram, ctx, runtime);
}

void entry_1d39f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d39f0 inside CalculateBlrunV__FiP5BLRUNP4MRSGP6VECTOR (0x1d39e0 - 0x1d3a38)
    ctx->pc = 0x1d39f0;
    CalculateBlrunV__FiP5BLRUNP4MRSGP6VECTOR(rdram, ctx, runtime);
}

void entry_1d3a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3a30 inside CalculateBlrunV__FiP5BLRUNP4MRSGP6VECTOR (0x1d39e0 - 0x1d3a38)
    ctx->pc = 0x1d3a30;
    CalculateBlrunV__FiP5BLRUNP4MRSGP6VECTOR(rdram, ctx, runtime);
}

void entry_1d3c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3c38 inside entry_1d3bcc (0x1d3bcc - 0x1d3c48)
    ctx->pc = 0x1d3c38;
    entry_1d3bcc(rdram, ctx, runtime);
}

void entry_1d3c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3c40 inside entry_1d3bcc (0x1d3bcc - 0x1d3c48)
    ctx->pc = 0x1d3c40;
    entry_1d3bcc(rdram, ctx, runtime);
}

void entry_1d3ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3ce0 inside FReblendAbl2D__FiiiP2BLe (0x1d3c68 - 0x1d3cf0)
    ctx->pc = 0x1d3ce0;
    FReblendAbl2D__FiiiP2BLe(rdram, ctx, runtime);
}

void entry_1d3d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3d00 inside entry_1d3cf0 (0x1d3cf0 - 0x1d3d38)
    ctx->pc = 0x1d3d00;
    entry_1d3cf0(rdram, ctx, runtime);
}

void entry_1d3d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3d28 inside entry_1d3cf0 (0x1d3cf0 - 0x1d3d38)
    ctx->pc = 0x1d3d28;
    entry_1d3cf0(rdram, ctx, runtime);
}

void entry_1d3d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3d48 inside entry_1d3d38 (0x1d3d38 - 0x1d3e00)
    ctx->pc = 0x1d3d48;
    entry_1d3d38(rdram, ctx, runtime);
}

void entry_1d3d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3d68 inside entry_1d3d38 (0x1d3d38 - 0x1d3e00)
    ctx->pc = 0x1d3d68;
    entry_1d3d38(rdram, ctx, runtime);
}

void entry_1d3d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3d88 inside entry_1d3d38 (0x1d3d38 - 0x1d3e00)
    ctx->pc = 0x1d3d88;
    entry_1d3d38(rdram, ctx, runtime);
}

void entry_1d3db0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3db0 inside entry_1d3d38 (0x1d3d38 - 0x1d3e00)
    ctx->pc = 0x1d3db0;
    entry_1d3d38(rdram, ctx, runtime);
}

void entry_1d3dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3dbc inside entry_1d3d38 (0x1d3d38 - 0x1d3e00)
    ctx->pc = 0x1d3dbc;
    entry_1d3d38(rdram, ctx, runtime);
}

void entry_1d3dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3dcc inside entry_1d3d38 (0x1d3d38 - 0x1d3e00)
    ctx->pc = 0x1d3dcc;
    entry_1d3d38(rdram, ctx, runtime);
}

void entry_1d3e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3e4c inside AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA (0x1d3e00 - 0x1d3f3c)
    ctx->pc = 0x1d3e4c;
    AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA(rdram, ctx, runtime);
}

void entry_1d3e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3e98 inside AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA (0x1d3e00 - 0x1d3f3c)
    ctx->pc = 0x1d3e98;
    AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA(rdram, ctx, runtime);
}

void entry_1d3ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3ea8 inside AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA (0x1d3e00 - 0x1d3f3c)
    ctx->pc = 0x1d3ea8;
    AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA(rdram, ctx, runtime);
}

void entry_1d3eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3eac inside AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA (0x1d3e00 - 0x1d3f3c)
    ctx->pc = 0x1d3eac;
    AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA(rdram, ctx, runtime);
}

void entry_1d3ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3ec0 inside AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA (0x1d3e00 - 0x1d3f3c)
    ctx->pc = 0x1d3ec0;
    AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA(rdram, ctx, runtime);
}

void entry_1d3eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3eec inside AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA (0x1d3e00 - 0x1d3f3c)
    ctx->pc = 0x1d3eec;
    AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA(rdram, ctx, runtime);
}

void entry_1d3f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3f18 inside AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA (0x1d3e00 - 0x1d3f3c)
    ctx->pc = 0x1d3f18;
    AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA(rdram, ctx, runtime);
}

void entry_1d3f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3f94 inside entry_1d3f78 (0x1d3f78 - 0x1d3fc0)
    ctx->pc = 0x1d3f94;
    entry_1d3f78(rdram, ctx, runtime);
}

void entry_1d3fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3fe4 inside entry_1d3fd4 (0x1d3fd4 - 0x1d4004)
    ctx->pc = 0x1d3fe4;
    entry_1d3fd4(rdram, ctx, runtime);
}

void entry_1d3ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3ff4 inside entry_1d3fd4 (0x1d3fd4 - 0x1d4004)
    ctx->pc = 0x1d3ff4;
    entry_1d3fd4(rdram, ctx, runtime);
}

void entry_1d3ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d3ffc inside entry_1d3fd4 (0x1d3fd4 - 0x1d4004)
    ctx->pc = 0x1d3ffc;
    entry_1d3fd4(rdram, ctx, runtime);
}

void entry_1d40dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d40dc inside SetStepRunTarget__FP4STEPffP5BLRUNP6ASEGBL (0x1d40a0 - 0x1d4114)
    ctx->pc = 0x1d40dc;
    SetStepRunTarget__FP4STEPffP5BLRUNP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d40ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d40ec inside SetStepRunTarget__FP4STEPffP5BLRUNP6ASEGBL (0x1d40a0 - 0x1d4114)
    ctx->pc = 0x1d40ec;
    SetStepRunTarget__FP4STEPffP5BLRUNP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d4190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4190 inside PostJtLoadSidestep__FP2JTP4BLSSPP6ASEGBL (0x1d4148 - 0x1d41d8)
    ctx->pc = 0x1d4190;
    PostJtLoadSidestep__FP2JTP4BLSSPP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d423c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d423c inside entry_1d4204 (0x1d4204 - 0x1d426c)
    ctx->pc = 0x1d423c;
    entry_1d4204(rdram, ctx, runtime);
}

void entry_1d4240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4240 inside entry_1d4204 (0x1d4204 - 0x1d426c)
    ctx->pc = 0x1d4240;
    entry_1d4204(rdram, ctx, runtime);
}

void entry_1d42dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d42dc inside entry_1d42d8 (0x1d42d8 - 0x1d430c)
    ctx->pc = 0x1d42dc;
    entry_1d42d8(rdram, ctx, runtime);
}

void entry_1d43a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d43a4 inside AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL (0x1d4348 - 0x1d468c)
    ctx->pc = 0x1d43a4;
    AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d43b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d43b8 inside AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL (0x1d4348 - 0x1d468c)
    ctx->pc = 0x1d43b8;
    AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d43f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d43f8 inside AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL (0x1d4348 - 0x1d468c)
    ctx->pc = 0x1d43f8;
    AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d44f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d44f8 inside AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL (0x1d4348 - 0x1d468c)
    ctx->pc = 0x1d44f8;
    AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d4518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4518 inside AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL (0x1d4348 - 0x1d468c)
    ctx->pc = 0x1d4518;
    AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d4618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4618 inside AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL (0x1d4348 - 0x1d468c)
    ctx->pc = 0x1d4618;
    AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d4634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4634 inside AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL (0x1d4348 - 0x1d468c)
    ctx->pc = 0x1d4634;
    AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d4638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4638 inside AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL (0x1d4348 - 0x1d468c)
    ctx->pc = 0x1d4638;
    AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d4640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4640 inside AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL (0x1d4348 - 0x1d468c)
    ctx->pc = 0x1d4640;
    AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL(rdram, ctx, runtime);
}

void entry_1d46f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d46f8 inside entry_1d46cc (0x1d46cc - 0x1d4848)
    ctx->pc = 0x1d46f8;
    entry_1d46cc(rdram, ctx, runtime);
}

void entry_1d4720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4720 inside entry_1d46cc (0x1d46cc - 0x1d4848)
    ctx->pc = 0x1d4720;
    entry_1d46cc(rdram, ctx, runtime);
}

void entry_1d4730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4730 inside entry_1d46cc (0x1d46cc - 0x1d4848)
    ctx->pc = 0x1d4730;
    entry_1d46cc(rdram, ctx, runtime);
}

void entry_1d4748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4748 inside entry_1d46cc (0x1d46cc - 0x1d4848)
    ctx->pc = 0x1d4748;
    entry_1d46cc(rdram, ctx, runtime);
}

void entry_1d47b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d47b8 inside entry_1d46cc (0x1d46cc - 0x1d4848)
    ctx->pc = 0x1d47b8;
    entry_1d46cc(rdram, ctx, runtime);
}

void entry_1d4810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4810 inside entry_1d46cc (0x1d46cc - 0x1d4848)
    ctx->pc = 0x1d4810;
    entry_1d46cc(rdram, ctx, runtime);
}

void entry_1d4898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4898 inside entry_1d4880 (0x1d4880 - 0x1d48b8)
    ctx->pc = 0x1d4898;
    entry_1d4880(rdram, ctx, runtime);
}

void entry_1d48cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d48cc inside entry_1d48b8 (0x1d48b8 - 0x1d48e8)
    ctx->pc = 0x1d48cc;
    entry_1d48b8(rdram, ctx, runtime);
}

void entry_1d49f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d49f4 inside entry_1d49cc (0x1d49cc - 0x1d4a20)
    ctx->pc = 0x1d49f4;
    entry_1d49cc(rdram, ctx, runtime);
}

void entry_1d4a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4a64 inside entry_1d4a60 (0x1d4a60 - 0x1d4a78)
    ctx->pc = 0x1d4a64;
    entry_1d4a60(rdram, ctx, runtime);
}

void entry_1d4acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4acc inside UpdateJtZap__FP2JT (0x1d4a98 - 0x1d4ad8)
    ctx->pc = 0x1d4acc;
    UpdateJtZap__FP2JT(rdram, ctx, runtime);
}

void entry_1d4b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4b44 inside entry_1d4b08 (0x1d4b08 - 0x1d4b98)
    ctx->pc = 0x1d4b44;
    entry_1d4b08(rdram, ctx, runtime);
}

void entry_1d4c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4c08 inside entry_1d4bfc (0x1d4bfc - 0x1d4c18)
    ctx->pc = 0x1d4c08;
    entry_1d4bfc(rdram, ctx, runtime);
}

void entry_1d4c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4c10 inside entry_1d4bfc (0x1d4bfc - 0x1d4c18)
    ctx->pc = 0x1d4c10;
    entry_1d4bfc(rdram, ctx, runtime);
}

void entry_1d4c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4c20 inside entry_1d4c18 (0x1d4c18 - 0x1d4c30)
    ctx->pc = 0x1d4c20;
    entry_1d4c18(rdram, ctx, runtime);
}

void entry_1d4c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4c54 inside entry_1d4c4c (0x1d4c4c - 0x1d4c7c)
    ctx->pc = 0x1d4c54;
    entry_1d4c4c(rdram, ctx, runtime);
}

void entry_1d4c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4c80 inside entry_1d4c7c (0x1d4c7c - 0x1d4c90)
    ctx->pc = 0x1d4c80;
    entry_1d4c7c(rdram, ctx, runtime);
}

void entry_1d4c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4c84 inside entry_1d4c7c (0x1d4c7c - 0x1d4c90)
    ctx->pc = 0x1d4c84;
    entry_1d4c7c(rdram, ctx, runtime);
}

void entry_1d4ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4ccc inside entry_1d4cc4 (0x1d4cc4 - 0x1d4ce8)
    ctx->pc = 0x1d4ccc;
    entry_1d4cc4(rdram, ctx, runtime);
}

void entry_1d4cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4cf0 inside entry_1d4ce8 (0x1d4ce8 - 0x1d4cf8)
    ctx->pc = 0x1d4cf0;
    entry_1d4ce8(rdram, ctx, runtime);
}

void entry_1d4cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4cfc inside entry_1d4cf8 (0x1d4cf8 - 0x1d4d08)
    ctx->pc = 0x1d4cfc;
    entry_1d4cf8(rdram, ctx, runtime);
}

void entry_1d4d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4d88 inside entry_1d4d80 (0x1d4d80 - 0x1d4de4)
    ctx->pc = 0x1d4d88;
    entry_1d4d80(rdram, ctx, runtime);
}

void entry_1d4e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4e10 inside entry_1d4de4 (0x1d4de4 - 0x1d4e18)
    ctx->pc = 0x1d4e10;
    entry_1d4de4(rdram, ctx, runtime);
}

void entry_1d4e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4e20 inside entry_1d4e18 (0x1d4e18 - 0x1d4e28)
    ctx->pc = 0x1d4e20;
    entry_1d4e18(rdram, ctx, runtime);
}

void entry_1d4e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4e2c inside entry_1d4e28 (0x1d4e28 - 0x1d4e50)
    ctx->pc = 0x1d4e2c;
    entry_1d4e28(rdram, ctx, runtime);
}

void entry_1d4e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4e3c inside entry_1d4e28 (0x1d4e28 - 0x1d4e50)
    ctx->pc = 0x1d4e3c;
    entry_1d4e28(rdram, ctx, runtime);
}

void entry_1d4e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4e40 inside entry_1d4e28 (0x1d4e28 - 0x1d4e50)
    ctx->pc = 0x1d4e40;
    entry_1d4e28(rdram, ctx, runtime);
}

void entry_1d4e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4e68 inside entry_1d4e50 (0x1d4e50 - 0x1d4e74)
    ctx->pc = 0x1d4e68;
    entry_1d4e50(rdram, ctx, runtime);
}

void entry_1d4e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4e6c inside entry_1d4e50 (0x1d4e50 - 0x1d4e74)
    ctx->pc = 0x1d4e6c;
    entry_1d4e50(rdram, ctx, runtime);
}

void entry_1d4efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4efc inside entry_1d4ef4 (0x1d4ef4 - 0x1d4f0c)
    ctx->pc = 0x1d4efc;
    entry_1d4ef4(rdram, ctx, runtime);
}

void entry_1d4f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4f10 inside entry_1d4f0c (0x1d4f0c - 0x1d4f1c)
    ctx->pc = 0x1d4f10;
    entry_1d4f0c(rdram, ctx, runtime);
}

void entry_1d4f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4f44 inside entry_1d4f3c (0x1d4f3c - 0x1d4f54)
    ctx->pc = 0x1d4f44;
    entry_1d4f3c(rdram, ctx, runtime);
}

void entry_1d4f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4f58 inside entry_1d4f54 (0x1d4f54 - 0x1d4fac)
    ctx->pc = 0x1d4f58;
    entry_1d4f54(rdram, ctx, runtime);
}

void entry_1d4ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d4ff0 inside entry_1d4fbc (0x1d4fbc - 0x1d5018)
    ctx->pc = 0x1d4ff0;
    entry_1d4fbc(rdram, ctx, runtime);
}

void entry_1d5000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5000 inside entry_1d4fbc (0x1d4fbc - 0x1d5018)
    ctx->pc = 0x1d5000;
    entry_1d4fbc(rdram, ctx, runtime);
}

void entry_1d504c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d504c inside entry_1d502c (0x1d502c - 0x1d5068)
    ctx->pc = 0x1d504c;
    entry_1d502c(rdram, ctx, runtime);
}

void entry_1d5054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5054 inside entry_1d502c (0x1d502c - 0x1d5068)
    ctx->pc = 0x1d5054;
    entry_1d502c(rdram, ctx, runtime);
}

void entry_1d5058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5058 inside entry_1d502c (0x1d502c - 0x1d5068)
    ctx->pc = 0x1d5058;
    entry_1d502c(rdram, ctx, runtime);
}

void entry_1d5060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5060 inside entry_1d502c (0x1d502c - 0x1d5068)
    ctx->pc = 0x1d5060;
    entry_1d502c(rdram, ctx, runtime);
}

void entry_1d509c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d509c inside entry_1d5094 (0x1d5094 - 0x1d50b4)
    ctx->pc = 0x1d509c;
    entry_1d5094(rdram, ctx, runtime);
}

void entry_1d50a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d50a8 inside entry_1d5094 (0x1d5094 - 0x1d50b4)
    ctx->pc = 0x1d50a8;
    entry_1d5094(rdram, ctx, runtime);
}

void entry_1d50f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d50f0 inside entry_1d50dc (0x1d50dc - 0x1d50fc)
    ctx->pc = 0x1d50f0;
    entry_1d50dc(rdram, ctx, runtime);
}

void entry_1d5120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5120 inside entry_1d5118 (0x1d5118 - 0x1d5130)
    ctx->pc = 0x1d5120;
    entry_1d5118(rdram, ctx, runtime);
}

void entry_1d5128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5128 inside entry_1d5118 (0x1d5118 - 0x1d5130)
    ctx->pc = 0x1d5128;
    entry_1d5118(rdram, ctx, runtime);
}

void entry_1d5148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5148 inside entry_1d5140 (0x1d5140 - 0x1d5154)
    ctx->pc = 0x1d5148;
    entry_1d5140(rdram, ctx, runtime);
}

void entry_1d5158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5158 inside entry_1d5154 (0x1d5154 - 0x1d5180)
    ctx->pc = 0x1d5158;
    entry_1d5154(rdram, ctx, runtime);
}

void entry_1d5184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5184 inside entry_1d5180 (0x1d5180 - 0x1d51a0)
    ctx->pc = 0x1d5184;
    entry_1d5180(rdram, ctx, runtime);
}

void entry_1d5244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5244 inside entry_1d523c (0x1d523c - 0x1d524c)
    ctx->pc = 0x1d5244;
    entry_1d523c(rdram, ctx, runtime);
}

void entry_1d5294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5294 inside entry_1d528c (0x1d528c - 0x1d52a0)
    ctx->pc = 0x1d5294;
    entry_1d528c(rdram, ctx, runtime);
}

void entry_1d52a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d52a8 inside entry_1d52a0 (0x1d52a0 - 0x1d52b0)
    ctx->pc = 0x1d52a8;
    entry_1d52a0(rdram, ctx, runtime);
}

void entry_1d52dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d52dc inside entry_1d52d4 (0x1d52d4 - 0x1d52e8)
    ctx->pc = 0x1d52dc;
    entry_1d52d4(rdram, ctx, runtime);
}

void entry_1d52ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d52ec inside entry_1d52e8 (0x1d52e8 - 0x1d5384)
    ctx->pc = 0x1d52ec;
    entry_1d52e8(rdram, ctx, runtime);
}

void entry_1d5344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5344 inside entry_1d52e8 (0x1d52e8 - 0x1d5384)
    ctx->pc = 0x1d5344;
    entry_1d52e8(rdram, ctx, runtime);
}

void entry_1d5354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5354 inside entry_1d52e8 (0x1d52e8 - 0x1d5384)
    ctx->pc = 0x1d5354;
    entry_1d52e8(rdram, ctx, runtime);
}

void entry_1d5388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5388 inside entry_1d5384 (0x1d5384 - 0x1d5398)
    ctx->pc = 0x1d5388;
    entry_1d5384(rdram, ctx, runtime);
}

void entry_1d544c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d544c inside entry_1d5444 (0x1d5444 - 0x1d5458)
    ctx->pc = 0x1d544c;
    entry_1d5444(rdram, ctx, runtime);
}

void entry_1d545c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d545c inside entry_1d5458 (0x1d5458 - 0x1d5468)
    ctx->pc = 0x1d545c;
    entry_1d5458(rdram, ctx, runtime);
}

void entry_1d54c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d54c4 inside entry_1d54bc (0x1d54bc - 0x1d54d0)
    ctx->pc = 0x1d54c4;
    entry_1d54bc(rdram, ctx, runtime);
}

void entry_1d54d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d54d4 inside entry_1d54d0 (0x1d54d0 - 0x1d54e0)
    ctx->pc = 0x1d54d4;
    entry_1d54d0(rdram, ctx, runtime);
}

void entry_1d5504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5504 inside FUN_001d54e0 (0x1d54e0 - 0x1d55ac)
    ctx->pc = 0x1d5504;
    FUN_001d54e0(rdram, ctx, runtime);
}

void entry_1d5598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5598 inside FUN_001d54e0 (0x1d54e0 - 0x1d55ac)
    ctx->pc = 0x1d5598;
    FUN_001d54e0(rdram, ctx, runtime);
}

void entry_1d55b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d55b4 inside entry_1d55ac (0x1d55ac - 0x1d55fc)
    ctx->pc = 0x1d55b4;
    entry_1d55ac(rdram, ctx, runtime);
}

void entry_1d55c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d55c0 inside entry_1d55ac (0x1d55ac - 0x1d55fc)
    ctx->pc = 0x1d55c0;
    entry_1d55ac(rdram, ctx, runtime);
}

void entry_1d5604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5604 inside entry_1d55fc (0x1d55fc - 0x1d5620)
    ctx->pc = 0x1d5604;
    entry_1d55fc(rdram, ctx, runtime);
}

void entry_1d560c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d560c inside entry_1d55fc (0x1d55fc - 0x1d5620)
    ctx->pc = 0x1d560c;
    entry_1d55fc(rdram, ctx, runtime);
}

void entry_1d5610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5610 inside entry_1d55fc (0x1d55fc - 0x1d5620)
    ctx->pc = 0x1d5610;
    entry_1d55fc(rdram, ctx, runtime);
}

void entry_1d566c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d566c inside SgnCmpSpkn__FPCvT0 (0x1d5650 - 0x1d5678)
    ctx->pc = 0x1d566c;
    SgnCmpSpkn__FPCvT0(rdram, ctx, runtime);
}

void entry_1d5720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5720 inside entry_1d56ec (0x1d56ec - 0x1d57bc)
    ctx->pc = 0x1d5720;
    entry_1d56ec(rdram, ctx, runtime);
}

void entry_1d5748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5748 inside entry_1d56ec (0x1d56ec - 0x1d57bc)
    ctx->pc = 0x1d5748;
    entry_1d56ec(rdram, ctx, runtime);
}

void entry_1d57dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d57dc inside entry_1d57bc (0x1d57bc - 0x1d5874)
    ctx->pc = 0x1d57dc;
    entry_1d57bc(rdram, ctx, runtime);
}

void entry_1d57e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d57e8 inside entry_1d57bc (0x1d57bc - 0x1d5874)
    ctx->pc = 0x1d57e8;
    entry_1d57bc(rdram, ctx, runtime);
}

void entry_1d57fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d57fc inside entry_1d57bc (0x1d57bc - 0x1d5874)
    ctx->pc = 0x1d57fc;
    entry_1d57bc(rdram, ctx, runtime);
}

void entry_1d5850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5850 inside entry_1d57bc (0x1d57bc - 0x1d5874)
    ctx->pc = 0x1d5850;
    entry_1d57bc(rdram, ctx, runtime);
}

void entry_1d5884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5884 inside entry_1d5874 (0x1d5874 - 0x1d58a0)
    ctx->pc = 0x1d5884;
    entry_1d5874(rdram, ctx, runtime);
}

void entry_1d58b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d58b8 inside entry_1d58a0 (0x1d58a0 - 0x1d5acc)
    ctx->pc = 0x1d58b8;
    entry_1d58a0(rdram, ctx, runtime);
}

void entry_1d58e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d58e0 inside entry_1d58a0 (0x1d58a0 - 0x1d5acc)
    ctx->pc = 0x1d58e0;
    entry_1d58a0(rdram, ctx, runtime);
}

void entry_1d5934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5934 inside entry_1d58a0 (0x1d58a0 - 0x1d5acc)
    ctx->pc = 0x1d5934;
    entry_1d58a0(rdram, ctx, runtime);
}

void entry_1d5938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5938 inside entry_1d58a0 (0x1d58a0 - 0x1d5acc)
    ctx->pc = 0x1d5938;
    entry_1d58a0(rdram, ctx, runtime);
}

void entry_1d5954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5954 inside entry_1d58a0 (0x1d58a0 - 0x1d5acc)
    ctx->pc = 0x1d5954;
    entry_1d58a0(rdram, ctx, runtime);
}

void entry_1d5990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5990 inside entry_1d58a0 (0x1d58a0 - 0x1d5acc)
    ctx->pc = 0x1d5990;
    entry_1d58a0(rdram, ctx, runtime);
}

void entry_1d59c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d59c0 inside entry_1d58a0 (0x1d58a0 - 0x1d5acc)
    ctx->pc = 0x1d59c0;
    entry_1d58a0(rdram, ctx, runtime);
}

void entry_1d5a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5a10 inside entry_1d58a0 (0x1d58a0 - 0x1d5acc)
    ctx->pc = 0x1d5a10;
    entry_1d58a0(rdram, ctx, runtime);
}

void entry_1d5a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5a84 inside entry_1d58a0 (0x1d58a0 - 0x1d5acc)
    ctx->pc = 0x1d5a84;
    entry_1d58a0(rdram, ctx, runtime);
}

void entry_1d5a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5a90 inside entry_1d58a0 (0x1d58a0 - 0x1d5acc)
    ctx->pc = 0x1d5a90;
    entry_1d58a0(rdram, ctx, runtime);
}

void entry_1d5aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5aa8 inside entry_1d58a0 (0x1d58a0 - 0x1d5acc)
    ctx->pc = 0x1d5aa8;
    entry_1d58a0(rdram, ctx, runtime);
}

void entry_1d5ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5ae0 inside entry_1d5ad4 (0x1d5ad4 - 0x1d5afc)
    ctx->pc = 0x1d5ae0;
    entry_1d5ad4(rdram, ctx, runtime);
}

void entry_1d5b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5b28 inside entry_1d5afc (0x1d5afc - 0x1d5b54)
    ctx->pc = 0x1d5b28;
    entry_1d5afc(rdram, ctx, runtime);
}

void entry_1d5b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5b98 inside entry_1d5b54 (0x1d5b54 - 0x1d5bfc)
    ctx->pc = 0x1d5b98;
    entry_1d5b54(rdram, ctx, runtime);
}

void entry_1d5c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5c08 inside entry_1d5bfc (0x1d5bfc - 0x1d5c30)
    ctx->pc = 0x1d5c08;
    entry_1d5bfc(rdram, ctx, runtime);
}

void entry_1d5c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5c0c inside entry_1d5bfc (0x1d5bfc - 0x1d5c30)
    ctx->pc = 0x1d5c0c;
    entry_1d5bfc(rdram, ctx, runtime);
}

void entry_1d5c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5c14 inside entry_1d5bfc (0x1d5bfc - 0x1d5c30)
    ctx->pc = 0x1d5c14;
    entry_1d5bfc(rdram, ctx, runtime);
}

void entry_1d5c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5c80 inside entry_1d5c70 (0x1d5c70 - 0x1d5cfc)
    ctx->pc = 0x1d5c80;
    entry_1d5c70(rdram, ctx, runtime);
}

void entry_1d5cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5cd0 inside entry_1d5c70 (0x1d5c70 - 0x1d5cfc)
    ctx->pc = 0x1d5cd0;
    entry_1d5c70(rdram, ctx, runtime);
}

void entry_1d5d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5d48 inside entry_1d5d20 (0x1d5d20 - 0x1d5de8)
    ctx->pc = 0x1d5d48;
    entry_1d5d20(rdram, ctx, runtime);
}

void entry_1d5d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5d88 inside entry_1d5d20 (0x1d5d20 - 0x1d5de8)
    ctx->pc = 0x1d5d88;
    entry_1d5d20(rdram, ctx, runtime);
}

void entry_1d5da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5da0 inside entry_1d5d20 (0x1d5d20 - 0x1d5de8)
    ctx->pc = 0x1d5da0;
    entry_1d5d20(rdram, ctx, runtime);
}

void entry_1d5db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5db8 inside entry_1d5d20 (0x1d5d20 - 0x1d5de8)
    ctx->pc = 0x1d5db8;
    entry_1d5d20(rdram, ctx, runtime);
}

void entry_1d5dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5dd4 inside entry_1d5d20 (0x1d5d20 - 0x1d5de8)
    ctx->pc = 0x1d5dd4;
    entry_1d5d20(rdram, ctx, runtime);
}

void entry_1d5e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5e04 inside entry_1d5de8 (0x1d5de8 - 0x1d5ed8)
    ctx->pc = 0x1d5e04;
    entry_1d5de8(rdram, ctx, runtime);
}

void entry_1d5e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5e38 inside entry_1d5de8 (0x1d5de8 - 0x1d5ed8)
    ctx->pc = 0x1d5e38;
    entry_1d5de8(rdram, ctx, runtime);
}

void entry_1d5f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5f28 inside entry_1d5f1c (0x1d5f1c - 0x1d5f40)
    ctx->pc = 0x1d5f28;
    entry_1d5f1c(rdram, ctx, runtime);
}

void entry_1d5f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d5f38 inside entry_1d5f1c (0x1d5f1c - 0x1d5f40)
    ctx->pc = 0x1d5f38;
    entry_1d5f1c(rdram, ctx, runtime);
}

void entry_1d6054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6054 inside entry_1d5ff0 (0x1d5ff0 - 0x1d6064)
    ctx->pc = 0x1d6054;
    entry_1d5ff0(rdram, ctx, runtime);
}

void entry_1d6174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6174 inside entry_1d60f8 (0x1d60f8 - 0x1d617c)
    ctx->pc = 0x1d6174;
    entry_1d60f8(rdram, ctx, runtime);
}

void entry_1d6274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6274 inside entry_1d6210 (0x1d6210 - 0x1d6284)
    ctx->pc = 0x1d6274;
    entry_1d6210(rdram, ctx, runtime);
}

void entry_1d6338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6338 inside entry_1d6328 (0x1d6328 - 0x1d6344)
    ctx->pc = 0x1d6338;
    entry_1d6328(rdram, ctx, runtime);
}

void entry_1d63a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d63a4 inside entry_1d6344 (0x1d6344 - 0x1d63d4)
    ctx->pc = 0x1d63a4;
    entry_1d6344(rdram, ctx, runtime);
}

void entry_1d63b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d63b8 inside entry_1d6344 (0x1d6344 - 0x1d63d4)
    ctx->pc = 0x1d63b8;
    entry_1d6344(rdram, ctx, runtime);
}

void entry_1d63c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d63c0 inside entry_1d6344 (0x1d6344 - 0x1d63d4)
    ctx->pc = 0x1d63c0;
    entry_1d6344(rdram, ctx, runtime);
}

void entry_1d63c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d63c8 inside entry_1d6344 (0x1d6344 - 0x1d63d4)
    ctx->pc = 0x1d63c8;
    entry_1d6344(rdram, ctx, runtime);
}

void entry_1d63cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d63cc inside entry_1d6344 (0x1d6344 - 0x1d63d4)
    ctx->pc = 0x1d63cc;
    entry_1d6344(rdram, ctx, runtime);
}

void entry_1d6414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6414 inside entry_1d63d4 (0x1d63d4 - 0x1d6438)
    ctx->pc = 0x1d6414;
    entry_1d63d4(rdram, ctx, runtime);
}

void entry_1d641c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d641c inside entry_1d63d4 (0x1d63d4 - 0x1d6438)
    ctx->pc = 0x1d641c;
    entry_1d63d4(rdram, ctx, runtime);
}

void entry_1d6494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6494 inside entry_1d6438 (0x1d6438 - 0x1d65c0)
    ctx->pc = 0x1d6494;
    entry_1d6438(rdram, ctx, runtime);
}

void entry_1d64d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d64d8 inside entry_1d6438 (0x1d6438 - 0x1d65c0)
    ctx->pc = 0x1d64d8;
    entry_1d6438(rdram, ctx, runtime);
}

void entry_1d64e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d64e8 inside entry_1d6438 (0x1d6438 - 0x1d65c0)
    ctx->pc = 0x1d64e8;
    entry_1d6438(rdram, ctx, runtime);
}

void entry_1d659c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d659c inside entry_1d6438 (0x1d6438 - 0x1d65c0)
    ctx->pc = 0x1d659c;
    entry_1d6438(rdram, ctx, runtime);
}

void entry_1d65b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d65b4 inside entry_1d6438 (0x1d6438 - 0x1d65c0)
    ctx->pc = 0x1d65b4;
    entry_1d6438(rdram, ctx, runtime);
}

void entry_1d6600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6600 inside JthsCurrentJt__FP2JT (0x1d65d8 - 0x1d6608)
    ctx->pc = 0x1d6600;
    JthsCurrentJt__FP2JT(rdram, ctx, runtime);
}

void entry_1d6634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6634 inside entry_1d662c (0x1d662c - 0x1d6648)
    ctx->pc = 0x1d6634;
    entry_1d662c(rdram, ctx, runtime);
}

void entry_1d6650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6650 inside entry_1d6648 (0x1d6648 - 0x1d6680)
    ctx->pc = 0x1d6650;
    entry_1d6648(rdram, ctx, runtime);
}

void entry_1d6694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6694 inside entry_1d6690 (0x1d6690 - 0x1d66a8)
    ctx->pc = 0x1d6694;
    entry_1d6690(rdram, ctx, runtime);
}

void entry_1d6724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6724 inside UpdateJtWater__FP2JT (0x1d66a8 - 0x1d6764)
    ctx->pc = 0x1d6724;
    UpdateJtWater__FP2JT(rdram, ctx, runtime);
}

void entry_1d6738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6738 inside UpdateJtWater__FP2JT (0x1d66a8 - 0x1d6764)
    ctx->pc = 0x1d6738;
    UpdateJtWater__FP2JT(rdram, ctx, runtime);
}

void entry_1d67a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d67a0 inside entry_1d6764 (0x1d6764 - 0x1d67b0)
    ctx->pc = 0x1d67a0;
    entry_1d6764(rdram, ctx, runtime);
}

void entry_1d67b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d67b4 inside entry_1d67b0 (0x1d67b0 - 0x1d6808)
    ctx->pc = 0x1d67b4;
    entry_1d67b0(rdram, ctx, runtime);
}

void entry_1d67fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d67fc inside entry_1d67b0 (0x1d67b0 - 0x1d6808)
    ctx->pc = 0x1d67fc;
    entry_1d67b0(rdram, ctx, runtime);
}

void entry_1d6868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6868 inside entry_1d684c (0x1d684c - 0x1d68ac)
    ctx->pc = 0x1d6868;
    entry_1d684c(rdram, ctx, runtime);
}

void entry_1d68c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d68c8 inside entry_1d68c0 (0x1d68c0 - 0x1d68fc)
    ctx->pc = 0x1d68c8;
    entry_1d68c0(rdram, ctx, runtime);
}

void entry_1d68d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d68d0 inside entry_1d68c0 (0x1d68c0 - 0x1d68fc)
    ctx->pc = 0x1d68d0;
    entry_1d68c0(rdram, ctx, runtime);
}

void entry_1d68e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d68e8 inside entry_1d68c0 (0x1d68c0 - 0x1d68fc)
    ctx->pc = 0x1d68e8;
    entry_1d68c0(rdram, ctx, runtime);
}

void entry_1d6948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6948 inside entry_1d6924 (0x1d6924 - 0x1d69bc)
    ctx->pc = 0x1d6948;
    entry_1d6924(rdram, ctx, runtime);
}

void entry_1d6950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6950 inside entry_1d6924 (0x1d6924 - 0x1d69bc)
    ctx->pc = 0x1d6950;
    entry_1d6924(rdram, ctx, runtime);
}

void entry_1d6958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6958 inside entry_1d6924 (0x1d6924 - 0x1d69bc)
    ctx->pc = 0x1d6958;
    entry_1d6924(rdram, ctx, runtime);
}

void entry_1d69ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d69ac inside entry_1d6924 (0x1d6924 - 0x1d69bc)
    ctx->pc = 0x1d69ac;
    entry_1d6924(rdram, ctx, runtime);
}

void entry_1d69c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d69c4 inside entry_1d69bc (0x1d69bc - 0x1d6a18)
    ctx->pc = 0x1d69c4;
    entry_1d69bc(rdram, ctx, runtime);
}

void entry_1d69d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d69d0 inside entry_1d69bc (0x1d69bc - 0x1d6a18)
    ctx->pc = 0x1d69d0;
    entry_1d69bc(rdram, ctx, runtime);
}

void entry_1d69d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d69d4 inside entry_1d69bc (0x1d69bc - 0x1d6a18)
    ctx->pc = 0x1d69d4;
    entry_1d69bc(rdram, ctx, runtime);
}

void entry_1d69e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d69e0 inside entry_1d69bc (0x1d69bc - 0x1d6a18)
    ctx->pc = 0x1d69e0;
    entry_1d69bc(rdram, ctx, runtime);
}

void entry_1d69e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d69e4 inside entry_1d69bc (0x1d69bc - 0x1d6a18)
    ctx->pc = 0x1d69e4;
    entry_1d69bc(rdram, ctx, runtime);
}

void entry_1d6a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6a78 inside entry_1d6a64 (0x1d6a64 - 0x1d6ae0)
    ctx->pc = 0x1d6a78;
    entry_1d6a64(rdram, ctx, runtime);
}

void entry_1d6a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6a88 inside entry_1d6a64 (0x1d6a64 - 0x1d6ae0)
    ctx->pc = 0x1d6a88;
    entry_1d6a64(rdram, ctx, runtime);
}

void entry_1d6afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6afc inside entry_1d6ae0 (0x1d6ae0 - 0x1d6b18)
    ctx->pc = 0x1d6afc;
    entry_1d6ae0(rdram, ctx, runtime);
}

void entry_1d6b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6b00 inside entry_1d6ae0 (0x1d6ae0 - 0x1d6b18)
    ctx->pc = 0x1d6b00;
    entry_1d6ae0(rdram, ctx, runtime);
}

void entry_1d6b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6b60 inside AddJtWaterAcceleration__FP2JTP5WATERf (0x1d6b18 - 0x1d6ba0)
    ctx->pc = 0x1d6b60;
    AddJtWaterAcceleration__FP2JTP5WATERf(rdram, ctx, runtime);
}

void entry_1d6b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6b7c inside AddJtWaterAcceleration__FP2JTP5WATERf (0x1d6b18 - 0x1d6ba0)
    ctx->pc = 0x1d6b7c;
    AddJtWaterAcceleration__FP2JTP5WATERf(rdram, ctx, runtime);
}

void entry_1d6ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6ba8 inside entry_1d6ba0 (0x1d6ba0 - 0x1d6bb8)
    ctx->pc = 0x1d6ba8;
    entry_1d6ba0(rdram, ctx, runtime);
}

void entry_1d6c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6c8c inside entry_1d6c84 (0x1d6c84 - 0x1d6c94)
    ctx->pc = 0x1d6c8c;
    entry_1d6c84(rdram, ctx, runtime);
}

void entry_1d6c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6c98 inside entry_1d6c94 (0x1d6c94 - 0x1d6cb0)
    ctx->pc = 0x1d6c98;
    entry_1d6c94(rdram, ctx, runtime);
}

void entry_1d6ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6ce0 inside FUN_001d6cb0 (0x1d6cb0 - 0x1d6d04)
    ctx->pc = 0x1d6ce0;
    FUN_001d6cb0(rdram, ctx, runtime);
}

void entry_1d6d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6d14 inside entry_1d6d04 (0x1d6d04 - 0x1d6d28)
    ctx->pc = 0x1d6d14;
    entry_1d6d04(rdram, ctx, runtime);
}

void entry_1d6d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6d1c inside entry_1d6d04 (0x1d6d04 - 0x1d6d28)
    ctx->pc = 0x1d6d1c;
    entry_1d6d04(rdram, ctx, runtime);
}

void entry_1d6d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6d84 inside entry_1d6d80 (0x1d6d80 - 0x1d6da0)
    ctx->pc = 0x1d6d84;
    entry_1d6d80(rdram, ctx, runtime);
}

void entry_1d6dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6dc4 inside entry_1d6dbc (0x1d6dbc - 0x1d6dd8)
    ctx->pc = 0x1d6dc4;
    entry_1d6dbc(rdram, ctx, runtime);
}

void entry_1d6dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6dcc inside entry_1d6dbc (0x1d6dbc - 0x1d6dd8)
    ctx->pc = 0x1d6dcc;
    entry_1d6dbc(rdram, ctx, runtime);
}

void entry_1d6e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6e5c inside entry_1d6e04 (0x1d6e04 - 0x1d6e80)
    ctx->pc = 0x1d6e5c;
    entry_1d6e04(rdram, ctx, runtime);
}

void entry_1d6e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6e70 inside entry_1d6e04 (0x1d6e04 - 0x1d6e80)
    ctx->pc = 0x1d6e70;
    entry_1d6e04(rdram, ctx, runtime);
}

void entry_1d6f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6f20 inside entry_1d6ef8 (0x1d6ef8 - 0x1d6f60)
    ctx->pc = 0x1d6f20;
    entry_1d6ef8(rdram, ctx, runtime);
}

void entry_1d6f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6f40 inside entry_1d6ef8 (0x1d6ef8 - 0x1d6f60)
    ctx->pc = 0x1d6f40;
    entry_1d6ef8(rdram, ctx, runtime);
}

void entry_1d6f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6f88 inside entry_1d6f60 (0x1d6f60 - 0x1d6fac)
    ctx->pc = 0x1d6f88;
    entry_1d6f60(rdram, ctx, runtime);
}

void entry_1d6f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d6f98 inside entry_1d6f60 (0x1d6f60 - 0x1d6fac)
    ctx->pc = 0x1d6f98;
    entry_1d6f60(rdram, ctx, runtime);
}

void entry_1d7080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7080 inside entry_1d7064 (0x1d7064 - 0x1d7098)
    ctx->pc = 0x1d7080;
    entry_1d7064(rdram, ctx, runtime);
}

void entry_1d717c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d717c inside entry_1d7178 (0x1d7178 - 0x1d7190)
    ctx->pc = 0x1d717c;
    entry_1d7178(rdram, ctx, runtime);
}

void entry_1d71f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d71f0 inside CbWrite__5OSTRMPvi (0x1d7190 - 0x1d721c)
    ctx->pc = 0x1d71f0;
    CbWrite__5OSTRMPvi(rdram, ctx, runtime);
}

void entry_1d7200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7200 inside CbWrite__5OSTRMPvi (0x1d7190 - 0x1d721c)
    ctx->pc = 0x1d7200;
    CbWrite__5OSTRMPvi(rdram, ctx, runtime);
}

void entry_1d722c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d722c inside entry_1d721c (0x1d721c - 0x1d7264)
    ctx->pc = 0x1d722c;
    entry_1d721c(rdram, ctx, runtime);
}

void entry_1d7238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7238 inside entry_1d721c (0x1d721c - 0x1d7264)
    ctx->pc = 0x1d7238;
    entry_1d721c(rdram, ctx, runtime);
}

void entry_1d7274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7274 inside entry_1d7264 (0x1d7264 - 0x1d7288)
    ctx->pc = 0x1d7274;
    entry_1d7264(rdram, ctx, runtime);
}

void entry_1d728c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d728c inside entry_1d7288 (0x1d7288 - 0x1d72c8)
    ctx->pc = 0x1d728c;
    entry_1d7288(rdram, ctx, runtime);
}

void entry_1d7294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7294 inside entry_1d7288 (0x1d7288 - 0x1d72c8)
    ctx->pc = 0x1d7294;
    entry_1d7288(rdram, ctx, runtime);
}

void entry_1d72a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d72a4 inside entry_1d7288 (0x1d7288 - 0x1d72c8)
    ctx->pc = 0x1d72a4;
    entry_1d7288(rdram, ctx, runtime);
}

void entry_1d7328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7328 inside Flush__5OSTRM (0x1d72c8 - 0x1d7348)
    ctx->pc = 0x1d7328;
    Flush__5OSTRM(rdram, ctx, runtime);
}

void entry_1d7378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7378 inside entry_1d7360 (0x1d7360 - 0x1d7380)
    ctx->pc = 0x1d7378;
    entry_1d7360(rdram, ctx, runtime);
}

void entry_1d7384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7384 inside entry_1d7380 (0x1d7380 - 0x1d73a8)
    ctx->pc = 0x1d7384;
    entry_1d7380(rdram, ctx, runtime);
}

void entry_1d7388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7388 inside entry_1d7380 (0x1d7380 - 0x1d73a8)
    ctx->pc = 0x1d7388;
    entry_1d7380(rdram, ctx, runtime);
}

void entry_1d7504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7504 inside entry_1d74d0 (0x1d74d0 - 0x1d75bc)
    ctx->pc = 0x1d7504;
    entry_1d74d0(rdram, ctx, runtime);
}

void entry_1d7518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7518 inside entry_1d74d0 (0x1d74d0 - 0x1d75bc)
    ctx->pc = 0x1d7518;
    entry_1d74d0(rdram, ctx, runtime);
}

void entry_1d7534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7534 inside entry_1d74d0 (0x1d74d0 - 0x1d75bc)
    ctx->pc = 0x1d7534;
    entry_1d74d0(rdram, ctx, runtime);
}

void entry_1d7550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7550 inside entry_1d74d0 (0x1d74d0 - 0x1d75bc)
    ctx->pc = 0x1d7550;
    entry_1d74d0(rdram, ctx, runtime);
}

void entry_1d7568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7568 inside entry_1d74d0 (0x1d74d0 - 0x1d75bc)
    ctx->pc = 0x1d7568;
    entry_1d74d0(rdram, ctx, runtime);
}

void entry_1d7654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7654 inside entry_1d763c (0x1d763c - 0x1d7660)
    ctx->pc = 0x1d7654;
    entry_1d763c(rdram, ctx, runtime);
}

void entry_1d7680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7680 inside entry_1d7660 (0x1d7660 - 0x1d76a8)
    ctx->pc = 0x1d7680;
    entry_1d7660(rdram, ctx, runtime);
}

void entry_1d76c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d76c0 inside entry_1d76a8 (0x1d76a8 - 0x1d76d8)
    ctx->pc = 0x1d76c0;
    entry_1d76a8(rdram, ctx, runtime);
}

void entry_1d76e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d76e4 inside entry_1d76d8 (0x1d76d8 - 0x1d7744)
    ctx->pc = 0x1d76e4;
    entry_1d76d8(rdram, ctx, runtime);
}

void entry_1d7718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7718 inside entry_1d76d8 (0x1d76d8 - 0x1d7744)
    ctx->pc = 0x1d7718;
    entry_1d76d8(rdram, ctx, runtime);
}

void entry_1d7720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7720 inside entry_1d76d8 (0x1d76d8 - 0x1d7744)
    ctx->pc = 0x1d7720;
    entry_1d76d8(rdram, ctx, runtime);
}

void entry_1d78a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d78a8 inside entry_1d7838 (0x1d7838 - 0x1d7904)
    ctx->pc = 0x1d78a8;
    entry_1d7838(rdram, ctx, runtime);
}

void entry_1d78e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d78e4 inside entry_1d7838 (0x1d7838 - 0x1d7904)
    ctx->pc = 0x1d78e4;
    entry_1d7838(rdram, ctx, runtime);
}

void entry_1d78e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d78e8 inside entry_1d7838 (0x1d7838 - 0x1d7904)
    ctx->pc = 0x1d78e8;
    entry_1d7838(rdram, ctx, runtime);
}

void entry_1d7920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7920 inside entry_1d7904 (0x1d7904 - 0x1d7940)
    ctx->pc = 0x1d7920;
    entry_1d7904(rdram, ctx, runtime);
}

void entry_1d7924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7924 inside entry_1d7904 (0x1d7904 - 0x1d7940)
    ctx->pc = 0x1d7924;
    entry_1d7904(rdram, ctx, runtime);
}

void entry_1d7a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7a3c inside entry_1d79a8 (0x1d79a8 - 0x1d7be0)
    ctx->pc = 0x1d7a3c;
    entry_1d79a8(rdram, ctx, runtime);
}

void entry_1d7a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7a4c inside entry_1d79a8 (0x1d79a8 - 0x1d7be0)
    ctx->pc = 0x1d7a4c;
    entry_1d79a8(rdram, ctx, runtime);
}

void entry_1d7aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7aa8 inside entry_1d79a8 (0x1d79a8 - 0x1d7be0)
    ctx->pc = 0x1d7aa8;
    entry_1d79a8(rdram, ctx, runtime);
}

void entry_1d7abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7abc inside entry_1d79a8 (0x1d79a8 - 0x1d7be0)
    ctx->pc = 0x1d7abc;
    entry_1d79a8(rdram, ctx, runtime);
}

void entry_1d7ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7ac0 inside entry_1d79a8 (0x1d79a8 - 0x1d7be0)
    ctx->pc = 0x1d7ac0;
    entry_1d79a8(rdram, ctx, runtime);
}

void entry_1d7c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7c20 inside entry_1d7bf8 (0x1d7bf8 - 0x1d7cc4)
    ctx->pc = 0x1d7c20;
    entry_1d7bf8(rdram, ctx, runtime);
}

void entry_1d7ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7ca4 inside entry_1d7bf8 (0x1d7bf8 - 0x1d7cc4)
    ctx->pc = 0x1d7ca4;
    entry_1d7bf8(rdram, ctx, runtime);
}

void entry_1d7cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7cb4 inside entry_1d7bf8 (0x1d7bf8 - 0x1d7cc4)
    ctx->pc = 0x1d7cb4;
    entry_1d7bf8(rdram, ctx, runtime);
}

void entry_1d7d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7d40 inside entry_1d7d0c (0x1d7d0c - 0x1d7fd4)
    ctx->pc = 0x1d7d40;
    entry_1d7d0c(rdram, ctx, runtime);
}

void entry_1d7d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7d50 inside entry_1d7d0c (0x1d7d0c - 0x1d7fd4)
    ctx->pc = 0x1d7d50;
    entry_1d7d0c(rdram, ctx, runtime);
}

void entry_1d7d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7d64 inside entry_1d7d0c (0x1d7d0c - 0x1d7fd4)
    ctx->pc = 0x1d7d64;
    entry_1d7d0c(rdram, ctx, runtime);
}

void entry_1d7d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7d68 inside entry_1d7d0c (0x1d7d0c - 0x1d7fd4)
    ctx->pc = 0x1d7d68;
    entry_1d7d0c(rdram, ctx, runtime);
}

void entry_1d7dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7dec inside entry_1d7d0c (0x1d7d0c - 0x1d7fd4)
    ctx->pc = 0x1d7dec;
    entry_1d7d0c(rdram, ctx, runtime);
}

void entry_1d7dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7dfc inside entry_1d7d0c (0x1d7d0c - 0x1d7fd4)
    ctx->pc = 0x1d7dfc;
    entry_1d7d0c(rdram, ctx, runtime);
}

void entry_1d7e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7e20 inside entry_1d7d0c (0x1d7d0c - 0x1d7fd4)
    ctx->pc = 0x1d7e20;
    entry_1d7d0c(rdram, ctx, runtime);
}

void entry_1d7eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7eac inside entry_1d7d0c (0x1d7d0c - 0x1d7fd4)
    ctx->pc = 0x1d7eac;
    entry_1d7d0c(rdram, ctx, runtime);
}

void entry_1d7ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7ec0 inside entry_1d7d0c (0x1d7d0c - 0x1d7fd4)
    ctx->pc = 0x1d7ec0;
    entry_1d7d0c(rdram, ctx, runtime);
}

void entry_1d7f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7f1c inside entry_1d7d0c (0x1d7d0c - 0x1d7fd4)
    ctx->pc = 0x1d7f1c;
    entry_1d7d0c(rdram, ctx, runtime);
}

void entry_1d7f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d7f2c inside entry_1d7d0c (0x1d7d0c - 0x1d7fd4)
    ctx->pc = 0x1d7f2c;
    entry_1d7d0c(rdram, ctx, runtime);
}

void entry_1d8060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8060 inside entry_1d8010 (0x1d8010 - 0x1d80a4)
    ctx->pc = 0x1d8060;
    entry_1d8010(rdram, ctx, runtime);
}

void entry_1d8070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8070 inside entry_1d8010 (0x1d8010 - 0x1d80a4)
    ctx->pc = 0x1d8070;
    entry_1d8010(rdram, ctx, runtime);
}

void entry_1d810c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d810c inside entry_1d80a4 (0x1d80a4 - 0x1d8150)
    ctx->pc = 0x1d810c;
    entry_1d80a4(rdram, ctx, runtime);
}

void entry_1d8120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8120 inside entry_1d80a4 (0x1d80a4 - 0x1d8150)
    ctx->pc = 0x1d8120;
    entry_1d80a4(rdram, ctx, runtime);
}

void entry_1d8174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8174 inside entry_1d8150 (0x1d8150 - 0x1d8254)
    ctx->pc = 0x1d8174;
    entry_1d8150(rdram, ctx, runtime);
}

void entry_1d817c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d817c inside entry_1d8150 (0x1d8150 - 0x1d8254)
    ctx->pc = 0x1d817c;
    entry_1d8150(rdram, ctx, runtime);
}

void entry_1d8204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8204 inside entry_1d8150 (0x1d8150 - 0x1d8254)
    ctx->pc = 0x1d8204;
    entry_1d8150(rdram, ctx, runtime);
}

void entry_1d8218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8218 inside entry_1d8150 (0x1d8150 - 0x1d8254)
    ctx->pc = 0x1d8218;
    entry_1d8150(rdram, ctx, runtime);
}

void entry_1d82b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d82b4 inside entry_1d829c (0x1d829c - 0x1d82c8)
    ctx->pc = 0x1d82b4;
    entry_1d829c(rdram, ctx, runtime);
}

void entry_1d82d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d82d8 inside entry_1d82c8 (0x1d82c8 - 0x1d8308)
    ctx->pc = 0x1d82d8;
    entry_1d82c8(rdram, ctx, runtime);
}

void entry_1d82dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d82dc inside entry_1d82c8 (0x1d82c8 - 0x1d8308)
    ctx->pc = 0x1d82dc;
    entry_1d82c8(rdram, ctx, runtime);
}

void entry_1d8328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8328 inside entry_1d8308 (0x1d8308 - 0x1d841c)
    ctx->pc = 0x1d8328;
    entry_1d8308(rdram, ctx, runtime);
}

void entry_1d8398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8398 inside entry_1d8308 (0x1d8308 - 0x1d841c)
    ctx->pc = 0x1d8398;
    entry_1d8308(rdram, ctx, runtime);
}

void entry_1d83ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d83ac inside entry_1d8308 (0x1d8308 - 0x1d841c)
    ctx->pc = 0x1d83ac;
    entry_1d8308(rdram, ctx, runtime);
}

void entry_1d83c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d83c4 inside entry_1d8308 (0x1d8308 - 0x1d841c)
    ctx->pc = 0x1d83c4;
    entry_1d8308(rdram, ctx, runtime);
}

void entry_1d84b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d84b8 inside entry_1d84a8 (0x1d84a8 - 0x1d84f4)
    ctx->pc = 0x1d84b8;
    entry_1d84a8(rdram, ctx, runtime);
}

void entry_1d84d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d84d0 inside entry_1d84a8 (0x1d84a8 - 0x1d84f4)
    ctx->pc = 0x1d84d0;
    entry_1d84a8(rdram, ctx, runtime);
}

void entry_1d8504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8504 inside entry_1d84f4 (0x1d84f4 - 0x1d8528)
    ctx->pc = 0x1d8504;
    entry_1d84f4(rdram, ctx, runtime);
}

void entry_1d8508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8508 inside entry_1d84f4 (0x1d84f4 - 0x1d8528)
    ctx->pc = 0x1d8508;
    entry_1d84f4(rdram, ctx, runtime);
}

void entry_1d8538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8538 inside entry_1d8528 (0x1d8528 - 0x1d8578)
    ctx->pc = 0x1d8538;
    entry_1d8528(rdram, ctx, runtime);
}

void entry_1d853c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d853c inside entry_1d8528 (0x1d8528 - 0x1d8578)
    ctx->pc = 0x1d853c;
    entry_1d8528(rdram, ctx, runtime);
}

void entry_1d8544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8544 inside entry_1d8528 (0x1d8528 - 0x1d8578)
    ctx->pc = 0x1d8544;
    entry_1d8528(rdram, ctx, runtime);
}

void entry_1d8548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8548 inside entry_1d8528 (0x1d8528 - 0x1d8578)
    ctx->pc = 0x1d8548;
    entry_1d8528(rdram, ctx, runtime);
}

void entry_1d8640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8640 inside entry_1d85c0 (0x1d85c0 - 0x1d86ac)
    ctx->pc = 0x1d8640;
    entry_1d85c0(rdram, ctx, runtime);
}

void entry_1d867c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d867c inside entry_1d85c0 (0x1d85c0 - 0x1d86ac)
    ctx->pc = 0x1d867c;
    entry_1d85c0(rdram, ctx, runtime);
}

void entry_1d868c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d868c inside entry_1d85c0 (0x1d85c0 - 0x1d86ac)
    ctx->pc = 0x1d868c;
    entry_1d85c0(rdram, ctx, runtime);
}

void entry_1d86dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d86dc inside entry_1d86cc (0x1d86cc - 0x1d86f8)
    ctx->pc = 0x1d86dc;
    entry_1d86cc(rdram, ctx, runtime);
}

void entry_1d86e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d86e0 inside entry_1d86cc (0x1d86cc - 0x1d86f8)
    ctx->pc = 0x1d86e0;
    entry_1d86cc(rdram, ctx, runtime);
}

void entry_1d871c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d871c inside DsGetTrackRelative__Ffff (0x1d86f8 - 0x1d8740)
    ctx->pc = 0x1d871c;
    DsGetTrackRelative__Ffff(rdram, ctx, runtime);
}

void entry_1d8738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8738 inside DsGetTrackRelative__Ffff (0x1d86f8 - 0x1d8740)
    ctx->pc = 0x1d8738;
    DsGetTrackRelative__Ffff(rdram, ctx, runtime);
}

void entry_1d8798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8798 inside FIsSuvAheadOf__FP3SUVT0 (0x1d8740 - 0x1d87a4)
    ctx->pc = 0x1d8798;
    FIsSuvAheadOf__FP3SUVT0(rdram, ctx, runtime);
}

void entry_1d87bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d87bc inside entry_1d87a4 (0x1d87a4 - 0x1d87c8)
    ctx->pc = 0x1d87bc;
    entry_1d87a4(rdram, ctx, runtime);
}

void entry_1d8860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8860 inside entry_1d8828 (0x1d8828 - 0x1d8888)
    ctx->pc = 0x1d8860;
    entry_1d8828(rdram, ctx, runtime);
}

void entry_1d88f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d88f0 inside entry_1d88a8 (0x1d88a8 - 0x1d89b0)
    ctx->pc = 0x1d88f0;
    entry_1d88a8(rdram, ctx, runtime);
}

void entry_1d8900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8900 inside entry_1d88a8 (0x1d88a8 - 0x1d89b0)
    ctx->pc = 0x1d8900;
    entry_1d88a8(rdram, ctx, runtime);
}

void entry_1d8930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8930 inside entry_1d88a8 (0x1d88a8 - 0x1d89b0)
    ctx->pc = 0x1d8930;
    entry_1d88a8(rdram, ctx, runtime);
}

void entry_1d8938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8938 inside entry_1d88a8 (0x1d88a8 - 0x1d89b0)
    ctx->pc = 0x1d8938;
    entry_1d88a8(rdram, ctx, runtime);
}

void entry_1d8b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8b0c inside entry_1d8afc (0x1d8afc - 0x1d8bd0)
    ctx->pc = 0x1d8b0c;
    entry_1d8afc(rdram, ctx, runtime);
}

void entry_1d8b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8b20 inside entry_1d8afc (0x1d8afc - 0x1d8bd0)
    ctx->pc = 0x1d8b20;
    entry_1d8afc(rdram, ctx, runtime);
}

void entry_1d8b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8b50 inside entry_1d8afc (0x1d8afc - 0x1d8bd0)
    ctx->pc = 0x1d8b50;
    entry_1d8afc(rdram, ctx, runtime);
}

void entry_1d8b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8b88 inside entry_1d8afc (0x1d8afc - 0x1d8bd0)
    ctx->pc = 0x1d8b88;
    entry_1d8afc(rdram, ctx, runtime);
}

void entry_1d8b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8b8c inside entry_1d8afc (0x1d8afc - 0x1d8bd0)
    ctx->pc = 0x1d8b8c;
    entry_1d8afc(rdram, ctx, runtime);
}

void entry_1d8b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8b94 inside entry_1d8afc (0x1d8afc - 0x1d8bd0)
    ctx->pc = 0x1d8b94;
    entry_1d8afc(rdram, ctx, runtime);
}

void entry_1d8b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8b98 inside entry_1d8afc (0x1d8afc - 0x1d8bd0)
    ctx->pc = 0x1d8b98;
    entry_1d8afc(rdram, ctx, runtime);
}

void entry_1d8d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8d1c inside entry_1d8cf4 (0x1d8cf4 - 0x1d8d90)
    ctx->pc = 0x1d8d1c;
    entry_1d8cf4(rdram, ctx, runtime);
}

void entry_1d8d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8d74 inside entry_1d8cf4 (0x1d8cf4 - 0x1d8d90)
    ctx->pc = 0x1d8d74;
    entry_1d8cf4(rdram, ctx, runtime);
}

void entry_1d8d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8d78 inside entry_1d8cf4 (0x1d8cf4 - 0x1d8d90)
    ctx->pc = 0x1d8d78;
    entry_1d8cf4(rdram, ctx, runtime);
}

void entry_1d8e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8e00 inside entry_1d8df0 (0x1d8df0 - 0x1d8e40)
    ctx->pc = 0x1d8e00;
    entry_1d8df0(rdram, ctx, runtime);
}

void entry_1d8e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8e14 inside entry_1d8df0 (0x1d8df0 - 0x1d8e40)
    ctx->pc = 0x1d8e14;
    entry_1d8df0(rdram, ctx, runtime);
}

void entry_1d8e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8e18 inside entry_1d8df0 (0x1d8df0 - 0x1d8e40)
    ctx->pc = 0x1d8e18;
    entry_1d8df0(rdram, ctx, runtime);
}

void entry_1d8ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8ee4 inside UpdateSuvExpls__FP3SUV (0x1d8e40 - 0x1d8f24)
    ctx->pc = 0x1d8ee4;
    UpdateSuvExpls__FP3SUV(rdram, ctx, runtime);
}

void entry_1d8ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8ef4 inside UpdateSuvExpls__FP3SUV (0x1d8e40 - 0x1d8f24)
    ctx->pc = 0x1d8ef4;
    UpdateSuvExpls__FP3SUV(rdram, ctx, runtime);
}

void entry_1d8f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8f50 inside entry_1d8f24 (0x1d8f24 - 0x1d8fb8)
    ctx->pc = 0x1d8f50;
    entry_1d8f24(rdram, ctx, runtime);
}

void entry_1d8fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8fa8 inside entry_1d8f24 (0x1d8f24 - 0x1d8fb8)
    ctx->pc = 0x1d8fa8;
    entry_1d8f24(rdram, ctx, runtime);
}

void entry_1d8fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d8fac inside entry_1d8f24 (0x1d8f24 - 0x1d8fb8)
    ctx->pc = 0x1d8fac;
    entry_1d8f24(rdram, ctx, runtime);
}

void entry_1d9008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9008 inside entry_1d8fe0 (0x1d8fe0 - 0x1d9048)
    ctx->pc = 0x1d9008;
    entry_1d8fe0(rdram, ctx, runtime);
}

void entry_1d9020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9020 inside entry_1d8fe0 (0x1d8fe0 - 0x1d9048)
    ctx->pc = 0x1d9020;
    entry_1d8fe0(rdram, ctx, runtime);
}

void entry_1d902c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d902c inside entry_1d8fe0 (0x1d8fe0 - 0x1d9048)
    ctx->pc = 0x1d902c;
    entry_1d8fe0(rdram, ctx, runtime);
}

void entry_1d9038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9038 inside entry_1d8fe0 (0x1d8fe0 - 0x1d9048)
    ctx->pc = 0x1d9038;
    entry_1d8fe0(rdram, ctx, runtime);
}

void entry_1d903c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d903c inside entry_1d8fe0 (0x1d8fe0 - 0x1d9048)
    ctx->pc = 0x1d903c;
    entry_1d8fe0(rdram, ctx, runtime);
}

void entry_1d9040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9040 inside entry_1d8fe0 (0x1d8fe0 - 0x1d9048)
    ctx->pc = 0x1d9040;
    entry_1d8fe0(rdram, ctx, runtime);
}

void entry_1d90c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d90c8 inside entry_1d90bc (0x1d90bc - 0x1d9124)
    ctx->pc = 0x1d90c8;
    entry_1d90bc(rdram, ctx, runtime);
}

void entry_1d919c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d919c inside entry_1d9130 (0x1d9130 - 0x1d91cc)
    ctx->pc = 0x1d919c;
    entry_1d9130(rdram, ctx, runtime);
}

void entry_1d91a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d91a0 inside entry_1d9130 (0x1d9130 - 0x1d91cc)
    ctx->pc = 0x1d91a0;
    entry_1d9130(rdram, ctx, runtime);
}

void entry_1d91d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d91d0 inside entry_1d91cc (0x1d91cc - 0x1d91e0)
    ctx->pc = 0x1d91d0;
    entry_1d91cc(rdram, ctx, runtime);
}

void entry_1d91e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d91e4 inside entry_1d91e0 (0x1d91e0 - 0x1d921c)
    ctx->pc = 0x1d91e4;
    entry_1d91e0(rdram, ctx, runtime);
}

void entry_1d9200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9200 inside entry_1d91e0 (0x1d91e0 - 0x1d921c)
    ctx->pc = 0x1d9200;
    entry_1d91e0(rdram, ctx, runtime);
}

void entry_1d9274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9274 inside entry_1d9250 (0x1d9250 - 0x1d9290)
    ctx->pc = 0x1d9274;
    entry_1d9250(rdram, ctx, runtime);
}

void entry_1d9278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9278 inside entry_1d9250 (0x1d9250 - 0x1d9290)
    ctx->pc = 0x1d9278;
    entry_1d9250(rdram, ctx, runtime);
}

void entry_1d92a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d92a4 inside entry_1d9290 (0x1d9290 - 0x1d92f0)
    ctx->pc = 0x1d92a4;
    entry_1d9290(rdram, ctx, runtime);
}

void entry_1d939c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d939c inside FUN_001d9338 (0x1d9338 - 0x1d940c)
    ctx->pc = 0x1d939c;
    FUN_001d9338(rdram, ctx, runtime);
}

void entry_1d93ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d93ac inside FUN_001d9338 (0x1d9338 - 0x1d940c)
    ctx->pc = 0x1d93ac;
    FUN_001d9338(rdram, ctx, runtime);
}

void entry_1d9404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9404 inside FUN_001d9338 (0x1d9338 - 0x1d940c)
    ctx->pc = 0x1d9404;
    FUN_001d9338(rdram, ctx, runtime);
}

void entry_1d9428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9428 inside entry_1d940c (0x1d940c - 0x1d9488)
    ctx->pc = 0x1d9428;
    entry_1d940c(rdram, ctx, runtime);
}

void entry_1d946c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d946c inside entry_1d940c (0x1d940c - 0x1d9488)
    ctx->pc = 0x1d946c;
    entry_1d940c(rdram, ctx, runtime);
}

void entry_1d9478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9478 inside entry_1d940c (0x1d940c - 0x1d9488)
    ctx->pc = 0x1d9478;
    entry_1d940c(rdram, ctx, runtime);
}

void entry_1d94e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d94e0 inside UpdateSuvVolumes__FP3SUVi (0x1d9488 - 0x1d94ec)
    ctx->pc = 0x1d94e0;
    UpdateSuvVolumes__FP3SUVi(rdram, ctx, runtime);
}

void entry_1d9518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9518 inside entry_1d94ec (0x1d94ec - 0x1d9568)
    ctx->pc = 0x1d9518;
    entry_1d94ec(rdram, ctx, runtime);
}

void entry_1d95a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d95a8 inside entry_1d9594 (0x1d9594 - 0x1d95c8)
    ctx->pc = 0x1d95a8;
    entry_1d9594(rdram, ctx, runtime);
}

void entry_1d95c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d95c0 inside entry_1d9594 (0x1d9594 - 0x1d95c8)
    ctx->pc = 0x1d95c0;
    entry_1d9594(rdram, ctx, runtime);
}

void entry_1d95e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d95e8 inside entry_1d95e0 (0x1d95e0 - 0x1d95f0)
    ctx->pc = 0x1d95e8;
    entry_1d95e0(rdram, ctx, runtime);
}

void entry_1d95f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d95f8 inside entry_1d95f0 (0x1d95f0 - 0x1d9600)
    ctx->pc = 0x1d95f8;
    entry_1d95f0(rdram, ctx, runtime);
}

void entry_1d9624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9624 inside entry_1d961c (0x1d961c - 0x1d9678)
    ctx->pc = 0x1d9624;
    entry_1d961c(rdram, ctx, runtime);
}

void entry_1d9630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9630 inside entry_1d961c (0x1d961c - 0x1d9678)
    ctx->pc = 0x1d9630;
    entry_1d961c(rdram, ctx, runtime);
}

void entry_1d9634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9634 inside entry_1d961c (0x1d961c - 0x1d9678)
    ctx->pc = 0x1d9634;
    entry_1d961c(rdram, ctx, runtime);
}

void entry_1d9644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9644 inside entry_1d961c (0x1d961c - 0x1d9678)
    ctx->pc = 0x1d9644;
    entry_1d961c(rdram, ctx, runtime);
}

void entry_1d96d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d96d0 inside UpdateSuvSounds__FP3SUVf (0x1d9678 - 0x1d96f4)
    ctx->pc = 0x1d96d0;
    UpdateSuvSounds__FP3SUVf(rdram, ctx, runtime);
}

void entry_1d96e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d96e0 inside UpdateSuvSounds__FP3SUVf (0x1d9678 - 0x1d96f4)
    ctx->pc = 0x1d96e0;
    UpdateSuvSounds__FP3SUVf(rdram, ctx, runtime);
}

void entry_1d9740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9740 inside entry_1d96f4 (0x1d96f4 - 0x1d9814)
    ctx->pc = 0x1d9740;
    entry_1d96f4(rdram, ctx, runtime);
}

void entry_1d9754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9754 inside entry_1d96f4 (0x1d96f4 - 0x1d9814)
    ctx->pc = 0x1d9754;
    entry_1d96f4(rdram, ctx, runtime);
}

void entry_1d97a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d97a0 inside entry_1d96f4 (0x1d96f4 - 0x1d9814)
    ctx->pc = 0x1d97a0;
    entry_1d96f4(rdram, ctx, runtime);
}

void entry_1d97b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d97b4 inside entry_1d96f4 (0x1d96f4 - 0x1d9814)
    ctx->pc = 0x1d97b4;
    entry_1d96f4(rdram, ctx, runtime);
}

void entry_1d985c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d985c inside entry_1d9814 (0x1d9814 - 0x1d9874)
    ctx->pc = 0x1d985c;
    entry_1d9814(rdram, ctx, runtime);
}

void entry_1d986c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d986c inside entry_1d9814 (0x1d9814 - 0x1d9874)
    ctx->pc = 0x1d986c;
    entry_1d9814(rdram, ctx, runtime);
}

void entry_1d98f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d98f0 inside entry_1d98a8 (0x1d98a8 - 0x1d9908)
    ctx->pc = 0x1d98f0;
    entry_1d98a8(rdram, ctx, runtime);
}

void entry_1d9900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9900 inside entry_1d98a8 (0x1d98a8 - 0x1d9908)
    ctx->pc = 0x1d9900;
    entry_1d98a8(rdram, ctx, runtime);
}

void entry_1d99bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d99bc inside entry_1d991c (0x1d991c - 0x1d9a50)
    ctx->pc = 0x1d99bc;
    entry_1d991c(rdram, ctx, runtime);
}

void entry_1d9a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9a08 inside entry_1d991c (0x1d991c - 0x1d9a50)
    ctx->pc = 0x1d9a08;
    entry_1d991c(rdram, ctx, runtime);
}

void entry_1d9a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9a18 inside entry_1d991c (0x1d991c - 0x1d9a50)
    ctx->pc = 0x1d9a18;
    entry_1d991c(rdram, ctx, runtime);
}

void entry_1d9a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9a98 inside entry_1d9a50 (0x1d9a50 - 0x1d9ab0)
    ctx->pc = 0x1d9a98;
    entry_1d9a50(rdram, ctx, runtime);
}

void entry_1d9aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9aa8 inside entry_1d9a50 (0x1d9a50 - 0x1d9ab0)
    ctx->pc = 0x1d9aa8;
    entry_1d9a50(rdram, ctx, runtime);
}

void entry_1d9b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9b10 inside UpdateSuvPuncher__FP3SUV (0x1d9ac8 - 0x1d9b88)
    ctx->pc = 0x1d9b10;
    UpdateSuvPuncher__FP3SUV(rdram, ctx, runtime);
}

void entry_1d9b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9b50 inside UpdateSuvPuncher__FP3SUV (0x1d9ac8 - 0x1d9b88)
    ctx->pc = 0x1d9b50;
    UpdateSuvPuncher__FP3SUV(rdram, ctx, runtime);
}

void entry_1d9b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9b6c inside UpdateSuvPuncher__FP3SUV (0x1d9ac8 - 0x1d9b88)
    ctx->pc = 0x1d9b6c;
    UpdateSuvPuncher__FP3SUV(rdram, ctx, runtime);
}

void entry_1d9b74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9b74 inside UpdateSuvPuncher__FP3SUV (0x1d9ac8 - 0x1d9b88)
    ctx->pc = 0x1d9b74;
    UpdateSuvPuncher__FP3SUV(rdram, ctx, runtime);
}

void entry_1d9c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9c1c inside entry_1d9bfc (0x1d9bfc - 0x1d9c28)
    ctx->pc = 0x1d9c1c;
    entry_1d9bfc(rdram, ctx, runtime);
}

void entry_1d9c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9c3c inside entry_1d9c28 (0x1d9c28 - 0x1d9c44)
    ctx->pc = 0x1d9c3c;
    entry_1d9c28(rdram, ctx, runtime);
}

void entry_1d9c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9c5c inside entry_1d9c58 (0x1d9c58 - 0x1d9c70)
    ctx->pc = 0x1d9c5c;
    entry_1d9c58(rdram, ctx, runtime);
}

void entry_1d9c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9c74 inside entry_1d9c70 (0x1d9c70 - 0x1d9c98)
    ctx->pc = 0x1d9c74;
    entry_1d9c70(rdram, ctx, runtime);
}

void entry_1d9ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9ce0 inside entry_1d9cb8 (0x1d9cb8 - 0x1d9ce8)
    ctx->pc = 0x1d9ce0;
    entry_1d9cb8(rdram, ctx, runtime);
}

void entry_1d9d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9d00 inside entry_1d9cfc (0x1d9cfc - 0x1d9d08)
    ctx->pc = 0x1d9d00;
    entry_1d9cfc(rdram, ctx, runtime);
}

void entry_1d9d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9d50 inside entry_1d9d2c (0x1d9d2c - 0x1d9d64)
    ctx->pc = 0x1d9d50;
    entry_1d9d2c(rdram, ctx, runtime);
}

void entry_1d9d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9d68 inside entry_1d9d64 (0x1d9d64 - 0x1d9d78)
    ctx->pc = 0x1d9d68;
    entry_1d9d64(rdram, ctx, runtime);
}

void entry_1d9ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9ddc inside entry_1d9dd4 (0x1d9dd4 - 0x1d9de8)
    ctx->pc = 0x1d9ddc;
    entry_1d9dd4(rdram, ctx, runtime);
}

void entry_1d9df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9df0 inside entry_1d9de8 (0x1d9de8 - 0x1d9e44)
    ctx->pc = 0x1d9df0;
    entry_1d9de8(rdram, ctx, runtime);
}

void entry_1d9e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9e2c inside entry_1d9de8 (0x1d9de8 - 0x1d9e44)
    ctx->pc = 0x1d9e2c;
    entry_1d9de8(rdram, ctx, runtime);
}

void entry_1d9ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9ec4 inside entry_1d9e98 (0x1d9e98 - 0x1d9f04)
    ctx->pc = 0x1d9ec4;
    entry_1d9e98(rdram, ctx, runtime);
}

void entry_1d9ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9ef4 inside entry_1d9e98 (0x1d9e98 - 0x1d9f04)
    ctx->pc = 0x1d9ef4;
    entry_1d9e98(rdram, ctx, runtime);
}

void entry_1d9f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9f0c inside entry_1d9f04 (0x1d9f04 - 0x1d9f24)
    ctx->pc = 0x1d9f0c;
    entry_1d9f04(rdram, ctx, runtime);
}

void entry_1d9f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9f28 inside entry_1d9f24 (0x1d9f24 - 0x1d9f34)
    ctx->pc = 0x1d9f28;
    entry_1d9f24(rdram, ctx, runtime);
}

void entry_1d9f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9f2c inside entry_1d9f24 (0x1d9f24 - 0x1d9f34)
    ctx->pc = 0x1d9f2c;
    entry_1d9f24(rdram, ctx, runtime);
}

void entry_1d9f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9f54 inside entry_1d9f34 (0x1d9f34 - 0x1d9f84)
    ctx->pc = 0x1d9f54;
    entry_1d9f34(rdram, ctx, runtime);
}

void entry_1d9fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1d9fc0 inside entry_1d9fb8 (0x1d9fb8 - 0x1da024)
    ctx->pc = 0x1d9fc0;
    entry_1d9fb8(rdram, ctx, runtime);
}

void entry_1da038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da038 inside entry_1da024 (0x1da024 - 0x1da04c)
    ctx->pc = 0x1da038;
    entry_1da024(rdram, ctx, runtime);
}

void entry_1da058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da058 inside entry_1da04c (0x1da04c - 0x1da0a4)
    ctx->pc = 0x1da058;
    entry_1da04c(rdram, ctx, runtime);
}

void entry_1da060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da060 inside entry_1da04c (0x1da04c - 0x1da0a4)
    ctx->pc = 0x1da060;
    entry_1da04c(rdram, ctx, runtime);
}

void entry_1da07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da07c inside entry_1da04c (0x1da04c - 0x1da0a4)
    ctx->pc = 0x1da07c;
    entry_1da04c(rdram, ctx, runtime);
}

void entry_1da090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da090 inside entry_1da04c (0x1da04c - 0x1da0a4)
    ctx->pc = 0x1da090;
    entry_1da04c(rdram, ctx, runtime);
}

void entry_1da0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da0e0 inside entry_1da0d8 (0x1da0d8 - 0x1da110)
    ctx->pc = 0x1da0e0;
    entry_1da0d8(rdram, ctx, runtime);
}

void entry_1da118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da118 inside entry_1da110 (0x1da110 - 0x1da134)
    ctx->pc = 0x1da118;
    entry_1da110(rdram, ctx, runtime);
}

void entry_1da14c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da14c inside entry_1da148 (0x1da148 - 0x1da170)
    ctx->pc = 0x1da14c;
    entry_1da148(rdram, ctx, runtime);
}

void entry_1da150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da150 inside entry_1da148 (0x1da148 - 0x1da170)
    ctx->pc = 0x1da150;
    entry_1da148(rdram, ctx, runtime);
}

void entry_1da1a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da1a8 inside FUN_001da170 (0x1da170 - 0x1da1bc)
    ctx->pc = 0x1da1a8;
    FUN_001da170(rdram, ctx, runtime);
}

void entry_1da1f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da1f4 inside entry_1da1ec (0x1da1ec - 0x1da20c)
    ctx->pc = 0x1da1f4;
    entry_1da1ec(rdram, ctx, runtime);
}

void entry_1da214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da214 inside entry_1da20c (0x1da20c - 0x1da21c)
    ctx->pc = 0x1da214;
    entry_1da20c(rdram, ctx, runtime);
}

void entry_1da220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da220 inside entry_1da21c (0x1da21c - 0x1da238)
    ctx->pc = 0x1da220;
    entry_1da21c(rdram, ctx, runtime);
}

void entry_1da268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da268 inside entry_1da260 (0x1da260 - 0x1da278)
    ctx->pc = 0x1da268;
    entry_1da260(rdram, ctx, runtime);
}

void entry_1da2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da2d4 inside entry_1da2cc (0x1da2cc - 0x1da2e4)
    ctx->pc = 0x1da2d4;
    entry_1da2cc(rdram, ctx, runtime);
}

void entry_1da2fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da2fc inside entry_1da2f8 (0x1da2f8 - 0x1da310)
    ctx->pc = 0x1da2fc;
    entry_1da2f8(rdram, ctx, runtime);
}

void entry_1da388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da388 inside AddSuvCustomXps__FP3SUVP2SOiP3BSPT3PP2XP (0x1da320 - 0x1da3ec)
    ctx->pc = 0x1da388;
    AddSuvCustomXps__FP3SUVP2SOiP3BSPT3PP2XP(rdram, ctx, runtime);
}

void entry_1da3a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da3a0 inside AddSuvCustomXps__FP3SUVP2SOiP3BSPT3PP2XP (0x1da320 - 0x1da3ec)
    ctx->pc = 0x1da3a0;
    AddSuvCustomXps__FP3SUVP2SOiP3BSPT3PP2XP(rdram, ctx, runtime);
}

void entry_1da3cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da3cc inside AddSuvCustomXps__FP3SUVP2SOiP3BSPT3PP2XP (0x1da320 - 0x1da3ec)
    ctx->pc = 0x1da3cc;
    AddSuvCustomXps__FP3SUVP2SOiP3BSPT3PP2XP(rdram, ctx, runtime);
}

void entry_1da3d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da3d0 inside AddSuvCustomXps__FP3SUVP2SOiP3BSPT3PP2XP (0x1da320 - 0x1da3ec)
    ctx->pc = 0x1da3d0;
    AddSuvCustomXps__FP3SUVP2SOiP3BSPT3PP2XP(rdram, ctx, runtime);
}

void entry_1da408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da408 inside entry_1da3ec (0x1da3ec - 0x1da428)
    ctx->pc = 0x1da408;
    entry_1da3ec(rdram, ctx, runtime);
}

void entry_1da40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da40c inside entry_1da3ec (0x1da3ec - 0x1da428)
    ctx->pc = 0x1da40c;
    entry_1da3ec(rdram, ctx, runtime);
}

void entry_1da43c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da43c inside entry_1da428 (0x1da428 - 0x1da4a8)
    ctx->pc = 0x1da43c;
    entry_1da428(rdram, ctx, runtime);
}

void entry_1da440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da440 inside entry_1da428 (0x1da428 - 0x1da4a8)
    ctx->pc = 0x1da440;
    entry_1da428(rdram, ctx, runtime);
}

void entry_1da52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da52c inside entry_1da4a8 (0x1da4a8 - 0x1da568)
    ctx->pc = 0x1da52c;
    entry_1da4a8(rdram, ctx, runtime);
}

void entry_1da534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da534 inside entry_1da4a8 (0x1da4a8 - 0x1da568)
    ctx->pc = 0x1da534;
    entry_1da4a8(rdram, ctx, runtime);
}

void entry_1da5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da5ac inside entry_1da5a4 (0x1da5a4 - 0x1da5b4)
    ctx->pc = 0x1da5ac;
    entry_1da5a4(rdram, ctx, runtime);
}

void entry_1da5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da5f4 inside entry_1da5f0 (0x1da5f0 - 0x1da604)
    ctx->pc = 0x1da5f4;
    entry_1da5f0(rdram, ctx, runtime);
}

void entry_1da608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da608 inside entry_1da604 (0x1da604 - 0x1da644)
    ctx->pc = 0x1da608;
    entry_1da604(rdram, ctx, runtime);
}

void entry_1da61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da61c inside entry_1da604 (0x1da604 - 0x1da644)
    ctx->pc = 0x1da61c;
    entry_1da604(rdram, ctx, runtime);
}

void entry_1da620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da620 inside entry_1da604 (0x1da604 - 0x1da644)
    ctx->pc = 0x1da620;
    entry_1da604(rdram, ctx, runtime);
}

void entry_1da634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da634 inside entry_1da604 (0x1da604 - 0x1da644)
    ctx->pc = 0x1da634;
    entry_1da604(rdram, ctx, runtime);
}

void entry_1da68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da68c inside entry_1da684 (0x1da684 - 0x1da6ac)
    ctx->pc = 0x1da68c;
    entry_1da684(rdram, ctx, runtime);
}

void entry_1da6b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da6b0 inside entry_1da6ac (0x1da6ac - 0x1da6e0)
    ctx->pc = 0x1da6b0;
    entry_1da6ac(rdram, ctx, runtime);
}

void entry_1da72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da72c inside AdjustSuvNewXp__FP3SUVP2XPi (0x1da6e0 - 0x1da7e0)
    ctx->pc = 0x1da72c;
    AdjustSuvNewXp__FP3SUVP2XPi(rdram, ctx, runtime);
}

void entry_1da734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da734 inside AdjustSuvNewXp__FP3SUVP2XPi (0x1da6e0 - 0x1da7e0)
    ctx->pc = 0x1da734;
    AdjustSuvNewXp__FP3SUVP2XPi(rdram, ctx, runtime);
}

void entry_1da7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da7a8 inside AdjustSuvNewXp__FP3SUVP2XPi (0x1da6e0 - 0x1da7e0)
    ctx->pc = 0x1da7a8;
    AdjustSuvNewXp__FP3SUVP2XPi(rdram, ctx, runtime);
}

void entry_1da7cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da7cc inside AdjustSuvNewXp__FP3SUVP2XPi (0x1da6e0 - 0x1da7e0)
    ctx->pc = 0x1da7cc;
    AdjustSuvNewXp__FP3SUVP2XPi(rdram, ctx, runtime);
}

void entry_1da838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da838 inside entry_1da81c (0x1da81c - 0x1da888)
    ctx->pc = 0x1da838;
    entry_1da81c(rdram, ctx, runtime);
}

void entry_1da89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da89c inside entry_1da888 (0x1da888 - 0x1da8cc)
    ctx->pc = 0x1da89c;
    entry_1da888(rdram, ctx, runtime);
}

void entry_1da8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da8a0 inside entry_1da888 (0x1da888 - 0x1da8cc)
    ctx->pc = 0x1da8a0;
    entry_1da888(rdram, ctx, runtime);
}

void entry_1da8ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da8ac inside entry_1da888 (0x1da888 - 0x1da8cc)
    ctx->pc = 0x1da8ac;
    entry_1da888(rdram, ctx, runtime);
}

void entry_1da8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da8d4 inside entry_1da8cc (0x1da8cc - 0x1da8e8)
    ctx->pc = 0x1da8d4;
    entry_1da8cc(rdram, ctx, runtime);
}

void entry_1da8f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da8f0 inside entry_1da8e8 (0x1da8e8 - 0x1da91c)
    ctx->pc = 0x1da8f0;
    entry_1da8e8(rdram, ctx, runtime);
}

void entry_1da90c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1da90c inside entry_1da8e8 (0x1da8e8 - 0x1da91c)
    ctx->pc = 0x1da90c;
    entry_1da8e8(rdram, ctx, runtime);
}

void entry_1daa70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1daa70 inside entry_1daa4c (0x1daa4c - 0x1daab8)
    ctx->pc = 0x1daa70;
    entry_1daa4c(rdram, ctx, runtime);
}

void entry_1dab70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dab70 inside entry_1dab58 (0x1dab58 - 0x1dab8c)
    ctx->pc = 0x1dab70;
    entry_1dab58(rdram, ctx, runtime);
}

void entry_1dab78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dab78 inside entry_1dab58 (0x1dab58 - 0x1dab8c)
    ctx->pc = 0x1dab78;
    entry_1dab58(rdram, ctx, runtime);
}

void entry_1dabbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dabbc inside entry_1dab8c (0x1dab8c - 0x1dabc8)
    ctx->pc = 0x1dabbc;
    entry_1dab8c(rdram, ctx, runtime);
}

void entry_1dabec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dabec inside entry_1dabc8 (0x1dabc8 - 0x1dabf4)
    ctx->pc = 0x1dabec;
    entry_1dabc8(rdram, ctx, runtime);
}

void entry_1dabf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dabf8 inside entry_1dabf4 (0x1dabf4 - 0x1dac20)
    ctx->pc = 0x1dabf8;
    entry_1dabf4(rdram, ctx, runtime);
}

void entry_1dac48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dac48 inside entry_1dac44 (0x1dac44 - 0x1dac6c)
    ctx->pc = 0x1dac48;
    entry_1dac44(rdram, ctx, runtime);
}

void entry_1dac7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dac7c inside entry_1dac6c (0x1dac6c - 0x1dac88)
    ctx->pc = 0x1dac7c;
    entry_1dac6c(rdram, ctx, runtime);
}

void entry_1dad00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dad00 inside entry_1dacf8 (0x1dacf8 - 0x1dad10)
    ctx->pc = 0x1dad00;
    entry_1dacf8(rdram, ctx, runtime);
}

void entry_1dad14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dad14 inside entry_1dad10 (0x1dad10 - 0x1dad28)
    ctx->pc = 0x1dad14;
    entry_1dad10(rdram, ctx, runtime);
}

void entry_1dae08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dae08 inside entry_1dadd8 (0x1dadd8 - 0x1dae18)
    ctx->pc = 0x1dae08;
    entry_1dadd8(rdram, ctx, runtime);
}

void entry_1daed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1daed8 inside entry_1daed0 (0x1daed0 - 0x1daef4)
    ctx->pc = 0x1daed8;
    entry_1daed0(rdram, ctx, runtime);
}

void entry_1daef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1daef8 inside entry_1daef4 (0x1daef4 - 0x1daf08)
    ctx->pc = 0x1daef8;
    entry_1daef4(rdram, ctx, runtime);
}

void entry_1daf98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1daf98 inside entry_1daf2c (0x1daf2c - 0x1dafb8)
    ctx->pc = 0x1daf98;
    entry_1daf2c(rdram, ctx, runtime);
}

void entry_1dafa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dafa0 inside entry_1daf2c (0x1daf2c - 0x1dafb8)
    ctx->pc = 0x1dafa0;
    entry_1daf2c(rdram, ctx, runtime);
}

void entry_1dafa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dafa4 inside entry_1daf2c (0x1daf2c - 0x1dafb8)
    ctx->pc = 0x1dafa4;
    entry_1daf2c(rdram, ctx, runtime);
}

void entry_1db048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db048 inside entry_1db030 (0x1db030 - 0x1db060)
    ctx->pc = 0x1db048;
    entry_1db030(rdram, ctx, runtime);
}

void entry_1db094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db094 inside entry_1db090 (0x1db090 - 0x1db0c8)
    ctx->pc = 0x1db094;
    entry_1db090(rdram, ctx, runtime);
}

void entry_1db0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db0a8 inside entry_1db090 (0x1db090 - 0x1db0c8)
    ctx->pc = 0x1db0a8;
    entry_1db090(rdram, ctx, runtime);
}

void entry_1db170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db170 inside AddSuvCheckPoint__FP3SUVP3VOL (0x1db110 - 0x1db1a0)
    ctx->pc = 0x1db170;
    AddSuvCheckPoint__FP3SUVP3VOL(rdram, ctx, runtime);
}

void entry_1db18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db18c inside AddSuvCheckPoint__FP3SUVP3VOL (0x1db110 - 0x1db1a0)
    ctx->pc = 0x1db18c;
    AddSuvCheckPoint__FP3SUVP3VOL(rdram, ctx, runtime);
}

void entry_1db230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db230 inside AddSuvFeature__FP3SUVP3VOLffP4EXPLT4 (0x1db1e8 - 0x1db238)
    ctx->pc = 0x1db230;
    AddSuvFeature__FP3SUVP3VOLffP4EXPLT4(rdram, ctx, runtime);
}

void entry_1db284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db284 inside entry_1db280 (0x1db280 - 0x1db290)
    ctx->pc = 0x1db284;
    entry_1db280(rdram, ctx, runtime);
}

void entry_1db338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db338 inside ResetSuv__FP3SUV (0x1db290 - 0x1db370)
    ctx->pc = 0x1db338;
    ResetSuv__FP3SUV(rdram, ctx, runtime);
}

void entry_1db34c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db34c inside ResetSuv__FP3SUV (0x1db290 - 0x1db370)
    ctx->pc = 0x1db34c;
    ResetSuv__FP3SUV(rdram, ctx, runtime);
}

void entry_1db410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db410 inside entry_1db3c0 (0x1db3c0 - 0x1db448)
    ctx->pc = 0x1db410;
    entry_1db3c0(rdram, ctx, runtime);
}

void entry_1db498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db498 inside InitSwDlHash__FP2SW (0x1db480 - 0x1db4a4)
    ctx->pc = 0x1db498;
    InitSwDlHash__FP2SW(rdram, ctx, runtime);
}

void entry_1db7b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db7b4 inside entry_1db78c (0x1db78c - 0x1db7bc)
    ctx->pc = 0x1db7b4;
    entry_1db78c(rdram, ctx, runtime);
}

void entry_1db914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db914 inside entry_1db8c4 (0x1db8c4 - 0x1db928)
    ctx->pc = 0x1db914;
    entry_1db8c4(rdram, ctx, runtime);
}

void entry_1db984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db984 inside entry_1db970 (0x1db970 - 0x1db98c)
    ctx->pc = 0x1db984;
    entry_1db970(rdram, ctx, runtime);
}

void entry_1db9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db9a0 inside entry_1db998 (0x1db998 - 0x1db9a8)
    ctx->pc = 0x1db9a0;
    entry_1db998(rdram, ctx, runtime);
}

void entry_1db9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1db9ec inside entry_1db9b4 (0x1db9b4 - 0x1db9f4)
    ctx->pc = 0x1db9ec;
    entry_1db9b4(rdram, ctx, runtime);
}

void entry_1dbb44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbb44 inside FOverflowSwLo__FP2SWP2LOi (0x1dbb20 - 0x1dbb50)
    ctx->pc = 0x1dbb44;
    FOverflowSwLo__FP2SWP2LOi(rdram, ctx, runtime);
}

void entry_1dbbb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbbb0 inside FreeSwXaList__FP2SWP2XA (0x1dbb90 - 0x1dbbbc)
    ctx->pc = 0x1dbbb0;
    FreeSwXaList__FP2SWP2XA(rdram, ctx, runtime);
}

void entry_1dbbc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbbc4 inside entry_1dbbbc (0x1dbbbc - 0x1dbbd8)
    ctx->pc = 0x1dbbc4;
    entry_1dbbbc(rdram, ctx, runtime);
}

void entry_1dbc38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbc38 inside FreeSwMqList__FP2SWP2MQ (0x1dbc18 - 0x1dbc44)
    ctx->pc = 0x1dbc38;
    FreeSwMqList__FP2SWP2MQ(rdram, ctx, runtime);
}

void entry_1dbc4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbc4c inside entry_1dbc44 (0x1dbc44 - 0x1dbc60)
    ctx->pc = 0x1dbc4c;
    entry_1dbc44(rdram, ctx, runtime);
}

void entry_1dbc78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbc78 inside EnsureSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2 (0x1dbc60 - 0x1dbcb8)
    ctx->pc = 0x1dbc78;
    EnsureSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime);
}

void entry_1dbca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbca8 inside EnsureSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2 (0x1dbc60 - 0x1dbcb8)
    ctx->pc = 0x1dbca8;
    EnsureSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime);
}

void entry_1dbcb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbcb0 inside EnsureSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2 (0x1dbc60 - 0x1dbcb8)
    ctx->pc = 0x1dbcb0;
    EnsureSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime);
}

void entry_1dbcbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbcbc inside entry_1dbcb8 (0x1dbcb8 - 0x1dbcc8)
    ctx->pc = 0x1dbcbc;
    entry_1dbcb8(rdram, ctx, runtime);
}

void entry_1dbd1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbd1c inside entry_1dbcfc (0x1dbcfc - 0x1dbd40)
    ctx->pc = 0x1dbd1c;
    entry_1dbcfc(rdram, ctx, runtime);
}

void entry_1dbd70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbd70 inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbd70;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbd78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbd78 inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbd78;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbda0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbda0 inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbda0;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbdb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbdb8 inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbdb8;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbdc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbdc8 inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbdc8;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbddc inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbddc;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbdec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbdec inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbdec;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbdf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbdf4 inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbdf4;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbdf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbdf8 inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbdf8;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbe0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbe0c inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbe0c;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbe14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbe14 inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbe14;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbe20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbe20 inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbe20;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbe24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbe24 inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbe24;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbe30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbe30 inside ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3 (0x1dbd40 - 0x1dbe38)
    ctx->pc = 0x1dbe30;
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime);
}

void entry_1dbe70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbe70 inside ProcessSwCallbacks__FP2SW (0x1dbe48 - 0x1dbe9c)
    ctx->pc = 0x1dbe70;
    ProcessSwCallbacks__FP2SW(rdram, ctx, runtime);
}

void entry_1dbe7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbe7c inside ProcessSwCallbacks__FP2SW (0x1dbe48 - 0x1dbe9c)
    ctx->pc = 0x1dbe7c;
    ProcessSwCallbacks__FP2SW(rdram, ctx, runtime);
}

void entry_1dbeb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbeb8 inside entry_1dbea8 (0x1dbea8 - 0x1dbec8)
    ctx->pc = 0x1dbeb8;
    entry_1dbea8(rdram, ctx, runtime);
}

void entry_1dbf50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbf50 inside entry_1dbf28 (0x1dbf28 - 0x1dbf78)
    ctx->pc = 0x1dbf50;
    entry_1dbf28(rdram, ctx, runtime);
}

void entry_1dbfa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbfa4 inside entry_1dbf9c (0x1dbf9c - 0x1dbfac)
    ctx->pc = 0x1dbfa4;
    entry_1dbf9c(rdram, ctx, runtime);
}

void entry_1dbfb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbfb0 inside entry_1dbfac (0x1dbfac - 0x1dbfcc)
    ctx->pc = 0x1dbfb0;
    entry_1dbfac(rdram, ctx, runtime);
}

void entry_1dbfb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbfb8 inside entry_1dbfac (0x1dbfac - 0x1dbfcc)
    ctx->pc = 0x1dbfb8;
    entry_1dbfac(rdram, ctx, runtime);
}

void entry_1dbfc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbfc4 inside entry_1dbfac (0x1dbfac - 0x1dbfcc)
    ctx->pc = 0x1dbfc4;
    entry_1dbfac(rdram, ctx, runtime);
}

void entry_1dbfe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dbfe0 inside entry_1dbfd8 (0x1dbfd8 - 0x1dbff0)
    ctx->pc = 0x1dbfe0;
    entry_1dbfd8(rdram, ctx, runtime);
}

void entry_1dc008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc008 inside entry_1dbff0 (0x1dbff0 - 0x1dc050)
    ctx->pc = 0x1dc008;
    entry_1dbff0(rdram, ctx, runtime);
}

void entry_1dc018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc018 inside entry_1dbff0 (0x1dbff0 - 0x1dc050)
    ctx->pc = 0x1dc018;
    entry_1dbff0(rdram, ctx, runtime);
}

void entry_1dc028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc028 inside entry_1dbff0 (0x1dbff0 - 0x1dc050)
    ctx->pc = 0x1dc028;
    entry_1dbff0(rdram, ctx, runtime);
}

void entry_1dc034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc034 inside entry_1dbff0 (0x1dbff0 - 0x1dc050)
    ctx->pc = 0x1dc034;
    entry_1dbff0(rdram, ctx, runtime);
}

void entry_1dc058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc058 inside entry_1dc050 (0x1dc050 - 0x1dc060)
    ctx->pc = 0x1dc058;
    entry_1dc050(rdram, ctx, runtime);
}

void entry_1dc064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc064 inside entry_1dc060 (0x1dc060 - 0x1dc078)
    ctx->pc = 0x1dc064;
    entry_1dc060(rdram, ctx, runtime);
}

void entry_1dc088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc088 inside entry_1dc084 (0x1dc084 - 0x1dc090)
    ctx->pc = 0x1dc088;
    entry_1dc084(rdram, ctx, runtime);
}

void entry_1dc0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc0a0 inside entry_1dc09c (0x1dc09c - 0x1dc0c8)
    ctx->pc = 0x1dc0a0;
    entry_1dc09c(rdram, ctx, runtime);
}

void entry_1dc128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc128 inside FreeSwStsoList__FP2SWP4STSO (0x1dc108 - 0x1dc134)
    ctx->pc = 0x1dc128;
    FreeSwStsoList__FP2SWP4STSO(rdram, ctx, runtime);
}

void entry_1dc13c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc13c inside entry_1dc134 (0x1dc134 - 0x1dc150)
    ctx->pc = 0x1dc13c;
    entry_1dc134(rdram, ctx, runtime);
}

void entry_1dc198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc198 inside entry_1dc184 (0x1dc184 - 0x1dc1a4)
    ctx->pc = 0x1dc198;
    entry_1dc184(rdram, ctx, runtime);
}

void entry_1dc1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc1c8 inside entry_1dc1a4 (0x1dc1a4 - 0x1dc208)
    ctx->pc = 0x1dc1c8;
    entry_1dc1a4(rdram, ctx, runtime);
}

void entry_1dc2f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc2f0 inside entry_1dc2b0 (0x1dc2b0 - 0x1dc3e8)
    ctx->pc = 0x1dc2f0;
    entry_1dc2b0(rdram, ctx, runtime);
}

void entry_1dc330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc330 inside entry_1dc2b0 (0x1dc2b0 - 0x1dc3e8)
    ctx->pc = 0x1dc330;
    entry_1dc2b0(rdram, ctx, runtime);
}

void entry_1dc40c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc40c inside entry_1dc404 (0x1dc404 - 0x1dc430)
    ctx->pc = 0x1dc40c;
    entry_1dc404(rdram, ctx, runtime);
}

void entry_1dc420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc420 inside entry_1dc404 (0x1dc404 - 0x1dc430)
    ctx->pc = 0x1dc420;
    entry_1dc404(rdram, ctx, runtime);
}

void entry_1dc440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc440 inside entry_1dc430 (0x1dc430 - 0x1dc4d0)
    ctx->pc = 0x1dc440;
    entry_1dc430(rdram, ctx, runtime);
}

void entry_1dc454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc454 inside entry_1dc430 (0x1dc430 - 0x1dc4d0)
    ctx->pc = 0x1dc454;
    entry_1dc430(rdram, ctx, runtime);
}

void entry_1dc45c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc45c inside entry_1dc430 (0x1dc430 - 0x1dc4d0)
    ctx->pc = 0x1dc45c;
    entry_1dc430(rdram, ctx, runtime);
}

void entry_1dc464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc464 inside entry_1dc430 (0x1dc430 - 0x1dc4d0)
    ctx->pc = 0x1dc464;
    entry_1dc430(rdram, ctx, runtime);
}

void entry_1dc468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc468 inside entry_1dc430 (0x1dc430 - 0x1dc4d0)
    ctx->pc = 0x1dc468;
    entry_1dc430(rdram, ctx, runtime);
}

void entry_1dc46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc46c inside entry_1dc430 (0x1dc430 - 0x1dc4d0)
    ctx->pc = 0x1dc46c;
    entry_1dc430(rdram, ctx, runtime);
}

void entry_1dc480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc480 inside entry_1dc430 (0x1dc430 - 0x1dc4d0)
    ctx->pc = 0x1dc480;
    entry_1dc430(rdram, ctx, runtime);
}

void entry_1dc484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc484 inside entry_1dc430 (0x1dc430 - 0x1dc4d0)
    ctx->pc = 0x1dc484;
    entry_1dc430(rdram, ctx, runtime);
}

void entry_1dc58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc58c inside entry_1dc54c (0x1dc54c - 0x1dc628)
    ctx->pc = 0x1dc58c;
    entry_1dc54c(rdram, ctx, runtime);
}

void entry_1dc5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc5b0 inside entry_1dc54c (0x1dc54c - 0x1dc628)
    ctx->pc = 0x1dc5b0;
    entry_1dc54c(rdram, ctx, runtime);
}

void entry_1dc64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc64c inside entry_1dc644 (0x1dc644 - 0x1dc670)
    ctx->pc = 0x1dc64c;
    entry_1dc644(rdram, ctx, runtime);
}

void entry_1dc660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc660 inside entry_1dc644 (0x1dc644 - 0x1dc670)
    ctx->pc = 0x1dc660;
    entry_1dc644(rdram, ctx, runtime);
}

void entry_1dc680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc680 inside entry_1dc670 (0x1dc670 - 0x1dc710)
    ctx->pc = 0x1dc680;
    entry_1dc670(rdram, ctx, runtime);
}

void entry_1dc694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc694 inside entry_1dc670 (0x1dc670 - 0x1dc710)
    ctx->pc = 0x1dc694;
    entry_1dc670(rdram, ctx, runtime);
}

void entry_1dc69c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc69c inside entry_1dc670 (0x1dc670 - 0x1dc710)
    ctx->pc = 0x1dc69c;
    entry_1dc670(rdram, ctx, runtime);
}

void entry_1dc6a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc6a4 inside entry_1dc670 (0x1dc670 - 0x1dc710)
    ctx->pc = 0x1dc6a4;
    entry_1dc670(rdram, ctx, runtime);
}

void entry_1dc6bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc6bc inside entry_1dc670 (0x1dc670 - 0x1dc710)
    ctx->pc = 0x1dc6bc;
    entry_1dc670(rdram, ctx, runtime);
}

void entry_1dc6c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc6c0 inside entry_1dc670 (0x1dc670 - 0x1dc710)
    ctx->pc = 0x1dc6c0;
    entry_1dc670(rdram, ctx, runtime);
}

void entry_1dc728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc728 inside RemoveOxa__FP3OXAPP3OXA (0x1dc710 - 0x1dc740)
    ctx->pc = 0x1dc728;
    RemoveOxa__FP3OXAPP3OXA(rdram, ctx, runtime);
}

void entry_1dc738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc738 inside RemoveOxa__FP3OXAPP3OXA (0x1dc710 - 0x1dc740)
    ctx->pc = 0x1dc738;
    RemoveOxa__FP3OXAPP3OXA(rdram, ctx, runtime);
}

void entry_1dc768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc768 inside entry_1dc758 (0x1dc758 - 0x1dc7b0)
    ctx->pc = 0x1dc768;
    entry_1dc758(rdram, ctx, runtime);
}

void entry_1dc7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc7c8 inside AddOxa__FP3OXAPP3OXA (0x1dc7b0 - 0x1dc7d0)
    ctx->pc = 0x1dc7c8;
    AddOxa__FP3OXAPP3OXA(rdram, ctx, runtime);
}

void entry_1dc868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc868 inside FreeSwPoxa__FP2SWP3OXA (0x1dc828 - 0x1dc87c)
    ctx->pc = 0x1dc868;
    FreeSwPoxa__FP2SWP3OXA(rdram, ctx, runtime);
}

void entry_1dc8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc8b8 inside entry_1dc8b4 (0x1dc8b4 - 0x1dc8d0)
    ctx->pc = 0x1dc8b8;
    entry_1dc8b4(rdram, ctx, runtime);
}

void entry_1dc8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc8d4 inside entry_1dc8d0 (0x1dc8d0 - 0x1dc8e8)
    ctx->pc = 0x1dc8d4;
    entry_1dc8d0(rdram, ctx, runtime);
}

void entry_1dc8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc8fc inside entry_1dc8f4 (0x1dc8f4 - 0x1dc96c)
    ctx->pc = 0x1dc8fc;
    entry_1dc8f4(rdram, ctx, runtime);
}

void entry_1dc928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc928 inside entry_1dc8f4 (0x1dc8f4 - 0x1dc96c)
    ctx->pc = 0x1dc928;
    entry_1dc8f4(rdram, ctx, runtime);
}

void entry_1dc95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dc95c inside entry_1dc8f4 (0x1dc8f4 - 0x1dc96c)
    ctx->pc = 0x1dc95c;
    entry_1dc8f4(rdram, ctx, runtime);
}

void entry_1dcd00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dcd00 inside entry_1dccd8 (0x1dccd8 - 0x1dcd08)
    ctx->pc = 0x1dcd00;
    entry_1dccd8(rdram, ctx, runtime);
}

void entry_1dcd10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dcd10 inside entry_1dcd08 (0x1dcd08 - 0x1dcd28)
    ctx->pc = 0x1dcd10;
    entry_1dcd08(rdram, ctx, runtime);
}

void entry_1dcd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dcd88 inside CreateSwPrizes__FP2SW (0x1dcd28 - 0x1dce20)
    ctx->pc = 0x1dcd88;
    CreateSwPrizes__FP2SW(rdram, ctx, runtime);
}

void entry_1dcdb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dcdb8 inside CreateSwPrizes__FP2SW (0x1dcd28 - 0x1dce20)
    ctx->pc = 0x1dcdb8;
    CreateSwPrizes__FP2SW(rdram, ctx, runtime);
}

void entry_1dcde8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dcde8 inside CreateSwPrizes__FP2SW (0x1dcd28 - 0x1dce20)
    ctx->pc = 0x1dcde8;
    CreateSwPrizes__FP2SW(rdram, ctx, runtime);
}

void entry_1dce10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dce10 inside CreateSwPrizes__FP2SW (0x1dcd28 - 0x1dce20)
    ctx->pc = 0x1dce10;
    CreateSwPrizes__FP2SW(rdram, ctx, runtime);
}

void entry_1dce60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dce60 inside entry_1dce50 (0x1dce50 - 0x1dcea0)
    ctx->pc = 0x1dce60;
    entry_1dce50(rdram, ctx, runtime);
}

void entry_1dcf40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dcf40 inside entry_1dcf30 (0x1dcf30 - 0x1dcf58)
    ctx->pc = 0x1dcf40;
    entry_1dcf30(rdram, ctx, runtime);
}

void entry_1dcf90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dcf90 inside entry_1dcf6c (0x1dcf6c - 0x1dcfa8)
    ctx->pc = 0x1dcf90;
    entry_1dcf6c(rdram, ctx, runtime);
}

void entry_1dd038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd038 inside entry_1dd034 (0x1dd034 - 0x1dd048)
    ctx->pc = 0x1dd038;
    entry_1dd034(rdram, ctx, runtime);
}

void entry_1dd074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd074 inside entry_1dd070 (0x1dd070 - 0x1dd09c)
    ctx->pc = 0x1dd074;
    entry_1dd070(rdram, ctx, runtime);
}

void entry_1dd0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd0e0 inside entry_1dd0d0 (0x1dd0d0 - 0x1dd0f4)
    ctx->pc = 0x1dd0e0;
    entry_1dd0d0(rdram, ctx, runtime);
}

void entry_1dd0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd0f8 inside entry_1dd0f4 (0x1dd0f4 - 0x1dd108)
    ctx->pc = 0x1dd0f8;
    entry_1dd0f4(rdram, ctx, runtime);
}

void entry_1dd100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd100 inside entry_1dd0f4 (0x1dd0f4 - 0x1dd108)
    ctx->pc = 0x1dd100;
    entry_1dd0f4(rdram, ctx, runtime);
}

void entry_1dd138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd138 inside entry_1dd108 (0x1dd108 - 0x1dd148)
    ctx->pc = 0x1dd138;
    entry_1dd108(rdram, ctx, runtime);
}

void entry_1dd164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd164 inside entry_1dd148 (0x1dd148 - 0x1dd174)
    ctx->pc = 0x1dd164;
    entry_1dd148(rdram, ctx, runtime);
}

void entry_1dd1c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd1c0 inside entry_1dd1bc (0x1dd1bc - 0x1dd1c8)
    ctx->pc = 0x1dd1c0;
    entry_1dd1bc(rdram, ctx, runtime);
}

void entry_1dd238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd238 inside FClipLineHomogeneous__FP7VECTOR4 (0x1dd218 - 0x1dd3e0)
    ctx->pc = 0x1dd238;
    FClipLineHomogeneous__FP7VECTOR4(rdram, ctx, runtime);
}

void entry_1dd258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd258 inside FClipLineHomogeneous__FP7VECTOR4 (0x1dd218 - 0x1dd3e0)
    ctx->pc = 0x1dd258;
    FClipLineHomogeneous__FP7VECTOR4(rdram, ctx, runtime);
}

void entry_1dd2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd2c4 inside FClipLineHomogeneous__FP7VECTOR4 (0x1dd218 - 0x1dd3e0)
    ctx->pc = 0x1dd2c4;
    FClipLineHomogeneous__FP7VECTOR4(rdram, ctx, runtime);
}

void entry_1dd2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd2e8 inside FClipLineHomogeneous__FP7VECTOR4 (0x1dd218 - 0x1dd3e0)
    ctx->pc = 0x1dd2e8;
    FClipLineHomogeneous__FP7VECTOR4(rdram, ctx, runtime);
}

void entry_1dd360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd360 inside FClipLineHomogeneous__FP7VECTOR4 (0x1dd218 - 0x1dd3e0)
    ctx->pc = 0x1dd360;
    FClipLineHomogeneous__FP7VECTOR4(rdram, ctx, runtime);
}

void entry_1dd3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd3c4 inside FClipLineHomogeneous__FP7VECTOR4 (0x1dd218 - 0x1dd3e0)
    ctx->pc = 0x1dd3c4;
    FClipLineHomogeneous__FP7VECTOR4(rdram, ctx, runtime);
}

void entry_1dd3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd3c8 inside FClipLineHomogeneous__FP7VECTOR4 (0x1dd218 - 0x1dd3e0)
    ctx->pc = 0x1dd3c8;
    FClipLineHomogeneous__FP7VECTOR4(rdram, ctx, runtime);
}

void entry_1dd3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd3d8 inside FClipLineHomogeneous__FP7VECTOR4 (0x1dd218 - 0x1dd3e0)
    ctx->pc = 0x1dd3d8;
    FClipLineHomogeneous__FP7VECTOR4(rdram, ctx, runtime);
}

void entry_1dd438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd438 inside DrawLineWorld__FP6VECTORT0G4RGBAP2CMi (0x1dd3e0 - 0x1dd448)
    ctx->pc = 0x1dd438;
    DrawLineWorld__FP6VECTORT0G4RGBAP2CMi(rdram, ctx, runtime);
}

void entry_1dd4a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd4a0 inside entry_1dd45c (0x1dd45c - 0x1dd520)
    ctx->pc = 0x1dd4a0;
    entry_1dd45c(rdram, ctx, runtime);
}

void entry_1dd598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd598 inside entry_1dd588 (0x1dd588 - 0x1dd5c0)
    ctx->pc = 0x1dd598;
    entry_1dd588(rdram, ctx, runtime);
}

void entry_1dd744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd744 inside entry_1dd720 (0x1dd720 - 0x1dd758)
    ctx->pc = 0x1dd744;
    entry_1dd720(rdram, ctx, runtime);
}

void entry_1dd790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd790 inside entry_1dd768 (0x1dd768 - 0x1dd7a0)
    ctx->pc = 0x1dd790;
    entry_1dd768(rdram, ctx, runtime);
}

void entry_1dd7d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd7d8 inside entry_1dd7b0 (0x1dd7b0 - 0x1dd7e8)
    ctx->pc = 0x1dd7d8;
    entry_1dd7b0(rdram, ctx, runtime);
}

void entry_1dd820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd820 inside entry_1dd808 (0x1dd808 - 0x1dd888)
    ctx->pc = 0x1dd820;
    entry_1dd808(rdram, ctx, runtime);
}

void entry_1dd824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd824 inside entry_1dd808 (0x1dd808 - 0x1dd888)
    ctx->pc = 0x1dd824;
    entry_1dd808(rdram, ctx, runtime);
}

void entry_1dd828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd828 inside entry_1dd808 (0x1dd808 - 0x1dd888)
    ctx->pc = 0x1dd828;
    entry_1dd808(rdram, ctx, runtime);
}

void entry_1dd850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd850 inside entry_1dd808 (0x1dd808 - 0x1dd888)
    ctx->pc = 0x1dd850;
    entry_1dd808(rdram, ctx, runtime);
}

void entry_1dd854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd854 inside entry_1dd808 (0x1dd808 - 0x1dd888)
    ctx->pc = 0x1dd854;
    entry_1dd808(rdram, ctx, runtime);
}

void entry_1dd860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd860 inside entry_1dd808 (0x1dd808 - 0x1dd888)
    ctx->pc = 0x1dd860;
    entry_1dd808(rdram, ctx, runtime);
}

void entry_1dd870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd870 inside entry_1dd808 (0x1dd808 - 0x1dd888)
    ctx->pc = 0x1dd870;
    entry_1dd808(rdram, ctx, runtime);
}

void entry_1dd874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd874 inside entry_1dd808 (0x1dd808 - 0x1dd888)
    ctx->pc = 0x1dd874;
    entry_1dd808(rdram, ctx, runtime);
}

void entry_1dd8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd8b0 inside entry_1dd8a0 (0x1dd8a0 - 0x1dd8e8)
    ctx->pc = 0x1dd8b0;
    entry_1dd8a0(rdram, ctx, runtime);
}

void entry_1dd8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd8c4 inside entry_1dd8a0 (0x1dd8a0 - 0x1dd8e8)
    ctx->pc = 0x1dd8c4;
    entry_1dd8a0(rdram, ctx, runtime);
}

void entry_1dd8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dd8d4 inside entry_1dd8a0 (0x1dd8a0 - 0x1dd8e8)
    ctx->pc = 0x1dd8d4;
    entry_1dd8a0(rdram, ctx, runtime);
}

void entry_1ddb18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddb18 inside entry_1ddb14 (0x1ddb14 - 0x1ddb20)
    ctx->pc = 0x1ddb18;
    entry_1ddb14(rdram, ctx, runtime);
}

void entry_1ddc70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddc70 inside entry_1ddc6c (0x1ddc6c - 0x1ddc78)
    ctx->pc = 0x1ddc70;
    entry_1ddc6c(rdram, ctx, runtime);
}

void entry_1ddd54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddd54 inside entry_1ddd4c (0x1ddd4c - 0x1ddd80)
    ctx->pc = 0x1ddd54;
    entry_1ddd4c(rdram, ctx, runtime);
}

void entry_1ddd60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddd60 inside entry_1ddd4c (0x1ddd4c - 0x1ddd80)
    ctx->pc = 0x1ddd60;
    entry_1ddd4c(rdram, ctx, runtime);
}

void entry_1ddd70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddd70 inside entry_1ddd4c (0x1ddd4c - 0x1ddd80)
    ctx->pc = 0x1ddd70;
    entry_1ddd4c(rdram, ctx, runtime);
}

void entry_1ddd88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddd88 inside entry_1ddd80 (0x1ddd80 - 0x1dddc4)
    ctx->pc = 0x1ddd88;
    entry_1ddd80(rdram, ctx, runtime);
}

void entry_1ddd90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddd90 inside entry_1ddd80 (0x1ddd80 - 0x1dddc4)
    ctx->pc = 0x1ddd90;
    entry_1ddd80(rdram, ctx, runtime);
}

void entry_1dddb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dddb8 inside entry_1ddd80 (0x1ddd80 - 0x1dddc4)
    ctx->pc = 0x1dddb8;
    entry_1ddd80(rdram, ctx, runtime);
}

void entry_1dddd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dddd8 inside entry_1dddc4 (0x1dddc4 - 0x1dde28)
    ctx->pc = 0x1dddd8;
    entry_1dddc4(rdram, ctx, runtime);
}

void entry_1dde18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dde18 inside entry_1dddc4 (0x1dddc4 - 0x1dde28)
    ctx->pc = 0x1dde18;
    entry_1dddc4(rdram, ctx, runtime);
}

void entry_1dde30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dde30 inside entry_1dde28 (0x1dde28 - 0x1dde68)
    ctx->pc = 0x1dde30;
    entry_1dde28(rdram, ctx, runtime);
}

void entry_1dde40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dde40 inside entry_1dde28 (0x1dde28 - 0x1dde68)
    ctx->pc = 0x1dde40;
    entry_1dde28(rdram, ctx, runtime);
}

void entry_1dde44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dde44 inside entry_1dde28 (0x1dde28 - 0x1dde68)
    ctx->pc = 0x1dde44;
    entry_1dde28(rdram, ctx, runtime);
}

void entry_1dde50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dde50 inside entry_1dde28 (0x1dde28 - 0x1dde68)
    ctx->pc = 0x1dde50;
    entry_1dde28(rdram, ctx, runtime);
}

void entry_1dde70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dde70 inside entry_1dde68 (0x1dde68 - 0x1dde90)
    ctx->pc = 0x1dde70;
    entry_1dde68(rdram, ctx, runtime);
}

void entry_1dde74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dde74 inside entry_1dde68 (0x1dde68 - 0x1dde90)
    ctx->pc = 0x1dde74;
    entry_1dde68(rdram, ctx, runtime);
}

void entry_1ddf24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddf24 inside entry_1ddee8 (0x1ddee8 - 0x1ddf90)
    ctx->pc = 0x1ddf24;
    entry_1ddee8(rdram, ctx, runtime);
}

void entry_1ddf50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddf50 inside entry_1ddee8 (0x1ddee8 - 0x1ddf90)
    ctx->pc = 0x1ddf50;
    entry_1ddee8(rdram, ctx, runtime);
}

void entry_1ddf7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddf7c inside entry_1ddee8 (0x1ddee8 - 0x1ddf90)
    ctx->pc = 0x1ddf7c;
    entry_1ddee8(rdram, ctx, runtime);
}

void entry_1ddfa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddfa8 inside entry_1ddf90 (0x1ddf90 - 0x1ddfc8)
    ctx->pc = 0x1ddfa8;
    entry_1ddf90(rdram, ctx, runtime);
}

void entry_1ddfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddfdc inside entry_1ddfc8 (0x1ddfc8 - 0x1de00c)
    ctx->pc = 0x1ddfdc;
    entry_1ddfc8(rdram, ctx, runtime);
}

void entry_1ddfe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ddfe0 inside entry_1ddfc8 (0x1ddfc8 - 0x1de00c)
    ctx->pc = 0x1ddfe0;
    entry_1ddfc8(rdram, ctx, runtime);
}

void entry_1de054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de054 inside entry_1de050 (0x1de050 - 0x1de1b0)
    ctx->pc = 0x1de054;
    entry_1de050(rdram, ctx, runtime);
}

void entry_1de070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de070 inside entry_1de050 (0x1de050 - 0x1de1b0)
    ctx->pc = 0x1de070;
    entry_1de050(rdram, ctx, runtime);
}

void entry_1de0ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de0ac inside entry_1de050 (0x1de050 - 0x1de1b0)
    ctx->pc = 0x1de0ac;
    entry_1de050(rdram, ctx, runtime);
}

void entry_1de0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de0e0 inside entry_1de050 (0x1de050 - 0x1de1b0)
    ctx->pc = 0x1de0e0;
    entry_1de050(rdram, ctx, runtime);
}

void entry_1de134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de134 inside entry_1de050 (0x1de050 - 0x1de1b0)
    ctx->pc = 0x1de134;
    entry_1de050(rdram, ctx, runtime);
}

void entry_1de144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de144 inside entry_1de050 (0x1de050 - 0x1de1b0)
    ctx->pc = 0x1de144;
    entry_1de050(rdram, ctx, runtime);
}

void entry_1de170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de170 inside entry_1de050 (0x1de050 - 0x1de1b0)
    ctx->pc = 0x1de170;
    entry_1de050(rdram, ctx, runtime);
}

void entry_1de200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de200 inside entry_1de1d4 (0x1de1d4 - 0x1de394)
    ctx->pc = 0x1de200;
    entry_1de1d4(rdram, ctx, runtime);
}

void entry_1de2c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de2c0 inside entry_1de1d4 (0x1de1d4 - 0x1de394)
    ctx->pc = 0x1de2c0;
    entry_1de1d4(rdram, ctx, runtime);
}

void entry_1de2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de2e8 inside entry_1de1d4 (0x1de1d4 - 0x1de394)
    ctx->pc = 0x1de2e8;
    entry_1de1d4(rdram, ctx, runtime);
}

void entry_1de358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de358 inside entry_1de1d4 (0x1de1d4 - 0x1de394)
    ctx->pc = 0x1de358;
    entry_1de1d4(rdram, ctx, runtime);
}

void entry_1de3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de3c8 inside entry_1de3a8 (0x1de3a8 - 0x1de628)
    ctx->pc = 0x1de3c8;
    entry_1de3a8(rdram, ctx, runtime);
}

void entry_1de3dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de3dc inside entry_1de3a8 (0x1de3a8 - 0x1de628)
    ctx->pc = 0x1de3dc;
    entry_1de3a8(rdram, ctx, runtime);
}

void entry_1de410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de410 inside entry_1de3a8 (0x1de3a8 - 0x1de628)
    ctx->pc = 0x1de410;
    entry_1de3a8(rdram, ctx, runtime);
}

void entry_1de430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de430 inside entry_1de3a8 (0x1de3a8 - 0x1de628)
    ctx->pc = 0x1de430;
    entry_1de3a8(rdram, ctx, runtime);
}

void entry_1de444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de444 inside entry_1de3a8 (0x1de3a8 - 0x1de628)
    ctx->pc = 0x1de444;
    entry_1de3a8(rdram, ctx, runtime);
}

void entry_1de460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de460 inside entry_1de3a8 (0x1de3a8 - 0x1de628)
    ctx->pc = 0x1de460;
    entry_1de3a8(rdram, ctx, runtime);
}

void entry_1de590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de590 inside entry_1de3a8 (0x1de3a8 - 0x1de628)
    ctx->pc = 0x1de590;
    entry_1de3a8(rdram, ctx, runtime);
}

void entry_1de5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de5f4 inside entry_1de3a8 (0x1de3a8 - 0x1de628)
    ctx->pc = 0x1de5f4;
    entry_1de3a8(rdram, ctx, runtime);
}

void entry_1de700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de700 inside entry_1de6c0 (0x1de6c0 - 0x1de728)
    ctx->pc = 0x1de700;
    entry_1de6c0(rdram, ctx, runtime);
}

void entry_1de72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de72c inside entry_1de728 (0x1de728 - 0x1de768)
    ctx->pc = 0x1de72c;
    entry_1de728(rdram, ctx, runtime);
}

void entry_1de780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de780 inside MatchTailOtherObject__FP4TAILP3ALO (0x1de768 - 0x1de788)
    ctx->pc = 0x1de780;
    MatchTailOtherObject__FP4TAILP3ALO(rdram, ctx, runtime);
}

void entry_1de8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de8e0 inside entry_1de8c4 (0x1de8c4 - 0x1de8ec)
    ctx->pc = 0x1de8e0;
    entry_1de8c4(rdram, ctx, runtime);
}

void entry_1de8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de8e4 inside entry_1de8c4 (0x1de8c4 - 0x1de8ec)
    ctx->pc = 0x1de8e4;
    entry_1de8c4(rdram, ctx, runtime);
}

void entry_1de964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de964 inside entry_1de960 (0x1de960 - 0x1de9dc)
    ctx->pc = 0x1de964;
    entry_1de960(rdram, ctx, runtime);
}

void entry_1de988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de988 inside entry_1de960 (0x1de960 - 0x1de9dc)
    ctx->pc = 0x1de988;
    entry_1de960(rdram, ctx, runtime);
}

void entry_1de9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de9a0 inside entry_1de960 (0x1de960 - 0x1de9dc)
    ctx->pc = 0x1de9a0;
    entry_1de960(rdram, ctx, runtime);
}

void entry_1de9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de9d0 inside entry_1de960 (0x1de960 - 0x1de9dc)
    ctx->pc = 0x1de9d0;
    entry_1de960(rdram, ctx, runtime);
}

void entry_1de9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1de9e0 inside entry_1de9dc (0x1de9dc - 0x1de9fc)
    ctx->pc = 0x1de9e0;
    entry_1de9dc(rdram, ctx, runtime);
}

void entry_1dea04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dea04 inside entry_1de9fc (0x1de9fc - 0x1dea18)
    ctx->pc = 0x1dea04;
    entry_1de9fc(rdram, ctx, runtime);
}

void entry_1dea1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dea1c inside entry_1dea18 (0x1dea18 - 0x1dea30)
    ctx->pc = 0x1dea1c;
    entry_1dea18(rdram, ctx, runtime);
}

void entry_1dea34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dea34 inside entry_1dea30 (0x1dea30 - 0x1deaa8)
    ctx->pc = 0x1dea34;
    entry_1dea30(rdram, ctx, runtime);
}

void entry_1dea84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dea84 inside entry_1dea30 (0x1dea30 - 0x1deaa8)
    ctx->pc = 0x1dea84;
    entry_1dea30(rdram, ctx, runtime);
}

void entry_1dea98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dea98 inside entry_1dea30 (0x1dea30 - 0x1deaa8)
    ctx->pc = 0x1dea98;
    entry_1dea30(rdram, ctx, runtime);
}

void entry_1deaf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1deaf8 inside entry_1deabc (0x1deabc - 0x1deb30)
    ctx->pc = 0x1deaf8;
    entry_1deabc(rdram, ctx, runtime);
}

void entry_1dec7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dec7c inside entry_1dec74 (0x1dec74 - 0x1decb4)
    ctx->pc = 0x1dec7c;
    entry_1dec74(rdram, ctx, runtime);
}

void entry_1decdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1decdc inside entry_1decd8 (0x1decd8 - 0x1ded14)
    ctx->pc = 0x1decdc;
    entry_1decd8(rdram, ctx, runtime);
}

void entry_1dece0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dece0 inside entry_1decd8 (0x1decd8 - 0x1ded14)
    ctx->pc = 0x1dece0;
    entry_1decd8(rdram, ctx, runtime);
}

void entry_1ded08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ded08 inside entry_1decd8 (0x1decd8 - 0x1ded14)
    ctx->pc = 0x1ded08;
    entry_1decd8(rdram, ctx, runtime);
}

void entry_1dedb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dedb4 inside entry_1dedac (0x1dedac - 0x1dedc0)
    ctx->pc = 0x1dedb4;
    entry_1dedac(rdram, ctx, runtime);
}

void entry_1dedb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dedb8 inside entry_1dedac (0x1dedac - 0x1dedc0)
    ctx->pc = 0x1dedb8;
    entry_1dedac(rdram, ctx, runtime);
}

void entry_1dedc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dedc4 inside entry_1dedc0 (0x1dedc0 - 0x1dedd4)
    ctx->pc = 0x1dedc4;
    entry_1dedc0(rdram, ctx, runtime);
}

void entry_1dee20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dee20 inside entry_1dedd4 (0x1dedd4 - 0x1dee54)
    ctx->pc = 0x1dee20;
    entry_1dedd4(rdram, ctx, runtime);
}

void entry_1dee30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dee30 inside entry_1dedd4 (0x1dedd4 - 0x1dee54)
    ctx->pc = 0x1dee30;
    entry_1dedd4(rdram, ctx, runtime);
}

void entry_1deee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1deee4 inside entry_1dee70 (0x1dee70 - 0x1def14)
    ctx->pc = 0x1deee4;
    entry_1dee70(rdram, ctx, runtime);
}

void entry_1deef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1deef8 inside entry_1dee70 (0x1dee70 - 0x1def14)
    ctx->pc = 0x1deef8;
    entry_1dee70(rdram, ctx, runtime);
}

void entry_1df10c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df10c inside entry_1df048 (0x1df048 - 0x1df1b0)
    ctx->pc = 0x1df10c;
    entry_1df048(rdram, ctx, runtime);
}

void entry_1df11c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df11c inside entry_1df048 (0x1df048 - 0x1df1b0)
    ctx->pc = 0x1df11c;
    entry_1df048(rdram, ctx, runtime);
}

void entry_1df130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df130 inside entry_1df048 (0x1df048 - 0x1df1b0)
    ctx->pc = 0x1df130;
    entry_1df048(rdram, ctx, runtime);
}

void entry_1df134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df134 inside entry_1df048 (0x1df048 - 0x1df1b0)
    ctx->pc = 0x1df134;
    entry_1df048(rdram, ctx, runtime);
}

void entry_1df17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df17c inside entry_1df048 (0x1df048 - 0x1df1b0)
    ctx->pc = 0x1df17c;
    entry_1df048(rdram, ctx, runtime);
}

void entry_1df18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df18c inside entry_1df048 (0x1df048 - 0x1df1b0)
    ctx->pc = 0x1df18c;
    entry_1df048(rdram, ctx, runtime);
}

void entry_1df264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df264 inside entry_1df260 (0x1df260 - 0x1df290)
    ctx->pc = 0x1df264;
    entry_1df260(rdram, ctx, runtime);
}

void entry_1df2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df2b4 inside entry_1df2ac (0x1df2ac - 0x1df2c8)
    ctx->pc = 0x1df2b4;
    entry_1df2ac(rdram, ctx, runtime);
}

void entry_1df344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df344 inside RenderTankAll__FP4TANKP2CMP2RO (0x1df2c8 - 0x1df368)
    ctx->pc = 0x1df344;
    RenderTankAll__FP4TANKP2CMP2RO(rdram, ctx, runtime);
}

void entry_1df34c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df34c inside RenderTankAll__FP4TANKP2CMP2RO (0x1df2c8 - 0x1df368)
    ctx->pc = 0x1df34c;
    RenderTankAll__FP4TANKP2CMP2RO(rdram, ctx, runtime);
}

void entry_1df3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df3c4 inside entry_1df368 (0x1df368 - 0x1df4f0)
    ctx->pc = 0x1df3c4;
    entry_1df368(rdram, ctx, runtime);
}

void entry_1df408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df408 inside entry_1df368 (0x1df368 - 0x1df4f0)
    ctx->pc = 0x1df408;
    entry_1df368(rdram, ctx, runtime);
}

void entry_1df418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df418 inside entry_1df368 (0x1df368 - 0x1df4f0)
    ctx->pc = 0x1df418;
    entry_1df368(rdram, ctx, runtime);
}

void entry_1df4cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df4cc inside entry_1df368 (0x1df368 - 0x1df4f0)
    ctx->pc = 0x1df4cc;
    entry_1df368(rdram, ctx, runtime);
}

void entry_1df4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df4e4 inside entry_1df368 (0x1df368 - 0x1df4f0)
    ctx->pc = 0x1df4e4;
    entry_1df368(rdram, ctx, runtime);
}

void entry_1df5ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df5ec inside entry_1df5e4 (0x1df5e4 - 0x1df600)
    ctx->pc = 0x1df5ec;
    entry_1df5e4(rdram, ctx, runtime);
}

void entry_1df5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df5f0 inside entry_1df5e4 (0x1df5e4 - 0x1df600)
    ctx->pc = 0x1df5f0;
    entry_1df5e4(rdram, ctx, runtime);
}

void entry_1df67c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df67c inside ApplyTankThrow__FP4TANKP2PO (0x1df600 - 0x1df6b4)
    ctx->pc = 0x1df67c;
    ApplyTankThrow__FP4TANKP2PO(rdram, ctx, runtime);
}

void entry_1df748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df748 inside entry_1df73c (0x1df73c - 0x1df764)
    ctx->pc = 0x1df748;
    entry_1df73c(rdram, ctx, runtime);
}

void entry_1df7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df7e8 inside entry_1df788 (0x1df788 - 0x1df800)
    ctx->pc = 0x1df7e8;
    entry_1df788(rdram, ctx, runtime);
}

void entry_1df7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df7f8 inside entry_1df788 (0x1df788 - 0x1df800)
    ctx->pc = 0x1df7f8;
    entry_1df788(rdram, ctx, runtime);
}

void entry_1df814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df814 inside entry_1df800 (0x1df800 - 0x1df848)
    ctx->pc = 0x1df814;
    entry_1df800(rdram, ctx, runtime);
}

void entry_1df820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df820 inside entry_1df800 (0x1df800 - 0x1df848)
    ctx->pc = 0x1df820;
    entry_1df800(rdram, ctx, runtime);
}

void entry_1df938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df938 inside entry_1df91c (0x1df91c - 0x1df940)
    ctx->pc = 0x1df938;
    entry_1df91c(rdram, ctx, runtime);
}

void entry_1df948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df948 inside entry_1df940 (0x1df940 - 0x1df954)
    ctx->pc = 0x1df948;
    entry_1df940(rdram, ctx, runtime);
}

void entry_1df9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df9d0 inside entry_1df9c4 (0x1df9c4 - 0x1df9f0)
    ctx->pc = 0x1df9d0;
    entry_1df9c4(rdram, ctx, runtime);
}

void entry_1df9f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1df9f4 inside entry_1df9f0 (0x1df9f0 - 0x1dfa10)
    ctx->pc = 0x1df9f4;
    entry_1df9f0(rdram, ctx, runtime);
}

void entry_1dfac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfac0 inside entry_1dfa64 (0x1dfa64 - 0x1dfb08)
    ctx->pc = 0x1dfac0;
    entry_1dfa64(rdram, ctx, runtime);
}

void entry_1dfad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfad4 inside entry_1dfa64 (0x1dfa64 - 0x1dfb08)
    ctx->pc = 0x1dfad4;
    entry_1dfa64(rdram, ctx, runtime);
}

void entry_1dfaec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfaec inside entry_1dfa64 (0x1dfa64 - 0x1dfb08)
    ctx->pc = 0x1dfaec;
    entry_1dfa64(rdram, ctx, runtime);
}

void entry_1dfaf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfaf4 inside entry_1dfa64 (0x1dfa64 - 0x1dfb08)
    ctx->pc = 0x1dfaf4;
    entry_1dfa64(rdram, ctx, runtime);
}

void entry_1dfb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfb68 inside entry_1dfb60 (0x1dfb60 - 0x1dfbb8)
    ctx->pc = 0x1dfb68;
    entry_1dfb60(rdram, ctx, runtime);
}

void entry_1dfba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfba0 inside entry_1dfb60 (0x1dfb60 - 0x1dfbb8)
    ctx->pc = 0x1dfba0;
    entry_1dfb60(rdram, ctx, runtime);
}

void entry_1dfba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfba8 inside entry_1dfb60 (0x1dfb60 - 0x1dfbb8)
    ctx->pc = 0x1dfba8;
    entry_1dfb60(rdram, ctx, runtime);
}

void entry_1dfbac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfbac inside entry_1dfb60 (0x1dfb60 - 0x1dfbb8)
    ctx->pc = 0x1dfbac;
    entry_1dfb60(rdram, ctx, runtime);
}

void entry_1dfbb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfbb0 inside entry_1dfb60 (0x1dfb60 - 0x1dfbb8)
    ctx->pc = 0x1dfbb0;
    entry_1dfb60(rdram, ctx, runtime);
}

void entry_1dfc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfc20 inside SetTankTanks__FP4TANK5TANKS (0x1dfbe0 - 0x1dfc84)
    ctx->pc = 0x1dfc20;
    SetTankTanks__FP4TANK5TANKS(rdram, ctx, runtime);
}

void entry_1dfc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfc28 inside SetTankTanks__FP4TANK5TANKS (0x1dfbe0 - 0x1dfc84)
    ctx->pc = 0x1dfc28;
    SetTankTanks__FP4TANK5TANKS(rdram, ctx, runtime);
}

void entry_1dfc30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfc30 inside SetTankTanks__FP4TANK5TANKS (0x1dfbe0 - 0x1dfc84)
    ctx->pc = 0x1dfc30;
    SetTankTanks__FP4TANK5TANKS(rdram, ctx, runtime);
}

void entry_1dfc44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfc44 inside SetTankTanks__FP4TANK5TANKS (0x1dfbe0 - 0x1dfc84)
    ctx->pc = 0x1dfc44;
    SetTankTanks__FP4TANK5TANKS(rdram, ctx, runtime);
}

void entry_1dfc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfc64 inside SetTankTanks__FP4TANK5TANKS (0x1dfbe0 - 0x1dfc84)
    ctx->pc = 0x1dfc64;
    SetTankTanks__FP4TANK5TANKS(rdram, ctx, runtime);
}

void entry_1dfc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfc7c inside SetTankTanks__FP4TANK5TANKS (0x1dfbe0 - 0x1dfc84)
    ctx->pc = 0x1dfc7c;
    SetTankTanks__FP4TANK5TANKS(rdram, ctx, runtime);
}

void entry_1dfc8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfc8c inside entry_1dfc84 (0x1dfc84 - 0x1dfc98)
    ctx->pc = 0x1dfc8c;
    entry_1dfc84(rdram, ctx, runtime);
}

void entry_1dfca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfca0 inside entry_1dfc98 (0x1dfc98 - 0x1dfcac)
    ctx->pc = 0x1dfca0;
    entry_1dfc98(rdram, ctx, runtime);
}

void entry_1dfcb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfcb4 inside entry_1dfcac (0x1dfcac - 0x1dfcbc)
    ctx->pc = 0x1dfcb4;
    entry_1dfcac(rdram, ctx, runtime);
}

void entry_1dfcc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfcc4 inside entry_1dfcbc (0x1dfcbc - 0x1dfd10)
    ctx->pc = 0x1dfcc4;
    entry_1dfcbc(rdram, ctx, runtime);
}

void entry_1dfccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfccc inside entry_1dfcbc (0x1dfcbc - 0x1dfd10)
    ctx->pc = 0x1dfccc;
    entry_1dfcbc(rdram, ctx, runtime);
}

void entry_1dfcf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfcf0 inside entry_1dfcbc (0x1dfcbc - 0x1dfd10)
    ctx->pc = 0x1dfcf0;
    entry_1dfcbc(rdram, ctx, runtime);
}

void entry_1dfd18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfd18 inside entry_1dfd10 (0x1dfd10 - 0x1dfd48)
    ctx->pc = 0x1dfd18;
    entry_1dfd10(rdram, ctx, runtime);
}

void entry_1dfd1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfd1c inside entry_1dfd10 (0x1dfd10 - 0x1dfd48)
    ctx->pc = 0x1dfd1c;
    entry_1dfd10(rdram, ctx, runtime);
}

void entry_1dfd20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfd20 inside entry_1dfd10 (0x1dfd10 - 0x1dfd48)
    ctx->pc = 0x1dfd20;
    entry_1dfd10(rdram, ctx, runtime);
}

void entry_1dfd30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfd30 inside entry_1dfd10 (0x1dfd10 - 0x1dfd48)
    ctx->pc = 0x1dfd30;
    entry_1dfd10(rdram, ctx, runtime);
}

void entry_1dfe90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfe90 inside get_commentary_data_by_level_id (0x1dfe80 - 0x1dfeb8)
    ctx->pc = 0x1dfe90;
    get_commentary_data_by_level_id(rdram, ctx, runtime);
}

void entry_1dfea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dfea0 inside get_commentary_data_by_level_id (0x1dfe80 - 0x1dfeb8)
    ctx->pc = 0x1dfea0;
    get_commentary_data_by_level_id(rdram, ctx, runtime);
}

void entry_1dff28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dff28 inside entry_1dfefc (0x1dfefc - 0x1dff74)
    ctx->pc = 0x1dff28;
    entry_1dfefc(rdram, ctx, runtime);
}

void entry_1dff3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dff3c inside entry_1dfefc (0x1dfefc - 0x1dff74)
    ctx->pc = 0x1dff3c;
    entry_1dfefc(rdram, ctx, runtime);
}

void entry_1dff48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dff48 inside entry_1dfefc (0x1dfefc - 0x1dff74)
    ctx->pc = 0x1dff48;
    entry_1dfefc(rdram, ctx, runtime);
}

void entry_1dff60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dff60 inside entry_1dfefc (0x1dfefc - 0x1dff74)
    ctx->pc = 0x1dff60;
    entry_1dfefc(rdram, ctx, runtime);
}

void entry_1dff80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dff80 inside entry_1dff74 (0x1dff74 - 0x1dff90)
    ctx->pc = 0x1dff80;
    entry_1dff74(rdram, ctx, runtime);
}

void entry_1dff88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dff88 inside entry_1dff74 (0x1dff74 - 0x1dff90)
    ctx->pc = 0x1dff88;
    entry_1dff74(rdram, ctx, runtime);
}

void entry_1dffb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1dffb0 inside entry_1dffa8 (0x1dffa8 - 0x1dffc4)
    ctx->pc = 0x1dffb0;
    entry_1dffa8(rdram, ctx, runtime);
}

