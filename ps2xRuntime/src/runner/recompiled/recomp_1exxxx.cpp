// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_1e000c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e000c) {
        switch (ctx->pc) {
            case 0x1e0010: ctx->pc = 0; goto label_1e0010;
            case 0x1e0038: ctx->pc = 0; goto label_1e0038;
            case 0x1e0044: ctx->pc = 0; goto label_1e0044;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e000c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1e0010:
    // 0x1e0010: 0x8c4423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1e0014: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e0018: 0x30630008
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 8));
    // 0x1e001c: 0x1060001b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E008C; return;
    }
    // 0x1e0024: 0x8c422310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8976)));
    // 0x1e0028: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
        goto label_1e0038;
    }
    // 0x1e0030: 0x10000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e0044;
    }
label_1e0038:
    // 0x1e0038: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x1e003c: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1e0040: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1e0044:
    // 0x1e0044: 0x10400011
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E008C; return;
    }
    // 0x1e004c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e0050: 0x24a5e140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294959424));
    // 0x1e0054: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1e0058: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e0060);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e0060
// Address: 0x1e0060 - 0x1e0070

void entry_1e0060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0060: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1e0064: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e0068: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1e0070);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1e0070
// Address: 0x1e0070 - 0x1e0080

void entry_1e0070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0070: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e0074: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1e0078: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e0080);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e0080
// Address: 0x1e0080 - 0x1e00b0

void entry_1e0080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0080) {
        switch (ctx->pc) {
            case 0x1e008c: ctx->pc = 0; goto label_1e008c;
            case 0x1e0090: ctx->pc = 0; goto label_1e0090;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0080: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0084: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 17), 620), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e0090;
    }
label_1e008c:
    // 0x1e008c: 0xae20026c
    WRITE32(ADD32(GPR_U32(ctx, 17), 620), GPR_U32(ctx, 0));
label_1e0090:
    // 0x1e0090: 0xae200270
    WRITE32(ADD32(GPR_U32(ctx, 17), 624), GPR_U32(ctx, 0));
    // 0x1e0094: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e0098: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e009c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e00a0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e00a4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e00a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001e00b0
// Address: 0x1e00b0 - 0x1e00cc

void FUN_001e00b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e00b0: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1e00b4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1e00b8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1e00bc: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1e00c0: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1e00c4: 0xc06a8a6
    SET_GPR_U32(ctx, 31, 0x1e00cc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    UpdateBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1e00cc
// Address: 0x1e00cc - 0x1e0118

void entry_1e00cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e00cc) {
        switch (ctx->pc) {
            case 0x1e00f4: ctx->pc = 0; goto label_1e00f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e00cc: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1e00d0: 0x4600076
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_S32(ctx, 3) < 0) {
        entry_1e02ac(rdram, ctx, runtime); return;
    }
    // 0x1e00d8: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 620)));
        goto label_1e00f4;
    }
    // 0x1e00e0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e00e4: 0x10620032
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E01B0; return;
    }
    // 0x1e00ec: 0x10000071
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E02B4; return;
    }
label_1e00f4:
    // 0x1e00f4: 0x1040006d
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e02ac(rdram, ctx, runtime); return;
    }
    // 0x1e00fc: 0x24642c70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 11376));
    // 0x1e0100: 0x948200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 4), 170)));
    // 0x1e0104: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x1e0108: 0x1040001b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0178; return;
    }
    // 0x1e0110: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1e0118);
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1e0118
// Address: 0x1e0118 - 0x1e0124

void entry_1e0118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0118: 0x8e225710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    // 0x1e011c: 0xc06f97e
    SET_GPR_U32(ctx, 31, 0x1e0124);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 8976)));
    PreloadVag__FPc2FK(rdram, ctx, runtime); return;
}


// Function: entry_1e0124
// Address: 0x1e0124 - 0x1e0144

void entry_1e0124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0124: 0x8e225710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    // 0x1e0128: 0x8c432314
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8980)));
    // 0x1e012c: 0x5060000d
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1E0164; return;
    }
    // 0x1e0134: 0x3c014170
    SET_GPR_U32(ctx, 1, ((uint32_t)16752 << 16));
    // 0x1e0138: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e013c: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1e0144);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1e0144
// Address: 0x1e0144 - 0x1e015c

void entry_1e0144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0144: 0x8e265710
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    // 0x1e0148: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e014c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e0150: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1e0154: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e015c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 8980)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e015c
// Address: 0x1e015c - 0x1e0170

void entry_1e015c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e015c) {
        switch (ctx->pc) {
            case 0x1e0164: ctx->pc = 0; goto label_1e0164;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e015c: 0x10000053
    WRITE32(ADD32(GPR_U32(ctx, 16), 620), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e02ac(rdram, ctx, runtime); return;
    }
label_1e0164:
    // 0x1e0164: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e0168: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e0170);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e0170
// Address: 0x1e0170 - 0x1e01a8

void entry_1e0170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0170) {
        switch (ctx->pc) {
            case 0x1e0178: ctx->pc = 0; goto label_1e0178;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0170: 0x1000004e
    WRITE32(ADD32(GPR_U32(ctx, 16), 620), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e02ac(rdram, ctx, runtime); return;
    }
label_1e0178:
    // 0x1e0178: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e017c: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1e0180: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e0184: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1e0188: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e018c: 0x0
    // NOP
    // 0x1e0190: 0x45000047
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E02B0; return;
    }
    // 0x1e0198: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e019c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e01a0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e01a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e01a8
// Address: 0x1e01a8 - 0x1e01d0

void entry_1e01a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e01a8) {
        switch (ctx->pc) {
            case 0x1e01b0: ctx->pc = 0; goto label_1e01b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e01a8: 0x10000040
    WRITE32(ADD32(GPR_U32(ctx, 16), 620), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e02ac(rdram, ctx, runtime); return;
    }
label_1e01b0:
    // 0x1e01b0: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e01b4: 0x2471e760
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 3), 4294960992));
    // 0x1e01b8: 0x8e220260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    // 0x1e01bc: 0x14400006
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E01D8; return;
    }
    // 0x1e01c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e01c8: 0xc0780b2
    SET_GPR_U32(ctx, 31, 0x1e01d0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    gui_set_widget_modeQMARK(rdram, ctx, runtime); return;
}


// Function: entry_1e01d0
// Address: 0x1e01d0 - 0x1e01f4

void entry_1e01d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e01d0) {
        switch (ctx->pc) {
            case 0x1e01d8: ctx->pc = 0; goto label_1e01d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e01d0: 0x10000037
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E02B0; return;
    }
label_1e01d8:
    // 0x1e01d8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e01dc: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1e01e0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e01e4: 0xc44d23dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 9180)); ctx->f[13] = *(float*)&val; }
    // 0x1e01e8: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
    // 0x1e01ec: 0xc08171e
    SET_GPR_U32(ctx, 31, 0x1e01f4);
    powf(rdram, ctx, runtime); return;
}


// Function: entry_1e01f4
// Address: 0x1e01f4 - 0x1e0200

void entry_1e01f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e01f4: 0x46000307
    ctx->f[12] = FPU_NEG_S(ctx->f[0]);
    // 0x1e01f8: 0xc06ae48
    SET_GPR_U32(ctx, 31, 0x1e0200);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetTimerSpeed__FP5TIMERf(rdram, ctx, runtime); return;
}


// Function: entry_1e0200
// Address: 0x1e0200 - 0x1e0208

void entry_1e0200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0200: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x1e0208);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e0208
// Address: 0x1e0208 - 0x1e0220

void entry_1e0208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0208: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e020c: 0x12000006
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4294960992)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0228; return;
    }
    // 0x1e0214: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1e0218: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e0220);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e0220
// Address: 0x1e0220 - 0x1e0234

void entry_1e0220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0220) {
        switch (ctx->pc) {
            case 0x1e0228: ctx->pc = 0; goto label_1e0228;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0220: 0x10000005
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0238; return;
    }
label_1e0228:
    // 0x1e0228: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e022c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e0234);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e0234
// Address: 0x1e0234 - 0x1e0294

void entry_1e0234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0234) {
        switch (ctx->pc) {
            case 0x1e0238: ctx->pc = 0; goto label_1e0238;
            case 0x1e027c: ctx->pc = 0; goto label_1e027c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0234: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
label_1e0238:
    // 0x1e0238: 0x8c6423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 9160)));
    // 0x1e023c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e0240: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1e0244: 0x1040001a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E02B0; return;
    }
    // 0x1e024c: 0x1200000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1e027c;
    }
    // 0x1e0254: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e0258: 0x8c4301c4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 452)));
    // 0x1e025c: 0x14600007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 4294960992));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1e027c;
    }
    // 0x1e0264: 0xc4810008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1e0268: 0xc4400268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 616)); ctx->f[0] = *(float*)&val; }
    // 0x1e026c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e0270: 0x0
    // NOP
    // 0x1e0274: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1e027c;
    }
label_1e027c:
    // 0x1e027c: 0x10a00007
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E029C; return;
    }
    // 0x1e0284: 0x8c83e9f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294961656)));
    // 0x1e0288: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1e028c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e0294);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294961656));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e0294
// Address: 0x1e0294 - 0x1e02ac

void entry_1e0294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0294) {
        switch (ctx->pc) {
            case 0x1e029c: ctx->pc = 0; goto label_1e029c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0294: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E02B0; return;
    }
label_1e029c:
    // 0x1e029c: 0x8c83e9f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294961656)));
    // 0x1e02a0: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e02a4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e02ac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294961656));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e02ac
// Address: 0x1e02ac - 0x1e02c8

void entry_1e02ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e02ac) {
        switch (ctx->pc) {
            case 0x1e02b0: ctx->pc = 0; goto label_1e02b0;
            case 0x1e02b4: ctx->pc = 0; goto label_1e02b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e02ac: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1e02b0:
    // 0x1e02b0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1e02b4:
    // 0x1e02b4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e02b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e02bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e02c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e02c8; return;
}


// Function: gui_set_widget_modeQMARK
// Address: 0x1e02c8 - 0x1e0330

void entry_1e0330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0330) {
        switch (ctx->pc) {
            case 0x1e0338: ctx->pc = 0; goto label_1e0338;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0330: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 620), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e0364(rdram, ctx, runtime); return;
    }
label_1e0338:
    // 0x1e0338: 0x2611e760
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 4294960992));
    // 0x1e033c: 0xc06ae56
    SET_GPR_U32(ctx, 31, 0x1e0344);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    StopTimer__FP5TIMER(rdram, ctx, runtime); return;
}


// Function: entry_1e0344
// Address: 0x1e0344 - 0x1e0354

void entry_1e0344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0344: 0x8e03e760
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294960992)));
    // 0x1e0348: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e034c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e0354);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e0354
// Address: 0x1e0354 - 0x1e0364

void entry_1e0354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0354: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1e0358: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e035c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e0364);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e0364
// Address: 0x1e0364 - 0x1e03cc

void entry_1e0364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0364) {
        switch (ctx->pc) {
            case 0x1e0368: ctx->pc = 0; goto label_1e0368;
            case 0x1e0380: ctx->pc = 0; goto label_1e0380;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0364: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_1e0368:
    // 0x1e0368: 0x12620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        goto label_1e0380;
    }
    // 0x1e0370: 0x12620074
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E0544; return;
    }
    // 0x1e0378: 0x100000ab
    WRITE32(ADD32(GPR_U32(ctx, 18), 608), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0628; return;
    }
label_1e0380:
    // 0x1e0380: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1e0384: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e0388: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e038c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1e0390: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e0394: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1e0398: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e039c: 0x4600a3c6
    ctx->f[15] = FPU_MOV_S(ctx->f[20]);
    // 0x1e03a0: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1e03a4: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1e03a8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e03ac: 0x4600a406
    ctx->f[16] = FPU_MOV_S(ctx->f[20]);
    // 0x1e03b0: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x1e03b4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e03b8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e03bc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e03c0: 0x2404006d
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 109));
    // 0x1e03c4: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1e03cc);
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1e03cc
// Address: 0x1e03cc - 0x1e03d4

void entry_1e03cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e03cc: 0xc058312
    SET_GPR_U32(ctx, 31, 0x1e03d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetCcharm__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1e03d4
// Address: 0x1e03d4 - 0x1e03dc

void entry_1e03d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e03d4: 0xc0776b4
    SET_GPR_U32(ctx, 31, 0x1e03dc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    CancelSwDialogPlaying__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1e03dc
// Address: 0x1e03dc - 0x1e0404

void entry_1e03dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e03dc: 0x8e225710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    // 0x1e03e0: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1e03e4: 0x3c013f7d
    SET_GPR_U32(ctx, 1, ((uint32_t)16253 << 16));
    // 0x1e03e8: 0x342170a4
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 28836));
    // 0x1e03ec: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e03f0: 0x2610e760
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294960992));
    // 0x1e03f4: 0xc44c230c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8972)); ctx->f[12] = *(float*)&val; }
    // 0x1e03f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e03fc: 0xc06ae24
    SET_GPR_U32(ctx, 31, 0x1e0404);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    SetTimer__FP5TIMERf(rdram, ctx, runtime); return;
}


// Function: entry_1e0404
// Address: 0x1e0404 - 0x1e0420

void entry_1e0404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0404: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e0408: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1e040c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e0410: 0xc44d23dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 9180)); ctx->f[13] = *(float*)&val; }
    // 0x1e0414: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
    // 0x1e0418: 0xc08171e
    SET_GPR_U32(ctx, 31, 0x1e0420);
    powf(rdram, ctx, runtime); return;
}


// Function: entry_1e0420
// Address: 0x1e0420 - 0x1e042c

void entry_1e0420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0420: 0x46000307
    ctx->f[12] = FPU_NEG_S(ctx->f[0]);
    // 0x1e0424: 0xc06ae48
    SET_GPR_U32(ctx, 31, 0x1e042c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetTimerSpeed__FP5TIMERf(rdram, ctx, runtime); return;
}


// Function: entry_1e042c
// Address: 0x1e042c - 0x1e043c

void entry_1e042c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e042c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1e0430: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e0434: 0xc06ae4a
    SET_GPR_U32(ctx, 31, 0x1e043c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTimerExpire__FP5TIMERfPv(rdram, ctx, runtime); return;
}


// Function: entry_1e043c
// Address: 0x1e043c - 0x1e0444

void entry_1e043c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e043c: 0xc06ae4e
    SET_GPR_U32(ctx, 31, 0x1e0444);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    StartTimer__FP5TIMER(rdram, ctx, runtime); return;
}


// Function: entry_1e0444
// Address: 0x1e0444 - 0x1e0498

void entry_1e0444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0444: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1e0448: 0x8c6623c8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 9160)));
    // 0x1e044c: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1e0450: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1e0454: 0x1040002b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0504; return;
    }
    // 0x1e045c: 0xc4c10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1e0460: 0x46150834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e0464: 0x0
    // NOP
    // 0x1e0468: 0x4500000d
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E04A0; return;
    }
    // 0x1e0470: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1e0474: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e0478: 0x24445900
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 22784));
    // 0x1e047c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e0480: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1e0484: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1e0488: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e048c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1e0490: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1e0498);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294959464));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1e0498
// Address: 0x1e0498 - 0x1e04dc

void entry_1e0498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0498) {
        switch (ctx->pc) {
            case 0x1e04a0: ctx->pc = 0; goto label_1e04a0;
            case 0x1e04bc: ctx->pc = 0; goto label_1e04bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0498: 0x10000010
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e04dc(rdram, ctx, runtime); return;
    }
label_1e04a0:
    // 0x1e04a0: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e04a4: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1e04a8: 0x3c080027
    SET_GPR_U32(ctx, 8, ((uint32_t)39 << 16));
    // 0x1e04ac: 0x2402003c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 60));
    // 0x1e04b0: 0x2403003c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 60));
    // 0x1e04b4: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1e04bc;
    }
label_1e04bc:
    // 0x1e04bc: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1e04c0: 0xc2001a
    { int32_t divisor = GPR_S32(ctx, 2); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 6) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 2) % divisor); } else { ctx->lo = (GPR_S32(ctx,6) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,2); } }
    // 0x1e04c4: 0x24a5e180
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294959488));
    // 0x1e04c8: 0x25045900
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 8), 22784));
    // 0x1e04cc: 0x3012
    SET_GPR_U32(ctx, 6, ctx->lo);
    // 0x1e04d0: 0x3810
    SET_GPR_U32(ctx, 7, ctx->hi);
    // 0x1e04d4: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x1e04dc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_1e04dc
// Address: 0x1e04dc - 0x1e04e8

void entry_1e04dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e04dc: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1e04e0: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1e04e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1e04e8
// Address: 0x1e04e8 - 0x1e04fc

void entry_1e04e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e04e8: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1e04ec: 0x26055900
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 22784));
    // 0x1e04f0: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1e04f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e04fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e04fc
// Address: 0x1e04fc - 0x1e0514

void entry_1e04fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e04fc) {
        switch (ctx->pc) {
            case 0x1e0504: ctx->pc = 0; goto label_1e0504;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e04fc: 0x1000000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0530; return;
    }
label_1e0504:
    // 0x1e0504: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1e0508: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e050c: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x1e0514);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_1e0514
// Address: 0x1e0514 - 0x1e052c

void entry_1e0514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0514: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1e0518: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1e051c: 0x24a5e198
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294959512));
    // 0x1e0520: 0x8c430020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1e0524: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1e052c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1e052c
// Address: 0x1e052c - 0x1e053c

void entry_1e052c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e052c) {
        switch (ctx->pc) {
            case 0x1e0530: ctx->pc = 0; goto label_1e0530;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e052c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_1e0530:
    // 0x1e0530: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1e0534: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e053c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e053c
// Address: 0x1e053c - 0x1e0598

void entry_1e053c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e053c) {
        switch (ctx->pc) {
            case 0x1e0544: ctx->pc = 0; goto label_1e0544;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e053c: 0x1000003a
    WRITE32(ADD32(GPR_U32(ctx, 18), 608), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0628; return;
    }
label_1e0544:
    // 0x1e0544: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1e0548: 0x2446e760
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294960992));
    // 0x1e054c: 0xc4c10268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 616)); ctx->f[1] = *(float*)&val; }
    // 0x1e0550: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e0554: 0x0
    // NOP
    // 0x1e0558: 0x45000027
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E05F8; return;
    }
    // 0x1e0560: 0x8c4523c8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1e0564: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1e0568: 0x30620008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 8));
    // 0x1e056c: 0x1040000e
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E05A8; return;
    }
    // 0x1e0574: 0xc4a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1e0578: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e057c: 0x0
    // NOP
    // 0x1e0580: 0x45000007
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E05A0; return;
    }
    // 0x1e0588: 0xe4a10008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 5), 8), *(uint32_t*)&val); }
    // 0x1e058c: 0x24844a40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    // 0x1e0590: 0xc0631fe
    SET_GPR_U32(ctx, 31, 0x1e0598);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 29));
    FUN_0018c7f8__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_1e0598
// Address: 0x1e0598 - 0x1e05d0

void entry_1e0598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0598) {
        switch (ctx->pc) {
            case 0x1e05a0: ctx->pc = 0; goto label_1e05a0;
            case 0x1e05a8: ctx->pc = 0; goto label_1e05a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0598: 0x1000001e
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0614; return;
    }
label_1e05a0:
    // 0x1e05a0: 0x1000001b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 30));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0610; return;
    }
label_1e05a8:
    // 0x1e05a8: 0x2410001b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 27));
    // 0x1e05ac: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x1e05b0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1e05b4: 0x8c6423c4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 9156)));
    // 0x1e05b8: 0xc4c00268
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 616)); ctx->f[0] = *(float*)&val; }
    // 0x1e05bc: 0xe4a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 8), *(uint32_t*)&val); }
    // 0x1e05c0: 0x8c820440
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1088)));
    // 0x1e05c4: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1e05c8: 0xc0580a8
    SET_GPR_U32(ctx, 31, 0x1e05d0);
    WRITE32(ADD32(GPR_U32(ctx, 4), 1088), GPR_U32(ctx, 2));
    get_game_completion__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e05d0
// Address: 0x1e05d0 - 0x1e05e4

void entry_1e05d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e05d0: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1e05d4: 0x5040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
        ctx->pc = 0x1E0614; return;
    }
    // 0x1e05dc: 0xc05812e
    SET_GPR_U32(ctx, 31, 0x1e05e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    UnlockEndgameCutscenesFromFgs(rdram, ctx, runtime); return;
}


// Function: entry_1e05e4
// Address: 0x1e05e4 - 0x1e05f0

void entry_1e05e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e05e4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1e05e8: 0xc0631fe
    SET_GPR_U32(ctx, 31, 0x1e05f0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c7f8__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_1e05f0
// Address: 0x1e05f0 - 0x1e0624

void entry_1e05f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e05f0) {
        switch (ctx->pc) {
            case 0x1e05f8: ctx->pc = 0; goto label_1e05f8;
            case 0x1e0610: ctx->pc = 0; goto label_1e0610;
            case 0x1e0614: ctx->pc = 0; goto label_1e0614;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e05f0: 0x10000008
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e0614;
    }
label_1e05f8:
    // 0x1e05f8: 0x2410001c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1e05fc: 0x8c4323c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1e0600: 0x2404001e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 30));
    // 0x1e0604: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e0608: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x1e060c: 0x82800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 4));
label_1e0610:
    // 0x1e0610: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
label_1e0614:
    // 0x1e0614: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e0618: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x1e061c: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1e0624);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1e0624
// Address: 0x1e0624 - 0x1e0648

void entry_1e0624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0624) {
        switch (ctx->pc) {
            case 0x1e0628: ctx->pc = 0; goto label_1e0628;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0624: 0xae530260
    WRITE32(ADD32(GPR_U32(ctx, 18), 608), GPR_U32(ctx, 19));
label_1e0628:
    // 0x1e0628: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e062c: 0x8e430258
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 600)));
    // 0x1e0630: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1e0634: 0x16620004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 612), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        entry_1e0648(rdram, ctx, runtime); return;
    }
    // 0x1e063c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e0640: 0xc052338
    SET_GPR_U32(ctx, 31, 0x1e0648);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    RemoveSwExtraneousCharms__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1e0648
// Address: 0x1e0648 - 0x1e0678

void entry_1e0648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0648) {
        switch (ctx->pc) {
            case 0x1e0654: ctx->pc = 0; goto label_1e0654;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0648: 0x8e420260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    // 0x1e064c: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1e0650: 0xae420268
    WRITE32(ADD32(GPR_U32(ctx, 18), 616), GPR_U32(ctx, 2));
label_1e0654:
    // 0x1e0654: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e0658: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e065c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e0660: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e0664: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e0668: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x1e066c: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x1e0670: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001e0678
// Address: 0x1e0678 - 0x1e06b4

void FUN_001e0678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0678: 0x27bdfec0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966976));
    // 0x1e067c: 0x7fb10100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 17));
    // 0x1e0680: 0x7fbf0120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 31));
    // 0x1e0684: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1e0688: 0x7fb20110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 18));
    // 0x1e068c: 0x7fb000f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 16));
    // 0x1e0690: 0xe7b50138
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 312), *(uint32_t*)&val); }
    // 0x1e0694: 0xe7b40130
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 304), *(uint32_t*)&val); }
    // 0x1e0698: 0x82220008
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1e069c: 0x10400057
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e07fc(rdram, ctx, runtime); return;
    }
    // 0x1e06a4: 0xc62c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
    // 0x1e06a8: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1e06ac: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x1e06b4);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_1e06b4
// Address: 0x1e06b4 - 0x1e071c

void entry_1e06b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e06b4: 0x8a22020b
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 523); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1e06b8: 0x9a220208
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 520); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1e06bc: 0xaba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e06c0: 0xbba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e06c4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e06c8: 0x3c014284
    SET_GPR_U32(ctx, 1, ((uint32_t)17028 << 16));
    // 0x1e06cc: 0x3421ccce
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52430));
    // 0x1e06d0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e06d4: 0x93a20003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 3)));
    // 0x1e06d8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e06dc: 0xc623023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 572)); ctx->f[3] = *(float*)&val; }
    // 0x1e06e0: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1e06e4: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1e06e8: 0xc46d240c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 9228)); ctx->f[13] = *(float*)&val; }
    // 0x1e06ec: 0xc6220228
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 552)); ctx->f[2] = *(float*)&val; }
    // 0x1e06f0: 0x46006b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[0]);
    // 0x1e06f4: 0xc62c0224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 548)); ctx->f[12] = *(float*)&val; }
    // 0x1e06f8: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1e06fc: 0xc6340234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 564)); ctx->f[20] = *(float*)&val; }
    // 0x1e0700: 0xc6350238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 568)); ctx->f[21] = *(float*)&val; }
    // 0x1e0704: 0x460d1341
    ctx->f[13] = FPU_SUB_S(ctx->f[2], ctx->f[13]);
    // 0x1e0708: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e070c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e0710: 0xa3a20003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e0714: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x1e071c);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1e071c
// Address: 0x1e071c - 0x1e072c

void entry_1e071c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e071c: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e0720: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1e0724: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1e072c);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1e072c
// Address: 0x1e072c - 0x1e073c

void entry_1e072c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e072c: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e0730: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1e0734: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1e073c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1e073c
// Address: 0x1e073c - 0x1e0748

void entry_1e073c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e073c: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e0740: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1e0748);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1e0748
// Address: 0x1e0748 - 0x1e0754

void entry_1e0748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0748: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e074c: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1e0754);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1e0754
// Address: 0x1e0754 - 0x1e07b8

void entry_1e0754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0754: 0x8e230210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1e0758: 0x1060001d
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E07D0; return;
    }
    // 0x1e0760: 0x8862001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 27); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1e0764: 0x98620018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1e0768: 0xaba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e076c: 0xbba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e0770: 0x9062001b
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 27)));
    // 0x1e0774: 0xc621023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 572)); ctx->f[1] = *(float*)&val; }
    // 0x1e0778: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1e077c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e0780: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1e0784: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e0788: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e078c: 0xa062001b
    WRITE8(ADD32(GPR_U32(ctx, 3), 27), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e0790: 0x8e250210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1e0794: 0x8ca80000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1e0798: 0x11000007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 8832));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_1e07b8(rdram, ctx, runtime); return;
    }
    // 0x1e07a0: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x1e07a4: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e07a8: 0x84440048
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1e07ac: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x1e07b0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1e07b8);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1e07b8
// Address: 0x1e07b8 - 0x1e07e0

void entry_1e07b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e07b8) {
        switch (ctx->pc) {
            case 0x1e07d0: ctx->pc = 0; goto label_1e07d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e07b8: 0x8e220210
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x1e07bc: 0x8ba30033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x1e07c0: 0x9ba30030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x1e07c4: 0xa843001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 27); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e07c8: 0xb8430018
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 24); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e07cc: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
label_1e07d0:
    // 0x1e07d0: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1e07d4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e07d8: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1e07e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1e07e0
// Address: 0x1e07e0 - 0x1e07f4

void entry_1e07e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e07e0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e07e4: 0x26472280
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 8832));
    // 0x1e07e8: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e07ec: 0xc0578c6
    SET_GPR_U32(ctx, 31, 0x1e07f4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Draw__9CRichTextP8CTextBoxT1P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1e07f4
// Address: 0x1e07f4 - 0x1e07fc

void entry_1e07f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e07f4: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1e07fc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1e07fc
// Address: 0x1e07fc - 0x1e0828

void entry_1e07fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e07fc: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1e0800: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1e0804: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1e0808: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1e080c: 0xc7b50138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[21] = *(float*)&val; }
    // 0x1e0810: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x1e0814: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e081c: 0x0
    // NOP
    // 0x1e0820: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e0824: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e0828; return;
}


// Function: gui_set_mode_3
// Address: 0x1e0828 - 0x1e0838

void entry_1e0838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0838: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e083c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e0844: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e0848; return;
}


// Function: FUN_001e0848
// Address: 0x1e0848 - 0x1e0878

void FUN_001e0848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0848: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1e084c: 0x3402ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    // 0x1e0850: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1e0854: 0x14a20018
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E08B8; return;
    }
    // 0x1e085c: 0x10800016
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E08B8; return;
    }
    // 0x1e0864: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e0868: 0x261058e0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 22752));
    // 0x1e086c: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1e0870: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1e0878);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1e0878
// Address: 0x1e0878 - 0x1e08ec

void entry_1e0878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0878) {
        switch (ctx->pc) {
            case 0x1e08b8: ctx->pc = 0; goto label_1e08b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0878: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x1e087c: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1e0880: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e0884: 0x3c02ff7d
    SET_GPR_U32(ctx, 2, ((uint32_t)65405 << 16));
    // 0x1e0888: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1e088c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e0890: 0x2403002d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 45));
    // 0x1e0894: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e0898: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e089c: 0x34424b00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 19200));
    // 0x1e08a0: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    // 0x1e08a4: 0xa2030004
    WRITE8(ADD32(GPR_U32(ctx, 16), 4), (uint8_t)GPR_U32(ctx, 3));
    // 0x1e08a8: 0xe6010008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1e08ac: 0xe600000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x1e08b0: 0xe6020014
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x1e08b4: 0xe6020010
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
label_1e08b8:
    // 0x1e08b8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e08bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e08c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e08c8: 0xe48c0000
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x1e08cc: 0x0
    // NOP
    // 0x1e08d0: 0xe48c0008
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 4), 8), *(uint32_t*)&val); }
    // 0x1e08d4: 0x0
    // NOP
    // 0x1e08d8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1e08dc: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e08e0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1e08e4: 0xc078212
    SET_GPR_U32(ctx, 31, 0x1e08ec);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    FUN_001e0848(rdram, ctx, runtime); return;
}


// Function: entry_1e08ec
// Address: 0x1e08ec - 0x1e08f8

void entry_1e08ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e08ec: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e08f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CchParsePchzInt__FPcPi
// Address: 0x1e08f8 - 0x1e0978

void entry_1e09b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e09b4) {
        switch (ctx->pc) {
            case 0x1e09c8: ctx->pc = 0; goto label_1e09c8;
            case 0x1e0a1c: ctx->pc = 0; goto label_1e0a1c;
            case 0x1e0aa8: ctx->pc = 0; goto label_1e0aa8;
            case 0x1e0ae0: ctx->pc = 0; goto label_1e0ae0;
            case 0x1e0aec: ctx->pc = 0; goto label_1e0aec;
            case 0x1e0af4: ctx->pc = 0; goto label_1e0af4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e09b4: 0x82820000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1e09b8: 0x104000bc
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0CAC; return;
    }
    // 0x1e09c0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e09c4: 0x0
    // NOP
label_1e09c8:
    // 0x1e09c8: 0x2ca20006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), 6));
    // 0x1e09cc: 0x104000b7
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0CAC; return;
    }
    // 0x1e09d4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e09d8: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x1e09dc: 0x2442e1c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294959552));
    // 0x1e09e0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1e09e4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e09e8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1e09f0: 0x82230000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e09f4: 0x24020025
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 37));
    // 0x1e09f8: 0x146200a5
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E0C90; return;
    }
    // 0x1e0a00: 0x82220001
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 1)));
    // 0x1e0a04: 0x14430005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_1e0a1c;
    }
    // 0x1e0a0c: 0xa202002c
    WRITE8(ADD32(GPR_U32(ctx, 16), 44), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e0a10: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1e0a14: 0x1000009e
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0C90; return;
    }
label_1e0a1c:
    // 0x1e0a1c: 0x1000009c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0C90; return;
    }
    // 0x1e0a24: 0x92220000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e0a28: 0x2442ffe0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967264));
    // 0x1e0a2c: 0x21600
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 24));
    // 0x1e0a30: 0x22603
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 2), 24));
    // 0x1e0a34: 0x2c830011
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 17));
    // 0x1e0a38: 0x1060001b
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1e0aa8;
    }
    // 0x1e0a40: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1e0a44: 0x2442e1e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294959584));
    // 0x1e0a48: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1e0a4c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e0a50: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1e0a58: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0a5c: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0a60: 0x1000008b
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0C90; return;
    }
    // 0x1e0a68: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0a6c: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0a70: 0x10000087
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0C90; return;
    }
    // 0x1e0a78: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0a7c: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0a80: 0x10000083
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0C90; return;
    }
    // 0x1e0a88: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0a8c: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0a90: 0x1000007f
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0C90; return;
    }
    // 0x1e0a98: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0a9c: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0aa0: 0x1000007b
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0C90; return;
    }
label_1e0aa8:
    // 0x1e0aa8: 0x10000079
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0C90; return;
    }
    // 0x1e0ab0: 0x82230000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e0ab4: 0x2402002a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 42));
    // 0x1e0ab8: 0x1462000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e0af4;
    }
    // 0x1e0ac0: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1e0ac4: 0x24620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1e0ac8: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x1e0acc: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e0ad0: 0x4610006
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 3) >= 0) {
        goto label_1e0aec;
    }
    // 0x1e0ad8: 0x4620001
    if (GPR_S32(ctx, 3) < 0) {
        SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
        goto label_1e0ae0;
    }
label_1e0ae0:
    // 0x1e0ae0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0ae4: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1e0ae8: 0xae030018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 3));
label_1e0aec:
    // 0x1e0aec: 0x10000004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0B00; return;
    }
label_1e0af4:
    // 0x1e0af4: 0xc07823e
    SET_GPR_U32(ctx, 31, 0x1e0afc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 24));
    CchParsePchzInt__FPcPi(rdram, ctx, runtime); return;
}


// Function: entry_1e0afc
// Address: 0x1e0afc - 0x1e0b5c

void entry_1e0afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0afc) {
        switch (ctx->pc) {
            case 0x1e0b00: ctx->pc = 0; goto label_1e0b00;
            case 0x1e0b4c: ctx->pc = 0; goto label_1e0b4c;
            case 0x1e0b54: ctx->pc = 0; goto label_1e0b54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0afc: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1e0b00:
    // 0x1e0b00: 0x2281021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 8)));
    // 0x1e0b04: 0x2404002e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 46));
    // 0x1e0b08: 0x80430000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e0b0c: 0x14640060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x1E0C90; return;
    }
    // 0x1e0b14: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1e0b18: 0x1000005d
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0C90; return;
    }
    // 0x1e0b20: 0x82230000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e0b24: 0x2402002a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 42));
    // 0x1e0b28: 0x1462000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e0b54;
    }
    // 0x1e0b30: 0x8e640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1e0b34: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0b38: 0x24830008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 8));
    // 0x1e0b3c: 0xae630000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 3));
    // 0x1e0b40: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e0b44: 0x4420001
    if (GPR_S32(ctx, 2) < 0) {
        SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
        goto label_1e0b4c;
    }
label_1e0b4c:
    // 0x1e0b4c: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0B60; return;
    }
label_1e0b54:
    // 0x1e0b54: 0xc07823e
    SET_GPR_U32(ctx, 31, 0x1e0b5c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 28));
    CchParsePchzInt__FPcPi(rdram, ctx, runtime); return;
}


// Function: entry_1e0b5c
// Address: 0x1e0b5c - 0x1e0cd0

void entry_1e0b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0b5c) {
        switch (ctx->pc) {
            case 0x1e0b60: ctx->pc = 0; goto label_1e0b60;
            case 0x1e0bd8: ctx->pc = 0; goto label_1e0bd8;
            case 0x1e0c40: ctx->pc = 0; goto label_1e0c40;
            case 0x1e0c88: ctx->pc = 0; goto label_1e0c88;
            case 0x1e0c90: ctx->pc = 0; goto label_1e0c90;
            case 0x1e0cac: ctx->pc = 0; goto label_1e0cac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0b5c: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1e0b60:
    // 0x1e0b60: 0x8e02001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x1e0b64: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e0b68: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x1e0b6c: 0x10000048
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e0c90;
    }
    // 0x1e0b74: 0x92220000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e0b78: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e0b7c: 0x2442ffb4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967220));
    // 0x1e0b80: 0x21600
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 24));
    // 0x1e0b84: 0x22603
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 2), 24));
    // 0x1e0b88: 0x2c83002b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 43));
    // 0x1e0b8c: 0x1060002c
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1e0c40;
    }
    // 0x1e0b94: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1e0b98: 0x2442e230
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294959664));
    // 0x1e0b9c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1e0ba0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e0ba4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1e0bac: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0bb0: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0bb4: 0x10000022
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e0c40;
    }
    // 0x1e0bbc: 0x82230001
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 1)));
    // 0x1e0bc0: 0x2402006c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 108));
    // 0x1e0bc4: 0x10620004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e0bd8;
    }
    // 0x1e0bcc: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e0bd0: 0x1000001b
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e0c40;
    }
label_1e0bd8:
    // 0x1e0bd8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e0bdc: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x1e0be0: 0x10000017
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e0c40;
    }
    // 0x1e0be8: 0x51600
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 24));
    // 0x1e0bec: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e0bf0: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1e0bf4: 0x21603
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 24));
    // 0x1e0bf8: 0x24a5e879
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294961273));
    // 0x1e0bfc: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1e0c00: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1e0c04: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0c08: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e0c0c: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0c10: 0x30630001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 1));
    // 0x1e0c14: 0x83300b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 4));
    // 0x1e0c18: 0xae060024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 6));
    // 0x1e0c1c: 0x82240000
    SET_GPR_S32(ctx, 4, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e0c20: 0x852821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1e0c24: 0x24830020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1e0c28: 0x90a20000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1e0c2c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1e0c30: 0x82180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 4));
    // 0x1e0c34: 0x38630076
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), 118));
    // 0x1e0c38: 0xc3380b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 7, GPR_U32(ctx, 6));
    // 0x1e0c3c: 0xae070028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 7));
label_1e0c40:
    // 0x1e0c40: 0x10000013
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e0c90;
    }
    // 0x1e0c48: 0x82230000
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e0c4c: 0x24020025
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 37));
    // 0x1e0c50: 0x1062000d
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e0c88;
    }
    // 0x1e0c58: 0x24a5e879
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294961273));
    // 0x1e0c5c: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1e0c60: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e0c64: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1e0c68: 0xae020030
    WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 2));
    // 0x1e0c6c: 0x82240000
    SET_GPR_S32(ctx, 4, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e0c70: 0x852821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x1e0c74: 0x24830020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1e0c78: 0x90a20000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1e0c7c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1e0c80: 0x82180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 4));
    // 0x1e0c84: 0xa203002c
    WRITE8(ADD32(GPR_U32(ctx, 16), 44), (uint8_t)GPR_U32(ctx, 3));
label_1e0c88:
    // 0x1e0c88: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0c8c: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
label_1e0c90:
    // 0x1e0c90: 0x2288821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 8)));
    // 0x1e0c94: 0x82220000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e0c98: 0x10400004
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e0cac;
    }
    // 0x1e0ca0: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1e0ca4: 0x14a2ff48
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E09C8; return;
    }
label_1e0cac:
    // 0x1e0cac: 0x2341023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 20)));
    // 0x1e0cb0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e0cb4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e0cb8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e0cbc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e0cc0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e0cc4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e0cc8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: WriteTftPchz__FP3TFTP5OSTRMPc
// Address: 0x1e0cd0 - 0x1e0d14

void entry_1e0d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0d14) {
        switch (ctx->pc) {
            case 0x1e0d38: ctx->pc = 0; goto label_1e0d38;
            case 0x1e0d3c: ctx->pc = 0; goto label_1e0d3c;
            case 0x1e0d40: ctx->pc = 0; goto label_1e0d40;
            case 0x1e0d70: ctx->pc = 0; goto label_1e0d70;
            case 0x1e0d74: ctx->pc = 0; goto label_1e0d74;
            case 0x1e0d88: ctx->pc = 0; goto label_1e0d88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0d14: 0x8e03001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x1e0d18: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e0d1c: 0x10600006
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1e0d38;
    }
    // 0x1e0d24: 0x71102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 17)));
    // 0x1e0d28: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        goto label_1e0d3c;
    }
    // 0x1e0d30: 0x10000003
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e0d40;
    }
label_1e0d38:
    // 0x1e0d38: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
label_1e0d3c:
    // 0x1e0d3c: 0x2880b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 0));
label_1e0d40:
    // 0x1e0d40: 0x8e050018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1e0d44: 0x225102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 5)));
    // 0x1e0d48: 0x1040000a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e0d74;
    }
    // 0x1e0d50: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1e0d54: 0x24140030
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1e0d58: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e0d5c: 0x62a00a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 3));
    // 0x1e0d60: 0x10800003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 17)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1e0d70;
    }
    // 0x1e0d68: 0x10000002
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e0d74;
    }
label_1e0d70:
    // 0x1e0d70: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1e0d74:
    // 0x1e0d74: 0xa3b40000
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 20));
    // 0x1e0d78: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1e0d7c: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0d80: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e0d84: 0x0
    // NOP
label_1e0d88:
    // 0x1e0d88: 0x18400007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E0DA8; return;
    }
    // 0x1e0d90: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e0d94: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e0d98: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e0da0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e0da0
// Address: 0x1e0da0 - 0x1e0dbc

void entry_1e0da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0da0) {
        switch (ctx->pc) {
            case 0x1e0da8: ctx->pc = 0; goto label_1e0da8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0da0: 0x1054fff9
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 20)) {
        ctx->pc = 0x1E0D88; return;
    }
label_1e0da8:
    // 0x1e0da8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e0dac: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e0db0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e0db4: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e0dbc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e0dbc
// Address: 0x1e0dbc - 0x1e0de8

void entry_1e0dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0dbc) {
        switch (ctx->pc) {
            case 0x1e0dd0: ctx->pc = 0; goto label_1e0dd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0dbc: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e0dc0: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1e0dc4: 0xa3a20000
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e0dc8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e0dcc: 0x0
    // NOP
label_1e0dd0:
    // 0x1e0dd0: 0x18400007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E0DF0; return;
    }
    // 0x1e0dd8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e0ddc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e0de0: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e0de8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e0de8
// Address: 0x1e0de8 - 0x1e0e18

void entry_1e0de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0de8) {
        switch (ctx->pc) {
            case 0x1e0df0: ctx->pc = 0; goto label_1e0df0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0de8: 0x1051fff9
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1E0DD0; return;
    }
label_1e0df0:
    // 0x1e0df0: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e0df4: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e0df8: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e0dfc: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e0e00: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e0e04: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e0e08: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e0e0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e0e14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e0e18; return;
}


// Function: FNegTftUl__FP3TFTP2UL
// Address: 0x1e0e18 - 0x1e0ef8

void entry_1e0fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e0fa8: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1e0fac: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1e0fb0: 0x2103f
    SET_GPR_S64(ctx, 2, GPR_S64(ctx, 2) >> (32 + 0));
    // 0x1e0fb4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e0fb8: 0x551021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1e0fbc: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e0fc0: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e0fc4: 0xc07ef80
    SET_GPR_U32(ctx, 31, 0x1e0fcc);
    WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 3));
    FUN_001fbe00(rdram, ctx, runtime); return;
}


// Function: entry_1e0fcc
// Address: 0x1e0fcc - 0x1e1000

void entry_1e0fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e0fcc) {
        switch (ctx->pc) {
            case 0x1e0fe0: ctx->pc = 0; goto label_1e0fe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e0fcc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e0fd0: 0x12000003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), GPR_U32(ctx, 19)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1e0fe0;
    }
    // 0x1e0fd8: 0x1040fff1
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E0FA0; return;
    }
label_1e0fe0:
    // 0x1e0fe0: 0x2918023
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 17)));
    // 0x1e0fe4: 0x12000006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 19), GPR_U32(ctx, 17)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1e1000(rdram, ctx, runtime); return;
    }
    // 0x1e0fec: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e1000(rdram, ctx, runtime); return;
    }
    // 0x1e0ff4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e0ff8: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1e1000);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1e1000
// Address: 0x1e1000 - 0x1e1028

void entry_1e1000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1000: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e1004: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e1008: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e100c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e1010: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e1014: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e1018: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e101c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e1020: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: WriteTftUl__FP3TFTP5OSTRMUl
// Address: 0x1e1028 - 0x1e10a8

void entry_1e10a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e10a8) {
        switch (ctx->pc) {
            case 0x1e10f4: ctx->pc = 0; goto label_1e10f4;
            case 0x1e1108: ctx->pc = 0; goto label_1e1108;
            case 0x1e1118: ctx->pc = 0; goto label_1e1118;
            case 0x1e111c: ctx->pc = 0; goto label_1e111c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e10a8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e10ac: 0x8e54001c
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x1e10b0: 0x9242002c
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 44)));
    // 0x1e10b4: 0x27b10050
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1e10b8: 0x2443ff9e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294967198));
    // 0x1e10bc: 0x2c620017
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 23));
    // 0x1e10c0: 0x10400033
    WRITE8(ADD32(GPR_U32(ctx, 29), 80), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1190; return;
    }
    // 0x1e10c8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e10cc: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1e10d0: 0x2442e400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294960128));
    // 0x1e10d4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1e10d8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e10dc: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1e10e4: 0x10a00003
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1e10f4;
    }
    // 0x1e10ec: 0x1000000a
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 4294960080)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1118;
    }
label_1e10f4:
    // 0x1e10f4: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1e10f8: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e1108;
    }
    // 0x1e1100: 0x10000005
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 4294960088)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1118;
    }
label_1e1108:
    // 0x1e1108: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1e110c: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e111c;
    }
    // 0x1e1114: 0x9443e3e0
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 4294960096)));
label_1e1118:
    // 0x1e1118: 0xa7a30050
    WRITE16(ADD32(GPR_U32(ctx, 29), 80), (uint16_t)GPR_U32(ctx, 3));
label_1e111c:
    // 0x1e111c: 0x27a20050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1e1120: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1124: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e112c);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e112c
// Address: 0x1e112c - 0x1e1198

void entry_1e112c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e112c) {
        switch (ctx->pc) {
            case 0x1e1184: ctx->pc = 0; goto label_1e1184;
            case 0x1e1190: ctx->pc = 0; goto label_1e1190;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e112c: 0x10000018
    SET_GPR_U32(ctx, 20, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1190;
    }
    // 0x1e1134: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1e1138: 0x10400015
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 80));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e1190;
    }
    // 0x1e1140: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e1144: 0x2443e3e8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294960104));
    // 0x1e1148: 0x1000000e
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 4294960104)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1184;
    }
    // 0x1e1150: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1e1154: 0x1040000e
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 80));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e1190;
    }
    // 0x1e115c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1e1160: 0x9462e3f0
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 4294960112)));
    // 0x1e1164: 0x1000000a
    WRITE16(ADD32(GPR_U32(ctx, 29), 80), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1190;
    }
    // 0x1e116c: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1e1170: 0x10400007
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 80));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e1190;
    }
    // 0x1e1178: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e117c: 0x2443e3f8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294960120));
    // 0x1e1180: 0x9444e3f8
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 4294960120)));
label_1e1184:
    // 0x1e1184: 0x90650002
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 2)));
    // 0x1e1188: 0xa7a40050
    WRITE16(ADD32(GPR_U32(ctx, 29), 80), (uint16_t)GPR_U32(ctx, 4));
    // 0x1e118c: 0xa3a50052
    WRITE8(ADD32(GPR_U32(ctx, 29), 82), (uint8_t)GPR_U32(ctx, 5));
label_1e1190:
    // 0x1e1190: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e1198);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e1198
// Address: 0x1e1198 - 0x1e11a8

void entry_1e1198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1198: 0x8244002c
    SET_GPR_S32(ctx, 4, (int8_t)READ8(ADD32(GPR_U32(ctx, 18), 44)));
    // 0x1e119c: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e11a0: 0xc0783be
    SET_GPR_U32(ctx, 31, 0x1e11a8);
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 29), 112)));
    UnRadixFromChConversion__Fc(rdram, ctx, runtime); return;
}


// Function: entry_1e11a8
// Address: 0x1e11a8 - 0x1e11bc

void entry_1e11a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e11a8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e11ac: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e11b0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e11b4: 0xc0783d6
    SET_GPR_U32(ctx, 31, 0x1e11bc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    CchAchFromUl__FPciUlUi(rdram, ctx, runtime); return;
}


// Function: entry_1e11bc
// Address: 0x1e11bc - 0x1e11e8

void entry_1e11bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e11bc) {
        switch (ctx->pc) {
            case 0x1e11d0: ctx->pc = 0; goto label_1e11d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e11bc: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e11c0: 0x295a023
    SET_GPR_U32(ctx, 20, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 21)));
    // 0x1e11c4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e11c8: 0x54102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 20)));
    // 0x1e11cc: 0x2a00a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 0));
label_1e11d0:
    // 0x1e11d0: 0x3b51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 21)));
    // 0x1e11d4: 0x8e430030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 48)));
    // 0x1e11d8: 0x10600005
    WRITE8(ADD32(GPR_U32(ctx, 2), 0), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1e11f0(rdram, ctx, runtime); return;
    }
    // 0x1e11e0: 0xc078886
    SET_GPR_U32(ctx, 31, 0x1e11e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpperizePchz__FPc(rdram, ctx, runtime); return;
}


// Function: entry_1e11e8
// Address: 0x1e11e8 - 0x1e11f0

void entry_1e11e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e11e8: 0xc078886
    SET_GPR_U32(ctx, 31, 0x1e11f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    UpperizePchz__FPc(rdram, ctx, runtime); return;
}


// Function: entry_1e11f0
// Address: 0x1e11f0 - 0x1e1268

void entry_1e11f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e11f0) {
        switch (ctx->pc) {
            case 0x1e1220: ctx->pc = 0; goto label_1e1220;
            case 0x1e1238: ctx->pc = 0; goto label_1e1238;
            case 0x1e1250: ctx->pc = 0; goto label_1e1250;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e11f0: 0x2d41021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 20)));
    // 0x1e11f4: 0x8e440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1e11f8: 0x551821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1e11fc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e1200: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x1e1204: 0x1040000c
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e1238;
    }
    // 0x1e120c: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1e1210: 0x10400003
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e1220;
    }
    // 0x1e1218: 0x10000007
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1238;
    }
label_1e1220:
    // 0x1e1220: 0x8e420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1e1224: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
        goto label_1e1238;
    }
    // 0x1e122c: 0x52a00002
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
        goto label_1e1238;
    }
    // 0x1e1234: 0x283a021
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 3)));
label_1e1238:
    // 0x1e1238: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1e123c: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1e1240: 0xa3a20060
    WRITE8(ADD32(GPR_U32(ctx, 29), 96), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e1244: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e1248: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e124c: 0x0
    // NOP
label_1e1250:
    // 0x1e1250: 0x18400007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E1270; return;
    }
    // 0x1e1258: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e125c: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1e1260: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1268);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1268
// Address: 0x1e1268 - 0x1e1284

void entry_1e1268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1268) {
        switch (ctx->pc) {
            case 0x1e1270: ctx->pc = 0; goto label_1e1270;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1268: 0x1052fff9
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x1E1250; return;
    }
label_1e1270:
    // 0x1e1270: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e1274: 0x2c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1e1278: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e127c: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1284);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1284
// Address: 0x1e1284 - 0x1e12b0

void entry_1e1284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1284) {
        switch (ctx->pc) {
            case 0x1e1298: ctx->pc = 0; goto label_1e1298;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1284: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e1288: 0x24020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1e128c: 0xa3a20060
    WRITE8(ADD32(GPR_U32(ctx, 29), 96), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e1290: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e1294: 0x0
    // NOP
label_1e1298:
    // 0x1e1298: 0x18400007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E12B8; return;
    }
    // 0x1e12a0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e12a4: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1e12a8: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e12b0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e12b0
// Address: 0x1e12b0 - 0x1e12cc

void entry_1e12b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e12b0) {
        switch (ctx->pc) {
            case 0x1e12b8: ctx->pc = 0; goto label_1e12b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e12b0: 0x1051fff9
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1E1298; return;
    }
label_1e12b8:
    // 0x1e12b8: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e12bc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e12c0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e12c4: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e12cc);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e12cc
// Address: 0x1e12cc - 0x1e12f8

void entry_1e12cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e12cc) {
        switch (ctx->pc) {
            case 0x1e12e0: ctx->pc = 0; goto label_1e12e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e12cc: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e12d0: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1e12d4: 0xa3a20060
    WRITE8(ADD32(GPR_U32(ctx, 29), 96), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e12d8: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e12dc: 0x0
    // NOP
label_1e12e0:
    // 0x1e12e0: 0x18400007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E1300; return;
    }
    // 0x1e12e8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e12ec: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1e12f0: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e12f8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e12f8
// Address: 0x1e12f8 - 0x1e1330

void entry_1e12f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e12f8) {
        switch (ctx->pc) {
            case 0x1e1300: ctx->pc = 0; goto label_1e1300;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e12f8: 0x1051fff9
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1E12E0; return;
    }
label_1e1300:
    // 0x1e1300: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1e1304: 0x7bb700f0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1e1308: 0x7bb600e0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1e130c: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1e1310: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1e1314: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1e1318: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e131c: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1e1320: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e1324: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e132c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e1330; return;
}


// Function: ExpFirstFromG__Fd
// Address: 0x1e1330 - 0x1e1354

void entry_1e1354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1354: 0x58400017
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x1E13B4; return;
    }
    // 0x1e135c: 0xc07f55e
    SET_GPR_U32(ctx, 31, 0x1e1364);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dptofp(rdram, ctx, runtime); return;
}


// Function: entry_1e1364
// Address: 0x1e1364 - 0x1e136c

void entry_1e1364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1364: 0xc0816ca
    SET_GPR_U32(ctx, 31, 0x1e136c);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    log10f(rdram, ctx, runtime); return;
}


// Function: entry_1e136c
// Address: 0x1e136c - 0x1e1374

void entry_1e136c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e136c: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x1e1374);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_1e1374
// Address: 0x1e1374 - 0x1e1380

void entry_1e1374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1374: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1378: 0xc07f504
    SET_GPR_U32(ctx, 31, 0x1e1380);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    dptoli(rdram, ctx, runtime); return;
}


// Function: entry_1e1380
// Address: 0x1e1380 - 0x1e1390

void entry_1e1380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1380: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1384: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1388: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x1e1390);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_1e1390
// Address: 0x1e1390 - 0x1e13a0

void entry_1e1390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1390: 0x4410009
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x1E13B8; return;
    }
    // 0x1e1398: 0xc07f4d6
    SET_GPR_U32(ctx, 31, 0x1e13a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    litodp(rdram, ctx, runtime); return;
}


// Function: entry_1e13a0
// Address: 0x1e13a0 - 0x1e13ac

void entry_1e13a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e13a0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e13a4: 0xc07f4c2
    SET_GPR_U32(ctx, 31, 0x1e13ac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpcmp(rdram, ctx, runtime); return;
}


// Function: entry_1e13ac
// Address: 0x1e13ac - 0x1e13d0

void entry_1e13ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e13ac) {
        switch (ctx->pc) {
            case 0x1e13b4: ctx->pc = 0; goto label_1e13b4;
            case 0x1e13b8: ctx->pc = 0; goto label_1e13b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e13ac: 0x2603ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1e13b0: 0x62800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
label_1e13b4:
    // 0x1e13b4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1e13b8:
    // 0x1e13b8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e13bc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e13c0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e13c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e13c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ChDigitFromG__Fdii
// Address: 0x1e13d0 - 0x1e1418

void entry_1e1418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1418: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x1e1420);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_1e1420
// Address: 0x1e1420 - 0x1e142c

void entry_1e1420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1420: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1424: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x1e142c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_1e142c
// Address: 0x1e142c - 0x1e1434

void entry_1e142c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e142c: 0xc07ab9e
    SET_GPR_U32(ctx, 31, 0x1e1434);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    GTrunc__Fd(rdram, ctx, runtime); return;
}


// Function: entry_1e1434
// Address: 0x1e1434 - 0x1e1448

void entry_1e1434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1434: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1438: 0x3c010025
    SET_GPR_U32(ctx, 1, ((uint32_t)37 << 16));
    // 0x1e143c: 0xdc25e460
    SET_GPR_U64(ctx, 5, READ64(ADD32(GPR_U32(ctx, 1), 4294960224)));
    // 0x1e1440: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x1e1448);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_1e1448
// Address: 0x1e1448 - 0x1e1450

void entry_1e1448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1448: 0xc07ab9e
    SET_GPR_U32(ctx, 31, 0x1e1450);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    GTrunc__Fd(rdram, ctx, runtime); return;
}


// Function: entry_1e1450
// Address: 0x1e1450 - 0x1e1460

void entry_1e1450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1450: 0x34058048
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32840));
    // 0x1e1454: 0x52bfc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 15));
    // 0x1e1458: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x1e1460);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_1e1460
// Address: 0x1e1460 - 0x1e146c

void entry_1e1460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1460: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e1464: 0xc07f35e
    SET_GPR_U32(ctx, 31, 0x1e146c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpsub(rdram, ctx, runtime); return;
}


// Function: entry_1e146c
// Address: 0x1e146c - 0x1e1474

void entry_1e146c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e146c: 0xc07f504
    SET_GPR_U32(ctx, 31, 0x1e1474);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dptoli(rdram, ctx, runtime); return;
}


// Function: entry_1e1474
// Address: 0x1e1474 - 0x1e1498

void entry_1e1474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1474: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e1478: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e147c: 0x24635940
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 22848));
    // 0x1e1480: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e1484: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1e1488: 0x80620000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e148c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e1494: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e1498; return;
}


// Function: CchAchFromDouble__FPciP3TFTd
// Address: 0x1e1498 - 0x1e150c

void entry_1e150c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e150c: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e1514);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e1514
// Address: 0x1e1514 - 0x1e1528

void entry_1e1514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1514) {
        switch (ctx->pc) {
            case 0x1e151c: ctx->pc = 0; goto label_1e151c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1514: 0x1000009a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1780; return;
    }
label_1e151c:
    // 0x1e151c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e1520: 0xc0784cc
    SET_GPR_U32(ctx, 31, 0x1e1528);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ExpFirstFromG__Fd(rdram, ctx, runtime); return;
}


// Function: entry_1e1528
// Address: 0x1e1528 - 0x1e1590

void entry_1e1528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1528) {
        switch (ctx->pc) {
            case 0x1e155c: ctx->pc = 0; goto label_1e155c;
            case 0x1e1568: ctx->pc = 0; goto label_1e1568;
            case 0x1e156c: ctx->pc = 0; goto label_1e156c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1528: 0x9284002c
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 20), 44)));
    // 0x1e152c: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1530: 0x24030067
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 103));
    // 0x1e1534: 0x38820065
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 4), 101));
    // 0x1e1538: 0x1483000b
    SET_GPR_U32(ctx, 23, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1e1568;
    }
    // 0x1e1540: 0x2a62fffc
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 4294967292));
    // 0x1e1544: 0x14400005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e155c;
    }
    // 0x1e154c: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1e1550: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 28)));
        goto label_1e156c;
    }
    // 0x1e1558: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
label_1e155c:
    // 0x1e155c: 0x24170001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e1560: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1e1564: 0xae82001c
    WRITE32(ADD32(GPR_U32(ctx, 20), 28), GPR_U32(ctx, 2));
label_1e1568:
    // 0x1e1568: 0x8e83001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 28)));
label_1e156c:
    // 0x1e156c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e1570: 0x277100b
    if (GPR_U32(ctx, 23) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 19));
    // 0x1e1574: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1e1578: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e157c: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1e1580: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1e1584: 0x46806b60
    ctx->f[13] = FPU_CVT_S_W(*(int32_t*)&ctx->f[13]);
    // 0x1e1588: 0xc08171e
    SET_GPR_U32(ctx, 31, 0x1e1590);
    powf(rdram, ctx, runtime); return;
}


// Function: entry_1e1590
// Address: 0x1e1590 - 0x1e1598

void entry_1e1590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1590: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x1e1598);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_1e1598
// Address: 0x1e1598 - 0x1e15a8

void entry_1e1598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1598: 0x3405ff80
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65408));
    // 0x1e159c: 0x52bbc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 14));
    // 0x1e15a0: 0xc07f378
    SET_GPR_U32(ctx, 31, 0x1e15a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    dpmul(rdram, ctx, runtime); return;
}


// Function: entry_1e15a8
// Address: 0x1e15a8 - 0x1e15b4

void entry_1e15a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e15a8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e15ac: 0xc07f348
    SET_GPR_U32(ctx, 31, 0x1e15b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    dpadd(rdram, ctx, runtime); return;
}


// Function: entry_1e15b4
// Address: 0x1e15b4 - 0x1e15c0

void entry_1e15b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e15b4: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e15b8: 0xc0784cc
    SET_GPR_U32(ctx, 31, 0x1e15c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ExpFirstFromG__Fd(rdram, ctx, runtime); return;
}


// Function: entry_1e15c0
// Address: 0x1e15c0 - 0x1e15cc

void entry_1e15c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e15c0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e15c4: 0xc0784cc
    SET_GPR_U32(ctx, 31, 0x1e15cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ExpFirstFromG__Fd(rdram, ctx, runtime); return;
}


// Function: entry_1e15cc
// Address: 0x1e15cc - 0x1e161c

void entry_1e15cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e15cc) {
        switch (ctx->pc) {
            case 0x1e15e4: ctx->pc = 0; goto label_1e15e4;
            case 0x1e15f4: ctx->pc = 0; goto label_1e15f4;
            case 0x1e15fc: ctx->pc = 0; goto label_1e15fc;
            case 0x1e1608: ctx->pc = 0; goto label_1e1608;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e15cc: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1e15d0: 0x12e00004
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_1e15e4;
    }
    // 0x1e15d8: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e15dc: 0x10000007
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e15fc;
    }
label_1e15e4:
    // 0x1e15e4: 0x6600003
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 19) < 0) {
        goto label_1e15f4;
    }
    // 0x1e15ec: 0x10000003
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e15fc;
    }
label_1e15f4:
    // 0x1e15f4: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e15f8: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1e15fc:
    // 0x1e15fc: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e1600: 0x1840000b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E1630; return;
    }
label_1e1608:
    // 0x1e1608: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e160c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e1610: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e1614: 0xc0784f4
    SET_GPR_U32(ctx, 31, 0x1e161c);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    ChDigitFromG__Fdii(rdram, ctx, runtime); return;
}


// Function: entry_1e161c
// Address: 0x1e161c - 0x1e166c

void entry_1e161c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e161c) {
        switch (ctx->pc) {
            case 0x1e1630: ctx->pc = 0; goto label_1e1630;
            case 0x1e1658: ctx->pc = 0; goto label_1e1658;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e161c: 0xa2220000
    WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e1620: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e1624: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1e1628: 0x1c40fff7
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x1E1608; return;
    }
label_1e1630:
    // 0x1e1630: 0x8e820014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x1e1634: 0x1440002b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 46));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E16E4; return;
    }
    // 0x1e163c: 0xa2220000
    WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e1640: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1e1644: 0x8e90001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x1e1648: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e164c: 0x1840000c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E1680; return;
    }
    // 0x1e1654: 0x0
    // NOP
label_1e1658:
    // 0x1e1658: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e165c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e1660: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e1664: 0xc0784f4
    SET_GPR_U32(ctx, 31, 0x1e166c);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    ChDigitFromG__Fdii(rdram, ctx, runtime); return;
}


// Function: entry_1e166c
// Address: 0x1e166c - 0x1e1724

void entry_1e166c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e166c) {
        switch (ctx->pc) {
            case 0x1e1680: ctx->pc = 0; goto label_1e1680;
            case 0x1e16b0: ctx->pc = 0; goto label_1e16b0;
            case 0x1e16cc: ctx->pc = 0; goto label_1e16cc;
            case 0x1e16e4: ctx->pc = 0; goto label_1e16e4;
            case 0x1e1704: ctx->pc = 0; goto label_1e1704;
            case 0x1e1708: ctx->pc = 0; goto label_1e1708;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e166c: 0xa2220000
    WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e1670: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e1674: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1e1678: 0x1c40fff7
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x1E1658; return;
    }
label_1e1680:
    // 0x1e1680: 0x9283002c
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 20), 44)));
    // 0x1e1684: 0x24020067
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 103));
    // 0x1e1688: 0x14620016
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), GPR_U32(ctx, 17)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e16e4;
    }
    // 0x1e1690: 0x10400014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294934528));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e16e4;
    }
    // 0x1e1698: 0x24040030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1e169c: 0x80437fff
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 32767)));
    // 0x1e16a0: 0x1464000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_1e16cc;
    }
    // 0x1e16a8: 0xa0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1e16ac: 0x0
    // NOP
label_1e16b0:
    // 0x1e16b0: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1e16b4: 0x2d1102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), GPR_U32(ctx, 17)));
    // 0x1e16b8: 0x1040000a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e16e4;
    }
    // 0x1e16c0: 0x80627fff
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 3), 32767)));
    // 0x1e16c4: 0x1044fffa
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        goto label_1e16b0;
    }
label_1e16cc:
    // 0x1e16cc: 0x2d1102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), GPR_U32(ctx, 17)));
    // 0x1e16d0: 0x10400004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e16e4;
    }
    // 0x1e16d8: 0x80a27fff
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 5), 32767)));
    // 0x1e16dc: 0x3842002e
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 46));
    // 0x1e16e0: 0x62880a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 3));
label_1e16e4:
    // 0x1e16e4: 0x12e00024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 101));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1778; return;
    }
    // 0x1e16ec: 0xa2220000
    WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e16f0: 0x6610004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_S32(ctx, 19) >= 0) {
        goto label_1e1704;
    }
    // 0x1e16f8: 0x2402002d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 45));
    // 0x1e16fc: 0x10000002
    SET_GPR_U32(ctx, 19, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 19)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1708;
    }
label_1e1704:
    // 0x1e1704: 0x2402002b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 43));
label_1e1708:
    // 0x1e1708: 0xa2220000
    WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e170c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1e1710: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e1714: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1e1718: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e171c: 0xc08171e
    SET_GPR_U32(ctx, 31, 0x1e1724);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    powf(rdram, ctx, runtime); return;
}


// Function: entry_1e1724
// Address: 0x1e1724 - 0x1e17a8

void entry_1e1724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1724) {
        switch (ctx->pc) {
            case 0x1e1740: ctx->pc = 0; goto label_1e1740;
            case 0x1e174c: ctx->pc = 0; goto label_1e174c;
            case 0x1e1770: ctx->pc = 0; goto label_1e1770;
            case 0x1e1778: ctx->pc = 0; goto label_1e1778;
            case 0x1e1780: ctx->pc = 0; goto label_1e1780;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1724: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e1728: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1e172c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e1730: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e1734: 0x2409000a
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1e1738: 0x24485940
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 22848));
    // 0x1e173c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
label_1e1740:
    // 0x1e1740: 0x266001a
    { int32_t divisor = GPR_S32(ctx, 6); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 19) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 6) % divisor); } else { ctx->lo = (GPR_S32(ctx,19) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,6); } }
    // 0x1e1744: 0x50c70001
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 7)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1e174c;
    }
label_1e174c:
    // 0x1e174c: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1e1750: 0x1812
    SET_GPR_U32(ctx, 3, ctx->lo);
    // 0x1e1754: 0x2010
    SET_GPR_U32(ctx, 4, ctx->hi);
    // 0x1e1758: 0x681821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1e175c: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e1760: 0x899818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 9); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1e1764: 0xa2220000
    WRITE8(ADD32(GPR_U32(ctx, 17), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e1768: 0x50c70001
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 7)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1e1770;
    }
label_1e1770:
    // 0x1e1770: 0x4a1fff3
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_1e1740;
    }
label_1e1778:
    // 0x1e1778: 0x2361023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 22)));
    // 0x1e177c: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1e1780:
    // 0x1e1780: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e1784: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e1788: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e178c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e1790: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e1794: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e1798: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e179c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e17a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: WriteTftDouble__FP3TFTP5OSTRMd
// Address: 0x1e17a8 - 0x1e1830

void entry_1e1830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1830: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e1834: 0x62182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1e1838: 0x38710001
    SET_GPR_U32(ctx, 17, XOR32(GPR_U32(ctx, 3), 1));
    // 0x1e183c: 0x12200004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1850; return;
    }
    // 0x1e1844: 0xc07f35e
    SET_GPR_U32(ctx, 31, 0x1e184c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    dpsub(rdram, ctx, runtime); return;
}


// Function: entry_1e184c
// Address: 0x1e184c - 0x1e1898

void entry_1e184c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e184c) {
        switch (ctx->pc) {
            case 0x1e1850: ctx->pc = 0; goto label_1e1850;
            case 0x1e1864: ctx->pc = 0; goto label_1e1864;
            case 0x1e1878: ctx->pc = 0; goto label_1e1878;
            case 0x1e1888: ctx->pc = 0; goto label_1e1888;
            case 0x1e188c: ctx->pc = 0; goto label_1e188c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e184c: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1e1850:
    // 0x1e1850: 0x12200004
    WRITE8(ADD32(GPR_U32(ctx, 29), 448), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1e1864;
    }
    // 0x1e1858: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e185c: 0x1000000a
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 4294960080)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1888;
    }
label_1e1864:
    // 0x1e1864: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1e1868: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e1878;
    }
    // 0x1e1870: 0x10000005
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 4294960088)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1888;
    }
label_1e1878:
    // 0x1e1878: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1e187c: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e188c;
    }
    // 0x1e1884: 0x9443e3e0
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 4294960096)));
label_1e1888:
    // 0x1e1888: 0xa7a301c0
    WRITE16(ADD32(GPR_U32(ctx, 29), 448), (uint16_t)GPR_U32(ctx, 3));
label_1e188c:
    // 0x1e188c: 0x27a401c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 448));
    // 0x1e1890: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e1898);
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e1898
// Address: 0x1e1898 - 0x1e18b0

void entry_1e1898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1898: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e189c: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e18a0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e18a4: 0x240501b5
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 437));
    // 0x1e18a8: 0xc078526
    SET_GPR_U32(ctx, 31, 0x1e18b0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CchAchFromDouble__FPciP3TFTd(rdram, ctx, runtime); return;
}


// Function: entry_1e18b0
// Address: 0x1e18b0 - 0x1e18cc

void entry_1e18b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e18b0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e18b4: 0x8e030030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x1e18b8: 0x3b11021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 17)));
    // 0x1e18bc: 0x10600003
    WRITE8(ADD32(GPR_U32(ctx, 2), 0), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1e18cc(rdram, ctx, runtime); return;
    }
    // 0x1e18c4: 0xc078886
    SET_GPR_U32(ctx, 31, 0x1e18cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    UpperizePchz__FPc(rdram, ctx, runtime); return;
}


// Function: entry_1e18cc
// Address: 0x1e18cc - 0x1e1940

void entry_1e18cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e18cc) {
        switch (ctx->pc) {
            case 0x1e18f8: ctx->pc = 0; goto label_1e18f8;
            case 0x1e1910: ctx->pc = 0; goto label_1e1910;
            case 0x1e1928: ctx->pc = 0; goto label_1e1928;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e18cc: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1e18d0: 0x2911821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 17)));
    // 0x1e18d4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e18d8: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x1e18dc: 0x1040000c
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e1910;
    }
    // 0x1e18e4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e18e8: 0x10400003
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e18f8;
    }
    // 0x1e18f0: 0x10000007
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1910;
    }
label_1e18f8:
    // 0x1e18f8: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1e18fc: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
        goto label_1e1910;
    }
    // 0x1e1904: 0x52200002
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
        goto label_1e1910;
    }
    // 0x1e190c: 0x60b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_1e1910:
    // 0x1e1910: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1e1914: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1e1918: 0xa3a201d0
    WRITE8(ADD32(GPR_U32(ctx, 29), 464), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e191c: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e1920: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e1924: 0x0
    // NOP
label_1e1928:
    // 0x1e1928: 0x18400007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E1948; return;
    }
    // 0x1e1930: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1934: 0x27a501d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 464));
    // 0x1e1938: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1940);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1940
// Address: 0x1e1940 - 0x1e195c

void entry_1e1940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1940) {
        switch (ctx->pc) {
            case 0x1e1948: ctx->pc = 0; goto label_1e1948;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1940: 0x1053fff9
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 19)) {
        ctx->pc = 0x1E1928; return;
    }
label_1e1948:
    // 0x1e1948: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1e194c: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e1950: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1954: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e195c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e195c
// Address: 0x1e195c - 0x1e1988

void entry_1e195c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e195c) {
        switch (ctx->pc) {
            case 0x1e1970: ctx->pc = 0; goto label_1e1970;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e195c: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e1960: 0x24020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1e1964: 0xa3a201d0
    WRITE8(ADD32(GPR_U32(ctx, 29), 464), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e1968: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e196c: 0x0
    // NOP
label_1e1970:
    // 0x1e1970: 0x18400007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E1990; return;
    }
    // 0x1e1978: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e197c: 0x27a501d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 464));
    // 0x1e1980: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1988);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1988
// Address: 0x1e1988 - 0x1e19a4

void entry_1e1988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1988) {
        switch (ctx->pc) {
            case 0x1e1990: ctx->pc = 0; goto label_1e1990;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1988: 0x1053fff9
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 19)) {
        ctx->pc = 0x1E1970; return;
    }
label_1e1990:
    // 0x1e1990: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e1994: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1998: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e199c: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e19a4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e19a4
// Address: 0x1e19a4 - 0x1e19d0

void entry_1e19a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e19a4) {
        switch (ctx->pc) {
            case 0x1e19b8: ctx->pc = 0; goto label_1e19b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e19a4: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e19a8: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1e19ac: 0xa3a201d0
    WRITE8(ADD32(GPR_U32(ctx, 29), 464), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e19b0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e19b4: 0x0
    // NOP
label_1e19b8:
    // 0x1e19b8: 0x18400007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E19D8; return;
    }
    // 0x1e19c0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e19c4: 0x27a501d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 464));
    // 0x1e19c8: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e19d0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e19d0
// Address: 0x1e19d0 - 0x1e1a08

void entry_1e19d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e19d0) {
        switch (ctx->pc) {
            case 0x1e19d8: ctx->pc = 0; goto label_1e19d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e19d0: 0x1051fff9
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1E19B8; return;
    }
label_1e19d8:
    // 0x1e19d8: 0x7bbf0260
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 608)));
    // 0x1e19dc: 0x7bb70250
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 592)));
    // 0x1e19e0: 0x7bb60240
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x1e19e4: 0x7bb50230
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x1e19e8: 0x7bb40220
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x1e19ec: 0x7bb30210
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x1e19f0: 0x7bb20200
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x1e19f4: 0x7bb101f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x1e19f8: 0x7bb001e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x1e19fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 624));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e1a04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e1a08; return;
}


// Function: WriteTft__FP3TFTP5OSTRMPPcPci
// Address: 0x1e1a08 - 0x1e1a84

void entry_1e1a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1a84: 0x100000c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1D88; return;
    }
    // 0x1e1a8c: 0x8d220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x1e1a90: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1a94: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e1a98: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e1a9c: 0x24430008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 8));
    // 0x1e1aa0: 0xad230000
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 3));
    // 0x1e1aa4: 0x80470000
    SET_GPR_S32(ctx, 7, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e1aa8: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1ab0);
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 7));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1ab0
// Address: 0x1e1ab0 - 0x1e1ad4

void entry_1e1ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1ab0: 0x100000b5
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1D88; return;
    }
    // 0x1e1ab8: 0x8d230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x1e1abc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e1ac0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1ac4: 0x24620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1e1ac8: 0xad220000
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 2));
    // 0x1e1acc: 0xc078334
    SET_GPR_U32(ctx, 31, 0x1e1ad4);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    WriteTftPchz__FP3TFTP5OSTRMPc(rdram, ctx, runtime); return;
}


// Function: entry_1e1ad4
// Address: 0x1e1ad4 - 0x1e1b48

void entry_1e1ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1ad4) {
        switch (ctx->pc) {
            case 0x1e1b18: ctx->pc = 0; goto label_1e1b18;
            case 0x1e1b28: ctx->pc = 0; goto label_1e1b28;
            case 0x1e1b38: ctx->pc = 0; goto label_1e1b38;
            case 0x1e1b40: ctx->pc = 0; goto label_1e1b40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1ad4: 0x100000ac
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1D88; return;
    }
    // 0x1e1adc: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1e1ae0: 0x24030078
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 120));
    // 0x1e1ae4: 0xae22001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 2));
    // 0x1e1ae8: 0xa223002c
    WRITE8(ADD32(GPR_U32(ctx, 17), 44), (uint8_t)GPR_U32(ctx, 3));
    // 0x1e1aec: 0xae200020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 0));
    // 0x1e1af0: 0x8e230020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1e1af4: 0x4600010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_S32(ctx, 3) < 0) {
        goto label_1e1b38;
    }
    // 0x1e1afc: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 0)));
        goto label_1e1b18;
    }
    // 0x1e1b04: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e1b08: 0x10620007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e1b28;
    }
    // 0x1e1b10: 0x1000000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1b40;
    }
label_1e1b18:
    // 0x1e1b18: 0x24620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1e1b1c: 0xad220000
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 2));
    // 0x1e1b20: 0x10000005
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e1b38;
    }
label_1e1b28:
    // 0x1e1b28: 0x8d230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x1e1b2c: 0x24620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1e1b30: 0xad220000
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 2));
    // 0x1e1b34: 0xdc6a0000
    SET_GPR_U64(ctx, 10, READ64(ADD32(GPR_U32(ctx, 3), 0)));
label_1e1b38:
    // 0x1e1b38: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e1b3c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1e1b40:
    // 0x1e1b40: 0xc07840a
    SET_GPR_U32(ctx, 31, 0x1e1b48);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    WriteTftUl__FP3TFTP5OSTRMUl(rdram, ctx, runtime); return;
}


// Function: entry_1e1b48
// Address: 0x1e1b48 - 0x1e1ba4

void entry_1e1b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1b48: 0x1000008f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1D88; return;
    }
    // 0x1e1b50: 0x8e220024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1e1b54: 0x1040005d
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1CCC; return;
    }
    // 0x1e1b5c: 0x8d250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x1e1b60: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1e1b64: 0x2457e488
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 2), 4294960264));
    // 0x1e1b68: 0x24a40008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 8));
    // 0x1e1b6c: 0x247ee480
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 3), 4294960256));
    // 0x1e1b70: 0xad240000
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 4));
    // 0x1e1b74: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1e1b78: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1e1b7c: 0x2475e490
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 3), 4294960272));
    // 0x1e1b80: 0x8e220028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 40)));
    // 0x1e1b84: 0x2496e498
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 4), 4294960280));
    // 0x1e1b88: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1e1b8c: 0x1440000a
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1e1bb8(rdram, ctx, runtime); return;
    }
    // 0x1e1b94: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1e1b98: 0x2484e478
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960248));
    // 0x1e1b9c: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e1ba4);
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e1ba4
// Address: 0x1e1ba4 - 0x1e1bb8

void entry_1e1ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1ba4: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1ba8: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1e1bac: 0x24a5e478
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294960248));
    // 0x1e1bb0: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1bb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1bb8
// Address: 0x1e1bb8 - 0x1e1bd8

void entry_1e1bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1bb8) {
        switch (ctx->pc) {
            case 0x1e1bc8: ctx->pc = 0; goto label_1e1bc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1bb8: 0x8e220028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 40)));
    // 0x1e1bbc: 0x18400035
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E1C94; return;
    }
    // 0x1e1bc4: 0x0
    // NOP
label_1e1bc8:
    // 0x1e1bc8: 0x12000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1BEC; return;
    }
    // 0x1e1bd0: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e1bd8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e1bd8
// Address: 0x1e1bd8 - 0x1e1be8

void entry_1e1bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1bd8: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1bdc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1be0: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1be8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1be8
// Address: 0x1e1be8 - 0x1e1bf4

void entry_1e1be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1be8) {
        switch (ctx->pc) {
            case 0x1e1bec: ctx->pc = 0; goto label_1e1bec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1be8: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
label_1e1bec:
    // 0x1e1bec: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e1bf4);
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 16), 1));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e1bf4
// Address: 0x1e1bf4 - 0x1e1c08

void entry_1e1bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1bf4: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e1bf8: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1bfc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1c00: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1c08);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1c08
// Address: 0x1e1c08 - 0x1e1c28

void entry_1e1c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1c08) {
        switch (ctx->pc) {
            case 0x1e1c18: ctx->pc = 0; goto label_1e1c18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1c08: 0x8e230024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1e1c0c: 0x18600016
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1E1C68; return;
    }
    // 0x1e1c14: 0x0
    // NOP
label_1e1c18:
    // 0x1e1c18: 0x52000008
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x1E1C3C; return;
    }
    // 0x1e1c20: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e1c28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e1c28
// Address: 0x1e1c28 - 0x1e1c38

void entry_1e1c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1c28: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1c2c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1c30: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1c38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1c38
// Address: 0x1e1c38 - 0x1e1c48

void entry_1e1c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1c38) {
        switch (ctx->pc) {
            case 0x1e1c3c: ctx->pc = 0; goto label_1e1c3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1c38: 0xc66c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[12] = *(float*)&val; }
label_1e1c3c:
    // 0x1e1c3c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1e1c40: 0xc07f61a
    SET_GPR_U32(ctx, 31, 0x1e1c48);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    fptodp(rdram, ctx, runtime); return;
}


// Function: entry_1e1c48
// Address: 0x1e1c48 - 0x1e1c58

void entry_1e1c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1c48: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1c4c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e1c50: 0xc0785ea
    SET_GPR_U32(ctx, 31, 0x1e1c58);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    WriteTftDouble__FP3TFTP5OSTRMd(rdram, ctx, runtime); return;
}


// Function: entry_1e1c58
// Address: 0x1e1c58 - 0x1e1c70

void entry_1e1c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1c58) {
        switch (ctx->pc) {
            case 0x1e1c68: ctx->pc = 0; goto label_1e1c68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1c58: 0x8e220024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1e1c5c: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1e1c60: 0x1440ffed
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1C18; return;
    }
label_1e1c68:
    // 0x1e1c68: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e1c70);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e1c70
// Address: 0x1e1c70 - 0x1e1c80

void entry_1e1c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1c70: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1c74: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1c78: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1c80);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1c80
// Address: 0x1e1c80 - 0x1e1cb0

void entry_1e1c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1c80) {
        switch (ctx->pc) {
            case 0x1e1c94: ctx->pc = 0; goto label_1e1c94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1c80: 0x8e230028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 40)));
    // 0x1e1c84: 0x203182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    // 0x1e1c88: 0x1460ffcf
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1BC8; return;
    }
    // 0x1e1c90: 0x8e220028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 40)));
label_1e1c94:
    // 0x1e1c94: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1e1c98: 0x1440003b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1D88; return;
    }
    // 0x1e1ca0: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1e1ca4: 0x2484e478
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960248));
    // 0x1e1ca8: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e1cb0);
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e1cb0
// Address: 0x1e1cb0 - 0x1e1cc4

void entry_1e1cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1cb0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1cb4: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1e1cb8: 0x24a5e478
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294960248));
    // 0x1e1cbc: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1cc4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1cc4
// Address: 0x1e1cc4 - 0x1e1ce8

void entry_1e1cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1cc4) {
        switch (ctx->pc) {
            case 0x1e1ccc: ctx->pc = 0; goto label_1e1ccc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1cc4: 0x10000030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1D88; return;
    }
label_1e1ccc:
    // 0x1e1ccc: 0x8d230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x1e1cd0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e1cd4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1cd8: 0x24620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1e1cdc: 0xad220000
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 2));
    // 0x1e1ce0: 0xc0785ea
    SET_GPR_U32(ctx, 31, 0x1e1ce8);
    SET_GPR_U64(ctx, 6, READ64(ADD32(GPR_U32(ctx, 3), 0)));
    WriteTftDouble__FP3TFTP5OSTRMd(rdram, ctx, runtime); return;
}


// Function: entry_1e1ce8
// Address: 0x1e1ce8 - 0x1e1d84

void entry_1e1ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1ce8) {
        switch (ctx->pc) {
            case 0x1e1d18: ctx->pc = 0; goto label_1e1d18;
            case 0x1e1d28: ctx->pc = 0; goto label_1e1d28;
            case 0x1e1d44: ctx->pc = 0; goto label_1e1d44;
            case 0x1e1d60: ctx->pc = 0; goto label_1e1d60;
            case 0x1e1d7c: ctx->pc = 0; goto label_1e1d7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1ce8: 0x10000027
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1D88; return;
    }
    // 0x1e1cf0: 0x8e240020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x1e1cf4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e1cf8: 0x10820012
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_1e1d44;
    }
    // 0x1e1d00: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_1e1d18;
    }
    // 0x1e1d08: 0x10800007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1e1d28;
    }
    // 0x1e1d10: 0x1000001e
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1D8C; return;
    }
label_1e1d18:
    // 0x1e1d18: 0x10820011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_1e1d60;
    }
    // 0x1e1d20: 0x1000001a
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1D8C; return;
    }
label_1e1d28:
    // 0x1e1d28: 0x8d230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x1e1d2c: 0x24620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1e1d30: 0xad220000
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 2));
    // 0x1e1d34: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e1d38: 0x8e420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1e1d3c: 0x10000011
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e1d84(rdram, ctx, runtime); return;
    }
label_1e1d44:
    // 0x1e1d44: 0x8d230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x1e1d48: 0x24620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1e1d4c: 0xad220000
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 2));
    // 0x1e1d50: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e1d54: 0x8e420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1e1d58: 0x1000000a
    WRITE16(ADD32(GPR_U32(ctx, 4), 0), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e1d84(rdram, ctx, runtime); return;
    }
label_1e1d60:
    // 0x1e1d60: 0x8d230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x1e1d64: 0x24620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1e1d68: 0xad220000
    WRITE32(ADD32(GPR_U32(ctx, 9), 0), GPR_U32(ctx, 2));
    // 0x1e1d6c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e1d70: 0x8e420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1e1d74: 0x10000003
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e1d84(rdram, ctx, runtime); return;
    }
label_1e1d7c:
    // 0x1e1d7c: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1d84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1d84
// Address: 0x1e1d84 - 0x1e1db8

void entry_1e1d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1d84) {
        switch (ctx->pc) {
            case 0x1e1d88: ctx->pc = 0; goto label_1e1d88;
            case 0x1e1d8c: ctx->pc = 0; goto label_1e1d8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1d84: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_1e1d88:
    // 0x1e1d88: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_1e1d8c:
    // 0x1e1d8c: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e1d90: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e1d94: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e1d98: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e1d9c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e1da0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e1da4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e1da8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e1dac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e1db4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e1db8; return;
}


// Function: CchOstrmPrintf__FP5OSTRMPcT1
// Address: 0x1e1db8 - 0x1e1e00

void entry_1e1e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1e00: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1e04: 0x16400005
    SET_GPR_U32(ctx, 16, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 17)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1E1C; return;
    }
    // 0x1e1e0c: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e1e14);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e1e14
// Address: 0x1e1e14 - 0x1e1e30

void entry_1e1e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1e14) {
        switch (ctx->pc) {
            case 0x1e1e1c: ctx->pc = 0; goto label_1e1e1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1e14: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1e18: 0x2309021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
label_1e1e1c:
    // 0x1e1e1c: 0x12000007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1E3C; return;
    }
    // 0x1e1e24: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e1e28: 0xc075c64
    SET_GPR_U32(ctx, 31, 0x1e1e30);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CbWrite__5OSTRMPvi(rdram, ctx, runtime); return;
}


// Function: entry_1e1e30
// Address: 0x1e1e30 - 0x1e1e54

void entry_1e1e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1e30) {
        switch (ctx->pc) {
            case 0x1e1e3c: ctx->pc = 0; goto label_1e1e3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1e30: 0x50102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 16)));
    // 0x1e1e34: 0x14400012
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1E80; return;
    }
label_1e1e3c:
    // 0x1e1e3c: 0x82220000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e1e40: 0x1455000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        ctx->pc = 0x1E1E78; return;
    }
    // 0x1e1e48: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e1e4c: 0xc07825e
    SET_GPR_U32(ctx, 31, 0x1e1e54);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    CchParsePchzTft__FPcP3TFTPPc(rdram, ctx, runtime); return;
}


// Function: entry_1e1e54
// Address: 0x1e1e54 - 0x1e1e70

void entry_1e1e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1e54: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1e58: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e1e5c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e1e60: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e1e64: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e1e68: 0xc078682
    SET_GPR_U32(ctx, 31, 0x1e1e70);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    WriteTft__FP3TFTP5OSTRMPPcPci(rdram, ctx, runtime); return;
}


// Function: entry_1e1e70
// Address: 0x1e1e70 - 0x1e1e88

void entry_1e1e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e1e70) {
        switch (ctx->pc) {
            case 0x1e1e78: ctx->pc = 0; goto label_1e1e78;
            case 0x1e1e80: ctx->pc = 0; goto label_1e1e80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e1e70: 0x2308821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
    // 0x1e1e74: 0x82220000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 0)));
label_1e1e78:
    // 0x1e1e78: 0x1440ffdf
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E1DF8; return;
    }
label_1e1e80:
    // 0x1e1e80: 0xc075cb2
    SET_GPR_U32(ctx, 31, 0x1e1e88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    Flush__5OSTRM(rdram, ctx, runtime); return;
}


// Function: entry_1e1e88
// Address: 0x1e1e88 - 0x1e1eb0

void entry_1e1e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1e88: 0x8e620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1e1e8c: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1e1e90: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e1e94: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1e1e98: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e1e9c: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e1ea0: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e1ea4: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e1ea8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: vprintf
// Address: 0x1e1eb0 - 0x1e1ed4

void entry_1e1ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1ed4: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e1ed8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e1edc: 0xc07876e
    SET_GPR_U32(ctx, 31, 0x1e1ee4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CchOstrmPrintf__FP5OSTRMPcT1(rdram, ctx, runtime); return;
}


// Function: entry_1e1ee4
// Address: 0x1e1ee4 - 0x1e1ef4

void entry_1e1ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1ee4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1ee8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e1eec: 0xc075c52
    SET_GPR_U32(ctx, 31, 0x1e1ef4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    scePrintf_deci(rdram, ctx, runtime); return;
}


// Function: entry_1e1ef4
// Address: 0x1e1ef4 - 0x1e1f10

void entry_1e1ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1ef4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e1ef8: 0x7bbf0440
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    // 0x1e1efc: 0x7bb10430
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x1e1f00: 0x7bb00420
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x1e1f04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1104));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e1f0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e1f10; return;
}


// Function: printf
// Address: 0x1e1f10 - 0x1e1f4c

void entry_1e1f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1f4c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e1f50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: vsprintf
// Address: 0x1e1f58 - 0x1e1f88

void entry_1e1f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1f88: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e1f8c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e1f90: 0xc07876e
    SET_GPR_U32(ctx, 31, 0x1e1f98);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CchOstrmPrintf__FP5OSTRMPcT1(rdram, ctx, runtime); return;
}


// Function: entry_1e1f98
// Address: 0x1e1f98 - 0x1e1fb0

void entry_1e1f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1f98: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e1f9c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e1fa0: 0x2118021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x1e1fa4: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e1fa8: 0xc075c52
    SET_GPR_U32(ctx, 31, 0x1e1fb0);
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 0));
    scePrintf_deci(rdram, ctx, runtime); return;
}


// Function: entry_1e1fb0
// Address: 0x1e1fb0 - 0x1e1fd0

void entry_1e1fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e1fb0: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e1fb4: 0x7bbf0450
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1104)));
    // 0x1e1fb8: 0x7bb20440
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    // 0x1e1fbc: 0x7bb10430
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x1e1fc0: 0x7bb00420
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x1e1fc4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1120));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e1fcc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e1fd0; return;
}


// Function: sprintf
// Address: 0x1e1fd0 - 0x1e2008

void entry_1e2008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2008: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e200c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e2014: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e2018; return;
}


// Function: _vsnprintf
// Address: 0x1e2018 - 0x1e2050

void entry_1e2050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2050: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e2054: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e2058: 0xc07876e
    SET_GPR_U32(ctx, 31, 0x1e2060);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CchOstrmPrintf__FP5OSTRMPcT1(rdram, ctx, runtime); return;
}


// Function: entry_1e2060
// Address: 0x1e2060 - 0x1e2090

void entry_1e2060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2060) {
        switch (ctx->pc) {
            case 0x1e2080: ctx->pc = 0; goto label_1e2080;
            case 0x1e2084: ctx->pc = 0; goto label_1e2084;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2060: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e2064: 0x213102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 19)));
    // 0x1e2068: 0x14400005
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e2080;
    }
    // 0x1e2070: 0x2721021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 18)));
    // 0x1e2074: 0x2410ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e2078: 0x10000002
    WRITE8(ADD32(GPR_U32(ctx, 2), 4294967295), (uint8_t)GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e2084;
    }
label_1e2080:
    // 0x1e2080: 0xa0400000
    WRITE8(ADD32(GPR_U32(ctx, 2), 0), (uint8_t)GPR_U32(ctx, 0));
label_1e2084:
    // 0x1e2084: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e2088: 0xc075c52
    SET_GPR_U32(ctx, 31, 0x1e2090);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    scePrintf_deci(rdram, ctx, runtime); return;
}


// Function: entry_1e2090
// Address: 0x1e2090 - 0x1e20b0

void entry_1e2090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2090: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e2094: 0x7bbf0460
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1120)));
    // 0x1e2098: 0x7bb30450
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1104)));
    // 0x1e209c: 0x7bb20440
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    // 0x1e20a0: 0x7bb10430
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x1e20a4: 0x7bb00420
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x1e20a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1136));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001E20B0
// Address: 0x1e20b0 - 0x1e20b8

void entry_1e20ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e20ec: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e20f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001E20F8
// Address: 0x1e20f8 - 0x1e2100

void entry_1e2158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2158: 0x24460001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1e215c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e2160: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1e2168);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1e2168
// Address: 0x1e2168 - 0x1e2180

void entry_1e2168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2168: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e216c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e2170: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e2174: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e2178: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: strcpy1
// Address: 0x1e2180 - 0x1e21a0

void entry_1e21a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e21a0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e21a4: 0xc078840
    SET_GPR_U32(ctx, 31, 0x1e21ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    strlen(rdram, ctx, runtime); return;
}


// Function: entry_1e21ac
// Address: 0x1e21ac - 0x1e21bc

void entry_1e21ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e21ac: 0x2112021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x1e21b0: 0x24460001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1e21b4: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1e21bc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1e21bc
// Address: 0x1e21bc - 0x1e21d8

void entry_1e21bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e21bc: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e21c0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e21c4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e21c8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e21cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e21d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: strchr
// Address: 0x1e21d8 - 0x1e2210

void entry_1e2290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2290: 0xafb00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 16));
    // 0x1e2294: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e2298: 0xc07dac8
    SET_GPR_U32(ctx, 31, 0x1e22a0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 17));
    CreateSema(rdram, ctx, runtime); return;
}


// Function: entry_1e22a0
// Address: 0x1e22a0 - 0x1e22b8

void entry_1e22a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e22a0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e22a4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e22a8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e22ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e22b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e22b8; return;
}


// Function: junk_001E22B8
// Address: 0x1e22b8 - 0x1e22c0

void entry_1e22e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e22e4: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x1e22e8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e22ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e22f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnterCritSect__FP8CRITSECT
// Address: 0x1e22f8 - 0x1e2310

void entry_1e2310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2310: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e2314: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1e2318: 0x52220007
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1E2338; return;
    }
    // 0x1e2320: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x1e2328);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_1e2328
// Address: 0x1e2328 - 0x1e2358

void entry_1e2328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2328) {
        switch (ctx->pc) {
            case 0x1e2338: ctx->pc = 0; goto label_1e2338;
            case 0x1e2340: ctx->pc = 0; goto label_1e2340;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2328: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e232c: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x1e2330: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e2340;
    }
label_1e2338:
    // 0x1e2338: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1e233c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
label_1e2340:
    // 0x1e2340: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e2344: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e2348: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e234c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e2354: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e2358; return;
}


// Function: LeaveCritSect__FP8CRITSECT
// Address: 0x1e2358 - 0x1e2384

void entry_1e2384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2384: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e2388: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001E2390
// Address: 0x1e2390 - 0x1e2398

void entry_1e23a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e23a8: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1e23ac: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e23b0: 0xae025958
    WRITE32(ADD32(GPR_U32(ctx, 16), 22872), GPR_U32(ctx, 2));
    // 0x1e23b4: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e23b8: 0xc07da94
    SET_GPR_U32(ctx, 31, 0x1e23c0);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 22872));
    ChangeThreadPriority(rdram, ctx, runtime); return;
}


// Function: entry_1e23c0
// Address: 0x1e23c0 - 0x1e23d0

void entry_1e23c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e23c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e23c4: 0x24060030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1e23c8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1e23d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1e23d0
// Address: 0x1e23d0 - 0x1e240c

void entry_1e23d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e23d0: 0x3c030060
    SET_GPR_U32(ctx, 3, ((uint32_t)96 << 16));
    // 0x1e23d4: 0x3c050028
    SET_GPR_U32(ctx, 5, ((uint32_t)40 << 16));
    // 0x1e23d8: 0x3c060016
    SET_GPR_U32(ctx, 6, ((uint32_t)22 << 16));
    // 0x1e23dc: 0x246356d0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 22224));
    // 0x1e23e0: 0x24a532f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 13040));
    // 0x1e23e4: 0x24c6ee80
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294962816));
    // 0x1e23e8: 0x24070002
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e23ec: 0x3c020002
    SET_GPR_U32(ctx, 2, ((uint32_t)2 << 16));
    // 0x1e23f0: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x1e23f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e23f8: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x1e23fc: 0xafa70014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 7));
    // 0x1e2400: 0xafa50010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 5));
    // 0x1e2404: 0xc07da84
    SET_GPR_U32(ctx, 31, 0x1e240c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 6));
    CreateThread(rdram, ctx, runtime); return;
}


// Function: entry_1e240c
// Address: 0x1e240c - 0x1e2420

void entry_1e240c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e240c: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x1e2410: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e2414: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e2418: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PtnfnFromTn__FP2TN
// Address: 0x1e2420 - 0x1e2438

void entry_1e24a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e24a8: 0xc6020078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 120)); ctx->f[2] = *(float*)&val; }
    // 0x1e24ac: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1e24b0: 0xc6010070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 112)); ctx->f[1] = *(float*)&val; }
    // 0x1e24b4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e24b8: 0xc6000074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 116)); ctx->f[0] = *(float*)&val; }
    // 0x1e24bc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e24c0: 0x8e300380
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 896)));
    // 0x1e24c4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e24c8: 0xae200380
    WRITE32(ADD32(GPR_U32(ctx, 17), 896), GPR_U32(ctx, 0));
    // 0x1e24cc: 0xe7a10014
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 20), *(uint32_t*)&val); }
    // 0x1e24d0: 0xe7a00024
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 36), *(uint32_t*)&val); }
    // 0x1e24d4: 0xc078a80
    SET_GPR_U32(ctx, 31, 0x1e24dc);
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 52), *(uint32_t*)&val); }
    CalculateTnCrv__FP2TNP6VECTORN21(rdram, ctx, runtime); return;
}


// Function: entry_1e24dc
// Address: 0x1e24dc - 0x1e2504

void entry_1e24dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e24dc: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x1e24e0: 0xc62c03a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 928)); ctx->f[12] = *(float*)&val; }
    // 0x1e24e4: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1e24e8: 0x24e759c0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 22976));
    // 0x1e24ec: 0x240482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e24f0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e24f4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e24f8: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e24fc: 0xc078afc
    SET_GPR_U32(ctx, 31, 0x1e2504);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1(rdram, ctx, runtime); return;
}


// Function: entry_1e2504
// Address: 0x1e2504 - 0x1e2520

void entry_1e2504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2504) {
        switch (ctx->pc) {
            case 0x1e2508: ctx->pc = 0; goto label_1e2508;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2504: 0xae300380
    WRITE32(ADD32(GPR_U32(ctx, 17), 896), GPR_U32(ctx, 16));
label_1e2508:
    // 0x1e2508: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e250c: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e2510: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e2514: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e2518: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitTn__FP2TN
// Address: 0x1e2520 - 0x1e2534

void entry_1e2534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2534) {
        switch (ctx->pc) {
            case 0x1e2544: ctx->pc = 0; goto label_1e2544;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2534: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e2538: 0x260302f0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 752));
    // 0x1e253c: 0x24425980
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 22912));
    // 0x1e2540: 0x24440080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 128));
label_1e2544:
    // 0x1e2544: 0x78450000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e2548: 0x78460010
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1e254c: 0x7c650000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 5));
    // 0x1e2550: 0x7c660010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 6));
    // 0x1e2554: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x1e2558: 0x1444fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_1e2544;
    }
    // 0x1e2560: 0x78440000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e2564: 0x7c640000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 4));
    // 0x1e2568: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x1e256c: 0x2404fcff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294966527));
    // 0x1e2570: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1e2574: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1e2578: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1e257c: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1e2580: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1e2584: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e2588: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1e258c: 0x52e78
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 25);
    // 0x1e2590: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e2594: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e2598: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1e259c: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1e25a0: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e25a4: 0xe6010420
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1056), *(uint32_t*)&val); }
    // 0x1e25a8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e25ac: 0xe6000424
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1060), *(uint32_t*)&val); }
    // 0x1e25b0: 0x24635a10
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 23056));
    // 0x1e25b4: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    // 0x1e25b8: 0xe6010428
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1064), *(uint32_t*)&val); }
    // 0x1e25bc: 0xe600042c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1068), *(uint32_t*)&val); }
    // 0x1e25c0: 0xae060430
    WRITE32(ADD32(GPR_U32(ctx, 16), 1072), GPR_U32(ctx, 6));
    // 0x1e25c4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e25c8: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e25cc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e25d0: 0x7e020450
    WRITE128(ADD32(GPR_U32(ctx, 16), 1104), GPR_VEC(ctx, 2));
    // 0x1e25d4: 0x24655a20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 23072));
    // 0x1e25d8: 0x68a80007
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1e25dc: 0x6ca80000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x1e25e0: 0xb2080467
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1127); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e25e4: 0xb6080460
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1120); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e25e8: 0xae060398
    WRITE32(ADD32(GPR_U32(ctx, 16), 920), GPR_U32(ctx, 6));
    // 0x1e25ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e25f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnTnRemove__FP2TN
// Address: 0x1e25f8 - 0x1e260c

void entry_1e260c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e260c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e2610: 0xc0789de
    SET_GPR_U32(ctx, 31, 0x1e2618);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTnTns__FP2TN3TNS(rdram, ctx, runtime); return;
}


// Function: entry_1e2618
// Address: 0x1e2618 - 0x1e2634

void entry_1e2618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2618: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1e261c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e2620: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e2624: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e2628: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e262c: 0xc076f50
    SET_GPR_U32(ctx, 31, 0x1e2634);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ClearSwCallbacks__FP2SWiPFPv5MSGIDPv_vPv5MSGIDT3(rdram, ctx, runtime); return;
}


// Function: entry_1e2634
// Address: 0x1e2634 - 0x1e2648

void entry_1e2634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2634: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e2638: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e263c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e2644: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e2648; return;
}


// Function: LoadTnFromBrx__FP2TNP18CBinaryInputStream
// Address: 0x1e2648 - 0x1e266c

void entry_1e266c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e266c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e2670: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x1e2678);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 256));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1e2678
// Address: 0x1e2678 - 0x1e2690

void entry_1e2678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2678: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e267c: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x1e2680: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1E2694; return;
    }
    // 0x1e2688: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e2690);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e2690
// Address: 0x1e2690 - 0x1e26a8

void entry_1e2690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2690) {
        switch (ctx->pc) {
            case 0x1e2694: ctx->pc = 0; goto label_1e2694;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2690: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1e2694:
    // 0x1e2694: 0x260502d4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 724));
    // 0x1e2698: 0x260602d8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 728));
    // 0x1e269c: 0x260702dc
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 732));
    // 0x1e26a0: 0xc079312
    SET_GPR_U32(ctx, 31, 0x1e26a8);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 736));
    LoadTbspFromBrx__FP18CBinaryInputStreamPiPP5TSURFT1PP4TBSP(rdram, ctx, runtime); return;
}


// Function: entry_1e26a8
// Address: 0x1e26a8 - 0x1e26b0

void entry_1e26a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e26a8: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x1e26b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1e26b0
// Address: 0x1e26b0 - 0x1e26c8

void entry_1e26b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e26b0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e26b4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e26b8: 0x50820013
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x1E2708; return;
    }
    // 0x1e26c0: 0xc05366a
    SET_GPR_U32(ctx, 31, 0x1e26c8);
    PcrvNew__F4CRVK(rdram, ctx, runtime); return;
}


// Function: entry_1e26c8
// Address: 0x1e26c8 - 0x1e26e8

void entry_1e26c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e26c8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e26cc: 0xae0202e4
    WRITE32(ADD32(GPR_U32(ctx, 16), 740), GPR_U32(ctx, 2));
    // 0x1e26d0: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e26d4: 0x8c420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e26d8: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        ctx->pc = 0x1E26EC; return;
    }
    // 0x1e26e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e26e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e26e8
// Address: 0x1e26e8 - 0x1e2710

void entry_1e26e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e26e8) {
        switch (ctx->pc) {
            case 0x1e26ec: ctx->pc = 0; goto label_1e26ec;
            case 0x1e2708: ctx->pc = 0; goto label_1e2708;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e26e8: 0x8e0302e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_1e26ec:
    // 0x1e26ec: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x1e26f0: 0x8c640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x1e26f4: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1e26f8: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1e26fc: 0xc440fffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[0] = *(float*)&val; }
    // 0x1e2700: 0x10000007
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1008), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E2720; return;
    }
label_1e2708:
    // 0x1e2708: 0xc04dfac
    SET_GPR_U32(ctx, 31, 0x1e2710);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 944));
    ReadMatrix__18CBinaryInputStreamP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1e2710
// Address: 0x1e2710 - 0x1e271c

void entry_1e2710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2710: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e2714: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x1e271c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 992));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1e271c
// Address: 0x1e271c - 0x1e2740

void entry_1e271c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e271c) {
        switch (ctx->pc) {
            case 0x1e2720: ctx->pc = 0; goto label_1e2720;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e271c: 0xae0003f0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1008), GPR_U32(ctx, 0));
label_1e2720:
    // 0x1e2720: 0x8e0202e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    // 0x1e2724: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1e2728: 0x24030005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1e272c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e2730: 0xa2180b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 5));
    // 0x1e2734: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e2738: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x1e2740);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1044), GPR_U32(ctx, 3));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1e2740
// Address: 0x1e2740 - 0x1e2758

void entry_1e2740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2740: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e2744: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e2748: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e274c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e2754: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e2758; return;
}


// Function: PostTnLoad__FP2TN
// Address: 0x1e2758 - 0x1e2768

void entry_1e2768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2768: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e276c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e2774: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e2778; return;
}


// Function: SetTnTns__FP2TN3TNS
// Address: 0x1e2778 - 0x1e27cc

void entry_1e27cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e27cc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e27d0: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e27d4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e27d8: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1e27e0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1e27e0
// Address: 0x1e27e0 - 0x1e2808

void entry_1e27e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e27e0) {
        switch (ctx->pc) {
            case 0x1e27e8: ctx->pc = 0; goto label_1e27e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e27e0: 0x1000000f
    WRITE32(ADD32(GPR_U32(ctx, 16), 916), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E2820; return;
    }
label_1e27e8:
    // 0x1e27e8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e27ec: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1e27f0: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1e27f4: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e27f8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e27fc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e2800: 0xc05147c
    SET_GPR_U32(ctx, 31, 0x1e2808);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RevokeCmPolicy(rdram, ctx, runtime); return;
}


// Function: entry_1e2808
// Address: 0x1e2808 - 0x1e281c

void entry_1e2808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2808: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e280c: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1e2810: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e2814: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1e281c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1e281c
// Address: 0x1e281c - 0x1e2840

void entry_1e281c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e281c) {
        switch (ctx->pc) {
            case 0x1e2820: ctx->pc = 0; goto label_1e2820;
            case 0x1e2830: ctx->pc = 0; goto label_1e2830;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e281c: 0xae110394
    WRITE32(ADD32(GPR_U32(ctx, 16), 916), GPR_U32(ctx, 17));
label_1e2820:
    // 0x1e2820: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e2824: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1e2828: 0xe600039c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 924), *(uint32_t*)&val); }
    // 0x1e282c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1e2830:
    // 0x1e2830: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e2834: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e2838: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001e2840__FP2TN3TNS
// Address: 0x1e2840 - 0x1e2860

void FUN_001e2840__FP2TN3TNS(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2840: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1e2844: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1e2848: 0x8c820398
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 920)));
    // 0x1e284c: 0x10a20004
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        entry_1e2860(rdram, ctx, runtime); return;
    }
    // 0x1e2854: 0xac850398
    WRITE32(ADD32(GPR_U32(ctx, 4), 920), GPR_U32(ctx, 5));
    // 0x1e2858: 0xc078a1c
    SET_GPR_U32(ctx, 31, 0x1e2860);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UpdateTnCallback__FP2TN5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_1e2860
// Address: 0x1e2860 - 0x1e2870

void entry_1e2860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2860: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e2864: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e286c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e2870; return;
}


// Function: UpdateTnCallback__FP2TN5MSGIDPv
// Address: 0x1e2870 - 0x1e2888

void entry_1e2888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2888: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e288c: 0x12200027
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E292C; return;
    }
    // 0x1e2894: 0x8e0202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x1e2898: 0x12220004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E28AC; return;
    }
    // 0x1e28a0: 0xc0789de
    SET_GPR_U32(ctx, 31, 0x1e28a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTnTns__FP2TN3TNS(rdram, ctx, runtime); return;
}


// Function: entry_1e28a8
// Address: 0x1e28a8 - 0x1e28d0

void entry_1e28a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e28a8) {
        switch (ctx->pc) {
            case 0x1e28ac: ctx->pc = 0; goto label_1e28ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e28a8: 0xae1102d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 720), GPR_U32(ctx, 17));
label_1e28ac:
    // 0x1e28ac: 0x8e050398
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 920)));
    // 0x1e28b0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e28b4: 0x54a2000b
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 900)));
        ctx->pc = 0x1E28E4; return;
    }
    // 0x1e28bc: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e28c0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e28c4: 0x26260140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1e28c8: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1e28d0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1e28d0
// Address: 0x1e28d0 - 0x1e28dc

void entry_1e28d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e28d0: 0x8e0402e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 736)));
    // 0x1e28d4: 0xc079370
    SET_GPR_U32(ctx, 31, 0x1e28dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FCheckTbspPoint__FP4TBSPP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1e28dc
// Address: 0x1e28dc - 0x1e2928

void entry_1e28dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e28dc) {
        switch (ctx->pc) {
            case 0x1e28e4: ctx->pc = 0; goto label_1e28e4;
            case 0x1e2920: ctx->pc = 0; goto label_1e2920;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e28dc: 0x2282b
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1e28e0: 0x8e020384
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 900)));
label_1e28e4:
    // 0x1e28e4: 0x1440000e
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e2920;
    }
    // 0x1e28ec: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1e28f0: 0x1623000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 3)) {
        goto label_1e2920;
    }
    // 0x1e28f8: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x1e28fc: 0x14620008
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e2920;
    }
    // 0x1e2904: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1e2908: 0x8c640224
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    // 0x1e290c: 0x14800004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1e2920;
    }
    // 0x1e2914: 0x8e030398
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 920)));
    // 0x1e2918: 0x10620004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E292C; return;
    }
label_1e2920:
    // 0x1e2920: 0xc0789de
    SET_GPR_U32(ctx, 31, 0x1e2928);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetTnTns__FP2TN3TNS(rdram, ctx, runtime); return;
}


// Function: entry_1e2928
// Address: 0x1e2928 - 0x1e2940

void entry_1e2928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2928) {
        switch (ctx->pc) {
            case 0x1e292c: ctx->pc = 0; goto label_1e292c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2928: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1e292c:
    // 0x1e292c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e2930: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e2934: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e293c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e2940; return;
}


// Function: UpdateTn__FP2TNf
// Address: 0x1e2940 - 0x1e2954

void entry_1e2954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2954: 0x8e020398
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 920)));
    // 0x1e2958: 0x10400007
    SET_GPR_U32(ctx, 5, ((uint32_t)30 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e2978(rdram, ctx, runtime); return;
    }
    // 0x1e2960: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1e2964: 0x24a52870
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 10352));
    // 0x1e2968: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e296c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e2970: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x1e2978);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_1e2978
// Address: 0x1e2978 - 0x1e2988

void entry_1e2978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2978: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e297c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e2980: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderTnSelf__FP2TNP2CMP2RO
// Address: 0x1e2988 - 0x1e2998

void entry_1e2998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2998: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e299c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e29a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e29a8; return;
}


// Function: FreezeTn__FP2TNi
// Address: 0x1e29a8 - 0x1e29c4

void entry_1e29c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e29c4: 0x12000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1e29d4(rdram, ctx, runtime); return;
    }
    // 0x1e29cc: 0xc0789de
    SET_GPR_U32(ctx, 31, 0x1e29d4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTnTns__FP2TN3TNS(rdram, ctx, runtime); return;
}


// Function: entry_1e29d4
// Address: 0x1e29d4 - 0x1e29e8

void entry_1e29d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e29d4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e29d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e29dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e29e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001e29e8
// Address: 0x1e29e8 - 0x1e2a00

void FUN_001e29e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e29e8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e29ec: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e29f0: 0xe48c0360
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 4), 864), *(uint32_t*)&val); }
    // 0x1e29f4: 0xe4800368
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 872), *(uint32_t*)&val); }
    // 0x1e29f8: 0x3e00008
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 4), 868), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateTnCrv__FP2TNP6VECTORN21
// Address: 0x1e2a00 - 0x1e2a34

void entry_1e2a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2a34: 0x8e0402e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    // 0x1e2a38: 0x5080001f
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 908)));
        ctx->pc = 0x1E2AB8; return;
    }
    // 0x1e2a40: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e2a44: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1e2a48: 0x10400004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e2a5c(rdram, ctx, runtime); return;
    }
    // 0x1e2a50: 0xc60c03a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 928)); ctx->f[12] = *(float*)&val; }
    // 0x1e2a54: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e2a5c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e2a5c
// Address: 0x1e2a5c - 0x1e2a70

void entry_1e2a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2a5c: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1e2a60: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e2a64: 0x24a58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937888));
    // 0x1e2a68: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x1e2a70);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1e2a70
// Address: 0x1e2a70 - 0x1e2ad8

void entry_1e2a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2a70) {
        switch (ctx->pc) {
            case 0x1e2ab8: ctx->pc = 0; goto label_1e2ab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2a70: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e2a74: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e2a78: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e2a7c: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e2a80: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e2a84: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e2a88: 0x4be3222a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1e2a8c: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x1e2a90: 0x4be311ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e2a94: 0x4be309aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e2a98: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1e2a9c: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2aa0: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1e2aa4: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2aa8: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1e2aac: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2ab0: 0x10000049
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[5]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E2BD8; return;
    }
label_1e2ab8:
    // 0x1e2ab8: 0x10400031
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E2B80; return;
    }
    // 0x1e2ac0: 0xc60c0410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1040)); ctx->f[12] = *(float*)&val; }
    // 0x1e2ac4: 0xc60003a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 928)); ctx->f[0] = *(float*)&val; }
    // 0x1e2ac8: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1e2acc: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x1e2ad0: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1e2ad8);
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[12];
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1e2ad8
// Address: 0x1e2ad8 - 0x1e2b38

void entry_1e2ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2ad8: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1e2adc: 0xdba30050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e2ae0: 0x24a58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937888));
    // 0x1e2ae4: 0xda020400
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1024)));
    // 0x1e2ae8: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1e2aec: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e2af0: 0x4bc30afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[3] = READ32(addr); }
    // 0x1e2af4: 0x4bc1186e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2af8: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e2afc: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e2b00: 0x4bc108ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e2b04: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1e2b08: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e2b0c: 0x4b0320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2b10: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e2b14: 0x4a0303bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e2b18: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e2b1c: 0x4b0000e0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e2b20: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1e2b24: 0x4a6303bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1e2b28: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e2b2c: 0x4be008dc
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1e2b30: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x1e2b38);
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1e2b38
// Address: 0x1e2b38 - 0x1e2bf0

void entry_1e2b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2b38) {
        switch (ctx->pc) {
            case 0x1e2b80: ctx->pc = 0; goto label_1e2b80;
            case 0x1e2bd8: ctx->pc = 0; goto label_1e2bd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2b38: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e2b3c: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e2b40: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e2b44: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e2b48: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e2b4c: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e2b50: 0x4be3222a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1e2b54: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x1e2b58: 0x4be311ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e2b5c: 0x4be309aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e2b60: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1e2b64: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2b68: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1e2b6c: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2b70: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1e2b74: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2b78: 0x10000017
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[5]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e2bd8;
    }
label_1e2b80:
    // 0x1e2b80: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1e2b84: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e2b88: 0x24638d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x1e2b8c: 0x260403b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 944));
    // 0x1e2b90: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e2b94: 0x7e220000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    // 0x1e2b98: 0xda0103e0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 992)));
    // 0x1e2b9c: 0x4be1212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1e2ba0: 0xda0303b0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 944)));
    // 0x1e2ba4: 0xd8820020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x1e2ba8: 0xd8810010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1e2bac: 0x4be41a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e2bb0: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x1e2bb4: 0x4be409ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e2bb8: 0x4be411aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e2bbc: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x1e2bc0: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2bc4: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1e2bc8: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2bcc: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1e2bd0: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2bd4: 0xfa450000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[5]));
label_1e2bd8:
    // 0x1e2bd8: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1e2bdc: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e2be0: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e2be4: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e2be8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1
// Address: 0x1e2bf0 - 0x1e2ccc

void entry_1e2ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2ccc) {
        switch (ctx->pc) {
            case 0x1e2ce4: ctx->pc = 0; goto label_1e2ce4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2ccc: 0x8e2402e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 740)));
    // 0x1e2cd0: 0x10800010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E2D14; return;
    }
    // 0x1e2cd8: 0x52020002
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->f[12] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
        goto label_1e2ce4;
    }
    // 0x1e2ce0: 0x4614ab01
    ctx->f[12] = FPU_SUB_S(ctx->f[21], ctx->f[20]);
label_1e2ce4:
    // 0x1e2ce4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e2ce8: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1e2cec: 0x10400004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e2d00(rdram, ctx, runtime); return;
    }
    // 0x1e2cf4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e2cf8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e2d00);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e2d00
// Address: 0x1e2d00 - 0x1e2d4c

void entry_1e2d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2d00) {
        switch (ctx->pc) {
            case 0x1e2d14: ctx->pc = 0; goto label_1e2d14;
            case 0x1e2d40: ctx->pc = 0; goto label_1e2d40;
            case 0x1e2d44: ctx->pc = 0; goto label_1e2d44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2d00: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1e2d04: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e2d08: 0x24a58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937888));
    // 0x1e2d0c: 0x1000002b
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E2DBC; return;
    }
label_1e2d14:
    // 0x1e2d14: 0x8e22038c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 908)));
    // 0x1e2d18: 0x10400033
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E2DE8; return;
    }
    // 0x1e2d20: 0xc6200410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1040)); ctx->f[0] = *(float*)&val; }
    // 0x1e2d24: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1e2d28: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1e2d2c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e2d30: 0x12020003
    ctx->f[13] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_1e2d40;
    }
    // 0x1e2d38: 0x10000002
    ctx->f[12] = FPU_SUB_S(ctx->f[21], ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e2d44;
    }
label_1e2d40:
    // 0x1e2d40: 0x4614ab00
    ctx->f[12] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
label_1e2d44:
    // 0x1e2d44: 0xc081628
    SET_GPR_U32(ctx, 31, 0x1e2d4c);
    fmodf(rdram, ctx, runtime); return;
}


// Function: entry_1e2d4c
// Address: 0x1e2d4c - 0x1e2d60

void entry_1e2d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2d4c: 0xc62d0410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1040)); ctx->f[13] = *(float*)&val; }
    // 0x1e2d50: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e2d54: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x1e2d58: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1e2d60);
    if (ctx->f[13] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[12] = ctx->f[0] / ctx->f[13];
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1e2d60
// Address: 0x1e2d60 - 0x1e2dc4

void entry_1e2d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2d60) {
        switch (ctx->pc) {
            case 0x1e2dbc: ctx->pc = 0; goto label_1e2dbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2d60: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1e2d64: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e2d68: 0x24a58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937888));
    // 0x1e2d6c: 0xda220400
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1024)));
    // 0x1e2d70: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1e2d74: 0x4be218a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e2d78: 0x4bc30afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[3] = READ32(addr); }
    // 0x1e2d7c: 0x4bc1186e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2d80: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e2d84: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e2d88: 0x4bc108ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e2d8c: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1e2d90: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e2d94: 0x4b0320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2d98: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e2d9c: 0x4a0303bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e2da0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e2da4: 0x4b0000e0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e2da8: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1e2dac: 0x4a6303bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1e2db0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e2db4: 0x4be008dc
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1e2db8: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
label_1e2dbc:
    // 0x1e2dbc: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x1e2dc4);
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1e2dc4
// Address: 0x1e2dc4 - 0x1e2e44

void entry_1e2dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2dc4) {
        switch (ctx->pc) {
            case 0x1e2de8: ctx->pc = 0; goto label_1e2de8;
            case 0x1e2e20: ctx->pc = 0; goto label_1e2e20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2dc4: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e2dc8: 0xdba40030
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e2dcc: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e2dd0: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e2dd4: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1e2dd8: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e2ddc: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2de0: 0x1000000f
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e2e20;
    }
label_1e2de8:
    // 0x1e2de8: 0xc7a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1e2dec: 0x262303b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 944));
    // 0x1e2df0: 0x7a2203e0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 992)));
    // 0x1e2df4: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1e2df8: 0xda2403b0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 944)));
    // 0x1e2dfc: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x1e2e00: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x1e2e04: 0xd8630020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1e2e08: 0xd8620010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1e2e0c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e2e10: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1e2e14: 0x4bc110bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e2e18: 0x4bc1184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e2e1c: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
label_1e2e20:
    // 0x1e2e20: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e2e24: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e2e28: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e2e2c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e2e30: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e2e34: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e2e38: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e2e3c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1e2e44);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1e2e44
// Address: 0x1e2e44 - 0x1e2e68

void entry_1e2e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2e44: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1e2e48: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e2e4c: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1e2e50: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e2e54: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e2e58: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x1e2e5c: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x1e2e60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ActivateCptn__FP4CPTNPv
// Address: 0x1e2e68 - 0x1e2eac

void entry_1e2eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2eac: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1e2eb0: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e2eb4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e2eb8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e2ebc: 0xc050d06
    SET_GPR_U32(ctx, 31, 0x1e2ec4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    GetCmCpdefi__FP2CMP2SOfP6CPDEFI(rdram, ctx, runtime); return;
}


// Function: entry_1e2ec4
// Address: 0x1e2ec4 - 0x1e2edc

void entry_1e2ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2ec4: 0x27a60050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1e2ec8: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e2ecc: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1e2ed0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e2ed4: 0xc07890e
    SET_GPR_U32(ctx, 31, 0x1e2edc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetTnfnNose__FP4TNFNP6CPDEFIP6VECTORP2TN(rdram, ctx, runtime); return;
}


// Function: entry_1e2edc
// Address: 0x1e2edc - 0x1e2f04

void entry_1e2edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2edc: 0x52600021
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
        ctx->pc = 0x1E2F64; return;
    }
    // 0x1e2ee4: 0x8e6202e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 740)));
    // 0x1e2ee8: 0x10400013
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E2F38; return;
    }
    // 0x1e2ef0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e2ef4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e2ef8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e2efc: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1e2f04);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1e2f04
// Address: 0x1e2f04 - 0x1e2f30

void entry_1e2f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2f04: 0x8e6402e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 740)));
    // 0x1e2f08: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e2f0c: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x1e2f10: 0x1040000e
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e2f4c(rdram, ctx, runtime); return;
    }
    // 0x1e2f18: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e2f1c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e2f20: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e2f24: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e2f28: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e2f30);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 19), 928));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e2f30
// Address: 0x1e2f30 - 0x1e2f4c

void entry_1e2f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2f30) {
        switch (ctx->pc) {
            case 0x1e2f38: ctx->pc = 0; goto label_1e2f38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2f30: 0x10000007
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E2F50; return;
    }
label_1e2f38:
    // 0x1e2f38: 0x8e62038c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 908)));
    // 0x1e2f3c: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e2f4c(rdram, ctx, runtime); return;
    }
    // 0x1e2f44: 0xc078c3a
    SET_GPR_U32(ctx, 31, 0x1e2f4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_001e30e8(rdram, ctx, runtime); return;
}


// Function: entry_1e2f4c
// Address: 0x1e2f4c - 0x1e2f60

void entry_1e2f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2f4c) {
        switch (ctx->pc) {
            case 0x1e2f50: ctx->pc = 0; goto label_1e2f50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2f4c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1e2f50:
    // 0x1e2f50: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e2f54: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e2f58: 0xc07890e
    SET_GPR_U32(ctx, 31, 0x1e2f60);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    GetTnfnNose__FP4TNFNP6CPDEFIP6VECTORP2TN(rdram, ctx, runtime); return;
}


// Function: entry_1e2f60
// Address: 0x1e2f60 - 0x1e2f94

void entry_1e2f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e2f60) {
        switch (ctx->pc) {
            case 0x1e2f64: ctx->pc = 0; goto label_1e2f64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e2f60: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
label_1e2f64:
    // 0x1e2f64: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e2f68: 0x8e221990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 6544)));
    // 0x1e2f6c: 0x27b00070
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1e2f70: 0x26840040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 64));
    // 0x1e2f74: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e2f78: 0xd8410270
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 624)));
    // 0x1e2f7c: 0x2646000c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 12));
    // 0x1e2f80: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e2f84: 0x26470010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 16));
    // 0x1e2f88: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e2f8c: 0xc05150e
    SET_GPR_U32(ctx, 31, 0x1e2f94);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 18), 20));
    DecomposeCylind(rdram, ctx, runtime); return;
}


// Function: entry_1e2f94
// Address: 0x1e2f94 - 0x1e2fdc

void entry_1e2f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2f94: 0xc6430010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16)); ctx->f[3] = *(float*)&val; }
    // 0x1e2f98: 0xc6420014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 20)); ctx->f[2] = *(float*)&val; }
    // 0x1e2f9c: 0x46031802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[3]);
    // 0x1e2fa0: 0x46021042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[2]);
    // 0x1e2fa4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1e2fa8: 0x46000104
    ctx->f[4] = FPU_SQRT_S(ctx->f[0]);
    // 0x1e2fac: 0xc68001e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 484)); ctx->f[0] = *(float*)&val; }
    // 0x1e2fb0: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1e2fb4: 0xc64c000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 12)); ctx->f[12] = *(float*)&val; }
    // 0x1e2fb8: 0x46002001
    ctx->f[0] = FPU_SUB_S(ctx->f[4], ctx->f[0]);
    // 0x1e2fbc: 0x46040003
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[4];
    // 0x1e2fc0: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1e2fc4: 0x460018c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1e2fc8: 0x46001386
    ctx->f[14] = FPU_MOV_S(ctx->f[2]);
    // 0x1e2fcc: 0xe6420014
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 18), 20), *(uint32_t*)&val); }
    // 0x1e2fd0: 0x46001b46
    ctx->f[13] = FPU_MOV_S(ctx->f[3]);
    // 0x1e2fd4: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1e2fdc);
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 18), 16), *(uint32_t*)&val); }
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1e2fdc
// Address: 0x1e2fdc - 0x1e3008

void entry_1e2fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e2fdc: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e2fe0: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e2fe4: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e2fe8: 0xae400020
    WRITE32(ADD32(GPR_U32(ctx, 18), 32), GPR_U32(ctx, 0));
    // 0x1e2fec: 0x12600006
    WRITE128(ADD32(GPR_U32(ctx, 18), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        entry_1e3008(rdram, ctx, runtime); return;
    }
    // 0x1e2ff4: 0x8e620434
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1076)));
    // 0x1e2ff8: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e3008(rdram, ctx, runtime); return;
    }
    // 0x1e3000: 0xc051570
    SET_GPR_U32(ctx, 31, 0x1e3008);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetCmCut__FP2CMPf(rdram, ctx, runtime); return;
}


// Function: entry_1e3008
// Address: 0x1e3008 - 0x1e3078

void entry_1e3008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3008) {
        switch (ctx->pc) {
            case 0x1e3064: ctx->pc = 0; goto label_1e3064;
            case 0x1e3068: ctx->pc = 0; goto label_1e3068;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3008: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e300c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1e3010: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e3014: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1e3018: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1e301c: 0xe6400060
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 96), *(uint32_t*)&val); }
    // 0x1e3020: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1e3024: 0xe6410040
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 64), *(uint32_t*)&val); }
    // 0x1e3028: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1e302c: 0xae400028
    WRITE32(ADD32(GPR_U32(ctx, 18), 40), GPR_U32(ctx, 0));
    // 0x1e3030: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e3034: 0x1260000b
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 48), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1e3064;
    }
    // 0x1e303c: 0xc6610438
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1080)); ctx->f[1] = *(float*)&val; }
    // 0x1e3040: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1e3044: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3048: 0x0
    // NOP
    // 0x1e304c: 0x45030006
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 92)); ctx->f[13] = *(float*)&val; }
        goto label_1e3068;
    }
    // 0x1e3054: 0x8e221990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 6544)));
    // 0x1e3058: 0xc44001c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 456)); ctx->f[0] = *(float*)&val; }
    // 0x1e305c: 0xe660043c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 1084), *(uint32_t*)&val); }
    // 0x1e3060: 0xe44101c8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 456), *(uint32_t*)&val); }
label_1e3064:
    // 0x1e3064: 0xc6ad005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 92)); ctx->f[13] = *(float*)&val; }
label_1e3068:
    // 0x1e3068: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e306c: 0xc6ac0058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 88)); ctx->f[12] = *(float*)&val; }
    // 0x1e3070: 0xc051584
    SET_GPR_U32(ctx, 31, 0x1e3078);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AdaptCm(rdram, ctx, runtime); return;
}


// Function: entry_1e3078
// Address: 0x1e3078 - 0x1e30a0

void entry_1e3078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3078: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1e307c: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1e3080: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1e3084: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1e3088: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1e308c: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e3090: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1e3094: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e309c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e30a0; return;
}


// Function: DeactivateCptn__FP4CPTNPv
// Address: 0x1e30a0 - 0x1e30d8

void FUN_001e30e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e30e8) {
        switch (ctx->pc) {
            case 0x1e311c: ctx->pc = 0; goto label_1e311c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e30e8: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x1e30ec: 0x7fb10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 17));
    // 0x1e30f0: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x1e30f4: 0x7fb00030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 16));
    // 0x1e30f8: 0x8c900008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1e30fc: 0x12000037
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E31DC; return;
    }
    // 0x1e3104: 0x8e0202e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    // 0x1e3108: 0x14400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e311c;
    }
    // 0x1e3110: 0x8e02038c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 908)));
    // 0x1e3114: 0x10400032
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E31E0; return;
    }
label_1e311c:
    // 0x1e311c: 0xc078908
    SET_GPR_U32(ctx, 31, 0x1e3124);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PtnfnFromTn__FP2TN(rdram, ctx, runtime); return;
}


// Function: entry_1e3124
// Address: 0x1e3124 - 0x1e3138

void entry_1e3124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3124: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e3128: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e312c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e3130: 0xc07890e
    SET_GPR_U32(ctx, 31, 0x1e3138);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetTnfnNose__FP4TNFNP6CPDEFIP6VECTORP2TN(rdram, ctx, runtime); return;
}


// Function: entry_1e3138
// Address: 0x1e3138 - 0x1e3150

void entry_1e3138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3138: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e313c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e3140: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e3144: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e3148: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1e3150);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1e3150
// Address: 0x1e3150 - 0x1e3188

void entry_1e3150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3150: 0x8e0402e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    // 0x1e3154: 0x5080000e
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1024)));
        ctx->pc = 0x1E3190; return;
    }
    // 0x1e315c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e3160: 0x8c420030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x1e3164: 0x1040001d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E31DC; return;
    }
    // 0x1e316c: 0xc60c03a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 928)); ctx->f[12] = *(float*)&val; }
    // 0x1e3170: 0x260a03a0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 16), 928));
    // 0x1e3174: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e3178: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e317c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e3180: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e3188);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e3188
// Address: 0x1e3188 - 0x1e31a8

void entry_1e3188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3188) {
        switch (ctx->pc) {
            case 0x1e3190: ctx->pc = 0; goto label_1e3190;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3188: 0x10000015
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E31E0; return;
    }
label_1e3190:
    // 0x1e3190: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e3194: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e3198: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e319c: 0xc7ac0024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[12] = *(float*)&val; }
    // 0x1e31a0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1e31a8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1e31a8
// Address: 0x1e31a8 - 0x1e31f0

void entry_1e31a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e31a8) {
        switch (ctx->pc) {
            case 0x1e31d4: ctx->pc = 0; goto label_1e31d4;
            case 0x1e31dc: ctx->pc = 0; goto label_1e31dc;
            case 0x1e31e0: ctx->pc = 0; goto label_1e31e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e31a8: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1e31ac: 0x46000086
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    // 0x1e31b0: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e31b4: 0x0
    // NOP
    // 0x1e31b8: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1040)); ctx->f[0] = *(float*)&val; }
        goto label_1e31d4;
    }
    // 0x1e31c0: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1e31c4: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1e31c8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e31cc: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1e31d0: 0xc6000410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1040)); ctx->f[0] = *(float*)&val; }
label_1e31d4:
    // 0x1e31d4: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1e31d8: 0xe60003a0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 928), *(uint32_t*)&val); }
label_1e31dc:
    // 0x1e31dc: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1e31e0:
    // 0x1e31e0: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e31e4: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e31e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateCptn__FP4CPTNP6CPDEFIP3JOYf
// Address: 0x1e31f0 - 0x1e32c0

void entry_1e32c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e32c0: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1e32c4: 0xc078908
    SET_GPR_U32(ctx, 31, 0x1e32cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PtnfnFromTn__FP2TN(rdram, ctx, runtime); return;
}


// Function: entry_1e32cc
// Address: 0x1e32cc - 0x1e32e4

void entry_1e32cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e32cc: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e32d0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e32d4: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1e32d8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e32dc: 0xc07890e
    SET_GPR_U32(ctx, 31, 0x1e32e4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetTnfnNose__FP4TNFNP6CPDEFIP6VECTORP2TN(rdram, ctx, runtime); return;
}


// Function: entry_1e32e4
// Address: 0x1e32e4 - 0x1e333c

void entry_1e32e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e32e4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1e32e8: 0x8c622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x1e32ec: 0x17c20014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E3340; return;
    }
    // 0x1e32f4: 0x8fc3268c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 9868)));
    // 0x1e32f8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e32fc: 0x14620010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E3340; return;
    }
    // 0x1e3304: 0xdbc12690
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 30), 9872)));
    // 0x1e3308: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1e330c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e3310: 0x4600db86
    ctx->f[14] = FPU_MOV_S(ctx->f[27]);
    // 0x1e3314: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3318: 0x3c014100
    SET_GPR_U32(ctx, 1, ((uint32_t)16640 << 16));
    // 0x1e331c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e3320: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e3324: 0x3c01c0c0
    SET_GPR_U32(ctx, 1, ((uint32_t)49344 << 16));
    // 0x1e3328: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e332c: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1e3330: 0x24850270
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 624));
    // 0x1e3334: 0xc050c60
    SET_GPR_U32(ctx, 31, 0x1e333c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 640));
    SpringCm__FfffP2CMP6VECTORP6VECTORP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1e333c
// Address: 0x1e333c - 0x1e337c

void entry_1e333c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e333c) {
        switch (ctx->pc) {
            case 0x1e3340: ctx->pc = 0; goto label_1e3340;
            case 0x1e3364: ctx->pc = 0; goto label_1e3364;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e333c: 0x8e031990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
label_1e3340:
    // 0x1e3340: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1e3344: 0xd8620270
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 624)));
    // 0x1e3348: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e334c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1e3350: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3354: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1e3358: 0x14400002
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e3364;
    }
    // 0x1e3360: 0xc6cd0064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 100)); ctx->f[13] = *(float*)&val; }
label_1e3364:
    // 0x1e3364: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e3368: 0xc62c0044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 68)); ctx->f[12] = *(float*)&val; }
    // 0x1e336c: 0x24845a80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23168));
    // 0x1e3370: 0x4600db86
    ctx->f[14] = FPU_MOV_S(ctx->f[27]);
    // 0x1e3374: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1e337c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1e337c
// Address: 0x1e337c - 0x1e33bc

void entry_1e337c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e337c: 0xe6200044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 68), *(uint32_t*)&val); }
    // 0x1e3380: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e3384: 0xafa30110
    WRITE32(ADD32(GPR_U32(ctx, 29), 272), GPR_U32(ctx, 3));
    // 0x1e3388: 0xc6210040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 64)); ctx->f[1] = *(float*)&val; }
    // 0x1e338c: 0xc6600038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 56)); ctx->f[0] = *(float*)&val; }
    // 0x1e3390: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1e3394: 0x12400047
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_1e34b4(rdram, ctx, runtime); return;
    }
    // 0x1e339c: 0x32a20003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 3));
    // 0x1e33a0: 0x10400044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e34b4(rdram, ctx, runtime); return;
    }
    // 0x1e33a8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e33ac: 0xc0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1e33b0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e33b4: 0xc078a80
    SET_GPR_U32(ctx, 31, 0x1e33bc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    CalculateTnCrv__FP2TNP6VECTORN21(rdram, ctx, runtime); return;
}


// Function: entry_1e33bc
// Address: 0x1e33bc - 0x1e33e0

void entry_1e33bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e33bc: 0x8e420380
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 896)));
    // 0x1e33c0: 0x10400015
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3418; return;
    }
    // 0x1e33c8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e33cc: 0x24a58d30
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937904));
    // 0x1e33d0: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e33d4: 0x27a70024
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 36));
    // 0x1e33d8: 0xc05150e
    SET_GPR_U32(ctx, 31, 0x1e33e0);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 40));
    DecomposeCylind(rdram, ctx, runtime); return;
}


// Function: entry_1e33e0
// Address: 0x1e33e0 - 0x1e33f8

void entry_1e33e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e33e0: 0x8e220024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1e33e4: 0x1440000b
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3414; return;
    }
    // 0x1e33ec: 0xc62c0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 52)); ctx->f[12] = *(float*)&val; }
    // 0x1e33f0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e33f8);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e33f8
// Address: 0x1e33f8 - 0x1e3404

void entry_1e33f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e33f8: 0xc64d0390
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 912)); ctx->f[13] = *(float*)&val; }
    // 0x1e33fc: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x1e3404);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e3404
// Address: 0x1e3404 - 0x1e3450

void entry_1e3404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3404) {
        switch (ctx->pc) {
            case 0x1e3414: ctx->pc = 0; goto label_1e3414;
            case 0x1e3418: ctx->pc = 0; goto label_1e3418;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3404: 0xc7a10020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[1] = *(float*)&val; }
    // 0x1e3408: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1e340c: 0xe7a10020
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    // 0x1e3410: 0xc7a00020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[0] = *(float*)&val; }
label_1e3414:
    // 0x1e3414: 0xe6200034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 52), *(uint32_t*)&val); }
label_1e3418:
    // 0x1e3418: 0x27a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e341c: 0x32a20001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 1));
    // 0x1e3420: 0x10400011
    WRITE32(ADD32(GPR_U32(ctx, 29), 272), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e3468(rdram, ctx, runtime); return;
    }
    // 0x1e3428: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1e342c: 0xc64c03a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 928)); ctx->f[12] = *(float*)&val; }
    // 0x1e3430: 0xc64d02f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 752)); ctx->f[13] = *(float*)&val; }
    // 0x1e3434: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e3438: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e343c: 0x26460300
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 768));
    // 0x1e3440: 0x26470330
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 816));
    // 0x1e3444: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e3448: 0xc078afc
    SET_GPR_U32(ctx, 31, 0x1e3450);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1(rdram, ctx, runtime); return;
}


// Function: entry_1e3450
// Address: 0x1e3450 - 0x1e3468

void entry_1e3450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3450: 0x8fa50110
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1e3454: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e3458: 0x27a600e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 224));
    // 0x1e345c: 0x27a700e4
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 228));
    // 0x1e3460: 0xc05150e
    SET_GPR_U32(ctx, 31, 0x1e3468);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 232));
    DecomposeCylind(rdram, ctx, runtime); return;
}


// Function: entry_1e3468
// Address: 0x1e3468 - 0x1e349c

void entry_1e3468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3468: 0x8e420414
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1044)));
    // 0x1e346c: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1e3470: 0x10400010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 80));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e34b4(rdram, ctx, runtime); return;
    }
    // 0x1e3478: 0xc64c03a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 928)); ctx->f[12] = *(float*)&val; }
    // 0x1e347c: 0xc64d02f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 752)); ctx->f[13] = *(float*)&val; }
    // 0x1e3480: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e3484: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e3488: 0x26460300
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 768));
    // 0x1e348c: 0x26470330
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 816));
    // 0x1e3490: 0x24080002
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e3494: 0xc078afc
    SET_GPR_U32(ctx, 31, 0x1e349c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1(rdram, ctx, runtime); return;
}


// Function: entry_1e349c
// Address: 0x1e349c - 0x1e34b4

void entry_1e349c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e349c: 0x8fa50110
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1e34a0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e34a4: 0x27a600ec
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 236));
    // 0x1e34a8: 0x27a700f0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 240));
    // 0x1e34ac: 0xc05150e
    SET_GPR_U32(ctx, 31, 0x1e34b4);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 244));
    DecomposeCylind(rdram, ctx, runtime); return;
}


// Function: entry_1e34b4
// Address: 0x1e34b4 - 0x1e3534

void entry_1e34b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e34b4) {
        switch (ctx->pc) {
            case 0x1e34c4: ctx->pc = 0; goto label_1e34c4;
            case 0x1e34f0: ctx->pc = 0; goto label_1e34f0;
            case 0x1e3510: ctx->pc = 0; goto label_1e3510;
            case 0x1e3520: ctx->pc = 0; goto label_1e3520;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e34b4: 0x8e220024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1e34b8: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e34c4;
    }
    // 0x1e34c0: 0xae220020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
label_1e34c4:
    // 0x1e34c4: 0x8fa30104
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x1e34c8: 0x8c620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    // 0x1e34cc: 0x50400030
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
        ctx->pc = 0x1E3590; return;
    }
    // 0x1e34d4: 0x8c620228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 552)));
    // 0x1e34d8: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e34f0;
    }
    // 0x1e34e0: 0xae220020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    // 0x1e34e4: 0xc460022c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 556)); ctx->f[0] = *(float*)&val; }
    // 0x1e34e8: 0x1000001f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 12), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3568; return;
    }
label_1e34f0:
    // 0x1e34f0: 0x32a20003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 3));
    // 0x1e34f4: 0x14400006
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e3510;
    }
    // 0x1e34fc: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e3500: 0xae220020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    // 0x1e3504: 0xc6600030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 48)); ctx->f[0] = *(float*)&val; }
    // 0x1e3508: 0x10000017
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 12), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3568; return;
    }
label_1e3510:
    // 0x1e3510: 0x14400003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e3520;
    }
    // 0x1e3518: 0x10000012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3564; return;
    }
label_1e3520:
    // 0x1e3520: 0x1040000f
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3560; return;
    }
    // 0x1e3528: 0xc66c0030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 48)); ctx->f[12] = *(float*)&val; }
    // 0x1e352c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3534);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3534
// Address: 0x1e3534 - 0x1e3548

void entry_1e3534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3534: 0xc7a100ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[1] = *(float*)&val; }
    // 0x1e3538: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1e353c: 0xc66c0030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 48)); ctx->f[12] = *(float*)&val; }
    // 0x1e3540: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3548);
    ctx->f[12] = FPU_SUB_S(ctx->f[1], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3548
// Address: 0x1e3548 - 0x1e36d8

void entry_1e3548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3548) {
        switch (ctx->pc) {
            case 0x1e3560: ctx->pc = 0; goto label_1e3560;
            case 0x1e3564: ctx->pc = 0; goto label_1e3564;
            case 0x1e3568: ctx->pc = 0; goto label_1e3568;
            case 0x1e3590: ctx->pc = 0; goto label_1e3590;
            case 0x1e35b0: ctx->pc = 0; goto label_1e35b0;
            case 0x1e3630: ctx->pc = 0; goto label_1e3630;
            case 0x1e3640: ctx->pc = 0; goto label_1e3640;
            case 0x1e3684: ctx->pc = 0; goto label_1e3684;
            case 0x1e3694: ctx->pc = 0; goto label_1e3694;
            case 0x1e36b0: ctx->pc = 0; goto label_1e36b0;
            case 0x1e36b4: ctx->pc = 0; goto label_1e36b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3548: 0x4600a505
    ctx->f[20] = FPU_ABS_S(ctx->f[20]);
    // 0x1e354c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1e3550: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3554: 0x0
    // NOP
    // 0x1e3558: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1e3564;
    }
label_1e3560:
    // 0x1e3560: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_1e3564:
    // 0x1e3564: 0xae220020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
label_1e3568:
    // 0x1e3568: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1e356c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1e3570: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e3574: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1e3578: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1e357c: 0xe6210040
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
    // 0x1e3580: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1e3584: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e3588: 0xe6200030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 48), *(uint32_t*)&val); }
    // 0x1e358c: 0x8e230020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
label_1e3590:
    // 0x1e3590: 0x751024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 21)));
    // 0x1e3594: 0x14400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e35b0;
    }
    // 0x1e359c: 0x18600004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_1e35b0;
    }
    // 0x1e35a4: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e35b0;
    }
    // 0x1e35ac: 0xae220020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
label_1e35b0:
    // 0x1e35b0: 0x5240003f
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 32)));
        goto label_1e36b0;
    }
    // 0x1e35b8: 0x8e420444
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1092)));
    // 0x1e35bc: 0x5040003c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 32)));
        goto label_1e36b0;
    }
    // 0x1e35c4: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1e35c8: 0xda620010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1e35cc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e35d0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e35d4: 0x24438d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1e35d8: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e35dc: 0xafa00078
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 0));
    // 0x1e35e0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1e35e4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1e35e8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e35ec: 0x7ba20070
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e35f0: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1e35f4: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e35f8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1e35fc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3600: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e3604: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3608: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e360c: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e3610: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e3614: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1e3618: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e361c: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e3630;
    }
    // 0x1e3624: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e3628: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e3640;
    }
label_1e3630:
    // 0x1e3630: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1e3634: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e3638: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1e363c: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
label_1e3640:
    // 0x1e3640: 0x26420450
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 1104));
    // 0x1e3644: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e3648: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1e364c: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x1e3650: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1e3654: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1e3658: 0xc6430450
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1104)); ctx->f[3] = *(float*)&val; }
    // 0x1e365c: 0xc6440460
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1120)); ctx->f[4] = *(float*)&val; }
    // 0x1e3660: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1e3664: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1e3668: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1e366c: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3670: 0x0
    // NOP
    // 0x1e3674: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1124)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e3684;
    }
    // 0x1e367c: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e3694;
    }
label_1e3684:
    // 0x1e3684: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3688: 0x0
    // NOP
    // 0x1e368c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_1e3694;
    }
label_1e3694:
    // 0x1e3694: 0x44021800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[3]);
    // 0x1e3698: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1e369c: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e36a0: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e36a4: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e36a8: 0x10000002
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e36b4;
    }
label_1e36b0:
    // 0x1e36b0: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
label_1e36b4:
    // 0x1e36b4: 0x96e200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 23), 170)));
    // 0x1e36b8: 0x30420400
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1024));
    // 0x1e36bc: 0x10400021
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[24] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3744; return;
    }
    // 0x1e36c4: 0x32a20004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 4));
    // 0x1e36c8: 0x1040007d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E38C0; return;
    }
    // 0x1e36d0: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1e36d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1024));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1e36d8
// Address: 0x1e36d8 - 0x1e371c

void entry_1e36d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e36d8: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e36dc: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1e36e0: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1e36e4: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1e36e8: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1e36ec: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e36f0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e36f4: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1e36f8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e36fc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e3700: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e3704: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1e3708: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e370c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1e3710: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e3714: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1e371c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1e371c
// Address: 0x1e371c - 0x1e3728

void entry_1e371c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e371c: 0xae300018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 16));
    // 0x1e3720: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3728);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 48)); ctx->f[12] = *(float*)&val; }
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3728
// Address: 0x1e3728 - 0x1e37d0

void entry_1e3728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3728) {
        switch (ctx->pc) {
            case 0x1e3744: ctx->pc = 0; goto label_1e3744;
            case 0x1e3788: ctx->pc = 0; goto label_1e3788;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3728: 0xe620001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 28), *(uint32_t*)&val); }
    // 0x1e372c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1e3730: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1e3734: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1e3738: 0xae300028
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 16));
    // 0x1e373c: 0x10000261
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 48), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E40C4; return;
    }
label_1e3744:
    // 0x1e3744: 0x32a20004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 4));
    // 0x1e3748: 0x5040005e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
        ctx->pc = 0x1E38C4; return;
    }
    // 0x1e3750: 0xc6e0007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 124)); ctx->f[0] = *(float*)&val; }
    // 0x1e3754: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1e3758: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e375c: 0x0
    // NOP
    // 0x1e3760: 0x45030009
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
        goto label_1e3788;
    }
    // 0x1e3768: 0xc620002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 44)); ctx->f[0] = *(float*)&val; }
    // 0x1e376c: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3770: 0x0
    // NOP
    // 0x1e3774: 0x45000004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e3788;
    }
    // 0x1e377c: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1e3780: 0x10400050
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E38C4; return;
    }
label_1e3788:
    // 0x1e3788: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e378c: 0x10620010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        entry_1e37d0(rdram, ctx, runtime); return;
    }
    // 0x1e3794: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1e3798: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1e379c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1e37a0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e37a4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e37a8: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1e37ac: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e37b0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e37b4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e37b8: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1e37bc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e37c0: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1e37c4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e37c8: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1e37d0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1e37d0
// Address: 0x1e37d0 - 0x1e3810

void entry_1e37d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e37d0) {
        switch (ctx->pc) {
            case 0x1e37e8: ctx->pc = 0; goto label_1e37e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e37d0: 0xc6e1007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 124)); ctx->f[1] = *(float*)&val; }
    // 0x1e37d4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1e37d8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e37dc: 0x0
    // NOP
    // 0x1e37e0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 0));
        goto label_1e37e8;
    }
label_1e37e8:
    // 0x1e37e8: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1e37ec: 0x10400010
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3830; return;
    }
    // 0x1e37f4: 0xc62c000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[12] = *(float*)&val; }
    // 0x1e37f8: 0xc62d002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 44)); ctx->f[13] = *(float*)&val; }
    // 0x1e37fc: 0x4600abc6
    ctx->f[15] = FPU_MOV_S(ctx->f[21]);
    // 0x1e3800: 0xc62e001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 28)); ctx->f[14] = *(float*)&val; }
    // 0x1e3804: 0x24845a90
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23184));
    // 0x1e3808: 0xc07a9e6
    SET_GPR_U32(ctx, 31, 0x1e3810);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 44));
    RadSmoothA__FffffP4SMPAPf(rdram, ctx, runtime); return;
}


// Function: entry_1e3810
// Address: 0x1e3810 - 0x1e3898

void entry_1e3810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3810) {
        switch (ctx->pc) {
            case 0x1e3830: ctx->pc = 0; goto label_1e3830;
            case 0x1e3884: ctx->pc = 0; goto label_1e3884;
            case 0x1e3888: ctx->pc = 0; goto label_1e3888;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3810: 0xc621001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 28)); ctx->f[1] = *(float*)&val; }
    // 0x1e3814: 0x46000606
    ctx->f[24] = FPU_MOV_S(ctx->f[0]);
    // 0x1e3818: 0x4601c032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[24], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e381c: 0x0
    // NOP
    // 0x1e3820: 0x4503001e
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 0));
        ctx->pc = 0x1E389C; return;
    }
    // 0x1e3828: 0x1000001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E38A0; return;
    }
label_1e3830:
    // 0x1e3830: 0xc6e20074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 116)); ctx->f[2] = *(float*)&val; }
    // 0x1e3834: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e3838: 0xc4405a30
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23088)); ctx->f[0] = *(float*)&val; }
    // 0x1e383c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e3840: 0x460010c5
    ctx->f[3] = FPU_ABS_S(ctx->f[2]);
    // 0x1e3844: 0xc621002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 44)); ctx->f[1] = *(float*)&val; }
    // 0x1e3848: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1e384c: 0xc4645a2c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 23084)); ctx->f[4] = *(float*)&val; }
    // 0x1e3850: 0x46031082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x1e3854: 0x460008c0
    ctx->f[3] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1e3858: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1e385c: 0x46041002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x1e3860: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3864: 0x0
    // NOP
    // 0x1e3868: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
        goto label_1e3888;
    }
    // 0x1e3870: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3874: 0x0
    // NOP
    // 0x1e3878: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e3884;
    }
    // 0x1e3880: 0x46001846
    ctx->f[1] = FPU_MOV_S(ctx->f[3]);
label_1e3884:
    // 0x1e3884: 0x46150802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
label_1e3888:
    // 0x1e3888: 0xc62c000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[12] = *(float*)&val; }
    // 0x1e388c: 0xe621002c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 44), *(uint32_t*)&val); }
    // 0x1e3890: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3898);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3898
// Address: 0x1e3898 - 0x1e3a70

void entry_1e3898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3898) {
        switch (ctx->pc) {
            case 0x1e389c: ctx->pc = 0; goto label_1e389c;
            case 0x1e38a0: ctx->pc = 0; goto label_1e38a0;
            case 0x1e38c0: ctx->pc = 0; goto label_1e38c0;
            case 0x1e38c4: ctx->pc = 0; goto label_1e38c4;
            case 0x1e395c: ctx->pc = 0; goto label_1e395c;
            case 0x1e39cc: ctx->pc = 0; goto label_1e39cc;
            case 0x1e39dc: ctx->pc = 0; goto label_1e39dc;
            case 0x1e39f8: ctx->pc = 0; goto label_1e39f8;
            case 0x1e39fc: ctx->pc = 0; goto label_1e39fc;
            case 0x1e3a14: ctx->pc = 0; goto label_1e3a14;
            case 0x1e3a38: ctx->pc = 0; goto label_1e3a38;
            case 0x1e3a40: ctx->pc = 0; goto label_1e3a40;
            case 0x1e3a48: ctx->pc = 0; goto label_1e3a48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3898: 0x46000606
    ctx->f[24] = FPU_MOV_S(ctx->f[0]);
label_1e389c:
    // 0x1e389c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
label_1e38a0:
    // 0x1e38a0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1e38a4: 0xae220020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    // 0x1e38a8: 0x24641858
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1e38ac: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e38b0: 0xc4800004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1e38b4: 0xae230028
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 3));
    // 0x1e38b8: 0x10000202
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 48), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E40C4; return;
    }
label_1e38c0:
    // 0x1e38c0: 0x8e230020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
label_1e38c4:
    // 0x1e38c4: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e38c8: 0x546201ff
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
        ctx->pc = 0x1E40C8; return;
    }
    // 0x1e38d0: 0xc6e20044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 68)); ctx->f[2] = *(float*)&val; }
    // 0x1e38d4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e38d8: 0xc6e10040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 64)); ctx->f[1] = *(float*)&val; }
    // 0x1e38dc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e38e0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1e38e4: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1e38e8: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x1e38ec: 0x44031000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[2]);
    // 0x1e38f0: 0x70642488
    SET_GPR_VEC(ctx, 4, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 4)));
    // 0x1e38f4: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1e38f8: 0x70642389
    SET_GPR_VEC(ctx, 4, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 4)));
    // 0x1e38fc: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1e3900: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1e3904: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1e3908: 0x48a40800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1e390c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e3910: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3914: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1e3918: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e391c: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e3920: 0x7fa40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 4));
    // 0x1e3924: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e3928: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e392c: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e3930: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e3934: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e3938: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e393c: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3940: 0x0
    // NOP
    // 0x1e3944: 0x45010005
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1e395c;
    }
    // 0x1e394c: 0x48a41800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x1e3950: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1e3954: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e3958: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1e395c:
    // 0x1e395c: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e3960: 0x26038d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4294937856));
    // 0x1e3964: 0x8fa20104
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x1e3968: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e396c: 0xd8420040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1e3970: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3974: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1e3978: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1e397c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e3980: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e3984: 0xafa00088
    WRITE32(ADD32(GPR_U32(ctx, 29), 136), GPR_U32(ctx, 0));
    // 0x1e3988: 0x7ba20080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e398c: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1e3990: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e3994: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1e3998: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e399c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e39a0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e39a4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e39a8: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e39ac: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e39b0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1e39b4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e39b8: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e39cc;
    }
    // 0x1e39c0: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e39c4: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e39dc;
    }
label_1e39cc:
    // 0x1e39cc: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1e39d0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e39d4: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1e39d8: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
label_1e39dc:
    // 0x1e39dc: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e39e0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e39e4: 0x12400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1e39f8;
    }
    // 0x1e39ec: 0x8e430430
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1072)));
    // 0x1e39f0: 0x14620002
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e39fc;
    }
label_1e39f8:
    // 0x1e39f8: 0x8e63003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 60)));
label_1e39fc:
    // 0x1e39fc: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1e3a14;
    }
    // 0x1e3a04: 0x1062000c
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e3a38;
    }
    // 0x1e3a0c: 0x1000000e
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e3a48;
    }
label_1e3a14:
    // 0x1e3a14: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e3a18: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e3a1c: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1e3a20: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e3a24: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1e3a28: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e3a2c: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3a30: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e3a40;
    }
label_1e3a38:
    // 0x1e3a38: 0x7ba20080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e3a3c: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
label_1e3a40:
    // 0x1e3a40: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e3a44: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1e3a48:
    // 0x1e3a48: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1e3a4c: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e3a50: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1e3a54: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e3a58: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e3a5c: 0xc44d5a28
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23080)); ctx->f[13] = *(float*)&val; }
    // 0x1e3a60: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e3a64: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1e3a68: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x1e3a70);
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[0];
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e3a70
// Address: 0x1e3a70 - 0x1e3b58

void entry_1e3a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3a70) {
        switch (ctx->pc) {
            case 0x1e3ac4: ctx->pc = 0; goto label_1e3ac4;
            case 0x1e3ad4: ctx->pc = 0; goto label_1e3ad4;
            case 0x1e3b38: ctx->pc = 0; goto label_1e3b38;
            case 0x1e3b48: ctx->pc = 0; goto label_1e3b48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3a70: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e3a74: 0xc7a30074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 116)); ctx->f[3] = *(float*)&val; }
    // 0x1e3a78: 0x24435a40
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 23104));
    // 0x1e3a7c: 0xc4455a40
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23104)); ctx->f[5] = *(float*)&val; }
    // 0x1e3a80: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1e3a84: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e3a88: 0xc4620004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1e3a8c: 0x24445a50
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 23120));
    // 0x1e3a90: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1e3a94: 0xc4465a50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23120)); ctx->f[6] = *(float*)&val; }
    // 0x1e3a98: 0xc6240044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 68)); ctx->f[4] = *(float*)&val; }
    // 0x1e3a9c: 0xc4870004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[7] = *(float*)&val; }
    // 0x1e3aa0: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1e3aa4: 0x460218c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[2]);
    // 0x1e3aa8: 0x46032940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[3]);
    // 0x1e3aac: 0x46062834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[6])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3ab0: 0x0
    // NOP
    // 0x1e3ab4: 0x45000003
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e3ac4;
    }
    // 0x1e3abc: 0x10000005
    ctx->f[5] = FPU_MOV_S(ctx->f[6]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e3ad4;
    }
label_1e3ac4:
    // 0x1e3ac4: 0x46053834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[7], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3ac8: 0x0
    // NOP
    // 0x1e3acc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[5] = FPU_MOV_S(ctx->f[7]);
        goto label_1e3ad4;
    }
label_1e3ad4:
    // 0x1e3ad4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e3ad8: 0xc6210030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 48)); ctx->f[1] = *(float*)&val; }
    // 0x1e3adc: 0x24431858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1e3ae0: 0x46056302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[5]);
    // 0x1e3ae4: 0xc4620004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1e3ae8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e3aec: 0x24435a70
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 23152));
    // 0x1e3af0: 0xc4435a70
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23152)); ctx->f[3] = *(float*)&val; }
    // 0x1e3af4: 0x46011081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    // 0x1e3af8: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1e3afc: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1e3b00: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e3b04: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1e3b08: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e3b0c: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1e3b10: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1e3b14: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1e3b18: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1e3b1c: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1e3b20: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3b24: 0x0
    // NOP
    // 0x1e3b28: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[6] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e3b38;
    }
    // 0x1e3b30: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e3b48;
    }
label_1e3b38:
    // 0x1e3b38: 0x46033034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3b3c: 0x0
    // NOP
    // 0x1e3b40: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[6]);
        goto label_1e3b48;
    }
label_1e3b48:
    // 0x1e3b48: 0x46036302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[3]);
    // 0x1e3b4c: 0x461b6302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[27]);
    // 0x1e3b50: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3b58);
    ctx->f[12] = FPU_ADD_S(ctx->f[24], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3b58
// Address: 0x1e3b58 - 0x1e3c7c

void entry_1e3b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3b58) {
        switch (ctx->pc) {
            case 0x1e3b6c: ctx->pc = 0; goto label_1e3b6c;
            case 0x1e3b84: ctx->pc = 0; goto label_1e3b84;
            case 0x1e3ba4: ctx->pc = 0; goto label_1e3ba4;
            case 0x1e3bac: ctx->pc = 0; goto label_1e3bac;
            case 0x1e3bb8: ctx->pc = 0; goto label_1e3bb8;
            case 0x1e3bc8: ctx->pc = 0; goto label_1e3bc8;
            case 0x1e3be0: ctx->pc = 0; goto label_1e3be0;
            case 0x1e3c00: ctx->pc = 0; goto label_1e3c00;
            case 0x1e3c58: ctx->pc = 0; goto label_1e3c58;
            case 0x1e3c64: ctx->pc = 0; goto label_1e3c64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3b58: 0x32a20003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 3));
    // 0x1e3b5c: 0x14400003
    ctx->f[26] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e3b6c;
    }
    // 0x1e3b64: 0x10000157
    ctx->f[24] = FPU_MOV_S(ctx->f[26]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E40C4; return;
    }
label_1e3b6c:
    // 0x1e3b6c: 0x8e4202e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 740)));
    // 0x1e3b70: 0x14400004
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e3b84;
    }
    // 0x1e3b78: 0x8e42038c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 908)));
    // 0x1e3b7c: 0x1040000e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e3bb8;
    }
label_1e3b84:
    // 0x1e3b84: 0x8c622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x1e3b88: 0x57c20008
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
        goto label_1e3bac;
    }
    // 0x1e3b90: 0x8fc22678
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 9848)));
    // 0x1e3b94: 0x56420005
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
        goto label_1e3bac;
    }
    // 0x1e3b9c: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1e3ba0: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
label_1e3ba4:
    // 0x1e3ba4: 0x1000004b
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[22] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3CD4; return;
    }
label_1e3bac:
    // 0x1e3bac: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e3bb0: 0x14620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e3bc8;
    }
label_1e3bb8:
    // 0x1e3bb8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e3bbc: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1e3bc0: 0x10000044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[22] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3CD4; return;
    }
label_1e3bc8:
    // 0x1e3bc8: 0x14620005
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e3be0;
    }
    // 0x1e3bd0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e3bd4: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1e3bd8: 0x1000003e
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[22] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3CD4; return;
    }
label_1e3be0:
    // 0x1e3be0: 0x8c622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x1e3be4: 0x57c20006
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 30), 272)));
        goto label_1e3c00;
    }
    // 0x1e3bec: 0x8fc32220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 8736)));
    // 0x1e3bf0: 0x2402000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    // 0x1e3bf4: 0x54620002
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 30), 272)));
        goto label_1e3c00;
    }
    // 0x1e3bfc: 0x7bc20150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 30), 336)));
label_1e3c00:
    // 0x1e3c00: 0x7fa200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 2));
    // 0x1e3c04: 0xafa000a8
    WRITE32(ADD32(GPR_U32(ctx, 29), 168), GPR_U32(ctx, 0));
    // 0x1e3c08: 0x26028d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 4294937856));
    // 0x1e3c0c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1e3c10: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1e3c14: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e3c18: 0xdba300a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e3c1c: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e3c20: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1e3c24: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3c28: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e3c2c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e3c30: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3c34: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e3c38: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e3c3c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e3c40: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e3c44: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3c48: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e3c58;
    }
    // 0x1e3c50: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e3c64;
    }
label_1e3c58:
    // 0x1e3c58: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1e3c5c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e3c60: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1e3c64:
    // 0x1e3c64: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1e3c68: 0xfba100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e3c6c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e3c70: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e3c74: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1e3c7c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1e3c7c
// Address: 0x1e3c7c - 0x1e3dd8

void entry_1e3c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3c7c) {
        switch (ctx->pc) {
            case 0x1e3cd4: ctx->pc = 0; goto label_1e3cd4;
            case 0x1e3d34: ctx->pc = 0; goto label_1e3d34;
            case 0x1e3d68: ctx->pc = 0; goto label_1e3d68;
            case 0x1e3d70: ctx->pc = 0; goto label_1e3d70;
            case 0x1e3d74: ctx->pc = 0; goto label_1e3d74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3c7c: 0xdba200a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e3c80: 0x32a20002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 2));
    // 0x1e3c84: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e3c88: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e3c8c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1e3c90: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e3c94: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e3c98: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1e3c9c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e3ca0: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e3ca4: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1e3ca8: 0x46001845
    ctx->f[1] = FPU_ABS_S(ctx->f[3]);
    // 0x1e3cac: 0x46031882
    ctx->f[2] = FPU_MUL_S(ctx->f[3], ctx->f[3]);
    // 0x1e3cb0: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1e3cb4: 0x1040ffbb
    ctx->f[25] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3BA4; return;
    }
    // 0x1e3cbc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1e3cc0: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3cc4: 0x0
    // NOP
    // 0x1e3cc8: 0x45010002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[22] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1e3cd4;
    }
    // 0x1e3cd0: 0xc7b600ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[22] = *(float*)&val; }
label_1e3cd4:
    // 0x1e3cd4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e3cd8: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1e3cdc: 0x10800024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1e3d70;
    }
    // 0x1e3ce4: 0x8c832220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x1e3ce8: 0x14620012
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e3d34;
    }
    // 0x1e3cf0: 0x8c82239c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 9116)));
    // 0x1e3cf4: 0x1440000f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e3d34;
    }
    // 0x1e3cfc: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3d00: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3d04: 0x3c013ba3
    SET_GPR_U32(ctx, 1, ((uint32_t)15267 << 16));
    // 0x1e3d08: 0x3421d70a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55050));
    // 0x1e3d0c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e3d10: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3d14: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e3d18: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e3d1c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e3d20: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e3d24: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e3d28: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e3d2c: 0x1000000e
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e3d68;
    }
label_1e3d34:
    // 0x1e3d34: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3d38: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3d3c: 0x3c013ada
    SET_GPR_U32(ctx, 1, ((uint32_t)15066 << 16));
    // 0x1e3d40: 0x3421740e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 29710));
    // 0x1e3d44: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e3d48: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e3d4c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e3d50: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e3d54: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e3d58: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e3d5c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e3d60: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1e3d64: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
label_1e3d68:
    // 0x1e3d68: 0x10000002
    ctx->f[21] = std::min(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e3d74;
    }
label_1e3d70:
    // 0x1e3d70: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
label_1e3d74:
    // 0x1e3d74: 0xc6c00068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 104)); ctx->f[0] = *(float*)&val; }
    // 0x1e3d78: 0x8fa3010c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 268)));
    // 0x1e3d7c: 0x10600031
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3E44; return;
    }
    // 0x1e3d84: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x1e3d88: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e3d8c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1e3d90: 0xc6220040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 64)); ctx->f[2] = *(float*)&val; }
    // 0x1e3d94: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1e3d98: 0xc6210030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 48)); ctx->f[1] = *(float*)&val; }
    // 0x1e3d9c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1e3da0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1e3da4: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1e3da8: 0xc6440428
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1064)); ctx->f[4] = *(float*)&val; }
    // 0x1e3dac: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1e3db0: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x1e3db4: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1e3db8: 0x4604a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3dbc: 0x46020301
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e3dc0: 0x4500000c
    ctx->f[23] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E3DF4; return;
    }
    // 0x1e3dc8: 0x46046303
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[4];
    // 0x1e3dcc: 0x26705c60
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 23648));
    // 0x1e3dd0: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x1e3dd8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_1e3dd8
// Address: 0x1e3dd8 - 0x1e3dec

void entry_1e3dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3dd8: 0xc64c0428
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1064)); ctx->f[12] = *(float*)&val; }
    // 0x1e3ddc: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1e3de0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e3de4: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x1e3dec);
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[23] * 0.0f); } else ctx->f[12] = ctx->f[23] / ctx->f[12];
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_1e3dec
// Address: 0x1e3dec - 0x1e3e90

void entry_1e3dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3dec) {
        switch (ctx->pc) {
            case 0x1e3df4: ctx->pc = 0; goto label_1e3df4;
            case 0x1e3e1c: ctx->pc = 0; goto label_1e3e1c;
            case 0x1e3e20: ctx->pc = 0; goto label_1e3e20;
            case 0x1e3e44: ctx->pc = 0; goto label_1e3e44;
            case 0x1e3e48: ctx->pc = 0; goto label_1e3e48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3dec: 0x1000000b
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e3e1c;
    }
label_1e3df4:
    // 0x1e3df4: 0x460ca034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3df8: 0x0
    // NOP
    // 0x1e3dfc: 0x45020008
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1068)); ctx->f[0] = *(float*)&val; }
        goto label_1e3e20;
    }
    // 0x1e3e04: 0x4617a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3e08: 0x0
    // NOP
    // 0x1e3e0c: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1068)); ctx->f[0] = *(float*)&val; }
        goto label_1e3e20;
    }
    // 0x1e3e14: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e3e18: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
label_1e3e1c:
    // 0x1e3e1c: 0xc640042c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1068)); ctx->f[0] = *(float*)&val; }
label_1e3e20:
    // 0x1e3e20: 0x4619a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[25]);
    // 0x1e3e24: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1e3e28: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3e2c: 0x0
    // NOP
    // 0x1e3e30: 0x45000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 264)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e3e48;
    }
    // 0x1e3e38: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e3e3c: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1e3e40: 0x4600a546
    ctx->f[21] = FPU_MOV_S(ctx->f[20]);
label_1e3e44:
    // 0x1e3e44: 0x8fa20108
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 264)));
label_1e3e48:
    // 0x1e3e48: 0x1040001f
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3EC8; return;
    }
    // 0x1e3e50: 0x8e220028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 40)));
    // 0x1e3e54: 0x1440001c
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E3EC8; return;
    }
    // 0x1e3e5c: 0xc6410420
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1056)); ctx->f[1] = *(float*)&val; }
    // 0x1e3e60: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1e3e64: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3e68: 0x0
    // NOP
    // 0x1e3e6c: 0x4500000a
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E3E98; return;
    }
    // 0x1e3e74: 0xc640039c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 924)); ctx->f[0] = *(float*)&val; }
    // 0x1e3e78: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1e3e7c: 0x26645c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 23648));
    // 0x1e3e80: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1e3e84: 0x46006301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x1e3e88: 0xc07ac3e
    SET_GPR_U32(ctx, 31, 0x1e3e90);
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[1];
    GLimitLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_1e3e90
// Address: 0x1e3e90 - 0x1e3ef4

void entry_1e3e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3e90) {
        switch (ctx->pc) {
            case 0x1e3e98: ctx->pc = 0; goto label_1e3e98;
            case 0x1e3ea0: ctx->pc = 0; goto label_1e3ea0;
            case 0x1e3ec8: ctx->pc = 0; goto label_1e3ec8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3e90: 0x10000003
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e3ea0;
    }
label_1e3e98:
    // 0x1e3e98: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e3e9c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
label_1e3ea0:
    // 0x1e3ea0: 0xc6400424
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1060)); ctx->f[0] = *(float*)&val; }
    // 0x1e3ea4: 0x4619a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[25]);
    // 0x1e3ea8: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x1e3eac: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3eb0: 0x0
    // NOP
    // 0x1e3eb4: 0x45000004
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e3ec8;
    }
    // 0x1e3ebc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e3ec0: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1e3ec4: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
label_1e3ec8:
    // 0x1e3ec8: 0x4618b301
    ctx->f[12] = FPU_SUB_S(ctx->f[22], ctx->f[24]);
    // 0x1e3ecc: 0x24435a58
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 23128));
    // 0x1e3ed0: 0xc4405a58
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23128)); ctx->f[0] = *(float*)&val; }
    // 0x1e3ed4: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1e3ed8: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1e3edc: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1e3ee0: 0x46150842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
    // 0x1e3ee4: 0xe7a200a8
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 168), *(uint32_t*)&val); }
    // 0x1e3ee8: 0xe7a000a0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 160), *(uint32_t*)&val); }
    // 0x1e3eec: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3ef4);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 164), *(uint32_t*)&val); }
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3ef4
// Address: 0x1e3ef4 - 0x1e3efc

void entry_1e3ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3ef4: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3efc);
    ctx->f[12] = FPU_ADD_S(ctx->f[24], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3efc
// Address: 0x1e3efc - 0x1e3f14

void entry_1e3efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3efc: 0x46000346
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    // 0x1e3f00: 0x4600db86
    ctx->f[14] = FPU_MOV_S(ctx->f[27]);
    // 0x1e3f04: 0x27a400a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1e3f08: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e3f0c: 0xc07a9ca
    SET_GPR_U32(ctx, 31, 0x1e3f14);
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    RadSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1e3f14
// Address: 0x1e3f14 - 0x1e3f20

void entry_1e3f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3f14: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1e3f18: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3f20);
    ctx->f[12] = FPU_SUB_S(ctx->f[22], ctx->f[21]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3f20
// Address: 0x1e3f20 - 0x1e3f2c

void entry_1e3f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3f20: 0x461ab301
    ctx->f[12] = FPU_SUB_S(ctx->f[22], ctx->f[26]);
    // 0x1e3f24: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3f2c);
    ctx->f[20] = FPU_ABS_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3f2c
// Address: 0x1e3f2c - 0x1e3f48

void entry_1e3f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3f2c) {
        switch (ctx->pc) {
            case 0x1e3f40: ctx->pc = 0; goto label_1e3f40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3f2c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1e3f30: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3f34: 0x0
    // NOP
    // 0x1e3f38: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[21] = FPU_MOV_S(ctx->f[26]);
        goto label_1e3f40;
    }
label_1e3f40:
    // 0x1e3f40: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3f48);
    ctx->f[12] = FPU_SUB_S(ctx->f[26], ctx->f[24]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3f48
// Address: 0x1e3f48 - 0x1e3f54

void entry_1e3f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3f48: 0x4618ab01
    ctx->f[12] = FPU_SUB_S(ctx->f[21], ctx->f[24]);
    // 0x1e3f4c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3f54);
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3f54
// Address: 0x1e3f54 - 0x1e3f74

void entry_1e3f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3f54: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e3f58: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e3f5c: 0x4600c802
    ctx->f[0] = FPU_MUL_S(ctx->f[25], ctx->f[0]);
    // 0x1e3f60: 0x46196301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[25]);
    // 0x1e3f64: 0x46146302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    // 0x1e3f68: 0x460cc300
    ctx->f[12] = FPU_ADD_S(ctx->f[24], ctx->f[12]);
    // 0x1e3f6c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3f74);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3f74
// Address: 0x1e3f74 - 0x1e3f9c

void entry_1e3f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3f74: 0x8e220024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x1e3f78: 0x14400052
    ctx->f[24] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E40C4; return;
    }
    // 0x1e3f80: 0x32a20001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 1));
    // 0x1e3f84: 0x10400027
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E4024; return;
    }
    // 0x1e3f8c: 0xc620000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1e3f90: 0xc62c0038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 56)); ctx->f[12] = *(float*)&val; }
    // 0x1e3f94: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3f9c);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3f9c
// Address: 0x1e3f9c - 0x1e3fac

void entry_1e3f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3f9c: 0xc7ac00e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[12] = *(float*)&val; }
    // 0x1e3fa0: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1e3fa4: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3fac);
    ctx->f[12] = FPU_SUB_S(ctx->f[24], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3fac
// Address: 0x1e3fac - 0x1e3fcc

void entry_1e3fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e3fac: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1e3fb0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1e3fb4: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3fb8: 0x0
    // NOP
    // 0x1e3fbc: 0x4501000b
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[12] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E3FEC; return;
    }
    // 0x1e3fc4: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3fcc);
    ctx->f[12] = FPU_SUB_S(ctx->f[24], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3fcc
// Address: 0x1e3fcc - 0x1e3ff4

void entry_1e3fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3fcc) {
        switch (ctx->pc) {
            case 0x1e3fec: ctx->pc = 0; goto label_1e3fec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3fcc: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1e3fd0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1e3fd4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1e3fd8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e3fdc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e3fe0: 0x0
    // NOP
    // 0x1e3fe4: 0x4500000e
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[12] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E4020; return;
    }
label_1e3fec:
    // 0x1e3fec: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e3ff4);
    ctx->f[12] = FPU_SUB_S(ctx->f[24], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e3ff4
// Address: 0x1e3ff4 - 0x1e403c

void entry_1e3ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e3ff4) {
        switch (ctx->pc) {
            case 0x1e4020: ctx->pc = 0; goto label_1e4020;
            case 0x1e4024: ctx->pc = 0; goto label_1e4024;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e3ff4: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1e3ff8: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x1e3ffc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1e4000: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e4004: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4008: 0x0
    // NOP
    // 0x1e400c: 0x45000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e4020;
    }
    // 0x1e4014: 0xae220028
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 2));
    // 0x1e4018: 0x1000002a
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E40C4; return;
    }
label_1e4020:
    // 0x1e4020: 0x32a20002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 2));
label_1e4024:
    // 0x1e4024: 0x50400028
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
        ctx->pc = 0x1E40C8; return;
    }
    // 0x1e402c: 0xc620000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1e4030: 0xc62c003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 60)); ctx->f[12] = *(float*)&val; }
    // 0x1e4034: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e403c);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e403c
// Address: 0x1e403c - 0x1e404c

void entry_1e403c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e403c: 0xc7ac00ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[12] = *(float*)&val; }
    // 0x1e4040: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1e4044: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e404c);
    ctx->f[12] = FPU_SUB_S(ctx->f[24], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e404c
// Address: 0x1e404c - 0x1e406c

void entry_1e404c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e404c: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1e4050: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1e4054: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4058: 0x0
    // NOP
    // 0x1e405c: 0x4501000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[12] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E4090; return;
    }
    // 0x1e4064: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e406c);
    ctx->f[12] = FPU_SUB_S(ctx->f[24], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e406c
// Address: 0x1e406c - 0x1e4098

void entry_1e406c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e406c) {
        switch (ctx->pc) {
            case 0x1e4090: ctx->pc = 0; goto label_1e4090;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e406c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1e4070: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1e4074: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1e4078: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e407c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4080: 0x0
    // NOP
    // 0x1e4084: 0x45020010
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
        ctx->pc = 0x1E40C8; return;
    }
    // 0x1e408c: 0xc7ac00ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[12] = *(float*)&val; }
label_1e4090:
    // 0x1e4090: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1e4098);
    ctx->f[12] = FPU_SUB_S(ctx->f[24], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e4098
// Address: 0x1e4098 - 0x1e43c4

void entry_1e4098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4098) {
        switch (ctx->pc) {
            case 0x1e40c4: ctx->pc = 0; goto label_1e40c4;
            case 0x1e40c8: ctx->pc = 0; goto label_1e40c8;
            case 0x1e40ec: ctx->pc = 0; goto label_1e40ec;
            case 0x1e4100: ctx->pc = 0; goto label_1e4100;
            case 0x1e4124: ctx->pc = 0; goto label_1e4124;
            case 0x1e414c: ctx->pc = 0; goto label_1e414c;
            case 0x1e4178: ctx->pc = 0; goto label_1e4178;
            case 0x1e4194: ctx->pc = 0; goto label_1e4194;
            case 0x1e41a8: ctx->pc = 0; goto label_1e41a8;
            case 0x1e41f0: ctx->pc = 0; goto label_1e41f0;
            case 0x1e4204: ctx->pc = 0; goto label_1e4204;
            case 0x1e420c: ctx->pc = 0; goto label_1e420c;
            case 0x1e4250: ctx->pc = 0; goto label_1e4250;
            case 0x1e4260: ctx->pc = 0; goto label_1e4260;
            case 0x1e4264: ctx->pc = 0; goto label_1e4264;
            case 0x1e4268: ctx->pc = 0; goto label_1e4268;
            case 0x1e4294: ctx->pc = 0; goto label_1e4294;
            case 0x1e42e8: ctx->pc = 0; goto label_1e42e8;
            case 0x1e42f0: ctx->pc = 0; goto label_1e42f0;
            case 0x1e43a0: ctx->pc = 0; goto label_1e43a0;
            case 0x1e43ac: ctx->pc = 0; goto label_1e43ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4098: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1e409c: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x1e40a0: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1e40a4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e40a8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e40ac: 0x0
    // NOP
    // 0x1e40b0: 0x45000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e40c4;
    }
    // 0x1e40b8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e40bc: 0xae220020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    // 0x1e40c0: 0xae230028
    WRITE32(ADD32(GPR_U32(ctx, 17), 40), GPR_U32(ctx, 3));
label_1e40c4:
    // 0x1e40c4: 0x8e230020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 32)));
label_1e40c8:
    // 0x1e40c8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e40cc: 0x10620015
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e4124;
    }
    // 0x1e40d4: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e40ec;
    }
    // 0x1e40dc: 0x10620008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e4100;
    }
    // 0x1e40e4: 0x10000082
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e42f0;
    }
label_1e40ec:
    // 0x1e40ec: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e40f0: 0x10620016
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e414c;
    }
    // 0x1e40f8: 0x1000007d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e42f0;
    }
label_1e4100:
    // 0x1e4100: 0xc7a000e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[0] = *(float*)&val; }
    // 0x1e4104: 0xc7a100e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 228)); ctx->f[1] = *(float*)&val; }
    // 0x1e4108: 0xc7a200e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[2] = *(float*)&val; }
    // 0x1e410c: 0xe7a000f8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 248), *(uint32_t*)&val); }
    // 0x1e4110: 0xe7a100fc
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 252), *(uint32_t*)&val); }
    // 0x1e4114: 0xe7a20100
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 256), *(uint32_t*)&val); }
    // 0x1e4118: 0xc6dc0058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 88)); ctx->f[28] = *(float*)&val; }
    // 0x1e411c: 0x10000072
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 92)); ctx->f[29] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e42e8;
    }
label_1e4124:
    // 0x1e4124: 0xc7a100ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[1] = *(float*)&val; }
    // 0x1e4128: 0xc7a200f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[2] = *(float*)&val; }
    // 0x1e412c: 0xc7a300f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 244)); ctx->f[3] = *(float*)&val; }
    // 0x1e4130: 0xc6c00058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 88)); ctx->f[0] = *(float*)&val; }
    // 0x1e4134: 0xe7a100f8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 248), *(uint32_t*)&val); }
    // 0x1e4138: 0xe7a200fc
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 252), *(uint32_t*)&val); }
    // 0x1e413c: 0x46000707
    ctx->f[28] = FPU_NEG_S(ctx->f[0]);
    // 0x1e4140: 0xe7a30100
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 256), *(uint32_t*)&val); }
    // 0x1e4144: 0x10000068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 92)); ctx->f[29] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e42e8;
    }
label_1e414c:
    // 0x1e414c: 0x32a20003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 3));
    // 0x1e4150: 0x14400009
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 248), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e4178;
    }
    // 0x1e4158: 0xc6c00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1e415c: 0xc6c10030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 48)); ctx->f[1] = *(float*)&val; }
    // 0x1e4160: 0xc6dc0058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 88)); ctx->f[28] = *(float*)&val; }
    // 0x1e4164: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1e4168: 0xe7a10100
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 256), *(uint32_t*)&val); }
    // 0x1e416c: 0xc6dd005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 92)); ctx->f[29] = *(float*)&val; }
    // 0x1e4170: 0x1000005d
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 252), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e42e8;
    }
label_1e4178:
    // 0x1e4178: 0x32a20002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 2));
    // 0x1e417c: 0x14400005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e4194;
    }
    // 0x1e4184: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e4188: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x1e418c: 0x10000041
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e4294;
    }
label_1e4194:
    // 0x1e4194: 0x14400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[2] = *(float*)&val; }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e41a8;
    }
    // 0x1e419c: 0x44803800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 0);
    // 0x1e41a0: 0x1000003c
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e4294;
    }
label_1e41a8:
    // 0x1e41a8: 0xc620000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1e41ac: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e41b0: 0x0
    // NOP
    // 0x1e41b4: 0x45000013
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[1] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e4204;
    }
    // 0x1e41bc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e41c0: 0x0
    // NOP
    // 0x1e41c4: 0x45020011
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[2] = *(float*)&val; }
        goto label_1e420c;
    }
    // 0x1e41cc: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e41d0: 0x45000007
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e41f0;
    }
    // 0x1e41d8: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1e41dc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1e41e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e41e4: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1e41e8: 0x1000001e
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 224), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e4264;
    }
label_1e41f0:
    // 0x1e41f0: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1e41f4: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1e41f8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e41fc: 0x10000018
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e4260;
    }
label_1e4204:
    // 0x1e4204: 0xc7a200e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[2] = *(float*)&val; }
    // 0x1e4208: 0xc620000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[0] = *(float*)&val; }
label_1e420c:
    // 0x1e420c: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4210: 0x0
    // NOP
    // 0x1e4214: 0x45000013
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[1] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e4264;
    }
    // 0x1e421c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4220: 0x0
    // NOP
    // 0x1e4224: 0x45000010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e4268;
    }
    // 0x1e422c: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4230: 0x45000007
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e4250;
    }
    // 0x1e4238: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1e423c: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1e4240: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e4244: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1e4248: 0x10000006
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 224), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e4264;
    }
label_1e4250:
    // 0x1e4250: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1e4254: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1e4258: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e425c: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
label_1e4260:
    // 0x1e4260: 0xe7a000ec
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 236), *(uint32_t*)&val); }
label_1e4264:
    // 0x1e4264: 0xc7a300ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[3] = *(float*)&val; }
label_1e4268:
    // 0x1e4268: 0xc621000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[1] = *(float*)&val; }
    // 0x1e426c: 0xc7a000e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[0] = *(float*)&val; }
    // 0x1e4270: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1e4274: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x1e4278: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e427c: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1e4280: 0x460009c3
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[7] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[7] = ctx->f[1] / ctx->f[0];
    // 0x1e4284: 0x460738c0
    ctx->f[3] = FPU_ADD_S(ctx->f[7], ctx->f[7]);
    // 0x1e4288: 0x46073802
    ctx->f[0] = FPU_MUL_S(ctx->f[7], ctx->f[7]);
    // 0x1e428c: 0x46031081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[3]);
    // 0x1e4290: 0x460201c2
    ctx->f[7] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
label_1e4294:
    // 0x1e4294: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e4298: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e429c: 0xc6c50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 88)); ctx->f[5] = *(float*)&val; }
    // 0x1e42a0: 0x46070001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[7]);
    // 0x1e42a4: 0xc7a300e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 228)); ctx->f[3] = *(float*)&val; }
    // 0x1e42a8: 0xc7a400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[4] = *(float*)&val; }
    // 0x1e42ac: 0x46002987
    ctx->f[6] = FPU_NEG_S(ctx->f[5]);
    // 0x1e42b0: 0xc7a200e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[2] = *(float*)&val; }
    // 0x1e42b4: 0x460338c2
    ctx->f[3] = FPU_MUL_S(ctx->f[7], ctx->f[3]);
    // 0x1e42b8: 0xc7a100f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 244)); ctx->f[1] = *(float*)&val; }
    // 0x1e42bc: 0x46040102
    ctx->f[4] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x1e42c0: 0x46023882
    ctx->f[2] = FPU_MUL_S(ctx->f[7], ctx->f[2]);
    // 0x1e42c4: 0xc6dd005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 92)); ctx->f[29] = *(float*)&val; }
    // 0x1e42c8: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1e42cc: 0x46060002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[6]);
    // 0x1e42d0: 0x46053942
    ctx->f[5] = FPU_MUL_S(ctx->f[7], ctx->f[5]);
    // 0x1e42d4: 0x460418c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[4]);
    // 0x1e42d8: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1e42dc: 0x46002f00
    ctx->f[28] = FPU_ADD_S(ctx->f[5], ctx->f[0]);
    // 0x1e42e0: 0xe7a300fc
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 252), *(uint32_t*)&val); }
    // 0x1e42e4: 0xe7a20100
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 256), *(uint32_t*)&val); }
label_1e42e8:
    // 0x1e42e8: 0x8fa30104
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x1e42ec: 0x8c620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 548)));
label_1e42f0:
    // 0x1e42f0: 0x1440002b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e43a0;
    }
    // 0x1e42f8: 0xc6c10084
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 132)); ctx->f[1] = *(float*)&val; }
    // 0x1e42fc: 0xc4481924
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6436)); ctx->f[8] = *(float*)&val; }
    // 0x1e4300: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1e4304: 0xc6240010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 16)); ctx->f[4] = *(float*)&val; }
    // 0x1e4308: 0xc7a000fc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 252)); ctx->f[0] = *(float*)&val; }
    // 0x1e430c: 0x46080842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[8]);
    // 0x1e4310: 0xc6c20080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 128)); ctx->f[2] = *(float*)&val; }
    // 0x1e4314: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x1e4318: 0xc4671920
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6432)); ctx->f[7] = *(float*)&val; }
    // 0x1e431c: 0x461b0842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[27]);
    // 0x1e4320: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e4324: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x1e4328: 0xc6230048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[3] = *(float*)&val; }
    // 0x1e432c: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1e4330: 0xc6250014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 20)); ctx->f[5] = *(float*)&val; }
    // 0x1e4334: 0x46060840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[6]);
    // 0x1e4338: 0xc7a20100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[2] = *(float*)&val; }
    // 0x1e433c: 0xc629004c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 76)); ctx->f[9] = *(float*)&val; }
    // 0x1e4340: 0x46070002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[7]);
    // 0x1e4344: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1e4348: 0x46051081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[5]);
    // 0x1e434c: 0x461b0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[27]);
    // 0x1e4350: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1e4354: 0xe6210048
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 72), *(uint32_t*)&val); }
    // 0x1e4358: 0x461b0842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[27]);
    // 0x1e435c: 0xc6c00084
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 132)); ctx->f[0] = *(float*)&val; }
    // 0x1e4360: 0xc6c30080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 128)); ctx->f[3] = *(float*)&val; }
    // 0x1e4364: 0x46080002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[8]);
    // 0x1e4368: 0x46031082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x1e436c: 0x46012100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[1]);
    // 0x1e4370: 0x461b0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[27]);
    // 0x1e4374: 0x46071082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[7]);
    // 0x1e4378: 0xe7a400fc
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 29), 252), *(uint32_t*)&val); }
    // 0x1e437c: 0x46060000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[6]);
    // 0x1e4380: 0x461b1082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[27]);
    // 0x1e4384: 0x46090002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[9]);
    // 0x1e4388: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1e438c: 0x461b0042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[27]);
    // 0x1e4390: 0xe620004c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 76), *(uint32_t*)&val); }
    // 0x1e4394: 0x46012940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[1]);
    // 0x1e4398: 0x10000004
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 29), 256), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e43ac;
    }
label_1e43a0:
    // 0x1e43a0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1e43a4: 0xe6200048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 72), *(uint32_t*)&val); }
    // 0x1e43a8: 0xe620004c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 76), *(uint32_t*)&val); }
label_1e43ac:
    // 0x1e43ac: 0x27a40070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1e43b0: 0xc7ac00f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[12] = *(float*)&val; }
    // 0x1e43b4: 0xc7ad00fc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 252)); ctx->f[13] = *(float*)&val; }
    // 0x1e43b8: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1e43bc: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1e43c4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[14] = *(float*)&val; }
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1e43c4
// Address: 0x1e43c4 - 0x1e4414

void entry_1e43c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e43c4) {
        switch (ctx->pc) {
            case 0x1e43e4: ctx->pc = 0; goto label_1e43e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e43c4: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e43c8: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e43cc: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e43d0: 0x12400004
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1e43e4;
    }
    // 0x1e43d8: 0x8e420440
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1088)));
    // 0x1e43dc: 0x14400017
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 128));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1e443c(rdram, ctx, runtime); return;
    }
label_1e43e4:
    // 0x1e43e4: 0x8fa30104
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x1e43e8: 0x8c620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    // 0x1e43ec: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
        ctx->pc = 0x1E441C; return;
    }
    // 0x1e43f4: 0x8c620228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 552)));
    // 0x1e43f8: 0x14400010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 128));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1e443c(rdram, ctx, runtime); return;
    }
    // 0x1e4400: 0x8fa50110
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1e4404: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e4408: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e440c: 0xc079222
    SET_GPR_U32(ctx, 31, 0x1e4414);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001e4888(rdram, ctx, runtime); return;
}


// Function: entry_1e4414
// Address: 0x1e4414 - 0x1e443c

void entry_1e4414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4414) {
        switch (ctx->pc) {
            case 0x1e441c: ctx->pc = 0; goto label_1e441c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4414: 0x1000000a
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E4440; return;
    }
label_1e441c:
    // 0x1e441c: 0x8c625978
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 22904)));
    // 0x1e4420: 0x14400006
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 128));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1e443c(rdram, ctx, runtime); return;
    }
    // 0x1e4428: 0x8fa40104
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x1e442c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e4430: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e4434: 0xc05179a
    SET_GPR_U32(ctx, 31, 0x1e443c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 80));
    FUN_00145e68(rdram, ctx, runtime); return;
}


// Function: entry_1e443c
// Address: 0x1e443c - 0x1e4454

void entry_1e443c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e443c) {
        switch (ctx->pc) {
            case 0x1e4440: ctx->pc = 0; goto label_1e4440;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e443c: 0x8fa50110
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 272)));
label_1e4440:
    // 0x1e4440: 0x27a600f8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 248));
    // 0x1e4444: 0x27a700fc
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 252));
    // 0x1e4448: 0x27a80100
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 256));
    // 0x1e444c: 0xc05150e
    SET_GPR_U32(ctx, 31, 0x1e4454);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DecomposeCylind(rdram, ctx, runtime); return;
}


// Function: entry_1e4454
// Address: 0x1e4454 - 0x1e4470

void entry_1e4454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4454: 0x7ba20080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e4458: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e445c: 0xc7ac00f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[12] = *(float*)&val; }
    // 0x1e4460: 0xc7ad00fc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 252)); ctx->f[13] = *(float*)&val; }
    // 0x1e4464: 0xc7ae0100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[14] = *(float*)&val; }
    // 0x1e4468: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1e4470);
    WRITE128(ADD32(GPR_U32(ctx, 17), 80), GPR_VEC(ctx, 2));
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1e4470
// Address: 0x1e4470 - 0x1e44dc

void entry_1e4470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4470: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e4474: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e4478: 0x8fa20104
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x1e447c: 0x4bc2106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e4480: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1e4484: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e4488: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e448c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e4490: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e4494: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e4498: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e449c: 0xc44001e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 484)); ctx->f[0] = *(float*)&val; }
    // 0x1e44a0: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e44a4: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x1e44a8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e44ac: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1e44b0: 0x8fa50110
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1e44b4: 0x4600e306
    ctx->f[12] = FPU_MOV_S(ctx->f[28]);
    // 0x1e44b8: 0x4600eb46
    ctx->f[13] = FPU_MOV_S(ctx->f[29]);
    // 0x1e44bc: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1e44c0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e44c4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1e44c8: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e44cc: 0xfba10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e44d0: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e44d4: 0xc0515c6
    SET_GPR_U32(ctx, 31, 0x1e44dc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    SetCm(rdram, ctx, runtime); return;
}


// Function: entry_1e44dc
// Address: 0x1e44dc - 0x1e450c

void entry_1e44dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e44dc: 0xc7a400f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[4] = *(float*)&val; }
    // 0x1e44e0: 0xc7a000fc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 252)); ctx->f[0] = *(float*)&val; }
    // 0x1e44e4: 0xc7a10100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[1] = *(float*)&val; }
    // 0x1e44e8: 0xc7a200e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[2] = *(float*)&val; }
    // 0x1e44ec: 0xc7a300ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 236)); ctx->f[3] = *(float*)&val; }
    // 0x1e44f0: 0x8fa40104
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x1e44f4: 0xe624000c
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 17), 12), *(uint32_t*)&val); }
    // 0x1e44f8: 0xe6200010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 16), *(uint32_t*)&val); }
    // 0x1e44fc: 0xe6210014
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 20), *(uint32_t*)&val); }
    // 0x1e4500: 0xe6220038
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 56), *(uint32_t*)&val); }
    // 0x1e4504: 0xc050ef8
    SET_GPR_U32(ctx, 31, 0x1e450c);
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 17), 60), *(uint32_t*)&val); }
    UpdateCmFade(rdram, ctx, runtime); return;
}


// Function: entry_1e450c
// Address: 0x1e450c - 0x1e451c

void entry_1e450c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e450c: 0xae200024
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 0));
    // 0x1e4510: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e4514: 0xc07915e
    SET_GPR_U32(ctx, 31, 0x1e451c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    FUN_001e4578(rdram, ctx, runtime); return;
}


// Function: entry_1e451c
// Address: 0x1e451c - 0x1e4578

void entry_1e451c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e451c: 0x7bbf01b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1e4520: 0x7bbe01a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1e4524: 0x7bb70190
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1e4528: 0x7bb60180
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1e452c: 0x7bb50170
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1e4530: 0x7bb40160
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1e4534: 0x7bb30150
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1e4538: 0x7bb20140
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1e453c: 0x7bb10130
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1e4540: 0x7bb00120
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1e4544: 0xc7bd0208
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 520)); ctx->f[29] = *(float*)&val; }
    // 0x1e4548: 0xc7bc0200
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 512)); ctx->f[28] = *(float*)&val; }
    // 0x1e454c: 0xc7bb01f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 504)); ctx->f[27] = *(float*)&val; }
    // 0x1e4550: 0xc7ba01f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 496)); ctx->f[26] = *(float*)&val; }
    // 0x1e4554: 0xc7b901e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 488)); ctx->f[25] = *(float*)&val; }
    // 0x1e4558: 0xc7b801e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 480)); ctx->f[24] = *(float*)&val; }
    // 0x1e455c: 0xc7b701d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 472)); ctx->f[23] = *(float*)&val; }
    // 0x1e4560: 0xc7b601d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 464)); ctx->f[22] = *(float*)&val; }
    // 0x1e4564: 0xc7b501c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 456)); ctx->f[21] = *(float*)&val; }
    // 0x1e4568: 0xc7b401c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 448)); ctx->f[20] = *(float*)&val; }
    // 0x1e456c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 528));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e4574: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e4578; return;
}


// Function: FUN_001e4578
// Address: 0x1e4578 - 0x1e4760

void FUN_001e4578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4578) {
        switch (ctx->pc) {
            case 0x1e45d4: ctx->pc = 0; goto label_1e45d4;
            case 0x1e45f0: ctx->pc = 0; goto label_1e45f0;
            case 0x1e46ac: ctx->pc = 0; goto label_1e46ac;
            case 0x1e46bc: ctx->pc = 0; goto label_1e46bc;
            case 0x1e46c8: ctx->pc = 0; goto label_1e46c8;
            case 0x1e4708: ctx->pc = 0; goto label_1e4708;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4578: 0x27bdfe90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966928));
    // 0x1e457c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1e4580: 0x7fb40100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 20));
    // 0x1e4584: 0x7fbf0150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), GPR_VEC(ctx, 31));
    // 0x1e4588: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1e458c: 0x7fbe0140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), GPR_VEC(ctx, 30));
    // 0x1e4590: 0x7fb70130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 23));
    // 0x1e4594: 0x7fb60120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 22));
    // 0x1e4598: 0x7fb50110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 21));
    // 0x1e459c: 0x7fb200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 18));
    // 0x1e45a0: 0x7fb100d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 17));
    // 0x1e45a4: 0x7fb000c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 16));
    // 0x1e45a8: 0xe7b40160
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 352), *(uint32_t*)&val); }
    // 0x1e45ac: 0x7fb300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 19));
    // 0x1e45b0: 0x8e930004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x1e45b4: 0x8c622c6c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11372)));
    // 0x1e45b8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1e45bc: 0x10400005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 988)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e45d4;
    }
    // 0x1e45c4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e45c8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1e45cc: 0x1000009f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 96), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e484c(rdram, ctx, runtime); return;
    }
label_1e45d4:
    // 0x1e45d4: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x1e45d8: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
        goto label_1e45f0;
    }
    // 0x1e45e0: 0x8c420440
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 1088)));
    // 0x1e45e4: 0x1440009a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E4850; return;
    }
    // 0x1e45ec: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1e45f0:
    // 0x1e45f0: 0x8c435978
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22904)));
    // 0x1e45f4: 0x14600096
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E4850; return;
    }
    // 0x1e45fc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e4600: 0xc6820060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 96)); ctx->f[2] = *(float*)&val; }
    // 0x1e4604: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1e4608: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e460c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1e4610: 0xc4615970
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 22896)); ctx->f[1] = *(float*)&val; }
    // 0x1e4614: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e4618: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e461c: 0x0
    // NOP
    // 0x1e4620: 0x4501008c
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E4854; return;
    }
    // 0x1e4628: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e462c: 0x7a640040
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 19), 64)));
    // 0x1e4630: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1e4634: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1e4638: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1e463c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e4640: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e4644: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1e4648: 0x7fa40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 4));
    // 0x1e464c: 0x24638d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x1e4650: 0x7fa40010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 4));
    // 0x1e4654: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1e4658: 0xda620040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 64)));
    // 0x1e465c: 0xd8a10140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 320)));
    // 0x1e4660: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e4664: 0x78630000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e4668: 0x4bc11afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x1e466c: 0x4bc3086e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e4670: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e4674: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e4678: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1e467c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e4680: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e4684: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e4688: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e468c: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e4690: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e4694: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1e4698: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e469c: 0x45000007
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e46bc;
    }
    // 0x1e46a4: 0x10000008
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e46c8;
    }
label_1e46ac:
    // 0x1e46ac: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1e46b0: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1e46b4: 0x10000056
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 96), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E4810; return;
    }
label_1e46bc:
    // 0x1e46bc: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1e46c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e46c4: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1e46c8:
    // 0x1e46c8: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e46cc: 0x27b60030
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1e46d0: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x1e46d4: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e46d8: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e46dc: 0xfba20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e46e0: 0xfba10080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e46e4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e46e8: 0x24445aa0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 23200));
    // 0x1e46ec: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e46f0: 0x27b50010
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e46f4: 0x27b000b0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1e46f8: 0x27b100b4
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 180));
    // 0x1e46fc: 0x27b70020
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1e4700: 0x27be00b8
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 184));
    // 0x1e4704: 0x2c0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_1e4708:
    // 0x1e4708: 0xd8830000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e470c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1e4710: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e4714: 0x24840010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16));
    // 0x1e4718: 0xdba50080
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e471c: 0x2e420005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 5));
    // 0x1e4720: 0xdba40090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1e4724: 0xd8a20140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 320)));
    // 0x1e4728: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1e472c: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e4730: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e4734: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e4738: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e473c: 0x4bc2086f
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e4740: 0x4bc208eb
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e4744: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e4748: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1e474c: 0xf8620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e4750: 0x1440ffed
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e4708;
    }
    // 0x1e4758: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1e4760);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e4760
// Address: 0x1e4760 - 0x1e4794

void entry_1e4760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4760: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e4764: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1e4768: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e476c: 0x3c080014
    SET_GPR_U32(ctx, 8, ((uint32_t)20 << 16));
    // 0x1e4770: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1e4774: 0x200502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e4778: 0x220582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e477c: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e4780: 0x25085dd8
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 24024));
    // 0x1e4784: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e4788: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e478c: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x1e4794);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1e4794
// Address: 0x1e4794 - 0x1e47b0

void entry_1e4794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4794) {
        switch (ctx->pc) {
            case 0x1e47a0: ctx->pc = 0; goto label_1e47a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4794: 0x2e0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1e4798: 0x2c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1e479c: 0x0
    // NOP
label_1e47a0:
    // 0x1e47a0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e47a4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e47a8: 0xc051070
    SET_GPR_U32(ctx, 31, 0x1e47b0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_1e47b0
// Address: 0x1e47b0 - 0x1e47c8

void entry_1e47b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e47b0: 0xc66001e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 484)); ctx->f[0] = *(float*)&val; }
    // 0x1e47b4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e47b8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e47bc: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e47c0: 0xc05104a
    SET_GPR_U32(ctx, 31, 0x1e47c8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
    ConvertCmScreenToWorld(rdram, ctx, runtime); return;
}


// Function: entry_1e47c8
// Address: 0x1e47c8 - 0x1e47e8

void entry_1e47c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e47c8: 0x8fa400b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1e47cc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e47d0: 0x8fa500b4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x1e47d4: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e47d8: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1e47dc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e47e0: 0xc051604
    SET_GPR_U32(ctx, 31, 0x1e47e8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    PsoEnemyStepguard(rdram, ctx, runtime); return;
}


// Function: entry_1e47e8
// Address: 0x1e47e8 - 0x1e4818

void entry_1e47e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e47e8) {
        switch (ctx->pc) {
            case 0x1e4800: ctx->pc = 0; goto label_1e4800;
            case 0x1e4810: ctx->pc = 0; goto label_1e4810;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e47e8: 0x10400005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e4800;
    }
    // 0x1e47f0: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e47f4: 0x0
    // NOP
    // 0x1e47f8: 0x4501ffac
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E46AC; return;
    }
label_1e4800:
    // 0x1e4800: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1e4804: 0x2e420005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 5));
    // 0x1e4808: 0x1440ffe5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E47A0; return;
    }
label_1e4810:
    // 0x1e4810: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1e4818);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e4818
// Address: 0x1e4818 - 0x1e484c

void entry_1e4818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4818: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e481c: 0xc6820060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 96)); ctx->f[2] = *(float*)&val; }
    // 0x1e4820: 0x24431858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1e4824: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1e4828: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e482c: 0xc4415974
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22900)); ctx->f[1] = *(float*)&val; }
    // 0x1e4830: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e4834: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4838: 0x0
    // NOP
    // 0x1e483c: 0x45000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E4850; return;
    }
    // 0x1e4844: 0xc051578
    SET_GPR_U32(ctx, 31, 0x1e484c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetResetFlag__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_1e484c
// Address: 0x1e484c - 0x1e4880

void entry_1e484c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e484c) {
        switch (ctx->pc) {
            case 0x1e4850: ctx->pc = 0; goto label_1e4850;
            case 0x1e4854: ctx->pc = 0; goto label_1e4854;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e484c: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
label_1e4850:
    // 0x1e4850: 0x7bbe0140
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 320)));
label_1e4854:
    // 0x1e4854: 0x7bb70130
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1e4858: 0x7bb60120
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1e485c: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1e4860: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1e4864: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1e4868: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1e486c: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1e4870: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1e4874: 0xc7b40160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[20] = *(float*)&val; }
    // 0x1e4878: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 368));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001e4880
// Address: 0x1e4880 - 0x1e4888

void FUN_001e4880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4880: 0x3e00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 32)); ctx->f[0] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001e4888
// Address: 0x1e4888 - 0x1e48f8

void FUN_001e4888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4888: 0x27bdfe70
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966896));
    // 0x1e488c: 0x7fb70110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 23));
    // 0x1e4890: 0x7fb60100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 22));
    // 0x1e4894: 0x7fb500f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 21));
    // 0x1e4898: 0x7fb400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 20));
    // 0x1e489c: 0x80a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1e48a0: 0x7fb300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 19));
    // 0x1e48a4: 0xe0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1e48a8: 0x7fb200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 18));
    // 0x1e48ac: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1e48b0: 0x7fb000a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 16));
    // 0x1e48b4: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1e48b8: 0xe7b60150
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 336), *(uint32_t*)&val); }
    // 0x1e48bc: 0xe7b40140
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 320), *(uint32_t*)&val); }
    // 0x1e48c0: 0x7fbf0130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 31));
    // 0x1e48c4: 0x7fb100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 17));
    // 0x1e48c8: 0xe7bc0180
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 384), *(uint32_t*)&val); }
    // 0x1e48cc: 0xe7bb0178
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 376), *(uint32_t*)&val); }
    // 0x1e48d0: 0xe7ba0170
    { float val = ctx->f[26]; WRITE32(ADD32(GPR_U32(ctx, 29), 368), *(uint32_t*)&val); }
    // 0x1e48d4: 0xe7b90168
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 29), 360), *(uint32_t*)&val); }
    // 0x1e48d8: 0xe7b80160
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 352), *(uint32_t*)&val); }
    // 0x1e48dc: 0xe7b70158
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 344), *(uint32_t*)&val); }
    // 0x1e48e0: 0xe7b50148
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 328), *(uint32_t*)&val); }
    // 0x1e48e4: 0x7fbe0120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 30));
    // 0x1e48e8: 0x8ebe0004
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x1e48ec: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1e48f0: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1e48f8);
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 30), 988)));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e48f8
// Address: 0x1e48f8 - 0x1e4958

void entry_1e48f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e48f8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e48fc: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1e4900: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1e4904: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e4908: 0xda430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1e490c: 0x3c080014
    SET_GPR_U32(ctx, 8, ((uint32_t)20 << 16));
    // 0x1e4910: 0xda620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1e4914: 0x4bc1186f
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e4918: 0x4bc1106f
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e491c: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1e4920: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e4924: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e4928: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e492c: 0x27ab0084
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 132));
    // 0x1e4930: 0x25085dd8
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 24024));
    // 0x1e4934: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e4938: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1e493c: 0x27aa0080
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1e4940: 0x4bc118eb
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e4944: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e4948: 0x4bc310ab
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e494c: 0x26310140
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1e4950: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x1e4958);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1e4958
// Address: 0x1e4958 - 0x1e4978

void entry_1e4958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4958: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1e495c: 0x8fa40080
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e4960: 0x8fa50084
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    // 0x1e4964: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e4968: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x1e496c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e4970: 0xc051654
    SET_GPR_U32(ctx, 31, 0x1e4978);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00145950(rdram, ctx, runtime); return;
}


// Function: entry_1e4978
// Address: 0x1e4978 - 0x1e49a0

void entry_1e4978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4978: 0x27a80088
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 136));
    // 0x1e497c: 0x27a9008c
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 140));
    // 0x1e4980: 0x8fa40080
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e4984: 0x100b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1e4988: 0x8fa50084
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    // 0x1e498c: 0x120b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1e4990: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e4994: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e4998: 0xc051604
    SET_GPR_U32(ctx, 31, 0x1e49a0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    PsoEnemyStepguard(rdram, ctx, runtime); return;
}


// Function: entry_1e49a0
// Address: 0x1e49a0 - 0x1e49d4

void entry_1e49a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e49a0: 0xc7a1008c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 140)); ctx->f[1] = *(float*)&val; }
    // 0x1e49a4: 0x46160834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e49a8: 0x0
    // NOP
    // 0x1e49ac: 0x45000057
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E4B0C; return;
    }
    // 0x1e49b4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e49b8: 0xaea20020
    WRITE32(ADD32(GPR_U32(ctx, 21), 32), GPR_U32(ctx, 2));
    // 0x1e49bc: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e49c0: 0x27a60090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1e49c4: 0x27a70094
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 148));
    // 0x1e49c8: 0x27a80098
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 152));
    // 0x1e49cc: 0xc05150e
    SET_GPR_U32(ctx, 31, 0x1e49d4);
    ctx->f[27] = FPU_MOV_S(ctx->f[22]);
    DecomposeCylind(rdram, ctx, runtime); return;
}


// Function: entry_1e49d4
// Address: 0x1e49d4 - 0x1e4a3c

void entry_1e49d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e49d4) {
        switch (ctx->pc) {
            case 0x1e4a28: ctx->pc = 0; goto label_1e4a28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e49d4: 0x3c013fa0
    SET_GPR_U32(ctx, 1, ((uint32_t)16288 << 16));
    // 0x1e49d8: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x1e49dc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e49e0: 0x3c013ef1
    SET_GPR_U32(ctx, 1, ((uint32_t)16113 << 16));
    // 0x1e49e4: 0x3421463b
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 17979));
    // 0x1e49e8: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1e49ec: 0xc455e5f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294960624)); ctx->f[21] = *(float*)&val; }
    // 0x1e49f0: 0x4600a5c6
    ctx->f[23] = FPU_MOV_S(ctx->f[20]);
    // 0x1e49f4: 0x3c013e92
    SET_GPR_U32(ctx, 1, ((uint32_t)16018 << 16));
    // 0x1e49f8: 0x34213a14
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 14868));
    // 0x1e49fc: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x1e4a00: 0x27b20040
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1e4a04: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1e4a08: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1e4a0c: 0x27b10050
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1e4a10: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1e4a14: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1e4a18: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x1e4a1c: 0x3c15001e
    SET_GPR_U32(ctx, 21, ((uint32_t)30 << 16));
    // 0x1e4a20: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1e4a24: 0xc7ac0090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[12] = *(float*)&val; }
label_1e4a28:
    // 0x1e4a28: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e4a2c: 0xc7ad0094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 148)); ctx->f[13] = *(float*)&val; }
    // 0x1e4a30: 0x46146300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[20]);
    // 0x1e4a34: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1e4a3c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[14] = *(float*)&val; }
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1e4a3c
// Address: 0x1e4a3c - 0x1e4a6c

void entry_1e4a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4a3c: 0xda620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1e4a40: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1e4a44: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e4a48: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e4a4c: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e4a50: 0x8fa40080
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e4a54: 0x8fa50084
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    // 0x1e4a58: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x1e4a5c: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e4a60: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1e4a64: 0xc051604
    SET_GPR_U32(ctx, 31, 0x1e4a6c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    PsoEnemyStepguard(rdram, ctx, runtime); return;
}


// Function: entry_1e4a6c
// Address: 0x1e4a6c - 0x1e4b6c

void entry_1e4a6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4a6c) {
        switch (ctx->pc) {
            case 0x1e4ac0: ctx->pc = 0; goto label_1e4ac0;
            case 0x1e4ad4: ctx->pc = 0; goto label_1e4ad4;
            case 0x1e4b00: ctx->pc = 0; goto label_1e4b00;
            case 0x1e4b0c: ctx->pc = 0; goto label_1e4b0c;
            case 0x1e4b44: ctx->pc = 0; goto label_1e4b44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4a6c: 0x4600a005
    ctx->f[0] = FPU_ABS_S(ctx->f[20]);
    // 0x1e4a70: 0xc7a2008c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 140)); ctx->f[2] = *(float*)&val; }
    // 0x1e4a74: 0x4602e041
    ctx->f[1] = FPU_SUB_S(ctx->f[28], ctx->f[2]);
    // 0x1e4a78: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x1e4a7c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1e4a80: 0x46150834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4a84: 0x0
    // NOP
    // 0x1e4a88: 0x4500000d
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e4ac0;
    }
    // 0x1e4a90: 0x4602d801
    ctx->f[0] = FPU_SUB_S(ctx->f[27], ctx->f[2]);
    // 0x1e4a94: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x1e4a98: 0x46000d46
    ctx->f[21] = FPU_MOV_S(ctx->f[1]);
    // 0x1e4a9c: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1e4aa0: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e4aa4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e4aa8: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1e4aac: 0x4be309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1e4ab0: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e4ab4: 0xfba30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1e4ab8: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e4abc: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
label_1e4ac0:
    // 0x1e4ac0: 0x4617a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4ac4: 0x0
    // NOP
    // 0x1e4ac8: 0x45000002
    ctx->f[1] = FPU_NEG_S(ctx->f[20]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e4ad4;
    }
    // 0x1e4ad0: 0x461a0840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[26]);
label_1e4ad4:
    // 0x1e4ad4: 0x46000805
    ctx->f[0] = FPU_ABS_S(ctx->f[1]);
    // 0x1e4ad8: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x1e4adc: 0x46190002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[25]);
    // 0x1e4ae0: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4ae4: 0x0
    // NOP
    // 0x1e4ae8: 0x45010005
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1e4b00;
    }
    // 0x1e4af0: 0x46180834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[24])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4af4: 0x0
    // NOP
    // 0x1e4af8: 0x4501ffcb
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[12] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E4A28; return;
    }
label_1e4b00:
    // 0x1e4b00: 0x7ba20060
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e4b04: 0x1000000f
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e4b44;
    }
label_1e4b0c:
    // 0x1e4b0c: 0x4601b001
    ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[1]);
    // 0x1e4b10: 0xda420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1e4b14: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e4b18: 0x3c15001e
    SET_GPR_U32(ctx, 21, ((uint32_t)30 << 16));
    // 0x1e4b1c: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1e4b20: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e4b24: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e4b28: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1e4b2c: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1e4b30: 0x4be309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1e4b34: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e4b38: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1e4b3c: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e4b40: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
label_1e4b44:
    // 0x1e4b44: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1e4b48: 0x8fa50080
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e4b4c: 0xc48c01ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 492)); ctx->f[12] = *(float*)&val; }
    // 0x1e4b50: 0x26a74880
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 21), 18560));
    // 0x1e4b54: 0x8fa60084
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    // 0x1e4b58: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e4b5c: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1e4b60: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e4b64: 0xc0516da
    SET_GPR_U32(ctx, 31, 0x1e4b6c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    FUN_00145b68(rdram, ctx, runtime); return;
}


// Function: entry_1e4b6c
// Address: 0x1e4b6c - 0x1e4b8c

void entry_1e4b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4b6c: 0x8fa40080
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e4b70: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e4b74: 0x8fa50084
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    // 0x1e4b78: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1e4b7c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1e4b80: 0x2e0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1e4b84: 0xc051604
    SET_GPR_U32(ctx, 31, 0x1e4b8c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PsoEnemyStepguard(rdram, ctx, runtime); return;
}


// Function: entry_1e4b8c
// Address: 0x1e4b8c - 0x1e4bf0

void entry_1e4b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4b8c) {
        switch (ctx->pc) {
            case 0x1e4be8: ctx->pc = 0; goto label_1e4be8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4b8c: 0xc7a2008c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 140)); ctx->f[2] = *(float*)&val; }
    // 0x1e4b90: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e4b94: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1e4b98: 0x46031032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[2], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e4b9c: 0x0
    // NOP
    // 0x1e4ba0: 0x45010011
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[0] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1e4be8;
    }
    // 0x1e4ba8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1e4bac: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e4bb0: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1e4bb4: 0xda840000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1e4bb8: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e4bbc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1e4bc0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e4bc4: 0x46001801
    ctx->f[0] = FPU_SUB_S(ctx->f[3], ctx->f[0]);
    // 0x1e4bc8: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1e4bcc: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e4bd0: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1e4bd4: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e4bd8: 0x4be111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1e4bdc: 0x4be32088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e4be0: 0xfa820000
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e4be4: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
label_1e4be8:
    // 0x1e4be8: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1e4bf0);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e4bf0
// Address: 0x1e4bf0 - 0x1e4c48

void entry_1e4bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4bf0: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1e4bf4: 0x7bbe0120
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1e4bf8: 0x7bb70110
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1e4bfc: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1e4c00: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1e4c04: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1e4c08: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1e4c0c: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1e4c10: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1e4c14: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e4c18: 0xc7bc0180
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 384)); ctx->f[28] = *(float*)&val; }
    // 0x1e4c1c: 0xc7bb0178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[27] = *(float*)&val; }
    // 0x1e4c20: 0xc7ba0170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[26] = *(float*)&val; }
    // 0x1e4c24: 0xc7b90168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 360)); ctx->f[25] = *(float*)&val; }
    // 0x1e4c28: 0xc7b80160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[24] = *(float*)&val; }
    // 0x1e4c2c: 0xc7b70158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 344)); ctx->f[23] = *(float*)&val; }
    // 0x1e4c30: 0xc7b60150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[22] = *(float*)&val; }
    // 0x1e4c34: 0xc7b50148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 328)); ctx->f[21] = *(float*)&val; }
    // 0x1e4c38: 0xc7b40140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[20] = *(float*)&val; }
    // 0x1e4c3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 400));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e4c44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e4c48; return;
}


// Function: LoadTbspFromBrx__FP18CBinaryInputStreamPiPP5TSURFT1PP4TBSP
// Address: 0x1e4c48 - 0x1e4c8c

void entry_1e4c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4c8c: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e4c90: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1e4c98);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 22), 5));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1e4c98
// Address: 0x1e4c98 - 0x1e4cbc

void entry_1e4c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4c98) {
        switch (ctx->pc) {
            case 0x1e4cb0: ctx->pc = 0; goto label_1e4cb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4c98: 0x1ac0000f
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 22) <= 0) {
        ctx->pc = 0x1E4CD8; return;
    }
    // 0x1e4ca0: 0x26b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 21), 16));
    // 0x1e4ca4: 0x2a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e4ca8: 0x2c0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1e4cac: 0x0
    // NOP
label_1e4cb0:
    // 0x1e4cb0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e4cb4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x1e4cbc);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1e4cbc
// Address: 0x1e4cbc - 0x1e4cd0

void entry_1e4cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4cbc: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    // 0x1e4cc0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e4cc4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e4cc8: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x1e4cd0);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 32));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1e4cd0
// Address: 0x1e4cd0 - 0x1e4ce0

void entry_1e4cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4cd0) {
        switch (ctx->pc) {
            case 0x1e4cd8: ctx->pc = 0; goto label_1e4cd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4cd0: 0x1600fff7
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 32));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E4CB0; return;
    }
label_1e4cd8:
    // 0x1e4cd8: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1e4ce0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1e4ce0
// Address: 0x1e4ce0 - 0x1e4cf0

void entry_1e4ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4ce0: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e4ce4: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1e4ce8: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1e4cf0);
    { int64_t result = (int64_t)GPR_S32(ctx, 20) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1e4cf0
// Address: 0x1e4cf0 - 0x1e4d10

void entry_1e4cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4cf0) {
        switch (ctx->pc) {
            case 0x1e4d08: ctx->pc = 0; goto label_1e4d08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4cf0: 0x1a80001f
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 20) <= 0) {
        ctx->pc = 0x1E4D70; return;
    }
    // 0x1e4cf8: 0x241e000c
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1e4cfc: 0x2417ffff
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e4d00: 0x240802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e4d04: 0x280882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_1e4d08:
    // 0x1e4d08: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1e4d10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1e4d10
// Address: 0x1e4d10 - 0x1e4d24

void entry_1e4d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4d10: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x1e4d14: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e4d18: 0x2a21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x1e4d1c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1e4d24);
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1e4d24
// Address: 0x1e4d24 - 0x1e4d48

void entry_1e4d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4d24) {
        switch (ctx->pc) {
            case 0x1e4d34: ctx->pc = 0; goto label_1e4d34;
            case 0x1e4d40: ctx->pc = 0; goto label_1e4d40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4d24: 0x14570003
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 23)) {
        goto label_1e4d34;
    }
    // 0x1e4d2c: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e4d40;
    }
label_1e4d34:
    // 0x1e4d34: 0x7e2018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 30); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1e4d38: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1e4d3c: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
label_1e4d40:
    // 0x1e4d40: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1e4d48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1e4d48
// Address: 0x1e4d48 - 0x1e4dc0

void entry_1e4d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4d48) {
        switch (ctx->pc) {
            case 0x1e4d58: ctx->pc = 0; goto label_1e4d58;
            case 0x1e4d64: ctx->pc = 0; goto label_1e4d64;
            case 0x1e4d70: ctx->pc = 0; goto label_1e4d70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4d48: 0x14570003
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 23)) {
        goto label_1e4d58;
    }
    // 0x1e4d50: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e4d64;
    }
label_1e4d58:
    // 0x1e4d58: 0x7e2018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 30); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1e4d5c: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1e4d60: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
label_1e4d64:
    // 0x1e4d64: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x1e4d68: 0x1620ffe7
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E4D08; return;
    }
label_1e4d70:
    // 0x1e4d70: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e4d74: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e4d78: 0xac560000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 22));
    // 0x1e4d7c: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1e4d80: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1e4d84: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e4d88: 0xac950000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 21));
    // 0x1e4d8c: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e4d90: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1e4d94: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e4d98: 0xac540000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 20));
    // 0x1e4d9c: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e4da0: 0x8fa4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1e4da4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e4da8: 0xac920000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 18));
    // 0x1e4dac: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e4db0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e4db4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e4db8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FCheckTbspPoint__FP4TBSPP6VECTOR
// Address: 0x1e4dc0 - 0x1e4e38

void entry_1e4e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4e6c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e4e70: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e4e74: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e4e78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: Set__11CTransitionPc3OIDT2i
// Address: 0x1e4e80 - 0x1e4ea8

void entry_1e4edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4edc: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1e4ee0: 0x104000a6
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E517C; return;
    }
    // 0x1e4ee8: 0xc063504
    SET_GPR_U32(ctx, 31, 0x1e4ef0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Clear__13CFileLocation(rdram, ctx, runtime); return;
}


// Function: entry_1e4ef0
// Address: 0x1e4ef0 - 0x1e4fd8

void entry_1e4ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e4ef0) {
        switch (ctx->pc) {
            case 0x1e4f94: ctx->pc = 0; goto label_1e4f94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e4ef0: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x1e4ef4: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e4ef8: 0x68430007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1e4efc: 0x6c430000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1e4f00: 0x6844000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1e4f04: 0x6c440008
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1e4f08: 0x68450017
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1e4f0c: 0x6c450010
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1e4f10: 0x6847001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1e4f14: 0x6c470018
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1e4f18: 0xb3a30017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e4f1c: 0xb7a30010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e4f20: 0xb3a4001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e4f24: 0xb7a40018
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e4f28: 0xb3a50027
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e4f2c: 0xb7a50020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e4f30: 0xb3a7002f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 47); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e4f34: 0xb7a70028
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 40); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e4f38: 0xae600004
    WRITE32(ADD32(GPR_U32(ctx, 19), 4), GPR_U32(ctx, 0));
    // 0x1e4f3c: 0x8fa30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1e4f40: 0x8fa4002c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x1e4f44: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e4f48: 0x8fa50024
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1e4f4c: 0x641826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1e4f50: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1e4f54: 0x451026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1e4f58: 0x106000b3
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1e5228(rdram, ctx, runtime); return;
    }
    // 0x1e4f60: 0x26720014
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 20));
    // 0x1e4f64: 0x10d2000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 18)) {
        goto label_1e4f94;
    }
    // 0x1e4f6c: 0x12400009
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1e4f94;
    }
    // 0x1e4f74: 0x8fa50028
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1e4f78: 0x8fa30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x1e4f7c: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1e4f80: 0x8e440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1e4f84: 0x651826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1e4f88: 0x441026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1e4f8c: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1e4f90: 0x2c650001
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 3), 1));
label_1e4f94:
    // 0x1e4f94: 0x24043f3f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16191));
    // 0x1e4f98: 0x2407003f
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 63));
    // 0x1e4f9c: 0x3c02003f
    SET_GPR_U32(ctx, 2, ((uint32_t)63 << 16));
    // 0x1e4fa0: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1e4fa4: 0x24033f00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16128));
    // 0x1e4fa8: 0xafa40080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 4));
    // 0x1e4fac: 0xafa70090
    WRITE32(ADD32(GPR_U32(ctx, 29), 144), GPR_U32(ctx, 7));
    // 0x1e4fb0: 0x34423f3f
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 16191));
    // 0x1e4fb4: 0x2cb50001
    SET_GPR_U32(ctx, 21, SLTU32(GPR_U32(ctx, 5), 1));
    // 0x1e4fb8: 0x27a60070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1e4fbc: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1e4fc0: 0x27a70080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1e4fc4: 0xafa30060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 3));
    // 0x1e4fc8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e4fcc: 0xafa20070
    WRITE32(ADD32(GPR_U32(ctx, 29), 112), GPR_U32(ctx, 2));
    // 0x1e4fd0: 0xc064c84
    SET_GPR_U32(ctx, 31, 0x1e4fd8);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 144));
    fn___5CProgP4RGBAN31(rdram, ctx, runtime); return;
}


// Function: entry_1e4fd8
// Address: 0x1e4fd8 - 0x1e4ffc

void entry_1e4fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4fd8: 0x27b000a0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1e4fdc: 0x3c06002c
    SET_GPR_U32(ctx, 6, ((uint32_t)44 << 16));
    // 0x1e4fe0: 0x3c050034
    SET_GPR_U32(ctx, 5, ((uint32_t)52 << 16));
    // 0x1e4fe4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e4fe8: 0x24c63b00
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 15104));
    // 0x1e4fec: 0x34a50c00
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 3072));
    // 0x1e4ff0: 0x24070006
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1e4ff4: 0xc04dca4
    SET_GPR_U32(ctx, 31, 0x1e4ffc);
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___18CBinaryInputStreamPvii(rdram, ctx, runtime); return;
}


// Function: entry_1e4ffc
// Address: 0x1e4ffc - 0x1e5014

void entry_1e4ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e4ffc: 0xae110030
    WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 17));
    // 0x1e5000: 0x8fa400d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1e5004: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
        ctx->pc = 0x1E5018; return;
    }
    // 0x1e500c: 0xc064c9c
    SET_GPR_U32(ctx, 31, 0x1e5014);
    Begin__5CProg(rdram, ctx, runtime); return;
}


// Function: entry_1e5014
// Address: 0x1e5014 - 0x1e5020

void entry_1e5014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5014) {
        switch (ctx->pc) {
            case 0x1e5018: ctx->pc = 0; goto label_1e5018;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5014: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_1e5018:
    // 0x1e5018: 0xc04dcec
    SET_GPR_U32(ctx, 31, 0x1e5020);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FOpenFile__18CBinaryInputStreamP13CFileLocation(rdram, ctx, runtime); return;
}


// Function: entry_1e5020
// Address: 0x1e5020 - 0x1e5034

void entry_1e5020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5020: 0x14400006
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E503C; return;
    }
    // 0x1e5028: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e502c: 0xc04dcb8
    SET_GPR_U32(ctx, 31, 0x1e5034);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x1372e0; return;
}


// Function: entry_1e5034
// Address: 0x1e5034 - 0x1e504c

void entry_1e5034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5034) {
        switch (ctx->pc) {
            case 0x1e503c: ctx->pc = 0; goto label_1e503c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5034: 0x1000007c
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e5228(rdram, ctx, runtime); return;
    }
label_1e503c:
    // 0x1e503c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1e5040: 0x8e045710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
    // 0x1e5044: 0xc076e0e
    SET_GPR_U32(ctx, 31, 0x1e504c);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DeleteSw__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1e504c
// Address: 0x1e504c - 0x1e505c

void entry_1e504c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e504c: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e5050: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e5054: 0xc076e4a
    SET_GPR_U32(ctx, 31, 0x1e505c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 22288), GPR_U32(ctx, 0));
    SetupBulkDataFromBrx__FiP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1e505c
// Address: 0x1e505c - 0x1e506c

void entry_1e505c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e505c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1e5060: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1e5064: 0xc050c2e
    SET_GPR_U32(ctx, 31, 0x1e506c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6232));
    ResetClock__FP5CLOCKf(rdram, ctx, runtime); return;
}


// Function: entry_1e506c
// Address: 0x1e506c - 0x1e5074

void entry_1e506c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e506c: 0xc05b83c
    SET_GPR_U32(ctx, 31, 0x1e5074);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 128));
    AddGrfusr__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1e5074
// Address: 0x1e5074 - 0x1e50c0

void entry_1e5074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5074: 0x6ba20017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1e5078: 0x6fa20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1e507c: 0x6ba3001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1e5080: 0x6fa30018
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1e5084: 0x6ba40027
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1e5088: 0x6fa40020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1e508c: 0x6ba5002f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 47); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1e5090: 0x6fa50028
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 40); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1e5094: 0xb262001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 27); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e5098: 0xb6620014
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 20); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e509c: 0xb2630023
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 35); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e50a0: 0xb663001c
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 28); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e50a4: 0xb264002b
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 43); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e50a8: 0xb6640024
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 36); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e50ac: 0xb2650033
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 51); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e50b0: 0xb665002c
    { uint32_t addr = ADD32(GPR_U32(ctx, 19), 44); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1e50b4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e50b8: 0xc0581a4
    SET_GPR_U32(ctx, 31, 0x1e50c0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    SetupGame__FPci(rdram, ctx, runtime); return;
}


// Function: entry_1e50c0
// Address: 0x1e50c0 - 0x1e50d8

void entry_1e50c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e50c0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e50c4: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1e50c8: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e50cc: 0x2404006c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 108));
    // 0x1e50d0: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1e50d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1e50d8
// Address: 0x1e50d8 - 0x1e50ec

void entry_1e50d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e50d8: 0xae025710
    WRITE32(ADD32(GPR_U32(ctx, 16), 22288), GPR_U32(ctx, 2));
    // 0x1e50dc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1e50e0: 0x2404000a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1e50e4: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1e50ec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1e50ec
// Address: 0x1e50ec - 0x1e5100

void entry_1e50ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e50ec: 0x8e045710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 22288)));
    // 0x1e50f0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e50f4: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1e50f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e5100);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e5100
// Address: 0x1e5100 - 0x1e5108

void entry_1e5100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5100: 0xc04dcf4
    SET_GPR_U32(ctx, 31, 0x1e5108);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    Close__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1e5108
// Address: 0x1e5108 - 0x1e511c

void entry_1e5108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5108: 0x8fa400d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1e510c: 0x10800004
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5120; return;
    }
    // 0x1e5114: 0xc064cc0
    SET_GPR_U32(ctx, 31, 0x1e511c);
    End__5CProg(rdram, ctx, runtime); return;
}


// Function: entry_1e511c
// Address: 0x1e511c - 0x1e516c

void entry_1e511c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e511c) {
        switch (ctx->pc) {
            case 0x1e5120: ctx->pc = 0; goto label_1e5120;
            case 0x1e5164: ctx->pc = 0; goto label_1e5164;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e511c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
label_1e5120:
    // 0x1e5120: 0x8c6623c0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x1e5124: 0x8cc219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 6636)));
    // 0x1e5128: 0x30420100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 256));
    // 0x1e512c: 0x1040000f
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e516c(rdram, ctx, runtime); return;
    }
    // 0x1e5134: 0x24444a40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 19008));
    // 0x1e5138: 0x8c854f44
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20292)));
    // 0x1e513c: 0x50a0000c
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
        ctx->pc = 0x1E5170; return;
    }
    // 0x1e5144: 0x8ca319d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 6616)));
    // 0x1e5148: 0x8cc219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 6616)));
    // 0x1e514c: 0x14620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e5164;
    }
    // 0x1e5154: 0x8ca319dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 6620)));
    // 0x1e5158: 0x8cc219dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 6620)));
    // 0x1e515c: 0x50620004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
        ctx->pc = 0x1E5170; return;
    }
label_1e5164:
    // 0x1e5164: 0xc0631fe
    SET_GPR_U32(ctx, 31, 0x1e516c);
    FUN_0018c7f8__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_1e516c
// Address: 0x1e516c - 0x1e5178

void entry_1e516c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e516c) {
        switch (ctx->pc) {
            case 0x1e5170: ctx->pc = 0; goto label_1e5170;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e516c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_1e5170:
    // 0x1e5170: 0xc04dcb8
    SET_GPR_U32(ctx, 31, 0x1e5178);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = 0x1372e0; return;
}


// Function: entry_1e5178
// Address: 0x1e5178 - 0x1e5190

void entry_1e5178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5178) {
        switch (ctx->pc) {
            case 0x1e517c: ctx->pc = 0; goto label_1e517c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5178: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
label_1e517c:
    // 0x1e517c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e5180: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e5184: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1e5188: 0xc050e98
    SET_GPR_U32(ctx, 31, 0x1e5190);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    ResetCm(rdram, ctx, runtime); return;
}


// Function: entry_1e5190
// Address: 0x1e5190 - 0x1e5198

void entry_1e5190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5190: 0xc07001c
    SET_GPR_U32(ctx, 31, 0x1e5198);
    UpdateSounds__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e5198
// Address: 0x1e5198 - 0x1e51a8

void entry_1e5198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5198: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1e519c: 0x2404000a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1e51a0: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1e51a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1e51a8
// Address: 0x1e51a8 - 0x1e51b8

void entry_1e51a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e51a8: 0x8e66000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 12)));
    // 0x1e51ac: 0x8e650008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x1e51b0: 0xc07d0c6
    SET_GPR_U32(ctx, 31, 0x1e51b8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    TeleportSwPlayer__FP2SW3OIDT1(rdram, ctx, runtime); return;
}


// Function: entry_1e51b8
// Address: 0x1e51b8 - 0x1e51c4

void entry_1e51b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e51b8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1e51bc: 0xc054786
    SET_GPR_U32(ctx, 31, 0x1e51c4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    OnDifficultyInitialTeleport__FP10DIFFICULTY(rdram, ctx, runtime); return;
}


// Function: entry_1e51c4
// Address: 0x1e51c4 - 0x1e51d0

void entry_1e51c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e51c4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1e51c8: 0xc05833a
    SET_GPR_U32(ctx, 31, 0x1e51d0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9176));
    FUN_00160ce8__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1e51d0
// Address: 0x1e51d0 - 0x1e51dc

void entry_1e51d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e51d0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e51d4: 0xc05ad48
    SET_GPR_U32(ctx, 31, 0x1e51dc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294965904));
    FUN_0016b520(rdram, ctx, runtime); return;
}


// Function: entry_1e51dc
// Address: 0x1e51dc - 0x1e51e8

void entry_1e51dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e51dc: 0x8e245710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    // 0x1e51e0: 0xc04e300
    SET_GPR_U32(ctx, 31, 0x1e51e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RecalcSwXpAll__FP2SWi(rdram, ctx, runtime); return;
}


// Function: entry_1e51e8
// Address: 0x1e51e8 - 0x1e51fc

void entry_1e51e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e51e8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e51ec: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1e51f0: 0xc44c186c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6252)); ctx->f[12] = *(float*)&val; }
    // 0x1e51f4: 0xc050f90
    SET_GPR_U32(ctx, 31, 0x1e51fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UpdateCmLast(rdram, ctx, runtime); return;
}


// Function: entry_1e51fc
// Address: 0x1e51fc - 0x1e5220

void entry_1e51fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e51fc: 0x8e620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1e5200: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x1e5204: 0x10400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e5220(rdram, ctx, runtime); return;
    }
    // 0x1e520c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e5210: 0x8c83c6c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294952648)));
    // 0x1e5214: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1e5218: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e5220);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294952648));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e5220
// Address: 0x1e5220 - 0x1e5228

void entry_1e5220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5220: 0xc050bb4
    SET_GPR_U32(ctx, 31, 0x1e5228);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetClockRate__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e5228
// Address: 0x1e5228 - 0x1e5230

void entry_1e5228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5228: 0xc0701b6
    SET_GPR_U32(ctx, 31, 0x1e5230);
    MvgkUnknown2__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e5230
// Address: 0x1e5230 - 0x1e5244

void entry_1e5230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5230: 0x8e225710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 22288)));
    // 0x1e5234: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e5238: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e523c: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1e5244);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 7548)); ctx->f[12] = *(float*)&val; }
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1e5244
// Address: 0x1e5244 - 0x1e524c

void entry_1e5244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5244: 0xc0647ac
    SET_GPR_U32(ctx, 31, 0x1e524c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    ClearPhase__F5PHASE(rdram, ctx, runtime); return;
}


// Function: entry_1e524c
// Address: 0x1e524c - 0x1e5278

void entry_1e524c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e524c: 0xae600000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 0));
    // 0x1e5250: 0x7bbf0160
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1e5254: 0x7bb50150
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1e5258: 0x7bb40140
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1e525c: 0x7bb30130
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1e5260: 0x7bb20120
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1e5264: 0x7bb10110
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1e5268: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1e526c: 0xc7b40170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[20] = *(float*)&val; }
    // 0x1e5270: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ResetWorld__F6FTRANS
// Address: 0x1e5278 - 0x1e5294

void entry_1e5294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5294) {
        switch (ctx->pc) {
            case 0x1e52b8: ctx->pc = 0; goto label_1e52b8;
            case 0x1e52d0: ctx->pc = 0; goto label_1e52d0;
            case 0x1e52d8: ctx->pc = 0; goto label_1e52d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5294: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e5298: 0x1202000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_1e52d8;
    }
    // 0x1e52a0: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e52b8;
    }
    // 0x1e52a8: 0x12000009
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1e52d0;
    }
    // 0x1e52b0: 0x10000013
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5300; return;
    }
label_1e52b8:
    // 0x1e52b8: 0x1202000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E52EC; return;
    }
    // 0x1e52c0: 0x1202000c
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E52F4; return;
    }
    // 0x1e52c8: 0x1000000d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5300; return;
    }
label_1e52d0:
    // 0x1e52d0: 0x10000009
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E52F8; return;
    }
label_1e52d8:
    // 0x1e52d8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1e52dc: 0xc0503b4
    SET_GPR_U32(ctx, 31, 0x1e52e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    ReturnChkmgrToCheckpoint__FP6CHKMGR(rdram, ctx, runtime); return;
}


// Function: entry_1e52e4
// Address: 0x1e52e4 - 0x1e5314

void entry_1e52e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e52e4) {
        switch (ctx->pc) {
            case 0x1e52ec: ctx->pc = 0; goto label_1e52ec;
            case 0x1e52f4: ctx->pc = 0; goto label_1e52f4;
            case 0x1e52f8: ctx->pc = 0; goto label_1e52f8;
            case 0x1e5300: ctx->pc = 0; goto label_1e5300;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e52e4: 0x1000000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5318; return;
    }
label_1e52ec:
    // 0x1e52ec: 0x10000002
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e52f8;
    }
label_1e52f4:
    // 0x1e52f4: 0x24110004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4));
label_1e52f8:
    // 0x1e52f8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e52fc: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1e5300:
    // 0x1e5300: 0x24845af0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23280));
    // 0x1e5304: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e5308: 0x2407ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e530c: 0xc0793a0
    SET_GPR_U32(ctx, 31, 0x1e5314);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 20));
    Set__11CTransitionPc3OIDT2i(rdram, ctx, runtime); return;
}


// Function: entry_1e5314
// Address: 0x1e5314 - 0x1e5328

void entry_1e5314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5314) {
        switch (ctx->pc) {
            case 0x1e5318: ctx->pc = 0; goto label_1e5318;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5314: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1e5318:
    // 0x1e5318: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e531c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e5320: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: transition__static_initialization_and_destruction_0
// Address: 0x1e5328 - 0x1e534c

void entry_1e534c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e534c) {
        switch (ctx->pc) {
            case 0x1e5350: ctx->pc = 0; goto label_1e5350;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e534c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1e5350:
    // 0x1e5350: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e5358: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1e535c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e5360: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1e5364: 0xc0794ca
    SET_GPR_U32(ctx, 31, 0x1e536c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    transition__static_initialization_and_destruction_0(rdram, ctx, runtime); return;
}


// Function: entry_1e536c
// Address: 0x1e536c - 0x1e5378

void entry_1e536c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e536c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e5370: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitTurret__FP6TURRET
// Address: 0x1e5378 - 0x1e538c

void entry_1e538c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e538c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e5390: 0x24040040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1e5394: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1e539c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1604), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1e539c
// Address: 0x1e539c - 0x1e53a8

void entry_1e539c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e539c: 0xae02063c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1596), GPR_U32(ctx, 2));
    // 0x1e53a0: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1e53a8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 64));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1e53a8
// Address: 0x1e53a8 - 0x1e53f8

void entry_1e53a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e53a8: 0x3c01bfc0
    SET_GPR_U32(ctx, 1, ((uint32_t)49088 << 16));
    // 0x1e53ac: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e53b0: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x1e53b4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e53b8: 0x3c01bf33
    SET_GPR_U32(ctx, 1, ((uint32_t)48947 << 16));
    // 0x1e53bc: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1e53c0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1e53c4: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1e53c8: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1e53cc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e53d0: 0xae020640
    WRITE32(ADD32(GPR_U32(ctx, 16), 1600), GPR_U32(ctx, 2));
    // 0x1e53d4: 0xe6000654
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1620), *(uint32_t*)&val); }
    // 0x1e53d8: 0xe6010658
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1624), *(uint32_t*)&val); }
    // 0x1e53dc: 0xe602065c
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 1628), *(uint32_t*)&val); }
    // 0x1e53e0: 0xe6030650
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 1616), *(uint32_t*)&val); }
    // 0x1e53e4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e53e8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e53ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e53f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e53f8; return;
}


// Function: FUN_001e53f8
// Address: 0x1e53f8 - 0x1e5428

void FUN_001e53f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e53f8) {
        switch (ctx->pc) {
            case 0x1e5420: ctx->pc = 0; goto label_1e5420;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e53f8: 0x80302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1e53fc: 0x8cc40638
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 1592)));
    // 0x1e5400: 0x28820011
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 17));
    // 0x1e5404: 0x10400006
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e5420;
    }
    // 0x1e540c: 0x8cc20640
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 1600)));
    // 0x1e5410: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1e5414: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1e5418: 0xac650000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 5));
    // 0x1e541c: 0xacc40638
    WRITE32(ADD32(GPR_U32(ctx, 6), 1592), GPR_U32(ctx, 4));
label_1e5420:
    // 0x1e5420: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostTurretLoad__FP6TURRET
// Address: 0x1e5428 - 0x1e5454

void entry_1e5454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5454: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1e5458: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e545c: 0x24c65b28
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 23336));
    // 0x1e5460: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1e5468);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1e5468
// Address: 0x1e5468 - 0x1e547c

void entry_1e5468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5468: 0x8e040610
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x1e546c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e5470: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e5474: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1e547c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1e547c
// Address: 0x1e547c - 0x1e5494

void entry_1e547c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e547c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e5480: 0xae020614
    WRITE32(ADD32(GPR_U32(ctx, 16), 1556), GPR_U32(ctx, 2));
    // 0x1e5484: 0x8c645710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    // 0x1e5488: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1e548c: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1e5494);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1e5494
// Address: 0x1e5494 - 0x1e54d0

void entry_1e5494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5494: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e5498: 0x12400023
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5528; return;
    }
    // 0x1e54a0: 0xae120620
    WRITE32(ADD32(GPR_U32(ctx, 16), 1568), GPR_U32(ctx, 18));
    // 0x1e54a4: 0xae120624
    WRITE32(ADD32(GPR_U32(ctx, 16), 1572), GPR_U32(ctx, 18));
    // 0x1e54a8: 0x24060160
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 352));
    // 0x1e54ac: 0xae500c2c
    WRITE32(ADD32(GPR_U32(ctx, 18), 3116), GPR_U32(ctx, 16));
    // 0x1e54b0: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e54b4: 0xae120598
    WRITE32(ADD32(GPR_U32(ctx, 16), 1432), GPR_U32(ctx, 18));
    // 0x1e54b8: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e54bc: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1e54c0: 0x26160110
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1e54c4: 0x26150648
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 16), 1608));
    // 0x1e54c8: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1e54d0);
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 16), 1612));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1e54d0
// Address: 0x1e54d0 - 0x1e54ec

void entry_1e54d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e54d0) {
        switch (ctx->pc) {
            case 0x1e54d8: ctx->pc = 0; goto label_1e54d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e54d0: 0x26110588
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1416));
    // 0x1e54d4: 0xae020584
    WRITE32(ADD32(GPR_U32(ctx, 16), 1412), GPR_U32(ctx, 2));
label_1e54d8:
    // 0x1e54d8: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1e54dc: 0x26660161
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 353));
    // 0x1e54e0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e54e4: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1e54ec);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1e54ec
// Address: 0x1e54ec - 0x1e5520

void entry_1e54ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e54ec: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1e54f0: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x1e54f4: 0x2a620003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 3));
    // 0x1e54f8: 0x1440fff7
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E54D8; return;
    }
    // 0x1e5500: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1e5504: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e5508: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e550c: 0xe6000594
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1428), *(uint32_t*)&val); }
    // 0x1e5510: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1e5514: 0x8c43006c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 108)));
    // 0x1e5518: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1e5520);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1e5520
// Address: 0x1e5520 - 0x1e5568

void entry_1e5520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5520) {
        switch (ctx->pc) {
            case 0x1e5528: ctx->pc = 0; goto label_1e5528;
            case 0x1e5544: ctx->pc = 0; goto label_1e5544;
            case 0x1e5550: ctx->pc = 0; goto label_1e5550;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5520: 0x10000008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1592)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e5544;
    }
label_1e5528:
    // 0x1e5528: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e552c: 0x26160110
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 16), 272));
    // 0x1e5530: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1e5534: 0x26150648
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 16), 1608));
    // 0x1e5538: 0x2614064c
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 16), 1612));
    // 0x1e553c: 0xae030620
    WRITE32(ADD32(GPR_U32(ctx, 16), 1568), GPR_U32(ctx, 3));
    // 0x1e5540: 0x8e020638
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1592)));
label_1e5544:
    // 0x1e5544: 0x18400013
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E5594; return;
    }
    // 0x1e554c: 0x8e020640
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1600)));
label_1e5550:
    // 0x1e5550: 0x119080
    SET_GPR_U32(ctx, 18, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1e5554: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1e5558: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e555c: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1e5560: 0xc056912
    SET_GPR_U32(ctx, 31, 0x1e5568);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1e5568
// Address: 0x1e5568 - 0x1e55a8

void entry_1e5568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5568) {
        switch (ctx->pc) {
            case 0x1e5588: ctx->pc = 0; goto label_1e5588;
            case 0x1e5594: ctx->pc = 0; goto label_1e5594;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5568: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e556c: 0x50600006
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1592)));
        goto label_1e5588;
    }
    // 0x1e5574: 0x8e02063c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1596)));
    // 0x1e5578: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1e557c: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1e5580: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x1e5584: 0x8e020638
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1592)));
label_1e5588:
    // 0x1e5588: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1e558c: 0x5440fff0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1600)));
        ctx->pc = 0x1E5550; return;
    }
label_1e5594:
    // 0x1e5594: 0xae110638
    WRITE32(ADD32(GPR_U32(ctx, 16), 1592), GPR_U32(ctx, 17));
    // 0x1e5598: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1e559c: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e55a0: 0xc06248c
    SET_GPR_U32(ctx, 31, 0x1e55a8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixPanTilt__FP7MATRIX3PfT1(rdram, ctx, runtime); return;
}


// Function: entry_1e55a8
// Address: 0x1e55a8 - 0x1e55d0

void entry_1e55a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e55a8: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e55ac: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e55b0: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e55b4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e55b8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e55bc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e55c0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e55c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e55c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateTurret__FP6TURRETf
// Address: 0x1e55d0 - 0x1e55f0

void entry_1e55f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e55f0: 0x8e440620
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1568)));
    // 0x1e55f4: 0x10800023
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5684; return;
    }
    // 0x1e55fc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e5600: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1e5604: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e560c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e560c
// Address: 0x1e560c - 0x1e562c

void entry_1e560c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e560c: 0x1040001a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5678; return;
    }
    // 0x1e5614: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1e5618: 0x24060008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1e561c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e5620: 0x24080008
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1e5624: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x1e562c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1e562c
// Address: 0x1e562c - 0x1e5664

void entry_1e562c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e562c) {
        switch (ctx->pc) {
            case 0x1e5640: ctx->pc = 0; goto label_1e5640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e562c: 0x18400010
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E5670; return;
    }
    // 0x1e5634: 0x2413000b
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1e5638: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e563c: 0x0
    // NOP
label_1e5640:
    // 0x1e5640: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e5644: 0x8e420620
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1568)));
    // 0x1e5648: 0x50820007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        ctx->pc = 0x1E5668; return;
    }
    // 0x1e5650: 0x8c820724
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1828)));
    // 0x1e5654: 0x10530003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 19)) {
        entry_1e5664(rdram, ctx, runtime); return;
    }
    // 0x1e565c: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x1e5664);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1e5664
// Address: 0x1e5664 - 0x1e56a0

void entry_1e5664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5664) {
        switch (ctx->pc) {
            case 0x1e5668: ctx->pc = 0; goto label_1e5668;
            case 0x1e5670: ctx->pc = 0; goto label_1e5670;
            case 0x1e5678: ctx->pc = 0; goto label_1e5678;
            case 0x1e5680: ctx->pc = 0; goto label_1e5680;
            case 0x1e5684: ctx->pc = 0; goto label_1e5684;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5664: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
label_1e5668:
    // 0x1e5668: 0x1620fff5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5640; return;
    }
label_1e5670:
    // 0x1e5670: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 18), 1408), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e5680;
    }
label_1e5678:
    // 0x1e5678: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e567c: 0xae420580
    WRITE32(ADD32(GPR_U32(ctx, 18), 1408), GPR_U32(ctx, 2));
label_1e5680:
    // 0x1e5680: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_1e5684:
    // 0x1e5684: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e5688: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e568c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e5690: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e5694: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e569c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e56a0; return;
}


// Function: UpdateTurretActive__FP6TURRETP3JOYf
// Address: 0x1e56a0 - 0x1e56c4

void entry_1e56c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e56c4: 0x960200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
    // 0x1e56c8: 0x304200c0
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 192));
    // 0x1e56cc: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e56e4(rdram, ctx, runtime); return;
    }
    // 0x1e56d4: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1e56dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 192));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1e56dc
// Address: 0x1e56dc - 0x1e56e4

void entry_1e56dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e56dc: 0xc07971e
    SET_GPR_U32(ctx, 31, 0x1e56e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FireTurret__FP6TURRET(rdram, ctx, runtime); return;
}


// Function: entry_1e56e4
// Address: 0x1e56e4 - 0x1e5708

void entry_1e56e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e56e4: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1e56e8: 0x8e042e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    // 0x1e56ec: 0x10800013
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E573C; return;
    }
    // 0x1e56f4: 0x8c822740
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 10048)));
    // 0x1e56f8: 0x50400011
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
        ctx->pc = 0x1E5740; return;
    }
    // 0x1e5700: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1e5708);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1e5708
// Address: 0x1e5708 - 0x1e571c

void entry_1e5708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5708: 0x1040000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e5738(rdram, ctx, runtime); return;
    }
    // 0x1e5710: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e5714: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1e571c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 196));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1e571c
// Address: 0x1e571c - 0x1e5738

void entry_1e571c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e571c: 0x8e042e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    // 0x1e5720: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e5724: 0x8c420134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 308)));
    // 0x1e5728: 0x10400003
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e5738(rdram, ctx, runtime); return;
    }
    // 0x1e5730: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e5738);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e5738
// Address: 0x1e5738 - 0x1e5750

void entry_1e5738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5738) {
        switch (ctx->pc) {
            case 0x1e573c: ctx->pc = 0; goto label_1e573c;
            case 0x1e5740: ctx->pc = 0; goto label_1e5740;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5738: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
label_1e573c:
    // 0x1e573c: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1e5740:
    // 0x1e5740: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1e5744: 0xc7b40100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[20] = *(float*)&val; }
    // 0x1e5748: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnTurretActive__FP6TURRETiP2PO
// Address: 0x1e5750 - 0x1e5770

void entry_1e5770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5770: 0x12000029
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5818; return;
    }
    // 0x1e5778: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1e577c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e5780: 0x8e421990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    // 0x1e5784: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1e5788: 0x261001f8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 504));
    // 0x1e578c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e5790: 0xe4400480
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 1152), *(uint32_t*)&val); }
    // 0x1e5794: 0x24845bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    // 0x1e5798: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x1e57a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1e57a0
// Address: 0x1e57a0 - 0x1e57ac

void entry_1e57a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e57a0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e57a4: 0xc04d5b0
    SET_GPR_U32(ctx, 31, 0x1e57ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    open_close_binoc(rdram, ctx, runtime); return;
}


// Function: entry_1e57ac
// Address: 0x1e57ac - 0x1e57f4

void entry_1e57ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e57ac) {
        switch (ctx->pc) {
            case 0x1e57e0: ctx->pc = 0; goto label_1e57e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e57ac: 0x8e441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    // 0x1e57b0: 0x8e22061c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1564)));
    // 0x1e57b4: 0xac8204bc
    WRITE32(ADD32(GPR_U32(ctx, 4), 1212), GPR_U32(ctx, 2));
    // 0x1e57b8: 0x8e230630
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1584)));
    // 0x1e57bc: 0x50600008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
        goto label_1e57e0;
    }
    // 0x1e57c4: 0x7a220110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x1e57c8: 0x7c820080
    WRITE128(ADD32(GPR_U32(ctx, 4), 128), GPR_VEC(ctx, 2));
    // 0x1e57cc: 0x7a230120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 17), 288)));
    // 0x1e57d0: 0x7c830090
    WRITE128(ADD32(GPR_U32(ctx, 4), 144), GPR_VEC(ctx, 3));
    // 0x1e57d4: 0x7a220130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 304)));
    // 0x1e57d8: 0x7c8200a0
    WRITE128(ADD32(GPR_U32(ctx, 4), 160), GPR_VEC(ctx, 2));
    // 0x1e57dc: 0x8e441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
label_1e57e0:
    // 0x1e57e0: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1e57e4: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e57e8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e57ec: 0xc051422
    SET_GPR_U32(ctx, 31, 0x1e57f4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1120));
    SetCmPolicy(rdram, ctx, runtime); return;
}


// Function: entry_1e57f4
// Address: 0x1e57f4 - 0x1e5804

void entry_1e57f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e57f4: 0x8e441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    // 0x1e57f8: 0x8e250644
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1604)));
    // 0x1e57fc: 0xc05257a
    SET_GPR_U32(ctx, 31, 0x1e5804);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1120));
    PushCplookLookk__FP6CPLOOK5LOOKK(rdram, ctx, runtime); return;
}


// Function: entry_1e5804
// Address: 0x1e5804 - 0x1e5810

void entry_1e5804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5804: 0x8e240614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1556)));
    // 0x1e5808: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1e5810);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 857));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1e5810
// Address: 0x1e5810 - 0x1e5838

void entry_1e5810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5810) {
        switch (ctx->pc) {
            case 0x1e5818: ctx->pc = 0; goto label_1e5818;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5810: 0x10000017
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5870; return;
    }
label_1e5818:
    // 0x1e5818: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1e581c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1e5820: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e5824: 0x8e021990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1e5828: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e582c: 0x24845bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    // 0x1e5830: 0xc07a55c
    SET_GPR_U32(ctx, 31, 0x1e5838);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 1152), *(uint32_t*)&val); }
    PopUiActiveBlot__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_1e5838
// Address: 0x1e5838 - 0x1e5854

void entry_1e5838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5838: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1e583c: 0x2405000f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    // 0x1e5840: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e5844: 0x24060006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1e5848: 0x24870460
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 1120));
    // 0x1e584c: 0xc05147c
    SET_GPR_U32(ctx, 31, 0x1e5854);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RevokeCmPolicy(rdram, ctx, runtime); return;
}


// Function: entry_1e5854
// Address: 0x1e5854 - 0x1e5860

void entry_1e5854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5854: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1e5858: 0xc052584
    SET_GPR_U32(ctx, 31, 0x1e5860);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1120));
    LookkPopCplook__FP6CPLOOK(rdram, ctx, runtime); return;
}


// Function: entry_1e5860
// Address: 0x1e5860 - 0x1e586c

void entry_1e5860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5860: 0x8e240614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1556)));
    // 0x1e5864: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1e586c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 856));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1e586c
// Address: 0x1e586c - 0x1e5888

void entry_1e586c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e586c) {
        switch (ctx->pc) {
            case 0x1e5870: ctx->pc = 0; goto label_1e5870;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e586c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1e5870:
    // 0x1e5870: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e5874: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e5878: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e587c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e5884: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e5888; return;
}


// Function: FFilterTurret__FP6TURRETP2SO
// Address: 0x1e5888 - 0x1e58d0

void entry_1e58d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e58d0: 0x14400013
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5920; return;
    }
    // 0x1e58d8: 0x8e120050
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1e58dc: 0x8e220618
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1560)));
    // 0x1e58e0: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1e58e4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e58e8: 0x8c500048
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1e58ec: 0x8c6200f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 240)));
    // 0x1e58f0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e58f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e58f8
// Address: 0x1e58f8 - 0x1e5914

void entry_1e58f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e58f8: 0x14400009
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5920; return;
    }
    // 0x1e5900: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e5904: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e5908: 0x8c6200f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 240)));
    // 0x1e590c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e5914);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e5914
// Address: 0x1e5914 - 0x1e5938

void entry_1e5914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5914) {
        switch (ctx->pc) {
            case 0x1e591c: ctx->pc = 0; goto label_1e591c;
            case 0x1e5920: ctx->pc = 0; goto label_1e5920;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5914: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e5920;
    }
label_1e591c:
    // 0x1e591c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1e5920:
    // 0x1e5920: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e5924: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e5928: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e592c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e5930: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateTurretAim__FP6TURRET
// Address: 0x1e5938 - 0x1e5970

void entry_1e5970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5970: 0x104000b5
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5C48; return;
    }
    // 0x1e5978: 0x8e740618
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 19), 1560)));
    // 0x1e597c: 0x245601f8
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 2), 504));
    // 0x1e5980: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e5984: 0x26820060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 96));
    // 0x1e5988: 0x27a50110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 272));
    // 0x1e598c: 0x27a60114
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 276));
    // 0x1e5990: 0xafa20120
    WRITE32(ADD32(GPR_U32(ctx, 29), 288), GPR_U32(ctx, 2));
    // 0x1e5994: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1e5998: 0xc04dbb2
    SET_GPR_U32(ctx, 31, 0x1e59a0);
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    GetBinocReticleFocus__FP5BINOCPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1e59a0
// Address: 0x1e59a0 - 0x1e5a40

void entry_1e59a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e59a0: 0x269500e0
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 20), 224));
    // 0x1e59a4: 0xc7a10110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[1] = *(float*)&val; }
    // 0x1e59a8: 0x27b10020
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1e59ac: 0x3c013b4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15180 << 16));
    // 0x1e59b0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e59b4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1e59b8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e59bc: 0xc7a20114
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 276)); ctx->f[2] = *(float*)&val; }
    // 0x1e59c0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e59c4: 0x3c013b84
    SET_GPR_U32(ctx, 1, ((uint32_t)15236 << 16));
    // 0x1e59c8: 0x3421fcad
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 64685));
    // 0x1e59cc: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1e59d0: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1e59d4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e59d8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e59dc: 0x269e0150
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 20), 336));
    // 0x1e59e0: 0x46041082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x1e59e4: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1e59e8: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1e59ec: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1e59f0: 0x3c01479c
    SET_GPR_U32(ctx, 1, ((uint32_t)18332 << 16));
    // 0x1e59f4: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1e59f8: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1e59fc: 0x8e441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    // 0x1e5a00: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e5a04: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e5a08: 0x44070000
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[0]);
    // 0x1e5a0c: 0x70e21488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 7), GPR_VEC(ctx, 2)));
    // 0x1e5a10: 0x44071800
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[3]);
    // 0x1e5a14: 0x70e21389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 7), GPR_VEC(ctx, 2)));
    // 0x1e5a18: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1e5a1c: 0x44080000
    SET_GPR_U32(ctx, 8, *(uint32_t*)&ctx->f[0]);
    // 0x1e5a20: 0x71031c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 8), GPR_VEC(ctx, 3)));
    // 0x1e5a24: 0x44082000
    SET_GPR_U32(ctx, 8, *(uint32_t*)&ctx->f[4]);
    // 0x1e5a28: 0x71031b89
    SET_GPR_VEC(ctx, 3, _mm_unpacklo_epi64(GPR_VEC(ctx, 8), GPR_VEC(ctx, 3)));
    // 0x1e5a2c: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x1e5a30: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1e5a34: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    // 0x1e5a38: 0xc05104a
    SET_GPR_U32(ctx, 31, 0x1e5a40);
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    ConvertCmScreenToWorld(rdram, ctx, runtime); return;
}


// Function: entry_1e5a40
// Address: 0x1e5a40 - 0x1e5a54

void entry_1e5a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5a40: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1e5a44: 0x8e441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    // 0x1e5a48: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e5a4c: 0xc05104a
    SET_GPR_U32(ctx, 31, 0x1e5a54);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertCmScreenToWorld(rdram, ctx, runtime); return;
}


// Function: entry_1e5a54
// Address: 0x1e5a54 - 0x1e5a5c

void entry_1e5a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5a54: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1e5a5c);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e5a5c
// Address: 0x1e5a5c - 0x1e5a84

void entry_1e5a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5a5c: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x1e5a60: 0x3c08001e
    SET_GPR_U32(ctx, 8, ((uint32_t)30 << 16));
    // 0x1e5a64: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e5a68: 0x27aa0118
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 280));
    // 0x1e5a6c: 0x27ab011c
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 284));
    // 0x1e5a70: 0x25085888
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 22664));
    // 0x1e5a74: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e5a78: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e5a7c: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x1e5a84);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1e5a84
// Address: 0x1e5a84 - 0x1e5aa4

void entry_1e5a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5a84: 0x27b20050
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1e5a88: 0x8fa70118
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 280)));
    // 0x1e5a8c: 0x8fa8011c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 284)));
    // 0x1e5a90: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e5a94: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e5a98: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e5a9c: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x1e5aa4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1e5aa4
// Address: 0x1e5aa4 - 0x1e5ad0

void entry_1e5aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5aa4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e5aa8: 0x12000043
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5BB8; return;
    }
    // 0x1e5ab0: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1e5ab4: 0x10510040
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1E5BB8; return;
    }
    // 0x1e5abc: 0xae9000e0
    WRITE32(ADD32(GPR_U32(ctx, 20), 224), GPR_U32(ctx, 16));
    // 0x1e5ac0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e5ac4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e5ac8: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1e5ad0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 20), 240));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1e5ad0
// Address: 0x1e5ad0 - 0x1e5ae4

void entry_1e5ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5ad0: 0x7ba20050
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e5ad4: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1e5ad8: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x1e5adc: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1e5ae4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1e5ae4
// Address: 0x1e5ae4 - 0x1e5af8

void entry_1e5ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5ae4: 0x14400006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5B00; return;
    }
    // 0x1e5aec: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1e5af0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1e5af8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1e5af8
// Address: 0x1e5af8 - 0x1e5b1c

void entry_1e5af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5af8) {
        switch (ctx->pc) {
            case 0x1e5b00: ctx->pc = 0; goto label_1e5b00;
            case 0x1e5b10: ctx->pc = 0; goto label_1e5b10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5af8: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e5b10;
    }
label_1e5b00:
    // 0x1e5b00: 0x27b100c0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1e5b04: 0xaec20320
    WRITE32(ADD32(GPR_U32(ctx, 22), 800), GPR_U32(ctx, 2));
    // 0x1e5b08: 0x10000034
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 208));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5BDC; return;
    }
label_1e5b10:
    // 0x1e5b10: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x1e5b14: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1e5b1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1e5b1c
// Address: 0x1e5b1c - 0x1e5be4

void entry_1e5b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5b1c) {
        switch (ctx->pc) {
            case 0x1e5b34: ctx->pc = 0; goto label_1e5b34;
            case 0x1e5b48: ctx->pc = 0; goto label_1e5b48;
            case 0x1e5b68: ctx->pc = 0; goto label_1e5b68;
            case 0x1e5b84: ctx->pc = 0; goto label_1e5b84;
            case 0x1e5b8c: ctx->pc = 0; goto label_1e5b8c;
            case 0x1e5b98: ctx->pc = 0; goto label_1e5b98;
            case 0x1e5bac: ctx->pc = 0; goto label_1e5bac;
            case 0x1e5bb8: ctx->pc = 0; goto label_1e5bb8;
            case 0x1e5bdc: ctx->pc = 0; goto label_1e5bdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5b1c: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 19), 1592)));
        goto label_1e5b34;
    }
    // 0x1e5b24: 0xaed10320
    WRITE32(ADD32(GPR_U32(ctx, 22), 800), GPR_U32(ctx, 17));
    // 0x1e5b28: 0x27b000d0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1e5b2c: 0x1000002b
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 192));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e5bdc;
    }
label_1e5b34:
    // 0x1e5b34: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e5b38: 0x27b100c0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1e5b3c: 0x27b000d0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1e5b40: 0x100382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1e5b44: 0x0
    // NOP
label_1e5b48:
    // 0x1e5b48: 0x18e00010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 7) <= 0) {
        goto label_1e5b8c;
    }
    // 0x1e5b50: 0x8e63063c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 1596)));
    // 0x1e5b54: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e5b58: 0x1045000a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 7)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        goto label_1e5b84;
    }
    // 0x1e5b60: 0x100302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1e5b64: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
label_1e5b68:
    // 0x1e5b68: 0x86102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 6)));
    // 0x1e5b6c: 0x10400007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e5b8c;
    }
    // 0x1e5b74: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e5b78: 0x5445fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_1e5b68;
    }
    // 0x1e5b80: 0x87102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 7)));
label_1e5b84:
    // 0x1e5b84: 0x14400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e5b98;
    }
label_1e5b8c:
    // 0x1e5b8c: 0x8ca50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 24)));
    // 0x1e5b90: 0x14a0ffed
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_1e5b48;
    }
label_1e5b98:
    // 0x1e5b98: 0x10a00004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 23), 504));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1e5bac;
    }
    // 0x1e5ba0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e5ba4: 0x1000000d
    WRITE32(ADD32(GPR_U32(ctx, 3), 800), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e5bdc;
    }
label_1e5bac:
    // 0x1e5bac: 0x26e201f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 504));
    // 0x1e5bb0: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 2), 800), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e5bdc;
    }
label_1e5bb8:
    // 0x1e5bb8: 0xaea00000
    WRITE32(ADD32(GPR_U32(ctx, 21), 0), GPR_U32(ctx, 0));
    // 0x1e5bbc: 0x26e201f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 504));
    // 0x1e5bc0: 0x27b100c0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1e5bc4: 0x27b000d0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1e5bc8: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e5bcc: 0x7ea30010
    WRITE128(ADD32(GPR_U32(ctx, 21), 16), GPR_VEC(ctx, 3));
    // 0x1e5bd0: 0xac400320
    WRITE32(ADD32(GPR_U32(ctx, 2), 800), GPR_U32(ctx, 0));
    // 0x1e5bd4: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e5bd8: 0x7fa30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
label_1e5bdc:
    // 0x1e5bdc: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1e5be4);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e5be4
// Address: 0x1e5be4 - 0x1e5bf8

void entry_1e5be4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5be4: 0x8fa40120
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1e5be8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e5bec: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e5bf0: 0xc06a530
    SET_GPR_U32(ctx, 31, 0x1e5bf8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetRwfiPosMat__FP4RWFIP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1e5bf8
// Address: 0x1e5bf8 - 0x1e5c14

void entry_1e5bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5bf8: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e5bfc: 0xdba200c0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1e5c00: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e5c04: 0xfba10100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e5c08: 0xc7ac0104
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 260)); ctx->f[12] = *(float*)&val; }
    // 0x1e5c0c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1e5c14);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1e5c14
// Address: 0x1e5c14 - 0x1e5c44

void entry_1e5c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5c14: 0xe7c00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 30), 8), *(uint32_t*)&val); }
    // 0x1e5c18: 0xdba10100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1e5c1c: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e5c20: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e5c24: 0xc7ac0108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[12] = *(float*)&val; }
    // 0x1e5c28: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e5c2c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e5c30: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e5c34: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e5c38: 0x44826800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 2);
    // 0x1e5c3c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1e5c44);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1e5c44
// Address: 0x1e5c44 - 0x1e5c78

void entry_1e5c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5c44) {
        switch (ctx->pc) {
            case 0x1e5c48: ctx->pc = 0; goto label_1e5c48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5c44: 0xe7c00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 30), 4), *(uint32_t*)&val); }
label_1e5c48:
    // 0x1e5c48: 0x7bbf01c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x1e5c4c: 0x7bbe01b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1e5c50: 0x7bb701a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1e5c54: 0x7bb60190
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1e5c58: 0x7bb50180
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1e5c5c: 0x7bb40170
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1e5c60: 0x7bb30160
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1e5c64: 0x7bb20150
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1e5c68: 0x7bb10140
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1e5c6c: 0x7bb00130
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1e5c70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 464));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FireTurret__FP6TURRET
// Address: 0x1e5c78 - 0x1e5c94

void entry_1e5c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5c94: 0x8e040614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x1e5c98: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x1e5ca0);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1e5ca0
// Address: 0x1e5ca0 - 0x1e5cc4

void entry_1e5ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5ca0: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e5ca4: 0x24020359
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 857));
    // 0x1e5ca8: 0x1462000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E5CDC; return;
    }
    // 0x1e5cb0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1e5cb4: 0x5443000a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
        ctx->pc = 0x1E5CE0; return;
    }
    // 0x1e5cbc: 0xc06a314
    SET_GPR_U32(ctx, 31, 0x1e5cc4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1560)));
    FEnsureRwmLoaded__FP3RWM(rdram, ctx, runtime); return;
}


// Function: entry_1e5cc4
// Address: 0x1e5cc4 - 0x1e5cd8

void entry_1e5cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5cc4: 0x10400005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5CDC; return;
    }
    // 0x1e5ccc: 0x8e040614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x1e5cd0: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1e5cd8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 858));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1e5cd8
// Address: 0x1e5cd8 - 0x1e5ce8

void entry_1e5cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5cd8) {
        switch (ctx->pc) {
            case 0x1e5cdc: ctx->pc = 0; goto label_1e5cdc;
            case 0x1e5ce0: ctx->pc = 0; goto label_1e5ce0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5cd8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1e5cdc:
    // 0x1e5cdc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1e5ce0:
    // 0x1e5ce0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleTurretMessage__FP6TURRET5MSGIDPv
// Address: 0x1e5ce8 - 0x1e5d0c

void entry_1e5d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5d0c: 0x24020013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 19));
    // 0x1e5d10: 0x1602001f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E5D90; return;
    }
    // 0x1e5d18: 0x8e430614
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1556)));
    // 0x1e5d1c: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e5d20: 0x8c620024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 36)));
    // 0x1e5d24: 0x5482000a
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1572)));
        ctx->pc = 0x1E5D50; return;
    }
    // 0x1e5d2c: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1e5d30: 0x2402035b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 859));
    // 0x1e5d34: 0x54620017
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        ctx->pc = 0x1E5D94; return;
    }
    // 0x1e5d3c: 0x8e440618
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1560)));
    // 0x1e5d40: 0xc06a324
    SET_GPR_U32(ctx, 31, 0x1e5d48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FFireRwm__FP3RWMi(rdram, ctx, runtime); return;
}


// Function: entry_1e5d48
// Address: 0x1e5d48 - 0x1e5da8

void entry_1e5d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5d48) {
        switch (ctx->pc) {
            case 0x1e5d50: ctx->pc = 0; goto label_1e5d50;
            case 0x1e5d84: ctx->pc = 0; goto label_1e5d84;
            case 0x1e5d90: ctx->pc = 0; goto label_1e5d90;
            case 0x1e5d94: ctx->pc = 0; goto label_1e5d94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5d48: 0x10000011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e5d90;
    }
label_1e5d50:
    // 0x1e5d50: 0x1040000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e5d90;
    }
    // 0x1e5d58: 0x8c4207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 2016)));
    // 0x1e5d5c: 0x5482000d
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        goto label_1e5d94;
    }
    // 0x1e5d64: 0x8e260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1e5d68: 0x2402015e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 350));
    // 0x1e5d6c: 0x10c20005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 351));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        goto label_1e5d84;
    }
    // 0x1e5d74: 0x50c20006
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 1576), GPR_U32(ctx, 0));
        goto label_1e5d90;
    }
    // 0x1e5d7c: 0x10000005
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e5d94;
    }
label_1e5d84:
    // 0x1e5d84: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e5d88: 0xae420628
    WRITE32(ADD32(GPR_U32(ctx, 18), 1576), GPR_U32(ctx, 2));
    // 0x1e5d8c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1e5d90:
    // 0x1e5d90: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1e5d94:
    // 0x1e5d94: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e5d98: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e5d9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e5da4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e5da8; return;
}


// Function: FIgnoreTurretIntersection__FP6TURRETP2SO
// Address: 0x1e5da8 - 0x1e5dc4

void entry_1e5dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5dc4: 0x1440000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5DF0; return;
    }
    // 0x1e5dcc: 0x8e040618
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1560)));
    // 0x1e5dd0: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x1E5DF0; return;
    }
    // 0x1e5dd8: 0xc06a208
    SET_GPR_U32(ctx, 31, 0x1e5de0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1e5de0
// Address: 0x1e5de0 - 0x1e5e08

void entry_1e5de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5de0) {
        switch (ctx->pc) {
            case 0x1e5df0: ctx->pc = 0; goto label_1e5df0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5de0: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e5de4: 0x14600002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1e5df0;
    }
    // 0x1e5dec: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1e5df0:
    // 0x1e5df0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e5df4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e5df8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e5dfc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e5e04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e5e08; return;
}


// Function: CollectTurretPrize__FP6TURRET3PCKP3ALO
// Address: 0x1e5e08 - 0x1e5e30

void entry_1e5e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5e30) {
        switch (ctx->pc) {
            case 0x1e5e38: ctx->pc = 0; goto label_1e5e38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5e30: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5E44; return;
    }
label_1e5e38:
    // 0x1e5e38: 0xc064932
    SET_GPR_U32(ctx, 31, 0x1e5e40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    CollectPoPrize__FP2PO3PCKP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1e5e40
// Address: 0x1e5e40 - 0x1e5e50

void entry_1e5e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5e40) {
        switch (ctx->pc) {
            case 0x1e5e44: ctx->pc = 0; goto label_1e5e44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5e40: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1e5e44:
    // 0x1e5e44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e5e4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e5e50; return;
}


// Function: GetTurretDiapi__FP6TURRETP6DIALOGP5DIAPI
// Address: 0x1e5e50 - 0x1e5e60

void FUN_001e5e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5e60: 0x8c820620
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1568)));
    // 0x1e5e64: 0x3e00008
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e5e6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e5e70; return;
}


// Function: InitTv__FP2TV5BLOTK
// Address: 0x1e5e70 - 0x1e5ee4

void entry_1e5ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e5ee4) {
        switch (ctx->pc) {
            case 0x1e5f14: ctx->pc = 0; goto label_1e5f14;
            case 0x1e5f30: ctx->pc = 0; goto label_1e5f30;
            case 0x1e5f80: ctx->pc = 0; goto label_1e5f80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e5ee4: 0x2402001a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 26));
    // 0x1e5ee8: 0x1602000a
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 564)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1e5f14;
    }
    // 0x1e5ef0: 0x3c01427a
    SET_GPR_U32(ctx, 1, ((uint32_t)17018 << 16));
    // 0x1e5ef4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e5ef8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e5efc: 0xae200c50
    WRITE32(ADD32(GPR_U32(ctx, 17), 3152), GPR_U32(ctx, 0));
    // 0x1e5f00: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1e5f04: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e5f08: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1e5f0c: 0x10000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3148), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e5f30;
    }
label_1e5f14:
    // 0x1e5f14: 0x3c01427a
    SET_GPR_U32(ctx, 1, ((uint32_t)17018 << 16));
    // 0x1e5f18: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e5f1c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e5f20: 0xe6200c50
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3152), *(uint32_t*)&val); }
    // 0x1e5f24: 0xe6210c4c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 3148), *(uint32_t*)&val); }
    // 0x1e5f28: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1e5f2c: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
label_1e5f30:
    // 0x1e5f30: 0x3c013c8f
    SET_GPR_U32(ctx, 1, ((uint32_t)15503 << 16));
    // 0x1e5f34: 0x3421b824
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47140));
    // 0x1e5f38: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x1e5f3c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e5f40: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e5f44: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x1e5f48: 0x3c143000
    SET_GPR_U32(ctx, 20, ((uint32_t)12288 << 16));
    // 0x1e5f4c: 0x4480b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 0);
    // 0x1e5f50: 0x2413001a
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 26));
    // 0x1e5f54: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x1e5f58: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1e5f5c: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1e5f60: 0x26300254
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 596));
    // 0x1e5f64: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x1e5f68: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1e5f6c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1e5f70: 0x3c013ecc
    SET_GPR_U32(ctx, 1, ((uint32_t)16076 << 16));
    // 0x1e5f74: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e5f78: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1e5f7c: 0x0
    // NOP
label_1e5f80:
    // 0x1e5f80: 0x44920000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 18);
    // 0x1e5f84: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e5f88: 0x461a0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[26]);
    // 0x1e5f8c: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x1e5f90: 0x46180001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[24]);
    // 0x1e5f94: 0x46000042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x1e5f98: 0xe6000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1e5f9c: 0x4601c041
    ctx->f[1] = FPU_SUB_S(ctx->f[24], ctx->f[1]);
    // 0x1e5fa0: 0x46010004
    ctx->f[0] = FPU_SQRT_S(ctx->f[0]);
    // 0x1e5fa4: 0x4600c802
    ctx->f[0] = FPU_MUL_S(ctx->f[25], ctx->f[0]);
    // 0x1e5fa8: 0x3c023080
    SET_GPR_U32(ctx, 2, ((uint32_t)12416 << 16));
    // 0x1e5fac: 0x32430001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 18), 1));
    // 0x1e5fb0: 0x34428080
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32896));
    // 0x1e5fb4: 0x283100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 20));
    // 0x1e5fb8: 0xe6170048
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 16), 72), *(uint32_t*)&val); }
    // 0x1e5fbc: 0xe600002c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 44), *(uint32_t*)&val); }
    // 0x1e5fc0: 0xae02003c
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 2));
    // 0x1e5fc4: 0xae020040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 2));
    // 0x1e5fc8: 0xe6170044
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x1e5fcc: 0x8e220214
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 532)));
    // 0x1e5fd0: 0x14530014
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 19)) {
        ctx->pc = 0x1E6024; return;
    }
    // 0x1e5fd8: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1e5fdc: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e5fe0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e5fe4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e5fec);
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e5fec
// Address: 0x1e5fec - 0x1e6004

void entry_1e5fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e5fec: 0x3c013ecc
    SET_GPR_U32(ctx, 1, ((uint32_t)16076 << 16));
    // 0x1e5ff0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e5ff4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e5ff8: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x1e5ffc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e6004);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 76), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e6004
// Address: 0x1e6004 - 0x1e602c

void entry_1e6004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e6004) {
        switch (ctx->pc) {
            case 0x1e6024: ctx->pc = 0; goto label_1e6024;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e6004: 0x3c013d4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15692 << 16));
    // 0x1e6008: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e600c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e6010: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1e6014: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e6018: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e601c: 0x1000000d
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E6054; return;
    }
label_1e6024:
    // 0x1e6024: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e602c);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e602c
// Address: 0x1e602c - 0x1e6044

void entry_1e602c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e602c: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1e6030: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e6034: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e6038: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1e603c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e6044);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 76), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e6044
// Address: 0x1e6044 - 0x1e605c

void entry_1e6044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e6044) {
        switch (ctx->pc) {
            case 0x1e6054: ctx->pc = 0; goto label_1e6054;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e6044: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1e6048: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e604c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e6050: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
label_1e6054:
    // 0x1e6054: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e605c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 80), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e605c
// Address: 0x1e605c - 0x1e60b4

void entry_1e605c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e605c) {
        switch (ctx->pc) {
            case 0x1e6074: ctx->pc = 0; goto label_1e6074;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e605c: 0x12400005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 84), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1e6074;
    }
    // 0x1e6064: 0xc6000034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1e6068: 0xc601002c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 44)); ctx->f[1] = *(float*)&val; }
    // 0x1e606c: 0xe600000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x1e6070: 0xe6010004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
label_1e6074:
    // 0x1e6074: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1e6078: 0x2a420039
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 57));
    // 0x1e607c: 0x1440ffc0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 44));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E5F80; return;
    }
    // 0x1e6084: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e6088: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e608c: 0x2403001a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 26));
    // 0x1e6090: 0x8e220214
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 532)));
    // 0x1e6094: 0xe62c0c2c
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 17), 3116), *(uint32_t*)&val); }
    // 0x1e6098: 0x14430016
    WRITE32(ADD32(GPR_U32(ctx, 17), 3108), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1E60F4; return;
    }
    // 0x1e60a0: 0x3c013fb3
    SET_GPR_U32(ctx, 1, ((uint32_t)16307 << 16));
    // 0x1e60a4: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1e60a8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e60ac: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e60b4);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e60b4
// Address: 0x1e60b4 - 0x1e60d4

void entry_1e60b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e60b4: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x1e60b8: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1e60bc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e60c0: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1e60c4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e60c8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e60cc: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e60d4);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3172), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e60d4
// Address: 0x1e60d4 - 0x1e611c

void entry_1e60d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e60d4) {
        switch (ctx->pc) {
            case 0x1e60f4: ctx->pc = 0; goto label_1e60f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e60d4: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1e60d8: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e60dc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e60e0: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1e60e4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e60e8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e60ec: 0x10000014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3176), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E6140; return;
    }
label_1e60f4:
    // 0x1e60f4: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1e60f8: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1e60fc: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1e6100: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1e6104: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e6108: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x1e610c: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1e6110: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1e6114: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e611c);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e611c
// Address: 0x1e611c - 0x1e6134

void entry_1e611c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e611c: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1e6120: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e6124: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e6128: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1e612c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e6134);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3172), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e6134
// Address: 0x1e6134 - 0x1e6148

void entry_1e6134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e6134) {
        switch (ctx->pc) {
            case 0x1e6140: ctx->pc = 0; goto label_1e6140;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e6134: 0xe6200c68
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3176), *(uint32_t*)&val); }
    // 0x1e6138: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1e613c: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
label_1e6140:
    // 0x1e6140: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e6148);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e6148
// Address: 0x1e6148 - 0x1e6188

void entry_1e6148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6148: 0xe6200c6c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3180), *(uint32_t*)&val); }
    // 0x1e614c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e6150: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e6154: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e6158: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e615c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e6160: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e6164: 0xc7ba0090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[26] = *(float*)&val; }
    // 0x1e6168: 0xc7b90088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[25] = *(float*)&val; }
    // 0x1e616c: 0xc7b80080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[24] = *(float*)&val; }
    // 0x1e6170: 0xc7b70078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[23] = *(float*)&val; }
    // 0x1e6174: 0xc7b60070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[22] = *(float*)&val; }
    // 0x1e6178: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x1e617c: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1e6180: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostTvLoad__FP2TV
// Address: 0x1e6188 - 0x1e619c

void entry_1e619c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e619c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e61a0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e61a4: 0x8c455710
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1e61a8: 0x24070201
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 513));
    // 0x1e61ac: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e61b0: 0xc047960
    SET_GPR_U32(ctx, 31, 0x1e61b8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 81));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1e61b8
// Address: 0x1e61b8 - 0x1e61c8

void entry_1e61b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e61b8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e61bc: 0xae02027c
    WRITE32(ADD32(GPR_U32(ctx, 16), 636), GPR_U32(ctx, 2));
    // 0x1e61c0: 0xc0611da
    SET_GPR_U32(ctx, 31, 0x1e61c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetLightKind__FP5LIGHT6LIGHTK(rdram, ctx, runtime); return;
}


// Function: entry_1e61c8
// Address: 0x1e61c8 - 0x1e61d8

void entry_1e61c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e61c8: 0x8e04027c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 636)));
    // 0x1e61cc: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1e61d0: 0xc0611fc
    SET_GPR_U32(ctx, 31, 0x1e61d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 22080));
    SetLightHighlightColor__FP5LIGHTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1e61d8
// Address: 0x1e61d8 - 0x1e61e8

void entry_1e61d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e61d8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e61dc: 0x8e04027c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 636)));
    // 0x1e61e0: 0xc061216
    SET_GPR_U32(ctx, 31, 0x1e61e8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22096)); ctx->f[12] = *(float*)&val; }
    SetLightHighlightAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1e61e8
// Address: 0x1e61e8 - 0x1e61f8

void entry_1e61e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e61e8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e61ec: 0x8e04027c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 636)));
    // 0x1e61f0: 0xc061206
    SET_GPR_U32(ctx, 31, 0x1e61f8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22100)); ctx->f[12] = *(float*)&val; }
    SetLightMidtoneStrength__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1e61f8
// Address: 0x1e61f8 - 0x1e6208

void entry_1e61f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e61f8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e61fc: 0x8e04027c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 636)));
    // 0x1e6200: 0xc06121e
    SET_GPR_U32(ctx, 31, 0x1e6208);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22104)); ctx->f[12] = *(float*)&val; }
    SetLightMidtoneAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1e6208
// Address: 0x1e6208 - 0x1e6218

void entry_1e6208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6208: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e620c: 0x8e04027c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 636)));
    // 0x1e6210: 0xc06120e
    SET_GPR_U32(ctx, 31, 0x1e6218);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22108)); ctx->f[12] = *(float*)&val; }
    SetLightShadowStrength__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1e6218
// Address: 0x1e6218 - 0x1e6228

void entry_1e6218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6218: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e621c: 0x8e04027c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 636)));
    // 0x1e6220: 0xc061226
    SET_GPR_U32(ctx, 31, 0x1e6228);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 22112)); ctx->f[12] = *(float*)&val; }
    SetLightShadowAngle__FP5LIGHTf(rdram, ctx, runtime); return;
}


// Function: entry_1e6228
// Address: 0x1e6228 - 0x1e6238

void entry_1e6228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6228: 0x8e04027c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 636)));
    // 0x1e622c: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1e6230: 0xc061264
    SET_GPR_U32(ctx, 31, 0x1e6238);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 23384));
    SetLightFallOff__FP5LIGHTP2LM(rdram, ctx, runtime); return;
}


// Function: entry_1e6238
// Address: 0x1e6238 - 0x1e6244

void entry_1e6238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6238: 0x8e04027c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 636)));
    // 0x1e623c: 0xc06125a
    SET_GPR_U32(ctx, 31, 0x1e6244);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetLightDynamic__FP5LIGHTi(rdram, ctx, runtime); return;
}


// Function: entry_1e6244
// Address: 0x1e6244 - 0x1e6258

void entry_1e6244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6244: 0x8e04027c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 636)));
    // 0x1e6248: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e624c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1e6250: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e6258);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e6258
// Address: 0x1e6258 - 0x1e6268

void entry_1e6258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6258: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e625c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e6260: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetTvItvbMinMax__FP2TVPiT1
// Address: 0x1e6268 - 0x1e62a8

void entry_1e6374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6374: 0xc6600238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 568)); ctx->f[0] = *(float*)&val; }
    // 0x1e6378: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e637c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e6380: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e6384: 0x4600a000
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1e6388: 0x46190002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[25]);
    // 0x1e638c: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x1e6390: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1e6394: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6398: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1e639c: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x1e63a4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e63a4
// Address: 0x1e63a4 - 0x1e63d0

void entry_1e63a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e63a4: 0xc6600234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 564)); ctx->f[0] = *(float*)&val; }
    // 0x1e63a8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e63ac: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e63b0: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e63b4: 0x4600a800
    ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    // 0x1e63b8: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x1e63bc: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1e63c0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e63c4: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1e63c8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e63d0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e63d0
// Address: 0x1e63d0 - 0x1e6414

void entry_1e63d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e63d0: 0xc6600238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 568)); ctx->f[0] = *(float*)&val; }
    // 0x1e63d4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e63d8: 0xc6610234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 564)); ctx->f[1] = *(float*)&val; }
    // 0x1e63dc: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e63e0: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1e63e4: 0x4601ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[1]);
    // 0x1e63e8: 0x4619a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[25]);
    // 0x1e63ec: 0x4617ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[23]);
    // 0x1e63f0: 0x4618a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[24]);
    // 0x1e63f4: 0x4616ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[22]);
    // 0x1e63f8: 0x4616a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[22]);
    // 0x1e63fc: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x1e6400: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x1e6404: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1e6408: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1e640c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e6414);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e6414
// Address: 0x1e6414 - 0x1e642c

void entry_1e6414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e6414) {
        switch (ctx->pc) {
            case 0x1e641c: ctx->pc = 0; goto label_1e641c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e6414: 0x10000068
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E65B8; return;
    }
label_1e641c:
    // 0x1e641c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e6420: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e6424: 0xc07989a
    SET_GPR_U32(ctx, 31, 0x1e642c);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 29), 4));
    GetTvItvbMinMax__FP2TVPiT1(rdram, ctx, runtime); return;
}


// Function: entry_1e642c
// Address: 0x1e642c - 0x1e64e8

void entry_1e642c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e642c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e6430: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1e6434: 0x1062005f
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 44));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E65B4; return;
    }
    // 0x1e643c: 0x3c01427a
    SET_GPR_U32(ctx, 1, ((uint32_t)17018 << 16));
    // 0x1e6440: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e6444: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1e6448: 0x761818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1e644c: 0xc6600220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 544)); ctx->f[0] = *(float*)&val; }
    // 0x1e6450: 0xc664021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 540)); ctx->f[4] = *(float*)&val; }
    // 0x1e6454: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e6458: 0x46160640
    ctx->f[25] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x1e645c: 0xc6610c50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 3152)); ctx->f[1] = *(float*)&val; }
    // 0x1e6460: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1e6464: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1e6468: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x1e646c: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e6470: 0x2631021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 3)));
    // 0x1e6474: 0x46012040
    ctx->f[1] = FPU_ADD_S(ctx->f[4], ctx->f[1]);
    // 0x1e6478: 0xc4400288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 648)); ctx->f[0] = *(float*)&val; }
    // 0x1e647c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e6480: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1e6484: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x1e6488: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e648c: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1e6490: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1e6494: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x1e6498: 0x46180840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[24]);
    // 0x1e649c: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1e64a0: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1e64a4: 0xc6620c4c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 3148)); ctx->f[2] = *(float*)&val; }
    // 0x1e64a8: 0x4600c800
    ctx->f[0] = FPU_ADD_S(ctx->f[25], ctx->f[0]);
    // 0x1e64ac: 0xc4630280
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 640)); ctx->f[3] = *(float*)&val; }
    // 0x1e64b0: 0x46150842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
    // 0x1e64b4: 0x460225c0
    ctx->f[23] = FPU_ADD_S(ctx->f[4], ctx->f[2]);
    // 0x1e64b8: 0x461a0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[26]);
    // 0x1e64bc: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e64c0: 0x44111000
    SET_GPR_U32(ctx, 17, *(uint32_t*)&ctx->f[2]);
    // 0x1e64c4: 0x461618c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[22]);
    // 0x1e64c8: 0x461c0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[28]);
    // 0x1e64cc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e64d0: 0x4603bd00
    ctx->f[20] = FPU_ADD_S(ctx->f[23], ctx->f[3]);
    // 0x1e64d4: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1e64d8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e64dc: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x1e64e0: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x1e64e8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e64e8
// Address: 0x1e64e8 - 0x1e650c

void entry_1e64e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e64e8: 0x4618a000
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[24]);
    // 0x1e64ec: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e64f0: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e64f4: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e64f8: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1e64fc: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6500: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1e6504: 0xc05859c
    SET_GPR_U32(ctx, 31, 0x1e650c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZFNoKick__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e650c
// Address: 0x1e650c - 0x1e6580

void entry_1e650c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e650c) {
        switch (ctx->pc) {
            case 0x1e6538: ctx->pc = 0; goto label_1e6538;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e650c: 0x8fb20000
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e6510: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1e6514: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1e6518: 0x10400026
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E65B4; return;
    }
    // 0x1e6520: 0x4600c6c6
    ctx->f[27] = FPU_MOV_S(ctx->f[24]);
    // 0x1e6524: 0x220b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e6528: 0x4600e606
    ctx->f[24] = FPU_MOV_S(ctx->f[28]);
    // 0x1e652c: 0x24420280
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 640));
    // 0x1e6530: 0x538821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1e6534: 0xc620000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[0] = *(float*)&val; }
label_1e6538:
    // 0x1e6538: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e653c: 0xc6210004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1e6540: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1e6544: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1e6548: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e654c: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
    // 0x1e6550: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e6554: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1e6558: 0x2631002c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 44));
    // 0x1e655c: 0x4600c800
    ctx->f[0] = FPU_ADD_S(ctx->f[25], ctx->f[0]);
    // 0x1e6560: 0x4601bd00
    ctx->f[20] = FPU_ADD_S(ctx->f[23], ctx->f[1]);
    // 0x1e6564: 0x461a0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[26]);
    // 0x1e6568: 0x46180000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[24]);
    // 0x1e656c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1e6570: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6574: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x1e6578: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e6580);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e6580
// Address: 0x1e6580 - 0x1e65a4

void entry_1e6580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6580: 0x461ba000
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[27]);
    // 0x1e6584: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e6588: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e658c: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1e6590: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1e6594: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6598: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1e659c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e65a4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e65a4
// Address: 0x1e65a4 - 0x1e6600

void entry_1e65a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e65a4) {
        switch (ctx->pc) {
            case 0x1e65b4: ctx->pc = 0; goto label_1e65b4;
            case 0x1e65b8: ctx->pc = 0; goto label_1e65b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e65a4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1e65a8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1e65ac: 0x5440ffe2
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 12)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1E6538; return;
    }
label_1e65b4:
    // 0x1e65b4: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1e65b8:
    // 0x1e65b8: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e65bc: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e65c0: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e65c4: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e65c8: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e65cc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e65d0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e65d4: 0xc7bc00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[28] = *(float*)&val; }
    // 0x1e65d8: 0xc7bb00c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[27] = *(float*)&val; }
    // 0x1e65dc: 0xc7ba00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[26] = *(float*)&val; }
    // 0x1e65e0: 0xc7b900b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[25] = *(float*)&val; }
    // 0x1e65e4: 0xc7b800b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[24] = *(float*)&val; }
    // 0x1e65e8: 0xc7b700a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[23] = *(float*)&val; }
    // 0x1e65ec: 0xc7b600a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[22] = *(float*)&val; }
    // 0x1e65f0: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1e65f4: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1e65f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawTvBands__FP2TVR4GIFS
// Address: 0x1e6600 - 0x1e6660

void entry_1e6660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6660: 0x8fa30040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e6664: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1e6668: 0x10620158
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 68));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E6BCC; return;
    }
    // 0x1e6670: 0xc682021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 540)); ctx->f[2] = *(float*)&val; }
    // 0x1e6674: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e6678: 0xc6810c4c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 3148)); ctx->f[1] = *(float*)&val; }
    // 0x1e667c: 0xc6830220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 544)); ctx->f[3] = *(float*)&val; }
    // 0x1e6680: 0x24060005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1e6684: 0x46011040
    ctx->f[1] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1e6688: 0x3c01427a
    SET_GPR_U32(ctx, 1, ((uint32_t)17018 << 16));
    // 0x1e668c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e6690: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1e6694: 0x3c070004
    SET_GPR_U32(ctx, 7, ((uint32_t)4 << 16));
    // 0x1e6698: 0x34e74441
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 17473));
    // 0x1e669c: 0x46151fc0
    ctx->f[31] = FPU_ADD_S(ctx->f[3], ctx->f[21]);
    // 0x1e66a0: 0xe7a10048
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 72), *(uint32_t*)&val); }
    // 0x1e66a4: 0xc6800c50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 3152)); ctx->f[0] = *(float*)&val; }
    // 0x1e66a8: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e66b0);
    ctx->f[30] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e66b0
// Address: 0x1e66b0 - 0x1e6964

void entry_1e66b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e66b0) {
        switch (ctx->pc) {
            case 0x1e66f8: ctx->pc = 0; goto label_1e66f8;
            case 0x1e6778: ctx->pc = 0; goto label_1e6778;
            case 0x1e67b0: ctx->pc = 0; goto label_1e67b0;
            case 0x1e67d8: ctx->pc = 0; goto label_1e67d8;
            case 0x1e67f0: ctx->pc = 0; goto label_1e67f0;
            case 0x1e6828: ctx->pc = 0; goto label_1e6828;
            case 0x1e6850: ctx->pc = 0; goto label_1e6850;
            case 0x1e6868: ctx->pc = 0; goto label_1e6868;
            case 0x1e68a0: ctx->pc = 0; goto label_1e68a0;
            case 0x1e68c8: ctx->pc = 0; goto label_1e68c8;
            case 0x1e68e0: ctx->pc = 0; goto label_1e68e0;
            case 0x1e6918: ctx->pc = 0; goto label_1e6918;
            case 0x1e6940: ctx->pc = 0; goto label_1e6940;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e66b0: 0x8fb30040
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e66b4: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1e66b8: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1e66bc: 0x104000e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E6A40; return;
    }
    // 0x1e66c4: 0x4600adc6
    ctx->f[23] = FPU_MOV_S(ctx->f[21]);
    // 0x1e66c8: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1e66cc: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1e66d0: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1e66d4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e66d8: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1e66dc: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1e66e0: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x1e66e4: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1e66e8: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1e66ec: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1e66f0: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x1e66f4: 0x2402002c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 44));
label_1e66f8:
    // 0x1e66f8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e66fc: 0x2621018
    { int64_t result = (int64_t)GPR_S32(ctx, 19) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1e6700: 0x24420280
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 640));
    // 0x1e6704: 0x2821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x1e6708: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1e670c: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1e6710: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1e6714: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x1e6718: 0xc443000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[3] = *(float*)&val; }
    // 0x1e671c: 0x46170842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[23]);
    // 0x1e6720: 0xc4440018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[4] = *(float*)&val; }
    // 0x1e6724: 0x46171082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[23]);
    // 0x1e6728: 0x88440017
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 23); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x1e672c: 0x98440014
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 20); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x1e6730: 0xaba40013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e6734: 0xbba40010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e6738: 0x461718c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[23]);
    // 0x1e673c: 0x24665b50
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 23376));
    // 0x1e6740: 0x88c20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1e6744: 0x98c20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1e6748: 0xaba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e674c: 0xbba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e6750: 0x4602fe00
    ctx->f[24] = FPU_ADD_S(ctx->f[31], ctx->f[2]);
    // 0x1e6754: 0xc7a50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[5] = *(float*)&val; }
    // 0x1e6758: 0x4603fe80
    ctx->f[26] = FPU_ADD_S(ctx->f[31], ctx->f[3]);
    // 0x1e675c: 0x93a40010
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e6760: 0x93a30020
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e6764: 0x46002e40
    ctx->f[25] = FPU_ADD_S(ctx->f[5], ctx->f[0]);
    // 0x1e6768: 0x14830003
    ctx->f[27] = FPU_ADD_S(ctx->f[5], ctx->f[1]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1e6778;
    }
    // 0x1e6770: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e67d8;
    }
label_1e6778:
    // 0x1e6778: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1e677c: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[22], ctx->f[4]);
        goto label_1e67b0;
    }
    // 0x1e6784: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e6788: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e678c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1e6790: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1e6794: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1e6798: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1e679c: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1e67a0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e67a4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e67a8: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e67d8;
    }
label_1e67b0:
    // 0x1e67b0: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1e67b4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e67b8: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x1e67bc: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1e67c0: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1e67c4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e67c8: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1e67cc: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e67d0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e67d4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1e67d8:
    // 0x1e67d8: 0x93a40011
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 17)));
    // 0x1e67dc: 0x93a30021
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 33)));
    // 0x1e67e0: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 48), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1e67f0;
    }
    // 0x1e67e8: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6850;
    }
label_1e67f0:
    // 0x1e67f0: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1e67f4: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[22], ctx->f[4]);
        goto label_1e6828;
    }
    // 0x1e67fc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e6800: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e6804: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1e6808: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1e680c: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1e6810: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1e6814: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1e6818: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e681c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6820: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6850;
    }
label_1e6828:
    // 0x1e6828: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1e682c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e6830: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x1e6834: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1e6838: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1e683c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e6840: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1e6844: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e6848: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e684c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1e6850:
    // 0x1e6850: 0x93a40012
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 18)));
    // 0x1e6854: 0x93a30022
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 34)));
    // 0x1e6858: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 49), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1e6868;
    }
    // 0x1e6860: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e68c8;
    }
label_1e6868:
    // 0x1e6868: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1e686c: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[22], ctx->f[4]);
        goto label_1e68a0;
    }
    // 0x1e6874: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e6878: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e687c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1e6880: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1e6884: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1e6888: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1e688c: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1e6890: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6894: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6898: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e68c8;
    }
label_1e68a0:
    // 0x1e68a0: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1e68a4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e68a8: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x1e68ac: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1e68b0: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1e68b4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e68b8: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1e68bc: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e68c0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e68c4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1e68c8:
    // 0x1e68c8: 0x93a40013
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 19)));
    // 0x1e68cc: 0x93a30023
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 35)));
    // 0x1e68d0: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 50), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1e68e0;
    }
    // 0x1e68d8: 0x10000019
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6940;
    }
label_1e68e0:
    // 0x1e68e0: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1e68e4: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[22], ctx->f[4]);
        goto label_1e6918;
    }
    // 0x1e68ec: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e68f0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e68f4: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1e68f8: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1e68fc: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1e6900: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1e6904: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1e6908: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e690c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6910: 0x1000000b
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6940;
    }
label_1e6918:
    // 0x1e6918: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1e691c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e6920: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x1e6924: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1e6928: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x1e692c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e6930: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1e6934: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e6938: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e693c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1e6940:
    // 0x1e6940: 0xa3a20033
    WRITE8(ADD32(GPR_U32(ctx, 29), 51), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e6944: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e6948: 0x8ba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1e694c: 0x9ba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1e6950: 0xaba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e6954: 0xbba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e6958: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1e695c: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1e6964);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1e6964
// Address: 0x1e6964 - 0x1e69ac

void entry_1e6964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6964: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1e6968: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1e696c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e6970: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e6974: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e6978: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e697c: 0x4601c002
    ctx->f[0] = FPU_MUL_S(ctx->f[24], ctx->f[1]);
    // 0x1e6980: 0x461cf040
    ctx->f[1] = FPU_ADD_S(ctx->f[30], ctx->f[28]);
    // 0x1e6984: 0x461d0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[29]);
    // 0x1e6988: 0x46150842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
    // 0x1e698c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1e6990: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e6994: 0x44111000
    SET_GPR_U32(ctx, 17, *(uint32_t*)&ctx->f[2]);
    // 0x1e6998: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e699c: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x1e69a0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e69a4: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e69ac);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e69ac
// Address: 0x1e69ac - 0x1e69d0

void entry_1e69ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e69ac: 0x461cc800
    ctx->f[0] = FPU_ADD_S(ctx->f[25], ctx->f[28]);
    // 0x1e69b0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e69b4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e69b8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e69bc: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1e69c0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e69c4: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1e69c8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e69d0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e69d0
// Address: 0x1e69d0 - 0x1e6a08

void entry_1e69d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e69d0: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1e69d4: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1e69d8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e69dc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e69e0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e69e4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e69e8: 0x4602d002
    ctx->f[0] = FPU_MUL_S(ctx->f[26], ctx->f[2]);
    // 0x1e69ec: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e69f0: 0x461d0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[29]);
    // 0x1e69f4: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1e69f8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e69fc: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x1e6a00: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e6a08);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e6a08
// Address: 0x1e6a08 - 0x1e6a2c

void entry_1e6a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6a08: 0x461cd800
    ctx->f[0] = FPU_ADD_S(ctx->f[27], ctx->f[28]);
    // 0x1e6a0c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e6a10: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e6a14: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e6a18: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1e6a1c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6a20: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1e6a24: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e6a2c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e6a2c
// Address: 0x1e6a2c - 0x1e6a50

void entry_1e6a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e6a2c) {
        switch (ctx->pc) {
            case 0x1e6a40: ctx->pc = 0; goto label_1e6a40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e6a2c: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1e6a30: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1e6a34: 0x1440ff30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 44));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E66F8; return;
    }
    // 0x1e6a3c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
label_1e6a40:
    // 0x1e6a40: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e6a44: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e6a48: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e6a50);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e6a50
// Address: 0x1e6a50 - 0x1e6a5c

void entry_1e6a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6a50: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x1e6a54: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1e6a5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1e6a5c
// Address: 0x1e6a5c - 0x1e6a70

void entry_1e6a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6a5c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e6a60: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e6a64: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e6a68: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e6a70);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e6a70
// Address: 0x1e6a70 - 0x1e6b68

void entry_1e6a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e6a70) {
        switch (ctx->pc) {
            case 0x1e6a98: ctx->pc = 0; goto label_1e6a98;
            case 0x1e6af8: ctx->pc = 0; goto label_1e6af8;
            case 0x1e6afc: ctx->pc = 0; goto label_1e6afc;
            case 0x1e6b10: ctx->pc = 0; goto label_1e6b10;
            case 0x1e6b60: ctx->pc = 0; goto label_1e6b60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e6a70: 0x8fa40040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e6a74: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1e6a78: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1e6a7c: 0x10400053
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 44));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E6BCC; return;
    }
    // 0x1e6a84: 0x3c01427a
    SET_GPR_U32(ctx, 1, ((uint32_t)17018 << 16));
    // 0x1e6a88: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e6a8c: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x1e6a90: 0x931018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1e6a94: 0x0
    // NOP
label_1e6a98:
    // 0x1e6a98: 0x3c01407f
    SET_GPR_U32(ctx, 1, ((uint32_t)16511 << 16));
    // 0x1e6a9c: 0x3421ef9e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 61342));
    // 0x1e6aa0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e6aa4: 0x24420280
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 640));
    // 0x1e6aa8: 0x2821821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x1e6aac: 0xc4600018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1e6ab0: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1e6ab4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6ab8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6abc: 0x24420002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 2));
    // 0x1e6ac0: 0x1040003d
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E6BB8; return;
    }
    // 0x1e6ac8: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1e6acc: 0xc7a20048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[2] = *(float*)&val; }
    // 0x1e6ad0: 0x461c0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[28]);
    // 0x1e6ad4: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1e6ad8: 0x461c0842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[28]);
    // 0x1e6adc: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1e6ae0: 0x4600f034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[30], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e6ae4: 0x0
    // NOP
    // 0x1e6ae8: 0x45000003
    ctx->f[13] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e6af8;
    }
    // 0x1e6af0: 0x10000002
    ctx->f[25] = std::min(ctx->f[13], ctx->f[30]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6afc;
    }
label_1e6af8:
    // 0x1e6af8: 0x46006e69
    ctx->f[25] = std::min(ctx->f[13], ctx->f[0]);
label_1e6afc:
    // 0x1e6afc: 0x461e0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[30])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e6b00: 0x0
    // NOP
    // 0x1e6b04: 0x45020002
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[22] = std::max(ctx->f[13], ctx->f[0]);
        goto label_1e6b10;
    }
    // 0x1e6b0c: 0x461e6da8
    ctx->f[22] = std::max(ctx->f[13], ctx->f[30]);
label_1e6b10:
    // 0x1e6b10: 0xc461000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 12)); ctx->f[1] = *(float*)&val; }
    // 0x1e6b14: 0x24910001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1e6b18: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1e6b1c: 0x461c0842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[28]);
    // 0x1e6b20: 0x461c0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[28]);
    // 0x1e6b24: 0x4601fe00
    ctx->f[24] = FPU_ADD_S(ctx->f[31], ctx->f[1]);
    // 0x1e6b28: 0x18400023
    ctx->f[23] = FPU_ADD_S(ctx->f[31], ctx->f[0]);
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E6BB8; return;
    }
    // 0x1e6b30: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1e6b34: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x1e6b38: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e6b3c: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1e6b40: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1e6b44: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1e6b48: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1e6b4c: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x1e6b50: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1e6b54: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x1e6b58: 0x4600cb06
    ctx->f[12] = FPU_MOV_S(ctx->f[25]);
    // 0x1e6b5c: 0x0
    // NOP
label_1e6b60:
    // 0x1e6b60: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e6b68);
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e6b68
// Address: 0x1e6b68 - 0x1e6b7c

void entry_1e6b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6b68: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x1e6b6c: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1e6b70: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x1e6b74: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e6b7c);
    ctx->f[13] = FPU_MOV_S(ctx->f[24]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e6b7c
// Address: 0x1e6b7c - 0x1e6bb0

void entry_1e6b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e6b7c: 0x461b0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[27]);
    // 0x1e6b80: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e6b84: 0x461da500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[29]);
    // 0x1e6b88: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e6b8c: 0x461a0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[26]);
    // 0x1e6b90: 0x4615a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[21]);
    // 0x1e6b94: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1e6b98: 0x4600a064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1e6b9c: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1e6ba0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6ba4: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1e6ba8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e6bb0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e6bb0
// Address: 0x1e6bb0 - 0x1e6c20

void entry_1e6bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e6bb0) {
        switch (ctx->pc) {
            case 0x1e6bb8: ctx->pc = 0; goto label_1e6bb8;
            case 0x1e6bcc: ctx->pc = 0; goto label_1e6bcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e6bb0: 0x1600ffeb
    ctx->f[12] = FPU_MOV_S(ctx->f[25]);
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E6B60; return;
    }
label_1e6bb8:
    // 0x1e6bb8: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1e6bbc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e6bc0: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1e6bc4: 0x1440ffb4
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E6A98; return;
    }
label_1e6bcc:
    // 0x1e6bcc: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e6bd0: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1e6bd4: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e6bd8: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e6bdc: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e6be0: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e6be4: 0xc7bf0108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[31] = *(float*)&val; }
    // 0x1e6be8: 0xc7be0100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[30] = *(float*)&val; }
    // 0x1e6bec: 0xc7bd00f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[29] = *(float*)&val; }
    // 0x1e6bf0: 0xc7bc00f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[28] = *(float*)&val; }
    // 0x1e6bf4: 0xc7bb00e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[27] = *(float*)&val; }
    // 0x1e6bf8: 0xc7ba00e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[26] = *(float*)&val; }
    // 0x1e6bfc: 0xc7b900d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[25] = *(float*)&val; }
    // 0x1e6c00: 0xc7b800d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[24] = *(float*)&val; }
    // 0x1e6c04: 0xc7b700c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[23] = *(float*)&val; }
    // 0x1e6c08: 0xc7b600c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[22] = *(float*)&val; }
    // 0x1e6c0c: 0xc7b500b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[21] = *(float*)&val; }
    // 0x1e6c10: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1e6c14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e6c1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e6c20; return;
}


// Function: DrawTvOutline__FP2TVR4GIFS
// Address: 0x1e6c20 - 0x1e6d48

void entry_1e6d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e6d48) {
        switch (ctx->pc) {
            case 0x1e6d90: ctx->pc = 0; goto label_1e6d90;
            case 0x1e6dd0: ctx->pc = 0; goto label_1e6dd0;
            case 0x1e6e10: ctx->pc = 0; goto label_1e6e10;
            case 0x1e6e28: ctx->pc = 0; goto label_1e6e28;
            case 0x1e6e6c: ctx->pc = 0; goto label_1e6e6c;
            case 0x1e6eac: ctx->pc = 0; goto label_1e6eac;
            case 0x1e6ec4: ctx->pc = 0; goto label_1e6ec4;
            case 0x1e6f08: ctx->pc = 0; goto label_1e6f08;
            case 0x1e6f48: ctx->pc = 0; goto label_1e6f48;
            case 0x1e6f60: ctx->pc = 0; goto label_1e6f60;
            case 0x1e6fa4: ctx->pc = 0; goto label_1e6fa4;
            case 0x1e6fe4: ctx->pc = 0; goto label_1e6fe4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e6d48: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e6d4c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1e6d50: 0x244710d8
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 4312));
    // 0x1e6d54: 0x88e40003
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x1e6d58: 0x98e40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x1e6d5c: 0xaba40013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e6d60: 0xbba40010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e6d64: 0x246610e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 4320));
    // 0x1e6d68: 0x88c20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1e6d6c: 0x98c20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1e6d70: 0xaba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e6d74: 0xbba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e6d78: 0x93a40010
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e6d7c: 0x93a30020
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e6d80: 0x14830003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1e6d90;
    }
    // 0x1e6d88: 0x10000021
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6e10;
    }
label_1e6d90:
    // 0x1e6d90: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e6dd0;
    }
    // 0x1e6d98: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e6d9c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e6da0: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1e6da4: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1e6da8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e6dac: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1e6db0: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1e6db4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1e6db8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e6dbc: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1e6dc0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6dc4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6dc8: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6e10;
    }
label_1e6dd0:
    // 0x1e6dd0: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1e6dd4: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1e6dd8: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1e6ddc: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1e6de0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e6de4: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1e6de8: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1e6dec: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e6df0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e6df4: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1e6df8: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1e6dfc: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1e6e00: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1e6e04: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6e08: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6e0c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1e6e10:
    // 0x1e6e10: 0x93a40011
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 17)));
    // 0x1e6e14: 0x93a30021
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 33)));
    // 0x1e6e18: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 48), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1e6e28;
    }
    // 0x1e6e20: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6eac;
    }
label_1e6e28:
    // 0x1e6e28: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1e6e2c: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e6e6c;
    }
    // 0x1e6e34: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e6e38: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e6e3c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1e6e40: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1e6e44: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e6e48: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1e6e4c: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1e6e50: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1e6e54: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e6e58: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1e6e5c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6e60: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6e64: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6eac;
    }
label_1e6e6c:
    // 0x1e6e6c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1e6e70: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1e6e74: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1e6e78: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1e6e7c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e6e80: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1e6e84: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1e6e88: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e6e8c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e6e90: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1e6e94: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1e6e98: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1e6e9c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1e6ea0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6ea4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6ea8: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1e6eac:
    // 0x1e6eac: 0x93a40012
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 18)));
    // 0x1e6eb0: 0x93a30022
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 34)));
    // 0x1e6eb4: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 49), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1e6ec4;
    }
    // 0x1e6ebc: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6f48;
    }
label_1e6ec4:
    // 0x1e6ec4: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1e6ec8: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e6f08;
    }
    // 0x1e6ed0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e6ed4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e6ed8: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1e6edc: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1e6ee0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e6ee4: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1e6ee8: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1e6eec: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1e6ef0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e6ef4: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1e6ef8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6efc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6f00: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6f48;
    }
label_1e6f08:
    // 0x1e6f08: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1e6f0c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1e6f10: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1e6f14: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1e6f18: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e6f1c: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1e6f20: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1e6f24: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e6f28: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e6f2c: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1e6f30: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1e6f34: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1e6f38: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1e6f3c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6f40: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6f44: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1e6f48:
    // 0x1e6f48: 0x93a40013
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 19)));
    // 0x1e6f4c: 0x93a30023
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 35)));
    // 0x1e6f50: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 50), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1e6f60;
    }
    // 0x1e6f58: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6fe4;
    }
label_1e6f60:
    // 0x1e6f60: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1e6f64: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e6fa4;
    }
    // 0x1e6f6c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1e6f70: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1e6f74: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1e6f78: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1e6f7c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e6f80: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1e6f84: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1e6f88: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1e6f8c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e6f90: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1e6f94: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6f98: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6f9c: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e6fe4;
    }
label_1e6fa4:
    // 0x1e6fa4: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1e6fa8: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1e6fac: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1e6fb0: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1e6fb4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e6fb8: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1e6fbc: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1e6fc0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e6fc4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e6fc8: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1e6fcc: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1e6fd0: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1e6fd4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1e6fd8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e6fdc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1e6fe0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1e6fe4:
    // 0x1e6fe4: 0xa3a20033
    WRITE8(ADD32(GPR_U32(ctx, 29), 51), (uint8_t)GPR_U32(ctx, 2));
    // 0x1e6fe8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e6fec: 0x8ba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1e6ff0: 0x9ba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1e6ff4: 0xaba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e6ff8: 0xbba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1e6ffc: 0x2415002c
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 44));
    // 0x1e7000: 0x3c01427a
    SET_GPR_U32(ctx, 1, ((uint32_t)17018 << 16));
    // 0x1e7004: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7008: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1e700c: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1e7010: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1e7014: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1e701c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1e701c
// Address: 0x1e701c - 0x1e7038

void entry_1e701c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e701c: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1e7020: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1e7024: 0x24070004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e7028: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e702c: 0x24050044
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 68));
    // 0x1e7030: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e7038);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e7038
// Address: 0x1e7038 - 0x1e707c

void entry_1e7038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7038: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1e703c: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1e7040: 0x4481f800
    *(uint32_t*)&ctx->f[31] = GPR_U32(ctx, 1);
    // 0x1e7044: 0xc683021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 540)); ctx->f[3] = *(float*)&val; }
    // 0x1e7048: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1e704c: 0xc6810c4c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 3148)); ctx->f[1] = *(float*)&val; }
    // 0x1e7050: 0x27a60044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 68));
    // 0x1e7054: 0xc6800c50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 3152)); ctx->f[0] = *(float*)&val; }
    // 0x1e7058: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1e705c: 0x46011ec0
    ctx->f[27] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x1e7060: 0xc6820220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 544)); ctx->f[2] = *(float*)&val; }
    // 0x1e7064: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1e7068: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1e706c: 0x4481f000
    *(uint32_t*)&ctx->f[30] = GPR_U32(ctx, 1);
    // 0x1e7070: 0x46141700
    ctx->f[28] = FPU_ADD_S(ctx->f[2], ctx->f[20]);
    // 0x1e7074: 0xc07989a
    SET_GPR_U32(ctx, 31, 0x1e707c);
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 72), *(uint32_t*)&val); }
    GetTvItvbMinMax__FP2TVPiT1(rdram, ctx, runtime); return;
}


// Function: entry_1e707c
// Address: 0x1e707c - 0x1e70f8

void entry_1e707c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e707c: 0xc7a00048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[0] = *(float*)&val; }
    // 0x1e7080: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e7084: 0x8fa20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e7088: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e708c: 0x46170040
    ctx->f[1] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x1e7090: 0xc6830c54
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 3156)); ctx->f[3] = *(float*)&val; }
    // 0x1e7094: 0x551018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 21); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1e7098: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e709c: 0x46141880
    ctx->f[2] = FPU_ADD_S(ctx->f[3], ctx->f[20]);
    // 0x1e70a0: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
    // 0x1e70a4: 0x24420280
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 640));
    // 0x1e70a8: 0x2829021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x1e70ac: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e70b0: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x1e70b4: 0xc6400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1e70b8: 0xc6410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1e70bc: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1e70c0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e70c4: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1e70c8: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x1e70cc: 0x4600e140
    ctx->f[5] = FPU_ADD_S(ctx->f[28], ctx->f[0]);
    // 0x1e70d0: 0x4602de80
    ctx->f[26] = FPU_ADD_S(ctx->f[27], ctx->f[2]);
    // 0x1e70d4: 0x4601de40
    ctx->f[25] = FPU_ADD_S(ctx->f[27], ctx->f[1]);
    // 0x1e70d8: 0x461f2802
    ctx->f[0] = FPU_MUL_S(ctx->f[5], ctx->f[31]);
    // 0x1e70dc: 0x46032e01
    ctx->f[24] = FPU_SUB_S(ctx->f[5], ctx->f[3]);
    // 0x1e70e0: 0x461e0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[30]);
    // 0x1e70e4: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1e70e8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e70ec: 0x44110800
    SET_GPR_U32(ctx, 17, *(uint32_t*)&ctx->f[1]);
    // 0x1e70f0: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e70f8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e70f8
// Address: 0x1e70f8 - 0x1e7124

void entry_1e70f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e70f8: 0x461fc002
    ctx->f[0] = FPU_MUL_S(ctx->f[24], ctx->f[31]);
    // 0x1e70fc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e7100: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e7104: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7108: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e710c: 0x461e0000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[30]);
    // 0x1e7110: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1e7114: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e7118: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x1e711c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e7124);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e7124
// Address: 0x1e7124 - 0x1e7148

void entry_1e7124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7124: 0x4617c800
    ctx->f[0] = FPU_ADD_S(ctx->f[25], ctx->f[23]);
    // 0x1e7128: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e712c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e7130: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7134: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1e7138: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e713c: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1e7140: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e7148);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e7148
// Address: 0x1e7148 - 0x1e716c

void entry_1e7148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7148: 0x4617d000
    ctx->f[0] = FPU_ADD_S(ctx->f[26], ctx->f[23]);
    // 0x1e714c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e7150: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e7154: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7158: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1e715c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e7160: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1e7164: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e716c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e716c
// Address: 0x1e716c - 0x1e720c

void entry_1e716c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e716c) {
        switch (ctx->pc) {
            case 0x1e71a0: ctx->pc = 0; goto label_1e71a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e716c: 0x8fb00040
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e7170: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1e7174: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1e7178: 0x10400035
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 21); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7250; return;
    }
    // 0x1e7180: 0x4600a546
    ctx->f[21] = FPU_MOV_S(ctx->f[20]);
    // 0x1e7184: 0x4600bf46
    ctx->f[29] = FPU_MOV_S(ctx->f[23]);
    // 0x1e7188: 0x4600b506
    ctx->f[20] = FPU_MOV_S(ctx->f[22]);
    // 0x1e718c: 0x4600fdc6
    ctx->f[23] = FPU_MOV_S(ctx->f[31]);
    // 0x1e7190: 0x4600f586
    ctx->f[22] = FPU_MOV_S(ctx->f[30]);
    // 0x1e7194: 0x24420280
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 640));
    // 0x1e7198: 0x541821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1e719c: 0x0
    // NOP
label_1e71a0:
    // 0x1e71a0: 0x60902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1e71a4: 0xc6820c54
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 3156)); ctx->f[2] = *(float*)&val; }
    // 0x1e71a8: 0xc6430008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[3] = *(float*)&val; }
    // 0x1e71ac: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e71b0: 0xc6440000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[4] = *(float*)&val; }
    // 0x1e71b4: 0x46151080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[21]);
    // 0x1e71b8: 0x46151842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[21]);
    // 0x1e71bc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e71c0: 0x46152002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[21]);
    // 0x1e71c4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e71c8: 0x460310c2
    ctx->f[3] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x1e71cc: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1e71d0: 0x4601e140
    ctx->f[5] = FPU_ADD_S(ctx->f[28], ctx->f[1]);
    // 0x1e71d4: 0x4600de40
    ctx->f[25] = FPU_ADD_S(ctx->f[27], ctx->f[0]);
    // 0x1e71d8: 0x46041082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x1e71dc: 0x46172802
    ctx->f[0] = FPU_MUL_S(ctx->f[5], ctx->f[23]);
    // 0x1e71e0: 0x461dc840
    ctx->f[1] = FPU_ADD_S(ctx->f[25], ctx->f[29]);
    // 0x1e71e4: 0x4602de80
    ctx->f[26] = FPU_ADD_S(ctx->f[27], ctx->f[2]);
    // 0x1e71e8: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x1e71ec: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x1e71f0: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1e71f4: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e71f8: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1e71fc: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e7200: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1e7204: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e720c);
    ctx->f[24] = FPU_ADD_S(ctx->f[28], ctx->f[3]);
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e720c
// Address: 0x1e720c - 0x1e7240

void entry_1e720c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e720c: 0x4617c002
    ctx->f[0] = FPU_MUL_S(ctx->f[24], ctx->f[23]);
    // 0x1e7210: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e7214: 0x461dd040
    ctx->f[1] = FPU_ADD_S(ctx->f[26], ctx->f[29]);
    // 0x1e7218: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e721c: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x1e7220: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x1e7224: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1e7228: 0x460008a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e722c: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1e7230: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e7234: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1e7238: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e7240);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e7240
// Address: 0x1e7240 - 0x1e72e4

void entry_1e7240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7240) {
        switch (ctx->pc) {
            case 0x1e7250: ctx->pc = 0; goto label_1e7250;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7240: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1e7244: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1e7248: 0x1440ffd5
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 44));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E71A0; return;
    }
label_1e7250:
    // 0x1e7250: 0xc640000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1e7254: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e7258: 0x3c01427a
    SET_GPR_U32(ctx, 1, ((uint32_t)17018 << 16));
    // 0x1e725c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7260: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e7264: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7268: 0xc6440004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[4] = *(float*)&val; }
    // 0x1e726c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7270: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1e7274: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1e7278: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1e727c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1e7280: 0x46022042
    ctx->f[1] = FPU_MUL_S(ctx->f[4], ctx->f[2]);
    // 0x1e7284: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1e7288: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1e728c: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1e7290: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1e7294: 0x4600e140
    ctx->f[5] = FPU_ADD_S(ctx->f[28], ctx->f[0]);
    // 0x1e7298: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1e729c: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1e72a0: 0x4601de40
    ctx->f[25] = FPU_ADD_S(ctx->f[27], ctx->f[1]);
    // 0x1e72a4: 0xc6830c54
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 3156)); ctx->f[3] = *(float*)&val; }
    // 0x1e72a8: 0x46142802
    ctx->f[0] = FPU_MUL_S(ctx->f[5], ctx->f[20]);
    // 0x1e72ac: 0x4615c840
    ctx->f[1] = FPU_ADD_S(ctx->f[25], ctx->f[21]);
    // 0x1e72b0: 0x46021880
    ctx->f[2] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x1e72b4: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x1e72b8: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
    // 0x1e72bc: 0x46032e00
    ctx->f[24] = FPU_ADD_S(ctx->f[5], ctx->f[3]);
    // 0x1e72c0: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1e72c4: 0x460008e4
    *(int32_t*)&ctx->f[3] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1e72c8: 0x44051800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[3]);
    // 0x1e72cc: 0x46041082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x1e72d0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e72d4: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x1e72d8: 0x4602de80
    ctx->f[26] = FPU_ADD_S(ctx->f[27], ctx->f[2]);
    // 0x1e72dc: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e72e4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e72e4
// Address: 0x1e72e4 - 0x1e731c

void entry_1e72e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e72e4: 0x4614c502
    ctx->f[20] = FPU_MUL_S(ctx->f[24], ctx->f[20]);
    // 0x1e72e8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e72ec: 0x4615d000
    ctx->f[0] = FPU_ADD_S(ctx->f[26], ctx->f[21]);
    // 0x1e72f0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e72f4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e72f8: 0x4617a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[23]);
    // 0x1e72fc: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x1e7300: 0x4616a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[22]);
    // 0x1e7304: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e7308: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x1e730c: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1e7310: 0x44110000
    SET_GPR_U32(ctx, 17, *(uint32_t*)&ctx->f[0]);
    // 0x1e7314: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e731c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e731c
// Address: 0x1e731c - 0x1e7348

void entry_1e731c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e731c: 0xc7a10048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[1] = *(float*)&val; }
    // 0x1e7320: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e7324: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e7328: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e732c: 0x46150d40
    ctx->f[21] = FPU_ADD_S(ctx->f[1], ctx->f[21]);
    // 0x1e7330: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7334: 0x4616ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[22]);
    // 0x1e7338: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x1e733c: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x1e7340: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e7348);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e7348
// Address: 0x1e7348 - 0x1e7360

void entry_1e7348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7348: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e734c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e7350: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e7354: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7358: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e7360);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e7360
// Address: 0x1e7360 - 0x1e73b8

void entry_1e7360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7360: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1e7364: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1e7368: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1e736c: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e7370: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e7374: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e7378: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e737c: 0xc7bf0118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[31] = *(float*)&val; }
    // 0x1e7380: 0xc7be0110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[30] = *(float*)&val; }
    // 0x1e7384: 0xc7bd0108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[29] = *(float*)&val; }
    // 0x1e7388: 0xc7bc0100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[28] = *(float*)&val; }
    // 0x1e738c: 0xc7bb00f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[27] = *(float*)&val; }
    // 0x1e7390: 0xc7ba00f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[26] = *(float*)&val; }
    // 0x1e7394: 0xc7b900e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[25] = *(float*)&val; }
    // 0x1e7398: 0xc7b800e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[24] = *(float*)&val; }
    // 0x1e739c: 0xc7b700d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[23] = *(float*)&val; }
    // 0x1e73a0: 0xc7b600d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[22] = *(float*)&val; }
    // 0x1e73a4: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x1e73a8: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x1e73ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e73b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e73b8; return;
}


// Function: DrawTv__FP2TV
// Address: 0x1e73b8 - 0x1e73d8

void entry_1e73d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e73d8: 0x10400014
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e742c(rdram, ctx, runtime); return;
    }
    // 0x1e73e0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e73e4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e73e8: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e73f0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e73f0
// Address: 0x1e73f0 - 0x1e7404

void entry_1e73f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e73f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e73f4: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1e73f8: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x1e73fc: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1e7404);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1e7404
// Address: 0x1e7404 - 0x1e7414

void entry_1e7404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7404: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e7408: 0x24050042
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    // 0x1e740c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1e7414);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1e7414
// Address: 0x1e7414 - 0x1e7420

void entry_1e7414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7414: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e7418: 0xc079980
    SET_GPR_U32(ctx, 31, 0x1e7420);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DrawTvBands__FP2TVR4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1e7420
// Address: 0x1e7420 - 0x1e742c

void entry_1e7420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7420: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e7424: 0xc079b08
    SET_GPR_U32(ctx, 31, 0x1e742c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DrawTvOutline__FP2TVR4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1e742c
// Address: 0x1e742c - 0x1e7440

void entry_1e742c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e742c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e7430: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e7434: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e7438: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetTvTvs__FP2TV3TVS
// Address: 0x1e7440 - 0x1e7460

void entry_1e74b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e74b4) {
        switch (ctx->pc) {
            case 0x1e74b8: ctx->pc = 0; goto label_1e74b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e74b4: 0x8e040270
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 624)));
label_1e74b8:
    // 0x1e74b8: 0x10800012
    WRITE32(ADD32(GPR_U32(ctx, 16), 628), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7504; return;
    }
    // 0x1e74c0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e74c4: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1e74c8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e74d0);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e74d0
// Address: 0x1e74d0 - 0x1e74ec

void entry_1e74d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e74d0: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e74d4: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e74d8: 0x8c620458
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1112)));
    // 0x1e74dc: 0x10440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 628)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x1E74F0; return;
    }
    // 0x1e74e4: 0xc049af0
    SET_GPR_U32(ctx, 31, 0x1e74ec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetAloBlotContext__FP3ALOP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1e74ec
// Address: 0x1e74ec - 0x1e7518

void entry_1e74ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e74ec) {
        switch (ctx->pc) {
            case 0x1e74f0: ctx->pc = 0; goto label_1e74f0;
            case 0x1e7504: ctx->pc = 0; goto label_1e7504;
            case 0x1e7508: ctx->pc = 0; goto label_1e7508;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e74ec: 0x8e040274
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 628)));
label_1e74f0:
    // 0x1e74f0: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1e74f4: 0x31c78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 17);
    // 0x1e74f8: 0xdc8202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    // 0x1e74fc: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1e7500: 0xfc8202c8
    WRITE64(ADD32(GPR_U32(ctx, 4), 712), GPR_U64(ctx, 2));
label_1e7504:
    // 0x1e7504: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1e7508:
    // 0x1e7508: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e750c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e7514: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e7518; return;
}


// Function: SetTvTvgs__FP2TV4TVGS
// Address: 0x1e7518 - 0x1e75dc

void entry_1e75dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e75dc) {
        switch (ctx->pc) {
            case 0x1e75f8: ctx->pc = 0; goto label_1e75f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e75dc: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1e75e0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e75e4: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1e75e8: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x1e75ec: 0x26700280
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 640));
    // 0x1e75f0: 0x24110038
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 56));
    // 0x1e75f4: 0x0
    // NOP
label_1e75f8:
    // 0x1e75f8: 0xe6140018
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 24), *(uint32_t*)&val); }
    // 0x1e75fc: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1e7600: 0x3c013d4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15692 << 16));
    // 0x1e7604: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7608: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e760c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e7614);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e7614
// Address: 0x1e7614 - 0x1e7678

void entry_1e7614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7614) {
        switch (ctx->pc) {
            case 0x1e7634: ctx->pc = 0; goto label_1e7634;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7614: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x1e7618: 0xe6140020
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 32), *(uint32_t*)&val); }
    // 0x1e761c: 0xe6160024
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    // 0x1e7620: 0xe6150028
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 16), 40), *(uint32_t*)&val); }
    // 0x1e7624: 0x621fff4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 44));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x1E75F8; return;
    }
    // 0x1e762c: 0x1000001d
    WRITE32(ADD32(GPR_U32(ctx, 19), 616), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E76A4; return;
    }
label_1e7634:
    // 0x1e7634: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1e7638: 0x2404008d
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 141));
    // 0x1e763c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1e7640: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1e7644: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e7648: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e764c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1e7650: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e7654: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7658: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e765c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1e7660: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7664: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1e7668: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e766c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7670: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1e7678);
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1e7678
// Address: 0x1e7678 - 0x1e76a0

void entry_1e7678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7678) {
        switch (ctx->pc) {
            case 0x1e7680: ctx->pc = 0; goto label_1e7680;
            case 0x1e7694: ctx->pc = 0; goto label_1e7694;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7678: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 19), 616), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E76A4; return;
    }
label_1e7680:
    // 0x1e7680: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e7684: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e7688: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x1e768c: 0x10000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 3184), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e76a0(rdram, ctx, runtime); return;
    }
label_1e7694:
    // 0x1e7694: 0xae600c70
    WRITE32(ADD32(GPR_U32(ctx, 19), 3184), GPR_U32(ctx, 0));
    // 0x1e7698: 0xc079d18
    SET_GPR_U32(ctx, 31, 0x1e76a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    AcceptTvSpeaker__FP2TV(rdram, ctx, runtime); return;
}


// Function: entry_1e76a0
// Address: 0x1e76a0 - 0x1e76e0

void entry_1e76a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e76a0) {
        switch (ctx->pc) {
            case 0x1e76a4: ctx->pc = 0; goto label_1e76a4;
            case 0x1e76b0: ctx->pc = 0; goto label_1e76b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e76a0: 0xae720268
    WRITE32(ADD32(GPR_U32(ctx, 19), 616), GPR_U32(ctx, 18));
label_1e76a4:
    // 0x1e76a4: 0x26821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x1e76a8: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1e76ac: 0xe660026c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 620), *(uint32_t*)&val); }
label_1e76b0:
    // 0x1e76b0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e76b4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e76b8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e76bc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e76c0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e76c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e76c8: 0xc7b60070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[22] = *(float*)&val; }
    // 0x1e76cc: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x1e76d0: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1e76d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e76dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e76e0; return;
}


// Function: SetTvBlots__FP2TV5BLOTS
// Address: 0x1e76e0 - 0x1e7704

void entry_1e7704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7704: 0x12320028
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x1E77A8; return;
    }
    // 0x1e770c: 0x1620001a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7778; return;
    }
    // 0x1e7714: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e7718: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e771c: 0x8c430458
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x1e7720: 0x1464000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 536)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x1E774C; return;
    }
    // 0x1e7728: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e772c: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x1e7730: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e7734: 0x3c0143b4
    SET_GPR_U32(ctx, 1, ((uint32_t)17332 << 16));
    // 0x1e7738: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e773c: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x1e7744);
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 0));
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_1e7744
// Address: 0x1e7744 - 0x1e7774

void entry_1e7744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7744) {
        switch (ctx->pc) {
            case 0x1e774c: ctx->pc = 0; goto label_1e774c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7744: 0x1000000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7778; return;
    }
label_1e774c:
    // 0x1e774c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e7750: 0x3c01c1a0
    SET_GPR_U32(ctx, 1, ((uint32_t)49568 << 16));
    // 0x1e7754: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e7758: 0x3c014320
    SET_GPR_U32(ctx, 1, ((uint32_t)17184 << 16));
    // 0x1e775c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e7760: 0x3c0142fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17146 << 16));
    // 0x1e7764: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7768: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e776c: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x1e7774);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_1e7774
// Address: 0x1e7774 - 0x1e77a4

void entry_1e7774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7774) {
        switch (ctx->pc) {
            case 0x1e7778: ctx->pc = 0; goto label_1e7778;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7774: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_1e7778:
    // 0x1e7778: 0x1642000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E77A8; return;
    }
    // 0x1e7780: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e7784: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e7788: 0x8c430458
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x1e778c: 0x10640006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x1E77A8; return;
    }
    // 0x1e7794: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e7798: 0xae020268
    WRITE32(ADD32(GPR_U32(ctx, 16), 616), GPR_U32(ctx, 2));
    // 0x1e779c: 0xc079d46
    SET_GPR_U32(ctx, 31, 0x1e77a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetTvTvgs__FP2TV4TVGS(rdram, ctx, runtime); return;
}


// Function: entry_1e77a4
// Address: 0x1e77a4 - 0x1e77c0

void entry_1e77a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e77a4) {
        switch (ctx->pc) {
            case 0x1e77a8: ctx->pc = 0; goto label_1e77a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e77a4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1e77a8:
    // 0x1e77a8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e77ac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e77b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e77b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e77bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e77c0; return;
}


// Function: UpdateTv__FP2TV
// Address: 0x1e77c0 - 0x1e77fc

void entry_1e77fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e77fc) {
        switch (ctx->pc) {
            case 0x1e7828: ctx->pc = 0; goto label_1e7828;
            case 0x1e7838: ctx->pc = 0; goto label_1e7838;
            case 0x1e7848: ctx->pc = 0; goto label_1e7848;
            case 0x1e785c: ctx->pc = 0; goto label_1e785c;
            case 0x1e787c: ctx->pc = 0; goto label_1e787c;
            case 0x1e788c: ctx->pc = 0; goto label_1e788c;
            case 0x1e78cc: ctx->pc = 0; goto label_1e78cc;
            case 0x1e7908: ctx->pc = 0; goto label_1e7908;
            case 0x1e7918: ctx->pc = 0; goto label_1e7918;
            case 0x1e7920: ctx->pc = 0; goto label_1e7920;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e77fc: 0x8e330250
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 17), 592)));
    // 0x1e7800: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e7804: 0x12620015
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 17), 616)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        goto label_1e785c;
    }
    // 0x1e780c: 0x2a620003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 3));
    // 0x1e7810: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e7828;
    }
    // 0x1e7818: 0x52600007
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 628)));
        goto label_1e7838;
    }
    // 0x1e7820: 0x100000fa
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7C0C; return;
    }
label_1e7828:
    // 0x1e7828: 0x526200f7
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 3));
        ctx->pc = 0x1E7C08; return;
    }
    // 0x1e7830: 0x100000f6
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7C0C; return;
    }
label_1e7838:
    // 0x1e7838: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 624)));
        goto label_1e7848;
    }
    // 0x1e7840: 0x100000f1
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7C08; return;
    }
label_1e7848:
    // 0x1e7848: 0x104000ef
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7C08; return;
    }
    // 0x1e7850: 0x8c430448
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1096)));
    // 0x1e7854: 0x100000ec
    SET_GPR_U32(ctx, 19, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7C08; return;
    }
label_1e785c:
    // 0x1e785c: 0x1293001b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), 3));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 19)) {
        goto label_1e78cc;
    }
    // 0x1e7864: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e787c;
    }
    // 0x1e786c: 0x12800007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1e788c;
    }
    // 0x1e7874: 0x1000002a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e7920;
    }
label_1e787c:
    // 0x1e787c: 0x12820022
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 2)) {
        goto label_1e7908;
    }
    // 0x1e7884: 0x10000026
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e7920;
    }
label_1e788c:
    // 0x1e788c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e7890: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1e7894: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e7898: 0xc440186c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6252)); ctx->f[0] = *(float*)&val; }
    // 0x1e789c: 0xc6210c70
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3184)); ctx->f[1] = *(float*)&val; }
    // 0x1e78a0: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1e78a4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e78a8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e78ac: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1e78b0: 0x46011036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e78b4: 0x0
    // NOP
    // 0x1e78b8: 0x45000017
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 3184), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e7918;
    }
    // 0x1e78c0: 0xe6220c70
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 3184), *(uint32_t*)&val); }
    // 0x1e78c4: 0x10000014
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e7918;
    }
label_1e78cc:
    // 0x1e78cc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e78d0: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1e78d4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e78d8: 0xc440186c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6252)); ctx->f[0] = *(float*)&val; }
    // 0x1e78dc: 0xc6210c70
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3184)); ctx->f[1] = *(float*)&val; }
    // 0x1e78e0: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1e78e4: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1e78e8: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1e78ec: 0x46020836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e78f0: 0x0
    // NOP
    // 0x1e78f4: 0x45000008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 3184), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e7918;
    }
    // 0x1e78fc: 0xe6220c70
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 3184), *(uint32_t*)&val); }
    // 0x1e7900: 0x10000005
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e7918;
    }
label_1e7908:
    // 0x1e7908: 0x8e220270
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 624)));
    // 0x1e790c: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 3));
        goto label_1e7918;
    }
    // 0x1e7914: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1e7918:
    // 0x1e7918: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e791c: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
label_1e7920:
    // 0x1e7920: 0x8c430458
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x1e7924: 0x106400b8
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x1E7C08; return;
    }
    // 0x1e792c: 0xc62c0c5c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3164)); ctx->f[12] = *(float*)&val; }
    // 0x1e7930: 0xc44e186c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6252)); ctx->f[14] = *(float*)&val; }
    // 0x1e7934: 0x26240c64
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 3172));
    // 0x1e7938: 0xc62d0c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3168)); ctx->f[13] = *(float*)&val; }
    // 0x1e793c: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1e7944);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1e7944
// Address: 0x1e7944 - 0x1e7960

void entry_1e7944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7944: 0xc62d0c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3168)); ctx->f[13] = *(float*)&val; }
    // 0x1e7948: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1e794c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1e7950: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1e7954: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1e7958: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1e7960);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3164), *(uint32_t*)&val); }
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1e7960
// Address: 0x1e7960 - 0x1e7990

void entry_1e7960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7960: 0x10400031
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 26));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7A28; return;
    }
    // 0x1e7968: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e796c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e7970: 0x8e220214
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 532)));
    // 0x1e7974: 0x14430016
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 17), 3164), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1E79D0; return;
    }
    // 0x1e797c: 0x3c013fb3
    SET_GPR_U32(ctx, 1, ((uint32_t)16307 << 16));
    // 0x1e7980: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1e7984: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e7988: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e7990);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e7990
// Address: 0x1e7990 - 0x1e79b0

void entry_1e7990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7990: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x1e7994: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1e7998: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e799c: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1e79a0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e79a4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e79a8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e79b0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3172), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e79b0
// Address: 0x1e79b0 - 0x1e79f8

void entry_1e79b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e79b0) {
        switch (ctx->pc) {
            case 0x1e79d0: ctx->pc = 0; goto label_1e79d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e79b0: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1e79b4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e79b8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e79bc: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1e79c0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e79c4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e79c8: 0x10000014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3176), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7A1C; return;
    }
label_1e79d0:
    // 0x1e79d0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1e79d4: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1e79d8: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1e79dc: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1e79e0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e79e4: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x1e79e8: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1e79ec: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1e79f0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e79f8);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e79f8
// Address: 0x1e79f8 - 0x1e7a10

void entry_1e79f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e79f8: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1e79fc: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7a00: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e7a04: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1e7a08: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e7a10);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3172), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e7a10
// Address: 0x1e7a10 - 0x1e7a24

void entry_1e7a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7a10) {
        switch (ctx->pc) {
            case 0x1e7a1c: ctx->pc = 0; goto label_1e7a1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7a10: 0xe6200c68
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3176), *(uint32_t*)&val); }
    // 0x1e7a14: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1e7a18: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
label_1e7a1c:
    // 0x1e7a1c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e7a24);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e7a24
// Address: 0x1e7a24 - 0x1e7a64

void entry_1e7a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7a24) {
        switch (ctx->pc) {
            case 0x1e7a28: ctx->pc = 0; goto label_1e7a28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7a24: 0xe6200c6c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 3180), *(uint32_t*)&val); }
label_1e7a28:
    // 0x1e7a28: 0x3c014263
    SET_GPR_U32(ctx, 1, ((uint32_t)16995 << 16));
    // 0x1e7a2c: 0x3421fefa
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 65274));
    // 0x1e7a30: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e7a34: 0xc6200c5c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 3164)); ctx->f[0] = *(float*)&val; }
    // 0x1e7a38: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1e7a3c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7a40: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e7a44: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1e7a48: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1e7a4c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7a50: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e7a54: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1e7a58: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x1e7a5c: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e7a64);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e7a64
// Address: 0x1e7a64 - 0x1e7b28

void entry_1e7a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7a64) {
        switch (ctx->pc) {
            case 0x1e7a78: ctx->pc = 0; goto label_1e7a78;
            case 0x1e7ab4: ctx->pc = 0; goto label_1e7ab4;
            case 0x1e7ac4: ctx->pc = 0; goto label_1e7ac4;
            case 0x1e7b10: ctx->pc = 0; goto label_1e7b10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7a64: 0x8e230214
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 532)));
    // 0x1e7a68: 0x2402001a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 26));
    // 0x1e7a6c: 0x14620002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e7a78;
    }
    // 0x1e7a74: 0x46010840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[1]);
label_1e7a78:
    // 0x1e7a78: 0x2403002c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 44));
    // 0x1e7a7c: 0x26220298
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 664));
    // 0x1e7a80: 0x2031818
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1e7a84: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e7a88: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1e7a8c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e7a90: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1e7a94: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1e7a98: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1e7a9c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1e7aa0: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e7aa4: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1e7ab4;
    }
    // 0x1e7aac: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e7ac4;
    }
label_1e7ab4:
    // 0x1e7ab4: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e7ab8: 0x0
    // NOP
    // 0x1e7abc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[3]);
        goto label_1e7ac4;
    }
label_1e7ac4:
    // 0x1e7ac4: 0x2403002c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 44));
    // 0x1e7ac8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e7acc: 0x2032818
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1e7ad0: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x1e7ad4: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1e7ad8: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1e7adc: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x1e7ae0: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1e7ae4: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1e7ae8: 0x24571858
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1e7aec: 0x3c013ecc
    SET_GPR_U32(ctx, 1, ((uint32_t)16076 << 16));
    // 0x1e7af0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7af4: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1e7af8: 0x2416001a
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 26));
    // 0x1e7afc: 0x263202a0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 672));
    // 0x1e7b00: 0x26300280
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 640));
    // 0x1e7b04: 0xa41821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    // 0x1e7b08: 0x24150038
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 56));
    // 0x1e7b0c: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
label_1e7b10:
    // 0x1e7b10: 0xc60c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[12] = *(float*)&val; }
    // 0x1e7b14: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1e7b18: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1e7b1c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1e7b20: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1e7b28);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[13] = *(float*)&val; }
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1e7b28
// Address: 0x1e7b28 - 0x1e7b50

void entry_1e7b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7b28: 0x5040002d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x1E7BE0; return;
    }
    // 0x1e7b30: 0x8e220214
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 532)));
    // 0x1e7b34: 0x14560014
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 22)) {
        ctx->pc = 0x1E7B88; return;
    }
    // 0x1e7b3c: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x1e7b40: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7b44: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e7b48: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e7b50);
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e7b50
// Address: 0x1e7b50 - 0x1e7b68

void entry_1e7b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7b50: 0x3c013ecc
    SET_GPR_U32(ctx, 1, ((uint32_t)16076 << 16));
    // 0x1e7b54: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7b58: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e7b5c: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x1e7b60: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e7b68);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 32), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e7b68
// Address: 0x1e7b68 - 0x1e7b90

void entry_1e7b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7b68) {
        switch (ctx->pc) {
            case 0x1e7b88: ctx->pc = 0; goto label_1e7b88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7b68: 0x3c013d4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15692 << 16));
    // 0x1e7b6c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7b70: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e7b74: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1e7b78: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7b7c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e7b80: 0x1000000d
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7BB8; return;
    }
label_1e7b88:
    // 0x1e7b88: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e7b90);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e7b90
// Address: 0x1e7b90 - 0x1e7ba8

void entry_1e7b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7b90: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1e7b94: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7b98: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e7b9c: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x1e7ba0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e7ba8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 32), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e7ba8
// Address: 0x1e7ba8 - 0x1e7bc0

void entry_1e7ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7ba8) {
        switch (ctx->pc) {
            case 0x1e7bb8: ctx->pc = 0; goto label_1e7bb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7ba8: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x1e7bac: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7bb0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e7bb4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
label_1e7bb8:
    // 0x1e7bb8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e7bc0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e7bc0
// Address: 0x1e7bc0 - 0x1e7bd8

void entry_1e7bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7bc0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1e7bc4: 0x3c013d4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15692 << 16));
    // 0x1e7bc8: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7bcc: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1e7bd0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1e7bd8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 40), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1e7bd8
// Address: 0x1e7bd8 - 0x1e7bf4

void entry_1e7bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7bd8) {
        switch (ctx->pc) {
            case 0x1e7be0: ctx->pc = 0; goto label_1e7be0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7bd8: 0x10000007
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7BF8; return;
    }
label_1e7be0:
    // 0x1e7be0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e7be4: 0xc60d001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[13] = *(float*)&val; }
    // 0x1e7be8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7bec: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1e7bf4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 20)); ctx->f[14] = *(float*)&val; }
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1e7bf4
// Address: 0x1e7bf4 - 0x1e7c1c

void entry_1e7bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7bf4) {
        switch (ctx->pc) {
            case 0x1e7bf8: ctx->pc = 0; goto label_1e7bf8;
            case 0x1e7c08: ctx->pc = 0; goto label_1e7c08;
            case 0x1e7c0c: ctx->pc = 0; goto label_1e7c0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7bf4: 0xe6000018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 24), *(uint32_t*)&val); }
label_1e7bf8:
    // 0x1e7bf8: 0x2652002c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 44));
    // 0x1e7bfc: 0x26b5ffff
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 4294967295));
    // 0x1e7c00: 0x6a1ffc3
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 44));
    if (GPR_S32(ctx, 21) >= 0) {
        ctx->pc = 0x1E7B10; return;
    }
label_1e7c08:
    // 0x1e7c08: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1e7c0c:
    // 0x1e7c0c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e7c10: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1e7c14: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e7c1c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e7c1c
// Address: 0x1e7c1c - 0x1e7c28

void entry_1e7c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7c1c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e7c20: 0xc079d46
    SET_GPR_U32(ctx, 31, 0x1e7c28);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SetTvTvgs__FP2TV4TVGS(rdram, ctx, runtime); return;
}


// Function: entry_1e7c28
// Address: 0x1e7c28 - 0x1e7c60

void entry_1e7c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7c28: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1e7c2c: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e7c30: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e7c34: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e7c38: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e7c3c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e7c40: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e7c44: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e7c48: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e7c4c: 0xc7b600a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[22] = *(float*)&val; }
    // 0x1e7c50: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1e7c54: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1e7c58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderTv__FP2TV
// Address: 0x1e7c60 - 0x1e7cd0

void entry_1e7cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7cd0) {
        switch (ctx->pc) {
            case 0x1e7cd8: ctx->pc = 0; goto label_1e7cd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7cd0: 0x104000f6
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E80AC; return;
    }
label_1e7cd8:
    // 0x1e7cd8: 0x27a50150
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 336));
    // 0x1e7cdc: 0xc07989a
    SET_GPR_U32(ctx, 31, 0x1e7ce4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 340));
    GetTvItvbMinMax__FP2TVPiT1(rdram, ctx, runtime); return;
}


// Function: entry_1e7ce4
// Address: 0x1e7ce4 - 0x1e7d20

void entry_1e7ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7ce4: 0x8fa30150
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1e7ce8: 0x8fa20154
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 340)));
    // 0x1e7cec: 0x106200ef
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 504));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E80AC; return;
    }
    // 0x1e7cf4: 0x24110004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e7cf8: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1e7cfc: 0x10510008
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        entry_1e7d20(rdram, ctx, runtime); return;
    }
    // 0x1e7d04: 0x8e430274
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 628)));
    // 0x1e7d08: 0x8e821990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 6544)));
    // 0x1e7d0c: 0xc46c02d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 724)); ctx->f[12] = *(float*)&val; }
    // 0x1e7d10: 0xc45401c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 452)); ctx->f[20] = *(float*)&val; }
    // 0x1e7d14: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e7d18: 0xc050e50
    SET_GPR_U32(ctx, 31, 0x1e7d20);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 456)); ctx->f[21] = *(float*)&val; }
    SetCmFov__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_1e7d20
// Address: 0x1e7d20 - 0x1e7dc8

void entry_1e7d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7d20: 0x8e420274
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 628)));
    // 0x1e7d24: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1e7d28: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e7d2c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e7d30: 0xc0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1e7d34: 0xc44702dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 732)); ctx->f[7] = *(float*)&val; }
    // 0x1e7d38: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e7d3c: 0xc644021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 540)); ctx->f[4] = *(float*)&val; }
    // 0x1e7d40: 0x46071001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[7]);
    // 0x1e7d44: 0xc6450234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 564)); ctx->f[5] = *(float*)&val; }
    // 0x1e7d48: 0xc44602e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 736)); ctx->f[6] = *(float*)&val; }
    // 0x1e7d4c: 0xc6480220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 544)); ctx->f[8] = *(float*)&val; }
    // 0x1e7d50: 0xc6430238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 568)); ctx->f[3] = *(float*)&val; }
    // 0x1e7d54: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x1e7d58: 0x46052100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[5]);
    // 0x1e7d5c: 0x3c013b4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15180 << 16));
    // 0x1e7d60: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e7d64: 0x44815000
    *(uint32_t*)&ctx->f[10] = GPR_U32(ctx, 1);
    // 0x1e7d68: 0x46061041
    ctx->f[1] = FPU_SUB_S(ctx->f[2], ctx->f[6]);
    // 0x1e7d6c: 0x3c013b84
    SET_GPR_U32(ctx, 1, ((uint32_t)15236 << 16));
    // 0x1e7d70: 0x3421fcad
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 64685));
    // 0x1e7d74: 0x44814800
    *(uint32_t*)&ctx->f[9] = GPR_U32(ctx, 1);
    // 0x1e7d78: 0x460340c0
    ctx->f[3] = FPU_ADD_S(ctx->f[8], ctx->f[3]);
    // 0x1e7d7c: 0xc44502d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 728)); ctx->f[5] = *(float*)&val; }
    // 0x1e7d80: 0x460439c2
    ctx->f[7] = FPU_MUL_S(ctx->f[7], ctx->f[4]);
    // 0x1e7d84: 0x46080842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[8]);
    // 0x1e7d88: 0x46033182
    ctx->f[6] = FPU_MUL_S(ctx->f[6], ctx->f[3]);
    // 0x1e7d8c: 0x46070000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[7]);
    // 0x1e7d90: 0x46060840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[6]);
    // 0x1e7d94: 0x460a0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[10]);
    // 0x1e7d98: 0x46090842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[9]);
    // 0x1e7d9c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1e7da0: 0x46011081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    // 0x1e7da4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e7da8: 0x44031000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[2]);
    // 0x1e7dac: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1e7db0: 0x44032800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[5]);
    // 0x1e7db4: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1e7db8: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1e7dbc: 0x7fa200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 2));
    // 0x1e7dc0: 0xc05104a
    SET_GPR_U32(ctx, 31, 0x1e7dc8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 6544)));
    ConvertCmScreenToWorld(rdram, ctx, runtime); return;
}


// Function: entry_1e7dc8
// Address: 0x1e7dc8 - 0x1e7ef8

void entry_1e7dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7dc8) {
        switch (ctx->pc) {
            case 0x1e7e00: ctx->pc = 0; goto label_1e7e00;
            case 0x1e7e10: ctx->pc = 0; goto label_1e7e10;
            case 0x1e7e4c: ctx->pc = 0; goto label_1e7e4c;
            case 0x1e7e80: ctx->pc = 0; goto label_1e7e80;
            case 0x1e7e88: ctx->pc = 0; goto label_1e7e88;
            case 0x1e7e98: ctx->pc = 0; goto label_1e7e98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7dc8: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1e7dcc: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1e7dd0: 0x3c014316
    SET_GPR_U32(ctx, 1, ((uint32_t)17174 << 16));
    // 0x1e7dd4: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x1e7dd8: 0x3c0141a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16800 << 16));
    // 0x1e7ddc: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x1e7de0: 0x10620029
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e7e88;
    }
    // 0x1e7de8: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e7e00;
    }
    // 0x1e7df0: 0x10620007
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 112));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e7e10;
    }
    // 0x1e7df8: 0x1000006d
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 504));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7FB0; return;
    }
label_1e7e00:
    // 0x1e7e00: 0x10710058
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 112));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x1E7F64; return;
    }
    // 0x1e7e08: 0x10000069
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 504));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7FB0; return;
    }
label_1e7e10:
    // 0x1e7e10: 0x8e430214
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 532)));
    // 0x1e7e14: 0x2402001a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 26));
    // 0x1e7e18: 0x1462000c
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e7e4c;
    }
    // 0x1e7e20: 0x46003106
    ctx->f[4] = FPU_MOV_S(ctx->f[6]);
    // 0x1e7e24: 0x24422c70
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 11376));
    // 0x1e7e28: 0xc4420044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 68)); ctx->f[2] = *(float*)&val; }
    // 0x1e7e2c: 0xc4430040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 64)); ctx->f[3] = *(float*)&val; }
    // 0x1e7e30: 0x46001005
    ctx->f[0] = FPU_ABS_S(ctx->f[2]);
    // 0x1e7e34: 0x46001845
    ctx->f[1] = FPU_ABS_S(ctx->f[3]);
    // 0x1e7e38: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1e7e3c: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1e7e40: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x1e7e44: 0x1000000e
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[6]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e7e80;
    }
label_1e7e4c:
    // 0x1e7e4c: 0x3c01c316
    SET_GPR_U32(ctx, 1, ((uint32_t)49942 << 16));
    // 0x1e7e50: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x1e7e54: 0x24422c70
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 11376));
    // 0x1e7e58: 0x3c014316
    SET_GPR_U32(ctx, 1, ((uint32_t)17174 << 16));
    // 0x1e7e5c: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1e7e60: 0xc4420078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 120)); ctx->f[2] = *(float*)&val; }
    // 0x1e7e64: 0xc4430074
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 116)); ctx->f[3] = *(float*)&val; }
    // 0x1e7e68: 0x46001005
    ctx->f[0] = FPU_ABS_S(ctx->f[2]);
    // 0x1e7e6c: 0x46001845
    ctx->f[1] = FPU_ABS_S(ctx->f[3]);
    // 0x1e7e70: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1e7e74: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1e7e78: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x1e7e7c: 0x46050842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[5]);
label_1e7e80:
    // 0x1e7e80: 0x460701c0
    ctx->f[7] = FPU_ADD_S(ctx->f[0], ctx->f[7]);
    // 0x1e7e84: 0x46060980
    ctx->f[6] = FPU_ADD_S(ctx->f[1], ctx->f[6]);
label_1e7e88:
    // 0x1e7e88: 0x8e430214
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 532)));
    // 0x1e7e8c: 0x2402001a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 26));
    // 0x1e7e90: 0x50620001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->f[6] = FPU_NEG_S(ctx->f[6]);
        goto label_1e7e98;
    }
label_1e7e98:
    // 0x1e7e98: 0x8e821990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 6544)));
    // 0x1e7e9c: 0x27b10040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1e7ea0: 0x44033800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[7]);
    // 0x1e7ea4: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1e7ea8: 0xd8420040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1e7eac: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1e7eb0: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1e7eb4: 0x244500a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 160));
    // 0x1e7eb8: 0x44033000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[6]);
    // 0x1e7ebc: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e7ec0: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1e7ec4: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e7ec8: 0xd84100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 160)));
    // 0x1e7ecc: 0x4be308d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e7ed0: 0xfba400c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1e7ed4: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e7ed8: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e7edc: 0xd8410090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x1e7ee0: 0x4be40918
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e7ee4: 0x4be410a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e7ee8: 0x4be5116c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1e7eec: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1e7ef0: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x1e7ef8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[5]));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1e7ef8
// Address: 0x1e7ef8 - 0x1e7f0c

void entry_1e7ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7ef8: 0x27b00070
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1e7efc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e7f00: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e7f04: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x1e7f0c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1e7f0c
// Address: 0x1e7f0c - 0x1e7f5c

void entry_1e7f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7f0c: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e7f10: 0x8e821990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 6544)));
    // 0x1e7f14: 0x27a500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1e7f18: 0x8e440274
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 628)));
    // 0x1e7f1c: 0x24430080
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 128));
    // 0x1e7f20: 0xd8450080
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 128)));
    // 0x1e7f24: 0xd88302f0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 752)));
    // 0x1e7f28: 0xd8640020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1e7f2c: 0xd8620010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1e7f30: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1e7f34: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1e7f38: 0x4bc320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1e7f3c: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e7f40: 0x8e46027c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 636)));
    // 0x1e7f44: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e7f48: 0xfba100c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e7f4c: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1e7f50: 0x8c430084
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 132)));
    // 0x1e7f54: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1e7f5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1e7f5c
// Address: 0x1e7f5c - 0x1e7f7c

void entry_1e7f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7f5c) {
        switch (ctx->pc) {
            case 0x1e7f64: ctx->pc = 0; goto label_1e7f64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7f5c: 0x10000014
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 504));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E7FB0; return;
    }
label_1e7f64:
    // 0x1e7f64: 0x8e440278
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 632)));
    // 0x1e7f68: 0x10800047
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 272));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1e8088(rdram, ctx, runtime); return;
    }
    // 0x1e7f70: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e7f74: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x1e7f7c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 320));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1e7f7c
// Address: 0x1e7f7c - 0x1e7f98

void entry_1e7f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7f7c: 0x8e460274
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 628)));
    // 0x1e7f80: 0x27b000c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1e7f84: 0x8e440278
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 632)));
    // 0x1e7f88: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7f8c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e7f90: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1e7f98);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 768));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1e7f98
// Address: 0x1e7f98 - 0x1e7fac

void entry_1e7f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7f98: 0x8e44027c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 636)));
    // 0x1e7f9c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e7fa0: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1e7fa4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e7fac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e7fac
// Address: 0x1e7fac - 0x1e7fcc

void entry_1e7fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e7fac) {
        switch (ctx->pc) {
            case 0x1e7fb0: ctx->pc = 0; goto label_1e7fb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e7fac: 0x26b001f8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 504));
label_1e7fb0:
    // 0x1e7fb0: 0x24130004
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e7fb4: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1e7fb8: 0x1053000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 208));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 19)) {
        entry_1e7fec(rdram, ctx, runtime); return;
    }
    // 0x1e7fc0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e7fc4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1e7fcc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1e7fcc
// Address: 0x1e7fcc - 0x1e7fec

void entry_1e7fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7fcc: 0x3c03001f
    SET_GPR_U32(ctx, 3, ((uint32_t)31 << 16));
    // 0x1e7fd0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e7fd4: 0x246380d8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294934744));
    // 0x1e7fd8: 0xafa200d8
    WRITE32(ADD32(GPR_U32(ctx, 29), 216), GPR_U32(ctx, 2));
    // 0x1e7fdc: 0xafa300d0
    WRITE32(ADD32(GPR_U32(ctx, 29), 208), GPR_U32(ctx, 3));
    // 0x1e7fe0: 0x27a400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1e7fe4: 0xc067504
    SET_GPR_U32(ctx, 31, 0x1e7fec);
    WRITE32(ADD32(GPR_U32(ctx, 29), 304), GPR_U32(ctx, 18));
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1e7fec
// Address: 0x1e7fec - 0x1e8038

void entry_1e7fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e7fec: 0x8e430274
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 628)));
    // 0x1e7ff0: 0x2404fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x1e7ff4: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1e7ff8: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1e7ffc: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1e8000: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x1e8004: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e8008: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e800c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e8010: 0xdc6202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 712)));
    // 0x1e8014: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1e8018: 0xfc6202c8
    WRITE64(ADD32(GPR_U32(ctx, 3), 712), GPR_U64(ctx, 2));
    // 0x1e801c: 0xe7a000b0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 176), *(uint32_t*)&val); }
    // 0x1e8020: 0xe7a000b4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 180), *(uint32_t*)&val); }
    // 0x1e8024: 0x8e440274
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 628)));
    // 0x1e8028: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e802c: 0x8c6200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 160)));
    // 0x1e8030: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e8038);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 6544)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e8038
// Address: 0x1e8038 - 0x1e8068

void entry_1e8038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8038: 0x8e440274
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 628)));
    // 0x1e803c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1e8040: 0x31c78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 17);
    // 0x1e8044: 0xdc8202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    // 0x1e8048: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1e804c: 0xfc8202c8
    WRITE64(ADD32(GPR_U32(ctx, 4), 712), GPR_U64(ctx, 2));
    // 0x1e8050: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x1e8054: 0x10730015
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 19)) {
        ctx->pc = 0x1E80AC; return;
    }
    // 0x1e805c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e8060: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1e8068);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1e8068
// Address: 0x1e8068 - 0x1e8088

void entry_1e8068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8068: 0x3c03001f
    SET_GPR_U32(ctx, 3, ((uint32_t)31 << 16));
    // 0x1e806c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e8070: 0x246383e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294935520));
    // 0x1e8074: 0xafa200c8
    WRITE32(ADD32(GPR_U32(ctx, 29), 200), GPR_U32(ctx, 2));
    // 0x1e8078: 0xafa300c0
    WRITE32(ADD32(GPR_U32(ctx, 29), 192), GPR_U32(ctx, 3));
    // 0x1e807c: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1e8080: 0xc067504
    SET_GPR_U32(ctx, 31, 0x1e8088);
    WRITE32(ADD32(GPR_U32(ctx, 29), 288), GPR_U32(ctx, 18));
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1e8088
// Address: 0x1e8088 - 0x1e80a4

void entry_1e8088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8088: 0x26a201f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 504));
    // 0x1e808c: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e8090: 0x8c430260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 608)));
    // 0x1e8094: 0x10640005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 6544)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x1E80AC; return;
    }
    // 0x1e809c: 0xc050e50
    SET_GPR_U32(ctx, 31, 0x1e80a4);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetCmFov__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_1e80a4
// Address: 0x1e80a4 - 0x1e80d8

void entry_1e80a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e80a4) {
        switch (ctx->pc) {
            case 0x1e80ac: ctx->pc = 0; goto label_1e80ac;
            case 0x1e80b0: ctx->pc = 0; goto label_1e80b0;
            case 0x1e80b4: ctx->pc = 0; goto label_1e80b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e80a4: 0x8e821990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 6544)));
    // 0x1e80a8: 0xe45501c8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 2), 456), *(uint32_t*)&val); }
label_1e80ac:
    // 0x1e80ac: 0x7bbf01c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 448)));
label_1e80b0:
    // 0x1e80b0: 0x7bb501b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 432)));
label_1e80b4:
    // 0x1e80b4: 0x7bb401a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1e80b8: 0x7bb30190
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1e80bc: 0x7bb20180
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1e80c0: 0x7bb10170
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1e80c4: 0x7bb00160
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1e80c8: 0xc7b501d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 472)); ctx->f[21] = *(float*)&val; }
    // 0x1e80cc: 0xc7b401d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 464)); ctx->f[20] = *(float*)&val; }
    // 0x1e80d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 480));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PreTvContext__FP3RPL
// Address: 0x1e80d8 - 0x1e8118

void entry_1e8118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8118: 0x8fa30030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e811c: 0x8fa20034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x1e8120: 0x106200a2
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        entry_1e83ac(rdram, ctx, runtime); return;
    }
    // 0x1e8128: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e812c: 0x8c430458
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x1e8130: 0x10640018
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x1E8194; return;
    }
    // 0x1e8138: 0x8e220274
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 628)));
    // 0x1e813c: 0x8e031990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1e8140: 0xc44d02d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 724)); ctx->f[13] = *(float*)&val; }
    // 0x1e8144: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1e8148: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1e814c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1e8150: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x1e8158);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 452)); ctx->f[12] = *(float*)&val; }
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_1e8158
// Address: 0x1e8158 - 0x1e8178

void entry_1e8158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8158: 0x1440000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8194; return;
    }
    // 0x1e8160: 0x8e230274
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 628)));
    // 0x1e8164: 0xc46c02d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 724)); ctx->f[12] = *(float*)&val; }
    // 0x1e8168: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e816c: 0xc45401c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 452)); ctx->f[20] = *(float*)&val; }
    // 0x1e8170: 0xc050e50
    SET_GPR_U32(ctx, 31, 0x1e8178);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 456)); ctx->f[21] = *(float*)&val; }
    SetCmFov__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_1e8178
// Address: 0x1e8178 - 0x1e8180

void entry_1e8178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8178: 0xc051212
    SET_GPR_U32(ctx, 31, 0x1e8180);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    DrawCm__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_1e8180
// Address: 0x1e8180 - 0x1e818c

void entry_1e8180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8180: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1e8184: 0xc050e50
    SET_GPR_U32(ctx, 31, 0x1e818c);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetCmFov__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_1e818c
// Address: 0x1e818c - 0x1e819c

void entry_1e818c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e818c) {
        switch (ctx->pc) {
            case 0x1e8194: ctx->pc = 0; goto label_1e8194;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e818c: 0x8e021990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1e8190: 0xe45501c8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 2), 456), *(uint32_t*)&val); }
label_1e8194:
    // 0x1e8194: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1e819c);
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e819c
// Address: 0x1e819c - 0x1e81b4

void entry_1e819c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e819c: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1e81a0: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1e81a4: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1e81a8: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x1e81ac: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x1e81b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1e81b4
// Address: 0x1e81b4 - 0x1e81c8

void entry_1e81b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e81b4: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1e81b8: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x1e81bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e81c0: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x1e81c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 256));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_1e81c8
// Address: 0x1e81c8 - 0x1e821c

void entry_1e81c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e81c8: 0xc622021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 540)); ctx->f[2] = *(float*)&val; }
    // 0x1e81cc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e81d0: 0xc6350220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 544)); ctx->f[21] = *(float*)&val; }
    // 0x1e81d4: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1e81d8: 0xc6210234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 564)); ctx->f[1] = *(float*)&val; }
    // 0x1e81dc: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e81e0: 0xc6200238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 568)); ctx->f[0] = *(float*)&val; }
    // 0x1e81e4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e81e8: 0x46011040
    ctx->f[1] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1e81ec: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x1e81f0: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1e81f4: 0x4600a800
    ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    // 0x1e81f8: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x1e81fc: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1e8200: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1e8204: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1e8208: 0x4601bde9
    ctx->f[23] = std::min(ctx->f[23], ctx->f[1]);
    // 0x1e820c: 0x4615a568
    ctx->f[21] = std::max(ctx->f[20], ctx->f[21]);
    // 0x1e8210: 0x4600b5a9
    ctx->f[22] = std::min(ctx->f[22], ctx->f[0]);
    // 0x1e8214: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e821c);
    ctx->f[20] = std::max(ctx->f[20], ctx->f[2]);
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e821c
// Address: 0x1e821c - 0x1e827c

void entry_1e821c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e821c: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1e8220: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1e8224: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e8228: 0x4600b864
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[23]);
    // 0x1e822c: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1e8230: 0x4600a064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1e8234: 0x44070800
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[1]);
    // 0x1e8238: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e823c: 0x4600b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[0]);
    // 0x1e8240: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1e8244: 0x4600ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x1e8248: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x1e824c: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x1e8250: 0xe63025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    // 0x1e8254: 0x4600b024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[22]);
    // 0x1e8258: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1e825c: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x1e8260: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1e8264: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1e8268: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1e826c: 0x31c3c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 16));
    // 0x1e8270: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x1e8274: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1e827c);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1e827c
// Address: 0x1e827c - 0x1e8294

void entry_1e827c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e827c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8280: 0x3c070004
    SET_GPR_U32(ctx, 7, ((uint32_t)4 << 16));
    // 0x1e8284: 0x34e741ee
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 16878));
    // 0x1e8288: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1e828c: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e8294);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e8294
// Address: 0x1e8294 - 0x1e82a4

void entry_1e8294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8294: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8298: 0x24050047
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    // 0x1e829c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1e82a4);
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1e82a4
// Address: 0x1e82a4 - 0x1e82b4

void entry_1e82a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e82a4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e82a8: 0x2406005a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 90));
    // 0x1e82ac: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1e82b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1e82b4
// Address: 0x1e82b4 - 0x1e82c0

void entry_1e82b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e82b4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e82b8: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1e82c0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1e82c0
// Address: 0x1e82c0 - 0x1e82f4

void entry_1e82c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e82c0: 0x4619a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[25]);
    // 0x1e82c4: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1e82c8: 0x461aad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[26]);
    // 0x1e82cc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e82d0: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x1e82d4: 0x4618a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[24]);
    // 0x1e82d8: 0x4618ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[24]);
    // 0x1e82dc: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1e82e0: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x1e82e4: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x1e82e8: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1e82ec: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e82f4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e82f4
// Address: 0x1e82f4 - 0x1e8328

void entry_1e82f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e82f4: 0x4619bdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[25]);
    // 0x1e82f8: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1e82fc: 0x461ab580
    ctx->f[22] = FPU_ADD_S(ctx->f[22], ctx->f[26]);
    // 0x1e8300: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8304: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e8308: 0x4618bdc2
    ctx->f[23] = FPU_MUL_S(ctx->f[23], ctx->f[24]);
    // 0x1e830c: 0x4618b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[24]);
    // 0x1e8310: 0x4600b824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[23]);
    // 0x1e8314: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x1e8318: 0x4600b024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[22]);
    // 0x1e831c: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x1e8320: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e8328);
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e8328
// Address: 0x1e8328 - 0x1e833c

void entry_1e8328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8328: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e832c: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1e8330: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e8334: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e833c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e833c
// Address: 0x1e833c - 0x1e8350

void entry_1e833c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e833c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8340: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1e8344: 0x34c62001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 8193));
    // 0x1e8348: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1e8350);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1e8350
// Address: 0x1e8350 - 0x1e8364

void entry_1e8350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8350: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8354: 0x24070004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e8358: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e835c: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e8364);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e8364
// Address: 0x1e8364 - 0x1e8374

void entry_1e8364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8364: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8368: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e836c: 0xc0798aa
    SET_GPR_U32(ctx, 31, 0x1e8374);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DrawTvArea__FP2TVR4GIFSi(rdram, ctx, runtime); return;
}


// Function: entry_1e8374
// Address: 0x1e8374 - 0x1e837c

void entry_1e8374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8374: 0xc058480
    SET_GPR_U32(ctx, 31, 0x1e837c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1e837c
// Address: 0x1e837c - 0x1e8388

void entry_1e837c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e837c: 0x261022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8872));
    // 0x1e8380: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x1e8388);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1e8388
// Address: 0x1e8388 - 0x1e8390

void entry_1e8388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8388: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x1e8390);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_1e8390
// Address: 0x1e8390 - 0x1e839c

void entry_1e8390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8390: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e8394: 0xc07ba34
    SET_GPR_U32(ctx, 31, 0x1e839c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddVifGifs__4VIFSP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1e839c
// Address: 0x1e839c - 0x1e83a4

void entry_1e839c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e839c: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1e83a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1e83a4
// Address: 0x1e83a4 - 0x1e83ac

void entry_1e83a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e83a4: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1e83ac);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e83ac
// Address: 0x1e83ac - 0x1e83e0

void entry_1e83ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e83ac: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e83b0: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e83b4: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e83b8: 0xc7ba00a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[26] = *(float*)&val; }
    // 0x1e83bc: 0xc7b90098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[25] = *(float*)&val; }
    // 0x1e83c0: 0xc7b80090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[24] = *(float*)&val; }
    // 0x1e83c4: 0xc7b70088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[23] = *(float*)&val; }
    // 0x1e83c8: 0xc7b60080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[22] = *(float*)&val; }
    // 0x1e83cc: 0xc7b50078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[21] = *(float*)&val; }
    // 0x1e83d0: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1e83d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e83dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e83e0; return;
}


// Function: PostTvContext__FP3RPL
// Address: 0x1e83e0 - 0x1e842c

void entry_1e842c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e842c: 0x8fa30030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e8430: 0x8fa20034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x1e8434: 0x1062009b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E86A4; return;
    }
    // 0x1e843c: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1e8444);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e8444
// Address: 0x1e8444 - 0x1e8460

void entry_1e8444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8444: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x1e8448: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x1e844c: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x1e8450: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x1e8454: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x1e8458: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x1e8460);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1e8460
// Address: 0x1e8460 - 0x1e8474

void entry_1e8460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8460: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x1e8464: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x1e8468: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e846c: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x1e8474);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 512));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_1e8474
// Address: 0x1e8474 - 0x1e84d0

void entry_1e8474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8474: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x1e8478: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x1e847c: 0xc602021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 540)); ctx->f[2] = *(float*)&val; }
    // 0x1e8480: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8484: 0xc6150220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 544)); ctx->f[21] = *(float*)&val; }
    // 0x1e8488: 0x2407044e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1102));
    // 0x1e848c: 0xc6010238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 568)); ctx->f[1] = *(float*)&val; }
    // 0x1e8490: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1e8494: 0xc6000234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 564)); ctx->f[0] = *(float*)&val; }
    // 0x1e8498: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1e849c: 0x4601a840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[1]);
    // 0x1e84a0: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x1e84a4: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x1e84a8: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x1e84ac: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x1e84b0: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1e84b4: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1e84b8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1e84bc: 0x4601b5a9
    ctx->f[22] = std::min(ctx->f[22], ctx->f[1]);
    // 0x1e84c0: 0x4615a568
    ctx->f[21] = std::max(ctx->f[20], ctx->f[21]);
    // 0x1e84c4: 0x4600bde9
    ctx->f[23] = std::min(ctx->f[23], ctx->f[0]);
    // 0x1e84c8: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e84d0);
    ctx->f[20] = std::max(ctx->f[20], ctx->f[2]);
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e84d0
// Address: 0x1e84d0 - 0x1e84e4

void entry_1e84d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e84d0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e84d4: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1e84d8: 0x34c62001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 8193));
    // 0x1e84dc: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1e84e4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1e84e4
// Address: 0x1e84e4 - 0x1e8520

void entry_1e84e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e84e4: 0x4619ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[25]);
    // 0x1e84e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e84ec: 0x461aa500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[26]);
    // 0x1e84f0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e84f4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e84f8: 0x461bad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[27]);
    // 0x1e84fc: 0x4618a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[24]);
    // 0x1e8500: 0x4618ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[24]);
    // 0x1e8504: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x1e8508: 0x44120000
    SET_GPR_U32(ctx, 18, *(uint32_t*)&ctx->f[0]);
    // 0x1e850c: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x1e8510: 0x44130000
    SET_GPR_U32(ctx, 19, *(uint32_t*)&ctx->f[0]);
    // 0x1e8514: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e8518: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e8520);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e8520
// Address: 0x1e8520 - 0x1e855c

void entry_1e8520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8520: 0x4619b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[25]);
    // 0x1e8524: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8528: 0x461abdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[26]);
    // 0x1e852c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e8530: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e8534: 0x461bb580
    ctx->f[22] = FPU_ADD_S(ctx->f[22], ctx->f[27]);
    // 0x1e8538: 0x4618bdc2
    ctx->f[23] = FPU_MUL_S(ctx->f[23], ctx->f[24]);
    // 0x1e853c: 0x4618b582
    ctx->f[22] = FPU_MUL_S(ctx->f[22], ctx->f[24]);
    // 0x1e8540: 0x4600b824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[23]);
    // 0x1e8544: 0x44100000
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[0]);
    // 0x1e8548: 0x4600b024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[22]);
    // 0x1e854c: 0x44110000
    SET_GPR_U32(ctx, 17, *(uint32_t*)&ctx->f[0]);
    // 0x1e8550: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e8554: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e855c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e855c
// Address: 0x1e855c - 0x1e8570

void entry_1e855c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e855c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8560: 0x2407044e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1102));
    // 0x1e8564: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1e8568: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e8570);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e8570
// Address: 0x1e8570 - 0x1e8584

void entry_1e8570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8570: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8574: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1e8578: 0x34c6e001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 57345));
    // 0x1e857c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1e8584);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1e8584
// Address: 0x1e8584 - 0x1e85a0

void entry_1e8584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8584: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1e8588: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e858c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e8590: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e8594: 0x34e7fff0
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    // 0x1e8598: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e85a0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e85a0
// Address: 0x1e85a0 - 0x1e85bc

void entry_1e85a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e85a0: 0x3c070fff
    SET_GPR_U32(ctx, 7, ((uint32_t)4095 << 16));
    // 0x1e85a4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e85a8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e85ac: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e85b0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e85b4: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e85bc);
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65520));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e85bc
// Address: 0x1e85bc - 0x1e85d4

void entry_1e85bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e85bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e85c0: 0x3c070004
    SET_GPR_U32(ctx, 7, ((uint32_t)4 << 16));
    // 0x1e85c4: 0x34e741ee
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 16878));
    // 0x1e85c8: 0x24050046
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 70));
    // 0x1e85cc: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e85d4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e85d4
// Address: 0x1e85d4 - 0x1e85e8

void entry_1e85d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e85d4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e85d8: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x1e85dc: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x1e85e0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1e85e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1e85e8
// Address: 0x1e85e8 - 0x1e85f8

void entry_1e85e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e85e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e85ec: 0x2406005a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 90));
    // 0x1e85f0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1e85f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1e85f8
// Address: 0x1e85f8 - 0x1e8604

void entry_1e85f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e85f8: 0x3c058000
    SET_GPR_U32(ctx, 5, ((uint32_t)32768 << 16));
    // 0x1e85fc: 0xc058516
    SET_GPR_U32(ctx, 31, 0x1e8604);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_1e8604
// Address: 0x1e8604 - 0x1e861c

void entry_1e8604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8604: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8608: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e860c: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1e8610: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e8614: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e861c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e861c
// Address: 0x1e861c - 0x1e8634

void entry_1e861c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e861c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8620: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e8624: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e8628: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e862c: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x1e8634);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_1e8634
// Address: 0x1e8634 - 0x1e8648

void entry_1e8634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8634: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e8638: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1e863c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e8640: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1e8648);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e8648
// Address: 0x1e8648 - 0x1e8664

void entry_1e8648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8648: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1e864c: 0x3c0600df
    SET_GPR_U32(ctx, 6, ((uint32_t)223 << 16));
    // 0x1e8650: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x1e8654: 0x34c6027f
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 639));
    // 0x1e8658: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x1e865c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x1e8664);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_1e8664
// Address: 0x1e8664 - 0x1e866c

void entry_1e8664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8664: 0xc058480
    SET_GPR_U32(ctx, 31, 0x1e866c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1e866c
// Address: 0x1e866c - 0x1e867c

void entry_1e866c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e866c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1e8670: 0x261022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8872));
    // 0x1e8674: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x1e867c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1e867c
// Address: 0x1e867c - 0x1e8684

void entry_1e867c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e867c: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x1e8684);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_1e8684
// Address: 0x1e8684 - 0x1e8690

void entry_1e8684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8684: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e8688: 0xc07ba34
    SET_GPR_U32(ctx, 31, 0x1e8690);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddVifGifs__4VIFSP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1e8690
// Address: 0x1e8690 - 0x1e8698

void entry_1e8690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8690: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1e8698);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1e8698
// Address: 0x1e8698 - 0x1e86a0

void entry_1e8698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8698: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1e86a0);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e86a0
// Address: 0x1e86a0 - 0x1e86e0

void entry_1e86a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e86a0) {
        switch (ctx->pc) {
            case 0x1e86a4: ctx->pc = 0; goto label_1e86a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e86a0: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1e86a4:
    // 0x1e86a4: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e86a8: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e86ac: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e86b0: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e86b4: 0xc7bb00c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[27] = *(float*)&val; }
    // 0x1e86b8: 0xc7ba00c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[26] = *(float*)&val; }
    // 0x1e86bc: 0xc7b900b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[25] = *(float*)&val; }
    // 0x1e86c0: 0xc7b800b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[24] = *(float*)&val; }
    // 0x1e86c4: 0xc7b700a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[23] = *(float*)&val; }
    // 0x1e86c8: 0xc7b600a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[22] = *(float*)&val; }
    // 0x1e86cc: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1e86d0: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1e86d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e86dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e86e0; return;
}


// Function: SetTvSpeaker__FP2TVP7SPEAKER
// Address: 0x1e86e0 - 0x1e8724

void entry_1e8724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8724: 0xae120270
    WRITE32(ADD32(GPR_U32(ctx, 16), 624), GPR_U32(ctx, 18));
    // 0x1e8728: 0x262201f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 504));
    // 0x1e872c: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e8730: 0x8c430260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 608)));
    // 0x1e8734: 0x54640021
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 616)));
        ctx->pc = 0x1E87BC; return;
    }
    // 0x1e873c: 0xc079d18
    SET_GPR_U32(ctx, 31, 0x1e8744);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AcceptTvSpeaker__FP2TV(rdram, ctx, runtime); return;
}


// Function: entry_1e8744
// Address: 0x1e8744 - 0x1e8760

void entry_1e8744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8744: 0x8e020270
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 624)));
    // 0x1e8748: 0x1040000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8780; return;
    }
    // 0x1e8750: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e8754: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1e8758: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e8760);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e8760
// Address: 0x1e8760 - 0x1e876c

void entry_1e8760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8760: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e8764: 0xc079d46
    SET_GPR_U32(ctx, 31, 0x1e876c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetTvTvgs__FP2TV4TVGS(rdram, ctx, runtime); return;
}


// Function: entry_1e876c
// Address: 0x1e876c - 0x1e8778

void entry_1e876c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e876c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e8770: 0xc079d10
    SET_GPR_U32(ctx, 31, 0x1e8778);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTvTvs__FP2TV3TVS(rdram, ctx, runtime); return;
}


// Function: entry_1e8778
// Address: 0x1e8778 - 0x1e8790

void entry_1e8778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8778) {
        switch (ctx->pc) {
            case 0x1e8780: ctx->pc = 0; goto label_1e8780;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8778: 0x10000018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E87DC; return;
    }
label_1e8780:
    // 0x1e8780: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e8784: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1e8788: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e8790);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e8790
// Address: 0x1e8790 - 0x1e879c

void entry_1e8790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8790: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e8794: 0xc079d46
    SET_GPR_U32(ctx, 31, 0x1e879c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetTvTvgs__FP2TV4TVGS(rdram, ctx, runtime); return;
}


// Function: entry_1e879c
// Address: 0x1e879c - 0x1e87a8

void entry_1e879c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e879c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e87a0: 0xc079d10
    SET_GPR_U32(ctx, 31, 0x1e87a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTvTvs__FP2TV3TVS(rdram, ctx, runtime); return;
}


// Function: entry_1e87a8
// Address: 0x1e87a8 - 0x1e87b4

void entry_1e87a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e87a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e87ac: 0xc07a1fc
    SET_GPR_U32(ctx, 31, 0x1e87b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetTvReplace__FP2TVP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1e87b4
// Address: 0x1e87b4 - 0x1e87d8

void entry_1e87b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e87b4) {
        switch (ctx->pc) {
            case 0x1e87bc: ctx->pc = 0; goto label_1e87bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e87b4: 0x10000009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E87DC; return;
    }
label_1e87bc:
    // 0x1e87bc: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    // 0x1e87c0: 0x10400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E87DC; return;
    }
    // 0x1e87c8: 0x4600004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) < 0) {
        ctx->pc = 0x1E87DC; return;
    }
    // 0x1e87d0: 0xc079d46
    SET_GPR_U32(ctx, 31, 0x1e87d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetTvTvgs__FP2TV4TVGS(rdram, ctx, runtime); return;
}


// Function: entry_1e87d8
// Address: 0x1e87d8 - 0x1e87f0

void entry_1e87d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e87d8) {
        switch (ctx->pc) {
            case 0x1e87dc: ctx->pc = 0; goto label_1e87dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e87d8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1e87dc:
    // 0x1e87dc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e87e0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e87e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e87e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetTvReplace__FP2TVP3ALO
// Address: 0x1e87f0 - 0x1e8840

void entry_1e8854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8854: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1e8858: 0xae000c70
    WRITE32(ADD32(GPR_U32(ctx, 16), 3184), GPR_U32(ctx, 0));
    // 0x1e885c: 0xae020268
    WRITE32(ADD32(GPR_U32(ctx, 16), 616), GPR_U32(ctx, 2));
    // 0x1e8860: 0xae000274
    WRITE32(ADD32(GPR_U32(ctx, 16), 628), GPR_U32(ctx, 0));
    // 0x1e8864: 0xae000270
    WRITE32(ADD32(GPR_U32(ctx, 16), 624), GPR_U32(ctx, 0));
    // 0x1e8868: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e886c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e8870: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: tv__static_initialization_and_destruction_0
// Address: 0x1e8878 - 0x1e88b0

void FUN_001e88b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e88b0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1e88b4: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e88b8: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1e88bc: 0xc07a21e
    SET_GPR_U32(ctx, 31, 0x1e88c4);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    tv__static_initialization_and_destruction_0(rdram, ctx, runtime); return;
}


// Function: entry_1e88c4
// Address: 0x1e88c4 - 0x1e88d0

void entry_1e88c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e88c4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e88c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitUbg__FP3UBG
// Address: 0x1e88d0 - 0x1e88e4

void entry_1e88e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e88e4: 0x3c014a37
    SET_GPR_U32(ctx, 1, ((uint32_t)18999 << 16));
    // 0x1e88e8: 0x34211b00
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 6912));
    // 0x1e88ec: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1e88f0: 0x240202d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 728));
    // 0x1e88f4: 0x3c0146ea
    SET_GPR_U32(ctx, 1, ((uint32_t)18154 << 16));
    // 0x1e88f8: 0x34216000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 24576));
    // 0x1e88fc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e8900: 0x3c014be4
    SET_GPR_U32(ctx, 1, ((uint32_t)19428 << 16));
    // 0x1e8904: 0x3421e1c0
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 57792));
    // 0x1e8908: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1e890c: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x1e8910: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1e8914: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e8918: 0xae020c58
    WRITE32(ADD32(GPR_U32(ctx, 16), 3160), GPR_U32(ctx, 2));
    // 0x1e891c: 0xe6000c2c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3116), *(uint32_t*)&val); }
    // 0x1e8920: 0xe6010c14
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 3092), *(uint32_t*)&val); }
    // 0x1e8924: 0xe6020c10
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 3088), *(uint32_t*)&val); }
    // 0x1e8928: 0xe6030c24
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 3108), *(uint32_t*)&val); }
    // 0x1e892c: 0xe6030c20
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 3104), *(uint32_t*)&val); }
    // 0x1e8930: 0xae000c28
    WRITE32(ADD32(GPR_U32(ctx, 16), 3112), GPR_U32(ctx, 0));
    // 0x1e8934: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e8938: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e893c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e8944: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e8948; return;
}


// Function: PostUbgLoad__FP3UBG
// Address: 0x1e8948 - 0x1e8974

void entry_1e8974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8974: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1e8978: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x1e8980);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_1e8980
// Address: 0x1e8980 - 0x1e8998

void entry_1e8980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8980: 0x8e240c50
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 3152)));
    // 0x1e8984: 0x10800005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E899C; return;
    }
    // 0x1e898c: 0x240602d7
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 727));
    // 0x1e8990: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1e8998);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1e8998
// Address: 0x1e8998 - 0x1e89bc

void entry_1e8998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8998) {
        switch (ctx->pc) {
            case 0x1e899c: ctx->pc = 0; goto label_1e899c;
            case 0x1e89b0: ctx->pc = 0; goto label_1e89b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8998: 0xae220c54
    WRITE32(ADD32(GPR_U32(ctx, 17), 3156), GPR_U32(ctx, 2));
label_1e899c:
    // 0x1e899c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e89a0: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e89a4: 0xae220c90
    WRITE32(ADD32(GPR_U32(ctx, 17), 3216), GPR_U32(ctx, 2));
    // 0x1e89a8: 0x3c130026
    SET_GPR_U32(ctx, 19, ((uint32_t)38 << 16));
    // 0x1e89ac: 0x26300c80
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 3200));
label_1e89b0:
    // 0x1e89b0: 0x26641420
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 5152));
    // 0x1e89b4: 0xc0503fe
    SET_GPR_U32(ctx, 31, 0x1e89bc);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    IchkAllocChkmgr__FP6CHKMGR(rdram, ctx, runtime); return;
}


// Function: entry_1e89bc
// Address: 0x1e89bc - 0x1e89d4

void entry_1e89bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e89bc: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1e89c0: 0x2e420004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 4));
    // 0x1e89c4: 0x1440fffa
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E89B0; return;
    }
    // 0x1e89cc: 0xc059f82
    SET_GPR_U32(ctx, 31, 0x1e89d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PostGomerLoad__FP5GOMER(rdram, ctx, runtime); return;
}


// Function: entry_1e89d4
// Address: 0x1e89d4 - 0x1e89f0

void entry_1e89d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e89d4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e89d8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e89dc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e89e0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e89e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e89e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PsoPadUbgClosest__FP3UBGP6VECTOR
// Address: 0x1e89f0 - 0x1e8a50

void entry_1e8ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8ac0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e8ac4: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x1e8ac8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e8ad0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e8ad0
// Address: 0x1e8ad0 - 0x1e8ae4

void entry_1e8ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8ad0: 0x10400005
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8AE8; return;
    }
    // 0x1e8ad8: 0x24450140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 320));
    // 0x1e8adc: 0xc07a27c
    SET_GPR_U32(ctx, 31, 0x1e8ae4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PsoPadUbgClosest__FP3UBGP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1e8ae4
// Address: 0x1e8ae4 - 0x1e8b50

void entry_1e8ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8ae4) {
        switch (ctx->pc) {
            case 0x1e8ae8: ctx->pc = 0; goto label_1e8ae8;
            case 0x1e8af8: ctx->pc = 0; goto label_1e8af8;
            case 0x1e8b44: ctx->pc = 0; goto label_1e8b44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8ae4: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1e8ae8:
    // 0x1e8ae8: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e8aec: 0x26340c64
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 3172));
    // 0x1e8af0: 0x8e220c58
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3160)));
    // 0x1e8af4: 0x0
    // NOP
label_1e8af8:
    // 0x1e8af8: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1e8afc: 0x2831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 3)));
    // 0x1e8b00: 0x2444fd29
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294966569));
    // 0x1e8b04: 0x2c820007
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 7));
    // 0x1e8b08: 0x1040000e
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e8b44;
    }
    // 0x1e8b10: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e8b14: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1e8b18: 0x2442e650
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294960720));
    // 0x1e8b1c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1e8b20: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e8b24: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1e8b2c: 0x10000005
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 734));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e8b44;
    }
    // 0x1e8b34: 0x241202df
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 735));
    // 0x1e8b38: 0x240302de
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 734));
    // 0x1e8b3c: 0xb31026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 5), GPR_U32(ctx, 19)));
    // 0x1e8b40: 0x62900a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 3));
label_1e8b44:
    // 0x1e8b44: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1e8b48: 0xc04a708
    SET_GPR_U32(ctx, 31, 0x1e8b50);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    PsmaFindAlo__FP3ALO3OID(rdram, ctx, runtime); return;
}


// Function: entry_1e8b50
// Address: 0x1e8b50 - 0x1e8b60

void entry_1e8b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8b50: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e8b60(rdram, ctx, runtime); return;
    }
    // 0x1e8b58: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1e8b60);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1e8b60
// Address: 0x1e8b60 - 0x1e8c60

void entry_1e8b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8b60) {
        switch (ctx->pc) {
            case 0x1e8b74: ctx->pc = 0; goto label_1e8b74;
            case 0x1e8bc4: ctx->pc = 0; goto label_1e8bc4;
            case 0x1e8bf8: ctx->pc = 0; goto label_1e8bf8;
            case 0x1e8c14: ctx->pc = 0; goto label_1e8c14;
            case 0x1e8c20: ctx->pc = 0; goto label_1e8c20;
            case 0x1e8c2c: ctx->pc = 0; goto label_1e8c2c;
            case 0x1e8c34: ctx->pc = 0; goto label_1e8c34;
            case 0x1e8c3c: ctx->pc = 0; goto label_1e8c3c;
            case 0x1e8c40: ctx->pc = 0; goto label_1e8c40;
            case 0x1e8c48: ctx->pc = 0; goto label_1e8c48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8b60: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1e8b64: 0x2e020006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), 6));
    // 0x1e8b68: 0x5440ffe3
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3160)));
        ctx->pc = 0x1E8AF8; return;
    }
    // 0x1e8b70: 0x8e230c58
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 3160)));
label_1e8b74:
    // 0x1e8b74: 0x240202da
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 730));
    // 0x1e8b78: 0x50620012
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
        goto label_1e8bc4;
    }
    // 0x1e8b80: 0xda210100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x1e8b84: 0xda220190
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 400)));
    // 0x1e8b88: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e8b8c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1e8b90: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e8b94: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e8b98: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e8b9c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1e8ba0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1e8ba4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1e8ba8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1e8bac: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1e8bb0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e8bb4: 0x0
    // NOP
    // 0x1e8bb8: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1e8bc4;
    }
    // 0x1e8bc0: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
label_1e8bc4:
    // 0x1e8bc4: 0xae220c5c
    WRITE32(ADD32(GPR_U32(ctx, 17), 3164), GPR_U32(ctx, 2));
    // 0x1e8bc8: 0x10000054
    WRITE32(ADD32(GPR_U32(ctx, 17), 3196), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8D1C; return;
    }
    // 0x1e8bd0: 0x8e230c58
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 3160)));
    // 0x1e8bd4: 0x240402d9
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 729));
    // 0x1e8bd8: 0x10640011
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 730));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_1e8c20;
    }
    // 0x1e8be0: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 728));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e8bf8;
    }
    // 0x1e8be8: 0x1062000a
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e8c14;
    }
    // 0x1e8bf0: 0x10000015
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 3200));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e8c48;
    }
label_1e8bf8:
    // 0x1e8bf8: 0x240202da
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 730));
    // 0x1e8bfc: 0x1062000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 731));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e8c2c;
    }
    // 0x1e8c04: 0x1062000b
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1e8c34;
    }
    // 0x1e8c0c: 0x1000000e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 3200));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e8c48;
    }
label_1e8c14:
    // 0x1e8c14: 0xae240c58
    WRITE32(ADD32(GPR_U32(ctx, 17), 3160), GPR_U32(ctx, 4));
    // 0x1e8c18: 0x10000009
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e8c40;
    }
label_1e8c20:
    // 0x1e8c20: 0x240202da
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 730));
    // 0x1e8c24: 0x10000005
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e8c3c;
    }
label_1e8c2c:
    // 0x1e8c2c: 0x10000003
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e8c3c;
    }
label_1e8c34:
    // 0x1e8c34: 0x240202dc
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 732));
    // 0x1e8c38: 0x24130003
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 3));
label_1e8c3c:
    // 0x1e8c3c: 0xae220c58
    WRITE32(ADD32(GPR_U32(ctx, 17), 3160), GPR_U32(ctx, 2));
label_1e8c40:
    // 0x1e8c40: 0x131080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 2));
    // 0x1e8c44: 0x26230c80
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 3200));
label_1e8c48:
    // 0x1e8c48: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1e8c4c: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1e8c50: 0x24921420
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 4), 5152));
    // 0x1e8c54: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e8c58: 0xc050402
    SET_GPR_U32(ctx, 31, 0x1e8c60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FGetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_1e8c60
// Address: 0x1e8c60 - 0x1e8c78

void entry_1e8c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8c60: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1E8C7C; return;
    }
    // 0x1e8c68: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1e8c6c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e8c70: 0xc0547b6
    SET_GPR_U32(ctx, 31, 0x1e8c78);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    OnDifficultyTriggerCheckpoint__FP10DIFFICULTYP6CHKPNT(rdram, ctx, runtime); return;
}


// Function: entry_1e8c78
// Address: 0x1e8c78 - 0x1e8c84

void entry_1e8c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8c78) {
        switch (ctx->pc) {
            case 0x1e8c7c: ctx->pc = 0; goto label_1e8c7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8c78: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1e8c7c:
    // 0x1e8c7c: 0xc050410
    SET_GPR_U32(ctx, 31, 0x1e8c84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_1e8c84
// Address: 0x1e8c84 - 0x1e8c9c

void entry_1e8c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8c84: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1e8c88: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e8c8c: 0x531023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x1e8c90: 0x2484e248
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    // 0x1e8c94: 0xc06b018
    SET_GPR_U32(ctx, 31, 0x1e8c9c);
    WRITE32(ADD32(GPR_U32(ctx, 17), 3216), GPR_U32(ctx, 2));
    FUN_001ac060(rdram, ctx, runtime); return;
}


// Function: entry_1e8c9c
// Address: 0x1e8c9c - 0x1e8cb8

void entry_1e8c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8c9c: 0x10000020
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8D20; return;
    }
    // 0x1e8ca4: 0x8e240c54
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 3156)));
    // 0x1e8ca8: 0x10800004
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8CBC; return;
    }
    // 0x1e8cb0: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1e8cb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 733));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1e8cb8
// Address: 0x1e8cb8 - 0x1e8ccc

void entry_1e8cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8cb8) {
        switch (ctx->pc) {
            case 0x1e8cbc: ctx->pc = 0; goto label_1e8cbc;
            case 0x1e8cc0: ctx->pc = 0; goto label_1e8cc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8cb8: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1e8cbc:
    // 0x1e8cbc: 0x26300c64
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 3172));
label_1e8cc0:
    // 0x1e8cc0: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e8cc4: 0xc04a708
    SET_GPR_U32(ctx, 31, 0x1e8ccc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    PsmaFindAlo__FP3ALO3OID(rdram, ctx, runtime); return;
}


// Function: entry_1e8ccc
// Address: 0x1e8ccc - 0x1e8cdc

void entry_1e8ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8ccc: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e8cdc(rdram, ctx, runtime); return;
    }
    // 0x1e8cd4: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1e8cdc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 734));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1e8cdc
// Address: 0x1e8cdc - 0x1e8cfc

void entry_1e8cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8cdc: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1e8ce0: 0x2e420006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 6));
    // 0x1e8ce4: 0x1440fff6
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8CC0; return;
    }
    // 0x1e8cec: 0xae200c90
    WRITE32(ADD32(GPR_U32(ctx, 17), 3216), GPR_U32(ctx, 0));
    // 0x1e8cf0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e8cf4: 0xc06b018
    SET_GPR_U32(ctx, 31, 0x1e8cfc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    FUN_001ac060(rdram, ctx, runtime); return;
}


// Function: entry_1e8cfc
// Address: 0x1e8cfc - 0x1e8d04

void entry_1e8cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8cfc: 0xc0580fa
    SET_GPR_U32(ctx, 31, 0x1e8d04);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    DefeatBossFromWid(rdram, ctx, runtime); return;
}


// Function: entry_1e8d04
// Address: 0x1e8d04 - 0x1e8d10

void entry_1e8d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8d04: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1e8d08: 0xc0631fe
    SET_GPR_U32(ctx, 31, 0x1e8d10);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c7f8__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_1e8d10
// Address: 0x1e8d10 - 0x1e8d2c

void entry_1e8d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8d10) {
        switch (ctx->pc) {
            case 0x1e8d1c: ctx->pc = 0; goto label_1e8d1c;
            case 0x1e8d20: ctx->pc = 0; goto label_1e8d20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8d10: 0x10000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e8d20;
    }
    // 0x1e8d18: 0xae200c5c
    WRITE32(ADD32(GPR_U32(ctx, 17), 3164), GPR_U32(ctx, 0));
label_1e8d1c:
    // 0x1e8d1c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1e8d20:
    // 0x1e8d20: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1e8d24: 0xc072472
    SET_GPR_U32(ctx, 31, 0x1e8d2c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1e8d2c
// Address: 0x1e8d2c - 0x1e8d58

void entry_1e8d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8d2c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1e8d30: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e8d34: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e8d38: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e8d3c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e8d40: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e8d44: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e8d48: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e8d4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e8d54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e8d58; return;
}


// Function: SgsNextUbgAI__FP3UBG
// Address: 0x1e8d58 - 0x1e8d9c

void entry_1e8d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8d9c) {
        switch (ctx->pc) {
            case 0x1e8da0: ctx->pc = 0; goto label_1e8da0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8d9c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1e8da0:
    // 0x1e8da0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e8da4: 0xa0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1e8da8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FDetectUbg__FP3UBG
// Address: 0x1e8db0 - 0x1e8dd0

void entry_1e8e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8e3c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e8e40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DoUbgFreefallLanding__FP3UBG
// Address: 0x1e8e48 - 0x1e8e80

void entry_1e8e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8e80: 0x10400015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8ED8; return;
    }
    // 0x1e8e88: 0xc07a27c
    SET_GPR_U32(ctx, 31, 0x1e8e90);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 320));
    PsoPadUbgClosest__FP3UBGP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1e8e90
// Address: 0x1e8e90 - 0x1e8ec4

void entry_1e8e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8e90: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e8e94: 0x8e020c7c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3196)));
    // 0x1e8e98: 0x1222000f
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E8ED8; return;
    }
    // 0x1e8ea0: 0x8e020c5c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3164)));
    // 0x1e8ea4: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1e8ea8: 0x2182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 0), GPR_S32(ctx, 2)));
    // 0x1e8eac: 0x3100a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
    // 0x1e8eb0: 0x18400009
    WRITE32(ADD32(GPR_U32(ctx, 16), 3164), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1E8ED8; return;
    }
    // 0x1e8eb8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1e8ebc: 0xc04a708
    SET_GPR_U32(ctx, 31, 0x1e8ec4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    PsmaFindAlo__FP3ALO3OID(rdram, ctx, runtime); return;
}


// Function: entry_1e8ec4
// Address: 0x1e8ec4 - 0x1e8ed4

void entry_1e8ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8ec4: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e8ed4(rdram, ctx, runtime); return;
    }
    // 0x1e8ecc: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1e8ed4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 736));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1e8ed4
// Address: 0x1e8ed4 - 0x1e8ee0

void entry_1e8ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8ed4) {
        switch (ctx->pc) {
            case 0x1e8ed8: ctx->pc = 0; goto label_1e8ed8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8ed4: 0xae110c7c
    WRITE32(ADD32(GPR_U32(ctx, 16), 3196), GPR_U32(ctx, 17));
label_1e8ed8:
    // 0x1e8ed8: 0xc07273e
    SET_GPR_U32(ctx, 31, 0x1e8ee0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DoStepguardFreefallLanding__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1e8ee0
// Address: 0x1e8ee0 - 0x1e8ef8

void entry_1e8ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8ee0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e8ee4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e8ee8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e8eec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e8ef4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e8ef8; return;
}


// Function: UpdateUbgGoal__FP3UBGi
// Address: 0x1e8ef8 - 0x1e8f3c

void entry_1e8f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8f3c) {
        switch (ctx->pc) {
            case 0x1e8f44: ctx->pc = 0; goto label_1e8f44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8f3c: 0x10000016
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8F98; return;
    }
label_1e8f44:
    // 0x1e8f44: 0x8e040c60
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3168)));
    // 0x1e8f48: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1e8f50);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1e8f50
// Address: 0x1e8f50 - 0x1e8f5c

void entry_1e8f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8f50: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e8f54: 0xc072106
    SET_GPR_U32(ctx, 31, 0x1e8f5c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1e8f5c
// Address: 0x1e8f5c - 0x1e8f70

void entry_1e8f5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8f5c) {
        switch (ctx->pc) {
            case 0x1e8f64: ctx->pc = 0; goto label_1e8f64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8f5c: 0x1000000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8F98; return;
    }
label_1e8f64:
    // 0x1e8f64: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x1e8f68: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e8f70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e8f70
// Address: 0x1e8f70 - 0x1e8f84

void entry_1e8f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8f70: 0x10400009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8F98; return;
    }
    // 0x1e8f78: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e8f7c: 0xc072106
    SET_GPR_U32(ctx, 31, 0x1e8f84);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 320));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1e8f84
// Address: 0x1e8f84 - 0x1e8f94

void entry_1e8f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8f84) {
        switch (ctx->pc) {
            case 0x1e8f8c: ctx->pc = 0; goto label_1e8f8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8f84: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8F98; return;
    }
label_1e8f8c:
    // 0x1e8f8c: 0xc072302
    SET_GPR_U32(ctx, 31, 0x1e8f94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateStepguardGoal__FP9STEPGUARDi(rdram, ctx, runtime); return;
}


// Function: entry_1e8f94
// Address: 0x1e8f94 - 0x1e8fa8

void entry_1e8f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8f94) {
        switch (ctx->pc) {
            case 0x1e8f98: ctx->pc = 0; goto label_1e8f98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8f94: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1e8f98:
    // 0x1e8f98: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e8f9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e8fa4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e8fa8; return;
}


// Function: UpdateUbgSgs__FP3UBG
// Address: 0x1e8fa8 - 0x1e8fc8

void entry_1e8fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8fc8) {
        switch (ctx->pc) {
            case 0x1e8fd0: ctx->pc = 0; goto label_1e8fd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8fc8: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E8FDC; return;
    }
label_1e8fd0:
    // 0x1e8fd0: 0xc07238a
    SET_GPR_U32(ctx, 31, 0x1e8fd8);
    UpdateStepguardSgs__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1e8fd8
// Address: 0x1e8fd8 - 0x1e8fe8

void entry_1e8fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e8fd8) {
        switch (ctx->pc) {
            case 0x1e8fdc: ctx->pc = 0; goto label_1e8fdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e8fd8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1e8fdc:
    // 0x1e8fdc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e8fe4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e8fe8; return;
}


// Function: FUN_001e8fe8
// Address: 0x1e8fe8 - 0x1e8ff8

void FUN_001e8fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8fe8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1e8fec: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1e8ff0: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x1e8ff8);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e8ff8
// Address: 0x1e8ff8 - 0x1e9010

void entry_1e8ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e8ff8: 0x10400007
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9018; return;
    }
    // 0x1e9000: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x1e9004: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1e9008: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e9010);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e9010
// Address: 0x1e9010 - 0x1e9028

void entry_1e9010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9010) {
        switch (ctx->pc) {
            case 0x1e9018: ctx->pc = 0; goto label_1e9018;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9010: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E902C; return;
    }
label_1e9018:
    // 0x1e9018: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x1e901c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e9020: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e9028);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e9028
// Address: 0x1e9028 - 0x1e9038

void entry_1e9028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9028) {
        switch (ctx->pc) {
            case 0x1e902c: ctx->pc = 0; goto label_1e902c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9028: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1e902c:
    // 0x1e902c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e9034: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e9038; return;
}


// Function: FIgnoreUbgIntersection__FP3UBGP2SO
// Address: 0x1e9038 - 0x1e9078

void entry_1e9078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9078: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e907c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e9084: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e9088; return;
}


// Function: StartupUi__Fv
// Address: 0x1e9088 - 0x1e909c

void entry_1e909c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e909c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e90a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitUi__FP2UI
// Address: 0x1e90a8 - 0x1e90cc

void entry_1e90cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e90cc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e90d0: 0xae00000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 0));
    // 0x1e90d4: 0xae02002c
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 2));
    // 0x1e90d8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e90dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e90e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostUiLoad__FP2UI
// Address: 0x1e90e8 - 0x1e90f8

void entry_1e90f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e90f8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e90fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e9104: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e9108; return;
}


// Function: UpdateUi__FP2UI
// Address: 0x1e9108 - 0x1e91b4

void entry_1e91b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e91b4) {
        switch (ctx->pc) {
            case 0x1e91b8: ctx->pc = 0; goto label_1e91b8;
            case 0x1e91dc: ctx->pc = 0; goto label_1e91dc;  // ADDED: Handle jump table target
            case 0x1e9218: ctx->pc = 0; goto label_1e9218;
            case 0x1e921c: ctx->pc = 0; goto label_1e921c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e91b4: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
label_1e91b8:
    // 0x1e91b8: 0x2c620009
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 9));
    // 0x1e91bc: 0x10400092
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9408; return;
    }
    // 0x1e91c4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1e91c8: 0x2442e670
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294960752));
    // 0x1e91cc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1e91d0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e91d4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
label_1e91dc:  // ADDED: Label for jump table target
    // 0x1e91dc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e91e0: 0x8c6201b8
    // PATCHED: Force $2 = 1 to bypass game state wait loop
    // Original: SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 440)));
    SET_GPR_U32(ctx, 2, 1);  // Force non-zero to proceed
    // 0x1e91e4: 0x1440000d
    // PATCHED: Set $6 = 1 instead of 0, so that label_1e921c proceeds to PexitDefault
    // Original: SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SET_GPR_U64(ctx, 6, 1);  // Force non-zero to continue past label_1e921c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e921c;
    }
    // 0x1e91ec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e91f0: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e91f4: 0x24454a40
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 19008));
    // 0x1e91f8: 0x8ca40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 24)));
    // 0x1e91fc: 0x10830006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_1e9218;
    }
    // 0x1e9204: 0x14820005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_1e921c;
    }
    // 0x1e920c: 0x8ca3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x1e9210: 0x14620002
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1e921c;
    }
label_1e9218:
    // 0x1e9218: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
label_1e921c:
    // 0x1e921c: 0x10c0007b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E940C; return;
    }
    // 0x1e9224: 0xc07d0de
    SET_GPR_U32(ctx, 31, 0x1e922c);
    PexitDefault__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e922c
// Address: 0x1e922c - 0x1e9234

void entry_1e922c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e922c: 0xc07d202
    SET_GPR_U32(ctx, 31, 0x1e9234);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    TriggerExit__FP4EXIT(rdram, ctx, runtime); return;
}


// Function: entry_1e9234
// Address: 0x1e9234 - 0x1e9254

void entry_1e9234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9234: 0x10000075
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E940C; return;
    }
    // 0x1e923c: 0x964300aa
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 170)));
    // 0x1e9240: 0x30620800
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 2048));
    // 0x1e9244: 0x10400013
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9294; return;
    }
    // 0x1e924c: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1e9254);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2048));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1e9254
// Address: 0x1e9254 - 0x1e9270

void entry_1e9254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9254: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e9258: 0x24444a40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 19008));
    // 0x1e925c: 0x8c834f48
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 20296)));
    // 0x1e9260: 0x10600005
    WRITE32(ADD32(GPR_U32(ctx, 4), 20292), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9278; return;
    }
    // 0x1e9268: 0xc06315a
    SET_GPR_U32(ctx, 31, 0x1e9270);
    FUN_0018c568(rdram, ctx, runtime); return;
}


// Function: entry_1e9270
// Address: 0x1e9270 - 0x1e9284

void entry_1e9270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9270) {
        switch (ctx->pc) {
            case 0x1e9278: ctx->pc = 0; goto label_1e9278;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9270: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e9284(rdram, ctx, runtime); return;
    }
label_1e9278:
    // 0x1e9278: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e927c: 0xc05817a
    SET_GPR_U32(ctx, 31, 0x1e9284);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    InitGameState__FP2GS(rdram, ctx, runtime); return;
}


// Function: entry_1e9284
// Address: 0x1e9284 - 0x1e928c

void entry_1e9284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9284: 0xc058252
    SET_GPR_U32(ctx, 31, 0x1e928c);
    FUN_00160948(rdram, ctx, runtime); return;
}


// Function: entry_1e928c
// Address: 0x1e928c - 0x1e92a8

void entry_1e928c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e928c) {
        switch (ctx->pc) {
            case 0x1e9294: ctx->pc = 0; goto label_1e9294;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e928c: 0x1000005e
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9408; return;
    }
label_1e9294:
    // 0x1e9294: 0x30620100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 256));
    // 0x1e9298: 0x5040005c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x1E940C; return;
    }
    // 0x1e92a0: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1e92a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 256));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1e92a8
// Address: 0x1e92a8 - 0x1e92bc

void entry_1e92a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e92a8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e92ac: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e92b0: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x1e92b4: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1e92bc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 23));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1e92bc
// Address: 0x1e92bc - 0x1e933c

void entry_1e92bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e92bc) {
        switch (ctx->pc) {
            case 0x1e932c: ctx->pc = 0; goto label_1e932c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e92bc: 0x10000052
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9408; return;
    }
    // 0x1e92c4: 0x8e622c6c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 11372)));
    // 0x1e92c8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1e92cc: 0x1440004f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E940C; return;
    }
    // 0x1e92d4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e92d8: 0x8c435f84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24452)));
    // 0x1e92dc: 0x1460004b
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E940C; return;
    }
    // 0x1e92e4: 0x964200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 170)));
    // 0x1e92e8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e92ec: 0x30420800
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2048));
    // 0x1e92f0: 0x5440000e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
        goto label_1e932c;
    }
    // 0x1e92f8: 0x8e430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1e92fc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1e9300: 0x14620014
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 256));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E9354; return;
    }
    // 0x1e9308: 0x26821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x1e930c: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1e9310: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1e9314: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1e9318: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e931c: 0x0
    // NOP
    // 0x1e9320: 0x4500000c
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 256));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E9354; return;
    }
    // 0x1e9328: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
label_1e932c:
    // 0x1e932c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e9330: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x1e9334: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1e933c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1e933c
// Address: 0x1e933c - 0x1e934c

void entry_1e933c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e933c: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1e9340: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e9344: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1e934c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2048));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1e934c
// Address: 0x1e934c - 0x1e9380

void entry_1e934c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e934c) {
        switch (ctx->pc) {
            case 0x1e9354: ctx->pc = 0; goto label_1e9354;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e934c: 0x1000002f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E940C; return;
    }
label_1e9354:
    // 0x1e9354: 0x1040002c
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9408; return;
    }
    // 0x1e935c: 0x2445f808
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294965256));
    // 0x1e9360: 0x8ca20260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 608)));
    // 0x1e9364: 0x10400029
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E940C; return;
    }
    // 0x1e936c: 0x8c4202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 720)));
    // 0x1e9370: 0x14400026
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E940C; return;
    }
    // 0x1e9378: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x1e9380);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1e9380
// Address: 0x1e9380 - 0x1e9390

void entry_1e9380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9380: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1e9384: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1e9388: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1e9390);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 256));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1e9390
// Address: 0x1e9390 - 0x1e93c8

void entry_1e9390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9390: 0x1000001e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E940C; return;
    }
    // 0x1e9398: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x1e939c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1e93a0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e93a4: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e93a8: 0x0
    // NOP
    // 0x1e93ac: 0x45000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1E93D0; return;
    }
    // 0x1e93b4: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1e93b8: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x1e93bc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e93c0: 0xc07a63a
    SET_GPR_U32(ctx, 31, 0x1e93c8);
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    SetUiUPause__FP2UIf(rdram, ctx, runtime); return;
}


// Function: entry_1e93c8
// Address: 0x1e93c8 - 0x1e93fc

void entry_1e93c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e93c8) {
        switch (ctx->pc) {
            case 0x1e93d0: ctx->pc = 0; goto label_1e93d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e93c8: 0x10000010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E940C; return;
    }
label_1e93d0:
    // 0x1e93d0: 0x1000000d
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9408; return;
    }
    // 0x1e93d8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1e93dc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1e93e0: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1e93e4: 0x0
    // NOP
    // 0x1e93e8: 0x45020007
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 3));
        ctx->pc = 0x1E9408; return;
    }
    // 0x1e93f0: 0x4614a300
    ctx->f[12] = FPU_ADD_S(ctx->f[20], ctx->f[20]);
    // 0x1e93f4: 0xc07a63a
    SET_GPR_U32(ctx, 31, 0x1e93fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetUiUPause__FP2UIf(rdram, ctx, runtime); return;
}


// Function: entry_1e93fc
// Address: 0x1e93fc - 0x1e9414

void entry_1e93fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e93fc) {
        switch (ctx->pc) {
            case 0x1e9408: ctx->pc = 0; goto label_1e9408;
            case 0x1e940c: ctx->pc = 0; goto label_1e940c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e93fc: 0x10000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e940c;
    }
    // 0x1e9404: 0x24150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
label_1e9408:
    // 0x1e9408: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1e940c:
    // 0x1e940c: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x1e9414);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_1e9414
// Address: 0x1e9414 - 0x1e9448

void entry_1e9414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9414: 0x8e02002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 44)));
    // 0x1e9418: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1e941c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1e9420: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1e9424: 0x8c44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x1e9428: 0x10800009
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9450; return;
    }
    // 0x1e9430: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e9434: 0x8c420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1e9438: 0x10400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e9460(rdram, ctx, runtime); return;
    }
    // 0x1e9440: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e9448);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e9448
// Address: 0x1e9448 - 0x1e9460

void entry_1e9448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9448) {
        switch (ctx->pc) {
            case 0x1e9450: ctx->pc = 0; goto label_1e9450;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9448: 0x10000005
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e9460(rdram, ctx, runtime); return;
    }
label_1e9450:
    // 0x1e9450: 0x12a00003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        entry_1e9460(rdram, ctx, runtime); return;
    }
    // 0x1e9458: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x1e9460);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_1e9460
// Address: 0x1e9460 - 0x1e9468

void entry_1e9460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9460: 0xc050278
    SET_GPR_U32(ctx, 31, 0x1e9468);
    UpdateCd__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e9468
// Address: 0x1e9468 - 0x1e9470

void entry_1e9468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9468: 0xc06a7f4
    SET_GPR_U32(ctx, 31, 0x1e9470);
    UpdateBlots__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e9470
// Address: 0x1e9470 - 0x1e9498

void entry_1e9470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9470: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1e9474: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e9478: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e947c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e9480: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e9484: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e9488: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e948c: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1e9490: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PushUiActiveBlot__FP2UIP4BLOT
// Address: 0x1e9498 - 0x1e94b8

void entry_1e94b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e94b8: 0x10400006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e94d4(rdram, ctx, runtime); return;
    }
    // 0x1e94c0: 0x8e03002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 44)));
    // 0x1e94c4: 0x14620005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E94DC; return;
    }
    // 0x1e94cc: 0xc06fa8a
    SET_GPR_U32(ctx, 31, 0x1e94d4);
    PauseVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e94d4
// Address: 0x1e94d4 - 0x1e950c

void entry_1e94d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e94d4) {
        switch (ctx->pc) {
            case 0x1e94dc: ctx->pc = 0; goto label_1e94dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e94d4: 0x8e03002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 44)));
    // 0x1e94d8: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
label_1e94dc:
    // 0x1e94dc: 0x1440000b
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1e950c(rdram, ctx, runtime); return;
    }
    // 0x1e94e4: 0x2462ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1e94e8: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1e94ec: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1e94f0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e94f4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e94f8: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x1e94fc: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1E9510; return;
    }
    // 0x1e9504: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e950c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e950c
// Address: 0x1e950c - 0x1e9524

void entry_1e950c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e950c) {
        switch (ctx->pc) {
            case 0x1e9510: ctx->pc = 0; goto label_1e9510;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e950c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_1e9510:
    // 0x1e9510: 0x8c42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x1e9514: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e9524(rdram, ctx, runtime); return;
    }
    // 0x1e951c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e9524);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e9524
// Address: 0x1e9524 - 0x1e9554

void entry_1e9524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9524: 0x8e02002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 44)));
    // 0x1e9528: 0x21880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1e952c: 0x2431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x1e9530: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1e9534: 0xac710000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 17));
    // 0x1e9538: 0xae02002c
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 2));
    // 0x1e953c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1e9540: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1e9544: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9558; return;
    }
    // 0x1e954c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e9554);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e9554
// Address: 0x1e9554 - 0x1e9570

void entry_1e9554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9554) {
        switch (ctx->pc) {
            case 0x1e9558: ctx->pc = 0; goto label_1e9558;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9554: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1e9558:
    // 0x1e9558: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e955c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e9560: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e9564: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e956c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e9570; return;
}


// Function: PopUiActiveBlot__FP2UI
// Address: 0x1e9570 - 0x1e95bc

void entry_1e95bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e95bc: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1e95c0: 0x8c42001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x1e95c4: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 44)));
        ctx->pc = 0x1E95D8; return;
    }
    // 0x1e95cc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e95d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e95d4
// Address: 0x1e95d4 - 0x1e9608

void entry_1e95d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e95d4) {
        switch (ctx->pc) {
            case 0x1e95d8: ctx->pc = 0; goto label_1e95d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e95d4: 0x8e23002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 44)));
label_1e95d8:
    // 0x1e95d8: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    // 0x1e95dc: 0x1440000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1e9608(rdram, ctx, runtime); return;
    }
    // 0x1e95e4: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1e95e8: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1e95ec: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e95f0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e95f4: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x1e95f8: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e9608(rdram, ctx, runtime); return;
    }
    // 0x1e9600: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e9608);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e9608
// Address: 0x1e9608 - 0x1e9610

void entry_1e9608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9608: 0xc06f97a
    SET_GPR_U32(ctx, 31, 0x1e9610);
    SetVagUnpaused__FUiUl(rdram, ctx, runtime); return;
}


// Function: entry_1e9610
// Address: 0x1e9610 - 0x1e962c

void entry_1e9610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9610: 0x10400006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e962c(rdram, ctx, runtime); return;
    }
    // 0x1e9618: 0x8e23002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 44)));
    // 0x1e961c: 0x14620004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1E9630; return;
    }
    // 0x1e9624: 0xc06fa94
    SET_GPR_U32(ctx, 31, 0x1e962c);
    ContinueVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e962c
// Address: 0x1e962c - 0x1e9648

void entry_1e962c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e962c) {
        switch (ctx->pc) {
            case 0x1e9630: ctx->pc = 0; goto label_1e9630;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e962c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1e9630:
    // 0x1e9630: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e9634: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e9638: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e963c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e9644: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e9648; return;
}


// Function: DrawUi__Fv
// Address: 0x1e9648 - 0x1e9658

void entry_1e9658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9658: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e965c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e9664: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e9668; return;
}


// Function: RenderUi__Fv
// Address: 0x1e9668 - 0x1e9678

void entry_1e9678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9678: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e967c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e9684: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e9688; return;
}


// Function: ResetUi__FP2UI
// Address: 0x1e9688 - 0x1e96a8

void entry_1e96a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e96a8: 0x8e02002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 44)));
    // 0x1e96ac: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1e96b0: 0x1040fffb
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E96A0; return;
    }
    // 0x1e96b8: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1e96bc: 0xae030030
    WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 3));
    // 0x1e96c0: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1e96c4: 0xae02002c
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 2));
    // 0x1e96c8: 0x24c62c70
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 11376));
    // 0x1e96cc: 0xae00000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 0));
    // 0x1e96d0: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1e96d4: 0xc069f66
    SET_GPR_U32(ctx, 31, 0x1e96dc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 188)));
    SetRumbleRums__FP6RUMBLE4RUMS(rdram, ctx, runtime); return;
}


// Function: entry_1e96dc
// Address: 0x1e96dc - 0x1e96e4

void entry_1e96dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e96dc: 0xc06a830
    SET_GPR_U32(ctx, 31, 0x1e96e4);
    ResetBlots__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e96e4
// Address: 0x1e96e4 - 0x1e96f8

void entry_1e96e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e96e4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e96e8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e96ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e96f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e96f8; return;
}


// Function: SetUiUis__FP2UI3UIS
// Address: 0x1e96f8 - 0x1e9758

void entry_1e9758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9758: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e975c: 0x8c832b98
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 11160)));
    // 0x1e9760: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e9764: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e976c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11160));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e976c
// Address: 0x1e976c - 0x1e9778

void entry_1e976c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e976c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e9770: 0xc077694
    SET_GPR_U32(ctx, 31, 0x1e9778);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    DecrementSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1e9778
// Address: 0x1e9778 - 0x1e97c8

void entry_1e9778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9778) {
        switch (ctx->pc) {
            case 0x1e977c: ctx->pc = 0; goto label_1e977c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9778: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
label_1e977c:
    // 0x1e977c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e9780: 0x2e230009
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 17), 9));
    // 0x1e9784: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x1e9788: 0x10600051
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1e98d0(rdram, ctx, runtime); return;
    }
    // 0x1e9790: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1e9794: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1e9798: 0x2442e6a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294960800));
    // 0x1e979c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1e97a0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1e97a4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1e97ac: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e97b0: 0x24444a40
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 19008));
    // 0x1e97b4: 0x8c830018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x1e97b8: 0x54600004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
        ctx->pc = 0x1E97CC; return;
    }
    // 0x1e97c0: 0xc06305e
    SET_GPR_U32(ctx, 31, 0x1e97c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FUN_0018c178_FP4SAVEi(rdram, ctx, runtime); return;
}


// Function: entry_1e97c8
// Address: 0x1e97c8 - 0x1e97d8

void entry_1e97c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e97c8) {
        switch (ctx->pc) {
            case 0x1e97cc: ctx->pc = 0; goto label_1e97cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e97c8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
label_1e97cc:
    // 0x1e97cc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1e97d0: 0xc07c088
    SET_GPR_U32(ctx, 31, 0x1e97d8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    SetWipeWipes__FP4WIPE5WIPES(rdram, ctx, runtime); return;
}


// Function: entry_1e97d8
// Address: 0x1e97d8 - 0x1e97f8

void entry_1e97d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e97d8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e97dc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e97e0: 0x10000023
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9870; return;
    }
    // 0x1e97e8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e97ec: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e97f0: 0xc07a63a
    SET_GPR_U32(ctx, 31, 0x1e97f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetUiUPause__FP2UIf(rdram, ctx, runtime); return;
}


// Function: entry_1e97f8
// Address: 0x1e97f8 - 0x1e980c

void entry_1e97f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e97f8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e97fc: 0x8c832930
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 10544)));
    // 0x1e9800: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1e9804: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e980c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 10544));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e980c
// Address: 0x1e980c - 0x1e9820

void entry_1e980c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e980c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e9810: 0x8c832b98
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 11160)));
    // 0x1e9814: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1e9818: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e9820);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11160));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e9820
// Address: 0x1e9820 - 0x1e982c

void entry_1e9820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9820: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e9824: 0xc077688
    SET_GPR_U32(ctx, 31, 0x1e982c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    IncrementSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1e982c
// Address: 0x1e982c - 0x1e9834

void entry_1e982c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e982c: 0xc069f9c
    SET_GPR_U32(ctx, 31, 0x1e9834);
    FUN_001A7E70__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e9834
// Address: 0x1e9834 - 0x1e985c

void entry_1e9834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9834: 0x10000027
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E98D4; return;
    }
    // 0x1e983c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e9840: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e9844: 0x1000000a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9870; return;
    }
    // 0x1e984c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1e9850: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1e9854: 0xc07a63a
    SET_GPR_U32(ctx, 31, 0x1e985c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetUiUPause__FP2UIf(rdram, ctx, runtime); return;
}


// Function: entry_1e985c
// Address: 0x1e985c - 0x1e9878

void entry_1e985c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e985c) {
        switch (ctx->pc) {
            case 0x1e9870: ctx->pc = 0; goto label_1e9870;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e985c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1e9860: 0x2402ff9c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967196));
    // 0x1e9864: 0x1000001a
    WRITE32(ADD32(GPR_U32(ctx, 3), 18232), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1e98d0(rdram, ctx, runtime); return;
    }
    // 0x1e986c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
label_1e9870:
    // 0x1e9870: 0xc07a63a
    SET_GPR_U32(ctx, 31, 0x1e9878);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetUiUPause__FP2UIf(rdram, ctx, runtime); return;
}


// Function: entry_1e9878
// Address: 0x1e9878 - 0x1e9894

void entry_1e9878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9878: 0x10000016
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E98D4; return;
    }
    // 0x1e9880: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e9884: 0x8c83c6c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294952648)));
    // 0x1e9888: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e988c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e9894);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294952648));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e9894
// Address: 0x1e9894 - 0x1e98a8

void entry_1e9894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9894: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e9898: 0x8c83c948
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294953288)));
    // 0x1e989c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e98a0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e98a8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294953288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e98a8
// Address: 0x1e98a8 - 0x1e98bc

void entry_1e98a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e98a8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e98ac: 0x8c83cbc8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294953928)));
    // 0x1e98b0: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e98b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e98bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294953928));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e98bc
// Address: 0x1e98bc - 0x1e98d0

void entry_1e98bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e98bc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1e98c0: 0x8c83ce48
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294954568)));
    // 0x1e98c4: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1e98c8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e98d0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294954568));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e98d0
// Address: 0x1e98d0 - 0x1e98e8

void entry_1e98d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e98d0) {
        switch (ctx->pc) {
            case 0x1e98d4: ctx->pc = 0; goto label_1e98d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e98d0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1e98d4:
    // 0x1e98d4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e98d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e98dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e98e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e98e8; return;
}


// Function: SetUiUPause__FP2UIf
// Address: 0x1e98e8 - 0x1e9940

void entry_1e9940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9940: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1e9944: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e9948: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1e9950);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1e9950
// Address: 0x1e9950 - 0x1e9958

void entry_1e9950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9950: 0xc050bb4
    SET_GPR_U32(ctx, 31, 0x1e9958);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    SetClockRate__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1e9958
// Address: 0x1e9958 - 0x1e9970

void entry_1e9958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9958: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e995c: 0xc7b50018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[21] = *(float*)&val; }
    // 0x1e9960: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x1e9964: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e996c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e9970; return;
}


// Function: FUN_001e9970__Fv
// Address: 0x1e9970 - 0x1e9990

void FUN_001e9970__Fv(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9970: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e9974: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1e9978: 0x8c435f84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24452)));
    // 0x1e997c: 0x1460001f
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E99FC; return;
    }
    // 0x1e9984: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e9988: 0xc0776a0
    SET_GPR_U32(ctx, 31, 0x1e9990);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    IsSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1e9990
// Address: 0x1e9990 - 0x1e9a10

void entry_1e9990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9990) {
        switch (ctx->pc) {
            case 0x1e99bc: ctx->pc = 0; goto label_1e99bc;
            case 0x1e99fc: ctx->pc = 0; goto label_1e99fc;
            case 0x1e9a00: ctx->pc = 0; goto label_1e9a00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9990: 0x1440001b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e9a00;
    }
    // 0x1e9998: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e999c: 0x2442ff68
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967144));
    // 0x1e99a0: 0x8c43025c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 604)));
    // 0x1e99a4: 0x50600005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
        goto label_1e99bc;
    }
    // 0x1e99ac: 0x8c420260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 608)));
    // 0x1e99b0: 0x14400013
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e9a00;
    }
    // 0x1e99b8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1e99bc:
    // 0x1e99bc: 0x2442f808
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965256));
    // 0x1e99c0: 0x8c43025c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 604)));
    // 0x1e99c4: 0x5460000e
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1e9a00;
    }
    // 0x1e99cc: 0x8c420250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 592)));
    // 0x1e99d0: 0x1440000b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e9a00;
    }
    // 0x1e99d8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e99dc: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1e99e0: 0x8c440458
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x1e99e4: 0x10830005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_1e99fc;
    }
    // 0x1e99ec: 0x10820003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_1e99fc;
    }
    // 0x1e99f4: 0x14820002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_1e9a00;
    }
label_1e99fc:
    // 0x1e99fc: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1e9a00:
    // 0x1e9a00: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1e9a04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e9a0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e9a10; return;
}


// Function: FUN_001e9a10__Fv
// Address: 0x1e9a10 - 0x1e9a68

void FUN_001e9a10__Fv(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9a10) {
        switch (ctx->pc) {
            case 0x1e9a58: ctx->pc = 0; goto label_1e9a58;
            case 0x1e9a60: ctx->pc = 0; goto label_1e9a60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9a10: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e9a14: 0x8c435f84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24452)));
    // 0x1e9a18: 0x1460000f
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1e9a58;
    }
    // 0x1e9a20: 0x2442ff68
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967144));
    // 0x1e9a24: 0x8c43025c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 604)));
    // 0x1e9a28: 0x1460000b
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1e9a58;
    }
    // 0x1e9a30: 0x8c420250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 592)));
    // 0x1e9a34: 0x14400008
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e9a58;
    }
    // 0x1e9a3c: 0x2442f808
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965256));
    // 0x1e9a40: 0x8c43025c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 604)));
    // 0x1e9a44: 0x14600004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1e9a58;
    }
    // 0x1e9a4c: 0x8c420250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 592)));
    // 0x1e9a50: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e9a60;
    }
label_1e9a58:
    // 0x1e9a58: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1e9a60:
    // 0x1e9a60: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001e9a68__Fv
// Address: 0x1e9a68 - 0x1e9ad8

void FUN_001e9a68__Fv(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9a68) {
        switch (ctx->pc) {
            case 0x1e9ac8: ctx->pc = 0; goto label_1e9ac8;
            case 0x1e9ad0: ctx->pc = 0; goto label_1e9ad0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9a68: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e9a6c: 0x8c435f84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24452)));
    // 0x1e9a70: 0x14600015
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1e9ac8;
    }
    // 0x1e9a78: 0x2442ff68
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967144));
    // 0x1e9a7c: 0x8c43025c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 604)));
    // 0x1e9a80: 0x14600011
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1e9ac8;
    }
    // 0x1e9a88: 0x8c420250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 592)));
    // 0x1e9a8c: 0x1440000e
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e9ac8;
    }
    // 0x1e9a94: 0x2442f808
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965256));
    // 0x1e9a98: 0x8c43025c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 604)));
    // 0x1e9a9c: 0x1460000a
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1e9ac8;
    }
    // 0x1e9aa4: 0x8c420250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 592)));
    // 0x1e9aa8: 0x14400007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e9ac8;
    }
    // 0x1e9ab0: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1e9ab4: 0x8c440458
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x1e9ab8: 0x10830003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_1e9ac8;
    }
    // 0x1e9ac0: 0x14820003
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_1e9ad0;
    }
label_1e9ac8:
    // 0x1e9ac8: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1e9ad0:
    // 0x1e9ad0: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001e9ad8__Fv
// Address: 0x1e9ad8 - 0x1e9b30

void FUN_001e9ad8__Fv(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9ad8) {
        switch (ctx->pc) {
            case 0x1e9b20: ctx->pc = 0; goto label_1e9b20;
            case 0x1e9b28: ctx->pc = 0; goto label_1e9b28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9ad8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1e9adc: 0x8c435f84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24452)));
    // 0x1e9ae0: 0x1460000f
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1e9b20;
    }
    // 0x1e9ae8: 0x2442ff68
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967144));
    // 0x1e9aec: 0x8c43025c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 604)));
    // 0x1e9af0: 0x1460000b
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1e9b20;
    }
    // 0x1e9af8: 0x8c420250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 592)));
    // 0x1e9afc: 0x14400008
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1e9b20;
    }
    // 0x1e9b04: 0x2442f808
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294965256));
    // 0x1e9b08: 0x8c43025c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 604)));
    // 0x1e9b0c: 0x14600004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1e9b20;
    }
    // 0x1e9b14: 0x8c420250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 592)));
    // 0x1e9b18: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e9b28;
    }
label_1e9b20:
    // 0x1e9b20: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
label_1e9b28:
    // 0x1e9b28: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: check_anticrack_collectibles_Fv
// Address: 0x1e9b30 - 0x1e9c78

void entry_1e9ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9ca0: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1e9ca8);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e9ca8
// Address: 0x1e9ca8 - 0x1e9cf0

void entry_1e9ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9ca8) {
        switch (ctx->pc) {
            case 0x1e9cdc: ctx->pc = 0; goto label_1e9cdc;
            case 0x1e9ce4: ctx->pc = 0; goto label_1e9ce4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9ca8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e9cac: 0x50800011
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x1E9CF4; return;
    }
    // 0x1e9cb4: 0x8c860000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1e9cb8: 0x8cc20134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 308)));
    // 0x1e9cbc: 0x1040000c
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1e9cf0(rdram, ctx, runtime); return;
    }
    // 0x1e9cc4: 0x8c622c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11368)));
    // 0x1e9cc8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1e9ccc: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1e9cdc;
    }
    // 0x1e9cd4: 0x10000003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 11376));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1e9ce4;
    }
label_1e9cdc:
    // 0x1e9cdc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1e9ce0: 0x24452d38
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 11576));
label_1e9ce4:
    // 0x1e9ce4: 0x8cc20134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 308)));
    // 0x1e9ce8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1e9cf0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1e9cf0
// Address: 0x1e9cf0 - 0x1e9cfc

void entry_1e9cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9cf0) {
        switch (ctx->pc) {
            case 0x1e9cf4: ctx->pc = 0; goto label_1e9cf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9cf0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1e9cf4:
    // 0x1e9cf4: 0xc057fd6
    SET_GPR_U32(ctx, 31, 0x1e9cfc);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 7012));
    UpdateSwBusyList__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1e9cfc
// Address: 0x1e9cfc - 0x1e9d48

void entry_1e9cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9cfc) {
        switch (ctx->pc) {
            case 0x1e9d40: ctx->pc = 0; goto label_1e9d40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9cfc: 0x26131c24
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 7204));
    // 0x1e9d00: 0x26030060
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 96));
    // 0x1e9d04: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x1e9d08: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1e9d0c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1e9d10: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1e9d14: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1e9d18: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1e9d1c: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1e9d20: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1e9d24: 0x8e030060
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x1e9d28: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1e9d2c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1e9d30: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1e9d34: 0x1080000a
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9D60; return;
    }
    // 0x1e9d3c: 0x0
    // NOP
label_1e9d40:
    // 0x1e9d40: 0xc0493ba
    SET_GPR_U32(ctx, 31, 0x1e9d48);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    UpdateAloHierarchy__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_1e9d48
// Address: 0x1e9d48 - 0x1e9d8c

void entry_1e9d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9d48) {
        switch (ctx->pc) {
            case 0x1e9d60: ctx->pc = 0; goto label_1e9d60;
            case 0x1e9d80: ctx->pc = 0; goto label_1e9d80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9d48: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1e9d4c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1e9d50: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e9d54: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1e9d58: 0x1480fff9
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9D40; return;
    }
label_1e9d60:
    // 0x1e9d60: 0x8e440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1e9d64: 0xae3db314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 29));
    // 0x1e9d68: 0x8e021b64
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 7012)));
    // 0x1e9d6c: 0xafb20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 18));
    // 0x1e9d70: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1e9d74: 0xafa40008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 4));
    // 0x1e9d78: 0x1040000b
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9DA8; return;
    }
label_1e9d80:
    // 0x1e9d80: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e9d84: 0xc04baf6
    SET_GPR_U32(ctx, 31, 0x1e9d8c);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    UpdateAsega__FP5ASEGAf(rdram, ctx, runtime); return;
}


// Function: entry_1e9d8c
// Address: 0x1e9d8c - 0x1e9dd4

void entry_1e9d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9d8c) {
        switch (ctx->pc) {
            case 0x1e9da8: ctx->pc = 0; goto label_1e9da8;
            case 0x1e9dc8: ctx->pc = 0; goto label_1e9dc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9d8c: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1e9d90: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1e9d94: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e9d98: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1e9d9c: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1e9da0: 0x1440fff7
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9D80; return;
    }
label_1e9da8:
    // 0x1e9da8: 0x8e640008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x1e9dac: 0xae3db314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 29));
    // 0x1e9db0: 0x8e021c24
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 7204)));
    // 0x1e9db4: 0xafb30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 19));
    // 0x1e9db8: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1e9dbc: 0xafa40008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 4));
    // 0x1e9dc0: 0x1040000b
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9DF0; return;
    }
label_1e9dc8:
    // 0x1e9dc8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e9dcc: 0xc0566b4
    SET_GPR_U32(ctx, 31, 0x1e9dd4);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    UpdateFader__FP5FADERf(rdram, ctx, runtime); return;
}


// Function: entry_1e9dd4
// Address: 0x1e9dd4 - 0x1e9e00

void entry_1e9dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9dd4) {
        switch (ctx->pc) {
            case 0x1e9df0: ctx->pc = 0; goto label_1e9df0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9dd4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1e9dd8: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1e9ddc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e9de0: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1e9de4: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1e9de8: 0x1440fff7
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9DC8; return;
    }
label_1e9df0:
    // 0x1e9df0: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1e9df4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1e9df8: 0xc056562
    SET_GPR_U32(ctx, 31, 0x1e9e00);
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
    FireSwTimedExplodeStyles__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1e9e00
// Address: 0x1e9e00 - 0x1e9e08

void entry_1e9e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9e00: 0xc07001c
    SET_GPR_U32(ctx, 31, 0x1e9e08);
    UpdateSounds__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1e9e08
// Address: 0x1e9e08 - 0x1e9e10

void entry_1e9e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9e08: 0xc076f92
    SET_GPR_U32(ctx, 31, 0x1e9e10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ProcessSwCallbacks__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1e9e10
// Address: 0x1e9e10 - 0x1e9e30

void entry_1e9e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1e9e10: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1e9e14: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e9e18: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e9e1c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e9e20: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e9e24: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1e9e28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSwPosWorldPrev__FP2SW
// Address: 0x1e9e30 - 0x1e9ea4

void entry_1e9ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9ea4) {
        switch (ctx->pc) {
            case 0x1e9ea8: ctx->pc = 0; goto label_1e9ea8;
            case 0x1e9ec0: ctx->pc = 0; goto label_1e9ec0;
            case 0x1e9ecc: ctx->pc = 0; goto label_1e9ecc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9ea4: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
label_1e9ea8:
    // 0x1e9ea8: 0x521024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1e9eac: 0xfe020538
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 2));
    // 0x1e9eb0: 0x8e1002e4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    // 0x1e9eb4: 0x5600fff4
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
        ctx->pc = 0x1E9E88; return;
    }
    // 0x1e9ebc: 0x8e310414
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 1044)));
label_1e9ec0:
    // 0x1e9ec0: 0x5620ffe5
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 728)));
        ctx->pc = 0x1E9E58; return;
    }
    // 0x1e9ec8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1e9ecc:
    // 0x1e9ecc: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1e9ed0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1e9ed4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1e9ed8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1e9edc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1e9ee4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1e9ee8; return;
}


// Function: UpdateSwRealClock__FP2SWf
// Address: 0x1e9ee8 - 0x1e9f6c

void entry_1e9f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9f6c) {
        switch (ctx->pc) {
            case 0x1e9f88: ctx->pc = 0; goto label_1e9f88;
            case 0x1e9fa8: ctx->pc = 0; goto label_1e9fa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9f6c: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1e9f70: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1e9f74: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e9f78: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1e9f7c: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1e9f80: 0x1440fff7
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9F60; return;
    }
label_1e9f88:
    // 0x1e9f88: 0x8e440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1e9f8c: 0xae3db314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 29));
    // 0x1e9f90: 0x8e021b70
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 7024)));
    // 0x1e9f94: 0xafb20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 18));
    // 0x1e9f98: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1e9f9c: 0xafa40008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 4));
    // 0x1e9fa0: 0x1040000b
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9FD0; return;
    }
label_1e9fa8:
    // 0x1e9fa8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e9fac: 0xc04baf6
    SET_GPR_U32(ctx, 31, 0x1e9fb4);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    UpdateAsega__FP5ASEGAf(rdram, ctx, runtime); return;
}


// Function: entry_1e9fb4
// Address: 0x1e9fb4 - 0x1e9ffc

void entry_1e9fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9fb4) {
        switch (ctx->pc) {
            case 0x1e9fd0: ctx->pc = 0; goto label_1e9fd0;
            case 0x1e9ff0: ctx->pc = 0; goto label_1e9ff0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9fb4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1e9fb8: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1e9fbc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1e9fc0: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1e9fc4: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1e9fc8: 0x1440fff7
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9FA8; return;
    }
label_1e9fd0:
    // 0x1e9fd0: 0x8e640008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x1e9fd4: 0xae3db314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 29));
    // 0x1e9fd8: 0x8e021c30
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 7216)));
    // 0x1e9fdc: 0xafb30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 19));
    // 0x1e9fe0: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1e9fe4: 0xafa40008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 4));
    // 0x1e9fe8: 0x1040000b
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA018; return;
    }
label_1e9ff0:
    // 0x1e9ff0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1e9ff4: 0xc0566b4
    SET_GPR_U32(ctx, 31, 0x1e9ffc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    UpdateFader__FP5FADERf(rdram, ctx, runtime); return;
}


// Function: entry_1e9ffc
// Address: 0x1e9ffc - 0x1ea058

void entry_1e9ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1e9ffc) {
        switch (ctx->pc) {
            case 0x1ea018: ctx->pc = 0; goto label_1ea018;
            case 0x1ea040: ctx->pc = 0; goto label_1ea040;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1e9ffc: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ea000: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1ea004: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ea008: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1ea00c: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ea010: 0x1440fff7
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1E9FF0; return;
    }
label_1ea018:
    // 0x1ea018: 0x8e840008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x1ea01c: 0xae3db314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 29));
    // 0x1ea020: 0x8e020078
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 120)));
    // 0x1ea024: 0xafb40000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 20));
    // 0x1ea028: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1ea02c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ea030: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1ea034: 0x10a0000f
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA074; return;
    }
    // 0x1ea03c: 0x0
    // NOP
label_1ea040:
    // 0x1ea040: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1ea044: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ea048: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ea04c: 0x8c62007c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 124)));
    // 0x1ea050: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ea058);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ea058
// Address: 0x1ea058 - 0x1ea084

void entry_1ea058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea058) {
        switch (ctx->pc) {
            case 0x1ea074: ctx->pc = 0; goto label_1ea074;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea058: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ea05c: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1ea060: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ea064: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ea068: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1ea06c: 0x14a0fff4
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA040; return;
    }
label_1ea074:
    // 0x1ea074: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1ea078: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ea07c: 0xc076f92
    SET_GPR_U32(ctx, 31, 0x1ea084);
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
    ProcessSwCallbacks__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1ea084
// Address: 0x1ea084 - 0x1ea0a8

void entry_1ea084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea084: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ea088: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ea08c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ea090: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ea094: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ea098: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ea09c: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1ea0a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSwDarkening__FP2SWf
// Address: 0x1ea0a8 - 0x1ea100

void entry_1ea100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea100) {
        switch (ctx->pc) {
            case 0x1ea104: ctx->pc = 0; goto label_1ea104;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea100: 0xe600234c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 9036), *(uint32_t*)&val); }
label_1ea104:
    // 0x1ea104: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ea108: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ea10c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ea114: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ea118; return;
}


// Function: UpdateSw__FP2SWf
// Address: 0x1ea118 - 0x1ea15c

void entry_1ea15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea15c: 0xc64c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1ea160: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1ea164: 0x46006032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ea168: 0x0
    // NOP
    // 0x1ea16c: 0x45010079
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        entry_1ea354(rdram, ctx, runtime); return;
    }
    // 0x1ea174: 0xc07a71e
    SET_GPR_U32(ctx, 31, 0x1ea17c);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 96));
    UpdateSwObjects__FP2SWf(rdram, ctx, runtime); return;
}


// Function: entry_1ea17c
// Address: 0x1ea17c - 0x1ea184

void entry_1ea17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea17c: 0xc07a78c
    SET_GPR_U32(ctx, 31, 0x1ea184);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateSwPosWorldPrev__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1ea184
// Address: 0x1ea184 - 0x1ea190

void entry_1ea184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea184: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ea188: 0xc04e300
    SET_GPR_U32(ctx, 31, 0x1ea190);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RecalcSwXpAll__FP2SWi(rdram, ctx, runtime); return;
}


// Function: entry_1ea190
// Address: 0x1ea190 - 0x1ea1a0

void entry_1ea190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea190: 0xc64c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1ea194: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ea198: 0xc06f740
    SET_GPR_U32(ctx, 31, 0x1ea1a0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SolveSw__FP2SWfi(rdram, ctx, runtime); return;
}


// Function: entry_1ea1a0
// Address: 0x1ea1a0 - 0x1ea1f0

void entry_1ea1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea1a0) {
        switch (ctx->pc) {
            case 0x1ea1d8: ctx->pc = 0; goto label_1ea1d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea1a0: 0x2622006c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 108));
    // 0x1ea1a4: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1ea1a8: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ea1ac: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1ea1b0: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1ea1b4: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x1ea1b8: 0x8e82b314
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4294947604)));
    // 0x1ea1bc: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x1ea1c0: 0xae9db314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 29));
    // 0x1ea1c4: 0x8e22006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 108)));
    // 0x1ea1c8: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ea1cc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ea1d0: 0x1080000d
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA208; return;
    }
label_1ea1d8:
    // 0x1ea1d8: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ea1dc: 0x8c420118
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 280)));
    // 0x1ea1e0: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
        ctx->pc = 0x1EA1F4; return;
    }
    // 0x1ea1e8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ea1f0);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[12] = *(float*)&val; }
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ea1f0
// Address: 0x1ea1f0 - 0x1ea21c

void entry_1ea1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea1f0) {
        switch (ctx->pc) {
            case 0x1ea1f4: ctx->pc = 0; goto label_1ea1f4;
            case 0x1ea208: ctx->pc = 0; goto label_1ea208;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea1f0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1ea1f4:
    // 0x1ea1f4: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1ea1f8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ea1fc: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1ea200: 0x1480fff5
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA1D8; return;
    }
label_1ea208:
    // 0x1ea208: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1ea20c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ea210: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ea214: 0xc04e300
    SET_GPR_U32(ctx, 31, 0x1ea21c);
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 2));
    RecalcSwXpAll__FP2SWi(rdram, ctx, runtime); return;
}


// Function: entry_1ea21c
// Address: 0x1ea21c - 0x1ea230

void entry_1ea21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea21c: 0x26a21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x1ea220: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ea224: 0xc44c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1ea228: 0xc06f740
    SET_GPR_U32(ctx, 31, 0x1ea230);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    SolveSw__FP2SWfi(rdram, ctx, runtime); return;
}


// Function: entry_1ea230
// Address: 0x1ea230 - 0x1ea278

void entry_1ea230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea230) {
        switch (ctx->pc) {
            case 0x1ea260: ctx->pc = 0; goto label_1ea260;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea230: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1ea234: 0xafb00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 16));
    // 0x1ea238: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x1ea23c: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x1ea240: 0x8e82b314
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4294947604)));
    // 0x1ea244: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x1ea248: 0xae9db314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 29));
    // 0x1ea24c: 0x8e220060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 96)));
    // 0x1ea250: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ea254: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ea258: 0x12000016
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA2B4; return;
    }
label_1ea260:
    // 0x1ea260: 0x8e020228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 552)));
    // 0x1ea264: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x1ea268: 0x1040000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA29C; return;
    }
    // 0x1ea270: 0xc04a75c
    SET_GPR_U32(ctx, 31, 0x1ea278);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsAloStatic__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1ea278
// Address: 0x1ea278 - 0x1ea298

void entry_1ea278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea278) {
        switch (ctx->pc) {
            case 0x1ea290: ctx->pc = 0; goto label_1ea290;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea278: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ea290;
    }
    // 0x1ea280: 0x8e020228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 552)));
    // 0x1ea284: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1ea288: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 552), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ea298(rdram, ctx, runtime); return;
    }
label_1ea290:
    // 0x1ea290: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1ea298);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1ea298
// Address: 0x1ea298 - 0x1ea2f8

void entry_1ea298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea298) {
        switch (ctx->pc) {
            case 0x1ea29c: ctx->pc = 0; goto label_1ea29c;
            case 0x1ea2b4: ctx->pc = 0; goto label_1ea2b4;
            case 0x1ea2e8: ctx->pc = 0; goto label_1ea2e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea298: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1ea29c:
    // 0x1ea29c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1ea2a0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ea2a4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1ea2a8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ea2ac: 0x1600ffec
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA260; return;
    }
label_1ea2b4:
    // 0x1ea2b4: 0x8e630008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 8)));
    // 0x1ea2b8: 0xafb30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 19));
    // 0x1ea2bc: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x1ea2c0: 0xafb30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 19));
    // 0x1ea2c4: 0xae9db314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 29));
    // 0x1ea2c8: 0x8e22006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 108)));
    // 0x1ea2cc: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ea2d0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ea2d4: 0x12000015
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA32C; return;
    }
    // 0x1ea2dc: 0x34128000
    SET_GPR_U32(ctx, 18, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1ea2e0: 0x12943c
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 18) << (32 + 16));
    // 0x1ea2e4: 0x0
    // NOP
label_1ea2e8:
    // 0x1ea2e8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ea2ec: 0x8c43011c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 284)));
    // 0x1ea2f0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ea2f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ea2f8
// Address: 0x1ea2f8 - 0x1ea310

void entry_1ea2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea2f8: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1ea2fc: 0x521024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1ea300: 0x10400004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA314; return;
    }
    // 0x1ea308: 0xc06ee74
    SET_GPR_U32(ctx, 31, 0x1ea310);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GenerateSoSpliceTouchingEvents__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1ea310
// Address: 0x1ea310 - 0x1ea344

void entry_1ea310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea310) {
        switch (ctx->pc) {
            case 0x1ea314: ctx->pc = 0; goto label_1ea314;
            case 0x1ea32c: ctx->pc = 0; goto label_1ea32c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea310: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_1ea314:
    // 0x1ea314: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1ea318: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ea31c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1ea320: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ea324: 0x1600fff0
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA2E8; return;
    }
label_1ea32c:
    // 0x1ea32c: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1ea330: 0x26b01858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x1ea334: 0xc60c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1ea338: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ea33c: 0xc076fb2
    SET_GPR_U32(ctx, 31, 0x1ea344);
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 2));
    ProcessSwSpliceScheduledCallbacks__FP2SWf(rdram, ctx, runtime); return;
}


// Function: entry_1ea344
// Address: 0x1ea344 - 0x1ea34c

void entry_1ea344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea344: 0xc076f92
    SET_GPR_U32(ctx, 31, 0x1ea34c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ProcessSwCallbacks__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1ea34c
// Address: 0x1ea34c - 0x1ea354

void entry_1ea34c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea34c: 0xc06d21e
    SET_GPR_U32(ctx, 31, 0x1ea354);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
    UpdateShaders__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1ea354
// Address: 0x1ea354 - 0x1ea35c

void entry_1ea354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea354: 0xc077710
    SET_GPR_U32(ctx, 31, 0x1ea35c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001ddc40(rdram, ctx, runtime); return;
}


// Function: entry_1ea35c
// Address: 0x1ea35c - 0x1ea398

void entry_1ea35c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea35c) {
        switch (ctx->pc) {
            case 0x1ea390: ctx->pc = 0; goto label_1ea390;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea35c: 0x26221b7c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 7036));
    // 0x1ea360: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1ea364: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1ea368: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1ea36c: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x1ea370: 0x8e82b314
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4294947604)));
    // 0x1ea374: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x1ea378: 0xae9db314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 29));
    // 0x1ea37c: 0x8e221b7c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 7036)));
    // 0x1ea380: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ea384: 0x1040000b
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA3B4; return;
    }
    // 0x1ea38c: 0x0
    // NOP
label_1ea390:
    // 0x1ea390: 0xc04b9c4
    SET_GPR_U32(ctx, 31, 0x1ea398);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    RemoveAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1ea398
// Address: 0x1ea398 - 0x1ea3d0

void entry_1ea398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea398) {
        switch (ctx->pc) {
            case 0x1ea3b4: ctx->pc = 0; goto label_1ea3b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea398: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ea39c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1ea3a0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ea3a4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1ea3a8: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ea3ac: 0x1440fff8
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EA390; return;
    }
label_1ea3b4:
    // 0x1ea3b4: 0x26b01858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x1ea3b8: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1ea3bc: 0xc60c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1ea3c0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ea3c4: 0x8ec41990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 6544)));
    // 0x1ea3c8: 0xc050f90
    SET_GPR_U32(ctx, 31, 0x1ea3d0);
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 2));
    UpdateCmLast(rdram, ctx, runtime); return;
}


// Function: entry_1ea3d0
// Address: 0x1ea3d0 - 0x1ea3dc

void entry_1ea3d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea3d0: 0xc60c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1ea3d4: 0xc07a82a
    SET_GPR_U32(ctx, 31, 0x1ea3dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateSwDarkening__FP2SWf(rdram, ctx, runtime); return;
}


// Function: entry_1ea3dc
// Address: 0x1ea3dc - 0x1ea408

void entry_1ea3dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea3dc: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ea3e0: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ea3e4: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ea3e8: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ea3ec: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ea3f0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ea3f4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ea3f8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ea3fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ea404: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ea408; return;
}


// Function: RadNormalize__Ff
// Address: 0x1ea408 - 0x1ea468

void entry_1ea468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea468) {
        switch (ctx->pc) {
            case 0x1ea470: ctx->pc = 0; goto label_1ea470;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea468: 0x46140301
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1ea46c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1ea470:
    // 0x1ea470: 0x46006006
    ctx->f[0] = FPU_MOV_S(ctx->f[12]);
    // 0x1ea474: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x1ea478: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GLimitAbs__Fff
// Address: 0x1ea480 - 0x1ea4b8

void entry_1ea57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea57c) {
        switch (ctx->pc) {
            case 0x1ea5d0: ctx->pc = 0; goto label_1ea5d0;
            case 0x1ea5d4: ctx->pc = 0; goto label_1ea5d4;
            case 0x1ea5f0: ctx->pc = 0; goto label_1ea5f0;
            case 0x1ea5fc: ctx->pc = 0; goto label_1ea5fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea57c: 0xc7a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1ea580: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ea584: 0x46140381
    ctx->f[14] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1ea588: 0x460e6034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[14])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ea58c: 0x0
    // NOP
    // 0x1ea590: 0x4502000f
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
        goto label_1ea5d0;
    }
    // 0x1ea598: 0xc6020004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1ea59c: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1ea5a0: 0xc6010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1ea5a4: 0x460e1102
    ctx->f[4] = FPU_MUL_S(ctx->f[2], ctx->f[14]);
    // 0x1ea5a8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1ea5ac: 0x460108c0
    ctx->f[3] = FPU_ADD_S(ctx->f[1], ctx->f[1]);
    // 0x1ea5b0: 0x460e0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[14]);
    // 0x1ea5b4: 0x46010043
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[1] = ctx->f[0] / ctx->f[1];
    // 0x1ea5b8: 0x460e0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[14]);
    // 0x1ea5bc: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x1ea5c0: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1ea5c4: 0x46001047
    ctx->f[1] = FPU_NEG_S(ctx->f[2]);
    // 0x1ea5c8: 0x10000002
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ea5d4;
    }
label_1ea5d0:
    // 0x1ea5d0: 0x46000047
    ctx->f[1] = FPU_NEG_S(ctx->f[0]);
label_1ea5d4:
    // 0x1ea5d4: 0x12400006
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1ea5f0;
    }
    // 0x1ea5dc: 0x12200007
    ctx->f[12] = FPU_SUB_S(ctx->f[21], ctx->f[12]);
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1ea5fc;
    }
    // 0x1ea5e4: 0x46000807
    ctx->f[0] = FPU_NEG_S(ctx->f[1]);
    // 0x1ea5e8: 0x10000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ea5fc;
    }
label_1ea5f0:
    // 0x1ea5f0: 0x12200002
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[21]);
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1ea5fc;
    }
    // 0x1ea5f8: 0xe6210000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_1ea5fc:
    // 0x1ea5fc: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ea600: 0x46006006
    ctx->f[0] = FPU_MOV_S(ctx->f[12]);
    // 0x1ea604: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ea608: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ea60c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ea610: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x1ea614: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x1ea618: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GSmoothA__FffffP4SMPAPf
// Address: 0x1ea620 - 0x1ea660

void entry_1ea660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea660) {
        switch (ctx->pc) {
            case 0x1ea6bc: ctx->pc = 0; goto label_1ea6bc;
            case 0x1ea6ec: ctx->pc = 0; goto label_1ea6ec;
            case 0x1ea6f8: ctx->pc = 0; goto label_1ea6f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea660: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x1ea664: 0xc604000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[4] = *(float*)&val; }
    // 0x1ea668: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1ea66c: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ea670: 0x0
    // NOP
    // 0x1ea674: 0x4500001d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1ea6ec;
    }
    // 0x1ea67c: 0x46142002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[20]);
    // 0x1ea680: 0x4600a880
    ctx->f[2] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    // 0x1ea684: 0x46031034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ea688: 0x0
    // NOP
    // 0x1ea68c: 0x4500000b
    ctx->f[5] = FPU_SUB_S(ctx->f[21], ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1ea6bc;
    }
    // 0x1ea694: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ea698: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ea69c: 0x4614a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[20]);
    // 0x1ea6a0: 0xe7a20000
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x1ea6a4: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1ea6a8: 0x4601b040
    ctx->f[1] = FPU_ADD_S(ctx->f[22], ctx->f[1]);
    // 0x1ea6ac: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1ea6b0: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1ea6b4: 0x1000000d
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ea6ec;
    }
label_1ea6bc:
    // 0x1ea6bc: 0x46051834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ea6c0: 0x4500000a
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1ea6ec;
    }
    // 0x1ea6c8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ea6cc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ea6d0: 0x4614a842
    ctx->f[1] = FPU_MUL_S(ctx->f[21], ctx->f[20]);
    // 0x1ea6d4: 0xe7a50000
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x1ea6d8: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1ea6dc: 0x4601b040
    ctx->f[1] = FPU_ADD_S(ctx->f[22], ctx->f[1]);
    // 0x1ea6e0: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1ea6e4: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1ea6e8: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
label_1ea6ec:
    // 0x1ea6ec: 0x12200002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1ea6f8;
    }
    // 0x1ea6f4: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_1ea6f8:
    // 0x1ea6f8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ea6fc: 0x46000806
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    // 0x1ea700: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ea704: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ea708: 0xc7b60050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[22] = *(float*)&val; }
    // 0x1ea70c: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x1ea710: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1ea714: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ea71c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ea720; return;
}


// Function: junk_001EA720
// Address: 0x1ea720 - 0x1ea728

void entry_1ea758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea758: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ea75c: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1ea760: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ea764: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ea768: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1ea770);
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1ea770
// Address: 0x1ea770 - 0x1ea778

void entry_1ea770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea770: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1ea778);
    ctx->f[12] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1ea778
// Address: 0x1ea778 - 0x1ea798

void entry_1ea778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea778: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ea77c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ea780: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ea784: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x1ea788: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1ea78c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ea794: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ea798; return;
}


// Function: RadSmoothA__FffffP4SMPAPf
// Address: 0x1ea798 - 0x1ea7d0

void entry_1ea7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea7d0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ea7d4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1ea7d8: 0x4600abc6
    ctx->f[15] = FPU_MOV_S(ctx->f[21]);
    // 0x1ea7dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ea7e0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ea7e4: 0xc07a988
    SET_GPR_U32(ctx, 31, 0x1ea7ec);
    ctx->f[14] = FPU_MOV_S(ctx->f[0]);
    GSmoothA__FffffP4SMPAPf(rdram, ctx, runtime); return;
}


// Function: entry_1ea7ec
// Address: 0x1ea7ec - 0x1ea7f4

void entry_1ea7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea7ec: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1ea7f4);
    ctx->f[12] = FPU_ADD_S(ctx->f[22], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1ea7f4
// Address: 0x1ea7f4 - 0x1ea818

void entry_1ea7f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea7f4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ea7f8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ea7fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ea800: 0xc7b60040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[22] = *(float*)&val; }
    // 0x1ea804: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x1ea808: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1ea80c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ea814: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ea818; return;
}


// Function: PosSmooth
// Address: 0x1ea818 - 0x1ea89c

void entry_1ea89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea89c) {
        switch (ctx->pc) {
            case 0x1ea8c4: ctx->pc = 0; goto label_1ea8c4;
            case 0x1ea8ec: ctx->pc = 0; goto label_1ea8ec;
            case 0x1ea900: ctx->pc = 0; goto label_1ea900;
            case 0x1ea904: ctx->pc = 0; goto label_1ea904;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea89c: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x1ea8a0: 0x12000008
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1ea8c4;
    }
    // 0x1ea8a8: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1ea8ac: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x1ea8b0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1ea8b4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ea8b8: 0x4be11898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1ea8bc: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ea8c0: 0xfa020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_1ea8c4:
    // 0x1ea8c4: 0x46140803
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[0] = ctx->f[1] / ctx->f[20];
    // 0x1ea8c8: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ea8cc: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ea8d0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1ea8d4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ea8d8: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1ea8dc: 0x4be11888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ea8e0: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ea8e4: 0x10000007
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ea904;
    }
label_1ea8ec:
    // 0x1ea8ec: 0x12000004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1ea900;
    }
    // 0x1ea8f4: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1ea8f8: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ea8fc: 0x7e030000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 3));
label_1ea900:
    // 0x1ea900: 0x48222000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[4]));
label_1ea904:
    // 0x1ea904: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ea908: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ea90c: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1ea910: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SmoothMatrix
// Address: 0x1ea918 - 0x1ea95c

void entry_1ea95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea95c: 0x27b40060
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1ea960: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ea964: 0x27a500d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1ea968: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x1ea970);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ea970
// Address: 0x1ea970 - 0x1ea988

void entry_1ea970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ea970: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1ea974: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1ea978: 0xc7ad00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[13] = *(float*)&val; }
    // 0x1ea97c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ea980: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1ea988);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 212));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1ea988
// Address: 0x1ea988 - 0x1ea9c8

void entry_1ea988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea988) {
        switch (ctx->pc) {
            case 0x1ea9c0: ctx->pc = 0; goto label_1ea9c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea988: 0x12200027
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EAA28; return;
    }
    // 0x1ea990: 0xc7a000d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[0] = *(float*)&val; }
    // 0x1ea994: 0x46006032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ea998: 0x0
    // NOP
    // 0x1ea99c: 0x45000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1ea9c0;
    }
    // 0x1ea9a4: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1ea9a8: 0x7e220000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    // 0x1ea9ac: 0x7a430010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1ea9b0: 0x7e230010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), GPR_VEC(ctx, 3));
    // 0x1ea9b4: 0x7a420020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x1ea9b8: 0x1000001b
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EAA28; return;
    }
label_1ea9c0:
    // 0x1ea9c0: 0xc062214
    SET_GPR_U32(ctx, 31, 0x1ea9c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1ea9c8
// Address: 0x1ea9c8 - 0x1eaa70

void entry_1ea9c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ea9c8) {
        switch (ctx->pc) {
            case 0x1eaa28: ctx->pc = 0; goto label_1eaa28;
            case 0x1eaa44: ctx->pc = 0; goto label_1eaa44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ea9c8: 0xda650020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 32)));
    // 0x1ea9cc: 0xda640000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1ea9d0: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ea9d4: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ea9d8: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ea9dc: 0xda660010
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1ea9e0: 0x4bc511bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x1ea9e4: 0x4bc518bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1ea9e8: 0x4bc5094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ea9ec: 0x4bc411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1ea9f0: 0x4bc418bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1ea9f4: 0x4bc4090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ea9f8: 0xfa250020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1ea9fc: 0x4bc611bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1eaa00: 0x4bc618bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x1eaa04: 0x4bc6088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1eaa08: 0xfa240000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1eaa0c: 0xfa220010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1eaa10: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1eaa14: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1eaa18: 0xfba200b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1eaa1c: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1eaa20: 0xfba500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1eaa24: 0xfba50090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[5]));
label_1eaa28:
    // 0x1eaa28: 0x12a00006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 212)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_1eaa44;
    }
    // 0x1eaa30: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1eaa34: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1eaa38: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1eaa3c: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1eaa40: 0xfaa10000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_1eaa44:
    // 0x1eaa44: 0x7bbf0140
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1eaa48: 0x7bb50130
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1eaa4c: 0x7bb40120
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1eaa50: 0x7bb30110
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1eaa54: 0x7bb20100
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1eaa58: 0x7bb100f0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1eaa5c: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1eaa60: 0xc7b40150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[20] = *(float*)&val; }
    // 0x1eaa64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eaa6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eaa70; return;
}


// Function: NRandInRange__Fii
// Address: 0x1eaa70 - 0x1eaa94

void entry_1eaa94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eaa94) {
        switch (ctx->pc) {
            case 0x1eaab0: ctx->pc = 0; goto label_1eaab0;
            case 0x1eaac4: ctx->pc = 0; goto label_1eaac4;
            case 0x1eaac8: ctx->pc = 0; goto label_1eaac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eaa94: 0x3c030009
    SET_GPR_U32(ctx, 3, ((uint32_t)9 << 16));
    // 0x1eaa98: 0x2302023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
    // 0x1eaa9c: 0x34635675
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 22133));
    // 0x1eaaa0: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1eaaa4: 0x43001a
    { int32_t divisor = GPR_S32(ctx, 3); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 3) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,3); } }
    // 0x1eaaa8: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1eaab0;
    }
label_1eaab0:
    // 0x1eaab0: 0x2810
    SET_GPR_U32(ctx, 5, ctx->hi);
    // 0x1eaab4: 0xa4001a
    { int32_t divisor = GPR_S32(ctx, 4); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 5) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 4) % divisor); } else { ctx->lo = (GPR_S32(ctx,5) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,4); } }
    // 0x1eaab8: 0x1010
    SET_GPR_U32(ctx, 2, ctx->hi);
    // 0x1eaabc: 0x10000002
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eaac8;
    }
label_1eaac4:
    // 0x1eaac4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1eaac8:
    // 0x1eaac8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1eaacc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eaad0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eaad4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eaadc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eaae0; return;
}


// Function: GRandInRange__Fff
// Address: 0x1eaae0 - 0x1eab0c

void entry_1eab0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eab0c) {
        switch (ctx->pc) {
            case 0x1eab30: ctx->pc = 0; goto label_1eab30;
            case 0x1eab34: ctx->pc = 0; goto label_1eab34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eab0c: 0x4614a801
    ctx->f[0] = FPU_SUB_S(ctx->f[21], ctx->f[20]);
    // 0x1eab10: 0x3c013000
    SET_GPR_U32(ctx, 1, ((uint32_t)12288 << 16));
    // 0x1eab14: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1eab18: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1eab1c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1eab20: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1eab24: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1eab28: 0x10000002
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eab34;
    }
label_1eab30:
    // 0x1eab30: 0x4600a006
    ctx->f[0] = FPU_MOV_S(ctx->f[20]);
label_1eab34:
    // 0x1eab34: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eab38: 0xc7b50018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[21] = *(float*)&val; }
    // 0x1eab3c: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x1eab40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GRandGaussian__Ffff
// Address: 0x1eab48 - 0x1eab9c

void entry_1eab9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eab9c: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1eaba0: 0x4600c306
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    // 0x1eaba4: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1eabac);
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1eabac
// Address: 0x1eabac - 0x1eabe0

void entry_1eabac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eabac: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1eabb0: 0x4614a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    // 0x1eabb4: 0x4615a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[21]);
    // 0x1eabb8: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1eabbc: 0x4614b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eabc0: 0x0
    // NOP
    // 0x1eabc4: 0x4501fff3
    ctx->f[12] = FPU_MOV_S(ctx->f[24]);
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1EAB94; return;
    }
    // 0x1eabcc: 0x461aa032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[26])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eabd0: 0x4501ffef
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1EAB90; return;
    }
    // 0x1eabd8: 0xc081678
    SET_GPR_U32(ctx, 31, 0x1eabe0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    logf(rdram, ctx, runtime); return;
}


// Function: entry_1eabe0
// Address: 0x1eabe0 - 0x1eac68

void entry_1eabe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eabe0) {
        switch (ctx->pc) {
            case 0x1eac2c: ctx->pc = 0; goto label_1eac2c;
            case 0x1eac3c: ctx->pc = 0; goto label_1eac3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eabe0: 0x3c01c000
    SET_GPR_U32(ctx, 1, ((uint32_t)49152 << 16));
    // 0x1eabe4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1eabe8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1eabec: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x1eabf0: 0x46000084
    ctx->f[2] = FPU_SQRT_S(ctx->f[0]);
    // 0x1eabf4: 0x4615d802
    ctx->f[0] = FPU_MUL_S(ctx->f[27], ctx->f[21]);
    // 0x1eabf8: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1eabfc: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1eac00: 0x4601b832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[23], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eac04: 0x0
    // NOP
    // 0x1eac08: 0x4501000c
    ctx->f[0] = FPU_ADD_S(ctx->f[25], ctx->f[0]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1eac3c;
    }
    // 0x1eac10: 0x4617c841
    ctx->f[1] = FPU_SUB_S(ctx->f[25], ctx->f[23]);
    // 0x1eac14: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eac18: 0x0
    // NOP
    // 0x1eac1c: 0x45000003
    ctx->f[12] = FPU_ADD_S(ctx->f[25], ctx->f[23]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1eac2c;
    }
    // 0x1eac24: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eac3c;
    }
label_1eac2c:
    // 0x1eac2c: 0x46006034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eac30: 0x0
    // NOP
    // 0x1eac34: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[12]);
        goto label_1eac3c;
    }
label_1eac3c:
    // 0x1eac3c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eac40: 0xc7bb0048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[27] = *(float*)&val; }
    // 0x1eac44: 0xc7ba0040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[26] = *(float*)&val; }
    // 0x1eac48: 0xc7b90038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[25] = *(float*)&val; }
    // 0x1eac4c: 0xc7b80030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[24] = *(float*)&val; }
    // 0x1eac50: 0xc7b70028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[23] = *(float*)&val; }
    // 0x1eac54: 0xc7b60020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[22] = *(float*)&val; }
    // 0x1eac58: 0xc7b50018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[21] = *(float*)&val; }
    // 0x1eac5c: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x1eac60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FFloatsNear__Ffff
// Address: 0x1eac68 - 0x1eaca0

void entry_1eaef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eaef8) {
        switch (ctx->pc) {
            case 0x1eaf00: ctx->pc = 0; goto label_1eaf00;
            case 0x1eaf18: ctx->pc = 0; goto label_1eaf18;
            case 0x1eaf1c: ctx->pc = 0; goto label_1eaf1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eaef8: 0x10000007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eaf18;
    }
label_1eaf00:
    // 0x1eaf00: 0x821024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1eaf04: 0x3403fff0
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 65520));
    // 0x1eaf08: 0x31c3c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 16));
    // 0x1eaf0c: 0xc31824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x1eaf10: 0x451024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1eaf14: 0x622025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1eaf18:
    // 0x1eaf18: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_1eaf1c:
    // 0x1eaf1c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eaf20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GTrunc__Ff
// Address: 0x1eaf28 - 0x1eafe0

void entry_1eaff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eaff4) {
        switch (ctx->pc) {
            case 0x1eb008: ctx->pc = 0; goto label_1eb008;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eaff4: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1eaff8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eaffc: 0x0
    // NOP
    // 0x1eb000: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
        goto label_1eb008;
    }
label_1eb008:
    // 0x1eb008: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eb00c: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x1eb010: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FitClq__FffffP3CLQ
// Address: 0x1eb018 - 0x1eb050

void entry_1eb0bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb0bc) {
        switch (ctx->pc) {
            case 0x1eb0d4: ctx->pc = 0; goto label_1eb0d4;
            case 0x1eb0d8: ctx->pc = 0; goto label_1eb0d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb0bc: 0x14400006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1eb0d8;
    }
    // 0x1eb0c4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1eb0c8: 0x232102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 18)));
    // 0x1eb0cc: 0x1440fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EB0B0; return;
    }
label_1eb0d4:
    // 0x1eb0d4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1eb0d8:
    // 0x1eb0d8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1eb0dc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1eb0e0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eb0e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eb0e8: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1eb0ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eb0f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eb0f8; return;
}


// Function: GLimitLm__FP2LMf
// Address: 0x1eb0f8 - 0x1eb128

void entry_1eb1f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb1f4: 0xe7b40010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x1eb1f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb1fc: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x1eb200: 0x220f809
    SET_GPR_U32(ctx, 31, 0x1eb208);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 17); return;
}


// Function: entry_1eb208
// Address: 0x1eb208 - 0x1eb228

void entry_1eb208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb208) {
        switch (ctx->pc) {
            case 0x1eb220: ctx->pc = 0; goto label_1eb220;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb208: 0x4617a040
    ctx->f[1] = FPU_ADD_S(ctx->f[20], ctx->f[23]);
    // 0x1eb20c: 0xe7a00014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 20), *(uint32_t*)&val); }
    // 0x1eb210: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb214: 0x4601a869
    ctx->f[1] = std::min(ctx->f[21], ctx->f[1]);
    // 0x1eb218: 0x46000b06
    ctx->f[12] = FPU_MOV_S(ctx->f[1]);
    // 0x1eb21c: 0xe7a10020
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
label_1eb220:
    // 0x1eb220: 0x220f809
    SET_GPR_U32(ctx, 31, 0x1eb228);
    ctx->pc = GPR_U32(ctx, 17); return;
}


// Function: entry_1eb228
// Address: 0x1eb228 - 0x1eb28c

void entry_1eb228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb228) {
        switch (ctx->pc) {
            case 0x1eb230: ctx->pc = 0; goto label_1eb230;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb228: 0xe7a00024
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 36), *(uint32_t*)&val); }
    // 0x1eb22c: 0x0
    // NOP
label_1eb230:
    // 0x1eb230: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1eb234: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1eb238: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eb23c: 0x0
    // NOP
    // 0x1eb240: 0x45000014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[0] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1EB294; return;
    }
    // 0x1eb248: 0x6ba20017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1eb24c: 0x6fa20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1eb250: 0xb3a20027
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb254: 0xb7a20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb258: 0x6ba60007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1eb25c: 0x6fa60000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1eb260: 0xb3a60017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb264: 0xb7a60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb268: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb26c: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1eb270: 0xc7a10020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[1] = *(float*)&val; }
    // 0x1eb274: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x1eb278: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1eb27c: 0x4600b028
    ctx->f[0] = std::max(ctx->f[22], ctx->f[0]);
    // 0x1eb280: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1eb284: 0x220f809
    SET_GPR_U32(ctx, 31, 0x1eb28c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 17); return;
}


// Function: entry_1eb28c
// Address: 0x1eb28c - 0x1eb314

void entry_1eb28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb28c) {
        switch (ctx->pc) {
            case 0x1eb294: ctx->pc = 0; goto label_1eb294;
            case 0x1eb2e8: ctx->pc = 0; goto label_1eb2e8;
            case 0x1eb2f8: ctx->pc = 0; goto label_1eb2f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb28c: 0x1000ffe8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EB230; return;
    }
label_1eb294:
    // 0x1eb294: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eb298: 0x0
    // NOP
    // 0x1eb29c: 0x45000012
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 9));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1eb2e8;
    }
    // 0x1eb2a4: 0x6ba60017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1eb2a8: 0x6fa60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1eb2ac: 0xb3a60007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb2b0: 0xb7a60000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb2b4: 0x6ba50027
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1eb2b8: 0x6fa50020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1eb2bc: 0xb3a50017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb2c0: 0xb7a50010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb2c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb2c8: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1eb2cc: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1eb2d0: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x1eb2d4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1eb2d8: 0x4600a829
    ctx->f[0] = std::min(ctx->f[21], ctx->f[0]);
    // 0x1eb2dc: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1eb2e0: 0x1000ffcf
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EB220; return;
    }
label_1eb2e8:
    // 0x1eb2e8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1eb2ec: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1eb2f0: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1eb2f4: 0x0
    // NOP
label_1eb2f8:
    // 0x1eb2f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb2fc: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x1eb300: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1eb304: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x1eb308: 0x46000b06
    ctx->f[12] = FPU_MOV_S(ctx->f[1]);
    // 0x1eb30c: 0x220f809
    SET_GPR_U32(ctx, 31, 0x1eb314);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 17); return;
}


// Function: entry_1eb314
// Address: 0x1eb314 - 0x1eb338

void entry_1eb314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb314: 0xc7a20020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[2] = *(float*)&val; }
    // 0x1eb318: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb31c: 0xc7a10010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1eb320: 0xe7a0000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 12), *(uint32_t*)&val); }
    // 0x1eb324: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1eb328: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x1eb32c: 0x46000b06
    ctx->f[12] = FPU_MOV_S(ctx->f[1]);
    // 0x1eb330: 0x220f809
    SET_GPR_U32(ctx, 31, 0x1eb338);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 17); return;
}


// Function: entry_1eb338
// Address: 0x1eb338 - 0x1eb458

void entry_1eb338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb338) {
        switch (ctx->pc) {
            case 0x1eb384: ctx->pc = 0; goto label_1eb384;
            case 0x1eb3ac: ctx->pc = 0; goto label_1eb3ac;
            case 0x1eb3e4: ctx->pc = 0; goto label_1eb3e4;
            case 0x1eb404: ctx->pc = 0; goto label_1eb404;
            case 0x1eb418: ctx->pc = 0; goto label_1eb418;
            case 0x1eb424: ctx->pc = 0; goto label_1eb424;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb338: 0xc7a2000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 12)); ctx->f[2] = *(float*)&val; }
    // 0x1eb33c: 0xc7a10014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[1] = *(float*)&val; }
    // 0x1eb340: 0x46011034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eb344: 0x0
    // NOP
    // 0x1eb348: 0x45000018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 28), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1eb3ac;
    }
    // 0x1eb350: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eb354: 0x4500000b
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1eb384;
    }
    // 0x1eb35c: 0x6ba40017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1eb360: 0x6fa40010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1eb364: 0xb3a40027
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb368: 0xb7a40020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb36c: 0x6ba3000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1eb370: 0x6fa30008
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1eb374: 0xb3a30017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb378: 0xb7a30010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb37c: 0x10000021
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eb404;
    }
label_1eb384:
    // 0x1eb384: 0x6ba20017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1eb388: 0x6fa20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1eb38c: 0xb3a20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb390: 0xb7a20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb394: 0x6ba6001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1eb398: 0x6fa60018
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x1eb39c: 0xb3a60017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb3a0: 0xb7a60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb3a4: 0x10000017
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eb404;
    }
label_1eb3ac:
    // 0x1eb3ac: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eb3b0: 0x0
    // NOP
    // 0x1eb3b4: 0x4500000b
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1eb3e4;
    }
    // 0x1eb3bc: 0x6ba5000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1eb3c0: 0x6fa50008
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1eb3c4: 0xb3a50007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb3c8: 0xb7a50000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb3cc: 0x6ba4001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1eb3d0: 0x6fa40018
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x1eb3d4: 0xb3a40027
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb3d8: 0xb7a40020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb3dc: 0x10000009
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eb404;
    }
label_1eb3e4:
    // 0x1eb3e4: 0x6ba30017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1eb3e8: 0x6fa30010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1eb3ec: 0xb3a30007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb3f0: 0xb7a30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb3f4: 0x6ba2001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1eb3f8: 0x6fa20018
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1eb3fc: 0xb3a20017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1eb400: 0xb7a20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
label_1eb404:
    // 0x1eb404: 0x641ffbc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x1EB2F8; return;
    }
    // 0x1eb40c: 0x12600002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1eb418;
    }
    // 0x1eb414: 0xe6600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 0), *(uint32_t*)&val); }
label_1eb418:
    // 0x1eb418: 0x12800002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1eb424;
    }
    // 0x1eb420: 0xe6800000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 0), *(uint32_t*)&val); }
label_1eb424:
    // 0x1eb424: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1eb428: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1eb42c: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1eb430: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1eb434: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1eb438: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1eb43c: 0xc7b700a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[23] = *(float*)&val; }
    // 0x1eb440: 0xc7b600a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[22] = *(float*)&val; }
    // 0x1eb444: 0xc7b50098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[21] = *(float*)&val; }
    // 0x1eb448: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1eb44c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eb454: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eb458; return;
}


// Function: junk_001EB458
// Address: 0x1eb458 - 0x1eb474

void entry_1eb474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb474) {
        switch (ctx->pc) {
            case 0x1eb4c8: ctx->pc = 0; goto label_1eb4c8;
            case 0x1eb4dc: ctx->pc = 0; goto label_1eb4dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb474: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1eb478: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1eb47c: 0x8c4423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1eb480: 0x24c35c80
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 23680));
    // 0x1eb484: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x1eb488: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1eb48c: 0xc481000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 12)); ctx->f[1] = *(float*)&val; }
    // 0x1eb490: 0x24455c60
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1eb494: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1eb498: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1eb49c: 0xc4c35c80
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 23680)); ctx->f[3] = *(float*)&val; }
    // 0x1eb4a0: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1eb4a4: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1eb4a8: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1eb4ac: 0x46011840
    ctx->f[1] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x1eb4b0: 0x46040834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eb4b4: 0x0
    // NOP
    // 0x1eb4b8: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1eb4c8;
    }
    // 0x1eb4c0: 0x10000006
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eb4dc;
    }
label_1eb4c8:
    // 0x1eb4c8: 0x46012834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eb4cc: 0x0
    // NOP
    // 0x1eb4d0: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1eb4dc;
    }
    // 0x1eb4d8: 0x460028c6
    ctx->f[3] = FPU_MOV_S(ctx->f[5]);
label_1eb4dc:
    // 0x1eb4dc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1eb4e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1eb4e4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1eb4e8: 0x24435c70
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 23664));
    // 0x1eb4ec: 0xc4425c70
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23664)); ctx->f[2] = *(float*)&val; }
    // 0x1eb4f0: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1eb4f4: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1eb4f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eb4fc: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1eb500: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1eb504: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1eb508: 0xe6000684
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1668), *(uint32_t*)&val); }
    // 0x1eb50c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eb510: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadUnknown5FromBrx
// Address: 0x1eb518 - 0x1eb52c

void entry_1eb52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb52c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1eb530: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb534: 0x24c65c90
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 23696));
    // 0x1eb538: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1eb540);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1eb540
// Address: 0x1eb540 - 0x1eb598

void entry_1eb540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb540) {
        switch (ctx->pc) {
            case 0x1eb568: ctx->pc = 0; goto label_1eb568;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb540: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eb544: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eb548: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eb550: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1eb554: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1eb558: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1eb55c: 0x24820580
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 1408));
    // 0x1eb560: 0x24650600
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 1536));
    // 0x1eb564: 0x24630580
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1408));
label_1eb568:
    // 0x1eb568: 0x78670000
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1eb56c: 0x78680010
    SET_GPR_VEC(ctx, 8, READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1eb570: 0x7c470000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 7));
    // 0x1eb574: 0x7c480010
    WRITE128(ADD32(GPR_U32(ctx, 2), 16), GPR_VEC(ctx, 8));
    // 0x1eb578: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x1eb57c: 0x1465fffa
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 5)) {
        goto label_1eb568;
    }
    // 0x1eb584: 0x8cc22e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 11792)));
    // 0x1eb588: 0x8c430604
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1540)));
    // 0x1eb58c: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 1540), GPR_U32(ctx, 3));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eb594: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eb598; return;
}


// Function: FUN_001eb598
// Address: 0x1eb598 - 0x1eb5ac

void FUN_001eb598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb598: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1eb59c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1eb5a0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1eb5a4: 0xc049292
    SET_GPR_U32(ctx, 31, 0x1eb5ac);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostAloLoad__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1eb5ac
// Address: 0x1eb5ac - 0x1eb5c0

void entry_1eb5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb5ac: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1eb5b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb5b4: 0x24c65ca0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 23712));
    // 0x1eb5b8: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1eb5c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1eb5c0
// Address: 0x1eb5c0 - 0x1eb5d4

void entry_1eb5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb5c0: 0x8e040610
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x1eb5c4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb5c8: 0x240604ca
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1226));
    // 0x1eb5cc: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1eb5d4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1eb5d4
// Address: 0x1eb5d4 - 0x1eb5f4

void entry_1eb5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb5d4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1eb5d8: 0x3c05001f
    SET_GPR_U32(ctx, 5, ((uint32_t)31 << 16));
    // 0x1eb5dc: 0xae020614
    WRITE32(ADD32(GPR_U32(ctx, 16), 1556), GPR_U32(ctx, 2));
    // 0x1eb5e0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb5e4: 0x24a5b550
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294948176));
    // 0x1eb5e8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eb5ec: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x1eb5f4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_1eb5f4
// Address: 0x1eb5f4 - 0x1eb608

void entry_1eb5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb5f4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eb5f8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eb5fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eb604: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eb608; return;
}


// Function: FUN_001eb608
// Address: 0x1eb608 - 0x1eb628

void FUN_001eb608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb608: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1eb60c: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1eb610: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1eb614: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1eb618: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1eb61c: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1eb620: 0xc0648ba
    SET_GPR_U32(ctx, 31, 0x1eb628);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    OnPoActive__FP2POiT0(rdram, ctx, runtime); return;
}


// Function: entry_1eb628
// Address: 0x1eb628 - 0x1eb63c

void entry_1eb628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb628: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1eb62c: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1eb630: 0x24060013
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 19));
    // 0x1eb634: 0xc056a0e
    SET_GPR_U32(ctx, 31, 0x1eb63c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObjectByClass__FP2SWi3CIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1eb63c
// Address: 0x1eb63c - 0x1eb650

void entry_1eb63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb63c: 0x12000007
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EB65C; return;
    }
    // 0x1eb644: 0x8e240614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1556)));
    // 0x1eb648: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1eb650);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1227));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1eb650
// Address: 0x1eb650 - 0x1eb668

void entry_1eb650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb650) {
        switch (ctx->pc) {
            case 0x1eb65c: ctx->pc = 0; goto label_1eb65c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb650: 0xae510c3c
    WRITE32(ADD32(GPR_U32(ctx, 18), 3132), GPR_U32(ctx, 17));
    // 0x1eb654: 0x10000009
    WRITE32(ADD32(GPR_U32(ctx, 17), 1676), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EB67C; return;
    }
label_1eb65c:
    // 0x1eb65c: 0x8e240614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1556)));
    // 0x1eb660: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1eb668);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1226));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1eb668
// Address: 0x1eb668 - 0x1eb6f8

void entry_1eb668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb668) {
        switch (ctx->pc) {
            case 0x1eb67c: ctx->pc = 0; goto label_1eb67c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb668: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1eb66c: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1eb670: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1eb674: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1eb678: 0xe46026d0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 9936), *(uint32_t*)&val); }
label_1eb67c:
    // 0x1eb67c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1eb680: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1eb684: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eb688: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eb68c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eb694: 0x0
    // NOP
    // 0x1eb698: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1eb69c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1eb6a0: 0xc4605cd0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 23760)); ctx->f[0] = *(float*)&val; }
    // 0x1eb6a4: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1eb6a8: 0x8c425cd4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 23764)));
    // 0x1eb6ac: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x1eb6b0: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1eb6b4: 0x7fb00020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 16));
    // 0x1eb6b8: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1eb6bc: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1eb6c0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1eb6c4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1eb6c8: 0xd8830130
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 304)));
    // 0x1eb6cc: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1eb6d0: 0xd8810110
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 272)));
    // 0x1eb6d4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1eb6d8: 0x4be209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1eb6dc: 0x4be41848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1eb6e0: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1eb6e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb6e8: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1eb6ec: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x1eb6f0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1eb6f8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1eb6f8
// Address: 0x1eb6f8 - 0x1eb704

void entry_1eb6f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb6f8: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1eb6fc: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1eb704);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1eb704
// Address: 0x1eb704 - 0x1eb718

void entry_1eb704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb704: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1eb708: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1eb70c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1eb710: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1eb718);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1eb718
// Address: 0x1eb718 - 0x1eb724

void entry_1eb718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb718: 0xe6000638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    // 0x1eb71c: 0xc071756
    SET_GPR_U32(ctx, 31, 0x1eb724);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FixStepAngularVelocity__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1eb724
// Address: 0x1eb724 - 0x1eb734

void entry_1eb724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb724: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb728: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1eb72c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1eb734);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 43));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1eb734
// Address: 0x1eb734 - 0x1eb748

void entry_1eb734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb734: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1eb738: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1eb73c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eb744: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eb748; return;
}


// Function: FUN_001eb748
// Address: 0x1eb748 - 0x1eb790

void FUN_001eb748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb748: 0x27bdff50
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967120));
    // 0x1eb74c: 0x7fb40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 20));
    // 0x1eb750: 0x7fb10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 17));
    // 0x1eb754: 0x7fbf0090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 31));
    // 0x1eb758: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1eb75c: 0x7fb30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 19));
    // 0x1eb760: 0x7fb20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 18));
    // 0x1eb764: 0x7fb00040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 16));
    // 0x1eb768: 0xe7b400a0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 160), *(uint32_t*)&val); }
    // 0x1eb76c: 0x8e24067c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1660)));
    // 0x1eb770: 0x1080001f
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1eb7f0(rdram, ctx, runtime); return;
    }
    // 0x1eb778: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x1eb77c: 0x8e422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 11792)));
    // 0x1eb780: 0x5040001c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1664)));
        ctx->pc = 0x1EB7F4; return;
    }
    // 0x1eb788: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1eb790);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1eb790
// Address: 0x1eb790 - 0x1eb7a0

void entry_1eb790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb790: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1eb794: 0x8e24067c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1660)));
    // 0x1eb798: 0xc07cf02
    SET_GPR_U32(ctx, 31, 0x1eb7a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetXfmMat__FP3XFMP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1eb7a0
// Address: 0x1eb7a0 - 0x1eb7b4

void entry_1eb7a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb7a0: 0x8e442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 11792)));
    // 0x1eb7a4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1eb7a8: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1eb7ac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1eb7b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1eb7b4
// Address: 0x1eb7b4 - 0x1eb7c8

void entry_1eb7b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb7b4: 0x8e442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 11792)));
    // 0x1eb7b8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1eb7bc: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1eb7c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1eb7c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1eb7c8
// Address: 0x1eb7c8 - 0x1eb7dc

void entry_1eb7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb7c8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1eb7cc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1eb7d0: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x1eb7d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1eb7dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1eb7dc
// Address: 0x1eb7dc - 0x1eb7f0

void entry_1eb7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb7dc: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1eb7e0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eb7e4: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x1eb7e8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1eb7f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1eb7f0
// Address: 0x1eb7f0 - 0x1eb90c

void entry_1eb7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb7f0) {
        switch (ctx->pc) {
            case 0x1eb7f4: ctx->pc = 0; goto label_1eb7f4;
            case 0x1eb81c: ctx->pc = 0; goto label_1eb81c;
            case 0x1eb82c: ctx->pc = 0; goto label_1eb82c;
            case 0x1eb83c: ctx->pc = 0; goto label_1eb83c;
            case 0x1eb844: ctx->pc = 0; goto label_1eb844;
            case 0x1eb8bc: ctx->pc = 0; goto label_1eb8bc;
            case 0x1eb8d0: ctx->pc = 0; goto label_1eb8d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb7f0: 0x8e220680
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1664)));
label_1eb7f4:
    // 0x1eb7f4: 0x50400046
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
        ctx->pc = 0x1EB910; return;
    }
    // 0x1eb7fc: 0x968300aa
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 20), 170)));
    // 0x1eb800: 0x306200f0
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 240));
    // 0x1eb804: 0x10400041
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 128));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1eb90c(rdram, ctx, runtime); return;
    }
    // 0x1eb80c: 0x10400003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1eb81c;
    }
    // 0x1eb814: 0x1000000b
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eb844;
    }
label_1eb81c:
    // 0x1eb81c: 0x10400003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1eb82c;
    }
    // 0x1eb824: 0x10000007
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eb844;
    }
label_1eb82c:
    // 0x1eb82c: 0x10400003
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1eb83c;
    }
    // 0x1eb834: 0x10000003
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eb844;
    }
label_1eb83c:
    // 0x1eb83c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1eb840: 0x43980b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 2));
label_1eb844:
    // 0x1eb844: 0x8e23062c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
    // 0x1eb848: 0x8e220630
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1584)));
    // 0x1eb84c: 0x62102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 2)));
    // 0x1eb850: 0x1040001a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1eb8bc;
    }
    // 0x1eb858: 0x310c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 3));
    // 0x1eb85c: 0x24420634
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1588));
    // 0x1eb860: 0x2222021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1eb864: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1eb868: 0x14730014
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 19)) {
        goto label_1eb8bc;
    }
    // 0x1eb870: 0x8e22068c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1676)));
    // 0x1eb874: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x1eb878: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1eb87c: 0xc4420c70
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 3184)); ctx->f[2] = *(float*)&val; }
    // 0x1eb880: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1eb884: 0xc4450c7c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 3196)); ctx->f[5] = *(float*)&val; }
    // 0x1eb888: 0xc4810004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1eb88c: 0xc6230684
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1668)); ctx->f[3] = *(float*)&val; }
    // 0x1eb890: 0x46041082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x1eb894: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1eb898: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1eb89c: 0x460018c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1eb8a0: 0x46051500
    ctx->f[20] = FPU_ADD_S(ctx->f[2], ctx->f[5]);
    // 0x1eb8a4: 0x46140841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[20]);
    // 0x1eb8a8: 0x46000845
    ctx->f[1] = FPU_ABS_S(ctx->f[1]);
    // 0x1eb8ac: 0x46030834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eb8b0: 0x0
    // NOP
    // 0x1eb8b4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1eb8bc;
    }
label_1eb8bc:
    // 0x1eb8bc: 0x10a00004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 123));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1eb8d0;
    }
    // 0x1eb8c4: 0xae330678
    WRITE32(ADD32(GPR_U32(ctx, 17), 1656), GPR_U32(ctx, 19));
    // 0x1eb8c8: 0x10000010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 1652), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1eb90c(rdram, ctx, runtime); return;
    }
label_1eb8d0:
    // 0x1eb8d0: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1eb8d4: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1eb8d8: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1eb8dc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1eb8e0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eb8e4: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1eb8e8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1eb8ec: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eb8f0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1eb8f4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1eb8f8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eb8fc: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1eb900: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eb904: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1eb90c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1eb90c
// Address: 0x1eb90c - 0x1eb99c

void entry_1eb90c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb90c) {
        switch (ctx->pc) {
            case 0x1eb910: ctx->pc = 0; goto label_1eb910;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb90c: 0x8e24062c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
label_1eb910:
    // 0x1eb910: 0x8e220630
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1584)));
    // 0x1eb914: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1eb918: 0x104000d2
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EBC64; return;
    }
    // 0x1eb920: 0x8e23068c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1676)));
    // 0x1eb924: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x1eb928: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1eb92c: 0x24420634
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1588));
    // 0x1eb930: 0xc4600c70
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 3184)); ctx->f[0] = *(float*)&val; }
    // 0x1eb934: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1eb938: 0xc4610c7c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 3196)); ctx->f[1] = *(float*)&val; }
    // 0x1eb93c: 0x2228021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1eb940: 0x8e230678
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1656)));
    // 0x1eb944: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1eb948: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1eb94c: 0xc6230684
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1668)); ctx->f[3] = *(float*)&val; }
    // 0x1eb950: 0x14620026
    ctx->f[4] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EB9EC; return;
    }
    // 0x1eb958: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1eb95c: 0xc6220674
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1652)); ctx->f[2] = *(float*)&val; }
    // 0x1eb960: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1eb964: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1eb968: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1eb96c: 0x46011842
    ctx->f[1] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x1eb970: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1eb974: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eb978: 0x0
    // NOP
    // 0x1eb97c: 0x4500001b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1EB9EC; return;
    }
    // 0x1eb984: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1eb988: 0x24425cd8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23768));
    // 0x1eb98c: 0x8e240614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1556)));
    // 0x1eb990: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1eb994: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1eb99c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1eb99c
// Address: 0x1eb99c - 0x1eb9e4

void entry_1eb99c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eb99c: 0x8e230678
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1656)));
    // 0x1eb9a0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1eb9a4: 0x24425ce8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23784));
    // 0x1eb9a8: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1eb9ac: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1eb9b0: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1eb9b4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1eb9b8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1eb9bc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eb9c0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1eb9c4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eb9c8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eb9cc: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x1eb9d0: 0x460063c6
    ctx->f[15] = FPU_MOV_S(ctx->f[12]);
    // 0x1eb9d4: 0x46006406
    ctx->f[16] = FPU_MOV_S(ctx->f[12]);
    // 0x1eb9d8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eb9dc: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1eb9e4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1eb9e4
// Address: 0x1eb9e4 - 0x1eba58

void entry_1eb9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eb9e4) {
        switch (ctx->pc) {
            case 0x1eb9ec: ctx->pc = 0; goto label_1eb9ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eb9e4: 0x1000008e
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EBC20; return;
    }
label_1eb9ec:
    // 0x1eb9ec: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1eb9f0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1eb9f4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1eb9f8: 0x46012041
    ctx->f[1] = FPU_SUB_S(ctx->f[4], ctx->f[1]);
    // 0x1eb9fc: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x1eba00: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eba04: 0x0
    // NOP
    // 0x1eba08: 0x45000096
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1EBC64; return;
    }
    // 0x1eba10: 0x3c0146ea
    SET_GPR_U32(ctx, 1, ((uint32_t)18154 << 16));
    // 0x1eba14: 0x34216000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 24576));
    // 0x1eba18: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1eba1c: 0x24040051
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 81));
    // 0x1eba20: 0x3c01469c
    SET_GPR_U32(ctx, 1, ((uint32_t)18076 << 16));
    // 0x1eba24: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1eba28: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1eba2c: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x1eba30: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1eba34: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eba38: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x1eba3c: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x1eba40: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
    // 0x1eba44: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eba48: 0x44808000
    *(uint32_t*)&ctx->f[16] = GPR_U32(ctx, 0);
    // 0x1eba4c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eba50: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1eba58);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1eba58
// Address: 0x1eba58 - 0x1eba60

void entry_1eba58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eba58: 0xc058316
    SET_GPR_U32(ctx, 31, 0x1eba60);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1eba60
// Address: 0x1eba60 - 0x1eba78

void entry_1eba60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eba60: 0x14400027
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EBB00; return;
    }
    // 0x1eba68: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1eba6c: 0x8c62013c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 316)));
    // 0x1eba70: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1eba78);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1eba78
// Address: 0x1eba78 - 0x1eba8c

void entry_1eba78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eba78: 0x54400021
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1EBB00; return;
    }
    // 0x1eba80: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1eba84: 0xc064a74
    SET_GPR_U32(ctx, 31, 0x1eba8c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    SwitchToPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1eba8c
// Address: 0x1eba8c - 0x1eba9c

void entry_1eba8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eba8c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1eba90: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1eba94: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x1eba9c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1eba9c
// Address: 0x1eba9c - 0x1ebac0

void entry_1eba9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eba9c: 0x3c02001f
    SET_GPR_U32(ctx, 2, ((uint32_t)31 << 16));
    // 0x1ebaa0: 0x8e062e10
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    // 0x1ebaa4: 0x2442b698
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294948504));
    // 0x1ebaa8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ebaac: 0xafa2000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    // 0x1ebab0: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1ebab4: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x1ebab8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ebac0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ebac0
// Address: 0x1ebac0 - 0x1ebad4

void entry_1ebac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebac0: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1ebac4: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1ebac8: 0x24060013
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 19));
    // 0x1ebacc: 0xc056a0e
    SET_GPR_U32(ctx, 31, 0x1ebad4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObjectByClass__FP2SWi3CIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1ebad4
// Address: 0x1ebad4 - 0x1ebae0

void entry_1ebad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebad4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ebad8: 0xc07b408
    SET_GPR_U32(ctx, 31, 0x1ebae0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001ed020(rdram, ctx, runtime); return;
}


// Function: entry_1ebae0
// Address: 0x1ebae0 - 0x1ebaf8

void entry_1ebae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebae0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ebae4: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ebae8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1ebaec: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ebaf0: 0xc070302
    SET_GPR_U32(ctx, 31, 0x1ebaf8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3068), *(uint32_t*)&val); }
    FUN_001c0c08(rdram, ctx, runtime); return;
}


// Function: entry_1ebaf8
// Address: 0x1ebaf8 - 0x1ebb10

void entry_1ebaf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ebaf8) {
        switch (ctx->pc) {
            case 0x1ebb00: ctx->pc = 0; goto label_1ebb00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ebaf8: 0x10000054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EBC4C; return;
    }
label_1ebb00:
    // 0x1ebb00: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ebb04: 0x8c62013c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 316)));
    // 0x1ebb08: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ebb10);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ebb10
// Address: 0x1ebb10 - 0x1ebb28

void entry_1ebb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebb10: 0x54400043
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1EBC20; return;
    }
    // 0x1ebb18: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ebb1c: 0x8c620150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x1ebb20: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ebb28);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ebb28
// Address: 0x1ebb28 - 0x1ebc38

void entry_1ebb28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ebb28) {
        switch (ctx->pc) {
            case 0x1ebba8: ctx->pc = 0; goto label_1ebba8;
            case 0x1ebbc8: ctx->pc = 0; goto label_1ebbc8;
            case 0x1ebc1c: ctx->pc = 0; goto label_1ebc1c;
            case 0x1ebc20: ctx->pc = 0; goto label_1ebc20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ebb28: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1ebb2c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ebb30: 0x8c642e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x1ebb34: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ebb38: 0xae250688
    WRITE32(ADD32(GPR_U32(ctx, 17), 1672), GPR_U32(ctx, 5));
    // 0x1ebb3c: 0x60582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1ebb40: 0xac8526c4
    WRITE32(ADD32(GPR_U32(ctx, 4), 9924), GPR_U32(ctx, 5));
    // 0x1ebb44: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1ebb48: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ebb4c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1ebb50: 0xe48026c8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 9928), *(uint32_t*)&val); }
    // 0x1ebb54: 0xe48026cc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 9932), *(uint32_t*)&val); }
    // 0x1ebb58: 0x8e22068c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1676)));
    // 0x1ebb5c: 0x8c430c38
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 3128)));
    // 0x1ebb60: 0x1060002e
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 9936), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1ebc1c;
    }
    // 0x1ebb68: 0x8c620034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x1ebb6c: 0x8c66003c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1ebb70: 0x40482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ebb74: 0xc2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 2)));
    // 0x1ebb78: 0x50400029
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1ebc20;
    }
    // 0x1ebb80: 0x8c640038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1ebb84: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1ebb88: 0x61900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 4));
    // 0x1ebb8c: 0x80502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ebb90: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1ebb94: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ebb98: 0x1045000b
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        goto label_1ebbc8;
    }
    // 0x1ebba0: 0x120282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1ebba4: 0x24080003
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 3));
label_1ebba8:
    // 0x1ebba8: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1ebbac: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1ebbb0: 0xc5102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 5)));
    // 0x1ebbb4: 0x10400019
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ebc1c;
    }
    // 0x1ebbbc: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ebbc0: 0x1448fff9
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 8)) {
        goto label_1ebba8;
    }
label_1ebbc8:
    // 0x1ebbc8: 0xc9102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 9)));
    // 0x1ebbcc: 0x10400013
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 7)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ebc1c;
    }
    // 0x1ebbd4: 0x8e22068c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1676)));
    // 0x1ebbd8: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1ebbdc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ebbe0: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x1ebbe4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ebbe8: 0xc4410c70
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 3184)); ctx->f[1] = *(float*)&val; }
    // 0x1ebbec: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1ebbf0: 0xc4440c7c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 3196)); ctx->f[4] = *(float*)&val; }
    // 0x1ebbf4: 0xc4630008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[3] = *(float*)&val; }
    // 0x1ebbf8: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1ebbfc: 0xc4450c88
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 3208)); ctx->f[5] = *(float*)&val; }
    // 0x1ebc00: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1ebc04: 0x8d622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 11), 11792)));
    // 0x1ebc08: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x1ebc0c: 0x46040840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[4]);
    // 0x1ebc10: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1ebc14: 0x46050002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x1ebc18: 0xe44026d0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 9936), *(uint32_t*)&val); }
label_1ebc1c:
    // 0x1ebc1c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1ebc20:
    // 0x1ebc20: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1ebc24: 0x54620009
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
        ctx->pc = 0x1EBC4C; return;
    }
    // 0x1ebc2c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1ebc30: 0xc064a74
    SET_GPR_U32(ctx, 31, 0x1ebc38);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    SwitchToPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1ebc38
// Address: 0x1ebc38 - 0x1ebc44

void entry_1ebc38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebc38: 0x8e052e10
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 11792)));
    // 0x1ebc3c: 0xc05f388
    SET_GPR_U32(ctx, 31, 0x1ebc44);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1576)));
    ApplyJsg__FP3JSGP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1ebc44
// Address: 0x1ebc44 - 0x1ebc88

void entry_1ebc44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ebc44) {
        switch (ctx->pc) {
            case 0x1ebc4c: ctx->pc = 0; goto label_1ebc4c;
            case 0x1ebc64: ctx->pc = 0; goto label_1ebc64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ebc44: 0xae200628
    WRITE32(ADD32(GPR_U32(ctx, 17), 1576), GPR_U32(ctx, 0));
    // 0x1ebc48: 0x8e22062c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
label_1ebc4c:
    // 0x1ebc4c: 0x8e230630
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1584)));
    // 0x1ebc50: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1ebc54: 0x14430003
    WRITE32(ADD32(GPR_U32(ctx, 17), 1580), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_1ebc64;
    }
    // 0x1ebc5c: 0xae200630
    WRITE32(ADD32(GPR_U32(ctx, 17), 1584), GPR_U32(ctx, 0));
    // 0x1ebc60: 0xae20062c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1580), GPR_U32(ctx, 0));
label_1ebc64:
    // 0x1ebc64: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1ebc68: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ebc6c: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ebc70: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ebc74: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ebc78: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ebc7c: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x1ebc80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ebc88
// Address: 0x1ebc88 - 0x1ebcb0

void FUN_001ebc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebc88: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1ebc8c: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ebc90: 0x8c622c64
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11364)));
    // 0x1ebc94: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ebc98: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ebc9c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1ebca0: 0x14400005
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EBCB8; return;
    }
    // 0x1ebca8: 0xc0776a0
    SET_GPR_U32(ctx, 31, 0x1ebcb0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    IsSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1ebcb0
// Address: 0x1ebcb0 - 0x1ebcd8

void entry_1ebcb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ebcb0) {
        switch (ctx->pc) {
            case 0x1ebcb8: ctx->pc = 0; goto label_1ebcb8;
            case 0x1ebcc0: ctx->pc = 0; goto label_1ebcc0;
            case 0x1ebcc4: ctx->pc = 0; goto label_1ebcc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ebcb0: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1672)));
        goto label_1ebcc0;
    }
label_1ebcb8:
    // 0x1ebcb8: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ebcc4;
    }
label_1ebcc0:
    // 0x1ebcc0: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_1ebcc4:
    // 0x1ebcc4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ebcc8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ebccc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ebcd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ebcd8; return;
}


// Function: FUN_001ebcd8
// Address: 0x1ebcd8 - 0x1ebd10

void FUN_001ebcd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebcd8: 0x8c820630
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1584)));
    // 0x1ebcdc: 0x218c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1ebce0: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1ebce4: 0x24630634
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1588));
    // 0x1ebce8: 0xac820630
    WRITE32(ADD32(GPR_U32(ctx, 4), 1584), GPR_U32(ctx, 2));
    // 0x1ebcec: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1ebcf0: 0x68a20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1ebcf4: 0x6ca20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1ebcf8: 0xb0820007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1ebcfc: 0x3e00008
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ebd04: 0x0
    // NOP
    // 0x1ebd08: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ebd10
// Address: 0x1ebd10 - 0x1ebd40

void FUN_001ebd10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebd10: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x1ebd14: 0x7fb20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 18));
    // 0x1ebd18: 0x7fb10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 17));
    // 0x1ebd1c: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1ebd20: 0x7fb00060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 16));
    // 0x1ebd24: 0x7fbf0090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 31));
    // 0x1ebd28: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ebd2c: 0x8e02067c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1660)));
    // 0x1ebd30: 0x14400005
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EBD48; return;
    }
    // 0x1ebd38: 0xc048954
    SET_GPR_U32(ctx, 31, 0x1ebd40);
    PredictAloPosition__FP3ALOfP6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1ebd40
// Address: 0x1ebd40 - 0x1ebd64

void entry_1ebd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ebd40) {
        switch (ctx->pc) {
            case 0x1ebd48: ctx->pc = 0; goto label_1ebd48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ebd40: 0x1000001d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EBDB8; return;
    }
label_1ebd48:
    // 0x1ebd48: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1ebd4c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ebd50: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ebd54: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ebd58: 0x27a80040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1ebd5c: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x1ebd64);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 80));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1ebd64
// Address: 0x1ebd64 - 0x1ebdd0

void entry_1ebd64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ebd64) {
        switch (ctx->pc) {
            case 0x1ebdb8: ctx->pc = 0; goto label_1ebdb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ebd64: 0x8e02067c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1660)));
    // 0x1ebd68: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ebd6c: 0xd8430040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1ebd70: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ebd74: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ebd78: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1ebd7c: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1ebd80: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ebd84: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ebd88: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ebd8c: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ebd90: 0xfa210000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ebd94: 0x8e02067c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1660)));
    // 0x1ebd98: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ebd9c: 0xd8410040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1ebda0: 0x4bc122fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x1ebda4: 0x4bc4092e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ebda8: 0x4a24212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1ebdac: 0x4be410a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ebdb0: 0xfa420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ebdb4: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_1ebdb8:
    // 0x1ebdb8: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ebdbc: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ebdc0: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ebdc4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ebdcc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ebdd0; return;
}


// Function: FUN_001ebdd0
// Address: 0x1ebdd0 - 0x1ebe00

void FUN_001ebdd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebdd0: 0x27bdff20
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967072));
    // 0x1ebdd4: 0x7fb200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 18));
    // 0x1ebdd8: 0x7fb100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 17));
    // 0x1ebddc: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1ebde0: 0x7fb000a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 16));
    // 0x1ebde4: 0x7fbf00d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 31));
    // 0x1ebde8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ebdec: 0x8e02067c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1660)));
    // 0x1ebdf0: 0x14400005
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EBE08; return;
    }
    // 0x1ebdf8: 0xc048974
    SET_GPR_U32(ctx, 31, 0x1ebe00);
    PredictAloRotation__FP3ALOfP7MATRIX3P6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ebe00
// Address: 0x1ebe00 - 0x1ebe24

void entry_1ebe00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ebe00) {
        switch (ctx->pc) {
            case 0x1ebe08: ctx->pc = 0; goto label_1ebe08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ebe00: 0x10000025
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EBE98; return;
    }
label_1ebe08:
    // 0x1ebe08: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1ebe0c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ebe10: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ebe14: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ebe18: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ebe1c: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x1ebe24);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 48));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1ebe24
// Address: 0x1ebe24 - 0x1ebeb0

void entry_1ebe24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ebe24) {
        switch (ctx->pc) {
            case 0x1ebe98: ctx->pc = 0; goto label_1ebe98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ebe24: 0x8e02067c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1660)));
    // 0x1ebe28: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ebe2c: 0xd8440050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x1ebe30: 0xdba60010
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ebe34: 0x24420050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 80));
    // 0x1ebe38: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ebe3c: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1ebe40: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x1ebe44: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ebe48: 0x7ba30030
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ebe4c: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1ebe50: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1ebe54: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1ebe58: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1ebe5c: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ebe60: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ebe64: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ebe68: 0xfba20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ebe6c: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1ebe70: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1ebe74: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ebe78: 0x4bc128ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ebe7c: 0xfa240000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1ebe80: 0xfa230020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1ebe84: 0xfa220010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ebe88: 0x7e430000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 3));
    // 0x1ebe8c: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1ebe90: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1ebe94: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
label_1ebe98:
    // 0x1ebe98: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ebe9c: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ebea0: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1ebea4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ebeac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ebeb0; return;
}


// Function: FUN_001ebeb0
// Address: 0x1ebeb0 - 0x1ebec4

void FUN_001ebeb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebeb0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ebeb4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ebeb8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ebebc: 0xc071bd2
    SET_GPR_U32(ctx, 31, 0x1ebec4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    InitStepguard__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1ebec4
// Address: 0x1ebec4 - 0x1ebf04

void entry_1ebec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebec4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ebec8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ebecc: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1ebed0: 0x3c014100
    SET_GPR_U32(ctx, 1, ((uint32_t)16640 << 16));
    // 0x1ebed4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ebed8: 0x24030008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1ebedc: 0x2402003c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 60));
    // 0x1ebee0: 0xae000c70
    WRITE32(ADD32(GPR_U32(ctx, 16), 3184), GPR_U32(ctx, 0));
    // 0x1ebee4: 0xe6010c8c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 3212), *(uint32_t*)&val); }
    // 0x1ebee8: 0x24040400
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1024));
    // 0x1ebeec: 0xe6000c64
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3172), *(uint32_t*)&val); }
    // 0x1ebef0: 0xae050c74
    WRITE32(ADD32(GPR_U32(ctx, 16), 3188), GPR_U32(ctx, 5));
    // 0x1ebef4: 0xae050c78
    WRITE32(ADD32(GPR_U32(ctx, 16), 3192), GPR_U32(ctx, 5));
    // 0x1ebef8: 0xae030c60
    WRITE32(ADD32(GPR_U32(ctx, 16), 3168), GPR_U32(ctx, 3));
    // 0x1ebefc: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1ebf04);
    WRITE32(ADD32(GPR_U32(ctx, 16), 3164), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1ebf04
// Address: 0x1ebf04 - 0x1ebf18

void entry_1ebf04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebf04: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1ebf08: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ebf0c: 0xae020c6c
    WRITE32(ADD32(GPR_U32(ctx, 16), 3180), GPR_U32(ctx, 2));
    // 0x1ebf10: 0xc06fa9e
    SET_GPR_U32(ctx, 31, 0x1ebf18);
    WRITE32(ADD32(GPR_U32(ctx, 4), 9048), GPR_U32(ctx, 3));
    KillMusic__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1ebf18
// Address: 0x1ebf18 - 0x1ebf40

void entry_1ebf18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebf18: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1ebf1c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ebf20: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1ebf24: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ebf28: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ebf2c: 0xac825db8
    WRITE32(ADD32(GPR_U32(ctx, 4), 23992), GPR_U32(ctx, 2));
    // 0x1ebf30: 0xac605dbc
    WRITE32(ADD32(GPR_U32(ctx, 3), 23996), GPR_U32(ctx, 0));
    // 0x1ebf34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ebf3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ebf40; return;
}


// Function: LoadMbgFromBrx
// Address: 0x1ebf40 - 0x1ebf68

void entry_1ebf68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ebf68) {
        switch (ctx->pc) {
            case 0x1ebf70: ctx->pc = 0; goto label_1ebf70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ebf68: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ebf6c: 0x24515cf8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 23800));
label_1ebf70:
    // 0x1ebf70: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ebf74: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ebf78: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x1ebf7c: 0xc0729d6
    SET_GPR_U32(ctx, 31, 0x1ebf84);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    PasegFindStepguard__FP9STEPGUARD3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ebf84
// Address: 0x1ebf84 - 0x1ebfb0

void entry_1ebf84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebf84: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1ebf88: 0x641fff9
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x1EBF70; return;
    }
    // 0x1ebf90: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ebf94: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ebf98: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ebf9c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ebfa0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ebfa4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ebfac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ebfb0; return;
}


// Function: FUN_001ebfb0
// Address: 0x1ebfb0 - 0x1ebfd4

void FUN_001ebfb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebfb0: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x1ebfb4: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1ebfb8: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ebfbc: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x1ebfc0: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x1ebfc4: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1ebfc8: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ebfcc: 0xc071ca8
    SET_GPR_U32(ctx, 31, 0x1ebfd4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    PostStepguardLoad__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1ebfd4
// Address: 0x1ebfd4 - 0x1ebfe0

void entry_1ebfd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebfd4: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1ebfd8: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x1ebfe0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_1ebfe0
// Address: 0x1ebfe0 - 0x1ebff4

void entry_1ebfe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebfe0: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1ebfe4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ebfe8: 0x24c65d08
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 23816));
    // 0x1ebfec: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1ebff4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1ebff4
// Address: 0x1ebff4 - 0x1ec008

void entry_1ebff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ebff4: 0x8e240c50
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 3152)));
    // 0x1ebff8: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1ebffc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ec000: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1ec008);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1ec008
// Address: 0x1ec008 - 0x1ec018

void entry_1ec008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec008: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ec00c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ec010: 0xc06db7e
    SET_GPR_U32(ctx, 31, 0x1ec018);
    WRITE32(ADD32(GPR_U32(ctx, 17), 3156), GPR_U32(ctx, 2));
    FUN_001b6df8(rdram, ctx, runtime); return;
}


// Function: entry_1ec018
// Address: 0x1ec018 - 0x1ec030

void entry_1ec018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec018: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    // 0x1ec01c: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1ec020: 0xae220c98
    WRITE32(ADD32(GPR_U32(ctx, 17), 3224), GPR_U32(ctx, 2));
    // 0x1ec024: 0x24a55d48
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 23880));
    // 0x1ec028: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x1ec030);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 108));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_1ec030
// Address: 0x1ec030 - 0x1ec068

void entry_1ec030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec030) {
        switch (ctx->pc) {
            case 0x1ec048: ctx->pc = 0; goto label_1ec048;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec030: 0x8e230c98
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 3224)));
    // 0x1ec034: 0x18600011
    WRITE32(ADD32(GPR_U32(ctx, 17), 3228), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1EC07C; return;
    }
    // 0x1ec03c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ec040: 0x8e300c9c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 3228)));
    // 0x1ec044: 0x0
    // NOP
label_1ec048:
    // 0x1ec048: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ec04c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1ec050: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ec054: 0x2128021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 18)));
    // 0x1ec058: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1ec05c: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ec060: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1ec068);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 12));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1ec068
// Address: 0x1ec068 - 0x1ec098

void entry_1ec068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec068) {
        switch (ctx->pc) {
            case 0x1ec07c: ctx->pc = 0; goto label_1ec07c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec068: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x1ec06c: 0x8e220c98
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3224)));
    // 0x1ec070: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1ec074: 0x5440fff4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 3228)));
        ctx->pc = 0x1EC048; return;
    }
label_1ec07c:
    // 0x1ec07c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ec080: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ec084: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ec088: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ec08c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ec090: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ec098
// Address: 0x1ec098 - 0x1ec0a8

void FUN_001ec098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec098: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ec09c: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ec0a0: 0xc064a14
    SET_GPR_U32(ctx, 31, 0x1ec0a8);
    OnPoRemove__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1ec0a8
// Address: 0x1ec0a8 - 0x1ec0b8

void entry_1ec0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec0a8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ec0ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ec0b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ec0b8; return;
}


// Function: FUN_001ec0b8
// Address: 0x1ec0b8 - 0x1ec0c8

void FUN_001ec0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec0b8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ec0bc: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ec0c0: 0xc064a08
    SET_GPR_U32(ctx, 31, 0x1ec0c8);
    OnPoAdd__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1ec0c8
// Address: 0x1ec0c8 - 0x1ec0d8

void entry_1ec0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec0c8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ec0cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ec0d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ec0d8; return;
}


// Function: FUN_001ec0d8
// Address: 0x1ec0d8 - 0x1ec0f4

void FUN_001ec0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec0d8: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1ec0dc: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1ec0e0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ec0e4: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1ec0e8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ec0ec: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1ec0f4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3156)));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ec0f4
// Address: 0x1ec0f4 - 0x1ec190

void entry_1ec0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec0f4) {
        switch (ctx->pc) {
            case 0x1ec12c: ctx->pc = 0; goto label_1ec12c;
            case 0x1ec15c: ctx->pc = 0; goto label_1ec15c;
            case 0x1ec16c: ctx->pc = 0; goto label_1ec16c;
            case 0x1ec170: ctx->pc = 0; goto label_1ec170;
            case 0x1ec174: ctx->pc = 0; goto label_1ec174;
            case 0x1ec178: ctx->pc = 0; goto label_1ec178;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec0f4: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ec0f8: 0x2444fb13
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294966035));
    // 0x1ec0fc: 0x2c83000b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 11));
    // 0x1ec100: 0x1060001b
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1ec170;
    }
    // 0x1ec108: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1ec10c: 0x2442e6d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294960848));
    // 0x1ec110: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ec114: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ec118: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1ec120: 0x8e020c20
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3104)));
    // 0x1ec124: 0x10400013
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ec174;
    }
label_1ec12c:
    // 0x1ec12c: 0x10000011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ec174;
    }
    // 0x1ec134: 0x8e030c94
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 3220)));
    // 0x1ec138: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ec13c: 0x1064000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_1ec170;
    }
    // 0x1ec144: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ec15c;
    }
    // 0x1ec14c: 0x10600007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1ec16c;
    }
    // 0x1ec154: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ec178;
    }
label_1ec15c:
    // 0x1ec15c: 0x1062fff3
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ec12c;
    }
    // 0x1ec164: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ec178;
    }
label_1ec16c:
    // 0x1ec16c: 0xae040c94
    WRITE32(ADD32(GPR_U32(ctx, 16), 3220), GPR_U32(ctx, 4));
label_1ec170:
    // 0x1ec170: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1ec174:
    // 0x1ec174: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1ec178:
    // 0x1ec178: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ec17c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ec184: 0x0
    // NOP
    // 0x1ec188: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ec190
// Address: 0x1ec190 - 0x1ec1e0

void FUN_001ec190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec190: 0x27bdfec0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966976));
    // 0x1ec194: 0x7fb300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 19));
    // 0x1ec198: 0x7fb60120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 22));
    // 0x1ec19c: 0x3c130027
    SET_GPR_U32(ctx, 19, ((uint32_t)39 << 16));
    // 0x1ec1a0: 0x7fbf0130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 31));
    // 0x1ec1a4: 0x80b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ec1a8: 0x7fb50110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 21));
    // 0x1ec1ac: 0x7fb40100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 20));
    // 0x1ec1b0: 0x7fb100d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 17));
    // 0x1ec1b4: 0x7fb000c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 16));
    // 0x1ec1b8: 0x7fb200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 18));
    // 0x1ec1bc: 0x8e625db4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 23988)));
    // 0x1ec1c0: 0x14400028
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 22), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EC264; return;
    }
    // 0x1ec1c8: 0x3c110062
    SET_GPR_U32(ctx, 17, ((uint32_t)98 << 16));
    // 0x1ec1cc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ec1d0: 0x263056e0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 22240));
    // 0x1ec1d4: 0x24060080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    // 0x1ec1d8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1ec1e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1ec1e0
// Address: 0x1ec1e0 - 0x1ec2b8

void entry_1ec1e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec1e0) {
        switch (ctx->pc) {
            case 0x1ec264: ctx->pc = 0; goto label_1ec264;
            case 0x1ec290: ctx->pc = 0; goto label_1ec290;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec1e0: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1ec1e4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ec1e8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ec1ec: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ec1f0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ec1f4: 0x3c0280ff
    SET_GPR_U32(ctx, 2, ((uint32_t)33023 << 16));
    // 0x1ec1f8: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1ec1fc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ec200: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1ec204: 0xae2356e0
    WRITE32(ADD32(GPR_U32(ctx, 17), 22240), GPR_U32(ctx, 3));
    // 0x1ec208: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1ec20c: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1ec210: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1ec214: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1ec218: 0xe6020024
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    // 0x1ec21c: 0xe6000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x1ec220: 0xe6010044
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 68), *(uint32_t*)&val); }
    // 0x1ec224: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ec228: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ec22c: 0xe6040004
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x1ec230: 0xe6030008
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1ec234: 0xae020028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 2));
    // 0x1ec238: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x1ec23c: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x1ec240: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ec244: 0x3c01c2c8
    SET_GPR_U32(ctx, 1, ((uint32_t)49864 << 16));
    // 0x1ec248: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ec24c: 0xae020068
    WRITE32(ADD32(GPR_U32(ctx, 16), 104), GPR_U32(ctx, 2));
    // 0x1ec250: 0xae635db4
    WRITE32(ADD32(GPR_U32(ctx, 19), 23988), GPR_U32(ctx, 3));
    // 0x1ec254: 0xe6000050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 80), *(uint32_t*)&val); }
    // 0x1ec258: 0xe6020060
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 96), *(uint32_t*)&val); }
    // 0x1ec25c: 0xe6010064
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 100), *(uint32_t*)&val); }
    // 0x1ec260: 0xe6020054
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 84), *(uint32_t*)&val); }
label_1ec264:
    // 0x1ec264: 0x8e420298
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 664)));
    // 0x1ec268: 0x1040003a
    SET_GPR_U32(ctx, 2, ((uint32_t)98 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ec354(rdram, ctx, runtime); return;
    }
    // 0x1ec270: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ec274: 0x244256e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 22240));
    // 0x1ec278: 0x27b00080
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1ec27c: 0x24440080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 128));
    // 0x1ec280: 0x27b10090
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1ec284: 0x27b300a0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 160));
    // 0x1ec288: 0x27b400b0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1ec28c: 0x26550140
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 18), 320));
label_1ec290:
    // 0x1ec290: 0x78450000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ec294: 0x78460010
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1ec298: 0x7c650000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 5));
    // 0x1ec29c: 0x7c660010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 6));
    // 0x1ec2a0: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x1ec2a4: 0x1444fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_1ec290;
    }
    // 0x1ec2ac: 0xafa00070
    WRITE32(ADD32(GPR_U32(ctx, 29), 112), GPR_U32(ctx, 0));
    // 0x1ec2b0: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x1ec2b8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 349));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ec2b8
// Address: 0x1ec2b8 - 0x1ec2d0

void entry_1ec2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec2b8: 0xafa20074
    WRITE32(ADD32(GPR_U32(ctx, 29), 116), GPR_U32(ctx, 2));
    // 0x1ec2bc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ec2c0: 0x8e420298
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 664)));
    // 0x1ec2c4: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1ec2c8: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1ec2d0);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[12]);
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1ec2d0
// Address: 0x1ec2d0 - 0x1ec2e0

void entry_1ec2d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec2d0: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ec2d4: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1ec2d8: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1ec2e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ec2e0
// Address: 0x1ec2e0 - 0x1ec2ec

void entry_1ec2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec2e0: 0x7ba50090
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1ec2e4: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1ec2ec);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ec2ec
// Address: 0x1ec2ec - 0x1ec2f8

void entry_1ec2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec2ec: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1ec2f0: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1ec2f8);
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ec2f8
// Address: 0x1ec2f8 - 0x1ec308

void entry_1ec2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec2f8: 0x8e430298
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 664)));
    // 0x1ec2fc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ec300: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1ec308);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[12] = *(float*)&val; }
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1ec308
// Address: 0x1ec308 - 0x1ec318

void entry_1ec308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec308: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1ec30c: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1ec310: 0xc046344
    SET_GPR_U32(ctx, 31, 0x1ec318);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ec318
// Address: 0x1ec318 - 0x1ec324

void entry_1ec318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec318: 0x7ba500b0
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ec31c: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x1ec324);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 16)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ec324
// Address: 0x1ec324 - 0x1ec330

void entry_1ec324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec324: 0x70022ca9
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x1ec328: 0xc046348
    SET_GPR_U32(ctx, 31, 0x1ec330);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ec330
// Address: 0x1ec330 - 0x1ec354

void entry_1ec330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec330: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1ec334: 0x8e480c9c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 3228)));
    // 0x1ec338: 0x8e470c98
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 3224)));
    // 0x1ec33c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1ec340: 0x24c65070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 20592));
    // 0x1ec344: 0x2c0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1ec348: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1ec34c: 0xc07559e
    SET_GPR_U32(ctx, 31, 0x1ec354);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    DrawHaloSpks__FP6VECTORiP4SPKSP4SPKDP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1ec354
// Address: 0x1ec354 - 0x1ec380

void entry_1ec354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec354: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1ec358: 0x7bb60120
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1ec35c: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1ec360: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1ec364: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1ec368: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1ec36c: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1ec370: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ec374: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ec37c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ec380; return;
}


// Function: FUN_001ec380
// Address: 0x1ec380 - 0x1ec3b0

void FUN_001ec380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec380: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x1ec384: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1ec388: 0x7fb10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 17));
    // 0x1ec38c: 0x7fb00050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 16));
    // 0x1ec390: 0x7fbf0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 31));
    // 0x1ec394: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ec398: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1ec39c: 0x14620006
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EC3B8; return;
    }
    // 0x1ec3a4: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1ec3a8: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x1ec3b0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_1ec3b0
// Address: 0x1ec3b0 - 0x1ec3c4

void entry_1ec3b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec3b0) {
        switch (ctx->pc) {
            case 0x1ec3b8: ctx->pc = 0; goto label_1ec3b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec3b0: 0xafa00044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 0));
    // 0x1ec3b4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_1ec3b8:
    // 0x1ec3b8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ec3bc: 0xc049724
    SET_GPR_U32(ctx, 31, 0x1ec3c4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RenderAloAll__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_1ec3c4
// Address: 0x1ec3c4 - 0x1ec3d8

void entry_1ec3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec3c4: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ec3c8: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ec3cc: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ec3d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ec3d8
// Address: 0x1ec3d8 - 0x1ec3f4

void FUN_001ec3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec3d8: 0x27bdff50
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967120));
    // 0x1ec3dc: 0x7fb10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 17));
    // 0x1ec3e0: 0x7fb00080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 16));
    // 0x1ec3e4: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ec3e8: 0x7fbf00a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 31));
    // 0x1ec3ec: 0xc072978
    SET_GPR_U32(ctx, 31, 0x1ec3f4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    RenderStepguardSelf__FP9STEPGUARDP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_1ec3f4
// Address: 0x1ec3f4 - 0x1ec414

void entry_1ec3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec3f4: 0x8e230724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1828)));
    // 0x1ec3f8: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1ec3fc: 0x14620019
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EC464; return;
    }
    // 0x1ec404: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ec408: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ec40c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1ec414);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1ec414
// Address: 0x1ec414 - 0x1ec460

void entry_1ec414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec414: 0xda030040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1ec418: 0x3c03001f
    SET_GPR_U32(ctx, 3, ((uint32_t)31 << 16));
    // 0x1ec41c: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1ec420: 0x2463c190
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294951312));
    // 0x1ec424: 0xda010080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x1ec428: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ec42c: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ec430: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ec434: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ec438: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ec43c: 0x2402000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    // 0x1ec440: 0x48241000
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ec444: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x1ec448: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1ec44c: 0xafb10060
    WRITE32(ADD32(GPR_U32(ctx, 29), 96), GPR_U32(ctx, 17));
    // 0x1ec450: 0xe7a00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x1ec454: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ec458: 0xc067504
    SET_GPR_U32(ctx, 31, 0x1ec460);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    SubmitRpl__FP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_1ec460
// Address: 0x1ec460 - 0x1ec478

void entry_1ec460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec460) {
        switch (ctx->pc) {
            case 0x1ec464: ctx->pc = 0; goto label_1ec464;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec460: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_1ec464:
    // 0x1ec464: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1ec468: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1ec46c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ec474: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ec478; return;
}


// Function: FUN_001ec478
// Address: 0x1ec478 - 0x1ec490

void FUN_001ec478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec478: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1ec47c: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1ec480: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ec484: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1ec488: 0xc072402
    SET_GPR_U32(ctx, 31, 0x1ec490);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    OnStepguardExitingSgs__FP9STEPGUARD3SGS(rdram, ctx, runtime); return;
}


// Function: entry_1ec490
// Address: 0x1ec490 - 0x1ec4b8

void entry_1ec490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec490: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1ec494: 0x2402000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1ec498: 0x1062001c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EC50C; return;
    }
    // 0x1ec4a0: 0x1462001c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EC514; return;
    }
    // 0x1ec4a8: 0xae000c94
    WRITE32(ADD32(GPR_U32(ctx, 16), 3220), GPR_U32(ctx, 0));
    // 0x1ec4ac: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ec4b0: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1ec4b8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3156)));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ec4b8
// Address: 0x1ec4b8 - 0x1ec504

void entry_1ec4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec4b8) {
        switch (ctx->pc) {
            case 0x1ec4e0: ctx->pc = 0; goto label_1ec4e0;
            case 0x1ec4f4: ctx->pc = 0; goto label_1ec4f4;
            case 0x1ec4f8: ctx->pc = 0; goto label_1ec4f8;
            case 0x1ec4fc: ctx->pc = 0; goto label_1ec4fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec4b8: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ec4bc: 0x240204f1
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1265));
    // 0x1ec4c0: 0x1062000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1266));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ec4f4;
    }
    // 0x1ec4c8: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1262));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ec4e0;
    }
    // 0x1ec4d0: 0x50620009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1263));
        goto label_1ec4f8;
    }
    // 0x1ec4d8: 0x10000008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3156)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ec4fc;
    }
label_1ec4e0:
    // 0x1ec4e0: 0x240204f4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1268));
    // 0x1ec4e4: 0x50620004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1269));
        goto label_1ec4f8;
    }
    // 0x1ec4ec: 0x10000003
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3156)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ec4fc;
    }
label_1ec4f4:
    // 0x1ec4f4: 0x241104f2
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1266));
label_1ec4f8:
    // 0x1ec4f8: 0x8e040c54
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3156)));
label_1ec4fc:
    // 0x1ec4fc: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1ec504);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ec504
// Address: 0x1ec504 - 0x1ec528

void entry_1ec504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec504) {
        switch (ctx->pc) {
            case 0x1ec50c: ctx->pc = 0; goto label_1ec50c;
            case 0x1ec514: ctx->pc = 0; goto label_1ec514;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec504: 0x10000003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ec514;
    }
label_1ec50c:
    // 0x1ec50c: 0xae000c94
    WRITE32(ADD32(GPR_U32(ctx, 16), 3220), GPR_U32(ctx, 0));
    // 0x1ec510: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1ec514:
    // 0x1ec514: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ec518: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ec51c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ec524: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ec528; return;
}


// Function: FUN_001ec528
// Address: 0x1ec528 - 0x1ec54c

void FUN_001ec528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec528: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1ec52c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ec530: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1ec534: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1ec538: 0x2610e248
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294959688));
    // 0x1ec53c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ec540: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1ec544: 0xc06b018
    SET_GPR_U32(ctx, 31, 0x1ec54c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001ac060(rdram, ctx, runtime); return;
}


// Function: entry_1ec54c
// Address: 0x1ec54c - 0x1ec570

void entry_1ec54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec54c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ec550: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ec554: 0xae220a68
    WRITE32(ADD32(GPR_U32(ctx, 17), 2664), GPR_U32(ctx, 2));
    // 0x1ec558: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ec55c: 0xc6000278
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 632)); ctx->f[0] = *(float*)&val; }
    // 0x1ec560: 0xe6000274
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 628), *(uint32_t*)&val); }
    // 0x1ec564: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ec568: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ec570
// Address: 0x1ec570 - 0x1ec5d8

void FUN_001ec570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec570) {
        switch (ctx->pc) {
            case 0x1ec5b8: ctx->pc = 0; goto label_1ec5b8;
            case 0x1ec5cc: ctx->pc = 0; goto label_1ec5cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec570: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x1ec574: 0x2402000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1ec578: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x1ec57c: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x1ec580: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ec584: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1ec588: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x1ec58c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ec590: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1ec594: 0x1062000d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ec5cc;
    }
    // 0x1ec59c: 0x2862000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 15));
    // 0x1ec5a0: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ec5b8;
    }
    // 0x1ec5a8: 0x10620021
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EC630; return;
    }
    // 0x1ec5b0: 0x10000027
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EC650; return;
    }
label_1ec5b8:
    // 0x1ec5b8: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1ec5bc: 0x10620018
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EC620; return;
    }
    // 0x1ec5c4: 0x10000022
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EC650; return;
    }
label_1ec5cc:
    // 0x1ec5cc: 0x8e040c54
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3156)));
    // 0x1ec5d0: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1ec5d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ec5d8
// Address: 0x1ec5d8 - 0x1ec628

void entry_1ec5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec5d8) {
        switch (ctx->pc) {
            case 0x1ec600: ctx->pc = 0; goto label_1ec600;
            case 0x1ec614: ctx->pc = 0; goto label_1ec614;
            case 0x1ec620: ctx->pc = 0; goto label_1ec620;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec5d8: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ec5dc: 0x240204f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1264));
    // 0x1ec5e0: 0x1062000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1265));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ec614;
    }
    // 0x1ec5e8: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1261));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ec600;
    }
    // 0x1ec5f0: 0x10620008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ec614;
    }
    // 0x1ec5f8: 0x10000016
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EC654; return;
    }
label_1ec600:
    // 0x1ec600: 0x240204f3
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1267));
    // 0x1ec604: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1270));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ec614;
    }
    // 0x1ec60c: 0x14620010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EC650; return;
    }
label_1ec614:
    // 0x1ec614: 0x8e110c20
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 3104)));
    // 0x1ec618: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 3104), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ec64c(rdram, ctx, runtime); return;
    }
label_1ec620:
    // 0x1ec620: 0xc06b018
    SET_GPR_U32(ctx, 31, 0x1ec628);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    FUN_001ac060(rdram, ctx, runtime); return;
}


// Function: entry_1ec628
// Address: 0x1ec628 - 0x1ec638

void entry_1ec628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec628) {
        switch (ctx->pc) {
            case 0x1ec630: ctx->pc = 0; goto label_1ec630;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec628: 0x10000009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EC650; return;
    }
label_1ec630:
    // 0x1ec630: 0xc06b018
    SET_GPR_U32(ctx, 31, 0x1ec638);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    FUN_001ac060(rdram, ctx, runtime); return;
}


// Function: entry_1ec638
// Address: 0x1ec638 - 0x1ec640

void entry_1ec638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec638: 0xc0580fa
    SET_GPR_U32(ctx, 31, 0x1ec640);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    DefeatBossFromWid(rdram, ctx, runtime); return;
}


// Function: entry_1ec640
// Address: 0x1ec640 - 0x1ec64c

void entry_1ec640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec640: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1ec644: 0xc0631fe
    SET_GPR_U32(ctx, 31, 0x1ec64c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c7f8__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_1ec64c
// Address: 0x1ec64c - 0x1ec65c

void entry_1ec64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec64c) {
        switch (ctx->pc) {
            case 0x1ec650: ctx->pc = 0; goto label_1ec650;
            case 0x1ec654: ctx->pc = 0; goto label_1ec654;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec64c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1ec650:
    // 0x1ec650: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1ec654:
    // 0x1ec654: 0xc072472
    SET_GPR_U32(ctx, 31, 0x1ec65c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1ec65c
// Address: 0x1ec65c - 0x1ec694

void entry_1ec65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec65c: 0x8e020724
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1ec660: 0x2444fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x1ec664: 0x2c83000f
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 15));
    // 0x1ec668: 0x10600049
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EC790; return;
    }
    // 0x1ec670: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1ec674: 0x2442e700
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294960896));
    // 0x1ec678: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ec67c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ec680: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1ec688: 0x8e040c54
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3156)));
    // 0x1ec68c: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1ec694);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ec694
// Address: 0x1ec694 - 0x1ec738

void entry_1ec694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec694) {
        switch (ctx->pc) {
            case 0x1ec6bc: ctx->pc = 0; goto label_1ec6bc;
            case 0x1ec6d8: ctx->pc = 0; goto label_1ec6d8;
            case 0x1ec6ec: ctx->pc = 0; goto label_1ec6ec;
            case 0x1ec704: ctx->pc = 0; goto label_1ec704;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec694: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ec698: 0x240204f1
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1265));
    // 0x1ec69c: 0x10620013
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1266));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ec6ec;
    }
    // 0x1ec6a4: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1262));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ec6bc;
    }
    // 0x1ec6ac: 0x1062000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ec6d8;
    }
    // 0x1ec6b4: 0x10000038
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EC798; return;
    }
label_1ec6bc:
    // 0x1ec6bc: 0x240204f4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1268));
    // 0x1ec6c0: 0x1062000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1271));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ec6ec;
    }
    // 0x1ec6c8: 0x10620008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ec6ec;
    }
    // 0x1ec6d0: 0x10000031
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EC798; return;
    }
label_1ec6d8:
    // 0x1ec6d8: 0x8e0307e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1ec6dc: 0xc6010c88
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3208)); ctx->f[1] = *(float*)&val; }
    // 0x1ec6e0: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1ec6e4: 0x10000007
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ec704;
    }
label_1ec6ec:
    // 0x1ec6ec: 0x8e0307e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1ec6f0: 0xc6010c88
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3208)); ctx->f[1] = *(float*)&val; }
    // 0x1ec6f4: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x1ec6f8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ec6fc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1ec700: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
label_1ec704:
    // 0x1ec704: 0x3c013daa
    SET_GPR_U32(ctx, 1, ((uint32_t)15786 << 16));
    // 0x1ec708: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x1ec70c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ec710: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1ec714: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1ec718: 0xe4600018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 24), *(uint32_t*)&val); }
    // 0x1ec71c: 0x8e0207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1ec720: 0x1000001b
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 20), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EC790; return;
    }
    // 0x1ec728: 0x8e040c54
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3156)));
    // 0x1ec72c: 0x37a50008
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 8));
    // 0x1ec730: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1ec738);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ec738
// Address: 0x1ec738 - 0x1ec760

void entry_1ec738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec738) {
        switch (ctx->pc) {
            case 0x1ec750: ctx->pc = 0; goto label_1ec750;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec738: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1ec73c: 0x286204ef
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1263));
    // 0x1ec740: 0x10400003
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), 1260));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ec750;
    }
    // 0x1ec748: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ec74c: 0x43880a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 2));
label_1ec750:
    // 0x1ec750: 0x8e0507e0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1ec754: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ec758: 0xc07b424
    SET_GPR_U32(ctx, 31, 0x1ec760);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001ed090(rdram, ctx, runtime); return;
}


// Function: entry_1ec760
// Address: 0x1ec760 - 0x1ec7a8

void entry_1ec760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec760) {
        switch (ctx->pc) {
            case 0x1ec790: ctx->pc = 0; goto label_1ec790;
            case 0x1ec798: ctx->pc = 0; goto label_1ec798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec760: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ec764: 0x44910000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 17);
    // 0x1ec768: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ec76c: 0xc6010c7c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3196)); ctx->f[1] = *(float*)&val; }
    // 0x1ec770: 0x8e0307e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x1ec774: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1ec778: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1ec77c: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x1ec780: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1ec784: 0x10000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 20), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ec790;
    }
    // 0x1ec78c: 0xae000c04
    WRITE32(ADD32(GPR_U32(ctx, 16), 3076), GPR_U32(ctx, 0));
label_1ec790:
    // 0x1ec790: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ec794: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1ec798:
    // 0x1ec798: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ec79c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ec7a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ec7a8
// Address: 0x1ec7a8 - 0x1ec81c

void FUN_001ec7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec7a8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ec7ac: 0xa0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ec7b0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ec7b4: 0x80382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ec7b8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ec7bc: 0x8d28000c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 9), 12)));
    // 0x1ec7c0: 0x81080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 8), 2));
    // 0x1ec7c4: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1ec7c8: 0xe21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x1ec7cc: 0xc4e30c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 3168)); ctx->f[3] = *(float*)&val; }
    // 0x1ec7d0: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1ec7d4: 0x8c430c10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 3088)));
    // 0x1ec7d8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ec7dc: 0xace80c40
    WRITE32(ADD32(GPR_U32(ctx, 7), 3136), GPR_U32(ctx, 8));
    // 0x1ec7e0: 0xace30c20
    WRITE32(ADD32(GPR_U32(ctx, 7), 3104), GPR_U32(ctx, 3));
    // 0x1ec7e4: 0x8ce40c3c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 3132)));
    // 0x1ec7e8: 0xc4c1185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1ec7ec: 0xafa80000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 8));
    // 0x1ec7f0: 0xe4e10c44
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 7), 3140), *(uint32_t*)&val); }
    // 0x1ec7f4: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x1ec7f8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ec7fc: 0xc5200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1ec800: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ec804: 0xc5210008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1ec808: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1ec80c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ec810: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x1ec814: 0xc07af36
    SET_GPR_U32(ctx, 31, 0x1ec81c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    FUN_001ebcd8(rdram, ctx, runtime); return;
}


// Function: entry_1ec81c
// Address: 0x1ec81c - 0x1ec828

void entry_1ec81c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec81c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ec820: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ec828
// Address: 0x1ec828 - 0x1ec8c4

void FUN_001ec828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec828) {
        switch (ctx->pc) {
            case 0x1ec874: ctx->pc = 0; goto label_1ec874;
            case 0x1ec888: ctx->pc = 0; goto label_1ec888;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec828: 0x27bdff10
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967056));
    // 0x1ec82c: 0x24020013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 19));
    // 0x1ec830: 0x7fb300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 19));
    // 0x1ec834: 0x7fb200b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 18));
    // 0x1ec838: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ec83c: 0x7fb100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 17));
    // 0x1ec840: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ec844: 0x7fbf00d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 31));
    // 0x1ec848: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1ec84c: 0x7fb00090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 16));
    // 0x1ec850: 0x1262000d
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 224), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        goto label_1ec888;
    }
    // 0x1ec858: 0x2a620014
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 20));
    // 0x1ec85c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ec874;
    }
    // 0x1ec864: 0x12620058
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EC9C8; return;
    }
    // 0x1ec86c: 0x100000a0
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECAF0; return;
    }
label_1ec874:
    // 0x1ec874: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x1ec878: 0x1262006a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1ECA24; return;
    }
    // 0x1ec880: 0x1000009b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECAF0; return;
    }
label_1ec888:
    // 0x1ec888: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ec88c: 0x8e4207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 2016)));
    // 0x1ec890: 0x14620096
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1ECAEC; return;
    }
    // 0x1ec898: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1ec89c: 0x240201a5
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 421));
    // 0x1ec8a0: 0x14620093
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1ECAF0; return;
    }
    // 0x1ec8a8: 0x8e420c40
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3136)));
    // 0x1ec8ac: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1ec8b0: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1ec8b4: 0x8c510c24
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 3108)));
    // 0x1ec8b8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ec8bc: 0xc06a2be
    SET_GPR_U32(ctx, 31, 0x1ec8c4);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 96));
    ReloadRwm__FP3RWM(rdram, ctx, runtime); return;
}


// Function: entry_1ec8c4
// Address: 0x1ec8c4 - 0x1ec924

void entry_1ec8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec8c4: 0xc6420c44
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 3140)); ctx->f[2] = *(float*)&val; }
    // 0x1ec8c8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ec8cc: 0xc6410c88
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 3208)); ctx->f[1] = *(float*)&val; }
    // 0x1ec8d0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ec8d4: 0xc6540c64
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 3172)); ctx->f[20] = *(float*)&val; }
    // 0x1ec8d8: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ec8dc: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ec8e0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ec8e4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ec8e8: 0x8e430c3c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 3132)));
    // 0x1ec8ec: 0x4602a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[2]);
    // 0x1ec8f0: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1ec8f4: 0xc442185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[2] = *(float*)&val; }
    // 0x1ec8f8: 0xc4600684
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 1668)); ctx->f[0] = *(float*)&val; }
    // 0x1ec8fc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ec900: 0x8e420c40
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3136)));
    // 0x1ec904: 0x4602a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[2]);
    // 0x1ec908: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1ec90c: 0x8e320048
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 72)));
    // 0x1ec910: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1ec914: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ec918: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1ec91c: 0xc06a530
    SET_GPR_U32(ctx, 31, 0x1ec924);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 1560)));
    GetRwfiPosMat__FP4RWFIP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1ec924
// Address: 0x1ec924 - 0x1ec944

void entry_1ec924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec924: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x1ec928: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ec92c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ec930: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ec934: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1ec938: 0x27a60070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1ec93c: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x1ec944);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1ec944
// Address: 0x1ec944 - 0x1ec9c0

void entry_1ec944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ec944: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ec948: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ec94c: 0xda030040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1ec950: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ec954: 0xdba50040
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ec958: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ec95c: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1ec960: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1ec964: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1ec968: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ec96c: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ec970: 0x3c013fa0
    SET_GPR_U32(ctx, 1, ((uint32_t)16288 << 16));
    // 0x1ec974: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ec978: 0xfa2200f0
    WRITE128(ADD32(GPR_U32(ctx, 17), 240), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ec97c: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x1ec980: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ec984: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ec988: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ec98c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ec990: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ec994: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ec998: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ec99c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ec9a0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ec9a4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ec9a8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1ec9ac: 0x46140003
    if (ctx->f[20] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[20];
    // 0x1ec9b0: 0xe64006f0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1776), *(uint32_t*)&val); }
    // 0x1ec9b4: 0xe6400690
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1680), *(uint32_t*)&val); }
    // 0x1ec9b8: 0xc06a324
    SET_GPR_U32(ctx, 31, 0x1ec9c0);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 19), 120), *(uint32_t*)&val); }
    FFireRwm__FP3RWMi(rdram, ctx, runtime); return;
}


// Function: entry_1ec9c0
// Address: 0x1ec9c0 - 0x1eca1c

void entry_1ec9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ec9c0) {
        switch (ctx->pc) {
            case 0x1ec9c8: ctx->pc = 0; goto label_1ec9c8;
            case 0x1ec9f0: ctx->pc = 0; goto label_1ec9f0;
            case 0x1eca08: ctx->pc = 0; goto label_1eca08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ec9c0: 0x1000004e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECAFC; return;
    }
label_1ec9c8:
    // 0x1ec9c8: 0x8e420c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3176)));
    // 0x1ec9cc: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ec9d0: 0x18400045
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_1ecae8(rdram, ctx, runtime); return;
    }
    // 0x1ec9d8: 0x8e430c6c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 3180)));
    // 0x1ec9dc: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ec9e0: 0x10510009
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        goto label_1eca08;
    }
    // 0x1ec9e8: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1ec9ec: 0x0
    // NOP
label_1ec9f0:
    // 0x1ec9f0: 0x85102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    // 0x1ec9f4: 0x1040003c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ecae8(rdram, ctx, runtime); return;
    }
    // 0x1ec9fc: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1eca00: 0x5451fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_1ec9f0;
    }
label_1eca08:
    // 0x1eca08: 0x86102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 6)));
    // 0x1eca0c: 0x10400036
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ecae8(rdram, ctx, runtime); return;
    }
    // 0x1eca14: 0xc07b436
    SET_GPR_U32(ctx, 31, 0x1eca1c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001ed0d8(rdram, ctx, runtime); return;
}


// Function: entry_1eca1c
// Address: 0x1eca1c - 0x1eca3c

void entry_1eca1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eca1c) {
        switch (ctx->pc) {
            case 0x1eca24: ctx->pc = 0; goto label_1eca24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eca1c: 0x10000033
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECAEC; return;
    }
label_1eca24:
    // 0x1eca24: 0x8e420c54
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 3156)));
    // 0x1eca28: 0x16220031
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1ECAF0; return;
    }
    // 0x1eca30: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1eca34: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1eca3c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1eca3c
// Address: 0x1eca3c - 0x1ecac4

void entry_1eca3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eca3c) {
        switch (ctx->pc) {
            case 0x1ecabc: ctx->pc = 0; goto label_1ecabc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eca3c: 0x8fa20080
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1eca40: 0x2444fb14
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294966036));
    // 0x1eca44: 0x2c83000d
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 13));
    // 0x1eca48: 0x1060001c
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1ecabc;
    }
    // 0x1eca50: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1eca54: 0x2442e740
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294960960));
    // 0x1eca58: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1eca5c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1eca60: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1eca68: 0x10000014
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ecabc;
    }
    // 0x1eca70: 0x10000012
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ecabc;
    }
    // 0x1eca78: 0x10000010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ecabc;
    }
    // 0x1eca80: 0x1000000e
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ecabc;
    }
    // 0x1eca88: 0x1000000c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ecabc;
    }
    // 0x1eca90: 0x1000000a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ecabc;
    }
    // 0x1eca98: 0x10000008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ecabc;
    }
    // 0x1ecaa0: 0x10000006
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ecabc;
    }
    // 0x1ecaa8: 0x10000004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ecabc;
    }
    // 0x1ecab0: 0x10000002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 9));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ecabc;
    }
    // 0x1ecab8: 0x2410000a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 10));
label_1ecabc:
    // 0x1ecabc: 0xc070314
    SET_GPR_U32(ctx, 31, 0x1ecac4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001c0c50(rdram, ctx, runtime); return;
}


// Function: entry_1ecac4
// Address: 0x1ecac4 - 0x1ecae8

void entry_1ecac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ecac4: 0x12020008
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        entry_1ecae8(rdram, ctx, runtime); return;
    }
    // 0x1ecacc: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ecad0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ecad4: 0xac835db8
    WRITE32(ADD32(GPR_U32(ctx, 4), 23992), GPR_U32(ctx, 3));
    // 0x1ecad8: 0xac505dbc
    WRITE32(ADD32(GPR_U32(ctx, 2), 23996), GPR_U32(ctx, 16));
    // 0x1ecadc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ecae0: 0xc070302
    SET_GPR_U32(ctx, 31, 0x1ecae8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001c0c08(rdram, ctx, runtime); return;
}


// Function: entry_1ecae8
// Address: 0x1ecae8 - 0x1ecaf8

void entry_1ecae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ecae8) {
        switch (ctx->pc) {
            case 0x1ecaec: ctx->pc = 0; goto label_1ecaec;
            case 0x1ecaf0: ctx->pc = 0; goto label_1ecaf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ecae8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_1ecaec:
    // 0x1ecaec: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1ecaf0:
    // 0x1ecaf0: 0xc072778
    SET_GPR_U32(ctx, 31, 0x1ecaf8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    HandleStepguardMessage__FP9STEPGUARD5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_1ecaf8
// Address: 0x1ecaf8 - 0x1ecbc8

void entry_1ecaf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ecaf8) {
        switch (ctx->pc) {
            case 0x1ecafc: ctx->pc = 0; goto label_1ecafc;
            case 0x1ecb40: ctx->pc = 0; goto label_1ecb40;
            case 0x1ecb70: ctx->pc = 0; goto label_1ecb70;
            case 0x1ecb9c: ctx->pc = 0; goto label_1ecb9c;
            case 0x1ecbbc: ctx->pc = 0; goto label_1ecbbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ecaf8: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
label_1ecafc:
    // 0x1ecafc: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1ecb00: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1ecb04: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1ecb08: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1ecb0c: 0xc7b400e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[20] = *(float*)&val; }
    // 0x1ecb10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ecb18: 0x80402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ecb1c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ecb20: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1ecb24: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ecb28: 0xc5000c84
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 3204)); ctx->f[0] = *(float*)&val; }
    // 0x1ecb2c: 0x8d020c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 3176)));
    // 0x1ecb30: 0x18400022
    ctx->f[4] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1ecbbc;
    }
    // 0x1ecb38: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ecb3c: 0x8d030c6c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 3180)));
label_1ecb40:
    // 0x1ecb40: 0x710c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 7), 3));
    // 0x1ecb44: 0x8d040c74
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 8), 3188)));
    // 0x1ecb48: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ecb4c: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1ecb50: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1ecb54: 0x8c660000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ecb58: 0x82001a
    { int32_t divisor = GPR_S32(ctx, 2); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 4) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 2) % divisor); } else { ctx->lo = (GPR_S32(ctx,4) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,2); } }
    // 0x1ecb5c: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1ecb60: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1ecb64: 0x8cc30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1ecb68: 0x50490001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 9)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1ecb70;
    }
label_1ecb70:
    // 0x1ecb70: 0xc4c30014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 20)); ctx->f[3] = *(float*)&val; }
    // 0x1ecb74: 0xc4620034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[2] = *(float*)&val; }
    // 0x1ecb78: 0x46011043
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[1] = ctx->f[2] / ctx->f[1];
    // 0x1ecb7c: 0x2810
    SET_GPR_U32(ctx, 5, ctx->hi);
    // 0x1ecb80: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x1ecb84: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ecb88: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1ecb8c: 0x46030036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ecb90: 0x0
    // NOP
    // 0x1ecb94: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
        goto label_1ecb9c;
    }
label_1ecb9c:
    // 0x1ecb9c: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1ecba0: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1ecba4: 0x46040003
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[4];
    // 0x1ecba8: 0xe4c00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 6), 24), *(uint32_t*)&val); }
    // 0x1ecbac: 0x8d020c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 3176)));
    // 0x1ecbb0: 0xe2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 2)));
    // 0x1ecbb4: 0x5440ffe2
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 3180)));
        goto label_1ecb40;
    }
label_1ecbbc:
    // 0x1ecbbc: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ecbc4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ecbc8; return;
}


// Function: FUN_001ecbc8
// Address: 0x1ecbc8 - 0x1ecbe8

void FUN_001ecbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ecbc8: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x1ecbcc: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1ecbd0: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ecbd4: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x1ecbd8: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x1ecbdc: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x1ecbe0: 0xc071f2e
    SET_GPR_U32(ctx, 31, 0x1ecbe8);
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    UpdateStepguard__FP9STEPGUARDf(rdram, ctx, runtime); return;
}


// Function: entry_1ecbe8
// Address: 0x1ecbe8 - 0x1ecc64

void entry_1ecbe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ecbe8) {
        switch (ctx->pc) {
            case 0x1ecc28: ctx->pc = 0; goto label_1ecc28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ecbe8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ecbec: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ecbf0: 0x8c435db8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 23992)));
    // 0x1ecbf4: 0x1464001c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x1ECC68; return;
    }
    // 0x1ecbfc: 0xc6000c88
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3208)); ctx->f[0] = *(float*)&val; }
    // 0x1ecc00: 0xc6010c8c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3212)); ctx->f[1] = *(float*)&val; }
    // 0x1ecc04: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ecc08: 0x0
    // NOP
    // 0x1ecc0c: 0x45010006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1ecc28;
    }
    // 0x1ecc14: 0xc6000c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3168)); ctx->f[0] = *(float*)&val; }
    // 0x1ecc18: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1ecc1c: 0xe6010c88
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 3208), *(uint32_t*)&val); }
    // 0x1ecc20: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1ecc24: 0xe6000c64
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3172), *(uint32_t*)&val); }
label_1ecc28:
    // 0x1ecc28: 0xc6010c88
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3208)); ctx->f[1] = *(float*)&val; }
    // 0x1ecc2c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1ecc30: 0x8e030c34
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 3124)));
    // 0x1ecc34: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ecc38: 0xe6000c84
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3204), *(uint32_t*)&val); }
    // 0x1ecc3c: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1ecc40: 0xae000c70
    WRITE32(ADD32(GPR_U32(ctx, 16), 3184), GPR_U32(ctx, 0));
    // 0x1ecc44: 0xe6010c80
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 3200), *(uint32_t*)&val); }
    // 0x1ecc48: 0xae000c78
    WRITE32(ADD32(GPR_U32(ctx, 16), 3192), GPR_U32(ctx, 0));
    // 0x1ecc4c: 0x10600005
    WRITE32(ADD32(GPR_U32(ctx, 16), 3188), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1ecc64(rdram, ctx, runtime); return;
    }
    // 0x1ecc54: 0xae000c34
    WRITE32(ADD32(GPR_U32(ctx, 16), 3124), GPR_U32(ctx, 0));
    // 0x1ecc58: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1ecc5c: 0xc07b476
    SET_GPR_U32(ctx, 31, 0x1ecc64);
    WRITE32(ADD32(GPR_U32(ctx, 16), 3128), GPR_U32(ctx, 3));
    FUN_001ed1d8(rdram, ctx, runtime); return;
}


// Function: entry_1ecc64
// Address: 0x1ecc64 - 0x1eccf8

void entry_1ecc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ecc64) {
        switch (ctx->pc) {
            case 0x1ecc68: ctx->pc = 0; goto label_1ecc68;
            case 0x1eccdc: ctx->pc = 0; goto label_1eccdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ecc64: 0xae205db8
    WRITE32(ADD32(GPR_U32(ctx, 17), 23992), GPR_U32(ctx, 0));
label_1ecc68:
    // 0x1ecc68: 0x26421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    // 0x1ecc6c: 0xc6010c84
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3204)); ctx->f[1] = *(float*)&val; }
    // 0x1ecc70: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1ecc74: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ecc78: 0x0
    // NOP
    // 0x1ecc7c: 0x45020036
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3200)); ctx->f[3] = *(float*)&val; }
        ctx->pc = 0x1ECD58; return;
    }
    // 0x1ecc84: 0x8e020c74
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3188)));
    // 0x1ecc88: 0x8e030c78
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 3192)));
    // 0x1ecc8c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1ecc90: 0xe6010c80
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 3200), *(uint32_t*)&val); }
    // 0x1ecc94: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1ecc98: 0xae020c74
    WRITE32(ADD32(GPR_U32(ctx, 16), 3188), GPR_U32(ctx, 2));
    // 0x1ecc9c: 0x28640004
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 3), 4));
    // 0x1ecca0: 0x1480000e
    WRITE32(ADD32(GPR_U32(ctx, 16), 3192), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1eccdc;
    }
    // 0x1ecca8: 0xc6000c88
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3208)); ctx->f[0] = *(float*)&val; }
    // 0x1eccac: 0xc6010c8c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3212)); ctx->f[1] = *(float*)&val; }
    // 0x1eccb0: 0x8e020c70
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3184)));
    // 0x1eccb4: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eccb8: 0xae000c78
    WRITE32(ADD32(GPR_U32(ctx, 16), 3192), GPR_U32(ctx, 0));
    // 0x1eccbc: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1eccc0: 0x45010006
    WRITE32(ADD32(GPR_U32(ctx, 16), 3184), GPR_U32(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1eccdc;
    }
    // 0x1eccc8: 0xc6000c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3168)); ctx->f[0] = *(float*)&val; }
    // 0x1ecccc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1eccd0: 0xe6010c88
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 3208), *(uint32_t*)&val); }
    // 0x1eccd4: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1eccd8: 0xe6000c64
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3172), *(uint32_t*)&val); }
label_1eccdc:
    // 0x1eccdc: 0x8e030c94
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 3220)));
    // 0x1ecce0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ecce4: 0x54620016
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3204)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x1ECD40; return;
    }
    // 0x1eccec: 0x8e040c54
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3156)));
    // 0x1eccf0: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1eccf8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1eccf8
// Address: 0x1eccf8 - 0x1ecd84

void entry_1eccf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eccf8) {
        switch (ctx->pc) {
            case 0x1ecd20: ctx->pc = 0; goto label_1ecd20;
            case 0x1ecd34: ctx->pc = 0; goto label_1ecd34;
            case 0x1ecd38: ctx->pc = 0; goto label_1ecd38;
            case 0x1ecd40: ctx->pc = 0; goto label_1ecd40;
            case 0x1ecd58: ctx->pc = 0; goto label_1ecd58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eccf8: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eccfc: 0x240204f1
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1265));
    // 0x1ecd00: 0x1062000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1266));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ecd34;
    }
    // 0x1ecd08: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1262));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ecd20;
    }
    // 0x1ecd10: 0x10620009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ecd38;
    }
    // 0x1ecd18: 0x10000009
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3204)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ecd40;
    }
label_1ecd20:
    // 0x1ecd20: 0x240204f4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1268));
    // 0x1ecd24: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1271));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ecd34;
    }
    // 0x1ecd2c: 0x54620004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3204)); ctx->f[0] = *(float*)&val; }
        goto label_1ecd40;
    }
label_1ecd34:
    // 0x1ecd34: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_1ecd38:
    // 0x1ecd38: 0xae020c94
    WRITE32(ADD32(GPR_U32(ctx, 16), 3220), GPR_U32(ctx, 2));
    // 0x1ecd3c: 0xc6000c84
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3204)); ctx->f[0] = *(float*)&val; }
label_1ecd40:
    // 0x1ecd40: 0xc6010c88
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3208)); ctx->f[1] = *(float*)&val; }
    // 0x1ecd44: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ecd48: 0xe6000c84
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 3204), *(uint32_t*)&val); }
    // 0x1ecd4c: 0x26421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 6232));
    // 0x1ecd50: 0xc6030c80
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3200)); ctx->f[3] = *(float*)&val; }
    // 0x1ecd54: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
label_1ecd58:
    // 0x1ecd58: 0xc6010c78
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3192)); ctx->f[1] = *(float*)&val; }
    // 0x1ecd5c: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1ecd60: 0xc6020c88
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3208)); ctx->f[2] = *(float*)&val; }
    // 0x1ecd64: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x1ecd68: 0x8e040c38
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3128)));
    // 0x1ecd6c: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x1ecd70: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1ecd74: 0x10800003
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 3196), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1ecd84(rdram, ctx, runtime); return;
    }
    // 0x1ecd7c: 0xc07b49e
    SET_GPR_U32(ctx, 31, 0x1ecd84);
    FUN_001ed278(rdram, ctx, runtime); return;
}


// Function: entry_1ecd84
// Address: 0x1ecd84 - 0x1ecda0

void entry_1ecd84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ecd84: 0x8e235db8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 23992)));
    // 0x1ecd88: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ecd8c: 0x5462000d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        ctx->pc = 0x1ECDC4; return;
    }
    // 0x1ecd94: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ecd98: 0xc07031a
    SET_GPR_U32(ctx, 31, 0x1ecda0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001c0c68(rdram, ctx, runtime); return;
}


// Function: entry_1ecda0
// Address: 0x1ecda0 - 0x1ecda8

void entry_1ecda0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ecda0: 0xc070314
    SET_GPR_U32(ctx, 31, 0x1ecda8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    FUN_001c0c50(rdram, ctx, runtime); return;
}


// Function: entry_1ecda8
// Address: 0x1ecda8 - 0x1ecddc

void entry_1ecda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ecda8) {
        switch (ctx->pc) {
            case 0x1ecdc4: ctx->pc = 0; goto label_1ecdc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ecda8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1ecdac: 0x8c645dbc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 23996)));
    // 0x1ecdb0: 0x54440004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        goto label_1ecdc4;
    }
    // 0x1ecdb8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ecdbc: 0xae225db8
    WRITE32(ADD32(GPR_U32(ctx, 17), 23992), GPR_U32(ctx, 2));
    // 0x1ecdc0: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
label_1ecdc4:
    // 0x1ecdc4: 0x3c05001f
    SET_GPR_U32(ctx, 5, ((uint32_t)31 << 16));
    // 0x1ecdc8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ecdcc: 0x24a5cb18
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294953752));
    // 0x1ecdd0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ecdd4: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x1ecddc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_1ecddc
// Address: 0x1ecddc - 0x1ecdf8

void entry_1ecddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ecddc: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ecde0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ecde4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ecde8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ecdec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ecdf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ecdf8; return;
}


// Function: FUN_001ecdf8
// Address: 0x1ecdf8 - 0x1ece0c

void FUN_001ecdf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ecdf8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ecdfc: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ece00: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ece04: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1ece0c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 3156)));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ece0c
// Address: 0x1ece0c - 0x1ece54

void entry_1ece0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ece0c) {
        switch (ctx->pc) {
            case 0x1ece38: ctx->pc = 0; goto label_1ece38;
            case 0x1ece4c: ctx->pc = 0; goto label_1ece4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ece0c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ece10: 0x240204f1
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1265));
    // 0x1ece14: 0x1062000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ece4c;
    }
    // 0x1ece1c: 0x286204f2
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1266));
    // 0x1ece20: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1262));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ece38;
    }
    // 0x1ece28: 0x10620008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ece4c;
    }
    // 0x1ece30: 0x10000009
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECE58; return;
    }
label_1ece38:
    // 0x1ece38: 0x240204f4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1268));
    // 0x1ece3c: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1271));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1ece4c;
    }
    // 0x1ece44: 0x14620004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1ECE58; return;
    }
label_1ece4c:
    // 0x1ece4c: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x1ece54);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1ece54
// Address: 0x1ece54 - 0x1ece70

void entry_1ece54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ece54) {
        switch (ctx->pc) {
            case 0x1ece58: ctx->pc = 0; goto label_1ece58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ece54: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1ece58:
    // 0x1ece58: 0x10800007
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECE78; return;
    }
    // 0x1ece60: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x1ece64: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1ece68: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ece70);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ece70
// Address: 0x1ece70 - 0x1ece88

void entry_1ece70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ece70) {
        switch (ctx->pc) {
            case 0x1ece78: ctx->pc = 0; goto label_1ece78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ece70: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECE8C; return;
    }
label_1ece78:
    // 0x1ece78: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x1ece7c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1ece80: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ece88);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ece88
// Address: 0x1ece88 - 0x1ece98

void entry_1ece88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ece88) {
        switch (ctx->pc) {
            case 0x1ece8c: ctx->pc = 0; goto label_1ece8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ece88: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1ece8c:
    // 0x1ece8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ece94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ece98; return;
}


// Function: FUN_001ece98
// Address: 0x1ece98 - 0x1eced4

void FUN_001ece98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ece98: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1ece9c: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1ecea0: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1ecea4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ecea8: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1eceac: 0x2862000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 14));
    // 0x1eceb0: 0x10400011
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 12));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECEF8; return;
    }
    // 0x1eceb8: 0x1440000f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECEF8; return;
    }
    // 0x1ecec0: 0x8e040c48
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3144)));
    // 0x1ecec4: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x1ECEE8; return;
    }
    // 0x1ececc: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x1eced4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1eced4
// Address: 0x1eced4 - 0x1ecee0

void entry_1eced4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eced4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eced8: 0xc072106
    SET_GPR_U32(ctx, 31, 0x1ecee0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ecee0
// Address: 0x1ecee0 - 0x1ecef0

void entry_1ecee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ecee0) {
        switch (ctx->pc) {
            case 0x1ecee8: ctx->pc = 0; goto label_1ecee8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ecee0: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECF04; return;
    }
label_1ecee8:
    // 0x1ecee8: 0xc072106
    SET_GPR_U32(ctx, 31, 0x1ecef0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 320));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ecef0
// Address: 0x1ecef0 - 0x1ecf00

void entry_1ecef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ecef0) {
        switch (ctx->pc) {
            case 0x1ecef8: ctx->pc = 0; goto label_1ecef8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ecef0: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECF04; return;
    }
label_1ecef8:
    // 0x1ecef8: 0xc072302
    SET_GPR_U32(ctx, 31, 0x1ecf00);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateStepguardGoal__FP9STEPGUARDi(rdram, ctx, runtime); return;
}


// Function: entry_1ecf00
// Address: 0x1ecf00 - 0x1ecf10

void entry_1ecf00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ecf00) {
        switch (ctx->pc) {
            case 0x1ecf04: ctx->pc = 0; goto label_1ecf04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ecf00: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1ecf04:
    // 0x1ecf04: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ecf08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ecf10
// Address: 0x1ecf10 - 0x1ecf2c

void FUN_001ecf10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ecf10: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x1ecf14: 0x7fb00050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 16));
    // 0x1ecf18: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1ecf1c: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x1ecf20: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ecf24: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1ecf2c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3156)));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1ecf2c
// Address: 0x1ecf2c - 0x1ecf60

void entry_1ecf2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ecf2c: 0x8fa20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ecf30: 0x2444fb14
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294966036));
    // 0x1ecf34: 0x2c83000c
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 12));
    // 0x1ecf38: 0x10600030
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECFFC; return;
    }
    // 0x1ecf40: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1ecf44: 0x2442e780
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294961024));
    // 0x1ecf48: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ecf4c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ecf50: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1ecf58: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1ecf60);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1ecf60
// Address: 0x1ecf60 - 0x1ecf98

void entry_1ecf60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ecf60: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1ecf64: 0x10000019
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECFCC; return;
    }
    // 0x1ecf6c: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1ecf70: 0x2862000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 15));
    // 0x1ecf74: 0x10400021
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 13));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECFFC; return;
    }
    // 0x1ecf7c: 0x1440001f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECFFC; return;
    }
    // 0x1ecf84: 0x8e040c48
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3144)));
    // 0x1ecf88: 0x1080001c
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECFFC; return;
    }
    // 0x1ecf90: 0xc07cf02
    SET_GPR_U32(ctx, 31, 0x1ecf98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    GetXfmMat__FP3XFMP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1ecf98
// Address: 0x1ecf98 - 0x1ecfc4

void entry_1ecf98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ecf98: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1ecf9c: 0x1000000f
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECFDC; return;
    }
    // 0x1ecfa4: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1ecfa8: 0x2862000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 15));
    // 0x1ecfac: 0x10400013
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 13));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECFFC; return;
    }
    // 0x1ecfb4: 0x14400011
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ECFFC; return;
    }
    // 0x1ecfbc: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1ecfc4);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1ecfc4
// Address: 0x1ecfc4 - 0x1ecfe4

void entry_1ecfc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ecfc4) {
        switch (ctx->pc) {
            case 0x1ecfcc: ctx->pc = 0; goto label_1ecfcc;
            case 0x1ecfdc: ctx->pc = 0; goto label_1ecfdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ecfc4: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1ecfc8: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
label_1ecfcc:
    // 0x1ecfcc: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ecfd0: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ecfd4: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1ecfd8: 0xc7ad0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
label_1ecfdc:
    // 0x1ecfdc: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1ecfe4);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1ecfe4
// Address: 0x1ecfe4 - 0x1ecff4

void entry_1ecfe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ecfe4: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1ecfe8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ecfec: 0xc071eb8
    SET_GPR_U32(ctx, 31, 0x1ecff4);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    SetStepguardTargetHeading__FP9STEPGUARDff(rdram, ctx, runtime); return;
}


// Function: entry_1ecff4
// Address: 0x1ecff4 - 0x1ed004

void entry_1ecff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ecff4) {
        switch (ctx->pc) {
            case 0x1ecffc: ctx->pc = 0; goto label_1ecffc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ecff4: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ED008; return;
    }
label_1ecffc:
    // 0x1ecffc: 0xc07238a
    SET_GPR_U32(ctx, 31, 0x1ed004);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateStepguardSgs__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1ed004
// Address: 0x1ed004 - 0x1ed018

void entry_1ed004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ed004) {
        switch (ctx->pc) {
            case 0x1ed008: ctx->pc = 0; goto label_1ed008;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ed004: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_1ed008:
    // 0x1ed008: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ed00c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ed014: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ed018; return;
}


// Function: FUN_001ed018
// Address: 0x1ed018 - 0x1ed020

void FUN_001ed018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed018: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 3124), GPR_U32(ctx, 5));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ed020
// Address: 0x1ed020 - 0x1ed038

void FUN_001ed020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed020: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ed024: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ed028: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ed02c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ed030: 0xc07b484
    SET_GPR_U32(ctx, 31, 0x1ed038);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3128)));
    FUN_001ed210(rdram, ctx, runtime); return;
}


// Function: entry_1ed038
// Address: 0x1ed038 - 0x1ed090

void entry_1ed038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed038: 0xae000c38
    WRITE32(ADD32(GPR_U32(ctx, 16), 3128), GPR_U32(ctx, 0));
    // 0x1ed03c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ed040: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed044: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ed04c: 0x0
    // NOP
    // 0x1ed050: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x1ed054: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1ed058: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x1ed05c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ed060: 0xac850c5c
    WRITE32(ADD32(GPR_U32(ctx, 4), 3164), GPR_U32(ctx, 5));
    // 0x1ed064: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x1ed068: 0x3e00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 3212), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ed070: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x1ed074: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1ed078: 0xc4800c88
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 3208)); ctx->f[0] = *(float*)&val; }
    // 0x1ed07c: 0xac850c60
    WRITE32(ADD32(GPR_U32(ctx, 4), 3168), GPR_U32(ctx, 5));
    // 0x1ed080: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1ed084: 0x3e00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 3172), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ed08c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ed090; return;
}


// Function: FUN_001ed090
// Address: 0x1ed090 - 0x1ed0cc

void FUN_001ed090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed090: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ed094: 0x80382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ed098: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ed09c: 0xa0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ed0a0: 0x120202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1ed0a4: 0xe0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1ed0a8: 0x8ce20c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 3176)));
    // 0x1ed0ac: 0x8ce30c6c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 3180)));
    // 0x1ed0b0: 0x240c0
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1ed0b4: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1ed0b8: 0x681821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x1ed0bc: 0xace20c68
    WRITE32(ADD32(GPR_U32(ctx, 7), 3176), GPR_U32(ctx, 2));
    // 0x1ed0c0: 0xac660004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 6));
    // 0x1ed0c4: 0xc04be04
    SET_GPR_U32(ctx, 31, 0x1ed0cc);
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 9));
    SubscribeAsegaObject__FP5ASEGAP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1ed0cc
// Address: 0x1ed0cc - 0x1ed0d8

void entry_1ed0cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed0cc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed0d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ed0d8
// Address: 0x1ed0d8 - 0x1ed14c

void FUN_001ed0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ed0d8) {
        switch (ctx->pc) {
            case 0x1ed110: ctx->pc = 0; goto label_1ed110;
            case 0x1ed128: ctx->pc = 0; goto label_1ed128;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ed0d8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ed0dc: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ed0e0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ed0e4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ed0e8: 0x8e020c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3176)));
    // 0x1ed0ec: 0x1840001a
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1ED158; return;
    }
    // 0x1ed0f4: 0x8e030c6c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 3180)));
    // 0x1ed0f8: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ed0fc: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ed100: 0x10450009
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        goto label_1ed128;
    }
    // 0x1ed108: 0xe0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1ed10c: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
label_1ed110:
    // 0x1ed110: 0xc4102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 4)));
    // 0x1ed114: 0x10400010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 8));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ED158; return;
    }
    // 0x1ed11c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ed120: 0x5445fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
        goto label_1ed110;
    }
label_1ed128:
    // 0x1ed128: 0xc7102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 7)));
    // 0x1ed12c: 0x1040000a
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 6), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ED158; return;
    }
    // 0x1ed134: 0xe63023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    // 0x1ed138: 0x1042021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    // 0x1ed13c: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x1ed140: 0x24850008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 8));
    // 0x1ed144: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1ed14c);
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 3));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1ed14c
// Address: 0x1ed14c - 0x1ed168

void entry_1ed14c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ed14c) {
        switch (ctx->pc) {
            case 0x1ed158: ctx->pc = 0; goto label_1ed158;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ed14c: 0x8e020c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3176)));
    // 0x1ed150: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1ed154: 0xae020c68
    WRITE32(ADD32(GPR_U32(ctx, 16), 3176), GPR_U32(ctx, 2));
label_1ed158:
    // 0x1ed158: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ed15c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed160: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ed168
// Address: 0x1ed168 - 0x1ed17c

void FUN_001ed168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed168: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ed16c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ed170: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ed174: 0xc060b06
    SET_GPR_U32(ctx, 31, 0x1ed17c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    InitLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1ed17c
// Address: 0x1ed17c - 0x1ed184

void entry_1ed17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed17c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1ed184);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3072));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1ed184
// Address: 0x1ed184 - 0x1ed198

void entry_1ed184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed184: 0xae020038
    WRITE32(ADD32(GPR_U32(ctx, 16), 56), GPR_U32(ctx, 2));
    // 0x1ed188: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ed18c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed190: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ed198
// Address: 0x1ed198 - 0x1ed1ac

void FUN_001ed198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed198: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ed19c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ed1a0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ed1a4: 0xc060b16
    SET_GPR_U32(ctx, 31, 0x1ed1ac);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostLoLoad__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1ed1ac
// Address: 0x1ed1ac - 0x1ed1c0

void entry_1ed1ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed1ac: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1ed1b0: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1ed1b4: 0x24060013
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 19));
    // 0x1ed1b8: 0xc056a0e
    SET_GPR_U32(ctx, 31, 0x1ed1c0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObjectByClass__FP2SWi3CIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1ed1c0
// Address: 0x1ed1c0 - 0x1ed1d8

void entry_1ed1c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed1c0: 0xae020040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 2));
    // 0x1ed1c4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ed1c8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed1cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ed1d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ed1d8; return;
}


// Function: FUN_001ed1d8
// Address: 0x1ed1d8 - 0x1ed204

void FUN_001ed1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed1d8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ed1dc: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ed1e0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ed1e4: 0x2405001a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 26));
    // 0x1ed1e8: 0xac40003c
    WRITE32(ADD32(GPR_U32(ctx, 2), 60), GPR_U32(ctx, 0));
    // 0x1ed1ec: 0x8c480040
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1ed1f0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ed1f4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ed1f8: 0x8d030c70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 3184)));
    // 0x1ed1fc: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1ed204);
    WRITE32(ADD32(GPR_U32(ctx, 2), 68), GPR_U32(ctx, 3));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1ed204
// Address: 0x1ed204 - 0x1ed210

void entry_1ed204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed204: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed208: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ed210
// Address: 0x1ed210 - 0x1ed230

void FUN_001ed210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed210: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1ed214: 0x2405001c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1ed218: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1ed21c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ed220: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ed224: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1ed228: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1ed230);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1ed230
// Address: 0x1ed230 - 0x1ed244

void entry_1ed230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed230: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1ed234: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ed238: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1ed23c: 0xc07b4c6
    SET_GPR_U32(ctx, 31, 0x1ed244);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_001ed318(rdram, ctx, runtime); return;
}


// Function: entry_1ed244
// Address: 0x1ed244 - 0x1ed264

void entry_1ed244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed244: 0x8e020040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1ed248: 0x8c430c3c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 3132)));
    // 0x1ed24c: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1ed264(rdram, ctx, runtime); return;
    }
    // 0x1ed254: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ed258: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1ed25c: 0xc07b4c6
    SET_GPR_U32(ctx, 31, 0x1ed264);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FUN_001ed318(rdram, ctx, runtime); return;
}


// Function: entry_1ed264
// Address: 0x1ed264 - 0x1ed278

void entry_1ed264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed264: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ed268: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ed26c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ed274: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ed278; return;
}


// Function: FUN_001ed278
// Address: 0x1ed278 - 0x1ed2c4

void FUN_001ed278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ed278) {
        switch (ctx->pc) {
            case 0x1ed298: ctx->pc = 0; goto label_1ed298;
            case 0x1ed2bc: ctx->pc = 0; goto label_1ed2bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ed278: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ed27c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ed280: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ed284: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1ed288: 0x8e04003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1ed28c: 0x8e020034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1ed290: 0x10000011
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ED2D8; return;
    }
label_1ed298:
    // 0x1ed298: 0x8ce20c70
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 3184)));
    // 0x1ed29c: 0x14620007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1ed2bc;
    }
    // 0x1ed2a4: 0xc4e10c7c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 3196)); ctx->f[1] = *(float*)&val; }
    // 0x1ed2a8: 0xc4c00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1ed2ac: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ed2b0: 0x0
    // NOP
    // 0x1ed2b4: 0x45010015
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1ED30C; return;
    }
label_1ed2bc:
    // 0x1ed2bc: 0xc07b4c6
    SET_GPR_U32(ctx, 31, 0x1ed2c4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    FUN_001ed318(rdram, ctx, runtime); return;
}


// Function: entry_1ed2c4
// Address: 0x1ed2c4 - 0x1ed318

void entry_1ed2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ed2c4) {
        switch (ctx->pc) {
            case 0x1ed2d8: ctx->pc = 0; goto label_1ed2d8;
            case 0x1ed308: ctx->pc = 0; goto label_1ed308;
            case 0x1ed30c: ctx->pc = 0; goto label_1ed30c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ed2c4: 0x8e03003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1ed2c8: 0x8e020034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x1ed2cc: 0x24640001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1ed2d0: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1ed2d4: 0xae04003c
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 4));
label_1ed2d8:
    // 0x1ed2d8: 0x1040000b
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ed308;
    }
    // 0x1ed2e0: 0x8e030038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x1ed2e4: 0x8e040040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1ed2e8: 0x623021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ed2ec: 0x8e050044
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    // 0x1ed2f0: 0x8cc30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x1ed2f4: 0x8c820c70
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 3184)));
    // 0x1ed2f8: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1ed2fc: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x1ed300: 0x1040ffe5
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ED298; return;
    }
label_1ed308:
    // 0x1ed308: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1ed30c:
    // 0x1ed30c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed310: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ed318
// Address: 0x1ed318 - 0x1ed354

void FUN_001ed318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed318: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ed31c: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ed320: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1ed324: 0x2c620006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 6));
    // 0x1ed328: 0x10400063
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ed4b8(rdram, ctx, runtime); return;
    }
    // 0x1ed330: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1ed334: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1ed338: 0x2442e7b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294961072));
    // 0x1ed33c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1ed340: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ed344: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1ed34c: 0xc07b1ea
    SET_GPR_U32(ctx, 31, 0x1ed354);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 64)));
    FUN_001ec7a8(rdram, ctx, runtime); return;
}


// Function: entry_1ed354
// Address: 0x1ed354 - 0x1ed378

void entry_1ed354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed354: 0x10000059
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ED4BC; return;
    }
    // 0x1ed35c: 0x24a2000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 12));
    // 0x1ed360: 0xe0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1ed364: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x1ed368: 0x2405001b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27));
    // 0x1ed36c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ed370: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1ed378);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1ed378
// Address: 0x1ed378 - 0x1ed3a8

void entry_1ed378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed378: 0x10000050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ED4BC; return;
    }
    // 0x1ed380: 0x8ce20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 64)));
    // 0x1ed384: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1ed388: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ed38c: 0x24c43c50
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 15440));
    // 0x1ed390: 0x8c430c3c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 3132)));
    // 0x1ed394: 0xac670680
    WRITE32(ADD32(GPR_U32(ctx, 3), 1664), GPR_U32(ctx, 7));
    // 0x1ed398: 0x8cc23c50
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 15440)));
    // 0x1ed39c: 0x8c430040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1ed3a0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ed3a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ed3a8
// Address: 0x1ed3a8 - 0x1ed3b4

void entry_1ed3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed3a8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1ed3ac: 0xc05bb22
    SET_GPR_U32(ctx, 31, 0x1ed3b4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    StartJoySelection__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_1ed3b4
// Address: 0x1ed3b4 - 0x1ed41c

void entry_1ed3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed3b4: 0x3c01479c
    SET_GPR_U32(ctx, 1, ((uint32_t)18332 << 16));
    // 0x1ed3b8: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1ed3bc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1ed3c0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ed3c4: 0x3c014788
    SET_GPR_U32(ctx, 1, ((uint32_t)18312 << 16));
    // 0x1ed3c8: 0x3421b800
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47104));
    // 0x1ed3cc: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1ed3d0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ed3d4: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x1ed3d8: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1ed3dc: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ed3e0: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
    // 0x1ed3e4: 0x10000025
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ED47C; return;
    }
    // 0x1ed3ec: 0x8ce30040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 64)));
    // 0x1ed3f0: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1ed3f4: 0x24c43c50
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 15440));
    // 0x1ed3f8: 0x8c620c3c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 3132)));
    // 0x1ed3fc: 0xac400680
    WRITE32(ADD32(GPR_U32(ctx, 2), 1664), GPR_U32(ctx, 0));
    // 0x1ed400: 0x8ce30040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 64)));
    // 0x1ed404: 0x8c620c3c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 3132)));
    // 0x1ed408: 0xac400688
    WRITE32(ADD32(GPR_U32(ctx, 2), 1672), GPR_U32(ctx, 0));
    // 0x1ed40c: 0x8cc33c50
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 15440)));
    // 0x1ed410: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x1ed414: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ed41c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ed41c
// Address: 0x1ed41c - 0x1ed448

void entry_1ed41c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed41c: 0x10000027
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ED4BC; return;
    }
    // 0x1ed424: 0x8ce30040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 64)));
    // 0x1ed428: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ed42c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1ed430: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1ed434: 0xac620c4c
    WRITE32(ADD32(GPR_U32(ctx, 3), 3148), GPR_U32(ctx, 2));
    // 0x1ed438: 0x8cc239f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 14832)));
    // 0x1ed43c: 0x8c430040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1ed440: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ed448);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 14832));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ed448
// Address: 0x1ed448 - 0x1ed490

void entry_1ed448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ed448) {
        switch (ctx->pc) {
            case 0x1ed47c: ctx->pc = 0; goto label_1ed47c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ed448: 0x3c01479c
    SET_GPR_U32(ctx, 1, ((uint32_t)18332 << 16));
    // 0x1ed44c: 0x34214000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 16384));
    // 0x1ed450: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1ed454: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ed458: 0x3c014788
    SET_GPR_U32(ctx, 1, ((uint32_t)18312 << 16));
    // 0x1ed45c: 0x3421b800
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47104));
    // 0x1ed460: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1ed464: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ed468: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x1ed46c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1ed470: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ed474: 0x3c01be80
    SET_GPR_U32(ctx, 1, ((uint32_t)48768 << 16));
    // 0x1ed478: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
label_1ed47c:
    // 0x1ed47c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ed480: 0x44808000
    *(uint32_t*)&ctx->f[16] = GPR_U32(ctx, 0);
    // 0x1ed484: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ed488: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1ed490);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1ed490
// Address: 0x1ed490 - 0x1ed4b8

void entry_1ed490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed490: 0x1000000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ED4BC; return;
    }
    // 0x1ed498: 0x8ce30040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 64)));
    // 0x1ed49c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1ed4a0: 0x24c439f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 14832));
    // 0x1ed4a4: 0xac600c4c
    WRITE32(ADD32(GPR_U32(ctx, 3), 3148), GPR_U32(ctx, 0));
    // 0x1ed4a8: 0x8cc239f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 14832)));
    // 0x1ed4ac: 0x8c430040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1ed4b0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ed4b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ed4b8
// Address: 0x1ed4b8 - 0x1ed4c8

void entry_1ed4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ed4b8) {
        switch (ctx->pc) {
            case 0x1ed4bc: ctx->pc = 0; goto label_1ed4bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ed4b8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1ed4bc:
    // 0x1ed4bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ed4c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ed4c8; return;
}


// Function: FUN_001ed4c8
// Address: 0x1ed4c8 - 0x1ed51c

void FUN_001ed4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed4c8: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x1ed4cc: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1ed4d0: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1ed4d4: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1ed4d8: 0xe7b40040
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x1ed4dc: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ed4e0: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1ed4e4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ed4e8: 0x8c830034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 52)));
    // 0x1ed4ec: 0x286200c0
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 192));
    // 0x1ed4f0: 0x1040000f
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1ED530; return;
    }
    // 0x1ed4f8: 0x8c900038
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 56)));
    // 0x1ed4fc: 0x31100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 4));
    // 0x1ed500: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1ed504: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ed508: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1ed50c: 0xac830034
    WRITE32(ADD32(GPR_U32(ctx, 4), 52), GPR_U32(ctx, 3));
    // 0x1ed510: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ed514: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1ed51c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1ed51c
// Address: 0x1ed51c - 0x1ed558

void entry_1ed51c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ed51c) {
        switch (ctx->pc) {
            case 0x1ed530: ctx->pc = 0; goto label_1ed530;
            case 0x1ed538: ctx->pc = 0; goto label_1ed538;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ed51c: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    // 0x1ed520: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ed524: 0xae120004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 18));
    // 0x1ed528: 0x10000003
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ed538;
    }
label_1ed530:
    // 0x1ed530: 0x3c020062
    SET_GPR_U32(ctx, 2, ((uint32_t)98 << 16));
    // 0x1ed534: 0x24425760
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 22368));
label_1ed538:
    // 0x1ed538: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ed53c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ed540: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ed544: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed548: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1ed54c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ed554: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ed558; return;
}


// Function: FUN_001ed558
// Address: 0x1ed558 - 0x1ed574

void FUN_001ed558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed558: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ed55c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ed560: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1ed564: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ed568: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ed56c: 0xc07b532
    SET_GPR_U32(ctx, 31, 0x1ed574);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001ed4c8(rdram, ctx, runtime); return;
}


// Function: entry_1ed574
// Address: 0x1ed574 - 0x1ed588

void entry_1ed574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed574: 0xac50000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 12), GPR_U32(ctx, 16));
    // 0x1ed578: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ed57c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed580: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ed588
// Address: 0x1ed588 - 0x1ed5a4

void FUN_001ed588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed588: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1ed58c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1ed590: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1ed594: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1ed598: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ed59c: 0xc07b532
    SET_GPR_U32(ctx, 31, 0x1ed5a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FUN_001ed4c8(rdram, ctx, runtime); return;
}


// Function: entry_1ed5a4
// Address: 0x1ed5a4 - 0x1ed5b8

void entry_1ed5a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed5a4: 0xac50000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 12), GPR_U32(ctx, 16));
    // 0x1ed5a8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ed5ac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed5b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ed5b8
// Address: 0x1ed5b8 - 0x1ed5cc

void FUN_001ed5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed5b8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ed5bc: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ed5c0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ed5c4: 0xc07b532
    SET_GPR_U32(ctx, 31, 0x1ed5cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FUN_001ed4c8(rdram, ctx, runtime); return;
}


// Function: entry_1ed5cc
// Address: 0x1ed5cc - 0x1ed5d8

void entry_1ed5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed5cc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed5d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ed5d8
// Address: 0x1ed5d8 - 0x1ed5ec

void FUN_001ed5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed5d8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ed5dc: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ed5e0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ed5e4: 0xc07b532
    SET_GPR_U32(ctx, 31, 0x1ed5ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    FUN_001ed4c8(rdram, ctx, runtime); return;
}


// Function: entry_1ed5ec
// Address: 0x1ed5ec - 0x1ed5f8

void entry_1ed5ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed5ec: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed5f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ed5f8
// Address: 0x1ed5f8 - 0x1ed60c

void FUN_001ed5f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed5f8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ed5fc: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ed600: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ed604: 0xc07b532
    SET_GPR_U32(ctx, 31, 0x1ed60c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    FUN_001ed4c8(rdram, ctx, runtime); return;
}


// Function: entry_1ed60c
// Address: 0x1ed60c - 0x1ed618

void entry_1ed60c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed60c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed610: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001ed618
// Address: 0x1ed618 - 0x1ed62c

void FUN_001ed618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed618: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1ed61c: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1ed620: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1ed624: 0xc07b532
    SET_GPR_U32(ctx, 31, 0x1ed62c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    FUN_001ed4c8(rdram, ctx, runtime); return;
}


// Function: entry_1ed62c
// Address: 0x1ed62c - 0x1ed650

void entry_1ed62c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed62c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ed630: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ed638: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ed63c: 0x0
    // NOP
    // 0x1ed640: 0x7c450000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 5));
    // 0x1ed644: 0x0
    // NOP
    // 0x1ed648: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ed64c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ed650; return;
}


// Function: SetVectorCylind__FP6VECTORfff
// Address: 0x1ed650 - 0x1ed67c

void entry_1ed67c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed67c: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1ed680: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1ed684: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1ed688: 0xe6150008
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1ed68c: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x1ed690: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ed694: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x1ed698: 0xe6000000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1ed69c: 0xe6010004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x1ed6a0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ed6a4: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1ed6a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetVectorSphere__FP6VECTORfff
// Address: 0x1ed6b0 - 0x1ed6dc

void entry_1ed6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed6dc: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1ed6e0: 0x37a40008
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 29), 8));
    // 0x1ed6e4: 0xc07ab62
    SET_GPR_U32(ctx, 31, 0x1ed6ec);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 12));
    CalculateSinCos__FfPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1ed6ec
// Address: 0x1ed6ec - 0x1ed738

void entry_1ed6ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ed6ec: 0xc7a2000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 12)); ctx->f[2] = *(float*)&val; }
    // 0x1ed6f0: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1ed6f4: 0xc7a30000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[3] = *(float*)&val; }
    // 0x1ed6f8: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x1ed6fc: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1ed700: 0x46031082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x1ed704: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ed708: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1ed70c: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x1ed710: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x1ed714: 0x46141082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[20]);
    // 0x1ed718: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x1ed71c: 0xe6010000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1ed720: 0xe6020004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x1ed724: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ed728: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1ed72c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ed734: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ed738; return;
}


// Function: SProjectVector__FP6VECTORT0
// Address: 0x1ed738 - 0x1ed780

void entry_1eda34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eda34) {
        switch (ctx->pc) {
            case 0x1eda38: ctx->pc = 0; goto label_1eda38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eda34: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
label_1eda38:
    // 0x1eda38: 0x4614a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[20]);
    // 0x1eda3c: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1eda40: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1eda44: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1eda48: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1eda4c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1eda50: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1eda54: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x1eda58: 0xc08155e
    SET_GPR_U32(ctx, 31, 0x1eda60);
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[0];
    acosf(rdram, ctx, runtime); return;
}


// Function: entry_1eda60
// Address: 0x1eda60 - 0x1eda80

void entry_1eda60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eda60: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1eda64: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1eda68: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eda6c: 0xc7b50048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 72)); ctx->f[21] = *(float*)&val; }
    // 0x1eda70: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1eda74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eda7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eda80; return;
}


// Function: FindClosestPointBetweenLines__FP6VECTORN30PfT4T0
// Address: 0x1eda80 - 0x1edc08

void entry_1edc4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1edc4c) {
        switch (ctx->pc) {
            case 0x1edc80: ctx->pc = 0; goto label_1edc80;
            case 0x1edc84: ctx->pc = 0; goto label_1edc84;
            case 0x1edcb4: ctx->pc = 0; goto label_1edcb4;
            case 0x1edd70: ctx->pc = 0; goto label_1edd70;
            case 0x1edd80: ctx->pc = 0; goto label_1edd80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1edc4c: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1edc50: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1edc54: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1edc58: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1edc5c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1edc60: 0x0
    // NOP
    // 0x1edc64: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
        goto label_1edc84;
    }
    // 0x1edc6c: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1edc70: 0x0
    // NOP
    // 0x1edc74: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1edc80;
    }
    // 0x1edc7c: 0x46001046
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
label_1edc80:
    // 0x1edc80: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
label_1edc84:
    // 0x1edc84: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1edc88: 0xe6010000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x1edc8c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1edc90: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1edc94: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1edc98: 0x45010006
    ctx->f[3] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1edcb4;
    }
    // 0x1edca0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1edca4: 0x0
    // NOP
    // 0x1edca8: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1edcb4;
    }
    // 0x1edcb0: 0x460008c6
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
label_1edcb4:
    // 0x1edcb4: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1edcb8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1edcbc: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1edcc0: 0x46000047
    ctx->f[1] = FPU_NEG_S(ctx->f[0]);
    // 0x1edcc4: 0xe6030004
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 4), *(uint32_t*)&val); }
    // 0x1edcc8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1edccc: 0x44021800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[3]);
    // 0x1edcd0: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x1edcd4: 0x48a24000
    ctx->vu0_vf[8] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1edcd8: 0x48a33800
    ctx->vu0_vf[7] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1edcdc: 0x460310c1
    ctx->f[3] = FPU_SUB_S(ctx->f[2], ctx->f[3]);
    // 0x1edce0: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1edce4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1edce8: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1edcec: 0xda820000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1edcf0: 0x44031800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[3]);
    // 0x1edcf4: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1edcf8: 0xdaa10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1edcfc: 0x48a33000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1edd00: 0xda450000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1edd04: 0xda630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1edd08: 0x4be429bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1edd0c: 0x4be718bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x1edd10: 0x4be610bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x1edd14: 0x4be808c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1edd18: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1edd1c: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1edd20: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1edd24: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1edd28: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1edd2c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1edd30: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1edd34: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1edd38: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1edd3c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1edd40: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1edd44: 0xfba70000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x1edd48: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1edd4c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1edd50: 0xfba60000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1edd54: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1edd58: 0xfba80000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x1edd5c: 0x45000004
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1edd70;
    }
    // 0x1edd64: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1edd68: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1edd80;
    }
label_1edd70:
    // 0x1edd70: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1edd74: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1edd78: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1edd7c: 0xfa210000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_1edd80:
    // 0x1edd80: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1edd84: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1edd88: 0xaec20000
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 2));
    // 0x1edd8c: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1edd90: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1edd94: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1edd98: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1edd9c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1edda0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1edda4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1edda8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculateVectorPanTilt__FP6VECTORPfT1
// Address: 0x1eddb0 - 0x1edde0

void entry_1edde0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1edde0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1edde8);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1edde8
// Address: 0x1edde8 - 0x1ede14

void entry_1edde8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1edde8) {
        switch (ctx->pc) {
            case 0x1eddec: ctx->pc = 0; goto label_1eddec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1edde8: 0xe6200000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 0), *(uint32_t*)&val); }
label_1eddec:
    // 0x1eddec: 0x1240000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EDE24; return;
    }
    // 0x1eddf4: 0xc6000000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1eddf8: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1eddfc: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x1ede00: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x1ede04: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ede08: 0x46000344
    ctx->f[13] = FPU_SQRT_S(ctx->f[0]);
    // 0x1ede0c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1ede14);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1ede14
// Address: 0x1ede14 - 0x1ede1c

void entry_1ede14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ede14: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1ede1c);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1ede1c
// Address: 0x1ede1c - 0x1ede38

void entry_1ede1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ede1c) {
        switch (ctx->pc) {
            case 0x1ede24: ctx->pc = 0; goto label_1ede24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ede1c: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x1ede20: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1ede24:
    // 0x1ede24: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ede28: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ede2c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ede30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ConvertDeulToW__FP6VECTORN20
// Address: 0x1ede38 - 0x1ede68

void entry_1ede68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ede68: 0xc62c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1ede6c: 0x37a40008
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 29), 8));
    // 0x1ede70: 0xc07ab62
    SET_GPR_U32(ctx, 31, 0x1ede78);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 12));
    CalculateSinCos__FfPfT1(rdram, ctx, runtime); return;
}


// Function: entry_1ede78
// Address: 0x1ede78 - 0x1edef0

void entry_1ede78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ede78: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1ede7c: 0xc7a5000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 12)); ctx->f[5] = *(float*)&val; }
    // 0x1ede80: 0xc6060000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[6] = *(float*)&val; }
    // 0x1ede84: 0x46050082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x1ede88: 0xc6030004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[3] = *(float*)&val; }
    // 0x1ede8c: 0xc7a40008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[4] = *(float*)&val; }
    // 0x1ede90: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1ede94: 0x460320c2
    ctx->f[3] = FPU_MUL_S(ctx->f[4], ctx->f[3]);
    // 0x1ede98: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ede9c: 0x46061082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[6]);
    // 0x1edea0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1edea4: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x1edea8: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x1edeac: 0x46031081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[3]);
    // 0x1edeb0: 0xe6420000
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x1edeb4: 0xc6020004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[2] = *(float*)&val; }
    // 0x1edeb8: 0xc6030000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[3] = *(float*)&val; }
    // 0x1edebc: 0x46022942
    ctx->f[5] = FPU_MUL_S(ctx->f[5], ctx->f[2]);
    // 0x1edec0: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1edec4: 0x46050000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[5]);
    // 0x1edec8: 0xe6400004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 4), *(uint32_t*)&val); }
    // 0x1edecc: 0xc6020000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1eded0: 0xc6000008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1eded4: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x1eded8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ededc: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1edee0: 0xe6410008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 8), *(uint32_t*)&val); }
    // 0x1edee4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1edee8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FCalculateMuzzleVelocity__FP6VECTORT0fT0P2SO
// Address: 0x1edef0 - 0x1edf2c

void entry_1edf2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1edf2c) {
        switch (ctx->pc) {
            case 0x1edf3c: ctx->pc = 0; goto label_1edf3c;
            case 0x1edf48: ctx->pc = 0; goto label_1edf48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1edf2c: 0x12000003
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1edf3c;
    }
    // 0x1edf34: 0x10000004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 848));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1edf48;
    }
label_1edf3c:
    // 0x1edf3c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1edf40: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1edf44: 0x24701ee0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 3), 7904));
label_1edf48:
    // 0x1edf48: 0xda620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1edf4c: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1edf50: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1edf54: 0x4480b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 0);
    // 0x1edf58: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1edf5c: 0xc7b40008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[20] = *(float*)&val; }
    // 0x1edf60: 0xe7b70008
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x1edf64: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1edf68: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1edf6c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1edf70: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1edf74: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1edf78: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1edf7c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1edf80: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1edf84: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1edf88: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1edf8c: 0x4482b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 2);
    // 0x1edf90: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1edf98);
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1edf98
// Address: 0x1edf98 - 0x1edfcc

void entry_1edf98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1edf98) {
        switch (ctx->pc) {
            case 0x1edfac: ctx->pc = 0; goto label_1edfac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1edf98: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x1edf9c: 0x46176034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1edfa0: 0x0
    // NOP
    // 0x1edfa4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[23]);
        goto label_1edfac;
    }
label_1edfac:
    // 0x1edfac: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x1edfb0: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1edfb4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1edfb8: 0x460c0001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    // 0x1edfbc: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x1edfc0: 0x46006540
    ctx->f[21] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x1edfc4: 0xc08153c
    SET_GPR_U32(ctx, 31, 0x1edfcc);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    tanf(rdram, ctx, runtime); return;
}


// Function: entry_1edfcc
// Address: 0x1edfcc - 0x1ee004

void entry_1edfcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1edfcc: 0x4600b002
    ctx->f[0] = FPU_MUL_S(ctx->f[22], ctx->f[0]);
    // 0x1edfd0: 0xc6010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1edfd4: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x1edfd8: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x1edfdc: 0x46000d03
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[20] = ctx->f[1] / ctx->f[0];
    // 0x1edfe0: 0x4617a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1edfe4: 0x0
    // NOP
    // 0x1edfe8: 0x4501001e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1EE064; return;
    }
    // 0x1edff0: 0x46140004
    ctx->f[0] = FPU_SQRT_S(ctx->f[0]);
    // 0x1edff4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x1edff8: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1edffc: 0xc081484
    SET_GPR_U32(ctx, 31, 0x1ee004);
    ctx->f[20] = FPU_MUL_S(ctx->f[22], ctx->f[20]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_1ee004
// Address: 0x1ee004 - 0x1ee018

void entry_1ee004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee004: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ee008: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1ee00c: 0x4600a503
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[20] = ctx->f[20] / ctx->f[0];
    // 0x1ee010: 0xc08153c
    SET_GPR_U32(ctx, 31, 0x1ee018);
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    tanf(rdram, ctx, runtime); return;
}


// Function: entry_1ee018
// Address: 0x1ee018 - 0x1ee090

void entry_1ee018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ee018) {
        switch (ctx->pc) {
            case 0x1ee064: ctx->pc = 0; goto label_1ee064;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ee018: 0x4600b002
    ctx->f[0] = FPU_MUL_S(ctx->f[22], ctx->f[0]);
    // 0x1ee01c: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1ee020: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ee024: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1ee028: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ee02c: 0xe6200008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 8), *(uint32_t*)&val); }
    // 0x1ee030: 0xda210000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ee034: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ee038: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ee03c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ee040: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ee044: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ee048: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ee04c: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ee050: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1ee054: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ee058: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1ee05c: 0x4be310d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ee060: 0xfa230000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[3]));
label_1ee064:
    // 0x1ee064: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ee068: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ee06c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ee070: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ee074: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ee078: 0xc7b70088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[23] = *(float*)&val; }
    // 0x1ee07c: 0xc7b60080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[22] = *(float*)&val; }
    // 0x1ee080: 0xc7b50078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[21] = *(float*)&val; }
    // 0x1ee084: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1ee088: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FCalculateMuzzleVelocity1
// Address: 0x1ee090 - 0x1ee290

void entry_1ee2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee2a0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ee2a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ee2ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ee2b0; return;
}


// Function: LimitVectorLength
// Address: 0x1ee2b0 - 0x1ee318

void entry_1ee32c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee32c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ee330: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1ee334: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x1ee338: 0x2463a0e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294942944));
    // 0x1ee33c: 0xae030018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 3));
    // 0x1ee340: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ee344: 0xae00001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 0));
    // 0x1ee348: 0xae000020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 0));
    // 0x1ee34c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ee350: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ee354: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ee35c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ee360; return;
}


// Function: junk_001EE360
// Address: 0x1ee360 - 0x1ee368

void entry_1ee60c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ee60c) {
        switch (ctx->pc) {
            case 0x1ee61c: ctx->pc = 0; goto label_1ee61c;
            case 0x1ee64c: ctx->pc = 0; goto label_1ee64c;
            case 0x1ee650: ctx->pc = 0; goto label_1ee650;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ee60c: 0x12000003
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1ee61c;
    }
    // 0x1ee614: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1ee618: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
label_1ee61c:
    // 0x1ee61c: 0x24c50003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 6), 3));
    // 0x1ee620: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1ee624: 0x65182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 5)));
    // 0x1ee628: 0x24c20006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 6));
    // 0x1ee62c: 0xa3100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 5));
    // 0x1ee630: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1ee634: 0x21083
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 2));
    // 0x1ee638: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1ee63c: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1ee640: 0x12400002
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1ee64c;
    }
    // 0x1ee648: 0xae460000
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 6));
label_1ee64c:
    // 0x1ee64c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1ee650:
    // 0x1ee650: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ee654: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ee658: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ee65c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ee664: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ee668; return;
}


// Function: AddVifUnpack__4VIFS3UPKiPvi
// Address: 0x1ee668 - 0x1ee688

void entry_1ee688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ee688) {
        switch (ctx->pc) {
            case 0x1ee6a8: ctx->pc = 0; goto label_1ee6a8;
            case 0x1ee6c4: ctx->pc = 0; goto label_1ee6c4;
            case 0x1ee6d0: ctx->pc = 0; goto label_1ee6d0;
            case 0x1ee704: ctx->pc = 0; goto label_1ee704;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ee688: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ee68c: 0x8fa70004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ee690: 0x24420003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 3));
    // 0x1ee694: 0x21083
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 2));
    // 0x1ee698: 0x30460003
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 2), 3));
    // 0x1ee69c: 0x10c00009
    SET_GPR_U32(ctx, 9, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_1ee6c4;
    }
    // 0x1ee6a4: 0xc0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
label_1ee6a8:
    // 0x1ee6a8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ee6ac: 0x2508ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967295));
    // 0x1ee6b0: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x1ee6b4: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
    // 0x1ee6b8: 0x0
    // NOP
    // 0x1ee6bc: 0x1500fffa
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    if (GPR_U32(ctx, 8) != GPR_U32(ctx, 0)) {
        goto label_1ee6a8;
    }
label_1ee6c4:
    // 0x1ee6c4: 0x1920000f
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 9) <= 0) {
        goto label_1ee704;
    }
    // 0x1ee6cc: 0x0
    // NOP
label_1ee6d0:
    // 0x1ee6d0: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ee6d4: 0x25080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4));
    // 0x1ee6d8: 0x8e050004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ee6dc: 0x109302a
    SET_GPR_U32(ctx, 6, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 9)));
    // 0x1ee6e0: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1ee6e4: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1ee6e8: 0xace40000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 4));
    // 0x1ee6ec: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    // 0x1ee6f0: 0xace50004
    WRITE32(ADD32(GPR_U32(ctx, 7), 4), GPR_U32(ctx, 5));
    // 0x1ee6f4: 0xace20008
    WRITE32(ADD32(GPR_U32(ctx, 7), 8), GPR_U32(ctx, 2));
    // 0x1ee6f8: 0xace3000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 3));
    // 0x1ee6fc: 0x14c0fff4
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_1ee6d0;
    }
label_1ee704:
    // 0x1ee704: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ee708: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ee70c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ee714: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ee718; return;
}


// Function: AddVifUnpackRefs__4VIFS3UPKiPviPPPv
// Address: 0x1ee718 - 0x1ee75c

void entry_1ee75c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee75c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ee760: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ee764: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ee768: 0xc07b958
    SET_GPR_U32(ctx, 31, 0x1ee770);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CbUnpackSetup__4VIFS3UPKii(rdram, ctx, runtime); return;
}


// Function: entry_1ee770
// Address: 0x1ee770 - 0x1ee794

void entry_1ee770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee770: 0x2444000f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 15));
    // 0x1ee774: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1ee778: 0x64182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x1ee77c: 0x2442001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 30));
    // 0x1ee780: 0x83100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    // 0x1ee784: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1ee788: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ee78c: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x1ee794);
    SET_GPR_S32(ctx, 5, SRA32(GPR_S32(ctx, 2), 4));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1ee794
// Address: 0x1ee794 - 0x1ee7d0

void entry_1ee794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ee794) {
        switch (ctx->pc) {
            case 0x1ee7a8: ctx->pc = 0; goto label_1ee7a8;
            case 0x1ee7ac: ctx->pc = 0; goto label_1ee7ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ee794: 0x12800005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_1ee7ac;
    }
    // 0x1ee79c: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1ee7a0: 0x2442fff4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967284));
    // 0x1ee7a4: 0xae820000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 2));
label_1ee7a8:
    // 0x1ee7a8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_1ee7ac:
    // 0x1ee7ac: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ee7b0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ee7b4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ee7b8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ee7bc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ee7c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ee7c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ee7cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ee7d0; return;
}


// Function: AddVifDirect__4VIFSiP2QWi
// Address: 0x1ee7d0 - 0x1ee800

void entry_1ee800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee800: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1ee804: 0x3c035000
    SET_GPR_U32(ctx, 3, ((uint32_t)20480 << 16));
    // 0x1ee808: 0x1087c0
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 31));
    // 0x1ee80c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ee810: 0x24a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1ee814: 0x2038025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1ee818: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x1ee81c: 0x2508025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
    // 0x1ee820: 0xacb00000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 16));
    // 0x1ee824: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ee828: 0xc054b38
    SET_GPR_U32(ctx, 31, 0x1ee830);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AddDmaBulk__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1ee830
// Address: 0x1ee830 - 0x1ee850

void entry_1ee830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee830: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ee834: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ee838: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ee83c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ee840: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ee844: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ee84c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ee850; return;
}


// Function: AddVifDirectRefs__4VIFSiP2QWi
// Address: 0x1ee850 - 0x1ee880

void entry_1ee880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee880: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1ee884: 0x3c035000
    SET_GPR_U32(ctx, 3, ((uint32_t)20480 << 16));
    // 0x1ee888: 0x1087c0
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 31));
    // 0x1ee88c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ee890: 0x24a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1ee894: 0x2038025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1ee898: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x1ee89c: 0x2508025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
    // 0x1ee8a0: 0xacb00000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 16));
    // 0x1ee8a4: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1ee8a8: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x1ee8b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1ee8b0
// Address: 0x1ee8b0 - 0x1ee8d0

void entry_1ee8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee8b0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ee8b4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ee8b8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ee8bc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ee8c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ee8c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ee8cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ee8d0; return;
}


// Function: AddVifGifs__4VIFSP4GIFS
// Address: 0x1ee8d0 - 0x1ee8f4

void entry_1ee8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee8f4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ee8f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitVismap__FP6VISMAP
// Address: 0x1ee900 - 0x1ee914

void entry_1ee914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee914: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1ee918: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ee91c: 0xac501ec4
    WRITE32(ADD32(GPR_U32(ctx, 2), 7876), GPR_U32(ctx, 16));
    // 0x1ee920: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ee924: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ee92c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ee930; return;
}


// Function: LoadVismapFromBrx__FP6VISMAPP18CBinaryInputStream
// Address: 0x1ee930 - 0x1ee95c

void entry_1ee95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee95c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ee960: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1ee968);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1ee968
// Address: 0x1ee968 - 0x1ee974

void entry_1ee968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee968: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1ee96c: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1ee974);
    WRITE32(ADD32(GPR_U32(ctx, 17), 60), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1ee974
// Address: 0x1ee974 - 0x1ee988

void entry_1ee974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ee974) {
        switch (ctx->pc) {
            case 0x1ee980: ctx->pc = 0; goto label_1ee980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ee974: 0x8e23003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    // 0x1ee978: 0x1860000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 64), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1EE9AC; return;
    }
label_1ee980:
    // 0x1ee980: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x1ee988);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1ee988
// Address: 0x1ee988 - 0x1ee9b8

void entry_1ee988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ee988) {
        switch (ctx->pc) {
            case 0x1ee9ac: ctx->pc = 0; goto label_1ee9ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ee988: 0x8e240040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x1ee98c: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1ee990: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1ee994: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1ee998: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1ee99c: 0x8e22003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    // 0x1ee9a0: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1ee9a4: 0x1440fff6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EE980; return;
    }
label_1ee9ac:
    // 0x1ee9ac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ee9b0: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x1ee9b8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1ee9b8
// Address: 0x1ee9b8 - 0x1ee9d0

void entry_1ee9b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ee9b8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ee9bc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ee9c0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ee9c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ee9c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GrfzonOneHop__FP6VISMAPP4VBSP
// Address: 0x1ee9d0 - 0x1eea40

void entry_1eea80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eea80) {
        switch (ctx->pc) {
            case 0x1eea88: ctx->pc = 0; goto label_1eea88;
            case 0x1eea90: ctx->pc = 0; goto label_1eea90;
            case 0x1eeae0: ctx->pc = 0; goto label_1eeae0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eea80: 0x1000002d
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EEB38; return;
    }
label_1eea88:
    // 0x1eea88: 0x4600a547
    ctx->f[21] = FPU_NEG_S(ctx->f[20]);
    // 0x1eea8c: 0x3c138000
    SET_GPR_U32(ctx, 19, ((uint32_t)32768 << 16));
label_1eea90:
    // 0x1eea90: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1eea94: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eea98: 0x4bc1186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1eea9c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1eeaa0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1eeaa4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1eeaa8: 0xc6010010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1eeaac: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1eeab0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1eeab4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1eeab8: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eeabc: 0x0
    // NOP
    // 0x1eeac0: 0x45030015
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        ctx->pc = 0x1EEB18; return;
    }
    // 0x1eeac8: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1eeacc: 0x0
    // NOP
    // 0x1eead0: 0x45000003
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1eeae0;
    }
    // 0x1eead8: 0x10000010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 19)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EEB1C; return;
    }
label_1eeae0:
    // 0x1eeae0: 0xb31024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 19)));
    // 0x1eeae4: 0x10400007
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EEB04; return;
    }
    // 0x1eeaec: 0xc07ba74
    SET_GPR_U32(ctx, 31, 0x1eeaf4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GrfzonOneHop__FP6VISMAPP4VBSP(rdram, ctx, runtime); return;
}


// Function: entry_1eeaf4
// Address: 0x1eeaf4 - 0x1eeb14

void entry_1eeaf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eeaf4) {
        switch (ctx->pc) {
            case 0x1eeb04: ctx->pc = 0; goto label_1eeb04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eeaf4: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1eeaf8: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1eeafc: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1eeb14(rdram, ctx, runtime); return;
    }
label_1eeb04:
    // 0x1eeb04: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1eeb08: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1eeb0c: 0xc07ba90
    SET_GPR_U32(ctx, 31, 0x1eeb14);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ClipVbspSphereOneHop__FP6VISMAPP4VBSPG9VU_VECTORfPi(rdram, ctx, runtime); return;
}


// Function: entry_1eeb14
// Address: 0x1eeb14 - 0x1eeb2c

void entry_1eeb14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eeb14) {
        switch (ctx->pc) {
            case 0x1eeb18: ctx->pc = 0; goto label_1eeb18;
            case 0x1eeb1c: ctx->pc = 0; goto label_1eeb1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eeb14: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
label_1eeb18:
    // 0x1eeb18: 0xb31024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 5), GPR_U32(ctx, 19)));
label_1eeb1c:
    // 0x1eeb1c: 0x1040ffdc
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EEA90; return;
    }
    // 0x1eeb24: 0xc07ba74
    SET_GPR_U32(ctx, 31, 0x1eeb2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GrfzonOneHop__FP6VISMAPP4VBSP(rdram, ctx, runtime); return;
}


// Function: entry_1eeb2c
// Address: 0x1eeb2c - 0x1eeb60

void entry_1eeb2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eeb2c) {
        switch (ctx->pc) {
            case 0x1eeb38: ctx->pc = 0; goto label_1eeb38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eeb2c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1eeb30: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1eeb34: 0xae230000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 3));
label_1eeb38:
    // 0x1eeb38: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1eeb3c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1eeb40: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1eeb44: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1eeb48: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eeb4c: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x1eeb50: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x1eeb54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eeb5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eeb60; return;
}


// Function: ClipVismapSphereOneHop__FP6VISMAPP6VECTORfPi
// Address: 0x1eeb60 - 0x1eeb8c

void entry_1eeb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eeb8c) {
        switch (ctx->pc) {
            case 0x1eeb94: ctx->pc = 0; goto label_1eeb94;
            case 0x1eeb98: ctx->pc = 0; goto label_1eeb98;
            case 0x1eeba4: ctx->pc = 0; goto label_1eeba4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eeb8c: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eeba4;
    }
label_1eeb94:
    // 0x1eeb94: 0x3c020fff
    SET_GPR_U32(ctx, 2, ((uint32_t)4095 << 16));
label_1eeb98:
    // 0x1eeb98: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1eeb9c: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
    // 0x1eeba0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1eeba4:
    // 0x1eeba4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eebac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eebb0; return;
}


// Function: ClipVismapPointNoHop__FP6VISMAPP6VECTORPi
// Address: 0x1eebb0 - 0x1eec60

void entry_1eec74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eec74: 0xde030538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1eec78: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1eec7c: 0x21738
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 28);
    // 0x1eec80: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1eec84: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1eec88: 0x24090001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1eec8c: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1eec90: 0xae090588
    WRITE32(ADD32(GPR_U32(ctx, 16), 1416), GPR_U32(ctx, 9));
    // 0x1eec94: 0xfe030538
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 3));
    // 0x1eec98: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eec9c: 0xe6000360
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 864), *(uint32_t*)&val); }
    // 0x1eeca0: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1eeca4: 0xae090584
    WRITE32(ADD32(GPR_U32(ctx, 16), 1412), GPR_U32(ctx, 9));
    // 0x1eeca8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eecac: 0xe6000364
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 868), *(uint32_t*)&val); }
    // 0x1eecb0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eecb4: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x1eecbc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_1eecbc
// Address: 0x1eecbc - 0x1eecc8

void entry_1eecbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eecbc: 0x26040590
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1424));
    // 0x1eecc0: 0xc07d564
    SET_GPR_U32(ctx, 31, 0x1eecc8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitZpd__FP3ZPDP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1eecc8
// Address: 0x1eecc8 - 0x1eece0

void entry_1eecc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eecc8: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1eeccc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eecd0: 0xae020594
    WRITE32(ADD32(GPR_U32(ctx, 16), 1428), GPR_U32(ctx, 2));
    // 0x1eecd4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eecd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostWaterLoad__FP5WATER
// Address: 0x1eece0 - 0x1eed1c

void entry_1eed1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eed1c: 0xc07d56a
    SET_GPR_U32(ctx, 31, 0x1eed24);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1424));
    PostZpdLoad__FP3ZPD(rdram, ctx, runtime); return;
}


// Function: entry_1eed24
// Address: 0x1eed24 - 0x1eed2c

void entry_1eed24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eed24: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1eed2c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 128));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1eed2c
// Address: 0x1eed2c - 0x1eed48

void entry_1eed2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eed2c: 0x8e030278
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 632)));
    // 0x1eed30: 0x10600005
    WRITE32(ADD32(GPR_U32(ctx, 16), 1376), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1eed48(rdram, ctx, runtime); return;
    }
    // 0x1eed38: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1eed3c: 0x8c6200d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 216)));
    // 0x1eed40: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1eed48);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1eed48
// Address: 0x1eed48 - 0x1eed68

void entry_1eed48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eed48: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1eed4c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1eed50: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
    // 0x1eed54: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1eed58: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eed5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eed64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eed68; return;
}


// Function: CalculateWaterCurrent__FP5WATERP6VECTORN21
// Address: 0x1eed68 - 0x1eeda4

void entry_1eeda4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eeda4: 0x7a050570
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 16), 1392)));
    // 0x1eeda8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1eedac: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x1eedb0: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1eedb4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1eedb8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1eedbc: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1eedc0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eedc4: 0x7fa50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 5));
    // 0x1eedc8: 0x27a80010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1eedcc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eedd0: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x1eedd4: 0xc049f98
    SET_GPR_U32(ctx, 31, 0x1eeddc);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 32));
    CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2(rdram, ctx, runtime); return;
}


// Function: entry_1eeddc
// Address: 0x1eeddc - 0x1eee08

void entry_1eeddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eeddc: 0x8e020278
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 632)));
    // 0x1eede0: 0x1040000d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EEE18; return;
    }
    // 0x1eede8: 0x8c44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x1eedec: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1eedf0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1eedf4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eedf8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eedfc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eee00: 0xc07cbbc
    SET_GPR_U32(ctx, 31, 0x1eee08);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 48));
    WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2(rdram, ctx, runtime); return;
}


// Function: entry_1eee08
// Address: 0x1eee08 - 0x1eee50

void entry_1eee08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eee08) {
        switch (ctx->pc) {
            case 0x1eee18: ctx->pc = 0; goto label_1eee18;
            case 0x1eee24: ctx->pc = 0; goto label_1eee24;
            case 0x1eee30: ctx->pc = 0; goto label_1eee30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eee08: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eee0c: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1eee10: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1eee14: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
label_1eee18:
    // 0x1eee18: 0x12400002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_1eee24;
    }
    // 0x1eee20: 0x7e420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), GPR_VEC(ctx, 2));
label_1eee24:
    // 0x1eee24: 0x12600002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1eee30;
    }
    // 0x1eee2c: 0x7e620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 2));
label_1eee30:
    // 0x1eee30: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1eee34: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1eee38: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1eee3c: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1eee40: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1eee44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1eee4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1eee50; return;
}


// Function: UpdateSwXaList__FP2SWPP2XA
// Address: 0x1eee50 - 0x1eef04

void entry_1eef04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eef04) {
        switch (ctx->pc) {
            case 0x1eef0c: ctx->pc = 0; goto label_1eef0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eef04: 0x10000004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EEF18; return;
    }
label_1eef0c:
    // 0x1eef0c: 0xc06e94a
    SET_GPR_U32(ctx, 31, 0x1eef14);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddSoXa__FP2SOP2XA(rdram, ctx, runtime); return;
}


// Function: entry_1eef14
// Address: 0x1eef14 - 0x1eef60

void entry_1eef14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eef14) {
        switch (ctx->pc) {
            case 0x1eef18: ctx->pc = 0; goto label_1eef18;
            case 0x1eef30: ctx->pc = 0; goto label_1eef30;
            case 0x1eef38: ctx->pc = 0; goto label_1eef38;
            case 0x1eef54: ctx->pc = 0; goto label_1eef54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eef14: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
label_1eef18:
    // 0x1eef18: 0xdc620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 1336)));
    // 0x1eef1c: 0x571024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x1eef20: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 17));
        goto label_1eef30;
    }
    // 0x1eef28: 0x10000003
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1eef38;
    }
label_1eef30:
    // 0x1eef30: 0xae13000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 19));
    // 0x1eef34: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1eef38:
    // 0x1eef38: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1eef3c: 0x220802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1eef40: 0xdc620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 1336)));
    // 0x1eef44: 0x561024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1eef48: 0x551024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1eef4c: 0x1600ffe0
    WRITE64(ADD32(GPR_U32(ctx, 3), 1336), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EEED0; return;
    }
label_1eef54:
    // 0x1eef54: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1eef58: 0xc076ee4
    SET_GPR_U32(ctx, 31, 0x1eef60);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FreeSwXaList__FP2SWP2XA(rdram, ctx, runtime); return;
}


// Function: entry_1eef60
// Address: 0x1eef60 - 0x1eef90

void entry_1eef60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1eef60: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1eef64: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1eef68: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1eef6c: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1eef70: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1eef74: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1eef78: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1eef7c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1eef80: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1eef84: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1eef88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateWater__FP5WATERf
// Address: 0x1eef90 - 0x1eefd8

void entry_1eefd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eefd8) {
        switch (ctx->pc) {
            case 0x1ef000: ctx->pc = 0; goto label_1ef000;
            case 0x1ef01c: ctx->pc = 0; goto label_1ef01c;
            case 0x1ef048: ctx->pc = 0; goto label_1ef048;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eefd8: 0x8e4203f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1016)));
    // 0x1eefdc: 0x104000e1
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 18), 1360));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1ef364(rdram, ctx, runtime); return;
    }
    // 0x1eefe4: 0x8e500550
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 1360)));
    // 0x1eefe8: 0x1200000c
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1ef01c;
    }
    // 0x1eeff0: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1eeff4: 0x4233c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << (32 + 12));
    // 0x1eeff8: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1eeffc: 0x0
    // NOP
label_1ef000:
    // 0x1ef000: 0xdc620538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 1336)));
    // 0x1ef004: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1ef008: 0xfc620538
    WRITE64(ADD32(GPR_U32(ctx, 3), 1336), GPR_U64(ctx, 2));
    // 0x1ef00c: 0x8e10000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1ef010: 0x0
    // NOP
    // 0x1ef014: 0x5600fffa
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_1ef000;
    }
label_1ef01c:
    // 0x1ef01c: 0x8e420050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x1ef020: 0x8c430480
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1152)));
    // 0x1ef024: 0x8c730000
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1ef028: 0x126000a1
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EF2B0; return;
    }
    // 0x1ef030: 0x4480b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 0);
    // 0x1ef034: 0x3c0140c0
    SET_GPR_U32(ctx, 1, ((uint32_t)16576 << 16));
    // 0x1ef038: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1ef03c: 0x24548d30
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1ef040: 0x8e71000c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 12)));
    // 0x1ef044: 0x0
    // NOP
label_1ef048:
    // 0x1ef048: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1ef04c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1ef050: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ef054: 0xc6200360
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 864)); ctx->f[0] = *(float*)&val; }
    // 0x1ef058: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ef05c: 0x0
    // NOP
    // 0x1ef060: 0x45030091
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x1EF2A8; return;
    }
    // 0x1ef068: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1ef06c: 0x34038008
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32776));
    // 0x1ef070: 0x319fc
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 7));
    // 0x1ef074: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ef078: 0x5440008b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x1EF2A8; return;
    }
    // 0x1ef080: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ef084: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ef088: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ef08c: 0xc07bd6e
    SET_GPR_U32(ctx, 31, 0x1ef094);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UGetWaterSubmerged__FP5WATERP2SOP6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1ef094
// Address: 0x1ef094 - 0x1ef0cc

void entry_1ef094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef094: 0x46170032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ef098: 0x0
    // NOP
    // 0x1ef09c: 0x45030082
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x1EF2A8; return;
    }
    // 0x1ef0a4: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1ef0a8: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1ef0ac: 0x31b7c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 13));
    // 0x1ef0b0: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ef0b4: 0xfe220538
    WRITE64(ADD32(GPR_U32(ctx, 17), 1336), GPR_U64(ctx, 2));
    // 0x1ef0b8: 0x8e430278
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 632)));
    // 0x1ef0bc: 0x50600004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
        ctx->pc = 0x1EF0D0; return;
    }
    // 0x1ef0c4: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x1ef0cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1ef0cc
// Address: 0x1ef0cc - 0x1ef0ec

void entry_1ef0cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef0cc) {
        switch (ctx->pc) {
            case 0x1ef0d0: ctx->pc = 0; goto label_1ef0d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef0cc: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
label_1ef0d0:
    // 0x1ef0d0: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1ef0d4: 0x31b3c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 12));
    // 0x1ef0d8: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ef0dc: 0x54400072
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x1EF2A8; return;
    }
    // 0x1ef0e4: 0xc076ed4
    SET_GPR_U32(ctx, 31, 0x1ef0ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    PxaAllocSw__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_1ef0ec
// Address: 0x1ef0ec - 0x1ef158

void entry_1ef0ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef0ec: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1ef0f0: 0xae120000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 18));
    // 0x1ef0f4: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x1ef0f8: 0x8e420550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1360)));
    // 0x1ef0fc: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    // 0x1ef100: 0xae500550
    WRITE32(ADD32(GPR_U32(ctx, 18), 1360), GPR_U32(ctx, 16));
    // 0x1ef104: 0x8e420580
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1408)));
    // 0x1ef108: 0x50400067
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x1EF2A8; return;
    }
    // 0x1ef110: 0xc6210158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 344)); ctx->f[1] = *(float*)&val; }
    // 0x1ef114: 0x3c01c2c8
    SET_GPR_U32(ctx, 1, ((uint32_t)49864 << 16));
    // 0x1ef118: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ef11c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ef120: 0x0
    // NOP
    // 0x1ef124: 0x45020060
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x1EF2A8; return;
    }
    // 0x1ef12c: 0x8e420278
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 632)));
    // 0x1ef130: 0x1040000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EF16C; return;
    }
    // 0x1ef138: 0x8c44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x1ef13c: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x1ef140: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1ef144: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ef148: 0x27a70730
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 1840));
    // 0x1ef14c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ef150: 0xc07cbbc
    SET_GPR_U32(ctx, 31, 0x1ef158);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2(rdram, ctx, runtime); return;
}


// Function: entry_1ef158
// Address: 0x1ef158 - 0x1ef1f0

void entry_1ef158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef158) {
        switch (ctx->pc) {
            case 0x1ef16c: ctx->pc = 0; goto label_1ef16c;
            case 0x1ef174: ctx->pc = 0; goto label_1ef174;
            case 0x1ef1ac: ctx->pc = 0; goto label_1ef1ac;
            case 0x1ef1bc: ctx->pc = 0; goto label_1ef1bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef158: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1ef15c: 0xdba10730
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 1840)));
    // 0x1ef160: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ef164: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 1824), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ef174;
    }
label_1ef16c:
    // 0x1ef16c: 0x7a820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1ef170: 0x7fa20720
    WRITE128(ADD32(GPR_U32(ctx, 29), 1824), GPR_VEC(ctx, 2));
label_1ef174:
    // 0x1ef174: 0xda220370
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 880)));
    // 0x1ef178: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ef17c: 0xdba30720
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 1824)));
    // 0x1ef180: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ef184: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1ef188: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ef18c: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1ef190: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ef194: 0x16230005
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 3)) {
        goto label_1ef1ac;
    }
    // 0x1ef19c: 0x3c01c296
    SET_GPR_U32(ctx, 1, ((uint32_t)49814 << 16));
    // 0x1ef1a0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ef1a4: 0x10000005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ef1bc;
    }
label_1ef1ac:
    // 0x1ef1ac: 0xc6210428
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1064)); ctx->f[1] = *(float*)&val; }
    // 0x1ef1b0: 0xc6200148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 328)); ctx->f[0] = *(float*)&val; }
    // 0x1ef1b4: 0x46000881
    ctx->f[2] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1ef1b8: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
label_1ef1bc:
    // 0x1ef1bc: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1ef1c0: 0xc7a10018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1ef1c4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ef1c8: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1ef1cc: 0x8e4403f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1016)));
    // 0x1ef1d0: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1ef1d4: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ef1d8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ef1dc: 0x24080010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1ef1e0: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x1ef1e4: 0x200482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ef1e8: 0xc04f7f6
    SET_GPR_U32(ctx, 31, 0x1ef1f0);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1ef1f0
// Address: 0x1ef1f0 - 0x1ef284

void entry_1ef1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef1f0: 0x1840002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_1ef2a4(rdram, ctx, runtime); return;
    }
    // 0x1ef1f8: 0x5040002b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        ctx->pc = 0x1EF2A8; return;
    }
    // 0x1ef200: 0xc6200420
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1056)); ctx->f[0] = *(float*)&val; }
    // 0x1ef204: 0xc6220424
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1060)); ctx->f[2] = *(float*)&val; }
    // 0x1ef208: 0xc6230430
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1072)); ctx->f[3] = *(float*)&val; }
    // 0x1ef20c: 0xc6210434
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1076)); ctx->f[1] = *(float*)&val; }
    // 0x1ef210: 0x460018c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[0]);
    // 0x1ef214: 0xc6240158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 344)); ctx->f[4] = *(float*)&val; }
    // 0x1ef218: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x1ef21c: 0x3c013e2a
    SET_GPR_U32(ctx, 1, ((uint32_t)15914 << 16));
    // 0x1ef220: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x1ef224: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x1ef228: 0x46002007
    ctx->f[0] = FPU_NEG_S(ctx->f[4]);
    // 0x1ef22c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1ef230: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1ef234: 0x46172034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1ef238: 0x460118c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[1]);
    // 0x1ef23c: 0x46160029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[22]);
    // 0x1ef240: 0x46050502
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    // 0x1ef244: 0x45000017
    ctx->f[21] = FPU_MUL_S(ctx->f[3], ctx->f[2]);
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1ef2a4(rdram, ctx, runtime); return;
    }
    // 0x1ef24c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1ef250: 0x24040022
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 34));
    // 0x1ef254: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x1ef258: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1ef25c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ef260: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1ef264: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1ef268: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ef26c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1ef270: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ef274: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1ef278: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ef27c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1ef284);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1ef284
// Address: 0x1ef284 - 0x1ef2a4

void entry_1ef284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef284: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ef288: 0x4614ab02
    ctx->f[12] = FPU_MUL_S(ctx->f[21], ctx->f[20]);
    // 0x1ef28c: 0xdba20720
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 1824)));
    // 0x1ef290: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ef294: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ef298: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1ef29c: 0xc055ffe
    SET_GPR_U32(ctx, 31, 0x1ef2a4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    StockSplashBig__FP6VECTORfP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1ef2a4
// Address: 0x1ef2a4 - 0x1ef33c

void entry_1ef2a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef2a4) {
        switch (ctx->pc) {
            case 0x1ef2a8: ctx->pc = 0; goto label_1ef2a8;
            case 0x1ef2b0: ctx->pc = 0; goto label_1ef2b0;
            case 0x1ef2e0: ctx->pc = 0; goto label_1ef2e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef2a4: 0x8e730004
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 19), 4)));
label_1ef2a8:
    // 0x1ef2a8: 0x5660ff67
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 12)));
        ctx->pc = 0x1EF048; return;
    }
label_1ef2b0:
    // 0x1ef2b0: 0x8e500550
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 1360)));
    // 0x1ef2b4: 0x12000024
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EF348; return;
    }
    // 0x1ef2bc: 0x2415fff7
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 4294967287));
    // 0x1ef2c0: 0x15ac38
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 21) << 16);
    // 0x1ef2c4: 0x36b5ffff
    SET_GPR_U32(ctx, 21, OR32(GPR_U32(ctx, 21), 65535));
    // 0x1ef2c8: 0x15ac38
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 21) << 16);
    // 0x1ef2cc: 0x36b5ffff
    SET_GPR_U32(ctx, 21, OR32(GPR_U32(ctx, 21), 65535));
    // 0x1ef2d0: 0x34148000
    SET_GPR_U32(ctx, 20, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1ef2d4: 0x14a33c
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 20) << (32 + 12));
    // 0x1ef2d8: 0x8e110004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ef2dc: 0x0
    // NOP
label_1ef2e0:
    // 0x1ef2e0: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1ef2e4: 0x21f3e
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) >> (32 + 28));
    // 0x1ef2e8: 0x216fe
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) >> (32 + 27));
    // 0x1ef2ec: 0x30630001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 1));
    // 0x1ef2f0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1ef2f4: 0x10430011
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        entry_1ef33c(rdram, ctx, runtime); return;
    }
    // 0x1ef2fc: 0xde2202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x1ef300: 0x2405000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1ef304: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1ef308: 0x551024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1ef30c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ef310: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1ef314: 0x24170001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ef318: 0xfe2202c8
    WRITE64(ADD32(GPR_U32(ctx, 17), 712), GPR_U64(ctx, 2));
    // 0x1ef31c: 0xafb20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 18));
    // 0x1ef320: 0xafb10004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 17));
    // 0x1ef324: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1ef328: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x1ef32c: 0x8c670048
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x1ef330: 0x541024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1ef334: 0xe0f809
    SET_GPR_U32(ctx, 31, 0x1ef33c);
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 19));
    ctx->pc = GPR_U32(ctx, 7); return;
}


// Function: entry_1ef33c
// Address: 0x1ef33c - 0x1ef354

void entry_1ef33c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef33c) {
        switch (ctx->pc) {
            case 0x1ef348: ctx->pc = 0; goto label_1ef348;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef33c: 0x8e10000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1ef340: 0x5600ffe7
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x1EF2E0; return;
    }
label_1ef348:
    // 0x1ef348: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1ef34c: 0xc07bb94
    SET_GPR_U32(ctx, 31, 0x1ef354);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    UpdateSwXaList__FP2SWPP2XA(rdram, ctx, runtime); return;
}


// Function: entry_1ef354
// Address: 0x1ef354 - 0x1ef364

void entry_1ef354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef354: 0x12e00004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 2000)));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EF368; return;
    }
    // 0x1ef35c: 0xc07bd48
    SET_GPR_U32(ctx, 31, 0x1ef364);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    UpdateWaterMergeGroup__FP5WATER(rdram, ctx, runtime); return;
}


// Function: entry_1ef364
// Address: 0x1ef364 - 0x1ef3a8

void entry_1ef364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef364) {
        switch (ctx->pc) {
            case 0x1ef368: ctx->pc = 0; goto label_1ef368;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef364: 0x7bbf07d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 2000)));
label_1ef368:
    // 0x1ef368: 0x7bbe07c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 1984)));
    // 0x1ef36c: 0x7bb707b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 1968)));
    // 0x1ef370: 0x7bb607a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 1952)));
    // 0x1ef374: 0x7bb50790
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 1936)));
    // 0x1ef378: 0x7bb40780
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 1920)));
    // 0x1ef37c: 0x7bb30770
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1904)));
    // 0x1ef380: 0x7bb20760
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1888)));
    // 0x1ef384: 0x7bb10750
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1872)));
    // 0x1ef388: 0x7bb00740
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1856)));
    // 0x1ef38c: 0xc7b707f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 2040)); ctx->f[23] = *(float*)&val; }
    // 0x1ef390: 0xc7b607f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 2032)); ctx->f[22] = *(float*)&val; }
    // 0x1ef394: 0xc7b507e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 2024)); ctx->f[21] = *(float*)&val; }
    // 0x1ef398: 0xc7b407e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 2016)); ctx->f[20] = *(float*)&val; }
    // 0x1ef39c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 2048));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ef3a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ef3a8; return;
}


// Function: AddWaterExternalAccelerations__FP5WATERP2XAf
// Address: 0x1ef3a8 - 0x1ef3c8

void entry_1ef3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef3c8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ef3cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ef3d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ef3d8; return;
}


// Function: HandleWaterMessage__FP5WATER5MSGIDPv
// Address: 0x1ef3d8 - 0x1ef430

void entry_1ef430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef430) {
        switch (ctx->pc) {
            case 0x1ef440: ctx->pc = 0; goto label_1ef440;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef430: 0x8e10000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1ef434: 0x5600fffc
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        ctx->pc = 0x1EF428; return;
    }
    // 0x1ef43c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_1ef440:
    // 0x1ef440: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ef444: 0xc076ee4
    SET_GPR_U32(ctx, 31, 0x1ef44c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    FreeSwXaList__FP2SWP2XA(rdram, ctx, runtime); return;
}


// Function: entry_1ef44c
// Address: 0x1ef44c - 0x1ef4bc

void entry_1ef44c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef44c) {
        switch (ctx->pc) {
            case 0x1ef454: ctx->pc = 0; goto label_1ef454;
            case 0x1ef478: ctx->pc = 0; goto label_1ef478;
            case 0x1ef498: ctx->pc = 0; goto label_1ef498;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef44c: 0x10000024
    WRITE32(ADD32(GPR_U32(ctx, 17), 1360), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1ef4e0(rdram, ctx, runtime); return;
    }
label_1ef454:
    // 0x1ef454: 0x12000010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1360));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1ef498;
    }
    // 0x1ef45c: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ef460: 0x54520005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
        goto label_1ef478;
    }
    // 0x1ef468: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1ef46c: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 17), 1360), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ef498;
    }
    // 0x1ef474: 0x0
    // NOP
label_1ef478:
    // 0x1ef478: 0x8c70000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x1ef47c: 0x12000006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 12));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1ef498;
    }
    // 0x1ef484: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ef488: 0x5452fffb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
        goto label_1ef478;
    }
    // 0x1ef490: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1ef494: 0xac62000c
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 2));
label_1ef498:
    // 0x1ef498: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    // 0x1ef49c: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ef4a0: 0x12000009
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_1ef4c8(rdram, ctx, runtime); return;
    }
    // 0x1ef4a8: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1ef4ac: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ef4b0: 0xae00000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 0));
    // 0x1ef4b4: 0xc06e954
    SET_GPR_U32(ctx, 31, 0x1ef4bc);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    RemoveSoXa__FP2SOP2XA(rdram, ctx, runtime); return;
}


// Function: entry_1ef4bc
// Address: 0x1ef4bc - 0x1ef4c8

void entry_1ef4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef4bc: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1ef4c0: 0xc076ee4
    SET_GPR_U32(ctx, 31, 0x1ef4c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FreeSwXaList__FP2SWP2XA(rdram, ctx, runtime); return;
}


// Function: entry_1ef4c8
// Address: 0x1ef4c8 - 0x1ef4e0

void entry_1ef4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef4c8: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1ef4cc: 0x2405000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1ef4d0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1ef4d4: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x1ef4d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ef4e0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ef4e0
// Address: 0x1ef4e0 - 0x1ef4f0

void entry_1ef4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef4e0: 0x12600004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EF4F4; return;
    }
    // 0x1ef4e8: 0xc07bd48
    SET_GPR_U32(ctx, 31, 0x1ef4f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateWaterMergeGroup__FP5WATER(rdram, ctx, runtime); return;
}


// Function: entry_1ef4f0
// Address: 0x1ef4f0 - 0x1ef500

void entry_1ef4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef4f0) {
        switch (ctx->pc) {
            case 0x1ef4f4: ctx->pc = 0; goto label_1ef4f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef4f0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1ef4f4:
    // 0x1ef4f4: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1ef4f8: 0xc049cde
    SET_GPR_U32(ctx, 31, 0x1ef500);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    HandleAloMessage__FP3ALO5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_1ef500
// Address: 0x1ef500 - 0x1ef520

void entry_1ef500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef500: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1ef504: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1ef508: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1ef50c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1ef510: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ef514: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ef518: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateWaterMergeGroup__FP5WATER
// Address: 0x1ef520 - 0x1ef550

void entry_1ef550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef550) {
        switch (ctx->pc) {
            case 0x1ef570: ctx->pc = 0; goto label_1ef570;
            case 0x1ef59c: ctx->pc = 0; goto label_1ef59c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef550: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1ef554: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ef558: 0xac510000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 17));
    // 0x1ef55c: 0xae030008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 3));
    // 0x1ef560: 0x8e260550
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x1ef564: 0x50c0000d
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_1ef59c;
    }
    // 0x1ef56c: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_1ef570:
    // 0x1ef570: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1ef574: 0x8cc50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x1ef578: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1ef57c: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1ef580: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1ef584: 0xac450000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 5));
    // 0x1ef588: 0xae030008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 3));
    // 0x1ef58c: 0x8cc6000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1ef590: 0x54c0fff7
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        goto label_1ef570;
    }
    // 0x1ef598: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_1ef59c:
    // 0x1ef59c: 0xc057e2c
    SET_GPR_U32(ctx, 31, 0x1ef5a4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddSwMergeGroup__FP2SWP3MRG(rdram, ctx, runtime); return;
}


// Function: entry_1ef5a4
// Address: 0x1ef5a4 - 0x1ef5b8

void entry_1ef5a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef5a4) {
        switch (ctx->pc) {
            case 0x1ef5a8: ctx->pc = 0; goto label_1ef5a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef5a4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1ef5a8:
    // 0x1ef5a8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ef5ac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ef5b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UGetWaterSubmerged__FP5WATERP2SOP6VECTORT2
// Address: 0x1ef5b8 - 0x1ef60c

void entry_1ef60c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef60c) {
        switch (ctx->pc) {
            case 0x1ef650: ctx->pc = 0; goto label_1ef650;
            case 0x1ef65c: ctx->pc = 0; goto label_1ef65c;
            case 0x1ef698: ctx->pc = 0; goto label_1ef698;
            case 0x1ef6ac: ctx->pc = 0; goto label_1ef6ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef60c: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1ef610: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1ef614: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1ef618: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ef61c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1ef620: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ef624: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1ef628: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1ef62c: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1ef630: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ef634: 0x4be309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1ef638: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ef63c: 0xfba30720
    WRITE128(ADD32(GPR_U32(ctx, 29), 1824), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1ef640: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ef644: 0xfba40720
    WRITE128(ADD32(GPR_U32(ctx, 29), 1824), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1ef648: 0x10000004
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ef65c;
    }
label_1ef650:
    // 0x1ef650: 0x7a020140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1ef654: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x1ef658: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
label_1ef65c:
    // 0x1ef65c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1ef660: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1ef664: 0x5603000c
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1064)); ctx->f[0] = *(float*)&val; }
        goto label_1ef698;
    }
    // 0x1ef66c: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1ef670: 0x3c01c296
    SET_GPR_U32(ctx, 1, ((uint32_t)49814 << 16));
    // 0x1ef674: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1ef678: 0x8e020690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1680)));
    // 0x1ef67c: 0x46010040
    ctx->f[1] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ef680: 0x1040000a
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1ef6ac;
    }
    // 0x1ef688: 0xc60006a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1704)); ctx->f[0] = *(float*)&val; }
    // 0x1ef68c: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x1ef690: 0x10000006
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ef6ac;
    }
label_1ef698:
    // 0x1ef698: 0xc6020148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 328)); ctx->f[2] = *(float*)&val; }
    // 0x1ef69c: 0xc7a10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    // 0x1ef6a0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1ef6a4: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1ef6a8: 0xe7a10008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
label_1ef6ac:
    // 0x1ef6ac: 0xc6020148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 328)); ctx->f[2] = *(float*)&val; }
    // 0x1ef6b0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1ef6b4: 0xc6010438
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1080)); ctx->f[1] = *(float*)&val; }
    // 0x1ef6b8: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1ef6bc: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1ef6c0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1ef6c4: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x1ef6c8: 0x8e4403f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1016)));
    // 0x1ef6cc: 0x24080010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1ef6d0: 0x27a90020
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1ef6d4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ef6d8: 0xc04f7f6
    SET_GPR_U32(ctx, 31, 0x1ef6e0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1ef6e0
// Address: 0x1ef6e0 - 0x1ef768

void entry_1ef6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef6e0) {
        switch (ctx->pc) {
            case 0x1ef6fc: ctx->pc = 0; goto label_1ef6fc;
            case 0x1ef708: ctx->pc = 0; goto label_1ef708;
            case 0x1ef714: ctx->pc = 0; goto label_1ef714;
            case 0x1ef730: ctx->pc = 0; goto label_1ef730;
            case 0x1ef73c: ctx->pc = 0; goto label_1ef73c;
            case 0x1ef74c: ctx->pc = 0; goto label_1ef74c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef6e0: 0x14400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1ef708;
    }
    // 0x1ef6e8: 0x12200004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1ef6fc;
    }
    // 0x1ef6f0: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1ef6f4: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ef6f8: 0x7e230000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 3));
label_1ef6fc:
    // 0x1ef6fc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1ef700: 0x10000012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1904)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ef74c;
    }
label_1ef708:
    // 0x1ef708: 0x12600002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1ef714;
    }
    // 0x1ef710: 0x7e620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 2));
label_1ef714:
    // 0x1ef714: 0x12200009
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1ef73c;
    }
    // 0x1ef71c: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
        goto label_1ef730;
    }
    // 0x1ef724: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ef728: 0x10000004
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1ef73c;
    }
label_1ef730:
    // 0x1ef730: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1ef734: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1ef738: 0x7e230000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), GPR_VEC(ctx, 3));
label_1ef73c:
    // 0x1ef73c: 0xc7a10064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[1] = *(float*)&val; }
    // 0x1ef740: 0xc7a00060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[0] = *(float*)&val; }
    // 0x1ef744: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1ef748: 0x7bbf0770
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1904)));
label_1ef74c:
    // 0x1ef74c: 0x7bb30760
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1888)));
    // 0x1ef750: 0x7bb20750
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1872)));
    // 0x1ef754: 0x7bb10740
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1856)));
    // 0x1ef758: 0x7bb00730
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1840)));
    // 0x1ef75c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1920));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ef764: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ef768; return;
}


// Function: UpdateWaterBounds__FP5WATER
// Address: 0x1ef768 - 0x1ef77c

void entry_1ef77c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef77c: 0x8e040278
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 632)));
    // 0x1ef780: 0x1080001d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EF7F8; return;
    }
    // 0x1ef788: 0x8c84000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x1ef78c: 0x5080001b
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
        ctx->pc = 0x1EF7FC; return;
    }
    // 0x1ef794: 0xc07cc50
    SET_GPR_U32(ctx, 31, 0x1ef79c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetWrBounds__FP2WRP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1ef79c
// Address: 0x1ef79c - 0x1ef808

void entry_1ef79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef79c) {
        switch (ctx->pc) {
            case 0x1ef7f8: ctx->pc = 0; goto label_1ef7f8;
            case 0x1ef7fc: ctx->pc = 0; goto label_1ef7fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef79c: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ef7a0: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1ef7a4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1ef7a8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ef7ac: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1ef7b0: 0xc60203d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 976)); ctx->f[2] = *(float*)&val; }
    // 0x1ef7b4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ef7b8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1ef7bc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1ef7c0: 0xc60003d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 980)); ctx->f[0] = *(float*)&val; }
    // 0x1ef7c4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ef7c8: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1ef7cc: 0xda020420
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1056)));
    // 0x1ef7d0: 0xda010430
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1072)));
    // 0x1ef7d4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1ef7d8: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1ef7dc: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1ef7e0: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1ef7e4: 0xfa020420
    WRITE128(ADD32(GPR_U32(ctx, 16), 1056), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1ef7e8: 0xfa010430
    WRITE128(ADD32(GPR_U32(ctx, 16), 1072), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1ef7ec: 0xe60003d4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 980), *(uint32_t*)&val); }
    // 0x1ef7f0: 0xe60203d0
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 976), *(uint32_t*)&val); }
    // 0x1ef7f4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1ef7f8:
    // 0x1ef7f8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1ef7fc:
    // 0x1ef7fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ef804: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ef808; return;
}


// Function: FInflictWaterZap__FP5WATERP2XPP3ZPR
// Address: 0x1ef808 - 0x1ef818

void entry_1ef818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef818: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ef81c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1ef820: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PzpdEnsureWater__FP5WATER4ENSK
// Address: 0x1ef828 - 0x1ef830

void FUN_001ef830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef830: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 1572), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitWaypoint__FP8WAYPOINT
// Address: 0x1ef838 - 0x1ef84c

void entry_1ef84c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef84c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1ef850: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ef854: 0xae0202e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 736), GPR_U32(ctx, 2));
    // 0x1ef858: 0xae0202d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 720), GPR_U32(ctx, 2));
    // 0x1ef85c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ef860: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostWaypointLoad__FP8WAYPOINT
// Address: 0x1ef868 - 0x1ef87c

void entry_1ef87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef87c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1ef880: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ef884: 0x24c65e10
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 24080));
    // 0x1ef888: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1ef890);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1ef890
// Address: 0x1ef890 - 0x1ef89c

void entry_1ef890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef890: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ef894: 0xc07be40
    SET_GPR_U32(ctx, 31, 0x1ef89c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetWaypointWps__FP8WAYPOINT3WPS(rdram, ctx, runtime); return;
}


// Function: entry_1ef89c
// Address: 0x1ef89c - 0x1ef8ac

void entry_1ef89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef89c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ef8a0: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1ef8a4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1ef8ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1ef8ac
// Address: 0x1ef8ac - 0x1ef8c0

void entry_1ef8ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef8ac: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ef8b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ef8b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1ef8bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1ef8c0; return;
}


// Function: SetWaypointRsmg__FP8WAYPOINTi3OIDN22
// Address: 0x1ef8c0 - 0x1ef8ec

void entry_1ef8ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef8ec: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1ef8f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateWaypoint__FP8WAYPOINTf
// Address: 0x1ef8f8 - 0x1ef900

void entry_1ef950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef950) {
        switch (ctx->pc) {
            case 0x1ef958: ctx->pc = 0; goto label_1ef958;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef950: 0x1000000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EF980; return;
    }
label_1ef958:
    // 0x1ef958: 0x54620009
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
        ctx->pc = 0x1EF980; return;
    }
    // 0x1ef960: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1ef964: 0x8e0502e4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 740)));
    // 0x1ef968: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1ef96c: 0x260602e8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 744));
    // 0x1ef970: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ef974: 0xc04fb2c
    SET_GPR_U32(ctx, 31, 0x1ef97c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TriggerRsmg__FP2SWiP4RSMGP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_1ef97c
// Address: 0x1ef97c - 0x1ef9b4

void entry_1ef97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef97c) {
        switch (ctx->pc) {
            case 0x1ef980: ctx->pc = 0; goto label_1ef980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef97c: 0x8e0202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
label_1ef980:
    // 0x1ef980: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1ef984: 0xae1102d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 720), GPR_U32(ctx, 17));
    // 0x1ef988: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1ef98c: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1ef990: 0x24050016
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 22));
    // 0x1ef994: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1ef998: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x1ef99c: 0xe60002d4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 724), *(uint32_t*)&val); }
    // 0x1ef9a0: 0xafb10008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 17));
    // 0x1ef9a4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1ef9a8: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x1ef9ac: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1ef9b4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1ef9b4
// Address: 0x1ef9b4 - 0x1ef9c8

void entry_1ef9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1ef9b4) {
        switch (ctx->pc) {
            case 0x1ef9b8: ctx->pc = 0; goto label_1ef9b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1ef9b4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1ef9b8:
    // 0x1ef9b8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1ef9bc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1ef9c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleWaypointMessage__FP8WAYPOINT5MSGIDPv
// Address: 0x1ef9c8 - 0x1ef9ec

void entry_1ef9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1ef9ec: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1ef9f0: 0x16020009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EFA18; return;
    }
    // 0x1ef9f8: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1ef9fc: 0x8e2202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 732)));
    // 0x1efa00: 0x14620006
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EFA1C; return;
    }
    // 0x1efa08: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1efa0c: 0xc07be40
    SET_GPR_U32(ctx, 31, 0x1efa14);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetWaypointWps__FP8WAYPOINT3WPS(rdram, ctx, runtime); return;
}


// Function: entry_1efa14
// Address: 0x1efa14 - 0x1efa30

void entry_1efa14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1efa14) {
        switch (ctx->pc) {
            case 0x1efa18: ctx->pc = 0; goto label_1efa18;
            case 0x1efa1c: ctx->pc = 0; goto label_1efa1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1efa14: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1efa18:
    // 0x1efa18: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1efa1c:
    // 0x1efa1c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1efa20: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1efa24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1efa2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1efa30; return;
}


// Function: PwpsgNew__Fv
// Address: 0x1efa30 - 0x1efa40

void entry_1efa40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1efa40: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1efa44: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1efa48: 0x246305c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1472));
    // 0x1efa4c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1efa50: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    // 0x1efa54: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1efa5c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1efa60; return;
}


// Function: AddWpsgWaypoint__FP4WPSGP8WAYPOINT
// Address: 0x1efa60 - 0x1efa88

void entry_1efb04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1efb04) {
        switch (ctx->pc) {
            case 0x1efb10: ctx->pc = 0; goto label_1efb10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1efb04: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1efb08: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x1efb0c: 0xae030004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 3));
label_1efb10:
    // 0x1efb10: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1efb14: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1efb18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateWpsgCallback__FP4WPSG5MSGIDPv
// Address: 0x1efb20 - 0x1efbe8

void entry_1efbe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1efbe8) {
        switch (ctx->pc) {
            case 0x1efbf8: ctx->pc = 0; goto label_1efbf8;
            case 0x1efc08: ctx->pc = 0; goto label_1efc08;
            case 0x1efc20: ctx->pc = 0; goto label_1efc20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1efbe8: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1efbec: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1efbf0: 0x5440fff9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1EFBD8; return;
    }
label_1efbf8:
    // 0x1efbf8: 0x8e43002c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 44)));
    // 0x1efbfc: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1efc00: 0x1000001d
    WRITE32(ADD32(GPR_U32(ctx, 3), 384), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EFC78; return;
    }
label_1efc08:
    // 0x1efc08: 0x1840001b
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1EFC78; return;
    }
    // 0x1efc10: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1efc14: 0x24140002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1efc18: 0x24531858
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1efc1c: 0x26500008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 8));
label_1efc20:
    // 0x1efc20: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1efc24: 0x8c8202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 720)));
    // 0x1efc28: 0x5454000f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x1EFC68; return;
    }
    // 0x1efc30: 0x8c8202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 732)));
    // 0x1efc34: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x1EFC68; return;
    }
    // 0x1efc3c: 0xc6600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1efc40: 0xc48102d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 724)); ctx->f[1] = *(float*)&val; }
    // 0x1efc44: 0xc48202d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 728)); ctx->f[2] = *(float*)&val; }
    // 0x1efc48: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1efc4c: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1efc50: 0x0
    // NOP
    // 0x1efc54: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x1EFC68; return;
    }
    // 0x1efc5c: 0xc07be40
    SET_GPR_U32(ctx, 31, 0x1efc64);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetWaypointWps__FP8WAYPOINT3WPS(rdram, ctx, runtime); return;
}


// Function: entry_1efc64
// Address: 0x1efc64 - 0x1efc98

void entry_1efc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1efc64) {
        switch (ctx->pc) {
            case 0x1efc68: ctx->pc = 0; goto label_1efc68;
            case 0x1efc78: ctx->pc = 0; goto label_1efc78;
            case 0x1efc7c: ctx->pc = 0; goto label_1efc7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1efc64: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_1efc68:
    // 0x1efc68: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1efc6c: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1efc70: 0x1440ffeb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EFC20; return;
    }
label_1efc78:
    // 0x1efc78: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1efc7c:
    // 0x1efc7c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1efc80: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1efc84: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1efc88: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1efc8c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1efc90: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnsureWpsgCallback__FP4WPSG
// Address: 0x1efc98 - 0x1efcd4

void entry_1efcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1efcd4) {
        switch (ctx->pc) {
            case 0x1efcd8: ctx->pc = 0; goto label_1efcd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1efcd4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1efcd8:
    // 0x1efcd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_001EFCE0
// Address: 0x1efce0 - 0x1efce8

void entry_1efd00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1efd00: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1efd04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1efd0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1efd10; return;
}


// Function: UpdateWipe__FP4WIPEP3JOY
// Address: 0x1efd10 - 0x1efd80

void entry_1efd80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1efd80) {
        switch (ctx->pc) {
            case 0x1efd90: ctx->pc = 0; goto label_1efd90;
            case 0x1efdb8: ctx->pc = 0; goto label_1efdb8;
            case 0x1efddc: ctx->pc = 0; goto label_1efddc;
            case 0x1efdfc: ctx->pc = 0; goto label_1efdfc;
            case 0x1efe0c: ctx->pc = 0; goto label_1efe0c;
            case 0x1efe24: ctx->pc = 0; goto label_1efe24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1efd80: 0x14400053
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EFED0; return;
    }
    // 0x1efd88: 0x1000004e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EFEC4; return;
    }
label_1efd90:
    // 0x1efd90: 0x8e030024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x1efd94: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1efd98: 0x1062004a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1EFEC4; return;
    }
    // 0x1efda0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1efda4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1efda8: 0x14710003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 17)) {
        goto label_1efdb8;
    }
    // 0x1efdb0: 0x3c013fc0
    SET_GPR_U32(ctx, 1, ((uint32_t)16320 << 16));
    // 0x1efdb4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
label_1efdb8:
    // 0x1efdb8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1efdbc: 0x0
    // NOP
    // 0x1efdc0: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[0] = ctx->f[1] / ctx->f[0];
        goto label_1efddc;
    }
    // 0x1efdc8: 0x8e040020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1efdcc: 0x24110002
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1efdd0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1efdd4: 0x10000013
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 4), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1efe24;
    }
label_1efddc:
    // 0x1efddc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1efde0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1efde4: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1efde8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1efdec: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1efdfc;
    }
    // 0x1efdf4: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1efe0c;
    }
label_1efdfc:
    // 0x1efdfc: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1efe00: 0x0
    // NOP
    // 0x1efe04: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[2]);
        goto label_1efe0c;
    }
label_1efe0c:
    // 0x1efe0c: 0x8e040020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x1efe10: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1efe14: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1efe18: 0x420c3
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 4), 3));
    // 0x1efe1c: 0xe600000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x1efe20: 0x46006301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
label_1efe24:
    // 0x1efe24: 0x38840001
    SET_GPR_U32(ctx, 4, XOR32(GPR_U32(ctx, 4), 1));
    // 0x1efe28: 0xc070000
    SET_GPR_U32(ctx, 31, 0x1efe30);
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 1));
    HandleWipeHandleWipeVolumes__FifVolumes(rdram, ctx, runtime); return;
}


// Function: entry_1efe30
// Address: 0x1efe30 - 0x1efecc

void entry_1efe30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1efe30) {
        switch (ctx->pc) {
            case 0x1efe38: ctx->pc = 0; goto label_1efe38;
            case 0x1efe58: ctx->pc = 0; goto label_1efe58;
            case 0x1efe8c: ctx->pc = 0; goto label_1efe8c;
            case 0x1efea0: ctx->pc = 0; goto label_1efea0;
            case 0x1efec0: ctx->pc = 0; goto label_1efec0;
            case 0x1efec4: ctx->pc = 0; goto label_1efec4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1efe30: 0x10000024
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1efec4;
    }
label_1efe38:
    // 0x1efe38: 0x50430022
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        goto label_1efec4;
    }
    // 0x1efe40: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1efe44: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1efe48: 0x14440003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_1efe58;
    }
    // 0x1efe50: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1efe54: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
label_1efe58:
    // 0x1efe58: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1efe5c: 0x0
    // NOP
    // 0x1efe60: 0x4502000a
    if (!(ctx->fcr31 & 0x800000)) {
        if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
        goto label_1efe8c;
    }
    // 0x1efe68: 0x54510015
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_1efec0;
    }
    // 0x1efe70: 0xae000024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 0));
    // 0x1efe74: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1efe78: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1efe7c: 0xc4c10010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 16)); ctx->f[1] = *(float*)&val; }
    // 0x1efe80: 0xe600000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x1efe84: 0x1000000e
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1efec0;
    }
label_1efe8c:
    // 0x1efe8c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1efe90: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1efe94: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1efe98: 0x10000009
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1efec0;
    }
label_1efea0:
    // 0x1efea0: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1efea4: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 3));
        goto label_1efec0;
    }
    // 0x1efeac: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1efeb0: 0x8c435af0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 23280)));
    // 0x1efeb4: 0x14600003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1efec4;
    }
    // 0x1efebc: 0x24110003
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 3));
label_1efec0:
    // 0x1efec0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1efec4:
    // 0x1efec4: 0xc07c088
    SET_GPR_U32(ctx, 31, 0x1efecc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetWipeWipes__FP4WIPE5WIPES(rdram, ctx, runtime); return;
}


// Function: entry_1efecc
// Address: 0x1efecc - 0x1efee0

void entry_1efecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1efecc) {
        switch (ctx->pc) {
            case 0x1efed0: ctx->pc = 0; goto label_1efed0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1efecc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1efed0:
    // 0x1efed0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1efed4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1efed8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawWipe__FP4WIPE
// Address: 0x1efee0 - 0x1eff44

void entry_1eff44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eff44) {
        switch (ctx->pc) {
            case 0x1eff4c: ctx->pc = 0; goto label_1eff4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eff44: 0x10000014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1EFF98; return;
    }
label_1eff4c:
    // 0x1eff4c: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x1eff50: 0x3c01437f
    SET_GPR_U32(ctx, 1, ((uint32_t)17279 << 16));
    // 0x1eff54: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1eff58: 0x25082280
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 8832));
    // 0x1eff5c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1eff60: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eff64: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1eff68: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x1eff6c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1eff70: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x1eff74: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x1eff78: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
    // 0x1eff7c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eff80: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1eff84: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1eff88: 0x44070800
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[1]);
    // 0x1eff8c: 0xc067768
    SET_GPR_U32(ctx, 31, 0x1eff94);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    FillScreenRect__FiiiiffffP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1eff94
// Address: 0x1eff94 - 0x1effa0

void entry_1eff94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1eff94) {
        switch (ctx->pc) {
            case 0x1eff98: ctx->pc = 0; goto label_1eff98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1eff94: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1eff98:
    // 0x1eff98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ActivateWipe__FP4WIPEP5TRANS5WIPEK
// Address: 0x1effa0 - 0x1efff4

void entry_1efff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1efff4) {
        switch (ctx->pc) {
            case 0x1efff8: ctx->pc = 0; goto label_1efff8;
            case 0x1f0018: ctx->pc = 0; goto label_1f0018;
            case 0x1f0028: ctx->pc = 0; goto label_1f0028;
            case 0x1f0044: ctx->pc = 0; goto label_1f0044;
            case 0x1f004c: ctx->pc = 0; goto label_1f004c;
            case 0x1f0054: ctx->pc = 0; goto label_1f0054;
            case 0x1f005c: ctx->pc = 0; goto label_1f005c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1efff4: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
label_1efff8:
    // 0x1efff8: 0x50c00014
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
        goto label_1f004c;
    }
    // 0x1f0000: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1f0004: 0x24425b04
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23300));
    // 0x1f0008: 0x14c20003
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        goto label_1f0018;
    }
    // 0x1f0010: 0x1000000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0044;
    }
label_1f0018:
    // 0x1f0018: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
        goto label_1f0028;
    }
    // 0x1f0020: 0x10000008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f0044;
    }
label_1f0028:
    // 0x1f0028: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1f002c: 0x8cc50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x1f0030: 0x8cc20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x1f0034: 0x641826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1f0038: 0x451026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1f003c: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1f0040: 0x2c620001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 1));
label_1f0044:
    // 0x1f0044: 0x10400003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1f0054;
    }
label_1f004c:
    // 0x1f004c: 0x10000003
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1f005c;
    }
label_1f0054:
    // 0x1f0054: 0x2403fff7
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967287));
    // 0x1f0058: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_1f005c:
    // 0x1f005c: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x1f0060: 0x6a020007
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1f0064: 0x6e020000
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x1f0068: 0x6a03000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1f006c: 0x6e030008
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x1f0070: 0x8e040010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1f0074: 0xb2220017
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f0078: 0xb6220010
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f007c: 0xb223001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f0080: 0xb6230018
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1f0084: 0xae240020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 4));
    // 0x1f0088: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1f008c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1f0090: 0x8e625710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 22288)));
    // 0x1f0094: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1f0098: 0xae320024
    WRITE32(ADD32(GPR_U32(ctx, 17), 36), GPR_U32(ctx, 18));
    // 0x1f009c: 0xc07c088
    SET_GPR_U32(ctx, 31, 0x1f00a4);
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    SetWipeWipes__FP4WIPE5WIPES(rdram, ctx, runtime); return;
}


// Function: entry_1f00a4
// Address: 0x1f00a4 - 0x1f00c0

void entry_1e0004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0004 inside entry_1dfffc (0x1dfffc - 0x1e000c)
    ctx->pc = 0x1e0004;
    entry_1dfffc(rdram, ctx, runtime);
}

void entry_1e0010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0010 inside entry_1e000c (0x1e000c - 0x1e0060)
    ctx->pc = 0x1e0010;
    entry_1e000c(rdram, ctx, runtime);
}

void entry_1e0038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0038 inside entry_1e000c (0x1e000c - 0x1e0060)
    ctx->pc = 0x1e0038;
    entry_1e000c(rdram, ctx, runtime);
}

void entry_1e0044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0044 inside entry_1e000c (0x1e000c - 0x1e0060)
    ctx->pc = 0x1e0044;
    entry_1e000c(rdram, ctx, runtime);
}

void entry_1e008c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e008c inside entry_1e0080 (0x1e0080 - 0x1e00b0)
    ctx->pc = 0x1e008c;
    entry_1e0080(rdram, ctx, runtime);
}

void entry_1e0090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0090 inside entry_1e0080 (0x1e0080 - 0x1e00b0)
    ctx->pc = 0x1e0090;
    entry_1e0080(rdram, ctx, runtime);
}

void entry_1e00f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e00f4 inside entry_1e00cc (0x1e00cc - 0x1e0118)
    ctx->pc = 0x1e00f4;
    entry_1e00cc(rdram, ctx, runtime);
}

void entry_1e0164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0164 inside entry_1e015c (0x1e015c - 0x1e0170)
    ctx->pc = 0x1e0164;
    entry_1e015c(rdram, ctx, runtime);
}

void entry_1e0178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0178 inside entry_1e0170 (0x1e0170 - 0x1e01a8)
    ctx->pc = 0x1e0178;
    entry_1e0170(rdram, ctx, runtime);
}

void entry_1e01b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e01b0 inside entry_1e01a8 (0x1e01a8 - 0x1e01d0)
    ctx->pc = 0x1e01b0;
    entry_1e01a8(rdram, ctx, runtime);
}

void entry_1e01d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e01d8 inside entry_1e01d0 (0x1e01d0 - 0x1e01f4)
    ctx->pc = 0x1e01d8;
    entry_1e01d0(rdram, ctx, runtime);
}

void entry_1e0228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0228 inside entry_1e0220 (0x1e0220 - 0x1e0234)
    ctx->pc = 0x1e0228;
    entry_1e0220(rdram, ctx, runtime);
}

void entry_1e0238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0238 inside entry_1e0234 (0x1e0234 - 0x1e0294)
    ctx->pc = 0x1e0238;
    entry_1e0234(rdram, ctx, runtime);
}

void entry_1e027c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e027c inside entry_1e0234 (0x1e0234 - 0x1e0294)
    ctx->pc = 0x1e027c;
    entry_1e0234(rdram, ctx, runtime);
}

void entry_1e029c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e029c inside entry_1e0294 (0x1e0294 - 0x1e02ac)
    ctx->pc = 0x1e029c;
    entry_1e0294(rdram, ctx, runtime);
}

void entry_1e02b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e02b0 inside entry_1e02ac (0x1e02ac - 0x1e02c8)
    ctx->pc = 0x1e02b0;
    entry_1e02ac(rdram, ctx, runtime);
}

void entry_1e02b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e02b4 inside entry_1e02ac (0x1e02ac - 0x1e02c8)
    ctx->pc = 0x1e02b4;
    entry_1e02ac(rdram, ctx, runtime);
}

void entry_1e0314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0314 inside gui_set_widget_modeQMARK (0x1e02c8 - 0x1e0330)
    ctx->pc = 0x1e0314;
    gui_set_widget_modeQMARK(rdram, ctx, runtime);
}

void entry_1e0338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0338 inside entry_1e0330 (0x1e0330 - 0x1e0344)
    ctx->pc = 0x1e0338;
    entry_1e0330(rdram, ctx, runtime);
}

void entry_1e0368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0368 inside entry_1e0364 (0x1e0364 - 0x1e03cc)
    ctx->pc = 0x1e0368;
    entry_1e0364(rdram, ctx, runtime);
}

void entry_1e0380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0380 inside entry_1e0364 (0x1e0364 - 0x1e03cc)
    ctx->pc = 0x1e0380;
    entry_1e0364(rdram, ctx, runtime);
}

void entry_1e04a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e04a0 inside entry_1e0498 (0x1e0498 - 0x1e04dc)
    ctx->pc = 0x1e04a0;
    entry_1e0498(rdram, ctx, runtime);
}

void entry_1e04bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e04bc inside entry_1e0498 (0x1e0498 - 0x1e04dc)
    ctx->pc = 0x1e04bc;
    entry_1e0498(rdram, ctx, runtime);
}

void entry_1e0504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0504 inside entry_1e04fc (0x1e04fc - 0x1e0514)
    ctx->pc = 0x1e0504;
    entry_1e04fc(rdram, ctx, runtime);
}

void entry_1e0530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0530 inside entry_1e052c (0x1e052c - 0x1e053c)
    ctx->pc = 0x1e0530;
    entry_1e052c(rdram, ctx, runtime);
}

void entry_1e0544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0544 inside entry_1e053c (0x1e053c - 0x1e0598)
    ctx->pc = 0x1e0544;
    entry_1e053c(rdram, ctx, runtime);
}

void entry_1e05a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e05a0 inside entry_1e0598 (0x1e0598 - 0x1e05d0)
    ctx->pc = 0x1e05a0;
    entry_1e0598(rdram, ctx, runtime);
}

void entry_1e05a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e05a8 inside entry_1e0598 (0x1e0598 - 0x1e05d0)
    ctx->pc = 0x1e05a8;
    entry_1e0598(rdram, ctx, runtime);
}

void entry_1e05f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e05f8 inside entry_1e05f0 (0x1e05f0 - 0x1e0624)
    ctx->pc = 0x1e05f8;
    entry_1e05f0(rdram, ctx, runtime);
}

void entry_1e0610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0610 inside entry_1e05f0 (0x1e05f0 - 0x1e0624)
    ctx->pc = 0x1e0610;
    entry_1e05f0(rdram, ctx, runtime);
}

void entry_1e0614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0614 inside entry_1e05f0 (0x1e05f0 - 0x1e0624)
    ctx->pc = 0x1e0614;
    entry_1e05f0(rdram, ctx, runtime);
}

void entry_1e0628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0628 inside entry_1e0624 (0x1e0624 - 0x1e0648)
    ctx->pc = 0x1e0628;
    entry_1e0624(rdram, ctx, runtime);
}

void entry_1e0654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0654 inside entry_1e0648 (0x1e0648 - 0x1e0678)
    ctx->pc = 0x1e0654;
    entry_1e0648(rdram, ctx, runtime);
}

void entry_1e07d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e07d0 inside entry_1e07b8 (0x1e07b8 - 0x1e07e0)
    ctx->pc = 0x1e07d0;
    entry_1e07b8(rdram, ctx, runtime);
}

void entry_1e08b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e08b8 inside entry_1e0878 (0x1e0878 - 0x1e08ec)
    ctx->pc = 0x1e08b8;
    entry_1e0878(rdram, ctx, runtime);
}

void entry_1e0924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0924 inside CchParsePchzInt__FPcPi (0x1e08f8 - 0x1e0978)
    ctx->pc = 0x1e0924;
    CchParsePchzInt__FPcPi(rdram, ctx, runtime);
}

void entry_1e0938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0938 inside CchParsePchzInt__FPcPi (0x1e08f8 - 0x1e0978)
    ctx->pc = 0x1e0938;
    CchParsePchzInt__FPcPi(rdram, ctx, runtime);
}

void entry_1e0964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0964 inside CchParsePchzInt__FPcPi (0x1e08f8 - 0x1e0978)
    ctx->pc = 0x1e0964;
    CchParsePchzInt__FPcPi(rdram, ctx, runtime);
}

void entry_1e09c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e09c8 inside entry_1e09b4 (0x1e09b4 - 0x1e0afc)
    ctx->pc = 0x1e09c8;
    entry_1e09b4(rdram, ctx, runtime);
}

void entry_1e0a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0a1c inside entry_1e09b4 (0x1e09b4 - 0x1e0afc)
    ctx->pc = 0x1e0a1c;
    entry_1e09b4(rdram, ctx, runtime);
}

void entry_1e0aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0aa8 inside entry_1e09b4 (0x1e09b4 - 0x1e0afc)
    ctx->pc = 0x1e0aa8;
    entry_1e09b4(rdram, ctx, runtime);
}

void entry_1e0ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0ae0 inside entry_1e09b4 (0x1e09b4 - 0x1e0afc)
    ctx->pc = 0x1e0ae0;
    entry_1e09b4(rdram, ctx, runtime);
}

void entry_1e0aec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0aec inside entry_1e09b4 (0x1e09b4 - 0x1e0afc)
    ctx->pc = 0x1e0aec;
    entry_1e09b4(rdram, ctx, runtime);
}

void entry_1e0af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0af4 inside entry_1e09b4 (0x1e09b4 - 0x1e0afc)
    ctx->pc = 0x1e0af4;
    entry_1e09b4(rdram, ctx, runtime);
}

void entry_1e0b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0b00 inside entry_1e0afc (0x1e0afc - 0x1e0b5c)
    ctx->pc = 0x1e0b00;
    entry_1e0afc(rdram, ctx, runtime);
}

void entry_1e0b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0b4c inside entry_1e0afc (0x1e0afc - 0x1e0b5c)
    ctx->pc = 0x1e0b4c;
    entry_1e0afc(rdram, ctx, runtime);
}

void entry_1e0b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0b54 inside entry_1e0afc (0x1e0afc - 0x1e0b5c)
    ctx->pc = 0x1e0b54;
    entry_1e0afc(rdram, ctx, runtime);
}

void entry_1e0b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0b60 inside entry_1e0b5c (0x1e0b5c - 0x1e0cd0)
    ctx->pc = 0x1e0b60;
    entry_1e0b5c(rdram, ctx, runtime);
}

void entry_1e0bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0bd8 inside entry_1e0b5c (0x1e0b5c - 0x1e0cd0)
    ctx->pc = 0x1e0bd8;
    entry_1e0b5c(rdram, ctx, runtime);
}

void entry_1e0c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0c40 inside entry_1e0b5c (0x1e0b5c - 0x1e0cd0)
    ctx->pc = 0x1e0c40;
    entry_1e0b5c(rdram, ctx, runtime);
}

void entry_1e0c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0c88 inside entry_1e0b5c (0x1e0b5c - 0x1e0cd0)
    ctx->pc = 0x1e0c88;
    entry_1e0b5c(rdram, ctx, runtime);
}

void entry_1e0c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0c90 inside entry_1e0b5c (0x1e0b5c - 0x1e0cd0)
    ctx->pc = 0x1e0c90;
    entry_1e0b5c(rdram, ctx, runtime);
}

void entry_1e0cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0cac inside entry_1e0b5c (0x1e0b5c - 0x1e0cd0)
    ctx->pc = 0x1e0cac;
    entry_1e0b5c(rdram, ctx, runtime);
}

void entry_1e0d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0d08 inside WriteTftPchz__FP3TFTP5OSTRMPc (0x1e0cd0 - 0x1e0d14)
    ctx->pc = 0x1e0d08;
    WriteTftPchz__FP3TFTP5OSTRMPc(rdram, ctx, runtime);
}

void entry_1e0d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0d38 inside entry_1e0d14 (0x1e0d14 - 0x1e0da0)
    ctx->pc = 0x1e0d38;
    entry_1e0d14(rdram, ctx, runtime);
}

void entry_1e0d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0d3c inside entry_1e0d14 (0x1e0d14 - 0x1e0da0)
    ctx->pc = 0x1e0d3c;
    entry_1e0d14(rdram, ctx, runtime);
}

void entry_1e0d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0d40 inside entry_1e0d14 (0x1e0d14 - 0x1e0da0)
    ctx->pc = 0x1e0d40;
    entry_1e0d14(rdram, ctx, runtime);
}

void entry_1e0d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0d70 inside entry_1e0d14 (0x1e0d14 - 0x1e0da0)
    ctx->pc = 0x1e0d70;
    entry_1e0d14(rdram, ctx, runtime);
}

void entry_1e0d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0d74 inside entry_1e0d14 (0x1e0d14 - 0x1e0da0)
    ctx->pc = 0x1e0d74;
    entry_1e0d14(rdram, ctx, runtime);
}

void entry_1e0d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0d88 inside entry_1e0d14 (0x1e0d14 - 0x1e0da0)
    ctx->pc = 0x1e0d88;
    entry_1e0d14(rdram, ctx, runtime);
}

void entry_1e0da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0da8 inside entry_1e0da0 (0x1e0da0 - 0x1e0dbc)
    ctx->pc = 0x1e0da8;
    entry_1e0da0(rdram, ctx, runtime);
}

void entry_1e0dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0dd0 inside entry_1e0dbc (0x1e0dbc - 0x1e0de8)
    ctx->pc = 0x1e0dd0;
    entry_1e0dbc(rdram, ctx, runtime);
}

void entry_1e0df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0df0 inside entry_1e0de8 (0x1e0de8 - 0x1e0e18)
    ctx->pc = 0x1e0df0;
    entry_1e0de8(rdram, ctx, runtime);
}

void entry_1e0e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0e44 inside FNegTftUl__FP3TFTP2UL (0x1e0e18 - 0x1e0ef8)
    ctx->pc = 0x1e0e44;
    FNegTftUl__FP3TFTP2UL(rdram, ctx, runtime);
}

void entry_1e0e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0e4c inside FNegTftUl__FP3TFTP2UL (0x1e0e18 - 0x1e0ef8)
    ctx->pc = 0x1e0e4c;
    FNegTftUl__FP3TFTP2UL(rdram, ctx, runtime);
}

void entry_1e0e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0e50 inside FNegTftUl__FP3TFTP2UL (0x1e0e18 - 0x1e0ef8)
    ctx->pc = 0x1e0e50;
    FNegTftUl__FP3TFTP2UL(rdram, ctx, runtime);
}

void entry_1e0e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0e64 inside FNegTftUl__FP3TFTP2UL (0x1e0e18 - 0x1e0ef8)
    ctx->pc = 0x1e0e64;
    FNegTftUl__FP3TFTP2UL(rdram, ctx, runtime);
}

void entry_1e0e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0e8c inside FNegTftUl__FP3TFTP2UL (0x1e0e18 - 0x1e0ef8)
    ctx->pc = 0x1e0e8c;
    FNegTftUl__FP3TFTP2UL(rdram, ctx, runtime);
}

void entry_1e0e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0e9c inside FNegTftUl__FP3TFTP2UL (0x1e0e18 - 0x1e0ef8)
    ctx->pc = 0x1e0e9c;
    FNegTftUl__FP3TFTP2UL(rdram, ctx, runtime);
}

void entry_1e0eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0eb8 inside FNegTftUl__FP3TFTP2UL (0x1e0e18 - 0x1e0ef8)
    ctx->pc = 0x1e0eb8;
    FNegTftUl__FP3TFTP2UL(rdram, ctx, runtime);
}

void entry_1e0ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0ed4 inside FNegTftUl__FP3TFTP2UL (0x1e0e18 - 0x1e0ef8)
    ctx->pc = 0x1e0ed4;
    FNegTftUl__FP3TFTP2UL(rdram, ctx, runtime);
}

void entry_1e0eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0eec inside FNegTftUl__FP3TFTP2UL (0x1e0e18 - 0x1e0ef8)
    ctx->pc = 0x1e0eec;
    FNegTftUl__FP3TFTP2UL(rdram, ctx, runtime);
}

void entry_1e0ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0ef0 inside FNegTftUl__FP3TFTP2UL (0x1e0e18 - 0x1e0ef8)
    ctx->pc = 0x1e0ef0;
    FNegTftUl__FP3TFTP2UL(rdram, ctx, runtime);
}

void entry_1e0f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0f4c inside UnRadixFromChConversion__Fc (0x1e0ef8 - 0x1e0f58)
    ctx->pc = 0x1e0f4c;
    UnRadixFromChConversion__Fc(rdram, ctx, runtime);
}

void entry_1e0fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0fa0 inside CchAchFromUl__FPciUlUi (0x1e0f58 - 0x1e0fa8)
    ctx->pc = 0x1e0fa0;
    CchAchFromUl__FPciUlUi(rdram, ctx, runtime);
}

void entry_1e0fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e0fe0 inside entry_1e0fcc (0x1e0fcc - 0x1e1000)
    ctx->pc = 0x1e0fe0;
    entry_1e0fcc(rdram, ctx, runtime);
}

void entry_1e1070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1070 inside WriteTftUl__FP3TFTP5OSTRMUl (0x1e1028 - 0x1e10a8)
    ctx->pc = 0x1e1070;
    WriteTftUl__FP3TFTP5OSTRMUl(rdram, ctx, runtime);
}

void entry_1e1078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1078 inside WriteTftUl__FP3TFTP5OSTRMUl (0x1e1028 - 0x1e10a8)
    ctx->pc = 0x1e1078;
    WriteTftUl__FP3TFTP5OSTRMUl(rdram, ctx, runtime);
}

void entry_1e109c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e109c inside WriteTftUl__FP3TFTP5OSTRMUl (0x1e1028 - 0x1e10a8)
    ctx->pc = 0x1e109c;
    WriteTftUl__FP3TFTP5OSTRMUl(rdram, ctx, runtime);
}

void entry_1e10a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e10a0 inside WriteTftUl__FP3TFTP5OSTRMUl (0x1e1028 - 0x1e10a8)
    ctx->pc = 0x1e10a0;
    WriteTftUl__FP3TFTP5OSTRMUl(rdram, ctx, runtime);
}

void entry_1e10f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e10f4 inside entry_1e10a8 (0x1e10a8 - 0x1e112c)
    ctx->pc = 0x1e10f4;
    entry_1e10a8(rdram, ctx, runtime);
}

void entry_1e1108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1108 inside entry_1e10a8 (0x1e10a8 - 0x1e112c)
    ctx->pc = 0x1e1108;
    entry_1e10a8(rdram, ctx, runtime);
}

void entry_1e1118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1118 inside entry_1e10a8 (0x1e10a8 - 0x1e112c)
    ctx->pc = 0x1e1118;
    entry_1e10a8(rdram, ctx, runtime);
}

void entry_1e111c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e111c inside entry_1e10a8 (0x1e10a8 - 0x1e112c)
    ctx->pc = 0x1e111c;
    entry_1e10a8(rdram, ctx, runtime);
}

void entry_1e1184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1184 inside entry_1e112c (0x1e112c - 0x1e1198)
    ctx->pc = 0x1e1184;
    entry_1e112c(rdram, ctx, runtime);
}

void entry_1e1190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1190 inside entry_1e112c (0x1e112c - 0x1e1198)
    ctx->pc = 0x1e1190;
    entry_1e112c(rdram, ctx, runtime);
}

void entry_1e11d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e11d0 inside entry_1e11bc (0x1e11bc - 0x1e11e8)
    ctx->pc = 0x1e11d0;
    entry_1e11bc(rdram, ctx, runtime);
}

void entry_1e1220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1220 inside entry_1e11f0 (0x1e11f0 - 0x1e1268)
    ctx->pc = 0x1e1220;
    entry_1e11f0(rdram, ctx, runtime);
}

void entry_1e1238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1238 inside entry_1e11f0 (0x1e11f0 - 0x1e1268)
    ctx->pc = 0x1e1238;
    entry_1e11f0(rdram, ctx, runtime);
}

void entry_1e1250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1250 inside entry_1e11f0 (0x1e11f0 - 0x1e1268)
    ctx->pc = 0x1e1250;
    entry_1e11f0(rdram, ctx, runtime);
}

void entry_1e1270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1270 inside entry_1e1268 (0x1e1268 - 0x1e1284)
    ctx->pc = 0x1e1270;
    entry_1e1268(rdram, ctx, runtime);
}

void entry_1e1298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1298 inside entry_1e1284 (0x1e1284 - 0x1e12b0)
    ctx->pc = 0x1e1298;
    entry_1e1284(rdram, ctx, runtime);
}

void entry_1e12b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e12b8 inside entry_1e12b0 (0x1e12b0 - 0x1e12cc)
    ctx->pc = 0x1e12b8;
    entry_1e12b0(rdram, ctx, runtime);
}

void entry_1e12e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e12e0 inside entry_1e12cc (0x1e12cc - 0x1e12f8)
    ctx->pc = 0x1e12e0;
    entry_1e12cc(rdram, ctx, runtime);
}

void entry_1e1300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1300 inside entry_1e12f8 (0x1e12f8 - 0x1e1330)
    ctx->pc = 0x1e1300;
    entry_1e12f8(rdram, ctx, runtime);
}

void entry_1e13b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e13b4 inside entry_1e13ac (0x1e13ac - 0x1e13d0)
    ctx->pc = 0x1e13b4;
    entry_1e13ac(rdram, ctx, runtime);
}

void entry_1e13b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e13b8 inside entry_1e13ac (0x1e13ac - 0x1e13d0)
    ctx->pc = 0x1e13b8;
    entry_1e13ac(rdram, ctx, runtime);
}

void entry_1e13f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e13f8 inside ChDigitFromG__Fdii (0x1e13d0 - 0x1e1418)
    ctx->pc = 0x1e13f8;
    ChDigitFromG__Fdii(rdram, ctx, runtime);
}

void entry_1e1400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1400 inside ChDigitFromG__Fdii (0x1e13d0 - 0x1e1418)
    ctx->pc = 0x1e1400;
    ChDigitFromG__Fdii(rdram, ctx, runtime);
}

void entry_1e14fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e14fc inside CchAchFromDouble__FPciP3TFTd (0x1e1498 - 0x1e150c)
    ctx->pc = 0x1e14fc;
    CchAchFromDouble__FPciP3TFTd(rdram, ctx, runtime);
}

void entry_1e1504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1504 inside CchAchFromDouble__FPciP3TFTd (0x1e1498 - 0x1e150c)
    ctx->pc = 0x1e1504;
    CchAchFromDouble__FPciP3TFTd(rdram, ctx, runtime);
}

void entry_1e151c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e151c inside entry_1e1514 (0x1e1514 - 0x1e1528)
    ctx->pc = 0x1e151c;
    entry_1e1514(rdram, ctx, runtime);
}

void entry_1e155c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e155c inside entry_1e1528 (0x1e1528 - 0x1e1590)
    ctx->pc = 0x1e155c;
    entry_1e1528(rdram, ctx, runtime);
}

void entry_1e1568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1568 inside entry_1e1528 (0x1e1528 - 0x1e1590)
    ctx->pc = 0x1e1568;
    entry_1e1528(rdram, ctx, runtime);
}

void entry_1e156c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e156c inside entry_1e1528 (0x1e1528 - 0x1e1590)
    ctx->pc = 0x1e156c;
    entry_1e1528(rdram, ctx, runtime);
}

void entry_1e15e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e15e4 inside entry_1e15cc (0x1e15cc - 0x1e161c)
    ctx->pc = 0x1e15e4;
    entry_1e15cc(rdram, ctx, runtime);
}

void entry_1e15f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e15f4 inside entry_1e15cc (0x1e15cc - 0x1e161c)
    ctx->pc = 0x1e15f4;
    entry_1e15cc(rdram, ctx, runtime);
}

void entry_1e15fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e15fc inside entry_1e15cc (0x1e15cc - 0x1e161c)
    ctx->pc = 0x1e15fc;
    entry_1e15cc(rdram, ctx, runtime);
}

void entry_1e1608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1608 inside entry_1e15cc (0x1e15cc - 0x1e161c)
    ctx->pc = 0x1e1608;
    entry_1e15cc(rdram, ctx, runtime);
}

void entry_1e1630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1630 inside entry_1e161c (0x1e161c - 0x1e166c)
    ctx->pc = 0x1e1630;
    entry_1e161c(rdram, ctx, runtime);
}

void entry_1e1658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1658 inside entry_1e161c (0x1e161c - 0x1e166c)
    ctx->pc = 0x1e1658;
    entry_1e161c(rdram, ctx, runtime);
}

void entry_1e1680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1680 inside entry_1e166c (0x1e166c - 0x1e1724)
    ctx->pc = 0x1e1680;
    entry_1e166c(rdram, ctx, runtime);
}

void entry_1e16b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e16b0 inside entry_1e166c (0x1e166c - 0x1e1724)
    ctx->pc = 0x1e16b0;
    entry_1e166c(rdram, ctx, runtime);
}

void entry_1e16cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e16cc inside entry_1e166c (0x1e166c - 0x1e1724)
    ctx->pc = 0x1e16cc;
    entry_1e166c(rdram, ctx, runtime);
}

void entry_1e16e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e16e4 inside entry_1e166c (0x1e166c - 0x1e1724)
    ctx->pc = 0x1e16e4;
    entry_1e166c(rdram, ctx, runtime);
}

void entry_1e1704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1704 inside entry_1e166c (0x1e166c - 0x1e1724)
    ctx->pc = 0x1e1704;
    entry_1e166c(rdram, ctx, runtime);
}

void entry_1e1708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1708 inside entry_1e166c (0x1e166c - 0x1e1724)
    ctx->pc = 0x1e1708;
    entry_1e166c(rdram, ctx, runtime);
}

void entry_1e1740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1740 inside entry_1e1724 (0x1e1724 - 0x1e17a8)
    ctx->pc = 0x1e1740;
    entry_1e1724(rdram, ctx, runtime);
}

void entry_1e174c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e174c inside entry_1e1724 (0x1e1724 - 0x1e17a8)
    ctx->pc = 0x1e174c;
    entry_1e1724(rdram, ctx, runtime);
}

void entry_1e1770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1770 inside entry_1e1724 (0x1e1724 - 0x1e17a8)
    ctx->pc = 0x1e1770;
    entry_1e1724(rdram, ctx, runtime);
}

void entry_1e1778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1778 inside entry_1e1724 (0x1e1724 - 0x1e17a8)
    ctx->pc = 0x1e1778;
    entry_1e1724(rdram, ctx, runtime);
}

void entry_1e1780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1780 inside entry_1e1724 (0x1e1724 - 0x1e17a8)
    ctx->pc = 0x1e1780;
    entry_1e1724(rdram, ctx, runtime);
}

void entry_1e17fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e17fc inside WriteTftDouble__FP3TFTP5OSTRMd (0x1e17a8 - 0x1e1830)
    ctx->pc = 0x1e17fc;
    WriteTftDouble__FP3TFTP5OSTRMd(rdram, ctx, runtime);
}

void entry_1e180c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e180c inside WriteTftDouble__FP3TFTP5OSTRMd (0x1e17a8 - 0x1e1830)
    ctx->pc = 0x1e180c;
    WriteTftDouble__FP3TFTP5OSTRMd(rdram, ctx, runtime);
}

void entry_1e181c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e181c inside WriteTftDouble__FP3TFTP5OSTRMd (0x1e17a8 - 0x1e1830)
    ctx->pc = 0x1e181c;
    WriteTftDouble__FP3TFTP5OSTRMd(rdram, ctx, runtime);
}

void entry_1e1824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1824 inside WriteTftDouble__FP3TFTP5OSTRMd (0x1e17a8 - 0x1e1830)
    ctx->pc = 0x1e1824;
    WriteTftDouble__FP3TFTP5OSTRMd(rdram, ctx, runtime);
}

void entry_1e1850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1850 inside entry_1e184c (0x1e184c - 0x1e1898)
    ctx->pc = 0x1e1850;
    entry_1e184c(rdram, ctx, runtime);
}

void entry_1e1864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1864 inside entry_1e184c (0x1e184c - 0x1e1898)
    ctx->pc = 0x1e1864;
    entry_1e184c(rdram, ctx, runtime);
}

void entry_1e1878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1878 inside entry_1e184c (0x1e184c - 0x1e1898)
    ctx->pc = 0x1e1878;
    entry_1e184c(rdram, ctx, runtime);
}

void entry_1e1888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1888 inside entry_1e184c (0x1e184c - 0x1e1898)
    ctx->pc = 0x1e1888;
    entry_1e184c(rdram, ctx, runtime);
}

void entry_1e188c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e188c inside entry_1e184c (0x1e184c - 0x1e1898)
    ctx->pc = 0x1e188c;
    entry_1e184c(rdram, ctx, runtime);
}

void entry_1e18f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e18f8 inside entry_1e18cc (0x1e18cc - 0x1e1940)
    ctx->pc = 0x1e18f8;
    entry_1e18cc(rdram, ctx, runtime);
}

void entry_1e1910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1910 inside entry_1e18cc (0x1e18cc - 0x1e1940)
    ctx->pc = 0x1e1910;
    entry_1e18cc(rdram, ctx, runtime);
}

void entry_1e1928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1928 inside entry_1e18cc (0x1e18cc - 0x1e1940)
    ctx->pc = 0x1e1928;
    entry_1e18cc(rdram, ctx, runtime);
}

void entry_1e1948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1948 inside entry_1e1940 (0x1e1940 - 0x1e195c)
    ctx->pc = 0x1e1948;
    entry_1e1940(rdram, ctx, runtime);
}

void entry_1e1970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1970 inside entry_1e195c (0x1e195c - 0x1e1988)
    ctx->pc = 0x1e1970;
    entry_1e195c(rdram, ctx, runtime);
}

void entry_1e1990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1990 inside entry_1e1988 (0x1e1988 - 0x1e19a4)
    ctx->pc = 0x1e1990;
    entry_1e1988(rdram, ctx, runtime);
}

void entry_1e19b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e19b8 inside entry_1e19a4 (0x1e19a4 - 0x1e19d0)
    ctx->pc = 0x1e19b8;
    entry_1e19a4(rdram, ctx, runtime);
}

void entry_1e19d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e19d8 inside entry_1e19d0 (0x1e19d0 - 0x1e1a08)
    ctx->pc = 0x1e19d8;
    entry_1e19d0(rdram, ctx, runtime);
}

void entry_1e1b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1b18 inside entry_1e1ad4 (0x1e1ad4 - 0x1e1b48)
    ctx->pc = 0x1e1b18;
    entry_1e1ad4(rdram, ctx, runtime);
}

void entry_1e1b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1b28 inside entry_1e1ad4 (0x1e1ad4 - 0x1e1b48)
    ctx->pc = 0x1e1b28;
    entry_1e1ad4(rdram, ctx, runtime);
}

void entry_1e1b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1b38 inside entry_1e1ad4 (0x1e1ad4 - 0x1e1b48)
    ctx->pc = 0x1e1b38;
    entry_1e1ad4(rdram, ctx, runtime);
}

void entry_1e1b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1b40 inside entry_1e1ad4 (0x1e1ad4 - 0x1e1b48)
    ctx->pc = 0x1e1b40;
    entry_1e1ad4(rdram, ctx, runtime);
}

void entry_1e1bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1bc8 inside entry_1e1bb8 (0x1e1bb8 - 0x1e1bd8)
    ctx->pc = 0x1e1bc8;
    entry_1e1bb8(rdram, ctx, runtime);
}

void entry_1e1bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1bec inside entry_1e1be8 (0x1e1be8 - 0x1e1bf4)
    ctx->pc = 0x1e1bec;
    entry_1e1be8(rdram, ctx, runtime);
}

void entry_1e1c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1c18 inside entry_1e1c08 (0x1e1c08 - 0x1e1c28)
    ctx->pc = 0x1e1c18;
    entry_1e1c08(rdram, ctx, runtime);
}

void entry_1e1c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1c3c inside entry_1e1c38 (0x1e1c38 - 0x1e1c48)
    ctx->pc = 0x1e1c3c;
    entry_1e1c38(rdram, ctx, runtime);
}

void entry_1e1c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1c68 inside entry_1e1c58 (0x1e1c58 - 0x1e1c70)
    ctx->pc = 0x1e1c68;
    entry_1e1c58(rdram, ctx, runtime);
}

void entry_1e1c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1c94 inside entry_1e1c80 (0x1e1c80 - 0x1e1cb0)
    ctx->pc = 0x1e1c94;
    entry_1e1c80(rdram, ctx, runtime);
}

void entry_1e1ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1ccc inside entry_1e1cc4 (0x1e1cc4 - 0x1e1ce8)
    ctx->pc = 0x1e1ccc;
    entry_1e1cc4(rdram, ctx, runtime);
}

void entry_1e1d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1d18 inside entry_1e1ce8 (0x1e1ce8 - 0x1e1d84)
    ctx->pc = 0x1e1d18;
    entry_1e1ce8(rdram, ctx, runtime);
}

void entry_1e1d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1d28 inside entry_1e1ce8 (0x1e1ce8 - 0x1e1d84)
    ctx->pc = 0x1e1d28;
    entry_1e1ce8(rdram, ctx, runtime);
}

void entry_1e1d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1d44 inside entry_1e1ce8 (0x1e1ce8 - 0x1e1d84)
    ctx->pc = 0x1e1d44;
    entry_1e1ce8(rdram, ctx, runtime);
}

void entry_1e1d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1d60 inside entry_1e1ce8 (0x1e1ce8 - 0x1e1d84)
    ctx->pc = 0x1e1d60;
    entry_1e1ce8(rdram, ctx, runtime);
}

void entry_1e1d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1d7c inside entry_1e1ce8 (0x1e1ce8 - 0x1e1d84)
    ctx->pc = 0x1e1d7c;
    entry_1e1ce8(rdram, ctx, runtime);
}

void entry_1e1d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1d88 inside entry_1e1d84 (0x1e1d84 - 0x1e1db8)
    ctx->pc = 0x1e1d88;
    entry_1e1d84(rdram, ctx, runtime);
}

void entry_1e1d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1d8c inside entry_1e1d84 (0x1e1d84 - 0x1e1db8)
    ctx->pc = 0x1e1d8c;
    entry_1e1d84(rdram, ctx, runtime);
}

void entry_1e1df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1df8 inside CchOstrmPrintf__FP5OSTRMPcT1 (0x1e1db8 - 0x1e1e00)
    ctx->pc = 0x1e1df8;
    CchOstrmPrintf__FP5OSTRMPcT1(rdram, ctx, runtime);
}

void entry_1e1e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1e1c inside entry_1e1e14 (0x1e1e14 - 0x1e1e30)
    ctx->pc = 0x1e1e1c;
    entry_1e1e14(rdram, ctx, runtime);
}

void entry_1e1e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1e3c inside entry_1e1e30 (0x1e1e30 - 0x1e1e54)
    ctx->pc = 0x1e1e3c;
    entry_1e1e30(rdram, ctx, runtime);
}

void entry_1e1e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1e78 inside entry_1e1e70 (0x1e1e70 - 0x1e1e88)
    ctx->pc = 0x1e1e78;
    entry_1e1e70(rdram, ctx, runtime);
}

void entry_1e1e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e1e80 inside entry_1e1e70 (0x1e1e70 - 0x1e1e88)
    ctx->pc = 0x1e1e80;
    entry_1e1e70(rdram, ctx, runtime);
}

void entry_1e2080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2080 inside entry_1e2060 (0x1e2060 - 0x1e2090)
    ctx->pc = 0x1e2080;
    entry_1e2060(rdram, ctx, runtime);
}

void entry_1e2084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2084 inside entry_1e2060 (0x1e2060 - 0x1e2090)
    ctx->pc = 0x1e2084;
    entry_1e2060(rdram, ctx, runtime);
}

void entry_1e2110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2110 inside strlen (0x1e2100 - 0x1e2138)
    ctx->pc = 0x1e2110;
    strlen(rdram, ctx, runtime);
}

void entry_1e212c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e212c inside strlen (0x1e2100 - 0x1e2138)
    ctx->pc = 0x1e212c;
    strlen(rdram, ctx, runtime);
}

void entry_1e21e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e21e0 inside strchr (0x1e21d8 - 0x1e2210)
    ctx->pc = 0x1e21e0;
    strchr(rdram, ctx, runtime);
}

void entry_1e21f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e21f8 inside strchr (0x1e21d8 - 0x1e2210)
    ctx->pc = 0x1e21f8;
    strchr(rdram, ctx, runtime);
}

void entry_1e21fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e21fc inside strchr (0x1e21d8 - 0x1e2210)
    ctx->pc = 0x1e21fc;
    strchr(rdram, ctx, runtime);
}

void entry_1e2230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2230 inside UpperizePchz__FPc (0x1e2218 - 0x1e2268)
    ctx->pc = 0x1e2230;
    UpperizePchz__FPc(rdram, ctx, runtime);
}

void entry_1e2260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2260 inside UpperizePchz__FPc (0x1e2218 - 0x1e2268)
    ctx->pc = 0x1e2260;
    UpperizePchz__FPc(rdram, ctx, runtime);
}

void entry_1e2338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2338 inside entry_1e2328 (0x1e2328 - 0x1e2358)
    ctx->pc = 0x1e2338;
    entry_1e2328(rdram, ctx, runtime);
}

void entry_1e2340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2340 inside entry_1e2328 (0x1e2328 - 0x1e2358)
    ctx->pc = 0x1e2340;
    entry_1e2328(rdram, ctx, runtime);
}

void entry_1e2430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2430 inside PtnfnFromTn__FP2TN (0x1e2420 - 0x1e2438)
    ctx->pc = 0x1e2430;
    PtnfnFromTn__FP2TN(rdram, ctx, runtime);
}

void entry_1e2508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2508 inside entry_1e2504 (0x1e2504 - 0x1e2520)
    ctx->pc = 0x1e2508;
    entry_1e2504(rdram, ctx, runtime);
}

void entry_1e2544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2544 inside entry_1e2534 (0x1e2534 - 0x1e25f8)
    ctx->pc = 0x1e2544;
    entry_1e2534(rdram, ctx, runtime);
}

void entry_1e2694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2694 inside entry_1e2690 (0x1e2690 - 0x1e26a8)
    ctx->pc = 0x1e2694;
    entry_1e2690(rdram, ctx, runtime);
}

void entry_1e26ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e26ec inside entry_1e26e8 (0x1e26e8 - 0x1e2710)
    ctx->pc = 0x1e26ec;
    entry_1e26e8(rdram, ctx, runtime);
}

void entry_1e2708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2708 inside entry_1e26e8 (0x1e26e8 - 0x1e2710)
    ctx->pc = 0x1e2708;
    entry_1e26e8(rdram, ctx, runtime);
}

void entry_1e2720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2720 inside entry_1e271c (0x1e271c - 0x1e2740)
    ctx->pc = 0x1e2720;
    entry_1e271c(rdram, ctx, runtime);
}

void entry_1e27e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e27e8 inside entry_1e27e0 (0x1e27e0 - 0x1e2808)
    ctx->pc = 0x1e27e8;
    entry_1e27e0(rdram, ctx, runtime);
}

void entry_1e2820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2820 inside entry_1e281c (0x1e281c - 0x1e2840)
    ctx->pc = 0x1e2820;
    entry_1e281c(rdram, ctx, runtime);
}

void entry_1e2830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2830 inside entry_1e281c (0x1e281c - 0x1e2840)
    ctx->pc = 0x1e2830;
    entry_1e281c(rdram, ctx, runtime);
}

void entry_1e28ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e28ac inside entry_1e28a8 (0x1e28a8 - 0x1e28d0)
    ctx->pc = 0x1e28ac;
    entry_1e28a8(rdram, ctx, runtime);
}

void entry_1e28e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e28e4 inside entry_1e28dc (0x1e28dc - 0x1e2928)
    ctx->pc = 0x1e28e4;
    entry_1e28dc(rdram, ctx, runtime);
}

void entry_1e2920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2920 inside entry_1e28dc (0x1e28dc - 0x1e2928)
    ctx->pc = 0x1e2920;
    entry_1e28dc(rdram, ctx, runtime);
}

void entry_1e292c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e292c inside entry_1e2928 (0x1e2928 - 0x1e2940)
    ctx->pc = 0x1e292c;
    entry_1e2928(rdram, ctx, runtime);
}

void entry_1e2ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2ab8 inside entry_1e2a70 (0x1e2a70 - 0x1e2ad8)
    ctx->pc = 0x1e2ab8;
    entry_1e2a70(rdram, ctx, runtime);
}

void entry_1e2b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2b80 inside entry_1e2b38 (0x1e2b38 - 0x1e2bf0)
    ctx->pc = 0x1e2b80;
    entry_1e2b38(rdram, ctx, runtime);
}

void entry_1e2bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2bd8 inside entry_1e2b38 (0x1e2b38 - 0x1e2bf0)
    ctx->pc = 0x1e2bd8;
    entry_1e2b38(rdram, ctx, runtime);
}

void entry_1e2c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2c30 inside CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1 (0x1e2bf0 - 0x1e2ccc)
    ctx->pc = 0x1e2c30;
    CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1(rdram, ctx, runtime);
}

void entry_1e2c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2c6c inside CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1 (0x1e2bf0 - 0x1e2ccc)
    ctx->pc = 0x1e2c6c;
    CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1(rdram, ctx, runtime);
}

void entry_1e2c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2c7c inside CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1 (0x1e2bf0 - 0x1e2ccc)
    ctx->pc = 0x1e2c7c;
    CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1(rdram, ctx, runtime);
}

void entry_1e2cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2cb4 inside CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1 (0x1e2bf0 - 0x1e2ccc)
    ctx->pc = 0x1e2cb4;
    CalculateTnPos__FP2TNP6VECTORffP3CLQP2LM4FTNDT1(rdram, ctx, runtime);
}

void entry_1e2ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2ce4 inside entry_1e2ccc (0x1e2ccc - 0x1e2d00)
    ctx->pc = 0x1e2ce4;
    entry_1e2ccc(rdram, ctx, runtime);
}

void entry_1e2d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2d14 inside entry_1e2d00 (0x1e2d00 - 0x1e2d4c)
    ctx->pc = 0x1e2d14;
    entry_1e2d00(rdram, ctx, runtime);
}

void entry_1e2d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2d40 inside entry_1e2d00 (0x1e2d00 - 0x1e2d4c)
    ctx->pc = 0x1e2d40;
    entry_1e2d00(rdram, ctx, runtime);
}

void entry_1e2d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2d44 inside entry_1e2d00 (0x1e2d00 - 0x1e2d4c)
    ctx->pc = 0x1e2d44;
    entry_1e2d00(rdram, ctx, runtime);
}

void entry_1e2dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2dbc inside entry_1e2d60 (0x1e2d60 - 0x1e2dc4)
    ctx->pc = 0x1e2dbc;
    entry_1e2d60(rdram, ctx, runtime);
}

void entry_1e2de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2de8 inside entry_1e2dc4 (0x1e2dc4 - 0x1e2e44)
    ctx->pc = 0x1e2de8;
    entry_1e2dc4(rdram, ctx, runtime);
}

void entry_1e2e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2e20 inside entry_1e2dc4 (0x1e2dc4 - 0x1e2e44)
    ctx->pc = 0x1e2e20;
    entry_1e2dc4(rdram, ctx, runtime);
}

void entry_1e2f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2f38 inside entry_1e2f30 (0x1e2f30 - 0x1e2f4c)
    ctx->pc = 0x1e2f38;
    entry_1e2f30(rdram, ctx, runtime);
}

void entry_1e2f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2f50 inside entry_1e2f4c (0x1e2f4c - 0x1e2f60)
    ctx->pc = 0x1e2f50;
    entry_1e2f4c(rdram, ctx, runtime);
}

void entry_1e2f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e2f64 inside entry_1e2f60 (0x1e2f60 - 0x1e2f94)
    ctx->pc = 0x1e2f64;
    entry_1e2f60(rdram, ctx, runtime);
}

void entry_1e3064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3064 inside entry_1e3008 (0x1e3008 - 0x1e3078)
    ctx->pc = 0x1e3064;
    entry_1e3008(rdram, ctx, runtime);
}

void entry_1e3068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3068 inside entry_1e3008 (0x1e3008 - 0x1e3078)
    ctx->pc = 0x1e3068;
    entry_1e3008(rdram, ctx, runtime);
}

void entry_1e30d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e30d0 inside DeactivateCptn__FP4CPTNPv (0x1e30a0 - 0x1e30d8)
    ctx->pc = 0x1e30d0;
    DeactivateCptn__FP4CPTNPv(rdram, ctx, runtime);
}

void entry_1e311c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e311c inside FUN_001e30e8 (0x1e30e8 - 0x1e3124)
    ctx->pc = 0x1e311c;
    FUN_001e30e8(rdram, ctx, runtime);
}

void entry_1e3190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3190 inside entry_1e3188 (0x1e3188 - 0x1e31a8)
    ctx->pc = 0x1e3190;
    entry_1e3188(rdram, ctx, runtime);
}

void entry_1e31d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e31d4 inside entry_1e31a8 (0x1e31a8 - 0x1e31f0)
    ctx->pc = 0x1e31d4;
    entry_1e31a8(rdram, ctx, runtime);
}

void entry_1e31dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e31dc inside entry_1e31a8 (0x1e31a8 - 0x1e31f0)
    ctx->pc = 0x1e31dc;
    entry_1e31a8(rdram, ctx, runtime);
}

void entry_1e31e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e31e0 inside entry_1e31a8 (0x1e31a8 - 0x1e31f0)
    ctx->pc = 0x1e31e0;
    entry_1e31a8(rdram, ctx, runtime);
}

void entry_1e3270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3270 inside UpdateCptn__FP4CPTNP6CPDEFIP3JOYf (0x1e31f0 - 0x1e32c0)
    ctx->pc = 0x1e3270;
    UpdateCptn__FP4CPTNP6CPDEFIP3JOYf(rdram, ctx, runtime);
}

void entry_1e327c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e327c inside UpdateCptn__FP4CPTNP6CPDEFIP3JOYf (0x1e31f0 - 0x1e32c0)
    ctx->pc = 0x1e327c;
    UpdateCptn__FP4CPTNP6CPDEFIP3JOYf(rdram, ctx, runtime);
}

void entry_1e32a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e32a8 inside UpdateCptn__FP4CPTNP6CPDEFIP3JOYf (0x1e31f0 - 0x1e32c0)
    ctx->pc = 0x1e32a8;
    UpdateCptn__FP4CPTNP6CPDEFIP3JOYf(rdram, ctx, runtime);
}

void entry_1e32b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e32b4 inside UpdateCptn__FP4CPTNP6CPDEFIP3JOYf (0x1e31f0 - 0x1e32c0)
    ctx->pc = 0x1e32b4;
    UpdateCptn__FP4CPTNP6CPDEFIP3JOYf(rdram, ctx, runtime);
}

void entry_1e3340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3340 inside entry_1e333c (0x1e333c - 0x1e337c)
    ctx->pc = 0x1e3340;
    entry_1e333c(rdram, ctx, runtime);
}

void entry_1e3364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3364 inside entry_1e333c (0x1e333c - 0x1e337c)
    ctx->pc = 0x1e3364;
    entry_1e333c(rdram, ctx, runtime);
}

void entry_1e3414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3414 inside entry_1e3404 (0x1e3404 - 0x1e3450)
    ctx->pc = 0x1e3414;
    entry_1e3404(rdram, ctx, runtime);
}

void entry_1e3418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3418 inside entry_1e3404 (0x1e3404 - 0x1e3450)
    ctx->pc = 0x1e3418;
    entry_1e3404(rdram, ctx, runtime);
}

void entry_1e34c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e34c4 inside entry_1e34b4 (0x1e34b4 - 0x1e3534)
    ctx->pc = 0x1e34c4;
    entry_1e34b4(rdram, ctx, runtime);
}

void entry_1e34f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e34f0 inside entry_1e34b4 (0x1e34b4 - 0x1e3534)
    ctx->pc = 0x1e34f0;
    entry_1e34b4(rdram, ctx, runtime);
}

void entry_1e3510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3510 inside entry_1e34b4 (0x1e34b4 - 0x1e3534)
    ctx->pc = 0x1e3510;
    entry_1e34b4(rdram, ctx, runtime);
}

void entry_1e3520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3520 inside entry_1e34b4 (0x1e34b4 - 0x1e3534)
    ctx->pc = 0x1e3520;
    entry_1e34b4(rdram, ctx, runtime);
}

void entry_1e3560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3560 inside entry_1e3548 (0x1e3548 - 0x1e36d8)
    ctx->pc = 0x1e3560;
    entry_1e3548(rdram, ctx, runtime);
}

void entry_1e3564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3564 inside entry_1e3548 (0x1e3548 - 0x1e36d8)
    ctx->pc = 0x1e3564;
    entry_1e3548(rdram, ctx, runtime);
}

void entry_1e3568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3568 inside entry_1e3548 (0x1e3548 - 0x1e36d8)
    ctx->pc = 0x1e3568;
    entry_1e3548(rdram, ctx, runtime);
}

void entry_1e3590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3590 inside entry_1e3548 (0x1e3548 - 0x1e36d8)
    ctx->pc = 0x1e3590;
    entry_1e3548(rdram, ctx, runtime);
}

void entry_1e35b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e35b0 inside entry_1e3548 (0x1e3548 - 0x1e36d8)
    ctx->pc = 0x1e35b0;
    entry_1e3548(rdram, ctx, runtime);
}

void entry_1e3630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3630 inside entry_1e3548 (0x1e3548 - 0x1e36d8)
    ctx->pc = 0x1e3630;
    entry_1e3548(rdram, ctx, runtime);
}

void entry_1e3640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3640 inside entry_1e3548 (0x1e3548 - 0x1e36d8)
    ctx->pc = 0x1e3640;
    entry_1e3548(rdram, ctx, runtime);
}

void entry_1e3684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3684 inside entry_1e3548 (0x1e3548 - 0x1e36d8)
    ctx->pc = 0x1e3684;
    entry_1e3548(rdram, ctx, runtime);
}

void entry_1e3694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3694 inside entry_1e3548 (0x1e3548 - 0x1e36d8)
    ctx->pc = 0x1e3694;
    entry_1e3548(rdram, ctx, runtime);
}

void entry_1e36b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e36b0 inside entry_1e3548 (0x1e3548 - 0x1e36d8)
    ctx->pc = 0x1e36b0;
    entry_1e3548(rdram, ctx, runtime);
}

void entry_1e36b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e36b4 inside entry_1e3548 (0x1e3548 - 0x1e36d8)
    ctx->pc = 0x1e36b4;
    entry_1e3548(rdram, ctx, runtime);
}

void entry_1e3744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3744 inside entry_1e3728 (0x1e3728 - 0x1e37d0)
    ctx->pc = 0x1e3744;
    entry_1e3728(rdram, ctx, runtime);
}

void entry_1e3788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3788 inside entry_1e3728 (0x1e3728 - 0x1e37d0)
    ctx->pc = 0x1e3788;
    entry_1e3728(rdram, ctx, runtime);
}

void entry_1e37e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e37e8 inside entry_1e37d0 (0x1e37d0 - 0x1e3810)
    ctx->pc = 0x1e37e8;
    entry_1e37d0(rdram, ctx, runtime);
}

void entry_1e3830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3830 inside entry_1e3810 (0x1e3810 - 0x1e3898)
    ctx->pc = 0x1e3830;
    entry_1e3810(rdram, ctx, runtime);
}

void entry_1e3884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3884 inside entry_1e3810 (0x1e3810 - 0x1e3898)
    ctx->pc = 0x1e3884;
    entry_1e3810(rdram, ctx, runtime);
}

void entry_1e3888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3888 inside entry_1e3810 (0x1e3810 - 0x1e3898)
    ctx->pc = 0x1e3888;
    entry_1e3810(rdram, ctx, runtime);
}

void entry_1e389c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e389c inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e389c;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e38a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e38a0 inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e38a0;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e38c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e38c0 inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e38c0;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e38c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e38c4 inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e38c4;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e395c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e395c inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e395c;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e39cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e39cc inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e39cc;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e39dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e39dc inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e39dc;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e39f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e39f8 inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e39f8;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e39fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e39fc inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e39fc;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e3a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3a14 inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e3a14;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e3a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3a38 inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e3a38;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e3a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3a40 inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e3a40;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e3a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3a48 inside entry_1e3898 (0x1e3898 - 0x1e3a70)
    ctx->pc = 0x1e3a48;
    entry_1e3898(rdram, ctx, runtime);
}

void entry_1e3ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3ac4 inside entry_1e3a70 (0x1e3a70 - 0x1e3b58)
    ctx->pc = 0x1e3ac4;
    entry_1e3a70(rdram, ctx, runtime);
}

void entry_1e3ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3ad4 inside entry_1e3a70 (0x1e3a70 - 0x1e3b58)
    ctx->pc = 0x1e3ad4;
    entry_1e3a70(rdram, ctx, runtime);
}

void entry_1e3b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3b38 inside entry_1e3a70 (0x1e3a70 - 0x1e3b58)
    ctx->pc = 0x1e3b38;
    entry_1e3a70(rdram, ctx, runtime);
}

void entry_1e3b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3b48 inside entry_1e3a70 (0x1e3a70 - 0x1e3b58)
    ctx->pc = 0x1e3b48;
    entry_1e3a70(rdram, ctx, runtime);
}

void entry_1e3b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3b6c inside entry_1e3b58 (0x1e3b58 - 0x1e3c7c)
    ctx->pc = 0x1e3b6c;
    entry_1e3b58(rdram, ctx, runtime);
}

void entry_1e3b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3b84 inside entry_1e3b58 (0x1e3b58 - 0x1e3c7c)
    ctx->pc = 0x1e3b84;
    entry_1e3b58(rdram, ctx, runtime);
}

void entry_1e3ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3ba4 inside entry_1e3b58 (0x1e3b58 - 0x1e3c7c)
    ctx->pc = 0x1e3ba4;
    entry_1e3b58(rdram, ctx, runtime);
}

void entry_1e3bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3bac inside entry_1e3b58 (0x1e3b58 - 0x1e3c7c)
    ctx->pc = 0x1e3bac;
    entry_1e3b58(rdram, ctx, runtime);
}

void entry_1e3bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3bb8 inside entry_1e3b58 (0x1e3b58 - 0x1e3c7c)
    ctx->pc = 0x1e3bb8;
    entry_1e3b58(rdram, ctx, runtime);
}

void entry_1e3bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3bc8 inside entry_1e3b58 (0x1e3b58 - 0x1e3c7c)
    ctx->pc = 0x1e3bc8;
    entry_1e3b58(rdram, ctx, runtime);
}

void entry_1e3be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3be0 inside entry_1e3b58 (0x1e3b58 - 0x1e3c7c)
    ctx->pc = 0x1e3be0;
    entry_1e3b58(rdram, ctx, runtime);
}

void entry_1e3c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3c00 inside entry_1e3b58 (0x1e3b58 - 0x1e3c7c)
    ctx->pc = 0x1e3c00;
    entry_1e3b58(rdram, ctx, runtime);
}

void entry_1e3c58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3c58 inside entry_1e3b58 (0x1e3b58 - 0x1e3c7c)
    ctx->pc = 0x1e3c58;
    entry_1e3b58(rdram, ctx, runtime);
}

void entry_1e3c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3c64 inside entry_1e3b58 (0x1e3b58 - 0x1e3c7c)
    ctx->pc = 0x1e3c64;
    entry_1e3b58(rdram, ctx, runtime);
}

void entry_1e3cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3cd4 inside entry_1e3c7c (0x1e3c7c - 0x1e3dd8)
    ctx->pc = 0x1e3cd4;
    entry_1e3c7c(rdram, ctx, runtime);
}

void entry_1e3d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3d34 inside entry_1e3c7c (0x1e3c7c - 0x1e3dd8)
    ctx->pc = 0x1e3d34;
    entry_1e3c7c(rdram, ctx, runtime);
}

void entry_1e3d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3d68 inside entry_1e3c7c (0x1e3c7c - 0x1e3dd8)
    ctx->pc = 0x1e3d68;
    entry_1e3c7c(rdram, ctx, runtime);
}

void entry_1e3d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3d70 inside entry_1e3c7c (0x1e3c7c - 0x1e3dd8)
    ctx->pc = 0x1e3d70;
    entry_1e3c7c(rdram, ctx, runtime);
}

void entry_1e3d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3d74 inside entry_1e3c7c (0x1e3c7c - 0x1e3dd8)
    ctx->pc = 0x1e3d74;
    entry_1e3c7c(rdram, ctx, runtime);
}

void entry_1e3df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3df4 inside entry_1e3dec (0x1e3dec - 0x1e3e90)
    ctx->pc = 0x1e3df4;
    entry_1e3dec(rdram, ctx, runtime);
}

void entry_1e3e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3e1c inside entry_1e3dec (0x1e3dec - 0x1e3e90)
    ctx->pc = 0x1e3e1c;
    entry_1e3dec(rdram, ctx, runtime);
}

void entry_1e3e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3e20 inside entry_1e3dec (0x1e3dec - 0x1e3e90)
    ctx->pc = 0x1e3e20;
    entry_1e3dec(rdram, ctx, runtime);
}

void entry_1e3e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3e44 inside entry_1e3dec (0x1e3dec - 0x1e3e90)
    ctx->pc = 0x1e3e44;
    entry_1e3dec(rdram, ctx, runtime);
}

void entry_1e3e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3e48 inside entry_1e3dec (0x1e3dec - 0x1e3e90)
    ctx->pc = 0x1e3e48;
    entry_1e3dec(rdram, ctx, runtime);
}

void entry_1e3e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3e98 inside entry_1e3e90 (0x1e3e90 - 0x1e3ef4)
    ctx->pc = 0x1e3e98;
    entry_1e3e90(rdram, ctx, runtime);
}

void entry_1e3ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3ea0 inside entry_1e3e90 (0x1e3e90 - 0x1e3ef4)
    ctx->pc = 0x1e3ea0;
    entry_1e3e90(rdram, ctx, runtime);
}

void entry_1e3ec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3ec8 inside entry_1e3e90 (0x1e3e90 - 0x1e3ef4)
    ctx->pc = 0x1e3ec8;
    entry_1e3e90(rdram, ctx, runtime);
}

void entry_1e3f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3f40 inside entry_1e3f2c (0x1e3f2c - 0x1e3f48)
    ctx->pc = 0x1e3f40;
    entry_1e3f2c(rdram, ctx, runtime);
}

void entry_1e3fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e3fec inside entry_1e3fcc (0x1e3fcc - 0x1e3ff4)
    ctx->pc = 0x1e3fec;
    entry_1e3fcc(rdram, ctx, runtime);
}

void entry_1e4020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4020 inside entry_1e3ff4 (0x1e3ff4 - 0x1e403c)
    ctx->pc = 0x1e4020;
    entry_1e3ff4(rdram, ctx, runtime);
}

void entry_1e4024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4024 inside entry_1e3ff4 (0x1e3ff4 - 0x1e403c)
    ctx->pc = 0x1e4024;
    entry_1e3ff4(rdram, ctx, runtime);
}

void entry_1e4090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4090 inside entry_1e406c (0x1e406c - 0x1e4098)
    ctx->pc = 0x1e4090;
    entry_1e406c(rdram, ctx, runtime);
}

void entry_1e40c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e40c4 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e40c4;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e40c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e40c8 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e40c8;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e40ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e40ec inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e40ec;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e4100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4100 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e4100;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e4124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4124 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e4124;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e414c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e414c inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e414c;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e4178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4178 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e4178;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e4194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4194 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e4194;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e41a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e41a8 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e41a8;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e41f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e41f0 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e41f0;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e4204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4204 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e4204;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e420c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e420c inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e420c;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e4250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4250 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e4250;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e4260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4260 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e4260;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e4264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4264 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e4264;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e4268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4268 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e4268;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e4294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4294 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e4294;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e42e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e42e8 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e42e8;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e42f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e42f0 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e42f0;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e43a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e43a0 inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e43a0;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e43ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e43ac inside entry_1e4098 (0x1e4098 - 0x1e43c4)
    ctx->pc = 0x1e43ac;
    entry_1e4098(rdram, ctx, runtime);
}

void entry_1e43e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e43e4 inside entry_1e43c4 (0x1e43c4 - 0x1e4414)
    ctx->pc = 0x1e43e4;
    entry_1e43c4(rdram, ctx, runtime);
}

void entry_1e441c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e441c inside entry_1e4414 (0x1e4414 - 0x1e443c)
    ctx->pc = 0x1e441c;
    entry_1e4414(rdram, ctx, runtime);
}

void entry_1e4440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4440 inside entry_1e443c (0x1e443c - 0x1e4454)
    ctx->pc = 0x1e4440;
    entry_1e443c(rdram, ctx, runtime);
}

void entry_1e45d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e45d4 inside FUN_001e4578 (0x1e4578 - 0x1e4760)
    ctx->pc = 0x1e45d4;
    FUN_001e4578(rdram, ctx, runtime);
}

void entry_1e45f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e45f0 inside FUN_001e4578 (0x1e4578 - 0x1e4760)
    ctx->pc = 0x1e45f0;
    FUN_001e4578(rdram, ctx, runtime);
}

void entry_1e46ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e46ac inside FUN_001e4578 (0x1e4578 - 0x1e4760)
    ctx->pc = 0x1e46ac;
    FUN_001e4578(rdram, ctx, runtime);
}

void entry_1e46bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e46bc inside FUN_001e4578 (0x1e4578 - 0x1e4760)
    ctx->pc = 0x1e46bc;
    FUN_001e4578(rdram, ctx, runtime);
}

void entry_1e46c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e46c8 inside FUN_001e4578 (0x1e4578 - 0x1e4760)
    ctx->pc = 0x1e46c8;
    FUN_001e4578(rdram, ctx, runtime);
}

void entry_1e4708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4708 inside FUN_001e4578 (0x1e4578 - 0x1e4760)
    ctx->pc = 0x1e4708;
    FUN_001e4578(rdram, ctx, runtime);
}

void entry_1e47a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e47a0 inside entry_1e4794 (0x1e4794 - 0x1e47b0)
    ctx->pc = 0x1e47a0;
    entry_1e4794(rdram, ctx, runtime);
}

void entry_1e4800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4800 inside entry_1e47e8 (0x1e47e8 - 0x1e4818)
    ctx->pc = 0x1e4800;
    entry_1e47e8(rdram, ctx, runtime);
}

void entry_1e4810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4810 inside entry_1e47e8 (0x1e47e8 - 0x1e4818)
    ctx->pc = 0x1e4810;
    entry_1e47e8(rdram, ctx, runtime);
}

void entry_1e4850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4850 inside entry_1e484c (0x1e484c - 0x1e4880)
    ctx->pc = 0x1e4850;
    entry_1e484c(rdram, ctx, runtime);
}

void entry_1e4854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4854 inside entry_1e484c (0x1e484c - 0x1e4880)
    ctx->pc = 0x1e4854;
    entry_1e484c(rdram, ctx, runtime);
}

void entry_1e4a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4a28 inside entry_1e49d4 (0x1e49d4 - 0x1e4a3c)
    ctx->pc = 0x1e4a28;
    entry_1e49d4(rdram, ctx, runtime);
}

void entry_1e4ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4ac0 inside entry_1e4a6c (0x1e4a6c - 0x1e4b6c)
    ctx->pc = 0x1e4ac0;
    entry_1e4a6c(rdram, ctx, runtime);
}

void entry_1e4ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4ad4 inside entry_1e4a6c (0x1e4a6c - 0x1e4b6c)
    ctx->pc = 0x1e4ad4;
    entry_1e4a6c(rdram, ctx, runtime);
}

void entry_1e4b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4b00 inside entry_1e4a6c (0x1e4a6c - 0x1e4b6c)
    ctx->pc = 0x1e4b00;
    entry_1e4a6c(rdram, ctx, runtime);
}

void entry_1e4b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4b0c inside entry_1e4a6c (0x1e4a6c - 0x1e4b6c)
    ctx->pc = 0x1e4b0c;
    entry_1e4a6c(rdram, ctx, runtime);
}

void entry_1e4b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4b44 inside entry_1e4a6c (0x1e4a6c - 0x1e4b6c)
    ctx->pc = 0x1e4b44;
    entry_1e4a6c(rdram, ctx, runtime);
}

void entry_1e4be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4be8 inside entry_1e4b8c (0x1e4b8c - 0x1e4bf0)
    ctx->pc = 0x1e4be8;
    entry_1e4b8c(rdram, ctx, runtime);
}

void entry_1e4cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4cb0 inside entry_1e4c98 (0x1e4c98 - 0x1e4cbc)
    ctx->pc = 0x1e4cb0;
    entry_1e4c98(rdram, ctx, runtime);
}

void entry_1e4cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4cd8 inside entry_1e4cd0 (0x1e4cd0 - 0x1e4ce0)
    ctx->pc = 0x1e4cd8;
    entry_1e4cd0(rdram, ctx, runtime);
}

void entry_1e4d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4d08 inside entry_1e4cf0 (0x1e4cf0 - 0x1e4d10)
    ctx->pc = 0x1e4d08;
    entry_1e4cf0(rdram, ctx, runtime);
}

void entry_1e4d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4d34 inside entry_1e4d24 (0x1e4d24 - 0x1e4d48)
    ctx->pc = 0x1e4d34;
    entry_1e4d24(rdram, ctx, runtime);
}

void entry_1e4d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4d40 inside entry_1e4d24 (0x1e4d24 - 0x1e4d48)
    ctx->pc = 0x1e4d40;
    entry_1e4d24(rdram, ctx, runtime);
}

void entry_1e4d58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4d58 inside entry_1e4d48 (0x1e4d48 - 0x1e4dc0)
    ctx->pc = 0x1e4d58;
    entry_1e4d48(rdram, ctx, runtime);
}

void entry_1e4d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4d64 inside entry_1e4d48 (0x1e4d48 - 0x1e4dc0)
    ctx->pc = 0x1e4d64;
    entry_1e4d48(rdram, ctx, runtime);
}

void entry_1e4d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4d70 inside entry_1e4d48 (0x1e4d48 - 0x1e4dc0)
    ctx->pc = 0x1e4d70;
    entry_1e4d48(rdram, ctx, runtime);
}

void entry_1e4dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4dc8 inside FCheckTbspPoint__FP4TBSPP6VECTOR (0x1e4dc0 - 0x1e4e38)
    ctx->pc = 0x1e4dc8;
    FCheckTbspPoint__FP4TBSPP6VECTOR(rdram, ctx, runtime);
}

void entry_1e4e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4e20 inside FCheckTbspPoint__FP4TBSPP6VECTOR (0x1e4dc0 - 0x1e4e38)
    ctx->pc = 0x1e4e20;
    FCheckTbspPoint__FP4TBSPP6VECTOR(rdram, ctx, runtime);
}

void entry_1e4e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4e30 inside FCheckTbspPoint__FP4TBSPP6VECTOR (0x1e4dc0 - 0x1e4e38)
    ctx->pc = 0x1e4e30;
    FCheckTbspPoint__FP4TBSPP6VECTOR(rdram, ctx, runtime);
}

void entry_1e4ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4ea0 inside Set__11CTransitionPc3OIDT2i (0x1e4e80 - 0x1e4ea8)
    ctx->pc = 0x1e4ea0;
    Set__11CTransitionPc3OIDT2i(rdram, ctx, runtime);
}

void entry_1e4f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e4f94 inside entry_1e4ef0 (0x1e4ef0 - 0x1e4fd8)
    ctx->pc = 0x1e4f94;
    entry_1e4ef0(rdram, ctx, runtime);
}

void entry_1e5018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5018 inside entry_1e5014 (0x1e5014 - 0x1e5020)
    ctx->pc = 0x1e5018;
    entry_1e5014(rdram, ctx, runtime);
}

void entry_1e503c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e503c inside entry_1e5034 (0x1e5034 - 0x1e504c)
    ctx->pc = 0x1e503c;
    entry_1e5034(rdram, ctx, runtime);
}

void entry_1e5120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5120 inside entry_1e511c (0x1e511c - 0x1e516c)
    ctx->pc = 0x1e5120;
    entry_1e511c(rdram, ctx, runtime);
}

void entry_1e5164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5164 inside entry_1e511c (0x1e511c - 0x1e516c)
    ctx->pc = 0x1e5164;
    entry_1e511c(rdram, ctx, runtime);
}

void entry_1e5170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5170 inside entry_1e516c (0x1e516c - 0x1e5178)
    ctx->pc = 0x1e5170;
    entry_1e516c(rdram, ctx, runtime);
}

void entry_1e517c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e517c inside entry_1e5178 (0x1e5178 - 0x1e5190)
    ctx->pc = 0x1e517c;
    entry_1e5178(rdram, ctx, runtime);
}

void entry_1e52b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e52b8 inside entry_1e5294 (0x1e5294 - 0x1e52e4)
    ctx->pc = 0x1e52b8;
    entry_1e5294(rdram, ctx, runtime);
}

void entry_1e52d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e52d0 inside entry_1e5294 (0x1e5294 - 0x1e52e4)
    ctx->pc = 0x1e52d0;
    entry_1e5294(rdram, ctx, runtime);
}

void entry_1e52d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e52d8 inside entry_1e5294 (0x1e5294 - 0x1e52e4)
    ctx->pc = 0x1e52d8;
    entry_1e5294(rdram, ctx, runtime);
}

void entry_1e52ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e52ec inside entry_1e52e4 (0x1e52e4 - 0x1e5314)
    ctx->pc = 0x1e52ec;
    entry_1e52e4(rdram, ctx, runtime);
}

void entry_1e52f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e52f4 inside entry_1e52e4 (0x1e52e4 - 0x1e5314)
    ctx->pc = 0x1e52f4;
    entry_1e52e4(rdram, ctx, runtime);
}

void entry_1e52f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e52f8 inside entry_1e52e4 (0x1e52e4 - 0x1e5314)
    ctx->pc = 0x1e52f8;
    entry_1e52e4(rdram, ctx, runtime);
}

void entry_1e5300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5300 inside entry_1e52e4 (0x1e52e4 - 0x1e5314)
    ctx->pc = 0x1e5300;
    entry_1e52e4(rdram, ctx, runtime);
}

void entry_1e5318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5318 inside entry_1e5314 (0x1e5314 - 0x1e5328)
    ctx->pc = 0x1e5318;
    entry_1e5314(rdram, ctx, runtime);
}

void entry_1e5350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5350 inside entry_1e534c (0x1e534c - 0x1e536c)
    ctx->pc = 0x1e5350;
    entry_1e534c(rdram, ctx, runtime);
}

void entry_1e5420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5420 inside FUN_001e53f8 (0x1e53f8 - 0x1e5428)
    ctx->pc = 0x1e5420;
    FUN_001e53f8(rdram, ctx, runtime);
}

void entry_1e54d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e54d8 inside entry_1e54d0 (0x1e54d0 - 0x1e54ec)
    ctx->pc = 0x1e54d8;
    entry_1e54d0(rdram, ctx, runtime);
}

void entry_1e5528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5528 inside entry_1e5520 (0x1e5520 - 0x1e5568)
    ctx->pc = 0x1e5528;
    entry_1e5520(rdram, ctx, runtime);
}

void entry_1e5544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5544 inside entry_1e5520 (0x1e5520 - 0x1e5568)
    ctx->pc = 0x1e5544;
    entry_1e5520(rdram, ctx, runtime);
}

void entry_1e5550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5550 inside entry_1e5520 (0x1e5520 - 0x1e5568)
    ctx->pc = 0x1e5550;
    entry_1e5520(rdram, ctx, runtime);
}

void entry_1e5588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5588 inside entry_1e5568 (0x1e5568 - 0x1e55a8)
    ctx->pc = 0x1e5588;
    entry_1e5568(rdram, ctx, runtime);
}

void entry_1e5594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5594 inside entry_1e5568 (0x1e5568 - 0x1e55a8)
    ctx->pc = 0x1e5594;
    entry_1e5568(rdram, ctx, runtime);
}

void entry_1e5640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5640 inside entry_1e562c (0x1e562c - 0x1e5664)
    ctx->pc = 0x1e5640;
    entry_1e562c(rdram, ctx, runtime);
}

void entry_1e5668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5668 inside entry_1e5664 (0x1e5664 - 0x1e56a0)
    ctx->pc = 0x1e5668;
    entry_1e5664(rdram, ctx, runtime);
}

void entry_1e5670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5670 inside entry_1e5664 (0x1e5664 - 0x1e56a0)
    ctx->pc = 0x1e5670;
    entry_1e5664(rdram, ctx, runtime);
}

void entry_1e5678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5678 inside entry_1e5664 (0x1e5664 - 0x1e56a0)
    ctx->pc = 0x1e5678;
    entry_1e5664(rdram, ctx, runtime);
}

void entry_1e5680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5680 inside entry_1e5664 (0x1e5664 - 0x1e56a0)
    ctx->pc = 0x1e5680;
    entry_1e5664(rdram, ctx, runtime);
}

void entry_1e5684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5684 inside entry_1e5664 (0x1e5664 - 0x1e56a0)
    ctx->pc = 0x1e5684;
    entry_1e5664(rdram, ctx, runtime);
}

void entry_1e573c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e573c inside entry_1e5738 (0x1e5738 - 0x1e5750)
    ctx->pc = 0x1e573c;
    entry_1e5738(rdram, ctx, runtime);
}

void entry_1e5740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5740 inside entry_1e5738 (0x1e5738 - 0x1e5750)
    ctx->pc = 0x1e5740;
    entry_1e5738(rdram, ctx, runtime);
}

void entry_1e57e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e57e0 inside entry_1e57ac (0x1e57ac - 0x1e57f4)
    ctx->pc = 0x1e57e0;
    entry_1e57ac(rdram, ctx, runtime);
}

void entry_1e5818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5818 inside entry_1e5810 (0x1e5810 - 0x1e5838)
    ctx->pc = 0x1e5818;
    entry_1e5810(rdram, ctx, runtime);
}

void entry_1e5870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5870 inside entry_1e586c (0x1e586c - 0x1e5888)
    ctx->pc = 0x1e5870;
    entry_1e586c(rdram, ctx, runtime);
}

void entry_1e591c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e591c inside entry_1e5914 (0x1e5914 - 0x1e5938)
    ctx->pc = 0x1e591c;
    entry_1e5914(rdram, ctx, runtime);
}

void entry_1e5920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5920 inside entry_1e5914 (0x1e5914 - 0x1e5938)
    ctx->pc = 0x1e5920;
    entry_1e5914(rdram, ctx, runtime);
}

void entry_1e5b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5b00 inside entry_1e5af8 (0x1e5af8 - 0x1e5b1c)
    ctx->pc = 0x1e5b00;
    entry_1e5af8(rdram, ctx, runtime);
}

void entry_1e5b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5b10 inside entry_1e5af8 (0x1e5af8 - 0x1e5b1c)
    ctx->pc = 0x1e5b10;
    entry_1e5af8(rdram, ctx, runtime);
}

void entry_1e5b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5b34 inside entry_1e5b1c (0x1e5b1c - 0x1e5be4)
    ctx->pc = 0x1e5b34;
    entry_1e5b1c(rdram, ctx, runtime);
}

void entry_1e5b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5b48 inside entry_1e5b1c (0x1e5b1c - 0x1e5be4)
    ctx->pc = 0x1e5b48;
    entry_1e5b1c(rdram, ctx, runtime);
}

void entry_1e5b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5b68 inside entry_1e5b1c (0x1e5b1c - 0x1e5be4)
    ctx->pc = 0x1e5b68;
    entry_1e5b1c(rdram, ctx, runtime);
}

void entry_1e5b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5b84 inside entry_1e5b1c (0x1e5b1c - 0x1e5be4)
    ctx->pc = 0x1e5b84;
    entry_1e5b1c(rdram, ctx, runtime);
}

void entry_1e5b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5b8c inside entry_1e5b1c (0x1e5b1c - 0x1e5be4)
    ctx->pc = 0x1e5b8c;
    entry_1e5b1c(rdram, ctx, runtime);
}

void entry_1e5b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5b98 inside entry_1e5b1c (0x1e5b1c - 0x1e5be4)
    ctx->pc = 0x1e5b98;
    entry_1e5b1c(rdram, ctx, runtime);
}

void entry_1e5bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5bac inside entry_1e5b1c (0x1e5b1c - 0x1e5be4)
    ctx->pc = 0x1e5bac;
    entry_1e5b1c(rdram, ctx, runtime);
}

void entry_1e5bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5bb8 inside entry_1e5b1c (0x1e5b1c - 0x1e5be4)
    ctx->pc = 0x1e5bb8;
    entry_1e5b1c(rdram, ctx, runtime);
}

void entry_1e5bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5bdc inside entry_1e5b1c (0x1e5b1c - 0x1e5be4)
    ctx->pc = 0x1e5bdc;
    entry_1e5b1c(rdram, ctx, runtime);
}

void entry_1e5c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5c48 inside entry_1e5c44 (0x1e5c44 - 0x1e5c78)
    ctx->pc = 0x1e5c48;
    entry_1e5c44(rdram, ctx, runtime);
}

void entry_1e5cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5cdc inside entry_1e5cd8 (0x1e5cd8 - 0x1e5ce8)
    ctx->pc = 0x1e5cdc;
    entry_1e5cd8(rdram, ctx, runtime);
}

void entry_1e5ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5ce0 inside entry_1e5cd8 (0x1e5cd8 - 0x1e5ce8)
    ctx->pc = 0x1e5ce0;
    entry_1e5cd8(rdram, ctx, runtime);
}

void entry_1e5d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5d50 inside entry_1e5d48 (0x1e5d48 - 0x1e5da8)
    ctx->pc = 0x1e5d50;
    entry_1e5d48(rdram, ctx, runtime);
}

void entry_1e5d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5d84 inside entry_1e5d48 (0x1e5d48 - 0x1e5da8)
    ctx->pc = 0x1e5d84;
    entry_1e5d48(rdram, ctx, runtime);
}

void entry_1e5d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5d90 inside entry_1e5d48 (0x1e5d48 - 0x1e5da8)
    ctx->pc = 0x1e5d90;
    entry_1e5d48(rdram, ctx, runtime);
}

void entry_1e5d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5d94 inside entry_1e5d48 (0x1e5d48 - 0x1e5da8)
    ctx->pc = 0x1e5d94;
    entry_1e5d48(rdram, ctx, runtime);
}

void entry_1e5df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5df0 inside entry_1e5de0 (0x1e5de0 - 0x1e5e08)
    ctx->pc = 0x1e5df0;
    entry_1e5de0(rdram, ctx, runtime);
}

void entry_1e5e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5e38 inside entry_1e5e30 (0x1e5e30 - 0x1e5e40)
    ctx->pc = 0x1e5e38;
    entry_1e5e30(rdram, ctx, runtime);
}

void entry_1e5e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5e44 inside entry_1e5e40 (0x1e5e40 - 0x1e5e50)
    ctx->pc = 0x1e5e44;
    entry_1e5e40(rdram, ctx, runtime);
}

void entry_1e5f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5f14 inside entry_1e5ee4 (0x1e5ee4 - 0x1e5fec)
    ctx->pc = 0x1e5f14;
    entry_1e5ee4(rdram, ctx, runtime);
}

void entry_1e5f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5f30 inside entry_1e5ee4 (0x1e5ee4 - 0x1e5fec)
    ctx->pc = 0x1e5f30;
    entry_1e5ee4(rdram, ctx, runtime);
}

void entry_1e5f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e5f80 inside entry_1e5ee4 (0x1e5ee4 - 0x1e5fec)
    ctx->pc = 0x1e5f80;
    entry_1e5ee4(rdram, ctx, runtime);
}

void entry_1e6024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6024 inside entry_1e6004 (0x1e6004 - 0x1e602c)
    ctx->pc = 0x1e6024;
    entry_1e6004(rdram, ctx, runtime);
}

void entry_1e6054(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6054 inside entry_1e6044 (0x1e6044 - 0x1e605c)
    ctx->pc = 0x1e6054;
    entry_1e6044(rdram, ctx, runtime);
}

void entry_1e6074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6074 inside entry_1e605c (0x1e605c - 0x1e60b4)
    ctx->pc = 0x1e6074;
    entry_1e605c(rdram, ctx, runtime);
}

void entry_1e60f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e60f4 inside entry_1e60d4 (0x1e60d4 - 0x1e611c)
    ctx->pc = 0x1e60f4;
    entry_1e60d4(rdram, ctx, runtime);
}

void entry_1e6140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6140 inside entry_1e6134 (0x1e6134 - 0x1e6148)
    ctx->pc = 0x1e6140;
    entry_1e6134(rdram, ctx, runtime);
}

void entry_1e641c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e641c inside entry_1e6414 (0x1e6414 - 0x1e642c)
    ctx->pc = 0x1e641c;
    entry_1e6414(rdram, ctx, runtime);
}

void entry_1e6538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6538 inside entry_1e650c (0x1e650c - 0x1e6580)
    ctx->pc = 0x1e6538;
    entry_1e650c(rdram, ctx, runtime);
}

void entry_1e65b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e65b4 inside entry_1e65a4 (0x1e65a4 - 0x1e6600)
    ctx->pc = 0x1e65b4;
    entry_1e65a4(rdram, ctx, runtime);
}

void entry_1e65b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e65b8 inside entry_1e65a4 (0x1e65a4 - 0x1e6600)
    ctx->pc = 0x1e65b8;
    entry_1e65a4(rdram, ctx, runtime);
}

void entry_1e66f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e66f8 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e66f8;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e6778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6778 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e6778;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e67b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e67b0 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e67b0;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e67d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e67d8 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e67d8;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e67f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e67f0 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e67f0;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e6828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6828 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e6828;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e6850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6850 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e6850;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e6868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6868 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e6868;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e68a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e68a0 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e68a0;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e68c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e68c8 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e68c8;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e68e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e68e0 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e68e0;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e6918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6918 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e6918;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e6940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6940 inside entry_1e66b0 (0x1e66b0 - 0x1e6964)
    ctx->pc = 0x1e6940;
    entry_1e66b0(rdram, ctx, runtime);
}

void entry_1e6a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6a40 inside entry_1e6a2c (0x1e6a2c - 0x1e6a50)
    ctx->pc = 0x1e6a40;
    entry_1e6a2c(rdram, ctx, runtime);
}

void entry_1e6a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6a98 inside entry_1e6a70 (0x1e6a70 - 0x1e6b68)
    ctx->pc = 0x1e6a98;
    entry_1e6a70(rdram, ctx, runtime);
}

void entry_1e6af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6af8 inside entry_1e6a70 (0x1e6a70 - 0x1e6b68)
    ctx->pc = 0x1e6af8;
    entry_1e6a70(rdram, ctx, runtime);
}

void entry_1e6afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6afc inside entry_1e6a70 (0x1e6a70 - 0x1e6b68)
    ctx->pc = 0x1e6afc;
    entry_1e6a70(rdram, ctx, runtime);
}

void entry_1e6b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6b10 inside entry_1e6a70 (0x1e6a70 - 0x1e6b68)
    ctx->pc = 0x1e6b10;
    entry_1e6a70(rdram, ctx, runtime);
}

void entry_1e6b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6b60 inside entry_1e6a70 (0x1e6a70 - 0x1e6b68)
    ctx->pc = 0x1e6b60;
    entry_1e6a70(rdram, ctx, runtime);
}

void entry_1e6bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6bb8 inside entry_1e6bb0 (0x1e6bb0 - 0x1e6c20)
    ctx->pc = 0x1e6bb8;
    entry_1e6bb0(rdram, ctx, runtime);
}

void entry_1e6bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6bcc inside entry_1e6bb0 (0x1e6bb0 - 0x1e6c20)
    ctx->pc = 0x1e6bcc;
    entry_1e6bb0(rdram, ctx, runtime);
}

void entry_1e6c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6c94 inside DrawTvOutline__FP2TVR4GIFS (0x1e6c20 - 0x1e6d48)
    ctx->pc = 0x1e6c94;
    DrawTvOutline__FP2TVR4GIFS(rdram, ctx, runtime);
}

void entry_1e6ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6ce4 inside DrawTvOutline__FP2TVR4GIFS (0x1e6c20 - 0x1e6d48)
    ctx->pc = 0x1e6ce4;
    DrawTvOutline__FP2TVR4GIFS(rdram, ctx, runtime);
}

void entry_1e6d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6d34 inside DrawTvOutline__FP2TVR4GIFS (0x1e6c20 - 0x1e6d48)
    ctx->pc = 0x1e6d34;
    DrawTvOutline__FP2TVR4GIFS(rdram, ctx, runtime);
}

void entry_1e6d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6d3c inside DrawTvOutline__FP2TVR4GIFS (0x1e6c20 - 0x1e6d48)
    ctx->pc = 0x1e6d3c;
    DrawTvOutline__FP2TVR4GIFS(rdram, ctx, runtime);
}

void entry_1e6d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6d90 inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6d90;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e6dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6dd0 inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6dd0;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e6e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6e10 inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6e10;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e6e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6e28 inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6e28;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e6e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6e6c inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6e6c;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e6eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6eac inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6eac;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e6ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6ec4 inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6ec4;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e6f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6f08 inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6f08;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e6f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6f48 inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6f48;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e6f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6f60 inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6f60;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e6fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6fa4 inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6fa4;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e6fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e6fe4 inside entry_1e6d48 (0x1e6d48 - 0x1e701c)
    ctx->pc = 0x1e6fe4;
    entry_1e6d48(rdram, ctx, runtime);
}

void entry_1e71a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e71a0 inside entry_1e716c (0x1e716c - 0x1e720c)
    ctx->pc = 0x1e71a0;
    entry_1e716c(rdram, ctx, runtime);
}

void entry_1e7250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7250 inside entry_1e7240 (0x1e7240 - 0x1e72e4)
    ctx->pc = 0x1e7250;
    entry_1e7240(rdram, ctx, runtime);
}

void entry_1e7458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7458 inside SetTvTvs__FP2TV3TVS (0x1e7440 - 0x1e7460)
    ctx->pc = 0x1e7458;
    SetTvTvs__FP2TV3TVS(rdram, ctx, runtime);
}

void entry_1e74a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e74a8 inside AcceptTvSpeaker__FP2TV (0x1e7460 - 0x1e74b4)
    ctx->pc = 0x1e74a8;
    AcceptTvSpeaker__FP2TV(rdram, ctx, runtime);
}

void entry_1e74b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e74b8 inside entry_1e74b4 (0x1e74b4 - 0x1e74d0)
    ctx->pc = 0x1e74b8;
    entry_1e74b4(rdram, ctx, runtime);
}

void entry_1e74f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e74f0 inside entry_1e74ec (0x1e74ec - 0x1e7518)
    ctx->pc = 0x1e74f0;
    entry_1e74ec(rdram, ctx, runtime);
}

void entry_1e7504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7504 inside entry_1e74ec (0x1e74ec - 0x1e7518)
    ctx->pc = 0x1e7504;
    entry_1e74ec(rdram, ctx, runtime);
}

void entry_1e7508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7508 inside entry_1e74ec (0x1e74ec - 0x1e7518)
    ctx->pc = 0x1e7508;
    entry_1e74ec(rdram, ctx, runtime);
}

void entry_1e7574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7574 inside SetTvTvgs__FP2TV4TVGS (0x1e7518 - 0x1e75dc)
    ctx->pc = 0x1e7574;
    SetTvTvgs__FP2TV4TVGS(rdram, ctx, runtime);
}

void entry_1e758c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e758c inside SetTvTvgs__FP2TV4TVGS (0x1e7518 - 0x1e75dc)
    ctx->pc = 0x1e758c;
    SetTvTvgs__FP2TV4TVGS(rdram, ctx, runtime);
}

void entry_1e75f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e75f8 inside entry_1e75dc (0x1e75dc - 0x1e7614)
    ctx->pc = 0x1e75f8;
    entry_1e75dc(rdram, ctx, runtime);
}

void entry_1e7634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7634 inside entry_1e7614 (0x1e7614 - 0x1e7678)
    ctx->pc = 0x1e7634;
    entry_1e7614(rdram, ctx, runtime);
}

void entry_1e7680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7680 inside entry_1e7678 (0x1e7678 - 0x1e76a0)
    ctx->pc = 0x1e7680;
    entry_1e7678(rdram, ctx, runtime);
}

void entry_1e7694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7694 inside entry_1e7678 (0x1e7678 - 0x1e76a0)
    ctx->pc = 0x1e7694;
    entry_1e7678(rdram, ctx, runtime);
}

void entry_1e76a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e76a4 inside entry_1e76a0 (0x1e76a0 - 0x1e76e0)
    ctx->pc = 0x1e76a4;
    entry_1e76a0(rdram, ctx, runtime);
}

void entry_1e76b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e76b0 inside entry_1e76a0 (0x1e76a0 - 0x1e76e0)
    ctx->pc = 0x1e76b0;
    entry_1e76a0(rdram, ctx, runtime);
}

void entry_1e774c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e774c inside entry_1e7744 (0x1e7744 - 0x1e7774)
    ctx->pc = 0x1e774c;
    entry_1e7744(rdram, ctx, runtime);
}

void entry_1e7778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7778 inside entry_1e7774 (0x1e7774 - 0x1e77a4)
    ctx->pc = 0x1e7778;
    entry_1e7774(rdram, ctx, runtime);
}

void entry_1e77a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e77a8 inside entry_1e77a4 (0x1e77a4 - 0x1e77c0)
    ctx->pc = 0x1e77a8;
    entry_1e77a4(rdram, ctx, runtime);
}

void entry_1e7828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7828 inside entry_1e77fc (0x1e77fc - 0x1e7944)
    ctx->pc = 0x1e7828;
    entry_1e77fc(rdram, ctx, runtime);
}

void entry_1e7838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7838 inside entry_1e77fc (0x1e77fc - 0x1e7944)
    ctx->pc = 0x1e7838;
    entry_1e77fc(rdram, ctx, runtime);
}

void entry_1e7848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7848 inside entry_1e77fc (0x1e77fc - 0x1e7944)
    ctx->pc = 0x1e7848;
    entry_1e77fc(rdram, ctx, runtime);
}

void entry_1e785c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e785c inside entry_1e77fc (0x1e77fc - 0x1e7944)
    ctx->pc = 0x1e785c;
    entry_1e77fc(rdram, ctx, runtime);
}

void entry_1e787c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e787c inside entry_1e77fc (0x1e77fc - 0x1e7944)
    ctx->pc = 0x1e787c;
    entry_1e77fc(rdram, ctx, runtime);
}

void entry_1e788c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e788c inside entry_1e77fc (0x1e77fc - 0x1e7944)
    ctx->pc = 0x1e788c;
    entry_1e77fc(rdram, ctx, runtime);
}

void entry_1e78cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e78cc inside entry_1e77fc (0x1e77fc - 0x1e7944)
    ctx->pc = 0x1e78cc;
    entry_1e77fc(rdram, ctx, runtime);
}

void entry_1e7908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7908 inside entry_1e77fc (0x1e77fc - 0x1e7944)
    ctx->pc = 0x1e7908;
    entry_1e77fc(rdram, ctx, runtime);
}

void entry_1e7918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7918 inside entry_1e77fc (0x1e77fc - 0x1e7944)
    ctx->pc = 0x1e7918;
    entry_1e77fc(rdram, ctx, runtime);
}

void entry_1e7920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7920 inside entry_1e77fc (0x1e77fc - 0x1e7944)
    ctx->pc = 0x1e7920;
    entry_1e77fc(rdram, ctx, runtime);
}

void entry_1e79d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e79d0 inside entry_1e79b0 (0x1e79b0 - 0x1e79f8)
    ctx->pc = 0x1e79d0;
    entry_1e79b0(rdram, ctx, runtime);
}

void entry_1e7a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7a1c inside entry_1e7a10 (0x1e7a10 - 0x1e7a24)
    ctx->pc = 0x1e7a1c;
    entry_1e7a10(rdram, ctx, runtime);
}

void entry_1e7a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7a28 inside entry_1e7a24 (0x1e7a24 - 0x1e7a64)
    ctx->pc = 0x1e7a28;
    entry_1e7a24(rdram, ctx, runtime);
}

void entry_1e7a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7a78 inside entry_1e7a64 (0x1e7a64 - 0x1e7b28)
    ctx->pc = 0x1e7a78;
    entry_1e7a64(rdram, ctx, runtime);
}

void entry_1e7ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7ab4 inside entry_1e7a64 (0x1e7a64 - 0x1e7b28)
    ctx->pc = 0x1e7ab4;
    entry_1e7a64(rdram, ctx, runtime);
}

void entry_1e7ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7ac4 inside entry_1e7a64 (0x1e7a64 - 0x1e7b28)
    ctx->pc = 0x1e7ac4;
    entry_1e7a64(rdram, ctx, runtime);
}

void entry_1e7b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7b10 inside entry_1e7a64 (0x1e7a64 - 0x1e7b28)
    ctx->pc = 0x1e7b10;
    entry_1e7a64(rdram, ctx, runtime);
}

void entry_1e7b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7b88 inside entry_1e7b68 (0x1e7b68 - 0x1e7b90)
    ctx->pc = 0x1e7b88;
    entry_1e7b68(rdram, ctx, runtime);
}

void entry_1e7bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7bb8 inside entry_1e7ba8 (0x1e7ba8 - 0x1e7bc0)
    ctx->pc = 0x1e7bb8;
    entry_1e7ba8(rdram, ctx, runtime);
}

void entry_1e7be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7be0 inside entry_1e7bd8 (0x1e7bd8 - 0x1e7bf4)
    ctx->pc = 0x1e7be0;
    entry_1e7bd8(rdram, ctx, runtime);
}

void entry_1e7bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7bf8 inside entry_1e7bf4 (0x1e7bf4 - 0x1e7c1c)
    ctx->pc = 0x1e7bf8;
    entry_1e7bf4(rdram, ctx, runtime);
}

void entry_1e7c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7c08 inside entry_1e7bf4 (0x1e7bf4 - 0x1e7c1c)
    ctx->pc = 0x1e7c08;
    entry_1e7bf4(rdram, ctx, runtime);
}

void entry_1e7c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7c0c inside entry_1e7bf4 (0x1e7bf4 - 0x1e7c1c)
    ctx->pc = 0x1e7c0c;
    entry_1e7bf4(rdram, ctx, runtime);
}

void entry_1e7cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7cc8 inside RenderTv__FP2TV (0x1e7c60 - 0x1e7cd0)
    ctx->pc = 0x1e7cc8;
    RenderTv__FP2TV(rdram, ctx, runtime);
}

void entry_1e7cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7cd8 inside entry_1e7cd0 (0x1e7cd0 - 0x1e7ce4)
    ctx->pc = 0x1e7cd8;
    entry_1e7cd0(rdram, ctx, runtime);
}

void entry_1e7e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7e00 inside entry_1e7dc8 (0x1e7dc8 - 0x1e7ef8)
    ctx->pc = 0x1e7e00;
    entry_1e7dc8(rdram, ctx, runtime);
}

void entry_1e7e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7e10 inside entry_1e7dc8 (0x1e7dc8 - 0x1e7ef8)
    ctx->pc = 0x1e7e10;
    entry_1e7dc8(rdram, ctx, runtime);
}

void entry_1e7e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7e4c inside entry_1e7dc8 (0x1e7dc8 - 0x1e7ef8)
    ctx->pc = 0x1e7e4c;
    entry_1e7dc8(rdram, ctx, runtime);
}

void entry_1e7e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7e80 inside entry_1e7dc8 (0x1e7dc8 - 0x1e7ef8)
    ctx->pc = 0x1e7e80;
    entry_1e7dc8(rdram, ctx, runtime);
}

void entry_1e7e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7e88 inside entry_1e7dc8 (0x1e7dc8 - 0x1e7ef8)
    ctx->pc = 0x1e7e88;
    entry_1e7dc8(rdram, ctx, runtime);
}

void entry_1e7e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7e98 inside entry_1e7dc8 (0x1e7dc8 - 0x1e7ef8)
    ctx->pc = 0x1e7e98;
    entry_1e7dc8(rdram, ctx, runtime);
}

void entry_1e7f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7f64 inside entry_1e7f5c (0x1e7f5c - 0x1e7f7c)
    ctx->pc = 0x1e7f64;
    entry_1e7f5c(rdram, ctx, runtime);
}

void entry_1e7fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e7fb0 inside entry_1e7fac (0x1e7fac - 0x1e7fcc)
    ctx->pc = 0x1e7fb0;
    entry_1e7fac(rdram, ctx, runtime);
}

void entry_1e80ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e80ac inside entry_1e80a4 (0x1e80a4 - 0x1e80d8)
    ctx->pc = 0x1e80ac;
    entry_1e80a4(rdram, ctx, runtime);
}

void entry_1e80b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e80b0 inside entry_1e80a4 (0x1e80a4 - 0x1e80d8)
    ctx->pc = 0x1e80b0;
    entry_1e80a4(rdram, ctx, runtime);
}

void entry_1e80b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e80b4 inside entry_1e80a4 (0x1e80a4 - 0x1e80d8)
    ctx->pc = 0x1e80b4;
    entry_1e80a4(rdram, ctx, runtime);
}

void entry_1e8194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8194 inside entry_1e818c (0x1e818c - 0x1e819c)
    ctx->pc = 0x1e8194;
    entry_1e818c(rdram, ctx, runtime);
}

void entry_1e86a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e86a4 inside entry_1e86a0 (0x1e86a0 - 0x1e86e0)
    ctx->pc = 0x1e86a4;
    entry_1e86a0(rdram, ctx, runtime);
}

void entry_1e8780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8780 inside entry_1e8778 (0x1e8778 - 0x1e8790)
    ctx->pc = 0x1e8780;
    entry_1e8778(rdram, ctx, runtime);
}

void entry_1e87bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e87bc inside entry_1e87b4 (0x1e87b4 - 0x1e87d8)
    ctx->pc = 0x1e87bc;
    entry_1e87b4(rdram, ctx, runtime);
}

void entry_1e87dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e87dc inside entry_1e87d8 (0x1e87d8 - 0x1e87f0)
    ctx->pc = 0x1e87dc;
    entry_1e87d8(rdram, ctx, runtime);
}

void entry_1e881c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e881c inside SetTvReplace__FP2TVP3ALO (0x1e87f0 - 0x1e8840)
    ctx->pc = 0x1e881c;
    SetTvReplace__FP2TVP3ALO(rdram, ctx, runtime);
}

void entry_1e8838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8838 inside SetTvReplace__FP2TVP3ALO (0x1e87f0 - 0x1e8840)
    ctx->pc = 0x1e8838;
    SetTvReplace__FP2TVP3ALO(rdram, ctx, runtime);
}

void entry_1e88a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e88a4 inside tv__static_initialization_and_destruction_0 (0x1e8878 - 0x1e88b0)
    ctx->pc = 0x1e88a4;
    tv__static_initialization_and_destruction_0(rdram, ctx, runtime);
}

void entry_1e899c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e899c inside entry_1e8998 (0x1e8998 - 0x1e89bc)
    ctx->pc = 0x1e899c;
    entry_1e8998(rdram, ctx, runtime);
}

void entry_1e89b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e89b0 inside entry_1e8998 (0x1e8998 - 0x1e89bc)
    ctx->pc = 0x1e89b0;
    entry_1e8998(rdram, ctx, runtime);
}

void entry_1e8a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8a08 inside PsoPadUbgClosest__FP3UBGP6VECTOR (0x1e89f0 - 0x1e8a50)
    ctx->pc = 0x1e8a08;
    PsoPadUbgClosest__FP3UBGP6VECTOR(rdram, ctx, runtime);
}

void entry_1e8a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8a3c inside PsoPadUbgClosest__FP3UBGP6VECTOR (0x1e89f0 - 0x1e8a50)
    ctx->pc = 0x1e8a3c;
    PsoPadUbgClosest__FP3UBGP6VECTOR(rdram, ctx, runtime);
}

void entry_1e8ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8ae8 inside entry_1e8ae4 (0x1e8ae4 - 0x1e8b50)
    ctx->pc = 0x1e8ae8;
    entry_1e8ae4(rdram, ctx, runtime);
}

void entry_1e8af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8af8 inside entry_1e8ae4 (0x1e8ae4 - 0x1e8b50)
    ctx->pc = 0x1e8af8;
    entry_1e8ae4(rdram, ctx, runtime);
}

void entry_1e8b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8b44 inside entry_1e8ae4 (0x1e8ae4 - 0x1e8b50)
    ctx->pc = 0x1e8b44;
    entry_1e8ae4(rdram, ctx, runtime);
}

void entry_1e8b74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8b74 inside entry_1e8b60 (0x1e8b60 - 0x1e8c60)
    ctx->pc = 0x1e8b74;
    entry_1e8b60(rdram, ctx, runtime);
}

void entry_1e8bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8bc4 inside entry_1e8b60 (0x1e8b60 - 0x1e8c60)
    ctx->pc = 0x1e8bc4;
    entry_1e8b60(rdram, ctx, runtime);
}

void entry_1e8bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8bf8 inside entry_1e8b60 (0x1e8b60 - 0x1e8c60)
    ctx->pc = 0x1e8bf8;
    entry_1e8b60(rdram, ctx, runtime);
}

void entry_1e8c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8c14 inside entry_1e8b60 (0x1e8b60 - 0x1e8c60)
    ctx->pc = 0x1e8c14;
    entry_1e8b60(rdram, ctx, runtime);
}

void entry_1e8c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8c20 inside entry_1e8b60 (0x1e8b60 - 0x1e8c60)
    ctx->pc = 0x1e8c20;
    entry_1e8b60(rdram, ctx, runtime);
}

void entry_1e8c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8c2c inside entry_1e8b60 (0x1e8b60 - 0x1e8c60)
    ctx->pc = 0x1e8c2c;
    entry_1e8b60(rdram, ctx, runtime);
}

void entry_1e8c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8c34 inside entry_1e8b60 (0x1e8b60 - 0x1e8c60)
    ctx->pc = 0x1e8c34;
    entry_1e8b60(rdram, ctx, runtime);
}

void entry_1e8c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8c3c inside entry_1e8b60 (0x1e8b60 - 0x1e8c60)
    ctx->pc = 0x1e8c3c;
    entry_1e8b60(rdram, ctx, runtime);
}

void entry_1e8c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8c40 inside entry_1e8b60 (0x1e8b60 - 0x1e8c60)
    ctx->pc = 0x1e8c40;
    entry_1e8b60(rdram, ctx, runtime);
}

void entry_1e8c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8c48 inside entry_1e8b60 (0x1e8b60 - 0x1e8c60)
    ctx->pc = 0x1e8c48;
    entry_1e8b60(rdram, ctx, runtime);
}

void entry_1e8c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8c7c inside entry_1e8c78 (0x1e8c78 - 0x1e8c84)
    ctx->pc = 0x1e8c7c;
    entry_1e8c78(rdram, ctx, runtime);
}

void entry_1e8cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8cbc inside entry_1e8cb8 (0x1e8cb8 - 0x1e8ccc)
    ctx->pc = 0x1e8cbc;
    entry_1e8cb8(rdram, ctx, runtime);
}

void entry_1e8cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8cc0 inside entry_1e8cb8 (0x1e8cb8 - 0x1e8ccc)
    ctx->pc = 0x1e8cc0;
    entry_1e8cb8(rdram, ctx, runtime);
}

void entry_1e8d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8d1c inside entry_1e8d10 (0x1e8d10 - 0x1e8d2c)
    ctx->pc = 0x1e8d1c;
    entry_1e8d10(rdram, ctx, runtime);
}

void entry_1e8d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8d20 inside entry_1e8d10 (0x1e8d10 - 0x1e8d2c)
    ctx->pc = 0x1e8d20;
    entry_1e8d10(rdram, ctx, runtime);
}

void entry_1e8d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8d7c inside SgsNextUbgAI__FP3UBG (0x1e8d58 - 0x1e8d9c)
    ctx->pc = 0x1e8d7c;
    SgsNextUbgAI__FP3UBG(rdram, ctx, runtime);
}

void entry_1e8d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8d94 inside SgsNextUbgAI__FP3UBG (0x1e8d58 - 0x1e8d9c)
    ctx->pc = 0x1e8d94;
    SgsNextUbgAI__FP3UBG(rdram, ctx, runtime);
}

void entry_1e8da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8da0 inside entry_1e8d9c (0x1e8d9c - 0x1e8db0)
    ctx->pc = 0x1e8da0;
    entry_1e8d9c(rdram, ctx, runtime);
}

void entry_1e8dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8dc8 inside FDetectUbg__FP3UBG (0x1e8db0 - 0x1e8dd0)
    ctx->pc = 0x1e8dc8;
    FDetectUbg__FP3UBG(rdram, ctx, runtime);
}

void entry_1e8de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8de0 inside FCanUbgAttack__FP3UBG (0x1e8dd0 - 0x1e8e08)
    ctx->pc = 0x1e8de0;
    FCanUbgAttack__FP3UBG(rdram, ctx, runtime);
}

void entry_1e8de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8de8 inside FCanUbgAttack__FP3UBG (0x1e8dd0 - 0x1e8e08)
    ctx->pc = 0x1e8de8;
    FCanUbgAttack__FP3UBG(rdram, ctx, runtime);
}

void entry_1e8e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8e34 inside DoUbgFreefallJump__FP3UBG (0x1e8e08 - 0x1e8e3c)
    ctx->pc = 0x1e8e34;
    DoUbgFreefallJump__FP3UBG(rdram, ctx, runtime);
}

void entry_1e8ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8ed8 inside entry_1e8ed4 (0x1e8ed4 - 0x1e8ee0)
    ctx->pc = 0x1e8ed8;
    entry_1e8ed4(rdram, ctx, runtime);
}

void entry_1e8f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8f28 inside UpdateUbgGoal__FP3UBGi (0x1e8ef8 - 0x1e8f3c)
    ctx->pc = 0x1e8f28;
    UpdateUbgGoal__FP3UBGi(rdram, ctx, runtime);
}

void entry_1e8f44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8f44 inside entry_1e8f3c (0x1e8f3c - 0x1e8f50)
    ctx->pc = 0x1e8f44;
    entry_1e8f3c(rdram, ctx, runtime);
}

void entry_1e8f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8f64 inside entry_1e8f5c (0x1e8f5c - 0x1e8f70)
    ctx->pc = 0x1e8f64;
    entry_1e8f5c(rdram, ctx, runtime);
}

void entry_1e8f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8f8c inside entry_1e8f84 (0x1e8f84 - 0x1e8f94)
    ctx->pc = 0x1e8f8c;
    entry_1e8f84(rdram, ctx, runtime);
}

void entry_1e8f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8f98 inside entry_1e8f94 (0x1e8f94 - 0x1e8fa8)
    ctx->pc = 0x1e8f98;
    entry_1e8f94(rdram, ctx, runtime);
}

void entry_1e8fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8fd0 inside entry_1e8fc8 (0x1e8fc8 - 0x1e8fd8)
    ctx->pc = 0x1e8fd0;
    entry_1e8fc8(rdram, ctx, runtime);
}

void entry_1e8fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e8fdc inside entry_1e8fd8 (0x1e8fd8 - 0x1e8fe8)
    ctx->pc = 0x1e8fdc;
    entry_1e8fd8(rdram, ctx, runtime);
}

void entry_1e9018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9018 inside entry_1e9010 (0x1e9010 - 0x1e9028)
    ctx->pc = 0x1e9018;
    entry_1e9010(rdram, ctx, runtime);
}

void entry_1e902c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e902c inside entry_1e9028 (0x1e9028 - 0x1e9038)
    ctx->pc = 0x1e902c;
    entry_1e9028(rdram, ctx, runtime);
}

void entry_1e9050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9050 inside FIgnoreUbgIntersection__FP3UBGP2SO (0x1e9038 - 0x1e9078)
    ctx->pc = 0x1e9050;
    FIgnoreUbgIntersection__FP3UBGP2SO(rdram, ctx, runtime);
}

void entry_1e9064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9064 inside FIgnoreUbgIntersection__FP3UBGP2SO (0x1e9038 - 0x1e9078)
    ctx->pc = 0x1e9064;
    FIgnoreUbgIntersection__FP3UBGP2SO(rdram, ctx, runtime);
}

void entry_1e9168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9168 inside UpdateUi__FP2UI (0x1e9108 - 0x1e91b4)
    ctx->pc = 0x1e9168;
    UpdateUi__FP2UI(rdram, ctx, runtime);
}

void entry_1e9170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9170 inside UpdateUi__FP2UI (0x1e9108 - 0x1e91b4)
    ctx->pc = 0x1e9170;
    UpdateUi__FP2UI(rdram, ctx, runtime);
}

void entry_1e91b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e91b8 inside entry_1e91b4 (0x1e91b4 - 0x1e922c)
    ctx->pc = 0x1e91b8;
    entry_1e91b4(rdram, ctx, runtime);
}

void entry_1e9218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9218 inside entry_1e91b4 (0x1e91b4 - 0x1e922c)
    ctx->pc = 0x1e9218;
    entry_1e91b4(rdram, ctx, runtime);
}

void entry_1e921c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e921c inside entry_1e91b4 (0x1e91b4 - 0x1e922c)
    ctx->pc = 0x1e921c;
    entry_1e91b4(rdram, ctx, runtime);
}

void entry_1e9278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9278 inside entry_1e9270 (0x1e9270 - 0x1e9284)
    ctx->pc = 0x1e9278;
    entry_1e9270(rdram, ctx, runtime);
}

void entry_1e9294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9294 inside entry_1e928c (0x1e928c - 0x1e92a8)
    ctx->pc = 0x1e9294;
    entry_1e928c(rdram, ctx, runtime);
}

void entry_1e932c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e932c inside entry_1e92bc (0x1e92bc - 0x1e933c)
    ctx->pc = 0x1e932c;
    entry_1e92bc(rdram, ctx, runtime);
}

void entry_1e9354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9354 inside entry_1e934c (0x1e934c - 0x1e9380)
    ctx->pc = 0x1e9354;
    entry_1e934c(rdram, ctx, runtime);
}

void entry_1e93d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e93d0 inside entry_1e93c8 (0x1e93c8 - 0x1e93fc)
    ctx->pc = 0x1e93d0;
    entry_1e93c8(rdram, ctx, runtime);
}

void entry_1e9408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9408 inside entry_1e93fc (0x1e93fc - 0x1e9414)
    ctx->pc = 0x1e9408;
    entry_1e93fc(rdram, ctx, runtime);
}

void entry_1e940c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e940c inside entry_1e93fc (0x1e93fc - 0x1e9414)
    ctx->pc = 0x1e940c;
    entry_1e93fc(rdram, ctx, runtime);
}

void entry_1e9450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9450 inside entry_1e9448 (0x1e9448 - 0x1e9460)
    ctx->pc = 0x1e9450;
    entry_1e9448(rdram, ctx, runtime);
}

void entry_1e94dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e94dc inside entry_1e94d4 (0x1e94d4 - 0x1e950c)
    ctx->pc = 0x1e94dc;
    entry_1e94d4(rdram, ctx, runtime);
}

void entry_1e9510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9510 inside entry_1e950c (0x1e950c - 0x1e9524)
    ctx->pc = 0x1e9510;
    entry_1e950c(rdram, ctx, runtime);
}

void entry_1e9558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9558 inside entry_1e9554 (0x1e9554 - 0x1e9570)
    ctx->pc = 0x1e9558;
    entry_1e9554(rdram, ctx, runtime);
}

void entry_1e95d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e95d8 inside entry_1e95d4 (0x1e95d4 - 0x1e9608)
    ctx->pc = 0x1e95d8;
    entry_1e95d4(rdram, ctx, runtime);
}

void entry_1e9630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9630 inside entry_1e962c (0x1e962c - 0x1e9648)
    ctx->pc = 0x1e9630;
    entry_1e962c(rdram, ctx, runtime);
}

void entry_1e96a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e96a0 inside ResetUi__FP2UI (0x1e9688 - 0x1e96a8)
    ctx->pc = 0x1e96a0;
    ResetUi__FP2UI(rdram, ctx, runtime);
}

void entry_1e9728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9728 inside SetUiUis__FP2UI3UIS (0x1e96f8 - 0x1e9758)
    ctx->pc = 0x1e9728;
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime);
}

void entry_1e977c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e977c inside entry_1e9778 (0x1e9778 - 0x1e97c8)
    ctx->pc = 0x1e977c;
    entry_1e9778(rdram, ctx, runtime);
}

void entry_1e97cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e97cc inside entry_1e97c8 (0x1e97c8 - 0x1e97d8)
    ctx->pc = 0x1e97cc;
    entry_1e97c8(rdram, ctx, runtime);
}

void entry_1e9870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9870 inside entry_1e985c (0x1e985c - 0x1e9878)
    ctx->pc = 0x1e9870;
    entry_1e985c(rdram, ctx, runtime);
}

void entry_1e98d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e98d4 inside entry_1e98d0 (0x1e98d0 - 0x1e98e8)
    ctx->pc = 0x1e98d4;
    entry_1e98d0(rdram, ctx, runtime);
}

void entry_1e99bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e99bc inside entry_1e9990 (0x1e9990 - 0x1e9a10)
    ctx->pc = 0x1e99bc;
    entry_1e9990(rdram, ctx, runtime);
}

void entry_1e99fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e99fc inside entry_1e9990 (0x1e9990 - 0x1e9a10)
    ctx->pc = 0x1e99fc;
    entry_1e9990(rdram, ctx, runtime);
}

void entry_1e9a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9a00 inside entry_1e9990 (0x1e9990 - 0x1e9a10)
    ctx->pc = 0x1e9a00;
    entry_1e9990(rdram, ctx, runtime);
}

void entry_1e9a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9a58 inside FUN_001e9a10__Fv (0x1e9a10 - 0x1e9a68)
    ctx->pc = 0x1e9a58;
    FUN_001e9a10__Fv(rdram, ctx, runtime);
}

void entry_1e9a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9a60 inside FUN_001e9a10__Fv (0x1e9a10 - 0x1e9a68)
    ctx->pc = 0x1e9a60;
    FUN_001e9a10__Fv(rdram, ctx, runtime);
}

void entry_1e9ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9ac8 inside FUN_001e9a68__Fv (0x1e9a68 - 0x1e9ad8)
    ctx->pc = 0x1e9ac8;
    FUN_001e9a68__Fv(rdram, ctx, runtime);
}

void entry_1e9ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9ad0 inside FUN_001e9a68__Fv (0x1e9a68 - 0x1e9ad8)
    ctx->pc = 0x1e9ad0;
    FUN_001e9a68__Fv(rdram, ctx, runtime);
}

void entry_1e9b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9b20 inside FUN_001e9ad8__Fv (0x1e9ad8 - 0x1e9b30)
    ctx->pc = 0x1e9b20;
    FUN_001e9ad8__Fv(rdram, ctx, runtime);
}

void entry_1e9b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9b28 inside FUN_001e9ad8__Fv (0x1e9ad8 - 0x1e9b30)
    ctx->pc = 0x1e9b28;
    FUN_001e9ad8__Fv(rdram, ctx, runtime);
}

void entry_1e9b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9b7c inside check_anticrack_collectibles_Fv (0x1e9b30 - 0x1e9c78)
    ctx->pc = 0x1e9b7c;
    check_anticrack_collectibles_Fv(rdram, ctx, runtime);
}

void entry_1e9b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9b88 inside check_anticrack_collectibles_Fv (0x1e9b30 - 0x1e9c78)
    ctx->pc = 0x1e9b88;
    check_anticrack_collectibles_Fv(rdram, ctx, runtime);
}

void entry_1e9bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9bb8 inside check_anticrack_collectibles_Fv (0x1e9b30 - 0x1e9c78)
    ctx->pc = 0x1e9bb8;
    check_anticrack_collectibles_Fv(rdram, ctx, runtime);
}

void entry_1e9c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9c50 inside check_anticrack_collectibles_Fv (0x1e9b30 - 0x1e9c78)
    ctx->pc = 0x1e9c50;
    check_anticrack_collectibles_Fv(rdram, ctx, runtime);
}

void entry_1e9c6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9c6c inside check_anticrack_collectibles_Fv (0x1e9b30 - 0x1e9c78)
    ctx->pc = 0x1e9c6c;
    check_anticrack_collectibles_Fv(rdram, ctx, runtime);
}

void entry_1e9cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9cdc inside entry_1e9ca8 (0x1e9ca8 - 0x1e9cf0)
    ctx->pc = 0x1e9cdc;
    entry_1e9ca8(rdram, ctx, runtime);
}

void entry_1e9ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9ce4 inside entry_1e9ca8 (0x1e9ca8 - 0x1e9cf0)
    ctx->pc = 0x1e9ce4;
    entry_1e9ca8(rdram, ctx, runtime);
}

void entry_1e9cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9cf4 inside entry_1e9cf0 (0x1e9cf0 - 0x1e9cfc)
    ctx->pc = 0x1e9cf4;
    entry_1e9cf0(rdram, ctx, runtime);
}

void entry_1e9d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9d40 inside entry_1e9cfc (0x1e9cfc - 0x1e9d48)
    ctx->pc = 0x1e9d40;
    entry_1e9cfc(rdram, ctx, runtime);
}

void entry_1e9d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9d60 inside entry_1e9d48 (0x1e9d48 - 0x1e9d8c)
    ctx->pc = 0x1e9d60;
    entry_1e9d48(rdram, ctx, runtime);
}

void entry_1e9d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9d80 inside entry_1e9d48 (0x1e9d48 - 0x1e9d8c)
    ctx->pc = 0x1e9d80;
    entry_1e9d48(rdram, ctx, runtime);
}

void entry_1e9da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9da8 inside entry_1e9d8c (0x1e9d8c - 0x1e9dd4)
    ctx->pc = 0x1e9da8;
    entry_1e9d8c(rdram, ctx, runtime);
}

void entry_1e9dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9dc8 inside entry_1e9d8c (0x1e9d8c - 0x1e9dd4)
    ctx->pc = 0x1e9dc8;
    entry_1e9d8c(rdram, ctx, runtime);
}

void entry_1e9df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9df0 inside entry_1e9dd4 (0x1e9dd4 - 0x1e9e00)
    ctx->pc = 0x1e9df0;
    entry_1e9dd4(rdram, ctx, runtime);
}

void entry_1e9e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9e58 inside UpdateSwPosWorldPrev__FP2SW (0x1e9e30 - 0x1e9ea4)
    ctx->pc = 0x1e9e58;
    UpdateSwPosWorldPrev__FP2SW(rdram, ctx, runtime);
}

void entry_1e9e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9e88 inside UpdateSwPosWorldPrev__FP2SW (0x1e9e30 - 0x1e9ea4)
    ctx->pc = 0x1e9e88;
    UpdateSwPosWorldPrev__FP2SW(rdram, ctx, runtime);
}

void entry_1e9ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9ea8 inside entry_1e9ea4 (0x1e9ea4 - 0x1e9ee8)
    ctx->pc = 0x1e9ea8;
    entry_1e9ea4(rdram, ctx, runtime);
}

void entry_1e9ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9ec0 inside entry_1e9ea4 (0x1e9ea4 - 0x1e9ee8)
    ctx->pc = 0x1e9ec0;
    entry_1e9ea4(rdram, ctx, runtime);
}

void entry_1e9ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9ecc inside entry_1e9ea4 (0x1e9ea4 - 0x1e9ee8)
    ctx->pc = 0x1e9ecc;
    entry_1e9ea4(rdram, ctx, runtime);
}

void entry_1e9f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9f60 inside UpdateSwRealClock__FP2SWf (0x1e9ee8 - 0x1e9f6c)
    ctx->pc = 0x1e9f60;
    UpdateSwRealClock__FP2SWf(rdram, ctx, runtime);
}

void entry_1e9f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9f88 inside entry_1e9f6c (0x1e9f6c - 0x1e9fb4)
    ctx->pc = 0x1e9f88;
    entry_1e9f6c(rdram, ctx, runtime);
}

void entry_1e9fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9fa8 inside entry_1e9f6c (0x1e9f6c - 0x1e9fb4)
    ctx->pc = 0x1e9fa8;
    entry_1e9f6c(rdram, ctx, runtime);
}

void entry_1e9fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9fd0 inside entry_1e9fb4 (0x1e9fb4 - 0x1e9ffc)
    ctx->pc = 0x1e9fd0;
    entry_1e9fb4(rdram, ctx, runtime);
}

void entry_1e9ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1e9ff0 inside entry_1e9fb4 (0x1e9fb4 - 0x1e9ffc)
    ctx->pc = 0x1e9ff0;
    entry_1e9fb4(rdram, ctx, runtime);
}

void entry_1ea018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea018 inside entry_1e9ffc (0x1e9ffc - 0x1ea058)
    ctx->pc = 0x1ea018;
    entry_1e9ffc(rdram, ctx, runtime);
}

void entry_1ea040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea040 inside entry_1e9ffc (0x1e9ffc - 0x1ea058)
    ctx->pc = 0x1ea040;
    entry_1e9ffc(rdram, ctx, runtime);
}

void entry_1ea074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea074 inside entry_1ea058 (0x1ea058 - 0x1ea084)
    ctx->pc = 0x1ea074;
    entry_1ea058(rdram, ctx, runtime);
}

void entry_1ea0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea0e0 inside UpdateSwDarkening__FP2SWf (0x1ea0a8 - 0x1ea100)
    ctx->pc = 0x1ea0e0;
    UpdateSwDarkening__FP2SWf(rdram, ctx, runtime);
}

void entry_1ea0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea0f8 inside UpdateSwDarkening__FP2SWf (0x1ea0a8 - 0x1ea100)
    ctx->pc = 0x1ea0f8;
    UpdateSwDarkening__FP2SWf(rdram, ctx, runtime);
}

void entry_1ea104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea104 inside entry_1ea100 (0x1ea100 - 0x1ea118)
    ctx->pc = 0x1ea104;
    entry_1ea100(rdram, ctx, runtime);
}

void entry_1ea1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea1d8 inside entry_1ea1a0 (0x1ea1a0 - 0x1ea1f0)
    ctx->pc = 0x1ea1d8;
    entry_1ea1a0(rdram, ctx, runtime);
}

void entry_1ea1f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea1f4 inside entry_1ea1f0 (0x1ea1f0 - 0x1ea21c)
    ctx->pc = 0x1ea1f4;
    entry_1ea1f0(rdram, ctx, runtime);
}

void entry_1ea208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea208 inside entry_1ea1f0 (0x1ea1f0 - 0x1ea21c)
    ctx->pc = 0x1ea208;
    entry_1ea1f0(rdram, ctx, runtime);
}

void entry_1ea260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea260 inside entry_1ea230 (0x1ea230 - 0x1ea278)
    ctx->pc = 0x1ea260;
    entry_1ea230(rdram, ctx, runtime);
}

void entry_1ea290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea290 inside entry_1ea278 (0x1ea278 - 0x1ea298)
    ctx->pc = 0x1ea290;
    entry_1ea278(rdram, ctx, runtime);
}

void entry_1ea29c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea29c inside entry_1ea298 (0x1ea298 - 0x1ea2f8)
    ctx->pc = 0x1ea29c;
    entry_1ea298(rdram, ctx, runtime);
}

void entry_1ea2b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea2b4 inside entry_1ea298 (0x1ea298 - 0x1ea2f8)
    ctx->pc = 0x1ea2b4;
    entry_1ea298(rdram, ctx, runtime);
}

void entry_1ea2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea2e8 inside entry_1ea298 (0x1ea298 - 0x1ea2f8)
    ctx->pc = 0x1ea2e8;
    entry_1ea298(rdram, ctx, runtime);
}

void entry_1ea314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea314 inside entry_1ea310 (0x1ea310 - 0x1ea344)
    ctx->pc = 0x1ea314;
    entry_1ea310(rdram, ctx, runtime);
}

void entry_1ea32c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea32c inside entry_1ea310 (0x1ea310 - 0x1ea344)
    ctx->pc = 0x1ea32c;
    entry_1ea310(rdram, ctx, runtime);
}

void entry_1ea390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea390 inside entry_1ea35c (0x1ea35c - 0x1ea398)
    ctx->pc = 0x1ea390;
    entry_1ea35c(rdram, ctx, runtime);
}

void entry_1ea3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea3b4 inside entry_1ea398 (0x1ea398 - 0x1ea3d0)
    ctx->pc = 0x1ea3b4;
    entry_1ea398(rdram, ctx, runtime);
}

void entry_1ea448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea448 inside RadNormalize__Ff (0x1ea408 - 0x1ea468)
    ctx->pc = 0x1ea448;
    RadNormalize__Ff(rdram, ctx, runtime);
}

void entry_1ea470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea470 inside entry_1ea468 (0x1ea468 - 0x1ea480)
    ctx->pc = 0x1ea470;
    entry_1ea468(rdram, ctx, runtime);
}

void entry_1ea49c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea49c inside GLimitAbs__Fff (0x1ea480 - 0x1ea4b8)
    ctx->pc = 0x1ea49c;
    GLimitAbs__Fff(rdram, ctx, runtime);
}

void entry_1ea4ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea4ac inside GLimitAbs__Fff (0x1ea480 - 0x1ea4b8)
    ctx->pc = 0x1ea4ac;
    GLimitAbs__Fff(rdram, ctx, runtime);
}

void entry_1ea500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea500 inside GSmooth__FfffP3SMPPf (0x1ea4b8 - 0x1ea57c)
    ctx->pc = 0x1ea500;
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime);
}

void entry_1ea55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea55c inside GSmooth__FfffP3SMPPf (0x1ea4b8 - 0x1ea57c)
    ctx->pc = 0x1ea55c;
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime);
}

void entry_1ea560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea560 inside GSmooth__FfffP3SMPPf (0x1ea4b8 - 0x1ea57c)
    ctx->pc = 0x1ea560;
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime);
}

void entry_1ea5d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea5d0 inside entry_1ea57c (0x1ea57c - 0x1ea620)
    ctx->pc = 0x1ea5d0;
    entry_1ea57c(rdram, ctx, runtime);
}

void entry_1ea5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea5d4 inside entry_1ea57c (0x1ea57c - 0x1ea620)
    ctx->pc = 0x1ea5d4;
    entry_1ea57c(rdram, ctx, runtime);
}

void entry_1ea5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea5f0 inside entry_1ea57c (0x1ea57c - 0x1ea620)
    ctx->pc = 0x1ea5f0;
    entry_1ea57c(rdram, ctx, runtime);
}

void entry_1ea5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea5fc inside entry_1ea57c (0x1ea57c - 0x1ea620)
    ctx->pc = 0x1ea5fc;
    entry_1ea57c(rdram, ctx, runtime);
}

void entry_1ea6bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea6bc inside entry_1ea660 (0x1ea660 - 0x1ea720)
    ctx->pc = 0x1ea6bc;
    entry_1ea660(rdram, ctx, runtime);
}

void entry_1ea6ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea6ec inside entry_1ea660 (0x1ea660 - 0x1ea720)
    ctx->pc = 0x1ea6ec;
    entry_1ea660(rdram, ctx, runtime);
}

void entry_1ea6f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea6f8 inside entry_1ea660 (0x1ea660 - 0x1ea720)
    ctx->pc = 0x1ea6f8;
    entry_1ea660(rdram, ctx, runtime);
}

void entry_1ea8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea8c4 inside entry_1ea89c (0x1ea89c - 0x1ea918)
    ctx->pc = 0x1ea8c4;
    entry_1ea89c(rdram, ctx, runtime);
}

void entry_1ea8ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea8ec inside entry_1ea89c (0x1ea89c - 0x1ea918)
    ctx->pc = 0x1ea8ec;
    entry_1ea89c(rdram, ctx, runtime);
}

void entry_1ea900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea900 inside entry_1ea89c (0x1ea89c - 0x1ea918)
    ctx->pc = 0x1ea900;
    entry_1ea89c(rdram, ctx, runtime);
}

void entry_1ea904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea904 inside entry_1ea89c (0x1ea89c - 0x1ea918)
    ctx->pc = 0x1ea904;
    entry_1ea89c(rdram, ctx, runtime);
}

void entry_1ea9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ea9c0 inside entry_1ea988 (0x1ea988 - 0x1ea9c8)
    ctx->pc = 0x1ea9c0;
    entry_1ea988(rdram, ctx, runtime);
}

void entry_1eaa28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eaa28 inside entry_1ea9c8 (0x1ea9c8 - 0x1eaa70)
    ctx->pc = 0x1eaa28;
    entry_1ea9c8(rdram, ctx, runtime);
}

void entry_1eaa44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eaa44 inside entry_1ea9c8 (0x1ea9c8 - 0x1eaa70)
    ctx->pc = 0x1eaa44;
    entry_1ea9c8(rdram, ctx, runtime);
}

void entry_1eaab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eaab0 inside entry_1eaa94 (0x1eaa94 - 0x1eaae0)
    ctx->pc = 0x1eaab0;
    entry_1eaa94(rdram, ctx, runtime);
}

void entry_1eaac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eaac4 inside entry_1eaa94 (0x1eaa94 - 0x1eaae0)
    ctx->pc = 0x1eaac4;
    entry_1eaa94(rdram, ctx, runtime);
}

void entry_1eaac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eaac8 inside entry_1eaa94 (0x1eaa94 - 0x1eaae0)
    ctx->pc = 0x1eaac8;
    entry_1eaa94(rdram, ctx, runtime);
}

void entry_1eab30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eab30 inside entry_1eab0c (0x1eab0c - 0x1eab48)
    ctx->pc = 0x1eab30;
    entry_1eab0c(rdram, ctx, runtime);
}

void entry_1eab34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eab34 inside entry_1eab0c (0x1eab0c - 0x1eab48)
    ctx->pc = 0x1eab34;
    entry_1eab0c(rdram, ctx, runtime);
}

void entry_1eab90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eab90 inside GRandGaussian__Ffff (0x1eab48 - 0x1eab9c)
    ctx->pc = 0x1eab90;
    GRandGaussian__Ffff(rdram, ctx, runtime);
}

void entry_1eab94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eab94 inside GRandGaussian__Ffff (0x1eab48 - 0x1eab9c)
    ctx->pc = 0x1eab94;
    GRandGaussian__Ffff(rdram, ctx, runtime);
}

void entry_1eac2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eac2c inside entry_1eabe0 (0x1eabe0 - 0x1eac68)
    ctx->pc = 0x1eac2c;
    entry_1eabe0(rdram, ctx, runtime);
}

void entry_1eac3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eac3c inside entry_1eabe0 (0x1eabe0 - 0x1eac68)
    ctx->pc = 0x1eac3c;
    entry_1eabe0(rdram, ctx, runtime);
}

void entry_1eac98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eac98 inside FFloatsNear__Ffff (0x1eac68 - 0x1eaca0)
    ctx->pc = 0x1eac98;
    FFloatsNear__Ffff(rdram, ctx, runtime);
}

void entry_1eacd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eacd8 inside CSolveQuadratic__FfffPf (0x1eaca0 - 0x1ead30)
    ctx->pc = 0x1eacd8;
    CSolveQuadratic__FfffPf(rdram, ctx, runtime);
}

void entry_1ead1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ead1c inside CSolveQuadratic__FfffPf (0x1eaca0 - 0x1ead30)
    ctx->pc = 0x1ead1c;
    CSolveQuadratic__FfffPf(rdram, ctx, runtime);
}

void entry_1eadc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eadc0 inside CalculateSinCos__FfPfT1 (0x1ead88 - 0x1eae78)
    ctx->pc = 0x1eadc0;
    CalculateSinCos__FfPfT1(rdram, ctx, runtime);
}

void entry_1eade8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eade8 inside CalculateSinCos__FfPfT1 (0x1ead88 - 0x1eae78)
    ctx->pc = 0x1eade8;
    CalculateSinCos__FfPfT1(rdram, ctx, runtime);
}

void entry_1eae6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eae6c inside CalculateSinCos__FfPfT1 (0x1ead88 - 0x1eae78)
    ctx->pc = 0x1eae6c;
    CalculateSinCos__FfPfT1(rdram, ctx, runtime);
}

void entry_1eaea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eaea0 inside GTrunc__Fd (0x1eae78 - 0x1eaef8)
    ctx->pc = 0x1eaea0;
    GTrunc__Fd(rdram, ctx, runtime);
}

void entry_1eaf00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eaf00 inside entry_1eaef8 (0x1eaef8 - 0x1eaf28)
    ctx->pc = 0x1eaf00;
    entry_1eaef8(rdram, ctx, runtime);
}

void entry_1eaf18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eaf18 inside entry_1eaef8 (0x1eaef8 - 0x1eaf28)
    ctx->pc = 0x1eaf18;
    entry_1eaef8(rdram, ctx, runtime);
}

void entry_1eaf1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eaf1c inside entry_1eaef8 (0x1eaef8 - 0x1eaf28)
    ctx->pc = 0x1eaf1c;
    entry_1eaef8(rdram, ctx, runtime);
}

void entry_1eaf58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eaf58 inside GTrunc__Ff (0x1eaf28 - 0x1eafe0)
    ctx->pc = 0x1eaf58;
    GTrunc__Ff(rdram, ctx, runtime);
}

void entry_1eafc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eafc0 inside GTrunc__Ff (0x1eaf28 - 0x1eafe0)
    ctx->pc = 0x1eafc0;
    GTrunc__Ff(rdram, ctx, runtime);
}

void entry_1eafd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eafd4 inside GTrunc__Ff (0x1eaf28 - 0x1eafe0)
    ctx->pc = 0x1eafd4;
    GTrunc__Ff(rdram, ctx, runtime);
}

void entry_1eafd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eafd8 inside GTrunc__Ff (0x1eaf28 - 0x1eafe0)
    ctx->pc = 0x1eafd8;
    GTrunc__Ff(rdram, ctx, runtime);
}

void entry_1eb008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb008 inside entry_1eaff4 (0x1eaff4 - 0x1eb018)
    ctx->pc = 0x1eb008;
    entry_1eaff4(rdram, ctx, runtime);
}

void entry_1eb078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb078 inside FCheckLm__FP2LMf (0x1eb050 - 0x1eb080)
    ctx->pc = 0x1eb078;
    FCheckLm__FP2LMf(rdram, ctx, runtime);
}

void entry_1eb0b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb0b0 inside FCheckAlm__FiP2LMf (0x1eb080 - 0x1eb0bc)
    ctx->pc = 0x1eb0b0;
    FCheckAlm__FiP2LMf(rdram, ctx, runtime);
}

void entry_1eb0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb0d4 inside entry_1eb0bc (0x1eb0bc - 0x1eb0f8)
    ctx->pc = 0x1eb0d4;
    entry_1eb0bc(rdram, ctx, runtime);
}

void entry_1eb0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb0d8 inside entry_1eb0bc (0x1eb0bc - 0x1eb0f8)
    ctx->pc = 0x1eb0d8;
    entry_1eb0bc(rdram, ctx, runtime);
}

void entry_1eb11c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb11c inside GLimitLm__FP2LMf (0x1eb0f8 - 0x1eb128)
    ctx->pc = 0x1eb11c;
    GLimitLm__FP2LMf(rdram, ctx, runtime);
}

void entry_1eb158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb158 inside SgnCompareG__FPfT0 (0x1eb128 - 0x1eb160)
    ctx->pc = 0x1eb158;
    SgnCompareG__FPfT0(rdram, ctx, runtime);
}

void entry_1eb1c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb1c4 inside MinimizeRange (0x1eb168 - 0x1eb1f4)
    ctx->pc = 0x1eb1c4;
    MinimizeRange(rdram, ctx, runtime);
}

void entry_1eb1d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb1d8 inside MinimizeRange (0x1eb168 - 0x1eb1f4)
    ctx->pc = 0x1eb1d8;
    MinimizeRange(rdram, ctx, runtime);
}

void entry_1eb220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb220 inside entry_1eb208 (0x1eb208 - 0x1eb228)
    ctx->pc = 0x1eb220;
    entry_1eb208(rdram, ctx, runtime);
}

void entry_1eb230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb230 inside entry_1eb228 (0x1eb228 - 0x1eb28c)
    ctx->pc = 0x1eb230;
    entry_1eb228(rdram, ctx, runtime);
}

void entry_1eb294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb294 inside entry_1eb28c (0x1eb28c - 0x1eb314)
    ctx->pc = 0x1eb294;
    entry_1eb28c(rdram, ctx, runtime);
}

void entry_1eb2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb2e8 inside entry_1eb28c (0x1eb28c - 0x1eb314)
    ctx->pc = 0x1eb2e8;
    entry_1eb28c(rdram, ctx, runtime);
}

void entry_1eb2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb2f8 inside entry_1eb28c (0x1eb28c - 0x1eb314)
    ctx->pc = 0x1eb2f8;
    entry_1eb28c(rdram, ctx, runtime);
}

void entry_1eb384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb384 inside entry_1eb338 (0x1eb338 - 0x1eb458)
    ctx->pc = 0x1eb384;
    entry_1eb338(rdram, ctx, runtime);
}

void entry_1eb3ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb3ac inside entry_1eb338 (0x1eb338 - 0x1eb458)
    ctx->pc = 0x1eb3ac;
    entry_1eb338(rdram, ctx, runtime);
}

void entry_1eb3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb3e4 inside entry_1eb338 (0x1eb338 - 0x1eb458)
    ctx->pc = 0x1eb3e4;
    entry_1eb338(rdram, ctx, runtime);
}

void entry_1eb404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb404 inside entry_1eb338 (0x1eb338 - 0x1eb458)
    ctx->pc = 0x1eb404;
    entry_1eb338(rdram, ctx, runtime);
}

void entry_1eb418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb418 inside entry_1eb338 (0x1eb338 - 0x1eb458)
    ctx->pc = 0x1eb418;
    entry_1eb338(rdram, ctx, runtime);
}

void entry_1eb424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb424 inside entry_1eb338 (0x1eb338 - 0x1eb458)
    ctx->pc = 0x1eb424;
    entry_1eb338(rdram, ctx, runtime);
}

void entry_1eb4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb4c8 inside entry_1eb474 (0x1eb474 - 0x1eb518)
    ctx->pc = 0x1eb4c8;
    entry_1eb474(rdram, ctx, runtime);
}

void entry_1eb4dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb4dc inside entry_1eb474 (0x1eb474 - 0x1eb518)
    ctx->pc = 0x1eb4dc;
    entry_1eb474(rdram, ctx, runtime);
}

void entry_1eb568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb568 inside entry_1eb540 (0x1eb540 - 0x1eb598)
    ctx->pc = 0x1eb568;
    entry_1eb540(rdram, ctx, runtime);
}

void entry_1eb65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb65c inside entry_1eb650 (0x1eb650 - 0x1eb668)
    ctx->pc = 0x1eb65c;
    entry_1eb650(rdram, ctx, runtime);
}

void entry_1eb67c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb67c inside entry_1eb668 (0x1eb668 - 0x1eb6f8)
    ctx->pc = 0x1eb67c;
    entry_1eb668(rdram, ctx, runtime);
}

void entry_1eb7f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb7f4 inside entry_1eb7f0 (0x1eb7f0 - 0x1eb90c)
    ctx->pc = 0x1eb7f4;
    entry_1eb7f0(rdram, ctx, runtime);
}

void entry_1eb81c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb81c inside entry_1eb7f0 (0x1eb7f0 - 0x1eb90c)
    ctx->pc = 0x1eb81c;
    entry_1eb7f0(rdram, ctx, runtime);
}

void entry_1eb82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb82c inside entry_1eb7f0 (0x1eb7f0 - 0x1eb90c)
    ctx->pc = 0x1eb82c;
    entry_1eb7f0(rdram, ctx, runtime);
}

void entry_1eb83c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb83c inside entry_1eb7f0 (0x1eb7f0 - 0x1eb90c)
    ctx->pc = 0x1eb83c;
    entry_1eb7f0(rdram, ctx, runtime);
}

void entry_1eb844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb844 inside entry_1eb7f0 (0x1eb7f0 - 0x1eb90c)
    ctx->pc = 0x1eb844;
    entry_1eb7f0(rdram, ctx, runtime);
}

void entry_1eb8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb8bc inside entry_1eb7f0 (0x1eb7f0 - 0x1eb90c)
    ctx->pc = 0x1eb8bc;
    entry_1eb7f0(rdram, ctx, runtime);
}

void entry_1eb8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb8d0 inside entry_1eb7f0 (0x1eb7f0 - 0x1eb90c)
    ctx->pc = 0x1eb8d0;
    entry_1eb7f0(rdram, ctx, runtime);
}

void entry_1eb910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb910 inside entry_1eb90c (0x1eb90c - 0x1eb99c)
    ctx->pc = 0x1eb910;
    entry_1eb90c(rdram, ctx, runtime);
}

void entry_1eb9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eb9ec inside entry_1eb9e4 (0x1eb9e4 - 0x1eba58)
    ctx->pc = 0x1eb9ec;
    entry_1eb9e4(rdram, ctx, runtime);
}

void entry_1ebb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebb00 inside entry_1ebaf8 (0x1ebaf8 - 0x1ebb10)
    ctx->pc = 0x1ebb00;
    entry_1ebaf8(rdram, ctx, runtime);
}

void entry_1ebba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebba8 inside entry_1ebb28 (0x1ebb28 - 0x1ebc38)
    ctx->pc = 0x1ebba8;
    entry_1ebb28(rdram, ctx, runtime);
}

void entry_1ebbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebbc8 inside entry_1ebb28 (0x1ebb28 - 0x1ebc38)
    ctx->pc = 0x1ebbc8;
    entry_1ebb28(rdram, ctx, runtime);
}

void entry_1ebc1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebc1c inside entry_1ebb28 (0x1ebb28 - 0x1ebc38)
    ctx->pc = 0x1ebc1c;
    entry_1ebb28(rdram, ctx, runtime);
}

void entry_1ebc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebc20 inside entry_1ebb28 (0x1ebb28 - 0x1ebc38)
    ctx->pc = 0x1ebc20;
    entry_1ebb28(rdram, ctx, runtime);
}

void entry_1ebc4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebc4c inside entry_1ebc44 (0x1ebc44 - 0x1ebc88)
    ctx->pc = 0x1ebc4c;
    entry_1ebc44(rdram, ctx, runtime);
}

void entry_1ebc64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebc64 inside entry_1ebc44 (0x1ebc44 - 0x1ebc88)
    ctx->pc = 0x1ebc64;
    entry_1ebc44(rdram, ctx, runtime);
}

void entry_1ebcb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebcb8 inside entry_1ebcb0 (0x1ebcb0 - 0x1ebcd8)
    ctx->pc = 0x1ebcb8;
    entry_1ebcb0(rdram, ctx, runtime);
}

void entry_1ebcc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebcc0 inside entry_1ebcb0 (0x1ebcb0 - 0x1ebcd8)
    ctx->pc = 0x1ebcc0;
    entry_1ebcb0(rdram, ctx, runtime);
}

void entry_1ebcc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebcc4 inside entry_1ebcb0 (0x1ebcb0 - 0x1ebcd8)
    ctx->pc = 0x1ebcc4;
    entry_1ebcb0(rdram, ctx, runtime);
}

void entry_1ebd48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebd48 inside entry_1ebd40 (0x1ebd40 - 0x1ebd64)
    ctx->pc = 0x1ebd48;
    entry_1ebd40(rdram, ctx, runtime);
}

void entry_1ebdb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebdb8 inside entry_1ebd64 (0x1ebd64 - 0x1ebdd0)
    ctx->pc = 0x1ebdb8;
    entry_1ebd64(rdram, ctx, runtime);
}

void entry_1ebe08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebe08 inside entry_1ebe00 (0x1ebe00 - 0x1ebe24)
    ctx->pc = 0x1ebe08;
    entry_1ebe00(rdram, ctx, runtime);
}

void entry_1ebe98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebe98 inside entry_1ebe24 (0x1ebe24 - 0x1ebeb0)
    ctx->pc = 0x1ebe98;
    entry_1ebe24(rdram, ctx, runtime);
}

void entry_1ebf70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ebf70 inside entry_1ebf68 (0x1ebf68 - 0x1ebf84)
    ctx->pc = 0x1ebf70;
    entry_1ebf68(rdram, ctx, runtime);
}

void entry_1ec048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec048 inside entry_1ec030 (0x1ec030 - 0x1ec068)
    ctx->pc = 0x1ec048;
    entry_1ec030(rdram, ctx, runtime);
}

void entry_1ec07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec07c inside entry_1ec068 (0x1ec068 - 0x1ec098)
    ctx->pc = 0x1ec07c;
    entry_1ec068(rdram, ctx, runtime);
}

void entry_1ec12c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec12c inside entry_1ec0f4 (0x1ec0f4 - 0x1ec190)
    ctx->pc = 0x1ec12c;
    entry_1ec0f4(rdram, ctx, runtime);
}

void entry_1ec15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec15c inside entry_1ec0f4 (0x1ec0f4 - 0x1ec190)
    ctx->pc = 0x1ec15c;
    entry_1ec0f4(rdram, ctx, runtime);
}

void entry_1ec16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec16c inside entry_1ec0f4 (0x1ec0f4 - 0x1ec190)
    ctx->pc = 0x1ec16c;
    entry_1ec0f4(rdram, ctx, runtime);
}

void entry_1ec170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec170 inside entry_1ec0f4 (0x1ec0f4 - 0x1ec190)
    ctx->pc = 0x1ec170;
    entry_1ec0f4(rdram, ctx, runtime);
}

void entry_1ec174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec174 inside entry_1ec0f4 (0x1ec0f4 - 0x1ec190)
    ctx->pc = 0x1ec174;
    entry_1ec0f4(rdram, ctx, runtime);
}

void entry_1ec178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec178 inside entry_1ec0f4 (0x1ec0f4 - 0x1ec190)
    ctx->pc = 0x1ec178;
    entry_1ec0f4(rdram, ctx, runtime);
}

void entry_1ec264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec264 inside entry_1ec1e0 (0x1ec1e0 - 0x1ec2b8)
    ctx->pc = 0x1ec264;
    entry_1ec1e0(rdram, ctx, runtime);
}

void entry_1ec290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec290 inside entry_1ec1e0 (0x1ec1e0 - 0x1ec2b8)
    ctx->pc = 0x1ec290;
    entry_1ec1e0(rdram, ctx, runtime);
}

void entry_1ec3b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec3b8 inside entry_1ec3b0 (0x1ec3b0 - 0x1ec3c4)
    ctx->pc = 0x1ec3b8;
    entry_1ec3b0(rdram, ctx, runtime);
}

void entry_1ec464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec464 inside entry_1ec460 (0x1ec460 - 0x1ec478)
    ctx->pc = 0x1ec464;
    entry_1ec460(rdram, ctx, runtime);
}

void entry_1ec4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec4e0 inside entry_1ec4b8 (0x1ec4b8 - 0x1ec504)
    ctx->pc = 0x1ec4e0;
    entry_1ec4b8(rdram, ctx, runtime);
}

void entry_1ec4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec4f4 inside entry_1ec4b8 (0x1ec4b8 - 0x1ec504)
    ctx->pc = 0x1ec4f4;
    entry_1ec4b8(rdram, ctx, runtime);
}

void entry_1ec4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec4f8 inside entry_1ec4b8 (0x1ec4b8 - 0x1ec504)
    ctx->pc = 0x1ec4f8;
    entry_1ec4b8(rdram, ctx, runtime);
}

void entry_1ec4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec4fc inside entry_1ec4b8 (0x1ec4b8 - 0x1ec504)
    ctx->pc = 0x1ec4fc;
    entry_1ec4b8(rdram, ctx, runtime);
}

void entry_1ec50c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec50c inside entry_1ec504 (0x1ec504 - 0x1ec528)
    ctx->pc = 0x1ec50c;
    entry_1ec504(rdram, ctx, runtime);
}

void entry_1ec514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec514 inside entry_1ec504 (0x1ec504 - 0x1ec528)
    ctx->pc = 0x1ec514;
    entry_1ec504(rdram, ctx, runtime);
}

void entry_1ec5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec5b8 inside FUN_001ec570 (0x1ec570 - 0x1ec5d8)
    ctx->pc = 0x1ec5b8;
    FUN_001ec570(rdram, ctx, runtime);
}

void entry_1ec5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec5cc inside FUN_001ec570 (0x1ec570 - 0x1ec5d8)
    ctx->pc = 0x1ec5cc;
    FUN_001ec570(rdram, ctx, runtime);
}

void entry_1ec600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec600 inside entry_1ec5d8 (0x1ec5d8 - 0x1ec628)
    ctx->pc = 0x1ec600;
    entry_1ec5d8(rdram, ctx, runtime);
}

void entry_1ec614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec614 inside entry_1ec5d8 (0x1ec5d8 - 0x1ec628)
    ctx->pc = 0x1ec614;
    entry_1ec5d8(rdram, ctx, runtime);
}

void entry_1ec620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec620 inside entry_1ec5d8 (0x1ec5d8 - 0x1ec628)
    ctx->pc = 0x1ec620;
    entry_1ec5d8(rdram, ctx, runtime);
}

void entry_1ec630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec630 inside entry_1ec628 (0x1ec628 - 0x1ec638)
    ctx->pc = 0x1ec630;
    entry_1ec628(rdram, ctx, runtime);
}

void entry_1ec650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec650 inside entry_1ec64c (0x1ec64c - 0x1ec65c)
    ctx->pc = 0x1ec650;
    entry_1ec64c(rdram, ctx, runtime);
}

void entry_1ec654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec654 inside entry_1ec64c (0x1ec64c - 0x1ec65c)
    ctx->pc = 0x1ec654;
    entry_1ec64c(rdram, ctx, runtime);
}

void entry_1ec6bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec6bc inside entry_1ec694 (0x1ec694 - 0x1ec738)
    ctx->pc = 0x1ec6bc;
    entry_1ec694(rdram, ctx, runtime);
}

void entry_1ec6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec6d8 inside entry_1ec694 (0x1ec694 - 0x1ec738)
    ctx->pc = 0x1ec6d8;
    entry_1ec694(rdram, ctx, runtime);
}

void entry_1ec6ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec6ec inside entry_1ec694 (0x1ec694 - 0x1ec738)
    ctx->pc = 0x1ec6ec;
    entry_1ec694(rdram, ctx, runtime);
}

void entry_1ec704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec704 inside entry_1ec694 (0x1ec694 - 0x1ec738)
    ctx->pc = 0x1ec704;
    entry_1ec694(rdram, ctx, runtime);
}

void entry_1ec750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec750 inside entry_1ec738 (0x1ec738 - 0x1ec760)
    ctx->pc = 0x1ec750;
    entry_1ec738(rdram, ctx, runtime);
}

void entry_1ec790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec790 inside entry_1ec760 (0x1ec760 - 0x1ec7a8)
    ctx->pc = 0x1ec790;
    entry_1ec760(rdram, ctx, runtime);
}

void entry_1ec798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec798 inside entry_1ec760 (0x1ec760 - 0x1ec7a8)
    ctx->pc = 0x1ec798;
    entry_1ec760(rdram, ctx, runtime);
}

void entry_1ec874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec874 inside FUN_001ec828 (0x1ec828 - 0x1ec8c4)
    ctx->pc = 0x1ec874;
    FUN_001ec828(rdram, ctx, runtime);
}

void entry_1ec888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec888 inside FUN_001ec828 (0x1ec828 - 0x1ec8c4)
    ctx->pc = 0x1ec888;
    FUN_001ec828(rdram, ctx, runtime);
}

void entry_1ec9c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec9c8 inside entry_1ec9c0 (0x1ec9c0 - 0x1eca1c)
    ctx->pc = 0x1ec9c8;
    entry_1ec9c0(rdram, ctx, runtime);
}

void entry_1ec9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ec9f0 inside entry_1ec9c0 (0x1ec9c0 - 0x1eca1c)
    ctx->pc = 0x1ec9f0;
    entry_1ec9c0(rdram, ctx, runtime);
}

void entry_1eca08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eca08 inside entry_1ec9c0 (0x1ec9c0 - 0x1eca1c)
    ctx->pc = 0x1eca08;
    entry_1ec9c0(rdram, ctx, runtime);
}

void entry_1eca24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eca24 inside entry_1eca1c (0x1eca1c - 0x1eca3c)
    ctx->pc = 0x1eca24;
    entry_1eca1c(rdram, ctx, runtime);
}

void entry_1ecabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecabc inside entry_1eca3c (0x1eca3c - 0x1ecac4)
    ctx->pc = 0x1ecabc;
    entry_1eca3c(rdram, ctx, runtime);
}

void entry_1ecaec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecaec inside entry_1ecae8 (0x1ecae8 - 0x1ecaf8)
    ctx->pc = 0x1ecaec;
    entry_1ecae8(rdram, ctx, runtime);
}

void entry_1ecaf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecaf0 inside entry_1ecae8 (0x1ecae8 - 0x1ecaf8)
    ctx->pc = 0x1ecaf0;
    entry_1ecae8(rdram, ctx, runtime);
}

void entry_1ecafc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecafc inside entry_1ecaf8 (0x1ecaf8 - 0x1ecbc8)
    ctx->pc = 0x1ecafc;
    entry_1ecaf8(rdram, ctx, runtime);
}

void entry_1ecb40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecb40 inside entry_1ecaf8 (0x1ecaf8 - 0x1ecbc8)
    ctx->pc = 0x1ecb40;
    entry_1ecaf8(rdram, ctx, runtime);
}

void entry_1ecb70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecb70 inside entry_1ecaf8 (0x1ecaf8 - 0x1ecbc8)
    ctx->pc = 0x1ecb70;
    entry_1ecaf8(rdram, ctx, runtime);
}

void entry_1ecb9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecb9c inside entry_1ecaf8 (0x1ecaf8 - 0x1ecbc8)
    ctx->pc = 0x1ecb9c;
    entry_1ecaf8(rdram, ctx, runtime);
}

void entry_1ecbbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecbbc inside entry_1ecaf8 (0x1ecaf8 - 0x1ecbc8)
    ctx->pc = 0x1ecbbc;
    entry_1ecaf8(rdram, ctx, runtime);
}

void entry_1ecc28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecc28 inside entry_1ecbe8 (0x1ecbe8 - 0x1ecc64)
    ctx->pc = 0x1ecc28;
    entry_1ecbe8(rdram, ctx, runtime);
}

void entry_1ecc68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecc68 inside entry_1ecc64 (0x1ecc64 - 0x1eccf8)
    ctx->pc = 0x1ecc68;
    entry_1ecc64(rdram, ctx, runtime);
}

void entry_1eccdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eccdc inside entry_1ecc64 (0x1ecc64 - 0x1eccf8)
    ctx->pc = 0x1eccdc;
    entry_1ecc64(rdram, ctx, runtime);
}

void entry_1ecd20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecd20 inside entry_1eccf8 (0x1eccf8 - 0x1ecd84)
    ctx->pc = 0x1ecd20;
    entry_1eccf8(rdram, ctx, runtime);
}

void entry_1ecd34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecd34 inside entry_1eccf8 (0x1eccf8 - 0x1ecd84)
    ctx->pc = 0x1ecd34;
    entry_1eccf8(rdram, ctx, runtime);
}

void entry_1ecd38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecd38 inside entry_1eccf8 (0x1eccf8 - 0x1ecd84)
    ctx->pc = 0x1ecd38;
    entry_1eccf8(rdram, ctx, runtime);
}

void entry_1ecd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecd40 inside entry_1eccf8 (0x1eccf8 - 0x1ecd84)
    ctx->pc = 0x1ecd40;
    entry_1eccf8(rdram, ctx, runtime);
}

void entry_1ecd58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecd58 inside entry_1eccf8 (0x1eccf8 - 0x1ecd84)
    ctx->pc = 0x1ecd58;
    entry_1eccf8(rdram, ctx, runtime);
}

void entry_1ecdc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecdc4 inside entry_1ecda8 (0x1ecda8 - 0x1ecddc)
    ctx->pc = 0x1ecdc4;
    entry_1ecda8(rdram, ctx, runtime);
}

void entry_1ece38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ece38 inside entry_1ece0c (0x1ece0c - 0x1ece54)
    ctx->pc = 0x1ece38;
    entry_1ece0c(rdram, ctx, runtime);
}

void entry_1ece4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ece4c inside entry_1ece0c (0x1ece0c - 0x1ece54)
    ctx->pc = 0x1ece4c;
    entry_1ece0c(rdram, ctx, runtime);
}

void entry_1ece58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ece58 inside entry_1ece54 (0x1ece54 - 0x1ece70)
    ctx->pc = 0x1ece58;
    entry_1ece54(rdram, ctx, runtime);
}

void entry_1ece78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ece78 inside entry_1ece70 (0x1ece70 - 0x1ece88)
    ctx->pc = 0x1ece78;
    entry_1ece70(rdram, ctx, runtime);
}

void entry_1ece8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ece8c inside entry_1ece88 (0x1ece88 - 0x1ece98)
    ctx->pc = 0x1ece8c;
    entry_1ece88(rdram, ctx, runtime);
}

void entry_1ecee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecee8 inside entry_1ecee0 (0x1ecee0 - 0x1ecef0)
    ctx->pc = 0x1ecee8;
    entry_1ecee0(rdram, ctx, runtime);
}

void entry_1ecef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecef8 inside entry_1ecef0 (0x1ecef0 - 0x1ecf00)
    ctx->pc = 0x1ecef8;
    entry_1ecef0(rdram, ctx, runtime);
}

void entry_1ecf04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecf04 inside entry_1ecf00 (0x1ecf00 - 0x1ecf10)
    ctx->pc = 0x1ecf04;
    entry_1ecf00(rdram, ctx, runtime);
}

void entry_1ecfcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecfcc inside entry_1ecfc4 (0x1ecfc4 - 0x1ecfe4)
    ctx->pc = 0x1ecfcc;
    entry_1ecfc4(rdram, ctx, runtime);
}

void entry_1ecfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecfdc inside entry_1ecfc4 (0x1ecfc4 - 0x1ecfe4)
    ctx->pc = 0x1ecfdc;
    entry_1ecfc4(rdram, ctx, runtime);
}

void entry_1ecffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ecffc inside entry_1ecff4 (0x1ecff4 - 0x1ed004)
    ctx->pc = 0x1ecffc;
    entry_1ecff4(rdram, ctx, runtime);
}

void entry_1ed008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed008 inside entry_1ed004 (0x1ed004 - 0x1ed018)
    ctx->pc = 0x1ed008;
    entry_1ed004(rdram, ctx, runtime);
}

void entry_1ed110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed110 inside FUN_001ed0d8 (0x1ed0d8 - 0x1ed14c)
    ctx->pc = 0x1ed110;
    FUN_001ed0d8(rdram, ctx, runtime);
}

void entry_1ed128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed128 inside FUN_001ed0d8 (0x1ed0d8 - 0x1ed14c)
    ctx->pc = 0x1ed128;
    FUN_001ed0d8(rdram, ctx, runtime);
}

void entry_1ed158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed158 inside entry_1ed14c (0x1ed14c - 0x1ed168)
    ctx->pc = 0x1ed158;
    entry_1ed14c(rdram, ctx, runtime);
}

void entry_1ed298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed298 inside FUN_001ed278 (0x1ed278 - 0x1ed2c4)
    ctx->pc = 0x1ed298;
    FUN_001ed278(rdram, ctx, runtime);
}

void entry_1ed2bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed2bc inside FUN_001ed278 (0x1ed278 - 0x1ed2c4)
    ctx->pc = 0x1ed2bc;
    FUN_001ed278(rdram, ctx, runtime);
}

void entry_1ed2d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed2d8 inside entry_1ed2c4 (0x1ed2c4 - 0x1ed318)
    ctx->pc = 0x1ed2d8;
    entry_1ed2c4(rdram, ctx, runtime);
}

void entry_1ed308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed308 inside entry_1ed2c4 (0x1ed2c4 - 0x1ed318)
    ctx->pc = 0x1ed308;
    entry_1ed2c4(rdram, ctx, runtime);
}

void entry_1ed30c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed30c inside entry_1ed2c4 (0x1ed2c4 - 0x1ed318)
    ctx->pc = 0x1ed30c;
    entry_1ed2c4(rdram, ctx, runtime);
}

void entry_1ed47c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed47c inside entry_1ed448 (0x1ed448 - 0x1ed490)
    ctx->pc = 0x1ed47c;
    entry_1ed448(rdram, ctx, runtime);
}

void entry_1ed4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed4bc inside entry_1ed4b8 (0x1ed4b8 - 0x1ed4c8)
    ctx->pc = 0x1ed4bc;
    entry_1ed4b8(rdram, ctx, runtime);
}

void entry_1ed530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed530 inside entry_1ed51c (0x1ed51c - 0x1ed558)
    ctx->pc = 0x1ed530;
    entry_1ed51c(rdram, ctx, runtime);
}

void entry_1ed538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed538 inside entry_1ed51c (0x1ed51c - 0x1ed558)
    ctx->pc = 0x1ed538;
    entry_1ed51c(rdram, ctx, runtime);
}

void entry_1ed760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed760 inside SProjectVector__FP6VECTORT0 (0x1ed738 - 0x1ed780)
    ctx->pc = 0x1ed760;
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1ed774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed774 inside SProjectVector__FP6VECTORT0 (0x1ed738 - 0x1ed780)
    ctx->pc = 0x1ed774;
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1ed7d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed7d4 inside GetNormalVectors__FP6VECTORN30 (0x1ed780 - 0x1ed840)
    ctx->pc = 0x1ed7d4;
    GetNormalVectors__FP6VECTORN30(rdram, ctx, runtime);
}

void entry_1ed88c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed88c inside GetNormalVector__FP6VECTORT0 (0x1ed840 - 0x1ed900)
    ctx->pc = 0x1ed88c;
    GetNormalVector__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1ed8ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed8ac inside GetNormalVector__FP6VECTORT0 (0x1ed840 - 0x1ed900)
    ctx->pc = 0x1ed8ac;
    GetNormalVector__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1ed8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed8b8 inside GetNormalVector__FP6VECTORT0 (0x1ed840 - 0x1ed900)
    ctx->pc = 0x1ed8b8;
    GetNormalVector__FP6VECTORT0(rdram, ctx, runtime);
}

void entry_1ed9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed9a0 inside RadBetweenVectors__FP6VECTORN20 (0x1ed908 - 0x1eda34)
    ctx->pc = 0x1ed9a0;
    RadBetweenVectors__FP6VECTORN20(rdram, ctx, runtime);
}

void entry_1ed9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ed9b4 inside RadBetweenVectors__FP6VECTORN20 (0x1ed908 - 0x1eda34)
    ctx->pc = 0x1ed9b4;
    RadBetweenVectors__FP6VECTORN20(rdram, ctx, runtime);
}

void entry_1eda2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eda2c inside RadBetweenVectors__FP6VECTORN20 (0x1ed908 - 0x1eda34)
    ctx->pc = 0x1eda2c;
    RadBetweenVectors__FP6VECTORN20(rdram, ctx, runtime);
}

void entry_1eda38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eda38 inside entry_1eda34 (0x1eda34 - 0x1eda60)
    ctx->pc = 0x1eda38;
    entry_1eda34(rdram, ctx, runtime);
}

void entry_1edaf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edaf0 inside FindClosestPointBetweenLines__FP6VECTORN30PfT4T0 (0x1eda80 - 0x1edc08)
    ctx->pc = 0x1edaf0;
    FindClosestPointBetweenLines__FP6VECTORN30PfT4T0(rdram, ctx, runtime);
}

void entry_1edb84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edb84 inside FindClosestPointBetweenLines__FP6VECTORN30PfT4T0 (0x1eda80 - 0x1edc08)
    ctx->pc = 0x1edb84;
    FindClosestPointBetweenLines__FP6VECTORN30PfT4T0(rdram, ctx, runtime);
}

void entry_1edbd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edbd4 inside FindClosestPointBetweenLines__FP6VECTORN30PfT4T0 (0x1eda80 - 0x1edc08)
    ctx->pc = 0x1edbd4;
    FindClosestPointBetweenLines__FP6VECTORN30PfT4T0(rdram, ctx, runtime);
}

void entry_1edbe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edbe0 inside FindClosestPointBetweenLines__FP6VECTORN30PfT4T0 (0x1eda80 - 0x1edc08)
    ctx->pc = 0x1edbe0;
    FindClosestPointBetweenLines__FP6VECTORN30PfT4T0(rdram, ctx, runtime);
}

void entry_1edc80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edc80 inside entry_1edc4c (0x1edc4c - 0x1eddb0)
    ctx->pc = 0x1edc80;
    entry_1edc4c(rdram, ctx, runtime);
}

void entry_1edc84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edc84 inside entry_1edc4c (0x1edc4c - 0x1eddb0)
    ctx->pc = 0x1edc84;
    entry_1edc4c(rdram, ctx, runtime);
}

void entry_1edcb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edcb4 inside entry_1edc4c (0x1edc4c - 0x1eddb0)
    ctx->pc = 0x1edcb4;
    entry_1edc4c(rdram, ctx, runtime);
}

void entry_1edd70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edd70 inside entry_1edc4c (0x1edc4c - 0x1eddb0)
    ctx->pc = 0x1edd70;
    entry_1edc4c(rdram, ctx, runtime);
}

void entry_1edd80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edd80 inside entry_1edc4c (0x1edc4c - 0x1eddb0)
    ctx->pc = 0x1edd80;
    entry_1edc4c(rdram, ctx, runtime);
}

void entry_1eddec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eddec inside entry_1edde8 (0x1edde8 - 0x1ede14)
    ctx->pc = 0x1eddec;
    entry_1edde8(rdram, ctx, runtime);
}

void entry_1ede24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ede24 inside entry_1ede1c (0x1ede1c - 0x1ede38)
    ctx->pc = 0x1ede24;
    entry_1ede1c(rdram, ctx, runtime);
}

void entry_1edf3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edf3c inside entry_1edf2c (0x1edf2c - 0x1edf98)
    ctx->pc = 0x1edf3c;
    entry_1edf2c(rdram, ctx, runtime);
}

void entry_1edf48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edf48 inside entry_1edf2c (0x1edf2c - 0x1edf98)
    ctx->pc = 0x1edf48;
    entry_1edf2c(rdram, ctx, runtime);
}

void entry_1edfac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1edfac inside entry_1edf98 (0x1edf98 - 0x1edfcc)
    ctx->pc = 0x1edfac;
    entry_1edf98(rdram, ctx, runtime);
}

void entry_1ee064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee064 inside entry_1ee018 (0x1ee018 - 0x1ee090)
    ctx->pc = 0x1ee064;
    entry_1ee018(rdram, ctx, runtime);
}

void entry_1ee0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee0a0 inside FCalculateMuzzleVelocity1 (0x1ee090 - 0x1ee290)
    ctx->pc = 0x1ee0a0;
    FCalculateMuzzleVelocity1(rdram, ctx, runtime);
}

void entry_1ee0ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee0ac inside FCalculateMuzzleVelocity1 (0x1ee090 - 0x1ee290)
    ctx->pc = 0x1ee0ac;
    FCalculateMuzzleVelocity1(rdram, ctx, runtime);
}

void entry_1ee130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee130 inside FCalculateMuzzleVelocity1 (0x1ee090 - 0x1ee290)
    ctx->pc = 0x1ee130;
    FCalculateMuzzleVelocity1(rdram, ctx, runtime);
}

void entry_1ee13c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee13c inside FCalculateMuzzleVelocity1 (0x1ee090 - 0x1ee290)
    ctx->pc = 0x1ee13c;
    FCalculateMuzzleVelocity1(rdram, ctx, runtime);
}

void entry_1ee14c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee14c inside FCalculateMuzzleVelocity1 (0x1ee090 - 0x1ee290)
    ctx->pc = 0x1ee14c;
    FCalculateMuzzleVelocity1(rdram, ctx, runtime);
}

void entry_1ee218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee218 inside FCalculateMuzzleVelocity1 (0x1ee090 - 0x1ee290)
    ctx->pc = 0x1ee218;
    FCalculateMuzzleVelocity1(rdram, ctx, runtime);
}

void entry_1ee228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee228 inside FCalculateMuzzleVelocity1 (0x1ee090 - 0x1ee290)
    ctx->pc = 0x1ee228;
    FCalculateMuzzleVelocity1(rdram, ctx, runtime);
}

void entry_1ee230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee230 inside FCalculateMuzzleVelocity1 (0x1ee090 - 0x1ee290)
    ctx->pc = 0x1ee230;
    FCalculateMuzzleVelocity1(rdram, ctx, runtime);
}

void entry_1ee288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee288 inside FCalculateMuzzleVelocity1 (0x1ee090 - 0x1ee290)
    ctx->pc = 0x1ee288;
    FCalculateMuzzleVelocity1(rdram, ctx, runtime);
}

void entry_1ee304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee304 inside LimitVectorLength (0x1ee2b0 - 0x1ee318)
    ctx->pc = 0x1ee304;
    LimitVectorLength(rdram, ctx, runtime);
}

void entry_1ee30c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee30c inside LimitVectorLength (0x1ee2b0 - 0x1ee318)
    ctx->pc = 0x1ee30c;
    LimitVectorLength(rdram, ctx, runtime);
}

void entry_1ee388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee388 inside Align__4VIFSi (0x1ee368 - 0x1ee3b8)
    ctx->pc = 0x1ee388;
    Align__4VIFSi(rdram, ctx, runtime);
}

void entry_1ee3b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee3b0 inside Align__4VIFSi (0x1ee368 - 0x1ee3b8)
    ctx->pc = 0x1ee3b0;
    Align__4VIFSi(rdram, ctx, runtime);
}

void entry_1ee558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee558 inside AddVifStmask__4VIFSUi (0x1ee528 - 0x1ee560)
    ctx->pc = 0x1ee558;
    AddVifStmask__4VIFSUi(rdram, ctx, runtime);
}

void entry_1ee5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee5b0 inside CbUnpackSetup__4VIFS3UPKii (0x1ee560 - 0x1ee5c8)
    ctx->pc = 0x1ee5b0;
    CbUnpackSetup__4VIFS3UPKii(rdram, ctx, runtime);
}

void entry_1ee5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee5f4 inside UnpackHelper__4VIFS3UPKiiPiPPUi (0x1ee5c8 - 0x1ee60c)
    ctx->pc = 0x1ee5f4;
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime);
}

void entry_1ee604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee604 inside UnpackHelper__4VIFS3UPKiiPiPPUi (0x1ee5c8 - 0x1ee60c)
    ctx->pc = 0x1ee604;
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime);
}

void entry_1ee61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee61c inside entry_1ee60c (0x1ee60c - 0x1ee668)
    ctx->pc = 0x1ee61c;
    entry_1ee60c(rdram, ctx, runtime);
}

void entry_1ee64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee64c inside entry_1ee60c (0x1ee60c - 0x1ee668)
    ctx->pc = 0x1ee64c;
    entry_1ee60c(rdram, ctx, runtime);
}

void entry_1ee650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee650 inside entry_1ee60c (0x1ee60c - 0x1ee668)
    ctx->pc = 0x1ee650;
    entry_1ee60c(rdram, ctx, runtime);
}

void entry_1ee6a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee6a8 inside entry_1ee688 (0x1ee688 - 0x1ee718)
    ctx->pc = 0x1ee6a8;
    entry_1ee688(rdram, ctx, runtime);
}

void entry_1ee6c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee6c4 inside entry_1ee688 (0x1ee688 - 0x1ee718)
    ctx->pc = 0x1ee6c4;
    entry_1ee688(rdram, ctx, runtime);
}

void entry_1ee6d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee6d0 inside entry_1ee688 (0x1ee688 - 0x1ee718)
    ctx->pc = 0x1ee6d0;
    entry_1ee688(rdram, ctx, runtime);
}

void entry_1ee704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee704 inside entry_1ee688 (0x1ee688 - 0x1ee718)
    ctx->pc = 0x1ee704;
    entry_1ee688(rdram, ctx, runtime);
}

void entry_1ee7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee7a8 inside entry_1ee794 (0x1ee794 - 0x1ee7d0)
    ctx->pc = 0x1ee7a8;
    entry_1ee794(rdram, ctx, runtime);
}

void entry_1ee7ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee7ac inside entry_1ee794 (0x1ee794 - 0x1ee7d0)
    ctx->pc = 0x1ee7ac;
    entry_1ee794(rdram, ctx, runtime);
}

void entry_1ee980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee980 inside entry_1ee974 (0x1ee974 - 0x1ee988)
    ctx->pc = 0x1ee980;
    entry_1ee974(rdram, ctx, runtime);
}

void entry_1ee9ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee9ac inside entry_1ee988 (0x1ee988 - 0x1ee9b8)
    ctx->pc = 0x1ee9ac;
    entry_1ee988(rdram, ctx, runtime);
}

void entry_1ee9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ee9ec inside GrfzonOneHop__FP6VISMAPP4VBSP (0x1ee9d0 - 0x1eea40)
    ctx->pc = 0x1ee9ec;
    GrfzonOneHop__FP6VISMAPP4VBSP(rdram, ctx, runtime);
}

void entry_1eea08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eea08 inside GrfzonOneHop__FP6VISMAPP4VBSP (0x1ee9d0 - 0x1eea40)
    ctx->pc = 0x1eea08;
    GrfzonOneHop__FP6VISMAPP4VBSP(rdram, ctx, runtime);
}

void entry_1eea24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eea24 inside GrfzonOneHop__FP6VISMAPP4VBSP (0x1ee9d0 - 0x1eea40)
    ctx->pc = 0x1eea24;
    GrfzonOneHop__FP6VISMAPP4VBSP(rdram, ctx, runtime);
}

void entry_1eea34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eea34 inside GrfzonOneHop__FP6VISMAPP4VBSP (0x1ee9d0 - 0x1eea40)
    ctx->pc = 0x1eea34;
    GrfzonOneHop__FP6VISMAPP4VBSP(rdram, ctx, runtime);
}

void entry_1eea88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eea88 inside entry_1eea80 (0x1eea80 - 0x1eeaf4)
    ctx->pc = 0x1eea88;
    entry_1eea80(rdram, ctx, runtime);
}

void entry_1eea90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eea90 inside entry_1eea80 (0x1eea80 - 0x1eeaf4)
    ctx->pc = 0x1eea90;
    entry_1eea80(rdram, ctx, runtime);
}

void entry_1eeae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eeae0 inside entry_1eea80 (0x1eea80 - 0x1eeaf4)
    ctx->pc = 0x1eeae0;
    entry_1eea80(rdram, ctx, runtime);
}

void entry_1eeb04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eeb04 inside entry_1eeaf4 (0x1eeaf4 - 0x1eeb14)
    ctx->pc = 0x1eeb04;
    entry_1eeaf4(rdram, ctx, runtime);
}

void entry_1eeb18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eeb18 inside entry_1eeb14 (0x1eeb14 - 0x1eeb2c)
    ctx->pc = 0x1eeb18;
    entry_1eeb14(rdram, ctx, runtime);
}

void entry_1eeb1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eeb1c inside entry_1eeb14 (0x1eeb14 - 0x1eeb2c)
    ctx->pc = 0x1eeb1c;
    entry_1eeb14(rdram, ctx, runtime);
}

void entry_1eeb38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eeb38 inside entry_1eeb2c (0x1eeb2c - 0x1eeb60)
    ctx->pc = 0x1eeb38;
    entry_1eeb2c(rdram, ctx, runtime);
}

void entry_1eeb94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eeb94 inside entry_1eeb8c (0x1eeb8c - 0x1eebb0)
    ctx->pc = 0x1eeb94;
    entry_1eeb8c(rdram, ctx, runtime);
}

void entry_1eeb98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eeb98 inside entry_1eeb8c (0x1eeb8c - 0x1eebb0)
    ctx->pc = 0x1eeb98;
    entry_1eeb8c(rdram, ctx, runtime);
}

void entry_1eeba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eeba4 inside entry_1eeb8c (0x1eeb8c - 0x1eebb0)
    ctx->pc = 0x1eeba4;
    entry_1eeb8c(rdram, ctx, runtime);
}

void entry_1eebc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eebc8 inside ClipVismapPointNoHop__FP6VISMAPP6VECTORPi (0x1eebb0 - 0x1eec60)
    ctx->pc = 0x1eebc8;
    ClipVismapPointNoHop__FP6VISMAPP6VECTORPi(rdram, ctx, runtime);
}

void entry_1eebd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eebd0 inside ClipVismapPointNoHop__FP6VISMAPP6VECTORPi (0x1eebb0 - 0x1eec60)
    ctx->pc = 0x1eebd0;
    ClipVismapPointNoHop__FP6VISMAPP6VECTORPi(rdram, ctx, runtime);
}

void entry_1eebdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eebdc inside ClipVismapPointNoHop__FP6VISMAPP6VECTORPi (0x1eebb0 - 0x1eec60)
    ctx->pc = 0x1eebdc;
    ClipVismapPointNoHop__FP6VISMAPP6VECTORPi(rdram, ctx, runtime);
}

void entry_1eebe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eebe8 inside ClipVismapPointNoHop__FP6VISMAPP6VECTORPi (0x1eebb0 - 0x1eec60)
    ctx->pc = 0x1eebe8;
    ClipVismapPointNoHop__FP6VISMAPP6VECTORPi(rdram, ctx, runtime);
}

void entry_1eec00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eec00 inside ClipVismapPointNoHop__FP6VISMAPP6VECTORPi (0x1eebb0 - 0x1eec60)
    ctx->pc = 0x1eec00;
    ClipVismapPointNoHop__FP6VISMAPP6VECTORPi(rdram, ctx, runtime);
}

void entry_1eec0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eec0c inside ClipVismapPointNoHop__FP6VISMAPP6VECTORPi (0x1eebb0 - 0x1eec60)
    ctx->pc = 0x1eec0c;
    ClipVismapPointNoHop__FP6VISMAPP6VECTORPi(rdram, ctx, runtime);
}

void entry_1eec10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eec10 inside ClipVismapPointNoHop__FP6VISMAPP6VECTORPi (0x1eebb0 - 0x1eec60)
    ctx->pc = 0x1eec10;
    ClipVismapPointNoHop__FP6VISMAPP6VECTORPi(rdram, ctx, runtime);
}

void entry_1eec54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eec54 inside ClipVismapPointNoHop__FP6VISMAPP6VECTORPi (0x1eebb0 - 0x1eec60)
    ctx->pc = 0x1eec54;
    ClipVismapPointNoHop__FP6VISMAPP6VECTORPi(rdram, ctx, runtime);
}

void entry_1eee18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eee18 inside entry_1eee08 (0x1eee08 - 0x1eee50)
    ctx->pc = 0x1eee18;
    entry_1eee08(rdram, ctx, runtime);
}

void entry_1eee24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eee24 inside entry_1eee08 (0x1eee08 - 0x1eee50)
    ctx->pc = 0x1eee24;
    entry_1eee08(rdram, ctx, runtime);
}

void entry_1eee30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eee30 inside entry_1eee08 (0x1eee08 - 0x1eee50)
    ctx->pc = 0x1eee30;
    entry_1eee08(rdram, ctx, runtime);
}

void entry_1eeed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eeed0 inside UpdateSwXaList__FP2SWPP2XA (0x1eee50 - 0x1eef04)
    ctx->pc = 0x1eeed0;
    UpdateSwXaList__FP2SWPP2XA(rdram, ctx, runtime);
}

void entry_1eef0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eef0c inside entry_1eef04 (0x1eef04 - 0x1eef14)
    ctx->pc = 0x1eef0c;
    entry_1eef04(rdram, ctx, runtime);
}

void entry_1eef18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eef18 inside entry_1eef14 (0x1eef14 - 0x1eef60)
    ctx->pc = 0x1eef18;
    entry_1eef14(rdram, ctx, runtime);
}

void entry_1eef30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eef30 inside entry_1eef14 (0x1eef14 - 0x1eef60)
    ctx->pc = 0x1eef30;
    entry_1eef14(rdram, ctx, runtime);
}

void entry_1eef38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eef38 inside entry_1eef14 (0x1eef14 - 0x1eef60)
    ctx->pc = 0x1eef38;
    entry_1eef14(rdram, ctx, runtime);
}

void entry_1eef54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eef54 inside entry_1eef14 (0x1eef14 - 0x1eef60)
    ctx->pc = 0x1eef54;
    entry_1eef14(rdram, ctx, runtime);
}

void entry_1ef000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef000 inside entry_1eefd8 (0x1eefd8 - 0x1ef094)
    ctx->pc = 0x1ef000;
    entry_1eefd8(rdram, ctx, runtime);
}

void entry_1ef01c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef01c inside entry_1eefd8 (0x1eefd8 - 0x1ef094)
    ctx->pc = 0x1ef01c;
    entry_1eefd8(rdram, ctx, runtime);
}

void entry_1ef048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef048 inside entry_1eefd8 (0x1eefd8 - 0x1ef094)
    ctx->pc = 0x1ef048;
    entry_1eefd8(rdram, ctx, runtime);
}

void entry_1ef0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef0d0 inside entry_1ef0cc (0x1ef0cc - 0x1ef0ec)
    ctx->pc = 0x1ef0d0;
    entry_1ef0cc(rdram, ctx, runtime);
}

void entry_1ef16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef16c inside entry_1ef158 (0x1ef158 - 0x1ef1f0)
    ctx->pc = 0x1ef16c;
    entry_1ef158(rdram, ctx, runtime);
}

void entry_1ef174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef174 inside entry_1ef158 (0x1ef158 - 0x1ef1f0)
    ctx->pc = 0x1ef174;
    entry_1ef158(rdram, ctx, runtime);
}

void entry_1ef1ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef1ac inside entry_1ef158 (0x1ef158 - 0x1ef1f0)
    ctx->pc = 0x1ef1ac;
    entry_1ef158(rdram, ctx, runtime);
}

void entry_1ef1bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef1bc inside entry_1ef158 (0x1ef158 - 0x1ef1f0)
    ctx->pc = 0x1ef1bc;
    entry_1ef158(rdram, ctx, runtime);
}

void entry_1ef2a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef2a8 inside entry_1ef2a4 (0x1ef2a4 - 0x1ef33c)
    ctx->pc = 0x1ef2a8;
    entry_1ef2a4(rdram, ctx, runtime);
}

void entry_1ef2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef2b0 inside entry_1ef2a4 (0x1ef2a4 - 0x1ef33c)
    ctx->pc = 0x1ef2b0;
    entry_1ef2a4(rdram, ctx, runtime);
}

void entry_1ef2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef2e0 inside entry_1ef2a4 (0x1ef2a4 - 0x1ef33c)
    ctx->pc = 0x1ef2e0;
    entry_1ef2a4(rdram, ctx, runtime);
}

void entry_1ef348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef348 inside entry_1ef33c (0x1ef33c - 0x1ef354)
    ctx->pc = 0x1ef348;
    entry_1ef33c(rdram, ctx, runtime);
}

void entry_1ef368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef368 inside entry_1ef364 (0x1ef364 - 0x1ef3a8)
    ctx->pc = 0x1ef368;
    entry_1ef364(rdram, ctx, runtime);
}

void entry_1ef428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef428 inside HandleWaterMessage__FP5WATER5MSGIDPv (0x1ef3d8 - 0x1ef430)
    ctx->pc = 0x1ef428;
    HandleWaterMessage__FP5WATER5MSGIDPv(rdram, ctx, runtime);
}

void entry_1ef440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef440 inside entry_1ef430 (0x1ef430 - 0x1ef44c)
    ctx->pc = 0x1ef440;
    entry_1ef430(rdram, ctx, runtime);
}

void entry_1ef454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef454 inside entry_1ef44c (0x1ef44c - 0x1ef4bc)
    ctx->pc = 0x1ef454;
    entry_1ef44c(rdram, ctx, runtime);
}

void entry_1ef478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef478 inside entry_1ef44c (0x1ef44c - 0x1ef4bc)
    ctx->pc = 0x1ef478;
    entry_1ef44c(rdram, ctx, runtime);
}

void entry_1ef498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef498 inside entry_1ef44c (0x1ef44c - 0x1ef4bc)
    ctx->pc = 0x1ef498;
    entry_1ef44c(rdram, ctx, runtime);
}

void entry_1ef4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef4f4 inside entry_1ef4f0 (0x1ef4f0 - 0x1ef500)
    ctx->pc = 0x1ef4f4;
    entry_1ef4f0(rdram, ctx, runtime);
}

void entry_1ef570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef570 inside entry_1ef550 (0x1ef550 - 0x1ef5a4)
    ctx->pc = 0x1ef570;
    entry_1ef550(rdram, ctx, runtime);
}

void entry_1ef59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef59c inside entry_1ef550 (0x1ef550 - 0x1ef5a4)
    ctx->pc = 0x1ef59c;
    entry_1ef550(rdram, ctx, runtime);
}

void entry_1ef5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef5a8 inside entry_1ef5a4 (0x1ef5a4 - 0x1ef5b8)
    ctx->pc = 0x1ef5a8;
    entry_1ef5a4(rdram, ctx, runtime);
}

void entry_1ef650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef650 inside entry_1ef60c (0x1ef60c - 0x1ef6e0)
    ctx->pc = 0x1ef650;
    entry_1ef60c(rdram, ctx, runtime);
}

void entry_1ef65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef65c inside entry_1ef60c (0x1ef60c - 0x1ef6e0)
    ctx->pc = 0x1ef65c;
    entry_1ef60c(rdram, ctx, runtime);
}

void entry_1ef698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef698 inside entry_1ef60c (0x1ef60c - 0x1ef6e0)
    ctx->pc = 0x1ef698;
    entry_1ef60c(rdram, ctx, runtime);
}

void entry_1ef6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef6ac inside entry_1ef60c (0x1ef60c - 0x1ef6e0)
    ctx->pc = 0x1ef6ac;
    entry_1ef60c(rdram, ctx, runtime);
}

void entry_1ef6fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef6fc inside entry_1ef6e0 (0x1ef6e0 - 0x1ef768)
    ctx->pc = 0x1ef6fc;
    entry_1ef6e0(rdram, ctx, runtime);
}

void entry_1ef708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef708 inside entry_1ef6e0 (0x1ef6e0 - 0x1ef768)
    ctx->pc = 0x1ef708;
    entry_1ef6e0(rdram, ctx, runtime);
}

void entry_1ef714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef714 inside entry_1ef6e0 (0x1ef6e0 - 0x1ef768)
    ctx->pc = 0x1ef714;
    entry_1ef6e0(rdram, ctx, runtime);
}

void entry_1ef730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef730 inside entry_1ef6e0 (0x1ef6e0 - 0x1ef768)
    ctx->pc = 0x1ef730;
    entry_1ef6e0(rdram, ctx, runtime);
}

void entry_1ef73c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef73c inside entry_1ef6e0 (0x1ef6e0 - 0x1ef768)
    ctx->pc = 0x1ef73c;
    entry_1ef6e0(rdram, ctx, runtime);
}

void entry_1ef74c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef74c inside entry_1ef6e0 (0x1ef6e0 - 0x1ef768)
    ctx->pc = 0x1ef74c;
    entry_1ef6e0(rdram, ctx, runtime);
}

void entry_1ef7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef7f8 inside entry_1ef79c (0x1ef79c - 0x1ef808)
    ctx->pc = 0x1ef7f8;
    entry_1ef79c(rdram, ctx, runtime);
}

void entry_1ef7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef7fc inside entry_1ef79c (0x1ef79c - 0x1ef808)
    ctx->pc = 0x1ef7fc;
    entry_1ef79c(rdram, ctx, runtime);
}

void entry_1ef958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef958 inside entry_1ef950 (0x1ef950 - 0x1ef97c)
    ctx->pc = 0x1ef958;
    entry_1ef950(rdram, ctx, runtime);
}

void entry_1ef980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef980 inside entry_1ef97c (0x1ef97c - 0x1ef9b4)
    ctx->pc = 0x1ef980;
    entry_1ef97c(rdram, ctx, runtime);
}

void entry_1ef9b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1ef9b8 inside entry_1ef9b4 (0x1ef9b4 - 0x1ef9c8)
    ctx->pc = 0x1ef9b8;
    entry_1ef9b4(rdram, ctx, runtime);
}

void entry_1efa18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efa18 inside entry_1efa14 (0x1efa14 - 0x1efa30)
    ctx->pc = 0x1efa18;
    entry_1efa14(rdram, ctx, runtime);
}

void entry_1efa1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efa1c inside entry_1efa14 (0x1efa14 - 0x1efa30)
    ctx->pc = 0x1efa1c;
    entry_1efa14(rdram, ctx, runtime);
}

void entry_1efa80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efa80 inside AddWpsgWaypoint__FP4WPSGP8WAYPOINT (0x1efa60 - 0x1efa88)
    ctx->pc = 0x1efa80;
    AddWpsgWaypoint__FP4WPSGP8WAYPOINT(rdram, ctx, runtime);
}

void entry_1efac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efac0 inside RemoveWpsgWaypoint__FP4WPSGP8WAYPOINT (0x1efa88 - 0x1efb04)
    ctx->pc = 0x1efac0;
    RemoveWpsgWaypoint__FP4WPSGP8WAYPOINT(rdram, ctx, runtime);
}

void entry_1efad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efad8 inside RemoveWpsgWaypoint__FP4WPSGP8WAYPOINT (0x1efa88 - 0x1efb04)
    ctx->pc = 0x1efad8;
    RemoveWpsgWaypoint__FP4WPSGP8WAYPOINT(rdram, ctx, runtime);
}

void entry_1efb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efb10 inside entry_1efb04 (0x1efb04 - 0x1efb20)
    ctx->pc = 0x1efb10;
    entry_1efb04(rdram, ctx, runtime);
}

void entry_1efba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efba0 inside UpdateWpsgCallback__FP4WPSG5MSGIDPv (0x1efb20 - 0x1efbe8)
    ctx->pc = 0x1efba0;
    UpdateWpsgCallback__FP4WPSG5MSGIDPv(rdram, ctx, runtime);
}

void entry_1efbc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efbc0 inside UpdateWpsgCallback__FP4WPSG5MSGIDPv (0x1efb20 - 0x1efbe8)
    ctx->pc = 0x1efbc0;
    UpdateWpsgCallback__FP4WPSG5MSGIDPv(rdram, ctx, runtime);
}

void entry_1efbc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efbc8 inside UpdateWpsgCallback__FP4WPSG5MSGIDPv (0x1efb20 - 0x1efbe8)
    ctx->pc = 0x1efbc8;
    UpdateWpsgCallback__FP4WPSG5MSGIDPv(rdram, ctx, runtime);
}

void entry_1efbd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efbd8 inside UpdateWpsgCallback__FP4WPSG5MSGIDPv (0x1efb20 - 0x1efbe8)
    ctx->pc = 0x1efbd8;
    UpdateWpsgCallback__FP4WPSG5MSGIDPv(rdram, ctx, runtime);
}

void entry_1efbf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efbf8 inside entry_1efbe8 (0x1efbe8 - 0x1efc64)
    ctx->pc = 0x1efbf8;
    entry_1efbe8(rdram, ctx, runtime);
}

void entry_1efc08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efc08 inside entry_1efbe8 (0x1efbe8 - 0x1efc64)
    ctx->pc = 0x1efc08;
    entry_1efbe8(rdram, ctx, runtime);
}

void entry_1efc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efc20 inside entry_1efbe8 (0x1efbe8 - 0x1efc64)
    ctx->pc = 0x1efc20;
    entry_1efbe8(rdram, ctx, runtime);
}

void entry_1efc68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efc68 inside entry_1efc64 (0x1efc64 - 0x1efc98)
    ctx->pc = 0x1efc68;
    entry_1efc64(rdram, ctx, runtime);
}

void entry_1efc78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efc78 inside entry_1efc64 (0x1efc64 - 0x1efc98)
    ctx->pc = 0x1efc78;
    entry_1efc64(rdram, ctx, runtime);
}

void entry_1efc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efc7c inside entry_1efc64 (0x1efc64 - 0x1efc98)
    ctx->pc = 0x1efc7c;
    entry_1efc64(rdram, ctx, runtime);
}

void entry_1efcd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efcd8 inside entry_1efcd4 (0x1efcd4 - 0x1efce0)
    ctx->pc = 0x1efcd8;
    entry_1efcd4(rdram, ctx, runtime);
}

void entry_1efd60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efd60 inside UpdateWipe__FP4WIPEP3JOY (0x1efd10 - 0x1efd80)
    ctx->pc = 0x1efd60;
    UpdateWipe__FP4WIPEP3JOY(rdram, ctx, runtime);
}

void entry_1efd78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efd78 inside UpdateWipe__FP4WIPEP3JOY (0x1efd10 - 0x1efd80)
    ctx->pc = 0x1efd78;
    UpdateWipe__FP4WIPEP3JOY(rdram, ctx, runtime);
}

void entry_1efd90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efd90 inside entry_1efd80 (0x1efd80 - 0x1efe30)
    ctx->pc = 0x1efd90;
    entry_1efd80(rdram, ctx, runtime);
}

void entry_1efdb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efdb8 inside entry_1efd80 (0x1efd80 - 0x1efe30)
    ctx->pc = 0x1efdb8;
    entry_1efd80(rdram, ctx, runtime);
}

void entry_1efddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efddc inside entry_1efd80 (0x1efd80 - 0x1efe30)
    ctx->pc = 0x1efddc;
    entry_1efd80(rdram, ctx, runtime);
}

void entry_1efdfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efdfc inside entry_1efd80 (0x1efd80 - 0x1efe30)
    ctx->pc = 0x1efdfc;
    entry_1efd80(rdram, ctx, runtime);
}

void entry_1efe0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efe0c inside entry_1efd80 (0x1efd80 - 0x1efe30)
    ctx->pc = 0x1efe0c;
    entry_1efd80(rdram, ctx, runtime);
}

void entry_1efe24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efe24 inside entry_1efd80 (0x1efd80 - 0x1efe30)
    ctx->pc = 0x1efe24;
    entry_1efd80(rdram, ctx, runtime);
}

void entry_1efe38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efe38 inside entry_1efe30 (0x1efe30 - 0x1efecc)
    ctx->pc = 0x1efe38;
    entry_1efe30(rdram, ctx, runtime);
}

void entry_1efe58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efe58 inside entry_1efe30 (0x1efe30 - 0x1efecc)
    ctx->pc = 0x1efe58;
    entry_1efe30(rdram, ctx, runtime);
}

void entry_1efe8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efe8c inside entry_1efe30 (0x1efe30 - 0x1efecc)
    ctx->pc = 0x1efe8c;
    entry_1efe30(rdram, ctx, runtime);
}

void entry_1efea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efea0 inside entry_1efe30 (0x1efe30 - 0x1efecc)
    ctx->pc = 0x1efea0;
    entry_1efe30(rdram, ctx, runtime);
}

void entry_1efec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efec0 inside entry_1efe30 (0x1efe30 - 0x1efecc)
    ctx->pc = 0x1efec0;
    entry_1efe30(rdram, ctx, runtime);
}

void entry_1efec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efec4 inside entry_1efe30 (0x1efe30 - 0x1efecc)
    ctx->pc = 0x1efec4;
    entry_1efe30(rdram, ctx, runtime);
}

void entry_1efed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efed0 inside entry_1efecc (0x1efecc - 0x1efee0)
    ctx->pc = 0x1efed0;
    entry_1efecc(rdram, ctx, runtime);
}

void entry_1eff2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eff2c inside DrawWipe__FP4WIPE (0x1efee0 - 0x1eff44)
    ctx->pc = 0x1eff2c;
    DrawWipe__FP4WIPE(rdram, ctx, runtime);
}

void entry_1eff4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eff4c inside entry_1eff44 (0x1eff44 - 0x1eff94)
    ctx->pc = 0x1eff4c;
    entry_1eff44(rdram, ctx, runtime);
}

void entry_1eff98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1eff98 inside entry_1eff94 (0x1eff94 - 0x1effa0)
    ctx->pc = 0x1eff98;
    entry_1eff94(rdram, ctx, runtime);
}

void entry_1efff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1efff8 inside entry_1efff4 (0x1efff4 - 0x1f00a4)
    ctx->pc = 0x1efff8;
    entry_1efff4(rdram, ctx, runtime);
}

