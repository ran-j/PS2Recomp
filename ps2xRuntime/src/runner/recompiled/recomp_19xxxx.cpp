// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_190058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190058) {
        switch (ctx->pc) {
            case 0x19005c: ctx->pc = 0; goto label_19005c;
            case 0x190060: ctx->pc = 0; goto label_190060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190058: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_19005c:
    // 0x19005c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_190060:
    // 0x190060: 0xc072472
    SET_GPR_U32(ctx, 31, 0x190068);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OnStepguardEnteringSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_190068
// Address: 0x190068 - 0x1900a0

void entry_190068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190068) {
        switch (ctx->pc) {
            case 0x190080: ctx->pc = 0; goto label_190080;
            case 0x190088: ctx->pc = 0; goto label_190088;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190068: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x19006c: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x190070: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_190080;
    }
    // 0x190078: 0x14620003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_190088;
    }
label_190080:
    // 0x190080: 0xae000c04
    WRITE32(ADD32(GPR_U32(ctx, 16), 3076), GPR_U32(ctx, 0));
    // 0x190084: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_190088:
    // 0x190088: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19008c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x190090: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x190094: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19009c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1900a0; return;
}


// Function: OnMurrayExitingSgs__FP6MURRAY3SGS
// Address: 0x1900a0 - 0x1900b4

void entry_1900b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1900b4: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1900b8: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1900bc: 0x1062000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1900F0; return;
    }
    // 0x1900c4: 0x14620014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x190118; return;
    }
    // 0x1900cc: 0x8e040c2c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3116)));
    // 0x1900d0: 0x10800012
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19011C; return;
    }
    // 0x1900d8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1900dc: 0x8c620150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x1900e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1900e8);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1900e8
// Address: 0x1900e8 - 0x190114

void entry_1900e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1900e8) {
        switch (ctx->pc) {
            case 0x1900f0: ctx->pc = 0; goto label_1900f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1900e8: 0x1000000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190118; return;
    }
label_1900f0:
    // 0x1900f0: 0x8e030600
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1536)));
    // 0x1900f4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1900f8: 0x14620007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x190118; return;
    }
    // 0x190100: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x190104: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x190108: 0x8c62014c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 332)));
    // 0x19010c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x190114);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_190114
// Address: 0x190114 - 0x190128

void entry_190114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190114) {
        switch (ctx->pc) {
            case 0x190118: ctx->pc = 0; goto label_190118;
            case 0x19011c: ctx->pc = 0; goto label_19011c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190114: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_190118:
    // 0x190118: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_19011c:
    // 0x19011c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x190124: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x190128; return;
}


// Function: UpdateMurrayGoal__FP6MURRAYi
// Address: 0x190128 - 0x1901bc

void entry_1901bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1901bc: 0x1040fff6
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190198; return;
    }
    // 0x1901c4: 0xc072106
    SET_GPR_U32(ctx, 31, 0x1901cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 320));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1901cc
// Address: 0x1901cc - 0x1901f4

void entry_1901cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1901cc) {
        switch (ctx->pc) {
            case 0x1901d4: ctx->pc = 0; goto label_1901d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1901cc: 0x1000001b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19023C; return;
    }
label_1901d4:
    // 0x1901d4: 0x14400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1901FC; return;
    }
    // 0x1901dc: 0x8e440c24
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 3108)));
    // 0x1901e0: 0x1480000c
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x190214; return;
    }
    // 0x1901e8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1901ec: 0xc072106
    SET_GPR_U32(ctx, 31, 0x1901f4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 320));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1901f4
// Address: 0x1901f4 - 0x190204

void entry_1901f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1901f4) {
        switch (ctx->pc) {
            case 0x1901fc: ctx->pc = 0; goto label_1901fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1901f4: 0x10000011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19023C; return;
    }
label_1901fc:
    // 0x1901fc: 0xc072302
    SET_GPR_U32(ctx, 31, 0x190204);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    UpdateStepguardGoal__FP9STEPGUARDi(rdram, ctx, runtime); return;
}


// Function: entry_190204
// Address: 0x190204 - 0x19021c

void entry_190204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190204) {
        switch (ctx->pc) {
            case 0x19020c: ctx->pc = 0; goto label_19020c;
            case 0x190214: ctx->pc = 0; goto label_190214;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190204: 0x1000000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19023C; return;
    }
label_19020c:
    // 0x19020c: 0x1080000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19023C; return;
    }
label_190214:
    // 0x190214: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x19021c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_19021c
// Address: 0x19021c - 0x190228

void entry_19021c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19021c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x190220: 0xc072106
    SET_GPR_U32(ctx, 31, 0x190228);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_190228
// Address: 0x190228 - 0x190238

void entry_190228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190228) {
        switch (ctx->pc) {
            case 0x190230: ctx->pc = 0; goto label_190230;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190228: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19023C; return;
    }
label_190230:
    // 0x190230: 0xc072302
    SET_GPR_U32(ctx, 31, 0x190238);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    UpdateStepguardGoal__FP9STEPGUARDi(rdram, ctx, runtime); return;
}


// Function: entry_190238
// Address: 0x190238 - 0x190258

void entry_190238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190238) {
        switch (ctx->pc) {
            case 0x19023c: ctx->pc = 0; goto label_19023c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190238: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_19023c:
    // 0x19023c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x190240: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x190244: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x190248: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19024c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x190254: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x190258; return;
}


// Function: UpdateMurraySgs__FP6MURRAY
// Address: 0x190258 - 0x19029c

void entry_19029c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19029c: 0x10000050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1903E0; return;
    }
    // 0x1902a4: 0x8e020754
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1876)));
    // 0x1902a8: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3108)));
        ctx->pc = 0x1902C0; return;
    }
    // 0x1902b0: 0xc07238a
    SET_GPR_U32(ctx, 31, 0x1902b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateStepguardSgs__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1902b8
// Address: 0x1902b8 - 0x1902d0

void entry_1902b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1902b8) {
        switch (ctx->pc) {
            case 0x1902c0: ctx->pc = 0; goto label_1902c0;
            case 0x1902c8: ctx->pc = 0; goto label_1902c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1902b8: 0x10000049
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1903E0; return;
    }
label_1902c0:
    // 0x1902c0: 0x10800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1902E4; return;
    }
label_1902c8:
    // 0x1902c8: 0xc07cf02
    SET_GPR_U32(ctx, 31, 0x1902d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetXfmMat__FP3XFMP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1902d0
// Address: 0x1902d0 - 0x1902dc

void entry_1902d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1902d0: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1902d4: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1902dc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1902dc
// Address: 0x1902dc - 0x1902ec

void entry_1902dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1902dc) {
        switch (ctx->pc) {
            case 0x1902e4: ctx->pc = 0; goto label_1902e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1902dc: 0x10000037
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1903bc(rdram, ctx, runtime); return;
    }
label_1902e4:
    // 0x1902e4: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x1902ec);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1902ec
// Address: 0x1902ec - 0x190380

void entry_1902ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1902ec: 0x1040003c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1903E0; return;
    }
    // 0x1902f4: 0x5050003b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
        ctx->pc = 0x1903E4; return;
    }
    // 0x1902fc: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x190300: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x190304: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x190308: 0x1000fff1
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1902d0(rdram, ctx, runtime); return;
    }
    // 0x190310: 0x8e040c28
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3112)));
    // 0x190314: 0x10800032
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1903E0; return;
    }
    // 0x19031c: 0x1000ffea
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1902C8; return;
    }
    // 0x190324: 0x8e0207e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    // 0x190328: 0x8e0405f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1520)));
    // 0x19032c: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x190330: 0x1464002b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x1903E0; return;
    }
    // 0x190338: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x19033c: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x190340: 0x8c621990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6544)));
    // 0x190344: 0xd8410040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x190348: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19034c: 0x1000ffe0
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1902d0(rdram, ctx, runtime); return;
    }
    // 0x190354: 0x8e020c34
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3124)));
    // 0x190358: 0x10400021
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1903E0; return;
    }
    // 0x190360: 0x8e020c2c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3116)));
    // 0x190364: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x190368: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x19036c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x190370: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x190374: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x190378: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x190380);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_190380
// Address: 0x190380 - 0x1903a0

void entry_190380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190380: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x190384: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x190388: 0x14620007
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1903A8; return;
    }
    // 0x190390: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x190394: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x190398: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1903a0);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1903a0
// Address: 0x1903a0 - 0x1903bc

void entry_1903a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1903a0) {
        switch (ctx->pc) {
            case 0x1903a8: ctx->pc = 0; goto label_1903a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1903a0: 0x10000006
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1903bc(rdram, ctx, runtime); return;
    }
label_1903a8:
    // 0x1903a8: 0x3c014096
    SET_GPR_U32(ctx, 1, ((uint32_t)16534 << 16));
    // 0x1903ac: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x1903b0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1903b4: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x1903bc);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1903bc
// Address: 0x1903bc - 0x1903cc

void entry_1903bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1903bc: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x1903c0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1903c4: 0xc071eb8
    SET_GPR_U32(ctx, 31, 0x1903cc);
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    SetStepguardTargetHeading__FP9STEPGUARDff(rdram, ctx, runtime); return;
}


// Function: entry_1903cc
// Address: 0x1903cc - 0x1903dc

void entry_1903cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1903cc) {
        switch (ctx->pc) {
            case 0x1903d4: ctx->pc = 0; goto label_1903d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1903cc: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1903E0; return;
    }
label_1903d4:
    // 0x1903d4: 0xc07238a
    SET_GPR_U32(ctx, 31, 0x1903dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateStepguardSgs__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1903dc
// Address: 0x1903dc - 0x1903f0

void entry_1903dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1903dc) {
        switch (ctx->pc) {
            case 0x1903e0: ctx->pc = 0; goto label_1903e0;
            case 0x1903e4: ctx->pc = 0; goto label_1903e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1903dc: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1903e0:
    // 0x1903e0: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1903e4:
    // 0x1903e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1903ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1903f0; return;
}


// Function: FUN_001903f0
// Address: 0x1903f0 - 0x190420

void FUN_001903f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1903f0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1903f4: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1903f8: 0x8c622c64
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11364)));
    // 0x1903fc: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x190400: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x190404: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x190408: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x19040c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x190410: 0x14400005
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x190428; return;
    }
    // 0x190418: 0xc0776a0
    SET_GPR_U32(ctx, 31, 0x190420);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    IsSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_190420
// Address: 0x190420 - 0x190438

void entry_190420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190420) {
        switch (ctx->pc) {
            case 0x190428: ctx->pc = 0; goto label_190428;
            case 0x190430: ctx->pc = 0; goto label_190430;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190420: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_190430;
    }
label_190428:
    // 0x190428: 0x10000003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_190438(rdram, ctx, runtime); return;
    }
label_190430:
    // 0x190430: 0xc072692
    SET_GPR_U32(ctx, 31, 0x190438);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001c9a48(rdram, ctx, runtime); return;
}


// Function: entry_190438
// Address: 0x190438 - 0x190450

void entry_190438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190438: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19043c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x190440: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x190444: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19044c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x190450; return;
}


// Function: FUN_00190450
// Address: 0x190450 - 0x190478

void FUN_00190450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190450: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x190454: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x190458: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x19045c: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x190460: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x190464: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x190468: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19046c: 0x8c62013c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 316)));
    // 0x190470: 0x40f809
    SET_GPR_U32(ctx, 31, 0x190478);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_190478
// Address: 0x190478 - 0x1904b0

void entry_190478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190478: 0x14400013
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_1904c8(rdram, ctx, runtime); return;
    }
    // 0x190480: 0xae000c34
    WRITE32(ADD32(GPR_U32(ctx, 16), 3124), GPR_U32(ctx, 0));
    // 0x190484: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x190488: 0xae020c30
    WRITE32(ADD32(GPR_U32(ctx, 16), 3120), GPR_U32(ctx, 2));
    // 0x19048c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x190490: 0x1460000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1904C0; return;
    }
    // 0x190498: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x19049c: 0x10a00008
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1904C0; return;
    }
    // 0x1904a4: 0x8e020c2c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3116)));
    // 0x1904a8: 0xc06a208
    SET_GPR_U32(ctx, 31, 0x1904b0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1560)));
    FIsRwmAmmo__FP3RWMP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1904b0
// Address: 0x1904b0 - 0x1904c8

void entry_1904b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1904b0) {
        switch (ctx->pc) {
            case 0x1904bc: ctx->pc = 0; goto label_1904bc;
            case 0x1904c0: ctx->pc = 0; goto label_1904c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1904b0: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1904bc;
    }
    // 0x1904b8: 0xae020c34
    WRITE32(ADD32(GPR_U32(ctx, 16), 3124), GPR_U32(ctx, 2));
label_1904bc:
    // 0x1904bc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1904c0:
    // 0x1904c0: 0xc072664
    SET_GPR_U32(ctx, 31, 0x1904c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FTakeStepguardDamage__FP9STEPGUARDP3ZPR(rdram, ctx, runtime); return;
}


// Function: entry_1904c8
// Address: 0x1904c8 - 0x1904e0

void entry_1904c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1904c8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1904cc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1904d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1904d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1904dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1904e0; return;
}


// Function: FAbsorbMurrayWkr__FP6MURRAYP3WKR
// Address: 0x1904e0 - 0x1904fc

void entry_1904fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1904fc) {
        switch (ctx->pc) {
            case 0x190518: ctx->pc = 0; goto label_190518;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1904fc: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 2664), GPR_U32(ctx, 0));
        goto label_190518;
    }
    // 0x190504: 0x8e020c34
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3124)));
    // 0x190508: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 2664), GPR_U32(ctx, 0));
        goto label_190518;
    }
    // 0x190510: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x190514: 0xae020a68
    WRITE32(ADD32(GPR_U32(ctx, 16), 2664), GPR_U32(ctx, 2));
label_190518:
    // 0x190518: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19051c: 0xc0725b6
    SET_GPR_U32(ctx, 31, 0x190524);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FAbsorbStepguardWkr__FP9STEPGUARDP3WKR(rdram, ctx, runtime); return;
}


// Function: entry_190524
// Address: 0x190524 - 0x19054c

void entry_190524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190524: 0x1040000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190554; return;
    }
    // 0x19052c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x190530: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x190534: 0x24050017
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 23));
    // 0x190538: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x19053c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x190540: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x190544: 0x60f809
    SET_GPR_U32(ctx, 31, 0x19054c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_19054c
// Address: 0x19054c - 0x190570

void entry_19054c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19054c) {
        switch (ctx->pc) {
            case 0x190554: ctx->pc = 0; goto label_190554;
            case 0x190558: ctx->pc = 0; goto label_190558;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19054c: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_190558;
    }
label_190554:
    // 0x190554: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_190558:
    // 0x190558: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19055c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x190560: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x190564: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19056c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x190570; return;
}


// Function: FDetectMurray__FP6MURRAY
// Address: 0x190570 - 0x1905dc

void entry_1905dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1905dc: 0x1040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190608; return;
    }
    // 0x1905e4: 0x8e110724
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1905e8: 0x1236fff3
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 22)) {
        ctx->pc = 0x1905B8; return;
    }
    // 0x1905f0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1905f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1905f8
// Address: 0x1905f8 - 0x190610

void entry_1905f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1905f8) {
        switch (ctx->pc) {
            case 0x190608: ctx->pc = 0; goto label_190608;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1905f8: 0x14400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_190608;
    }
    // 0x190600: 0x5235ffee
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 21)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
        ctx->pc = 0x1905BC; return;
    }
label_190608:
    // 0x190608: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x190610);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_190610
// Address: 0x190610 - 0x190658

void entry_190610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190610) {
        switch (ctx->pc) {
            case 0x190628: ctx->pc = 0; goto label_190628;
            case 0x19062c: ctx->pc = 0; goto label_19062c;
            case 0x190630: ctx->pc = 0; goto label_190630;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190610: 0x1040ffea
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1905BC; return;
    }
    // 0x190618: 0x8e820c10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 3088)));
    // 0x19061c: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x190620: 0x14400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_190630;
    }
label_190628:
    // 0x190628: 0xae800c28
    WRITE32(ADD32(GPR_U32(ctx, 20), 3112), GPR_U32(ctx, 0));
label_19062c:
    // 0x19062c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_190630:
    // 0x190630: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x190634: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x190638: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19063c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x190640: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x190644: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x190648: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19064c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x190650: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FCanMurrayAttack__FP6MURRAY
// Address: 0x190658 - 0x190660

void FUN_00190660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190660: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x190664: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x190668: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x19066c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x190670: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x190674: 0x12000016
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1906D0; return;
    }
    // 0x19067c: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x190684);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_190684
// Address: 0x190684 - 0x190694

void entry_190684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190684: 0x10400012
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1906D0; return;
    }
    // 0x19068c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x190694);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_190694
// Address: 0x190694 - 0x1906e8

void entry_190694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190694) {
        switch (ctx->pc) {
            case 0x1906a8: ctx->pc = 0; goto label_1906a8;
            case 0x1906d0: ctx->pc = 0; goto label_1906d0;
            case 0x1906d4: ctx->pc = 0; goto label_1906d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190694: 0x10400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1906a8;
    }
    // 0x19069c: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1906a0: 0x1062000c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1906d4;
    }
label_1906a8:
    // 0x1906a8: 0x8e240c10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 3088)));
    // 0x1906ac: 0x2c820004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 4));
    // 0x1906b0: 0x10400007
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1906d0;
    }
    // 0x1906b8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1906bc: 0x2231821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x1906c0: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x1906c4: 0xac700c14
    WRITE32(ADD32(GPR_U32(ctx, 3), 3092), GPR_U32(ctx, 16));
    // 0x1906c8: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 17), 3088), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1906d4;
    }
label_1906d0:
    // 0x1906d0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1906d4:
    // 0x1906d4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1906d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1906dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1906e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetMurrayPursueXfm__FP6MURRAYP3XFM
// Address: 0x1906e8 - 0x1906f0

void entry_190714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190714: 0x16000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x190730; return;
    }
    // 0x19071c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x190720: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x190724: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x19072c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 1520)));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_19072c
// Address: 0x19072c - 0x190740

void entry_19072c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19072c) {
        switch (ctx->pc) {
            case 0x190730: ctx->pc = 0; goto label_190730;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19072c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_190730:
    // 0x190730: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x190734: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x190738: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00190740
// Address: 0x190740 - 0x190770

void FUN_00190740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190740) {
        switch (ctx->pc) {
            case 0x190760: ctx->pc = 0; goto label_190760;
            case 0x190768: ctx->pc = 0; goto label_190768;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190740: 0x8c830724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1828)));
    // 0x190744: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x190748: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_190760;
    }
    // 0x190750: 0x14620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_190768;
    }
    // 0x190758: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
label_190760:
    // 0x190760: 0x3e00008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 31); return;
label_190768:
    // 0x190768: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleMurrayMessage
// Address: 0x190770 - 0x190794

void entry_190794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190794: 0x24020013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 19));
    // 0x190798: 0x1602000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1907CC; return;
    }
    // 0x1907a0: 0x8e4307e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 2016)));
    // 0x1907a4: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1907a8: 0x14430009
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1907D0; return;
    }
    // 0x1907b0: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1907b4: 0x2402053a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1338));
    // 0x1907b8: 0x14620006
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1907D4; return;
    }
    // 0x1907c0: 0xc058368
    SET_GPR_U32(ctx, 31, 0x1907c8);
    reload_post_death(rdram, ctx, runtime); return;
}


// Function: entry_1907c8
// Address: 0x1907c8 - 0x1907e0

void entry_1907c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1907c8) {
        switch (ctx->pc) {
            case 0x1907cc: ctx->pc = 0; goto label_1907cc;
            case 0x1907d0: ctx->pc = 0; goto label_1907d0;
            case 0x1907d4: ctx->pc = 0; goto label_1907d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1907c8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1907cc:
    // 0x1907cc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1907d0:
    // 0x1907d0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1907d4:
    // 0x1907d4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1907d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PcbspExtract__FP4CBSP
// Address: 0x1907e0 - 0x1907f0

void entry_190878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190878) {
        switch (ctx->pc) {
            case 0x190888: ctx->pc = 0; goto label_190888;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190878: 0x1440000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1908AC; return;
    }
    // 0x190880: 0x10000006
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19089C; return;
    }
label_190888:
    // 0x190888: 0xc0641fc
    SET_GPR_U32(ctx, 31, 0x190890);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    PcgtExtract__FP3CGT(rdram, ctx, runtime); return;
}


// Function: entry_190890
// Address: 0x190890 - 0x1908c0

void entry_190890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190890) {
        switch (ctx->pc) {
            case 0x19089c: ctx->pc = 0; goto label_19089c;
            case 0x1908a4: ctx->pc = 0; goto label_1908a4;
            case 0x1908ac: ctx->pc = 0; goto label_1908ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190890: 0x14400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1908ac;
    }
    // 0x190898: 0x8e100014
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 20)));
label_19089c:
    // 0x19089c: 0x5600ffe8
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x190840; return;
    }
label_1908a4:
    // 0x1908a4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1908a8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1908ac:
    // 0x1908ac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1908b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1908b4: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1908b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PcgtPointInCbspSafe__FP4CBSPP6VECTOR
// Address: 0x1908c0 - 0x19093c

void entry_19093c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19093c) {
        switch (ctx->pc) {
            case 0x19094c: ctx->pc = 0; goto label_19094c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19093c: 0x14400015
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x190994; return;
    }
    // 0x190944: 0x1000000f
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190984; return;
    }
label_19094c:
    // 0x19094c: 0xc0641fc
    SET_GPR_U32(ctx, 31, 0x190954);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    PcgtExtract__FP3CGT(rdram, ctx, runtime); return;
}


// Function: entry_190954
// Address: 0x190954 - 0x190968

void entry_190954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190954: 0x1440000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x190994; return;
    }
    // 0x19095c: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x190960: 0xc064230
    SET_GPR_U32(ctx, 31, 0x190968);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PcgtPointInCbspSafe__FP4CBSPP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_190968
// Address: 0x190968 - 0x190978

void entry_190968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190968) {
        switch (ctx->pc) {
            case 0x190970: ctx->pc = 0; goto label_190970;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190968: 0x1440000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x190994; return;
    }
label_190970:
    // 0x190970: 0xc0641fc
    SET_GPR_U32(ctx, 31, 0x190978);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    PcgtExtract__FP3CGT(rdram, ctx, runtime); return;
}


// Function: entry_190978
// Address: 0x190978 - 0x1909b0

void entry_190978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190978) {
        switch (ctx->pc) {
            case 0x190984: ctx->pc = 0; goto label_190984;
            case 0x19098c: ctx->pc = 0; goto label_19098c;
            case 0x190994: ctx->pc = 0; goto label_190994;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190978: 0x14400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_190994;
    }
    // 0x190980: 0x8e100014
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 20)));
label_190984:
    // 0x190984: 0x5600ffdc
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x1908F8; return;
    }
label_19098c:
    // 0x19098c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x190990: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_190994:
    // 0x190994: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x190998: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19099c: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x1909a0: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x1909a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1909ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1909b0; return;
}


// Function: CbskFromG__Ff
// Address: 0x1909b0 - 0x1909f0

void entry_190c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190c40: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x190c44: 0xc06426c
    SET_GPR_U32(ctx, 31, 0x190c4c);
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    CbskFromG__Ff(rdram, ctx, runtime); return;
}


// Function: entry_190c4c
// Address: 0x190c4c - 0x190cac

void entry_190c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190c4c) {
        switch (ctx->pc) {
            case 0x190c64: ctx->pc = 0; goto label_190c64;
            case 0x190c7c: ctx->pc = 0; goto label_190c7c;
            case 0x190c84: ctx->pc = 0; goto label_190c84;
            case 0x190c90: ctx->pc = 0; goto label_190c90;
            case 0x190ca4: ctx->pc = 0; goto label_190ca4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190c4c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x190c50: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x190c54: 0x16020003
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_190c64;
    }
    // 0x190c5c: 0x54600050
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
        ctx->pc = 0x190DA0; return;
    }
label_190c64:
    // 0x190c64: 0x14620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_190c7c;
    }
    // 0x190c6c: 0x12000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_190c84;
    }
    // 0x190c74: 0x1000004b
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190DA4; return;
    }
label_190c7c:
    // 0x190c7c: 0x16000004
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_190c90;
    }
label_190c84:
    // 0x190c84: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x190c88: 0x14660006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 6)) {
        goto label_190ca4;
    }
label_190c90:
    // 0x190c90: 0x1460000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x190CC0; return;
    }
    // 0x190c98: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x190c9c: 0x12070007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 7)) {
        ctx->pc = 0x190CBC; return;
    }
label_190ca4:
    // 0x190ca4: 0xc0641fc
    SET_GPR_U32(ctx, 31, 0x190cac);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    PcgtExtract__FP3CGT(rdram, ctx, runtime); return;
}


// Function: entry_190cac
// Address: 0x190cac - 0x190d38

void entry_190cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190cac) {
        switch (ctx->pc) {
            case 0x190cbc: ctx->pc = 0; goto label_190cbc;
            case 0x190cc0: ctx->pc = 0; goto label_190cc0;
            case 0x190cd4: ctx->pc = 0; goto label_190cd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190cac: 0x14400045
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x190DC4; return;
    }
    // 0x190cb4: 0x10000047
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190DD4; return;
    }
label_190cbc:
    // 0x190cbc: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_190cc0:
    // 0x190cc0: 0x56020004
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->f[3] = FPU_SUB_S(ctx->f[20], ctx->f[21]);
        goto label_190cd4;
    }
    // 0x190cc8: 0x10700035
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x190DA0; return;
    }
    // 0x190cd0: 0x4615a0c1
    ctx->f[3] = FPU_SUB_S(ctx->f[20], ctx->f[21]);
label_190cd4:
    // 0x190cd4: 0xc7a10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    // 0x190cd8: 0xc6250008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[5] = *(float*)&val; }
    // 0x190cdc: 0x4601b081
    ctx->f[2] = FPU_SUB_S(ctx->f[22], ctx->f[1]);
    // 0x190ce0: 0x4603a183
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[6] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[6] = ctx->f[20] / ctx->f[3];
    // 0x190ce4: 0x4605b001
    ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[5]);
    // 0x190ce8: 0x4601a8c2
    ctx->f[3] = FPU_MUL_S(ctx->f[21], ctx->f[1]);
    // 0x190cec: 0x46141082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[20]);
    // 0x190cf0: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x190cf4: 0x4605a902
    ctx->f[4] = FPU_MUL_S(ctx->f[21], ctx->f[5]);
    // 0x190cf8: 0x46060834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[6])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x190cfc: 0x46021d00
    ctx->f[20] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x190d00: 0x4500001c
    ctx->f[21] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x190D74; return;
    }
    // 0x190d08: 0x46053034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x190d0c: 0x45000019
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x190D74; return;
    }
    // 0x190d14: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x190d18: 0x2631000c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 12));
    // 0x190d1c: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x190d20: 0x0
    // NOP
    // 0x190d24: 0x4500000d
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 17), 8), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x190D5C; return;
    }
    // 0x190d2c: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x190d30: 0xc0641fc
    SET_GPR_U32(ctx, 31, 0x190d38);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    PcgtExtract__FP3CGT(rdram, ctx, runtime); return;
}


// Function: entry_190d38
// Address: 0x190d38 - 0x190d70

void entry_190d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190d38) {
        switch (ctx->pc) {
            case 0x190d4c: ctx->pc = 0; goto label_190d4c;
            case 0x190d5c: ctx->pc = 0; goto label_190d5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190d38: 0x10400004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_190d4c;
    }
    // 0x190d40: 0xae200000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
    // 0x190d44: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190D74; return;
    }
label_190d4c:
    // 0x190d4c: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x190d50: 0xae200004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 0));
    // 0x190d54: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190D74; return;
    }
label_190d5c:
    // 0x190d5c: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x190d60: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x190d64: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x190d68: 0xc0641f8
    SET_GPR_U32(ctx, 31, 0x190d70);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    PcbspExtract__FP4CBSP(rdram, ctx, runtime); return;
}


// Function: entry_190d70
// Address: 0x190d70 - 0x190dac

void entry_190d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190d70) {
        switch (ctx->pc) {
            case 0x190d74: ctx->pc = 0; goto label_190d74;
            case 0x190da0: ctx->pc = 0; goto label_190da0;
            case 0x190da4: ctx->pc = 0; goto label_190da4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190d70: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
label_190d74:
    // 0x190d74: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x190d78: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x190d7c: 0x0
    // NOP
    // 0x190d80: 0x45010007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_190da0;
    }
    // 0x190d88: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x190d8c: 0x45000009
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x190DB4; return;
    }
    // 0x190d94: 0x4600a836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x190d98: 0x45000006
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x190DB4; return;
    }
label_190da0:
    // 0x190da0: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
label_190da4:
    // 0x190da4: 0xc0641f8
    SET_GPR_U32(ctx, 31, 0x190dac);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    PcbspExtract__FP4CBSP(rdram, ctx, runtime); return;
}


// Function: entry_190dac
// Address: 0x190dac - 0x190dbc

void entry_190dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190dac) {
        switch (ctx->pc) {
            case 0x190db4: ctx->pc = 0; goto label_190db4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190dac: 0x1000ff38
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190A90; return;
    }
label_190db4:
    // 0x190db4: 0xc0641fc
    SET_GPR_U32(ctx, 31, 0x190dbc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    PcgtExtract__FP3CGT(rdram, ctx, runtime); return;
}


// Function: entry_190dbc
// Address: 0x190dbc - 0x190e30

void entry_190dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190dbc) {
        switch (ctx->pc) {
            case 0x190dc4: ctx->pc = 0; goto label_190dc4;
            case 0x190dd0: ctx->pc = 0; goto label_190dd0;
            case 0x190dd4: ctx->pc = 0; goto label_190dd4;
            case 0x190de0: ctx->pc = 0; goto label_190de0;
            case 0x190dec: ctx->pc = 0; goto label_190dec;
            case 0x190df0: ctx->pc = 0; goto label_190df0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190dbc: 0x10400004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_190dd0;
    }
label_190dc4:
    // 0x190dc4: 0xafa00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 0));
    // 0x190dc8: 0x1000ff31
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190A90; return;
    }
label_190dd0:
    // 0x190dd0: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
label_190dd4:
    // 0x190dd4: 0xafa00004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 0));
    // 0x190dd8: 0x1000ff2d
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190A90; return;
    }
label_190de0:
    // 0x190de0: 0x2c81018
    { int64_t result = (int64_t)GPR_S32(ctx, 22) * (int64_t)GPR_S32(ctx, 8); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x190de4: 0x10000002
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_190df0;
    }
label_190dec:
    // 0x190dec: 0x3c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
label_190df0:
    // 0x190df0: 0x7bbf0240
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x190df4: 0x7bbe0230
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x190df8: 0x7bb70220
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x190dfc: 0x7bb60210
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x190e00: 0x7bb50200
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x190e04: 0x7bb401f0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x190e08: 0x7bb301e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x190e0c: 0x7bb201d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x190e10: 0x7bb101c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x190e14: 0x7bb001b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x190e18: 0xc7b60260
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 608)); ctx->f[22] = *(float*)&val; }
    // 0x190e1c: 0xc7b50258
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 600)); ctx->f[21] = *(float*)&val; }
    // 0x190e20: 0xc7b40250
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 592)); ctx->f[20] = *(float*)&val; }
    // 0x190e24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 624));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x190e2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x190e30; return;
}


// Function: FClipEdgeToCbsp__FP4CBSPP6VECTORT1
// Address: 0x190e30 - 0x190e44

void entry_190e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190e44) {
        switch (ctx->pc) {
            case 0x190e64: ctx->pc = 0; goto label_190e64;
            case 0x190e94: ctx->pc = 0; goto label_190e94;
            case 0x190e98: ctx->pc = 0; goto label_190e98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190e44: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x190e48: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x190e4c: 0x10620005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_190e64;
    }
    // 0x190e54: 0x5040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_190e94;
    }
    // 0x190e5c: 0x1000000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_190e98;
    }
label_190e64:
    // 0x190e64: 0xc7a10040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[1] = *(float*)&val; }
    // 0x190e68: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x190e6c: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x190e70: 0x0
    // NOP
    // 0x190e74: 0x45000007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 68)); ctx->f[1] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_190e94;
    }
    // 0x190e7c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x190e80: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x190e84: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x190e88: 0x0
    // NOP
    // 0x190e8c: 0x45010002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_190e98;
    }
label_190e94:
    // 0x190e94: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_190e98:
    // 0x190e98: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x190e9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x190ea4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x190ea8; return;
}


// Function: IcgvFromPcgv__FP2CGP3CGV
// Address: 0x190ea8 - 0x190eb8

void entry_190efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x190efc: 0x8ec40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x190f00: 0xc0635aa
    SET_GPR_U32(ctx, 31, 0x190f08);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocStackClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_190f08
// Address: 0x190f08 - 0x190fb0

void entry_190f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190f08) {
        switch (ctx->pc) {
            case 0x190f68: ctx->pc = 0; goto label_190f68;
            case 0x190f80: ctx->pc = 0; goto label_190f80;
            case 0x190f98: ctx->pc = 0; goto label_190f98;
            case 0x190fa8: ctx->pc = 0; goto label_190fa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190f08: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x190f0c: 0x3a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x190f10: 0x8fa20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x190f14: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x190f18: 0xafa00020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
    // 0x190f1c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x190f20: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x190f24: 0xdaa20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x190f28: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x190f2c: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    // 0x190f30: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x190f34: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x190f38: 0xafb00000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 16));
    // 0x190f3c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x190f40: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x190f44: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x190f48: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x190f4c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x190f50: 0xafa0000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 0));
    // 0x190f54: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x190f58: 0x12150054
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x1910AC; return;
    }
    // 0x190f60: 0x8e340000
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x190f64: 0x0
    // NOP
label_190f68:
    // 0x190f68: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x190f6c: 0x18400047
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x19108C; return;
    }
    // 0x190f74: 0x241e0001
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 1));
    // 0x190f78: 0x8e830014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x190f7c: 0x0
    // NOP
label_190f80:
    // 0x190f80: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x190f84: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x190f88: 0x8c530000
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x190f8c: 0x8e700000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x190f90: 0x52140001
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 4)));
        goto label_190f98;
    }
label_190f98:
    // 0x190f98: 0x16150003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 21)) {
        goto label_190fa8;
    }
    // 0x190fa0: 0x1000000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x190FCC; return;
    }
label_190fa8:
    // 0x190fa8: 0xc0643aa
    SET_GPR_U32(ctx, 31, 0x190fb0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    IcgvFromPcgv__FP2CGP3CGV(rdram, ctx, runtime); return;
}


// Function: entry_190fb0
// Address: 0x190fb0 - 0x190fdc

void entry_190fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190fb0) {
        switch (ctx->pc) {
            case 0x190fcc: ctx->pc = 0; goto label_190fcc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190fb0: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x190fb4: 0x571821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x190fb8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x190fbc: 0x14400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_190fcc;
    }
    // 0x190fc4: 0xac7e0000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 30));
    // 0x190fc8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_190fcc:
    // 0x190fcc: 0x1440002b
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19107C; return;
    }
    // 0x190fd4: 0xc063596
    SET_GPR_U32(ctx, 31, 0x190fdc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 24));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_190fdc
// Address: 0x190fdc - 0x1910f8

void entry_190fdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x190fdc) {
        switch (ctx->pc) {
            case 0x191050: ctx->pc = 0; goto label_191050;
            case 0x191064: ctx->pc = 0; goto label_191064;
            case 0x191078: ctx->pc = 0; goto label_191078;
            case 0x19107c: ctx->pc = 0; goto label_19107c;
            case 0x19108c: ctx->pc = 0; goto label_19108c;
            case 0x1910ac: ctx->pc = 0; goto label_1910ac;
            case 0x1910c0: ctx->pc = 0; goto label_1910c0;
            case 0x1910e8: ctx->pc = 0; goto label_1910e8;
            case 0x1910ec: ctx->pc = 0; goto label_1910ec;
            case 0x1910f0: ctx->pc = 0; goto label_1910f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x190fdc: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x190fe0: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x190fe4: 0xac700000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 16));
    // 0x190fe8: 0xc6600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 8)); ctx->f[0] = *(float*)&val; }
    // 0x190fec: 0xc6210008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[1] = *(float*)&val; }
    // 0x190ff0: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x190ff4: 0xe4610008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 8), *(uint32_t*)&val); }
    // 0x190ff8: 0xda810000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x190ffc: 0xdaa20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x191000: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x191004: 0xac71000c
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 17));
    // 0x191008: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19100c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x191010: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x191014: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x191018: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19101c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x191020: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x191024: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x191028: 0xe4610004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
    // 0x19102c: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x191030: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x191034: 0xac620010
    WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 2));
    // 0x191038: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19103c: 0x5040000e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 20), GPR_U32(ctx, 2));
        goto label_191078;
    }
    // 0x191044: 0x10000007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_191064;
    }
    // 0x19104c: 0x0
    // NOP
label_191050:
    // 0x191050: 0x8c420014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x191054: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 20), GPR_U32(ctx, 2));
        goto label_191078;
    }
    // 0x19105c: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x191060: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
label_191064:
    // 0x191064: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x191068: 0x0
    // NOP
    // 0x19106c: 0x4502fff8
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 20));
        goto label_191050;
    }
    // 0x191074: 0xac620014
    WRITE32(ADD32(GPR_U32(ctx, 3), 20), GPR_U32(ctx, 2));
label_191078:
    // 0x191078: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
label_19107c:
    // 0x19107c: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x191080: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x191084: 0x5440ffbe
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 20)));
        ctx->pc = 0x190F80; return;
    }
label_19108c:
    // 0x19108c: 0x8fb10020
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x191090: 0x12200016
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1910ec;
    }
    // 0x191098: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x19109c: 0xafa20020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    // 0x1910a0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1910a4: 0x5475ffb0
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 21)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x190F68; return;
    }
label_1910ac:
    // 0x1910ac: 0x1220000e
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_1910e8;
    }
    // 0x1910b4: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1910b8: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1910bc: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
label_1910c0:
    // 0x1910c0: 0x8fa40028
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1910c4: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1910c8: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1910cc: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1910d0: 0xac43fffc
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294967292), GPR_U32(ctx, 3));
    // 0x1910d4: 0x8e31000c
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1910d8: 0x5620fff9
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
        goto label_1910c0;
    }
    // 0x1910e0: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1910f0;
    }
label_1910e8:
    // 0x1910e8: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
label_1910ec:
    // 0x1910ec: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
label_1910f0:
    // 0x1910f0: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1910f8);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1910f8
// Address: 0x1910f8 - 0x191128

void entry_1910f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1910f8: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1910fc: 0x7bbe00b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x191100: 0x7bb700a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x191104: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x191108: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19110c: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x191110: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x191114: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x191118: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19111c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x191120: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SimplifyApcgvNeighbor__FP4CBSPPiPP3CGV
// Address: 0x191128 - 0x191170

void entry_191170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191170: 0x8fd60000
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x191174: 0x162080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 22), 2));
    // 0x191178: 0xc063596
    SET_GPR_U32(ctx, 31, 0x191180);
    SET_GPR_U32(ctx, 21, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 4)));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_191180
// Address: 0x191180 - 0x1911ac

void entry_191180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191180) {
        switch (ctx->pc) {
            case 0x1911a0: ctx->pc = 0; goto label_1911a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191180: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x191184: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x191188: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x19118c: 0x215202b
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 21)));
    // 0x191190: 0xae820000
    WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 2));
    // 0x191194: 0x10800017
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1911F4; return;
    }
    // 0x19119c: 0x8e650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_1911a0:
    // 0x1911a0: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1911a4: 0xc06438c
    SET_GPR_U32(ctx, 31, 0x1911ac);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    FClipEdgeToCbsp__FP4CBSPP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_1911ac
// Address: 0x1911ac - 0x191240

void entry_1911ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1911ac) {
        switch (ctx->pc) {
            case 0x1911e0: ctx->pc = 0; goto label_1911e0;
            case 0x1911e8: ctx->pc = 0; goto label_1911e8;
            case 0x1911f4: ctx->pc = 0; goto label_1911f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1911ac: 0x1040000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1911e0;
    }
    // 0x1911b4: 0x220982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1911b8: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1911bc: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1911c0: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1911c4: 0x541021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1911c8: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x1911cc: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
    // 0x1911d0: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1911d4: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1911d8: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1911e8;
    }
label_1911e0:
    // 0x1911e0: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1911e4: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
label_1911e8:
    // 0x1911e8: 0x215102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 21)));
    // 0x1911ec: 0x5440ffec
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x1911A0; return;
    }
label_1911f4:
    // 0x1911f4: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1911f8: 0x161080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
    // 0x1911fc: 0x521021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x191200: 0x8c44fffc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294967292)));
    // 0x191204: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x191208: 0x741821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 20)));
    // 0x19120c: 0xac640000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
    // 0x191210: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191214: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x191218: 0x56182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 22)));
    // 0x19121c: 0x10600008
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_191240(rdram, ctx, runtime); return;
    }
    // 0x191224: 0x28420003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 3));
    // 0x191228: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 0)));
        ctx->pc = 0x191244; return;
    }
    // 0x191230: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x191234: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x191238: 0xc06444a
    SET_GPR_U32(ctx, 31, 0x191240);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SimplifyApcgvNeighbor__FP4CBSPPiPP3CGV(rdram, ctx, runtime); return;
}


// Function: entry_191240
// Address: 0x191240 - 0x191254

void entry_191240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191240) {
        switch (ctx->pc) {
            case 0x191244: ctx->pc = 0; goto label_191244;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191240: 0x8fa60000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_191244:
    // 0x191244: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x191248: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19124c: 0xc063600
    SET_GPR_U32(ctx, 31, 0x191254);
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 2));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_191254
// Address: 0x191254 - 0x191260

void entry_191254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191254: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191258: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x191260);
    WRITE32(ADD32(GPR_U32(ctx, 30), 0), GPR_U32(ctx, 2));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_191260
// Address: 0x191260 - 0x191290

void entry_191260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191260: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x191264: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x191268: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19126c: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x191270: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x191274: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x191278: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19127c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x191280: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x191284: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x191288: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CposFindPath__FP2CGP6VECTORT1iT1
// Address: 0x191290 - 0x1912d8

void entry_1912d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1912d8) {
        switch (ctx->pc) {
            case 0x1912f0: ctx->pc = 0; goto label_1912f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1912d8: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1912dc: 0x12600004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_1912f0;
    }
    // 0x1912e4: 0x7a020000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1912e8: 0x10000008
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19130C; return;
    }
label_1912f0:
    // 0x1912f0: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1912f4: 0xc06455c
    SET_GPR_U32(ctx, 31, 0x1912fc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FindClosestPointInCg__FP2CGP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_1912fc
// Address: 0x1912fc - 0x191308

void entry_1912fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1912fc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x191300: 0xc064230
    SET_GPR_U32(ctx, 31, 0x191308);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PcgtPointInCbspSafe__FP4CBSPP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_191308
// Address: 0x191308 - 0x191318

void entry_191308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191308) {
        switch (ctx->pc) {
            case 0x19130c: ctx->pc = 0; goto label_19130c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191308: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_19130c:
    // 0x19130c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x191310: 0xc064204
    SET_GPR_U32(ctx, 31, 0x191318);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PcgtPointInCbspQuick__FP4CBSPP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_191318
// Address: 0x191318 - 0x191340

void entry_191318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191318) {
        switch (ctx->pc) {
            case 0x191330: ctx->pc = 0; goto label_191330;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191318: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19131c: 0x12800004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_191330;
    }
    // 0x191324: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x191328: 0x10000009
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x191350; return;
    }
label_191330:
    // 0x191330: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x191334: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x191338: 0xc06455c
    SET_GPR_U32(ctx, 31, 0x191340);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FindClosestPointInCg__FP2CGP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_191340
// Address: 0x191340 - 0x19134c

void entry_191340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191340: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x191344: 0xc064230
    SET_GPR_U32(ctx, 31, 0x19134c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PcgtPointInCbspSafe__FP4CBSPP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_19134c
// Address: 0x19134c - 0x191374

void entry_19134c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19134c) {
        switch (ctx->pc) {
            case 0x191350: ctx->pc = 0; goto label_191350;
            case 0x19136c: ctx->pc = 0; goto label_19136c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19134c: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_191350:
    // 0x191350: 0x16740006
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 20)) {
        goto label_19136c;
    }
    // 0x191358: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x19135c: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x191360: 0x7ec40000
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), GPR_VEC(ctx, 4));
    // 0x191364: 0x10000076
    WRITE128(ADD32(GPR_U32(ctx, 22), 16), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x191540; return;
    }
label_19136c:
    // 0x19136c: 0xc063582
    SET_GPR_U32(ctx, 31, 0x191374);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_191374
// Address: 0x191374 - 0x19137c

void entry_191374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191374: 0xc063596
    SET_GPR_U32(ctx, 31, 0x19137c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 512));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_19137c
// Address: 0x19137c - 0x19139c

void entry_19137c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19137c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x191380: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191384: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x191388: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x19138c: 0xafa20030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 2));
    // 0x191390: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x191394: 0xc063596
    SET_GPR_U32(ctx, 31, 0x19139c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_19139c
// Address: 0x19139c - 0x1914b0

void entry_19139c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19139c) {
        switch (ctx->pc) {
            case 0x1913c0: ctx->pc = 0; goto label_1913c0;
            case 0x191438: ctx->pc = 0; goto label_191438;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19139c: 0xafa20034
    WRITE32(ADD32(GPR_U32(ctx, 29), 52), GPR_U32(ctx, 2));
    // 0x1913a0: 0x200582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1913a4: 0x27a90090
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 144));
    // 0x1913a8: 0x27a60070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 112));
    // 0x1913ac: 0x27b200c0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1913b0: 0x260402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1913b4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1913b8: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1913bc: 0x0
    // NOP
label_1913c0:
    // 0x1913c0: 0xacb00000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 16));
    // 0x1913c4: 0x71880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 7), 2));
    // 0x1913c8: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1913cc: 0x8d020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1913d0: 0x28e40003
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 7), 3));
    // 0x1913d4: 0x25080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4));
    // 0x1913d8: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x1913dc: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1913e0: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1913e4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1913e8: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1913ec: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1913f0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1913f4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1913f8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1913fc: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x191400: 0xaca20008
    WRITE32(ADD32(GPR_U32(ctx, 5), 8), GPR_U32(ctx, 2));
    // 0x191404: 0x8fa20034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x191408: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19140c: 0xac650000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 5));
    // 0x191410: 0x1480ffeb
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 12));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1913c0;
    }
    // 0x191418: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19141c: 0x120382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x191420: 0xafa00080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 0));
    // 0x191424: 0xc0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x191428: 0x7fa20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 2));
    // 0x19142c: 0x280482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x191430: 0xafa00084
    WRITE32(ADD32(GPR_U32(ctx, 29), 132), GPR_U32(ctx, 0));
    // 0x191434: 0x24080002
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
label_191438:
    // 0x191438: 0x8d250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x19143c: 0x2508ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967295));
    // 0x191440: 0xacea0004
    WRITE32(ADD32(GPR_U32(ctx, 7), 4), GPR_U32(ctx, 10));
    // 0x191444: 0x25290004
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4));
    // 0x191448: 0xace50000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 5));
    // 0x19144c: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x191450: 0xd8a10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x191454: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x191458: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19145c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x191460: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x191464: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x191468: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19146c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x191470: 0xace20008
    WRITE32(ADD32(GPR_U32(ctx, 7), 8), GPR_U32(ctx, 2));
    // 0x191474: 0x8ca30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x191478: 0x8ca40014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 20)));
    // 0x19147c: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x191480: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x191484: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x191488: 0xac470000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 7));
    // 0x19148c: 0xaca30010
    WRITE32(ADD32(GPR_U32(ctx, 5), 16), GPR_U32(ctx, 3));
    // 0x191490: 0x501ffe9
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 12));
    if (GPR_S32(ctx, 8) >= 0) {
        goto label_191438;
    }
    // 0x191498: 0x160282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x19149c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1914a0: 0x24070080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 128));
    // 0x1914a4: 0x240402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1914a8: 0xc0643ae
    SET_GPR_U32(ctx, 31, 0x1914b0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FindPathAStar__FP2CGP3CGVT1iPiPP3CGV(rdram, ctx, runtime); return;
}


// Function: entry_1914b0
// Address: 0x1914b0 - 0x1914d0

void entry_1914b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1914b0: 0x8fa200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1914b4: 0x28420003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 3));
    // 0x1914b8: 0x14400006
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1914D4; return;
    }
    // 0x1914c0: 0x8ea40020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 32)));
    // 0x1914c4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1914c8: 0xc06444a
    SET_GPR_U32(ctx, 31, 0x1914d0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SimplifyApcgvNeighbor__FP4CBSPPiPP3CGV(rdram, ctx, runtime); return;
}


// Function: entry_1914d0
// Address: 0x1914d0 - 0x19153c

void entry_1914d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1914d0) {
        switch (ctx->pc) {
            case 0x1914d4: ctx->pc = 0; goto label_1914d4;
            case 0x1914f0: ctx->pc = 0; goto label_1914f0;
            case 0x19150c: ctx->pc = 0; goto label_19150c;
            case 0x191518: ctx->pc = 0; goto label_191518;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1914d0: 0x8fa300c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 192)));
label_1914d4:
    // 0x1914d4: 0x2e0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1914d8: 0x2e3102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 23), GPR_S32(ctx, 3)));
    // 0x1914dc: 0x62800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    // 0x1914e0: 0x1a00000a
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) <= 0) {
        goto label_19150c;
    }
    // 0x1914e8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1914ec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1914f0:
    // 0x1914f0: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1914f4: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x1914f8: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x1914fc: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x191500: 0x7d020000
    WRITE128(ADD32(GPR_U32(ctx, 8), 0), GPR_VEC(ctx, 2));
    // 0x191504: 0x1480fffa
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 16));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1914f0;
    }
label_19150c:
    // 0x19150c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x191510: 0x24080002
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    // 0x191514: 0x0
    // NOP
label_191518:
    // 0x191518: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19151c: 0x2508ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967295));
    // 0x191520: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x191524: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x191528: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x19152c: 0x501fffa
    WRITE32(ADD32(GPR_U32(ctx, 3), 16), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 8) >= 0) {
        goto label_191518;
    }
    // 0x191534: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x19153c);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19153c
// Address: 0x19153c - 0x191570

void entry_19153c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19153c) {
        switch (ctx->pc) {
            case 0x191540: ctx->pc = 0; goto label_191540;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19153c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_191540:
    // 0x191540: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x191544: 0x7bb70140
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x191548: 0x7bb60130
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x19154c: 0x7bb50120
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x191550: 0x7bb40110
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x191554: 0x7bb30100
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x191558: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x19155c: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x191560: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x191564: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19156c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x191570; return;
}


// Function: FindClosestPointInCg__FP2CGP6VECTORT1
// Address: 0x191570 - 0x1915b0

void entry_1915b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1915b0) {
        switch (ctx->pc) {
            case 0x1915c4: ctx->pc = 0; goto label_1915c4;
            case 0x1915e8: ctx->pc = 0; goto label_1915e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1915b0: 0x10400004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1915c4;
    }
    // 0x1915b8: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1915bc: 0x10000037
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19169C; return;
    }
label_1915c4:
    // 0x1915c4: 0x8e23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1915c8: 0xc454b64c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948428)); ctx->f[20] = *(float*)&val; }
    // 0x1915cc: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1915d0: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1915d4: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1915d8: 0x18600020
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x19165C; return;
    }
    // 0x1915e0: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1915e4: 0x0
    // NOP
label_1915e8:
    // 0x1915e8: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1915ec: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1915f0: 0xc6400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1915f4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1915f8: 0x548021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1915fc: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x191600: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x191604: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x191608: 0x27a80024
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 36));
    // 0x19160c: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x191610: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x191614: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x191618: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x19161c: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x191620: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x191624: 0xc0618c8
    SET_GPR_U32(ctx, 31, 0x19162c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime); return;
}


// Function: entry_19162c
// Address: 0x19162c - 0x1916d0

void entry_19162c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19162c) {
        switch (ctx->pc) {
            case 0x19164c: ctx->pc = 0; goto label_19164c;
            case 0x19165c: ctx->pc = 0; goto label_19165c;
            case 0x19169c: ctx->pc = 0; goto label_19169c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19162c: 0xc7a00024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[0] = *(float*)&val; }
    // 0x191630: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x191634: 0x0
    // NOP
    // 0x191638: 0x45000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19164c;
    }
    // 0x191640: 0xc7b50020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[21] = *(float*)&val; }
    // 0x191644: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x191648: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
label_19164c:
    // 0x19164c: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x191650: 0x2a2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 2)));
    // 0x191654: 0x1440ffe4
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1915E8; return;
    }
label_19165c:
    // 0x19165c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x191660: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x191664: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x191668: 0x46150001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[21]);
    // 0x19166c: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x191670: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x191674: 0x8e630004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x191678: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x19167c: 0x48a41000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x191680: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x191684: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x191688: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19168c: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x191690: 0x4be219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x191694: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x191698: 0xfac20000
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), _mm_castps_si128(ctx->vu0_vf[2]));
label_19169c:
    // 0x19169c: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1916a0: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1916a4: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1916a8: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1916ac: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1916b0: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1916b4: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1916b8: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1916bc: 0xc7b500b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[21] = *(float*)&val; }
    // 0x1916c0: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x1916c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1916cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1916d0; return;
}


// Function: LoadPathzoneFromBrx__FP8PATHZONEP18CBinaryInputStream
// Address: 0x1916d0 - 0x191704

void entry_191704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191704: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x191708: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x191710);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_191710
// Address: 0x191710 - 0x19171c

void entry_191710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191710: 0x22140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 5));
    // 0x191714: 0xc063570
    SET_GPR_U32(ctx, 31, 0x19171c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 52), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_19171c
// Address: 0x19171c - 0x191728

void entry_19171c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19171c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x191720: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x191728);
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_191728
// Address: 0x191728 - 0x191734

void entry_191728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191728: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19172c: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x191734);
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 2));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_191734
// Address: 0x191734 - 0x191748

void entry_191734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191734: 0x8e43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x191738: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19173c: 0x512018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x191740: 0xc063570
    SET_GPR_U32(ctx, 31, 0x191748);
    WRITE32(ADD32(GPR_U32(ctx, 18), 8), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_191748
// Address: 0x191748 - 0x191754

void entry_191748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191748: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19174c: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x191754);
    WRITE32(ADD32(GPR_U32(ctx, 18), 16), GPR_U32(ctx, 2));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_191754
// Address: 0x191754 - 0x191760

void entry_191754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191754: 0x512018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x191758: 0xc063570
    SET_GPR_U32(ctx, 31, 0x191760);
    WRITE32(ADD32(GPR_U32(ctx, 18), 20), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_191760
// Address: 0x191760 - 0x191794

void entry_191760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191760) {
        switch (ctx->pc) {
            case 0x191778: ctx->pc = 0; goto label_191778;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191760: 0xae420018
    WRITE32(ADD32(GPR_U32(ctx, 18), 24), GPR_U32(ctx, 2));
    // 0x191764: 0x8e020034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x191768: 0x58400029
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
        ctx->pc = 0x191810; return;
    }
    // 0x191770: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x191774: 0x0
    // NOP
label_191778:
    // 0x191778: 0x131140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 5));
    // 0x19177c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x191780: 0x26750001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 19), 1));
    // 0x191784: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x191788: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19178c: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x191794);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_191794
// Address: 0x191794 - 0x19179c

void entry_191794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191794: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x19179c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19179c
// Address: 0x19179c - 0x1917ac

void entry_19179c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19179c: 0x24440001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1917a0: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x1917a4: 0xc063540
    SET_GPR_U32(ctx, 31, 0x1917ac);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1917ac
// Address: 0x1917ac - 0x1917c8

void entry_1917ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1917ac) {
        switch (ctx->pc) {
            case 0x1917c0: ctx->pc = 0; goto label_1917c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1917ac: 0x8e030010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1917b0: 0x18600011
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1917F8; return;
    }
    // 0x1917b8: 0x2413000c
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1917bc: 0x0
    // NOP
label_1917c0:
    // 0x1917c0: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1917c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1917c8
// Address: 0x1917c8 - 0x19183c

void entry_1917c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1917c8) {
        switch (ctx->pc) {
            case 0x1917f8: ctx->pc = 0; goto label_1917f8;
            case 0x191810: ctx->pc = 0; goto label_191810;
            case 0x191820: ctx->pc = 0; goto label_191820;
            case 0x191830: ctx->pc = 0; goto label_191830;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1917c8: 0x531018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1917cc: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1917d0: 0x8e440010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x1917d4: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x1917d8: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1917dc: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1917e0: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1917e4: 0xac640000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 4));
    // 0x1917e8: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1917ec: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1917f0: 0x1440fff3
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1917C0; return;
    }
label_1917f8:
    // 0x1917f8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1917fc: 0x2a0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x191800: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x191804: 0x5440ffdc
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
        ctx->pc = 0x191778; return;
    }
    // 0x19180c: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
label_191810:
    // 0x191810: 0x18400015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x191868; return;
    }
    // 0x191818: 0x2415000c
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 12));
    // 0x19181c: 0x951818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 21); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
label_191820:
    // 0x191820: 0x8e420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x191824: 0x24930001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 4), 1));
    // 0x191828: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19182c: 0x438021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_191830:
    // 0x191830: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x191834: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x19183c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19183c
// Address: 0x19183c - 0x19189c

void entry_19183c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19183c) {
        switch (ctx->pc) {
            case 0x191868: ctx->pc = 0; goto label_191868;
            case 0x191880: ctx->pc = 0; goto label_191880;
            case 0x191890: ctx->pc = 0; goto label_191890;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19183c: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x191840: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x191844: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x191848: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    // 0x19184c: 0x621fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x191830; return;
    }
    // 0x191854: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x191858: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19185c: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x191860: 0x1440ffef
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 21); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x191820; return;
    }
label_191868:
    // 0x191868: 0x8e420014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x19186c: 0x18400016
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1918C8; return;
    }
    // 0x191874: 0x2415000c
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 12));
    // 0x191878: 0x951818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 21); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x19187c: 0x0
    // NOP
label_191880:
    // 0x191880: 0x8e420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x191884: 0x24930001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 4), 1));
    // 0x191888: 0x24110002
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    // 0x19188c: 0x438021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
label_191890:
    // 0x191890: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x191894: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x19189c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19189c
// Address: 0x19189c - 0x1918d4

void entry_19189c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19189c) {
        switch (ctx->pc) {
            case 0x1918c8: ctx->pc = 0; goto label_1918c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19189c: 0x8e430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1918a0: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x1918a4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1918a8: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    // 0x1918ac: 0x621fff8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x191890; return;
    }
    // 0x1918b4: 0x8e420014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1918b8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1918bc: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x1918c0: 0x1440ffef
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 21); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x191880; return;
    }
label_1918c8:
    // 0x1918c8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1918cc: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1918d4);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1918d4
// Address: 0x1918d4 - 0x1918e0

void entry_1918d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1918d4: 0x22140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 5));
    // 0x1918d8: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1918e0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 28), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1918e0
// Address: 0x1918e0 - 0x19190c

void entry_1918e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1918e0) {
        switch (ctx->pc) {
            case 0x1918f8: ctx->pc = 0; goto label_1918f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1918e0: 0x8e43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x1918e4: 0x18600039
    WRITE32(ADD32(GPR_U32(ctx, 18), 32), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1919CC; return;
    }
    // 0x1918ec: 0x2415ffff
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1918f0: 0x2413000c
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1918f4: 0x8e430020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 32)));
label_1918f8:
    // 0x1918f8: 0x111140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 5));
    // 0x1918fc: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x191900: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x191904: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x19190c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_19190c
// Address: 0x19190c - 0x191914

void entry_19190c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19190c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x191914);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_191914
// Address: 0x191914 - 0x191920

void entry_191914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191914: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x191918: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x191920);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_191920
// Address: 0x191920 - 0x191970

void entry_191920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191920) {
        switch (ctx->pc) {
            case 0x191934: ctx->pc = 0; goto label_191934;
            case 0x19194c: ctx->pc = 0; goto label_19194c;
            case 0x191968: ctx->pc = 0; goto label_191968;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191920: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x191924: 0x14950003
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 21)) {
        goto label_191934;
    }
    // 0x19192c: 0x1000000e
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_191968;
    }
label_191934:
    // 0x191934: 0x4800005
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 5));
    if (GPR_S32(ctx, 4) < 0) {
        goto label_19194c;
    }
    // 0x19193c: 0x8e420020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x191940: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x191944: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_191968;
    }
label_19194c:
    // 0x19194c: 0x24840002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 2));
    // 0x191950: 0x8e430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x191954: 0x42023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 4)));
    // 0x191958: 0x931018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x19195c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x191960: 0x34630001
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 1));
    // 0x191964: 0xae030014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 3));
label_191968:
    // 0x191968: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x191970);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_191970
// Address: 0x191970 - 0x1919d4

void entry_191970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191970) {
        switch (ctx->pc) {
            case 0x191984: ctx->pc = 0; goto label_191984;
            case 0x19199c: ctx->pc = 0; goto label_19199c;
            case 0x1919b8: ctx->pc = 0; goto label_1919b8;
            case 0x1919cc: ctx->pc = 0; goto label_1919cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191970: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x191974: 0x14950003
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 21)) {
        goto label_191984;
    }
    // 0x19197c: 0x1000000e
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1919b8;
    }
label_191984:
    // 0x191984: 0x4800005
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 5));
    if (GPR_S32(ctx, 4) < 0) {
        goto label_19199c;
    }
    // 0x19198c: 0x8e420020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x191990: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x191994: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1919b8;
    }
label_19199c:
    // 0x19199c: 0x24840002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 2));
    // 0x1919a0: 0x8e430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1919a4: 0x42023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 0), GPR_U32(ctx, 4)));
    // 0x1919a8: 0x931018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1919ac: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1919b0: 0x34630001
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 1));
    // 0x1919b4: 0xae030018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 3));
label_1919b8:
    // 0x1919b8: 0x8e42001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x1919bc: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1919c0: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1919c4: 0x5440ffcc
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 32)));
        ctx->pc = 0x1918F8; return;
    }
label_1919cc:
    // 0x1919cc: 0xc06467e
    SET_GPR_U32(ctx, 31, 0x1919d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    HookupCg__FP2CG(rdram, ctx, runtime); return;
}


// Function: entry_1919d4
// Address: 0x1919d4 - 0x1919f8

void entry_1919d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1919d4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1919d8: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1919dc: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1919e0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1919e4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1919e8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1919ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1919f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HookupCg__FP2CG
// Address: 0x1919f8 - 0x191a68

void entry_191a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191a78: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191a7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x191a84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x191a88; return;
}


// Function: FindPathzoneClosestPoint__FP8PATHZONEP6VECTORT1
// Address: 0x191a88 - 0x191a98

void entry_191a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191a98: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191a9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x191aa4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x191aa8; return;
}


// Function: FUN_00191aa8
// Address: 0x191aa8 - 0x191ab8

void FUN_00191aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191aa8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x191aac: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x191ab0: 0xc06427c
    SET_GPR_U32(ctx, 31, 0x191ab8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 84)));
    ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_191ab8
// Address: 0x191ab8 - 0x191ac8

void entry_191ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191ab8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191abc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x191ac4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x191ac8; return;
}


// Function: FUN_00191ac8
// Address: 0x191ac8 - 0x191b50

void FUN_00191ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191ac8) {
        switch (ctx->pc) {
            case 0x191b38: ctx->pc = 0; goto label_191b38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191ac8: 0x27bdfe00
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966784));
    // 0x191acc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x191ad0: 0x7fb601b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 432), GPR_VEC(ctx, 22));
    // 0x191ad4: 0xe7b501f8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 504), *(uint32_t*)&val); }
    // 0x191ad8: 0xe7b401f0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 496), *(uint32_t*)&val); }
    // 0x191adc: 0x7fbe01d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 464), GPR_VEC(ctx, 30));
    // 0x191ae0: 0x7fb701c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 448), GPR_VEC(ctx, 23));
    // 0x191ae4: 0x3c1e0025
    SET_GPR_U32(ctx, 30, ((uint32_t)37 << 16));
    // 0x191ae8: 0x7fb501a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), GPR_VEC(ctx, 21));
    // 0x191aec: 0x80b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x191af0: 0x7fb40190
    WRITE128(ADD32(GPR_U32(ctx, 29), 400), GPR_VEC(ctx, 20));
    // 0x191af4: 0x27b50030
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 48));
    // 0x191af8: 0x7fb30180
    WRITE128(ADD32(GPR_U32(ctx, 29), 384), GPR_VEC(ctx, 19));
    // 0x191afc: 0x27b40050
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 80));
    // 0x191b00: 0x7fb20170
    WRITE128(ADD32(GPR_U32(ctx, 29), 368), GPR_VEC(ctx, 18));
    // 0x191b04: 0x24539b78
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 2), 4294941560));
    // 0x191b08: 0x7fb10160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), GPR_VEC(ctx, 17));
    // 0x191b0c: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x191b10: 0x7fb00150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), GPR_VEC(ctx, 16));
    // 0x191b14: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x191b18: 0x7fbf01e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 480), GPR_VEC(ctx, 31));
    // 0x191b1c: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x191b20: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x191b24: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x191b28: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x191b2c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x191b30: 0x44166000
    SET_GPR_U32(ctx, 22, *(uint32_t*)&ctx->f[12]);
    // 0x191b34: 0x0
    // NOP
label_191b38:
    // 0x191b38: 0x2c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x191b3c: 0xc66c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 0)); ctx->f[12] = *(float*)&val; }
    // 0x191b40: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x191b44: 0x7fa20130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 2));
    // 0x191b48: 0xc062214
    SET_GPR_U32(ctx, 31, 0x191b50);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 4294937888));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_191b50
// Address: 0x191b50 - 0x191b9c

void entry_191b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191b50: 0xdba20130
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x191b54: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x191b58: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191b5c: 0x27a50100
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 256));
    // 0x191b60: 0x4be218d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x191b64: 0xdba40130
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x191b68: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x191b6c: 0x24060030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 48));
    // 0x191b70: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x191b74: 0x4be40858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x191b78: 0x4be41098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x191b7c: 0xfba30100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x191b80: 0xfba10110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x191b84: 0xfba20120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x191b88: 0x7ba20130
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x191b8c: 0xda040000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x191b90: 0x7fa200f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 2));
    // 0x191b94: 0xc07d696
    SET_GPR_U32(ctx, 31, 0x191b9c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[4]));
    memcpy(rdram, ctx, runtime); return;
}


// Function: entry_191b9c
// Address: 0x191b9c - 0x191bdc

void entry_191b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191b9c: 0xda420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x191ba0: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x191ba4: 0xdba500c0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x191ba8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x191bac: 0xdba300d0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x191bb0: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x191bb4: 0xdba100e0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x191bb8: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x191bbc: 0x4bc229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x191bc0: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x191bc4: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x191bc8: 0xdba40140
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x191bcc: 0x4be22128
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x191bd0: 0x280402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x191bd4: 0xc0646aa
    SET_GPR_U32(ctx, 31, 0x191bdc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    FUN_00191aa8(rdram, ctx, runtime); return;
}


// Function: entry_191bdc
// Address: 0x191bdc - 0x191c78

void entry_191bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191bdc) {
        switch (ctx->pc) {
            case 0x191c0c: ctx->pc = 0; goto label_191c0c;
            case 0x191c1c: ctx->pc = 0; goto label_191c1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191bdc: 0x1040000b
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_191c0c;
    }
    // 0x191be4: 0xc7a00094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 148)); ctx->f[0] = *(float*)&val; }
    // 0x191be8: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x191bec: 0x0
    // NOP
    // 0x191bf0: 0x45000006
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_191c0c;
    }
    // 0x191bf8: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x191bfc: 0x4614a836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[21], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x191c00: 0x0
    // NOP
    // 0x191c04: 0x45010005
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_191c1c;
    }
label_191c0c:
    // 0x191c0c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x191c10: 0x2e22000b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 11));
    // 0x191c14: 0x1440ffc8
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x191B38; return;
    }
label_191c1c:
    // 0x191c1c: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x191c20: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x191c24: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x191c28: 0xfba400c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x191c2c: 0x4a6403bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x191c30: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x191c34: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x191c38: 0x7bbf01e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x191c3c: 0xfa410000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x191c40: 0x7bbe01d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x191c44: 0x7bb701c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x191c48: 0x7bb601b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x191c4c: 0x7bb501a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x191c50: 0x7bb40190
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x191c54: 0x7bb30180
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x191c58: 0x7bb20170
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x191c5c: 0x7bb10160
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x191c60: 0x7bb00150
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x191c64: 0xc7b501f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 504)); ctx->f[21] = *(float*)&val; }
    // 0x191c68: 0xc7b401f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 496)); ctx->f[20] = *(float*)&val; }
    // 0x191c6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 512));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x191c74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x191c78; return;
}


// Function: ChoosePathzoneRandomPoint__FP8PATHZONEP6VECTOR
// Address: 0x191c78 - 0x191d24

void entry_191d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191d24) {
        switch (ctx->pc) {
            case 0x191d40: ctx->pc = 0; goto label_191d40;
            case 0x191db0: ctx->pc = 0; goto label_191db0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191d24: 0x8e220048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 72)));
    // 0x191d28: 0x46000106
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    // 0x191d2c: 0x18400020
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_191db0;
    }
    // 0x191d34: 0x8e24004c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x191d38: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x191d3c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_191d40:
    // 0x191d40: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x191d44: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x191d48: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x191d4c: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x191d50: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x191d54: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x191d58: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x191d5c: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x191d60: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x191d64: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x191d68: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x191d6c: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x191d70: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x191d74: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x191d78: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x191d7c: 0xc7a20014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[2] = *(float*)&val; }
    // 0x191d80: 0xc7a30010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[3] = *(float*)&val; }
    // 0x191d84: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x191d88: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x191d8c: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x191d90: 0x46012101
    ctx->f[4] = FPU_SUB_S(ctx->f[4], ctx->f[1]);
    // 0x191d94: 0x460c2034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x191d98: 0x0
    // NOP
    // 0x191d9c: 0x45010004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_191db0;
    }
    // 0x191da4: 0xa6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 6)));
    // 0x191da8: 0x1440ffe5
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_191d40;
    }
label_191db0:
    // 0x191db0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x191db4: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x191db8: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x191dbc: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x191dc0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x191dc8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_191dc8
// Address: 0x191dc8 - 0x191dd8

void entry_191dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191dc8: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x191dcc: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x191dd0: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x191dd8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_191dd8
// Address: 0x191dd8 - 0x191e70

void entry_191dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191dd8) {
        switch (ctx->pc) {
            case 0x191df4: ctx->pc = 0; goto label_191df4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191dd8: 0x46000346
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    // 0x191ddc: 0x460da800
    ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[13]);
    // 0x191de0: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x191de4: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_191df4;
    }
    // 0x191dec: 0x4615b541
    ctx->f[21] = FPU_SUB_S(ctx->f[22], ctx->f[21]);
    // 0x191df0: 0x460db341
    ctx->f[13] = FPU_SUB_S(ctx->f[22], ctx->f[13]);
label_191df4:
    // 0x191df4: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x191df8: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x191dfc: 0x4615b001
    ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[21]);
    // 0x191e00: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x191e04: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x191e08: 0x44036800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[13]);
    // 0x191e0c: 0x48a32800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x191e10: 0x460d0001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[13]);
    // 0x191e14: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x191e18: 0xd8460000
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x191e1c: 0xfba50020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x191e20: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x191e24: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x191e28: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x191e2c: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x191e30: 0xd8630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x191e34: 0xfba40020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x191e38: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x191e3c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x191e40: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x191e44: 0x4be231bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x191e48: 0x4be518bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x191e4c: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x191e50: 0xc7b60080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[22] = *(float*)&val; }
    // 0x191e54: 0xfa420000
    WRITE128(ADD32(GPR_U32(ctx, 18), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x191e58: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x191e5c: 0xc7b50078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[21] = *(float*)&val; }
    // 0x191e60: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x191e64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x191e6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x191e70; return;
}


// Function: SetPhase__F5PHASE
// Address: 0x191e70 - 0x191e98

void entry_191e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x191e98) {
        switch (ctx->pc) {
            case 0x191e9c: ctx->pc = 0; goto label_191e9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x191e98: 0xae309ba4
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294941604), GPR_U32(ctx, 16));
label_191e9c:
    // 0x191e9c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x191ea0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x191ea4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191ea8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClearPhase__F5PHASE
// Address: 0x191eb0 - 0x191ec0

void entry_191ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191ed8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191edc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x191ee4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x191ee8; return;
}


// Function: ResetPipeList__Fv
// Address: 0x191ee8 - 0x191efc

void entry_191efc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191efc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191f00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitPipe__FP4PIPE
// Address: 0x191f08 - 0x191f1c

void entry_191f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191f1c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x191f20: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x191f24: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x191f28: 0xc460b650
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294948432)); ctx->f[0] = *(float*)&val; }
    // 0x191f2c: 0x78440000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x191f30: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x191f34: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    // 0x191f38: 0x24030008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 8));
    // 0x191f3c: 0xae050064
    WRITE32(ADD32(GPR_U32(ctx, 16), 100), GPR_U32(ctx, 5));
    // 0x191f40: 0x7e040040
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 4));
    // 0x191f44: 0xae020054
    WRITE32(ADD32(GPR_U32(ctx, 16), 84), GPR_U32(ctx, 2));
    // 0x191f48: 0xae030050
    WRITE32(ADD32(GPR_U32(ctx, 16), 80), GPR_U32(ctx, 3));
    // 0x191f4c: 0xe600005c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 92), *(uint32_t*)&val); }
    // 0x191f50: 0xae050058
    WRITE32(ADD32(GPR_U32(ctx, 16), 88), GPR_U32(ctx, 5));
    // 0x191f54: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x191f58: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191f5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x191f64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x191f68; return;
}


// Function: OnPipeAdd__FP4PIPE
// Address: 0x191f68 - 0x191f7c

void entry_191f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191f7c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x191f80: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x191f84: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x191f8c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941608));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_191f8c
// Address: 0x191f8c - 0x191fa0

void entry_191f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191f8c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x191f90: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191f94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x191f9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x191fa0; return;
}


// Function: OnPipeRemove__FP4PIPE
// Address: 0x191fa0 - 0x191fb4

void entry_191fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191fb4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x191fb8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x191fbc: 0xc054980
    SET_GPR_U32(ctx, 31, 0x191fc4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941608));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_191fc4
// Address: 0x191fc4 - 0x191fd8

void entry_191fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191fc4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x191fc8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x191fcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x191fd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x191fd8; return;
}


// Function: PostPipeLoad__FP4PIPE
// Address: 0x191fd8 - 0x191fec

void entry_191fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x191fec: 0x8e060064
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 100)));
    // 0x191ff0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x191ff4: 0x10c20005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19200C; return;
    }
    // 0x191ffc: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x192000: 0xc056906
    SET_GPR_U32(ctx, 31, 0x192008);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_192008
// Address: 0x192008 - 0x192020

void entry_192008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192008) {
        switch (ctx->pc) {
            case 0x19200c: ctx->pc = 0; goto label_19200c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192008: 0xae020068
    WRITE32(ADD32(GPR_U32(ctx, 16), 104), GPR_U32(ctx, 2));
label_19200c:
    // 0x19200c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x192010: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192014: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19201c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192020; return;
}


// Function: ClonePipe__FP4PIPET0
// Address: 0x192020 - 0x192048

void entry_192048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192048: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x19204c: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x192050: 0xb202003f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 63); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x192054: 0xb6020038
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 56); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x192058: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19205c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x192060: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadPntFromBrx__FP3PNTP18CBinaryInputStream
// Address: 0x192068 - 0x19208c

void entry_19208c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19208c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x192090: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x192098);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_192098
// Address: 0x192098 - 0x1920b0

void entry_192098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192098: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19209c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1920a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1920a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1920ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1920b0; return;
}


// Function: GetPntPos__FP3PNTP6VECTOR
// Address: 0x1920b0 - 0x1920d0

void entry_1920d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1920d0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1920d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1920dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1920e0; return;
}


// Function: SetPntParent__FP3PNTP3ALO
// Address: 0x1920e0 - 0x192108

void entry_192108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192108: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19210c: 0xc060bde
    SET_GPR_U32(ctx, 31, 0x192114);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_192114
// Address: 0x192114 - 0x192128

void entry_192114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192114: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x192118: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19211c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192120: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ApplyPntProxy__FP3PNTP5PROXY
// Address: 0x192128 - 0x192144

void entry_192144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192144: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192148: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00192150__FP3PNTP18CBinaryInputStream
// Address: 0x192150 - 0x19216c

void FUN_00192150__FP3PNTP18CBinaryInputStream(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192150: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x192154: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x192158: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x19215c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x192160: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x192164: 0xc06481a
    SET_GPR_U32(ctx, 31, 0x19216c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    LoadPntFromBrx__FP3PNTP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19216c
// Address: 0x19216c - 0x192178

void entry_19216c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19216c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x192170: 0xc04e128
    SET_GPR_U32(ctx, 31, 0x192178);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 80));
    ReadStringSw__18CBinaryInputStreamPPc(rdram, ctx, runtime); return;
}


// Function: entry_192178
// Address: 0x192178 - 0x192190

void entry_192178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192178: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19217c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x192180: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192184: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19218c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192190; return;
}


// Function: FUN_00192190__FP3PNT
// Address: 0x192190 - 0x1921a8

void FUN_00192190__FP3PNT(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192190: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x192194: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x192198: 0xe4800058
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 88), *(uint32_t*)&val); }
    // 0x19219c: 0x3e00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 84), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1921a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1921a8; return;
}


// Function: InitPo__FP2PO
// Address: 0x1921a8 - 0x1921bc

void entry_1921bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1921bc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1921c0: 0xae100598
    WRITE32(ADD32(GPR_U32(ctx, 16), 1432), GPR_U32(ctx, 16));
    // 0x1921c4: 0xae020580
    WRITE32(ADD32(GPR_U32(ctx, 16), 1408), GPR_U32(ctx, 2));
    // 0x1921c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1921cc: 0xc064a64
    SET_GPR_U32(ctx, 31, 0x1921d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetPoPlayable__FP2POi(rdram, ctx, runtime); return;
}


// Function: entry_1921d4
// Address: 0x1921d4 - 0x1921e8

void entry_1921d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1921d4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1921d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1921dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1921e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1921e8; return;
}


// Function: ClonePo__FP2POT0
// Address: 0x1921e8 - 0x1921fc

void entry_1921fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1921fc: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x192200: 0x14400007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x192220; return;
    }
    // 0x192208: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19220c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x192210: 0xae020550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 2));
    // 0x192214: 0xc064a64
    SET_GPR_U32(ctx, 31, 0x19221c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetPoPlayable__FP2POi(rdram, ctx, runtime); return;
}


// Function: entry_19221c
// Address: 0x19221c - 0x192230

void entry_19221c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19221c) {
        switch (ctx->pc) {
            case 0x192220: ctx->pc = 0; goto label_192220;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19221c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_192220:
    // 0x192220: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192224: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19222c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192230; return;
}


// Function: HandlePoMessage__FP2PO5MSGIDPv
// Address: 0x192230 - 0x192254

void entry_192254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192254) {
        switch (ctx->pc) {
            case 0x192270: ctx->pc = 0; goto label_192270;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192254: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x192258: 0x12220005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_192270;
    }
    // 0x192260: 0x12220008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x192284; return;
    }
    // 0x192268: 0x1000001a
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1922D4; return;
    }
label_192270:
    // 0x192270: 0x8e040574
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1396)));
    // 0x192274: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x19227c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_19227c
// Address: 0x19227c - 0x1922e8

void entry_19227c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19227c) {
        switch (ctx->pc) {
            case 0x192284: ctx->pc = 0; goto label_192284;
            case 0x1922a8: ctx->pc = 0; goto label_1922a8;
            case 0x1922cc: ctx->pc = 0; goto label_1922cc;
            case 0x1922d0: ctx->pc = 0; goto label_1922d0;
            case 0x1922d4: ctx->pc = 0; goto label_1922d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19227c: 0x10000014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1922d0;
    }
label_192284:
    // 0x192284: 0x8e0205d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1488)));
    // 0x192288: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19228c: 0x1840000f
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1922cc;
    }
    // 0x192294: 0x8e0205ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1452)));
    // 0x192298: 0x54520003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
        goto label_1922a8;
    }
    // 0x1922a0: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 1452), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1922cc;
    }
label_1922a8:
    // 0x1922a8: 0xa6102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 6)));
    // 0x1922ac: 0x10400007
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1922cc;
    }
    // 0x1922b4: 0x260305ac
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 1452));
    // 0x1922b8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1922bc: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1922c0: 0x5492fff9
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 18)) {
        SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
        goto label_1922a8;
    }
    // 0x1922c8: 0xac600000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 0));
label_1922cc:
    // 0x1922cc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1922d0:
    // 0x1922d0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1922d4:
    // 0x1922d4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1922d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1922dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1922e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1922e8; return;
}


// Function: OnPoActive__FP2POiT0
// Address: 0x1922e8 - 0x192328

void entry_192328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192328) {
        switch (ctx->pc) {
            case 0x192330: ctx->pc = 0; goto label_192330;
            case 0x192340: ctx->pc = 0; goto label_192340;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192328: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19236C; return;
    }
label_192330:
    // 0x192330: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x192334: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x192338: 0x8e441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    // 0x19233c: 0x0
    // NOP
label_192340:
    // 0x192340: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x192344: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x192348: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19234c: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x192350: 0xc05147c
    SET_GPR_U32(ctx, 31, 0x192358);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RevokeCmPolicy(rdram, ctx, runtime); return;
}


// Function: entry_192358
// Address: 0x192358 - 0x192380

void entry_192358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192358) {
        switch (ctx->pc) {
            case 0x19236c: ctx->pc = 0; goto label_19236c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192358: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x19235c: 0x2a020007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 7));
    // 0x192360: 0x1440fff7
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 6544)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x192340; return;
    }
    // 0x192368: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_19236c:
    // 0x19236c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x192370: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x192374: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192378: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetPoCpdefi__FP2POfP6CPDEFI
// Address: 0x192380 - 0x1923a4

void entry_1923a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1923a4) {
        switch (ctx->pc) {
            case 0x1923bc: ctx->pc = 0; goto label_1923bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1923a4: 0x8e020554
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x1923a8: 0x10400004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1923bc;
    }
    // 0x1923b0: 0x7a020560
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 1376)));
    // 0x1923b4: 0x1000000f
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1923F4; return;
    }
label_1923bc:
    // 0x1923bc: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1923c0: 0x8c640224
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    // 0x1923c4: 0x5480000a
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 16)));
        ctx->pc = 0x1923F0; return;
    }
    // 0x1923cc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1923d0: 0xc60c0568
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1384)); ctx->f[12] = *(float*)&val; }
    // 0x1923d4: 0xc60d0148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 328)); ctx->f[13] = *(float*)&val; }
    // 0x1923d8: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x1923dc: 0x24849bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941632));
    // 0x1923e0: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1923e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1923e8
// Address: 0x1923e8 - 0x192410

void entry_1923e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1923e8) {
        switch (ctx->pc) {
            case 0x1923f0: ctx->pc = 0; goto label_1923f0;
            case 0x1923f4: ctx->pc = 0; goto label_1923f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1923e8: 0xe6200018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 24), *(uint32_t*)&val); }
    // 0x1923ec: 0x7a220010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 16)));
label_1923f0:
    // 0x1923f0: 0x7e020560
    WRITE128(ADD32(GPR_U32(ctx, 16), 1376), GPR_VEC(ctx, 2));
label_1923f4:
    // 0x1923f4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1923f8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1923fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192400: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x192404: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19240c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192410; return;
}


// Function: FIsPoSoundBase__FP2PO
// Address: 0x192410 - 0x192418

void entry_19242c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19242c: 0x12020004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x192440; return;
    }
    // 0x192434: 0xc064a74
    SET_GPR_U32(ctx, 31, 0x19243c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SwitchToPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_19243c
// Address: 0x19243c - 0x192450

void entry_19243c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19243c) {
        switch (ctx->pc) {
            case 0x192440: ctx->pc = 0; goto label_192440;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19243c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_192440:
    // 0x192440: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192444: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19244c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192450; return;
}


// Function: FInvulnerablePo__FP2PO3ZPK
// Address: 0x192450 - 0x192470

void entry_192470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192470) {
        switch (ctx->pc) {
            case 0x192478: ctx->pc = 0; goto label_192478;
            case 0x19247c: ctx->pc = 0; goto label_19247c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192470: 0x10400002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19247c;
    }
label_192478:
    // 0x192478: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_19247c:
    // 0x19247c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192480: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FTakePoDamage__FP2POP3ZPR
// Address: 0x192488 - 0x192490

void FUN_00192498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192498: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x19249c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1924a0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1924a4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1924a8: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x1924ac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1924b4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1924b4
// Address: 0x1924b4 - 0x1924c8

void entry_1924b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1924b4: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1924b8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1924bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1924c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CollectPoPrize__FP2PO3PCKP3ALO
// Address: 0x1924c8 - 0x192510

void entry_192510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192510: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x192514: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x192518: 0xae3005ac
    WRITE32(ADD32(GPR_U32(ctx, 17), 1452), GPR_U32(ctx, 16));
    // 0x19251c: 0x12000016
    WRITE32(ADD32(GPR_U32(ctx, 17), 1488), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x192578; return;
    }
    // 0x192524: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x192528: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19252c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x192530: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x192534: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x192538: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x19253c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x192544);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 320));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_192544
// Address: 0x192544 - 0x192550

void entry_192544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192544: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x192548: 0xc067e3a
    SET_GPR_U32(ctx, 31, 0x192550);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SubscribeRipObject__FP3RIPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_192550
// Address: 0x192550 - 0x19255c

void entry_192550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192550: 0x8e2405f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1520)));
    // 0x192554: 0xc04b330
    SET_GPR_U32(ctx, 31, 0x19255c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 319));
    TFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_19255c
// Address: 0x19255c - 0x19258c

void entry_19255c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19255c) {
        switch (ctx->pc) {
            case 0x192578: ctx->pc = 0; goto label_192578;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19255c: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x192560: 0x8e22059c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1436)));
    // 0x192564: 0xae020020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    // 0x192568: 0x8e430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x19256c: 0x78621ee0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 7904)));
    // 0x192570: 0xae120134
    WRITE32(ADD32(GPR_U32(ctx, 16), 308), GPR_U32(ctx, 18));
    // 0x192574: 0x7e0200c0
    WRITE128(ADD32(GPR_U32(ctx, 16), 192), GPR_VEC(ctx, 2));
label_192578:
    // 0x192578: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x19257c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x192580: 0x8c62014c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 332)));
    // 0x192584: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19258c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19258c
// Address: 0x19258c - 0x1925a8

void entry_19258c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19258c) {
        switch (ctx->pc) {
            case 0x192594: ctx->pc = 0; goto label_192594;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19258c: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1925AC; return;
    }
label_192594:
    // 0x192594: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x192598: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19259c: 0x8c62014c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 332)));
    // 0x1925a0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1925a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1925a8
// Address: 0x1925a8 - 0x1925c0

void entry_1925a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1925a8) {
        switch (ctx->pc) {
            case 0x1925ac: ctx->pc = 0; goto label_1925ac;
            case 0x1925b0: ctx->pc = 0; goto label_1925b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1925a8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1925ac:
    // 0x1925ac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1925b0:
    // 0x1925b0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1925b4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1925b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001925C0
// Address: 0x1925c0 - 0x1925f0

void FUN_001925C0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1925c0) {
        switch (ctx->pc) {
            case 0x1925e0: ctx->pc = 0; goto label_1925e0;
            case 0x1925e8: ctx->pc = 0; goto label_1925e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1925c0: 0x8c820600
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1536)));
    // 0x1925c4: 0x10450008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        goto label_1925e8;
    }
    // 0x1925cc: 0x10a20004
    WRITE32(ADD32(GPR_U32(ctx, 4), 1536), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_1925e0;
    }
    // 0x1925d4: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1925d8: 0x14a20003
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_1925e8;
    }
label_1925e0:
    // 0x1925e0: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1925e4: 0xf88105e0
    WRITE128(ADD32(GPR_U32(ctx, 4), 1504), _mm_castps_si128(ctx->vu0_vf[1]));
label_1925e8:
    // 0x1925e8: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PpoCur__Fv
// Address: 0x1925f0 - 0x192620

void entry_192630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192630) {
        switch (ctx->pc) {
            case 0x192658: ctx->pc = 0; goto label_192658;
            case 0x192678: ctx->pc = 0; goto label_192678;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192630: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x192634: 0x14800010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_192678;
    }
    // 0x19263c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x192640: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x192644: 0x10600004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_192658;
    }
    // 0x19264c: 0x8c620550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1360)));
    // 0x192650: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x192654: 0x2200a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 0));
label_192658:
    // 0x192658: 0x14800007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_192678;
    }
    // 0x192660: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x192664: 0x8c439c90
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294941840)));
    // 0x192668: 0x10600003
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_192678;
    }
    // 0x192670: 0x8c449c98
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294941848)));
    // 0x192674: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_192678:
    // 0x192678: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19267c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x192684: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192688; return;
}


// Function: fn__IppoFindPo__FP2PO
// Address: 0x192688 - 0x1926d0

void entry_192700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192700: 0x1040001c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x192774; return;
    }
    // 0x192708: 0xc0649a2
    SET_GPR_U32(ctx, 31, 0x192710);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn__IppoFindPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_192710
// Address: 0x192710 - 0x192780

void entry_192710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192710) {
        switch (ctx->pc) {
            case 0x192748: ctx->pc = 0; goto label_192748;
            case 0x192774: ctx->pc = 0; goto label_192774;
            case 0x192778: ctx->pc = 0; goto label_192778;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192710: 0x4410018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_192774;
    }
    // 0x192718: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x19271c: 0x8ca49c90
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4294941840)));
    // 0x192720: 0x2c820010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 16));
    // 0x192724: 0x10400008
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_192748;
    }
    // 0x19272c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x192730: 0x24429c98
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294941848));
    // 0x192734: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x192738: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19273c: 0xaca49c90
    WRITE32(ADD32(GPR_U32(ctx, 5), 4294941840), GPR_U32(ctx, 4));
    // 0x192740: 0x1000000c
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_192774;
    }
label_192748:
    // 0x192748: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x19274c: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x192750: 0x14620008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_192774;
    }
    // 0x192758: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19275c: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x192760: 0x54600005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
        goto label_192778;
    }
    // 0x192768: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19276c: 0xac509c98
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294941848), GPR_U32(ctx, 16));
    // 0x192770: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_192774:
    // 0x192774: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_192778:
    // 0x192778: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemovePoFromList__FP2PO
// Address: 0x192780 - 0x192798

void entry_192798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192798: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19279c: 0x600001a
    SET_GPR_U32(ctx, 18, ((uint32_t)39 << 16));
    if (GPR_S32(ctx, 16) < 0) {
        ctx->pc = 0x192808; return;
    }
    // 0x1927a4: 0x8e429bcc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4294941644)));
    // 0x1927a8: 0x16020004
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1927BC; return;
    }
    // 0x1927b0: 0xc064a20
    SET_GPR_U32(ctx, 31, 0x1927b8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    SwitchToIppo__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1927b8
// Address: 0x1927b8 - 0x1927e8

void entry_1927b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1927b8) {
        switch (ctx->pc) {
            case 0x1927bc: ctx->pc = 0; goto label_1927bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1927b8: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
label_1927bc:
    // 0x1927bc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1927c0: 0x8e269c90
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4294941840)));
    // 0x1927c4: 0x24849c98
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941848));
    // 0x1927c8: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1927cc: 0x24850004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4));
    // 0x1927d0: 0xd03023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 16)));
    // 0x1927d4: 0x452821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1927d8: 0x63080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 2));
    // 0x1927dc: 0x442021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1927e0: 0xc07d6c2
    SET_GPR_U32(ctx, 31, 0x1927e8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967292));
    memmove(rdram, ctx, runtime); return;
}


// Function: entry_1927e8
// Address: 0x1927e8 - 0x192820

void entry_1927e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1927e8) {
        switch (ctx->pc) {
            case 0x1927fc: ctx->pc = 0; goto label_1927fc;
            case 0x192808: ctx->pc = 0; goto label_192808;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1927e8: 0x8e439bcc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4294941644)));
    // 0x1927ec: 0x203102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    // 0x1927f0: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1927fc;
    }
    // 0x1927f8: 0xae429bcc
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294941644), GPR_U32(ctx, 2));
label_1927fc:
    // 0x1927fc: 0x8e229c90
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4294941840)));
    // 0x192800: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x192804: 0xae229c90
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294941840), GPR_U32(ctx, 2));
label_192808:
    // 0x192808: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19280c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x192810: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x192814: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192818: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnPoAdd__FP2PO
// Address: 0x192820 - 0x192834

void entry_192834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192834: 0xc0649b4
    SET_GPR_U32(ctx, 31, 0x19283c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddPoToList__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_19283c
// Address: 0x19283c - 0x192850

void entry_19283c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19283c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x192840: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192844: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19284c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192850; return;
}


// Function: OnPoRemove__FP2PO
// Address: 0x192850 - 0x192864

void entry_192864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192864: 0xc0649e0
    SET_GPR_U32(ctx, 31, 0x19286c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemovePoFromList__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_19286c
// Address: 0x19286c - 0x192880

void entry_19286c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19286c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x192870: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192874: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19287c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192880; return;
}


// Function: SwitchToIppo__Fi
// Address: 0x192880 - 0x19290c

void entry_19290c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19290c) {
        switch (ctx->pc) {
            case 0x19295c: ctx->pc = 0; goto label_19295c;
            case 0x192960: ctx->pc = 0; goto label_192960;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19290c: 0x8e269bcc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4294941644)));
    // 0x192910: 0x6000017
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294941644), GPR_U32(ctx, 16));
    if (GPR_S32(ctx, 16) < 0) {
        entry_192970(rdram, ctx, runtime); return;
    }
    // 0x192918: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19291c: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x192920: 0x24489c98
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 4294941848));
    // 0x192924: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x192928: 0x52fb8
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 30);
    // 0x19292c: 0x683821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 8)));
    // 0x192930: 0x8ce40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x192934: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x192938: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x19293c: 0xfc820538
    WRITE64(ADD32(GPR_U32(ctx, 4), 1336), GPR_U64(ctx, 2));
    // 0x192940: 0x8ce30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x192944: 0x4c00005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    if (GPR_S32(ctx, 6) < 0) {
        goto label_19295c;
    }
    // 0x19294c: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x192950: 0x481021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x192954: 0x10000002
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_192960;
    }
label_19295c:
    // 0x19295c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_192960:
    // 0x192960: 0x8c620130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 304)));
    // 0x192964: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x192968: 0x40f809
    SET_GPR_U32(ctx, 31, 0x192970);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_192970
// Address: 0x192970 - 0x192988

void entry_192970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192970: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x192974: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x192978: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19297c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x192984: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192988; return;
}


// Function: junk_00192988
// Address: 0x192988 - 0x192990

void entry_1929b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1929b4) {
        switch (ctx->pc) {
            case 0x1929bc: ctx->pc = 0; goto label_1929bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1929b4: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1929C8; return;
    }
label_1929bc:
    // 0x1929bc: 0xc0649e0
    SET_GPR_U32(ctx, 31, 0x1929c4);
    RemovePoFromList__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1929c4
// Address: 0x1929c4 - 0x1929d0

void entry_1929c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1929c4) {
        switch (ctx->pc) {
            case 0x1929c8: ctx->pc = 0; goto label_1929c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1929c4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1929c8:
    // 0x1929c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SwitchToPo__FP2PO
// Address: 0x1929d0 - 0x1929e0

void entry_1929e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1929e0: 0xc064a20
    SET_GPR_U32(ctx, 31, 0x1929e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SwitchToIppo__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1929e8
// Address: 0x1929e8 - 0x1929f8

void entry_1929e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1929e8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1929ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1929f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1929f8; return;
}


// Function: PpziCur__Fv
// Address: 0x1929f8 - 0x192a08

void entry_192a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192a08) {
        switch (ctx->pc) {
            case 0x192a18: ctx->pc = 0; goto label_192a18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192a08: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1408));
        goto label_192a18;
    }
    // 0x192a10: 0x3c020060
    SET_GPR_U32(ctx, 2, ((uint32_t)96 << 16));
    // 0x192a14: 0x24424700
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 18176));
label_192a18:
    // 0x192a18: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192a1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x192a24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192a28; return;
}


// Function: GetPoDiapi__FP2POP6DIALOGP5DIAPI
// Address: 0x192a28 - 0x192a38

void entry_192a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192a60: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192a64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x192a6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192a70; return;
}


// Function: FUN_00192a70
// Address: 0x192a70 - 0x192a90

void FUN_00192a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192a70: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x192a74: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x192a78: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x192a7c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x192a80: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x192a84: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x192a88: 0xc0524e8
    SET_GPR_U32(ctx, 31, 0x192a90);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1108));
    FActiveCplcy(rdram, ctx, runtime); return;
}


// Function: entry_192a90
// Address: 0x192a90 - 0x192b0c

void entry_192a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192a90) {
        switch (ctx->pc) {
            case 0x192ab4: ctx->pc = 0; goto label_192ab4;
            case 0x192abc: ctx->pc = 0; goto label_192abc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192a90: 0x1440002d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x192B48; return;
    }
    // 0x192a98: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x192a9c: 0x8c622c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11368)));
    // 0x192aa0: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x192aa4: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_192ab4;
    }
    // 0x192aac: 0x10000003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 11376));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_192abc;
    }
label_192ab4:
    // 0x192ab4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x192ab8: 0x24452d38
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 11576));
label_192abc:
    // 0x192abc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x192ac0: 0x8c44051c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1308)));
    // 0x192ac4: 0x10800013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x192B14; return;
    }
    // 0x192acc: 0x8c8302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 724)));
    // 0x192ad0: 0x54620011
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
        ctx->pc = 0x192B18; return;
    }
    // 0x192ad8: 0x8c82032c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 812)));
    // 0x192adc: 0x5440000e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
        ctx->pc = 0x192B18; return;
    }
    // 0x192ae4: 0x94a200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 170)));
    // 0x192ae8: 0x3042000c
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 12));
    // 0x192aec: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
        ctx->pc = 0x192B18; return;
    }
    // 0x192af4: 0x8c820304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 772)));
    // 0x192af8: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x192afc: 0x50600006
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
        ctx->pc = 0x192B18; return;
    }
    // 0x192b04: 0xc0545b0
    SET_GPR_U32(ctx, 31, 0x192b0c);
    FUN_001516c0(rdram, ctx, runtime); return;
}


// Function: entry_192b0c
// Address: 0x192b0c - 0x192b38

void entry_192b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192b0c) {
        switch (ctx->pc) {
            case 0x192b14: ctx->pc = 0; goto label_192b14;
            case 0x192b18: ctx->pc = 0; goto label_192b18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192b0c: 0x1000000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x192B3C; return;
    }
label_192b14:
    // 0x192b14: 0x960200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
label_192b18:
    // 0x192b18: 0x3042000c
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 12));
    // 0x192b1c: 0x10400006
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_192b38(rdram, ctx, runtime); return;
    }
    // 0x192b24: 0x8c44f800
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294965248)));
    // 0x192b28: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x192B3C; return;
    }
    // 0x192b30: 0xc0541e4
    SET_GPR_U32(ctx, 31, 0x192b38);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime); return;
}


// Function: entry_192b38
// Address: 0x192b38 - 0x192b44

void entry_192b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192b38) {
        switch (ctx->pc) {
            case 0x192b3c: ctx->pc = 0; goto label_192b3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192b38: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_192b3c:
    // 0x192b3c: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x192b44);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_192b44
// Address: 0x192b44 - 0x192b58

void entry_192b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192b44) {
        switch (ctx->pc) {
            case 0x192b48: ctx->pc = 0; goto label_192b48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192b44: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_192b48:
    // 0x192b48: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192b4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x192b54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192b58; return;
}


// Function: UpdatePo__FP2POf
// Address: 0x192b58 - 0x192b7c

void entry_192b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192b7c) {
        switch (ctx->pc) {
            case 0x192ba0: ctx->pc = 0; goto label_192ba0;
            case 0x192bb8: ctx->pc = 0; goto label_192bb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192b7c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x192b80: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x192b84: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x192b88: 0x8c6319e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 6628)));
    // 0x192b8c: 0x4600004
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) < 0) {
        goto label_192ba0;
    }
    // 0x192b94: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x192b98: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x192b9c: 0x62980a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 19, GPR_U32(ctx, 3));
label_192ba0:
    // 0x192ba0: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x192ba4: 0x34148000
    SET_GPR_U32(ctx, 20, OR32(GPR_U32(ctx, 0), 32768));
    // 0x192ba8: 0x14a478
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 20) << 17);
    // 0x192bac: 0x26500588
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1416));
    // 0x192bb0: 0xde4202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 712)));
    // 0x192bb4: 0x0
    // NOP
label_192bb8:
    // 0x192bb8: 0x541024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x192bbc: 0x1440000b
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x192BEC; return;
    }
    // 0x192bc4: 0x16330009
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 19)) {
        ctx->pc = 0x192BEC; return;
    }
    // 0x192bcc: 0x1080000d
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_192c04(rdram, ctx, runtime); return;
    }
    // 0x192bd4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x192bd8: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x192bdc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x192be4);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_192be4
// Address: 0x192be4 - 0x192c04

void entry_192be4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192be4) {
        switch (ctx->pc) {
            case 0x192bec: ctx->pc = 0; goto label_192bec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192be4: 0x10000008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x192C08; return;
    }
label_192bec:
    // 0x192bec: 0x10800005
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_192c04(rdram, ctx, runtime); return;
    }
    // 0x192bf4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x192bf8: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x192bfc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x192c04);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_192c04
// Address: 0x192c04 - 0x192c34

void entry_192c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192c04) {
        switch (ctx->pc) {
            case 0x192c08: ctx->pc = 0; goto label_192c08;
            case 0x192c2c: ctx->pc = 0; goto label_192c2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192c04: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
label_192c08:
    // 0x192c08: 0x2a220003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 3));
    // 0x192c0c: 0x5440ffea
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 712)));
        ctx->pc = 0x192BB8; return;
    }
    // 0x192c14: 0x8e430600
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1536)));
    // 0x192c18: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x192c1c: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_192c2c;
    }
    // 0x192c24: 0x14620004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x192C38; return;
    }
label_192c2c:
    // 0x192c2c: 0xc064b74
    SET_GPR_U32(ctx, 31, 0x192c34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_00192dd0(rdram, ctx, runtime); return;
}


// Function: entry_192c34
// Address: 0x192c34 - 0x192c58

void entry_192c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192c34) {
        switch (ctx->pc) {
            case 0x192c38: ctx->pc = 0; goto label_192c38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192c34: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_192c38:
    // 0x192c38: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x192c3c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x192c40: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x192c44: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x192c48: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x192c4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x192c54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192c58; return;
}


// Function: UsePoCharm__FP2PO
// Address: 0x192c58 - 0x192cb8

void entry_192cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192cb8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x192cbc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x192cc0: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x192cc4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x192ccc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_192ccc
// Address: 0x192ccc - 0x192ce0

void entry_192ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192ccc: 0x8e440584
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1412)));
    // 0x192cd0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x192cd4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x192cd8: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x192ce0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 272));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_192ce0
// Address: 0x192ce0 - 0x192cf8

void entry_192ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192ce0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x192ce4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x192ce8: 0x8e450584
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1412)));
    // 0x192cec: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x192cf0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x192cf8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_192cf8
// Address: 0x192cf8 - 0x192d0c

void entry_192cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192cf8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x192cfc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x192d00: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x192d04: 0x40f809
    SET_GPR_U32(ctx, 31, 0x192d0c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_192d0c
// Address: 0x192d0c - 0x192d28

void entry_192d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192d0c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x192d10: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x192d14: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x192d18: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x192d1c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x192d20: 0x40f809
    SET_GPR_U32(ctx, 31, 0x192d28);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_192d28
// Address: 0x192d28 - 0x192d3c

void entry_192d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192d28: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x192d2c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x192d30: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x192d34: 0x40f809
    SET_GPR_U32(ctx, 31, 0x192d3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_192d3c
// Address: 0x192d3c - 0x192d50

void entry_192d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192d3c: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x192d40: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x192d44: 0x2406018c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 396));
    // 0x192d48: 0xc056906
    SET_GPR_U32(ctx, 31, 0x192d50);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_192d50
// Address: 0x192d50 - 0x192d74

void entry_192d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x192d50: 0x10400018
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_192db4(rdram, ctx, runtime); return;
    }
    // 0x192d58: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x192d5c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x192d60: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x192d64: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x192d68: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x192d6c: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x192d74);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_192d74
// Address: 0x192d74 - 0x192db4

void entry_192d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192d74) {
        switch (ctx->pc) {
            case 0x192d7c: ctx->pc = 0; goto label_192d7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192d74: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x192DB8; return;
    }
label_192d7c:
    // 0x192d7c: 0x1040000d
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_192db4(rdram, ctx, runtime); return;
    }
    // 0x192d84: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x192d88: 0x24e79bd0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294941648));
    // 0x192d8c: 0x3c080027
    SET_GPR_U32(ctx, 8, ((uint32_t)39 << 16));
    // 0x192d90: 0xace20028
    WRITE32(ADD32(GPR_U32(ctx, 7), 40), GPR_U32(ctx, 2));
    // 0x192d94: 0x24a58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937888));
    // 0x192d98: 0x25089c10
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294941712));
    // 0x192d9c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x192da0: 0x8e440584
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1412)));
    // 0x192da4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x192da8: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x192dac: 0xc055fbe
    SET_GPR_U32(ctx, 31, 0x192db4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 320));
    EmitRipsSphere__FP6VECTORT0iP7EMITRIPP5EMITVPP4RIPGP2LO(rdram, ctx, runtime); return;
}


// Function: entry_192db4
// Address: 0x192db4 - 0x192dd0

void entry_192db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192db4) {
        switch (ctx->pc) {
            case 0x192db8: ctx->pc = 0; goto label_192db8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192db4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_192db8:
    // 0x192db8: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x192dbc: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x192dc0: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x192dc4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x192dcc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x192dd0; return;
}


// Function: FUN_00192dd0
// Address: 0x192dd0 - 0x192e4c

void FUN_00192dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192dd0) {
        switch (ctx->pc) {
            case 0x192e28: ctx->pc = 0; goto label_192e28;
            case 0x192e2c: ctx->pc = 0; goto label_192e2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192dd0: 0x27bdfdc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966720));
    // 0x192dd4: 0x7fb301d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 464), GPR_VEC(ctx, 19));
    // 0x192dd8: 0x7fbf0200
    WRITE128(ADD32(GPR_U32(ctx, 29), 512), GPR_VEC(ctx, 31));
    // 0x192ddc: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x192de0: 0x7fb501f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 496), GPR_VEC(ctx, 21));
    // 0x192de4: 0x7fb401e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 480), GPR_VEC(ctx, 20));
    // 0x192de8: 0x7fb201c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 448), GPR_VEC(ctx, 18));
    // 0x192dec: 0x7fb101b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 432), GPR_VEC(ctx, 17));
    // 0x192df0: 0x7fb001a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), GPR_VEC(ctx, 16));
    // 0x192df4: 0xe7b80230
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 560), *(uint32_t*)&val); }
    // 0x192df8: 0xe7b70228
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 552), *(uint32_t*)&val); }
    // 0x192dfc: 0xe7b60220
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 544), *(uint32_t*)&val); }
    // 0x192e00: 0xe7b50218
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 536), *(uint32_t*)&val); }
    // 0x192e04: 0xe7b40210
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 528), *(uint32_t*)&val); }
    // 0x192e08: 0x8e620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x192e0c: 0x8c521d5c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 7516)));
    // 0x192e10: 0x12400099
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193078; return;
    }
    // 0x192e18: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x192e1c: 0x10000003
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 1436));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_192e2c;
    }
    // 0x192e24: 0x0
    // NOP
label_192e28:
    // 0x192e28: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
label_192e2c:
    // 0x192e2c: 0x2e220004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 4));
    // 0x192e30: 0x10400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x192E58; return;
    }
    // 0x192e38: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x192e3c: 0x5080fffa
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
        goto label_192e28;
    }
    // 0x192e44: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x192e4c);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_192e4c
// Address: 0x192e4c - 0x193038

void entry_192e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x192e4c) {
        switch (ctx->pc) {
            case 0x192e58: ctx->pc = 0; goto label_192e58;
            case 0x192ebc: ctx->pc = 0; goto label_192ebc;
            case 0x192ec4: ctx->pc = 0; goto label_192ec4;
            case 0x192ed4: ctx->pc = 0; goto label_192ed4;
            case 0x192ef8: ctx->pc = 0; goto label_192ef8;
            case 0x192f30: ctx->pc = 0; goto label_192f30;
            case 0x192f38: ctx->pc = 0; goto label_192f38;
            case 0x192f60: ctx->pc = 0; goto label_192f60;
            case 0x192fbc: ctx->pc = 0; goto label_192fbc;
            case 0x192fcc: ctx->pc = 0; goto label_192fcc;
            case 0x192ff0: ctx->pc = 0; goto label_192ff0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x192e4c: 0x5040fff6
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
        ctx->pc = 0x192E28; return;
    }
    // 0x192e54: 0x8e140000
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_192e58:
    // 0x192e58: 0x1280001e
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_192ed4;
    }
    // 0x192e60: 0x7a6205e0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 1504)));
    // 0x192e64: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x192e68: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x192e6c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x192e70: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x192e74: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x192e78: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x192e7c: 0x0
    // NOP
    // 0x192e80: 0x4500000e
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_192ebc;
    }
    // 0x192e88: 0x700227c9
    SET_GPR_VEC(ctx, 4, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x192e8c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x192e90: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x192e94: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x192e98: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_192ebc;
    }
    // 0x192ea0: 0x700224a8
    SET_GPR_VEC(ctx, 4, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x192ea4: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x192ea8: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x192eac: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x192eb0: 0x0
    // NOP
    // 0x192eb4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_192ebc;
    }
label_192ebc:
    // 0x192ebc: 0x54600001
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 20), 320)));
        goto label_192ec4;
    }
label_192ec4:
    // 0x192ec4: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x192ec8: 0x7a820140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 20), 320)));
    // 0x192ecc: 0x1000001a
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_192f38;
    }
label_192ed4:
    // 0x192ed4: 0x8e6305d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 1488)));
    // 0x192ed8: 0x18600017
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_192f38;
    }
    // 0x192ee0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x192ee4: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x192ee8: 0x24471858
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x192eec: 0x266505ac
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 1452));
    // 0x192ef0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x192ef4: 0x0
    // NOP
label_192ef8:
    // 0x192ef8: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x192efc: 0x1040000c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_192f30;
    }
    // 0x192f04: 0xc4e10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[1] = *(float*)&val; }
    // 0x192f08: 0xc4400018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[0] = *(float*)&val; }
    // 0x192f0c: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x192f10: 0x45000007
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_192f30;
    }
    // 0x192f18: 0x78430090
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x192f1c: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x192f20: 0x7c830000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 3));
    // 0x192f24: 0x78420080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 128)));
    // 0x192f28: 0x7c820090
    WRITE128(ADD32(GPR_U32(ctx, 4), 144), GPR_VEC(ctx, 2));
    // 0x192f2c: 0x24840010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16));
label_192f30:
    // 0x192f30: 0x14c0fff1
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_192ef8;
    }
label_192f38:
    // 0x192f38: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x192f3c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x192f40: 0x1aa0004d
    WRITE32(ADD32(GPR_U32(ctx, 29), 288), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 21) <= 0) {
        ctx->pc = 0x193078; return;
    }
    // 0x192f48: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x192f4c: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x192f50: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x192f54: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x192f58: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x192f5c: 0x0
    // NOP
label_192f60:
    // 0x192f60: 0x41100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    // 0x192f64: 0x5d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
    // 0x192f68: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x192f6c: 0xfba10170
    WRITE128(ADD32(GPR_U32(ctx, 29), 368), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x192f70: 0xd8420090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x192f74: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x192f78: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x192f7c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x192f80: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x192f84: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x192f88: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x192f8c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x192f90: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x192f94: 0xfba20180
    WRITE128(ADD32(GPR_U32(ctx, 29), 384), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x192f98: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x192f9c: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x192fa0: 0x46170834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x192fa4: 0x45000005
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_192fbc;
    }
    // 0x192fac: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x192fb0: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x192fb4: 0x10000005
    ctx->f[20] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_192fcc;
    }
label_192fbc:
    // 0x192fbc: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x192fc0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x192fc4: 0x46010583
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[22] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[22] = ctx->f[0] / ctx->f[1];
    // 0x192fc8: 0x4600b506
    ctx->f[20] = FPU_MOV_S(ctx->f[22]);
label_192fcc:
    // 0x192fcc: 0x24910001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 4), 1));
    // 0x192fd0: 0x4618a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[24])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x192fd4: 0x0
    // NOP
    // 0x192fd8: 0x4500001b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 288));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x193048; return;
    }
    // 0x192fe0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x192fe4: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x192fe8: 0x4614a801
    ctx->f[0] = FPU_SUB_S(ctx->f[21], ctx->f[20]);
    // 0x192fec: 0x0
    // NOP
label_192ff0:
    // 0x192ff0: 0xdba10170
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x192ff4: 0x4404a000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[20]);
    // 0x192ff8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x192ffc: 0x48a42000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x193000: 0xdba20180
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x193004: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x193008: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19300c: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x193010: 0x4616a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[22]);
    // 0x193014: 0xfba30190
    WRITE128(ADD32(GPR_U32(ctx, 29), 400), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x193018: 0x4be309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x19301c: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x193020: 0xfba10140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x193024: 0xfba40190
    WRITE128(ADD32(GPR_U32(ctx, 29), 400), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x193028: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x19302c: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x193030: 0x60f809
    SET_GPR_U32(ctx, 31, 0x193038);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_193038
// Address: 0x193038 - 0x193064

void entry_193038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193038) {
        switch (ctx->pc) {
            case 0x193048: ctx->pc = 0; goto label_193048;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193038: 0x4615a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19303c: 0x0
    // NOP
    // 0x193040: 0x4503ffeb
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_SUB_S(ctx->f[21], ctx->f[20]);
        ctx->pc = 0x192FF0; return;
    }
label_193048:
    // 0x193048: 0x7ba30180
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x19304c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x193050: 0x7fa30140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), GPR_VEC(ctx, 3));
    // 0x193054: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x193058: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x19305c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x193064);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_193064
// Address: 0x193064 - 0x1930b0

void entry_193064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193064) {
        switch (ctx->pc) {
            case 0x193078: ctx->pc = 0; goto label_193078;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193064: 0x7ba20180
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x193068: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19306c: 0x95182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 21)));
    // 0x193070: 0x1460ffbb
    WRITE128(ADD32(GPR_U32(ctx, 19), 1504), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x192F60; return;
    }
label_193078:
    // 0x193078: 0x7bbf0200
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x19307c: 0x7bb501f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x193080: 0x7bb401e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x193084: 0x7bb301d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x193088: 0x7bb201c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x19308c: 0x7bb101b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x193090: 0x7bb001a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x193094: 0xc7b80230
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 560)); ctx->f[24] = *(float*)&val; }
    // 0x193098: 0xc7b70228
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 552)); ctx->f[23] = *(float*)&val; }
    // 0x19309c: 0xc7b60220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 544)); ctx->f[22] = *(float*)&val; }
    // 0x1930a0: 0xc7b50218
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 536)); ctx->f[21] = *(float*)&val; }
    // 0x1930a4: 0xc7b40210
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 528)); ctx->f[20] = *(float*)&val; }
    // 0x1930a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 576));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001930B0
// Address: 0x1930b0 - 0x1930b8

void FUN_001930B0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1930b0: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: po__static_initialization_and_destruction_04
// Address: 0x1930b8 - 0x1930ec

void entry_1930ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1930ec) {
        switch (ctx->pc) {
            case 0x193108: ctx->pc = 0; goto label_193108;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1930ec: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1930f0: 0x27b10080
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1930f4: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1930f8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1930fc: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x193100: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x193104: 0x7fa30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 3));
label_193108:
    // 0x193108: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19310c: 0x78450010
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x193110: 0x7e030000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 3));
    // 0x193114: 0x7e050010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 5));
    // 0x193118: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x19311c: 0x1444fffa
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_193108;
    }
    // 0x193124: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x193128: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19312c: 0x26109c10
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294941712));
    // 0x193130: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x193134: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x19313c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 128));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_19313c
// Address: 0x19313c - 0x1931f0

void entry_19313c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19313c) {
        switch (ctx->pc) {
            case 0x1931c0: ctx->pc = 0; goto label_1931c0;
            case 0x1931dc: ctx->pc = 0; goto label_1931dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19313c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x193140: 0x3c01bf00
    SET_GPR_U32(ctx, 1, ((uint32_t)48896 << 16));
    // 0x193144: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x193148: 0x24638d20
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937888));
    // 0x19314c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x193150: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x193154: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x193158: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19315c: 0xe7a00020
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    // 0x193160: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x193164: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x193168: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x19316c: 0x3c014496
    SET_GPR_U32(ctx, 1, ((uint32_t)17558 << 16));
    // 0x193170: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x193174: 0x3c01c4da
    SET_GPR_U32(ctx, 1, ((uint32_t)50394 << 16));
    // 0x193178: 0x3421c000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 49152));
    // 0x19317c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x193180: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x193184: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x193188: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x19318c: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x193190: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x193194: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x193198: 0xe7a50000
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x19319c: 0xe7a20004
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x1931a0: 0xe7a10018
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x1931a4: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x1931a8: 0xafa3004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 3));
    // 0x1931ac: 0xe7a30050
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x1931b0: 0xe7a40054
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    // 0x1931b4: 0xe7a60008
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x1931b8: 0xe7a60070
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
    // 0x1931bc: 0xe7a00074
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 116), *(uint32_t*)&val); }
label_1931c0:
    // 0x1931c0: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1931c4: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1931c8: 0x7e020000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), GPR_VEC(ctx, 2));
    // 0x1931cc: 0x7e030010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 3));
    // 0x1931d0: 0x24840020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    // 0x1931d4: 0x1491fffa
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 17)) {
        goto label_1931c0;
    }
label_1931dc:
    // 0x1931dc: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1931e0: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1931e4: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1931e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001931f0
// Address: 0x1931f0 - 0x193204

void FUN_001931f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1931f0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1931f4: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1931f8: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1931fc: 0xc064c2e
    SET_GPR_U32(ctx, 31, 0x193204);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    po__static_initialization_and_destruction_04(rdram, ctx, runtime); return;
}


// Function: entry_193204
// Address: 0x193204 - 0x193210

void entry_193204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193204: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x193208: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___5CProgP4RGBAN31
// Address: 0x193210 - 0x193270

void entry_1932c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1932c4) {
        switch (ctx->pc) {
            case 0x1932cc: ctx->pc = 0; goto label_1932cc;
            case 0x1932e0: ctx->pc = 0; goto label_1932e0;
            case 0x1932e4: ctx->pc = 0; goto label_1932e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1932c4: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1932e4;
    }
label_1932cc:
    // 0x1932cc: 0x54510004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 0));
        goto label_1932e0;
    }
    // 0x1932d4: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1932d8: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1932dc: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
label_1932e0:
    // 0x1932e0: 0xae11000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 17));
label_1932e4:
    // 0x1932e4: 0xc064cc6
    SET_GPR_U32(ctx, 31, 0x1932ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    Draw__5CProg(rdram, ctx, runtime); return;
}


// Function: entry_1932ec
// Address: 0x1932ec - 0x193300

void entry_1932ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1932ec: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1932f0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1932f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1932f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: End__5CProg
// Address: 0x193300 - 0x193318

void entry_1933d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1933d0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1933d4: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    // 0x1933d8: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1933e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1933e0
// Address: 0x1933e0 - 0x1933e8

void entry_1933e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1933e0: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x1933e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1933e8
// Address: 0x1933e8 - 0x1933fc

void entry_1933e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1933e8: 0x92930014
    SET_GPR_U32(ctx, 19, (uint8_t)READ8(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x1933ec: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x1933f0: 0x92910015
    SET_GPR_U32(ctx, 17, (uint8_t)READ8(ADD32(GPR_U32(ctx, 20), 21)));
    // 0x1933f4: 0xc07abca
    SET_GPR_U32(ctx, 31, 0x1933fc);
    SET_GPR_U32(ctx, 18, (uint8_t)READ8(ADD32(GPR_U32(ctx, 20), 22)));
    GTrunc__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1933fc
// Address: 0x1933fc - 0x193414

void entry_1933fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1933fc: 0x26a2000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 10));
    // 0x193400: 0x46170502
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x193404: 0x4482a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 2);
    // 0x193408: 0x4680ad60
    ctx->f[21] = FPU_CVT_S_W(*(int32_t*)&ctx->f[21]);
    // 0x19340c: 0xc07abca
    SET_GPR_U32(ctx, 31, 0x193414);
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    GTrunc__Ff(rdram, ctx, runtime); return;
}


// Function: entry_193414
// Address: 0x193414 - 0x193450

void entry_193414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193414: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x193418: 0x3c0140d3
    SET_GPR_U32(ctx, 1, ((uint32_t)16595 << 16));
    // 0x19341c: 0x34213334
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13108));
    // 0x193420: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
    // 0x193424: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x193428: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19342c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x193430: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x193434: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x193438: 0x460f03c0
    ctx->f[15] = FPU_ADD_S(ctx->f[0], ctx->f[15]);
    // 0x19343c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x193440: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x193444: 0x240700ff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 255));
    // 0x193448: 0xc067768
    SET_GPR_U32(ctx, 31, 0x193450);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FillScreenRect__FiiiiffffP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_193450
// Address: 0x193450 - 0x1934d0

void entry_193450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193450) {
        switch (ctx->pc) {
            case 0x193474: ctx->pc = 0; goto label_193474;
            case 0x193494: ctx->pc = 0; goto label_193494;
            case 0x1934a4: ctx->pc = 0; goto label_1934a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193450: 0x8e830010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x193454: 0x1c600007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 3) > 0) {
        goto label_193474;
    }
    // 0x19345c: 0x8a82001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 27); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x193460: 0x9a820018
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 24); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x193464: 0xaba20433
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 1075); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x193468: 0xbba20430
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 1072); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x19346c: 0x1000000d
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1934a4;
    }
label_193474:
    // 0x193474: 0x14620007
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_193494;
    }
    // 0x19347c: 0x8a82001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 31); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x193480: 0x9a82001c
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 28); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x193484: 0xaba20433
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 1075); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x193488: 0xbba20430
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 1072); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x19348c: 0x10000005
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1934a4;
    }
label_193494:
    // 0x193494: 0x8a820023
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 35); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x193498: 0x9a820020
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 32); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x19349c: 0xaba20433
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 1075); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1934a0: 0xbba20430
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 1072); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
label_1934a4:
    // 0x1934a4: 0x3c0143ce
    SET_GPR_U32(ctx, 1, ((uint32_t)17358 << 16));
    // 0x1934a8: 0x3421745d
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 29789));
    // 0x1934ac: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1934b0: 0x26a2000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 10));
    // 0x1934b4: 0x93b20430
    SET_GPR_U32(ctx, 18, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x1934b8: 0x4482b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 2);
    // 0x1934bc: 0x4680bde0
    ctx->f[23] = FPU_CVT_S_W(*(int32_t*)&ctx->f[23]);
    // 0x1934c0: 0x93b10431
    SET_GPR_U32(ctx, 17, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 1073)));
    // 0x1934c4: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1934c8: 0xc07abca
    SET_GPR_U32(ctx, 31, 0x1934d0);
    SET_GPR_U32(ctx, 16, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 1074)));
    GTrunc__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1934d0
// Address: 0x1934d0 - 0x1934f4

void entry_1934d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1934d0: 0x3c013f8c
    SET_GPR_U32(ctx, 1, ((uint32_t)16268 << 16));
    // 0x1934d4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x1934d8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1934dc: 0x26e2000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 10));
    // 0x1934e0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x1934e4: 0x4482a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 2);
    // 0x1934e8: 0x4680ad60
    ctx->f[21] = FPU_CVT_S_W(*(int32_t*)&ctx->f[21]);
    // 0x1934ec: 0xc07abca
    SET_GPR_U32(ctx, 31, 0x1934f4);
    ctx->f[22] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    GTrunc__Ff(rdram, ctx, runtime); return;
}


// Function: entry_1934f4
// Address: 0x1934f4 - 0x19352c

void entry_1934f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1934f4: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x1934f8: 0x3c0140d3
    SET_GPR_U32(ctx, 1, ((uint32_t)16595 << 16));
    // 0x1934fc: 0x34213334
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13108));
    // 0x193500: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
    // 0x193504: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x193508: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x19350c: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x193510: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x193514: 0x460f03c0
    ctx->f[15] = FPU_ADD_S(ctx->f[0], ctx->f[15]);
    // 0x193518: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19351c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x193520: 0x240700ff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 255));
    // 0x193524: 0xc067768
    SET_GPR_U32(ctx, 31, 0x19352c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FillScreenRect__FiiiiffffP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_19352c
// Address: 0x19352c - 0x193534

void entry_19352c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19352c: 0xc058480
    SET_GPR_U32(ctx, 31, 0x193534);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_193534
// Address: 0x193534 - 0x19353c

void entry_193534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193534: 0xc054b4c
    SET_GPR_U32(ctx, 31, 0x19353c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    AddDmaEnd__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_19353c
// Address: 0x19353c - 0x193544

void entry_19353c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19353c: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x193544);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_193544
// Address: 0x193544 - 0x193554

void entry_193544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193544: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x193548: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19354c: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x193554);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_193554
// Address: 0x193554 - 0x19355c

void entry_193554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193554: 0xc05a292
    SET_GPR_U32(ctx, 31, 0x19355c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    BlastAqwGifsBothFrames__FP2QW(rdram, ctx, runtime); return;
}


// Function: entry_19355c
// Address: 0x19355c - 0x193598

void entry_19355c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19355c: 0x7bbf04c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1216)));
    // 0x193560: 0x7bb704b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 1200)));
    // 0x193564: 0x7bb604a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 1184)));
    // 0x193568: 0x7bb50490
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 1168)));
    // 0x19356c: 0x7bb40480
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 1152)));
    // 0x193570: 0x7bb30470
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1136)));
    // 0x193574: 0x7bb20460
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1120)));
    // 0x193578: 0x7bb10450
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1104)));
    // 0x19357c: 0x7bb00440
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    // 0x193580: 0xc7b704e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1256)); ctx->f[23] = *(float*)&val; }
    // 0x193584: 0xc7b604e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1248)); ctx->f[22] = *(float*)&val; }
    // 0x193588: 0xc7b504d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1240)); ctx->f[21] = *(float*)&val; }
    // 0x19358c: 0xc7b404d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1232)); ctx->f[20] = *(float*)&val; }
    // 0x193590: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1264));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AchzFromRespk
// Address: 0x193598 - 0x1935b0

void FUN_001935b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1935b0: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1935b4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1935b8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1935bc: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1935c0: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1935c4: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1935c8: 0xc0582ca
    SET_GPR_U32(ctx, 31, 0x1935d0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime); return;
}


// Function: entry_1935d0
// Address: 0x1935d0 - 0x1935e8

void entry_1935d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1935d0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1935d4: 0x8e0419d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6616)));
    // 0x1935d8: 0x8e0219dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6620)));
    // 0x1935dc: 0x42200
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 8));
    // 0x1935e0: 0xc058052
    SET_GPR_U32(ctx, 31, 0x1935e8);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    PchzFriendlyFromWid(rdram, ctx, runtime); return;
}


// Function: entry_1935e8
// Address: 0x1935e8 - 0x193644

void entry_1935e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1935e8) {
        switch (ctx->pc) {
            case 0x193604: ctx->pc = 0; goto label_193604;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1935e8: 0x3c013c88
    SET_GPR_U32(ctx, 1, ((uint32_t)15496 << 16));
    // 0x1935ec: 0x34218889
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 34953));
    // 0x1935f0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1935f4: 0x240a003c
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 60));
    // 0x1935f8: 0xc600000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1935fc: 0x51400001
    if (GPR_U32(ctx, 10) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_193604;
    }
label_193604:
    // 0x193604: 0x2403003c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 60));
    // 0x193608: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19360c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x193610: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x193614: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x193618: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19361c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x193620: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x193624: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x193628: 0x3102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 0), GPR_S32(ctx, 3)));
    // 0x19362c: 0x62400b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 3));
    // 0x193630: 0x10a001a
    { int32_t divisor = GPR_S32(ctx, 10); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 8) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 10) % divisor); } else { ctx->lo = (GPR_S32(ctx,8) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,10); } }
    // 0x193634: 0x4012
    SET_GPR_U32(ctx, 8, ctx->lo);
    // 0x193638: 0x4810
    SET_GPR_U32(ctx, 9, ctx->hi);
    // 0x19363c: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x193644);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294951960));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_193644
// Address: 0x193644 - 0x193660

void entry_193644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193644: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x193648: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19364c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x193650: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x193654: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19365c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x193660; return;
}


// Function: FUN_00193660
// Address: 0x193660 - 0x193680

void FUN_00193660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193660: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x193664: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x193668: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x19366c: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x193670: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x193674: 0x2406042c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1068));
    // 0x193678: 0xc056906
    SET_GPR_U32(ctx, 31, 0x193680);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_193680
// Address: 0x193680 - 0x1936a0

void entry_193680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193680) {
        switch (ctx->pc) {
            case 0x19368c: ctx->pc = 0; goto label_19368c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193680: 0x10400002
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19368c;
    }
    // 0x193688: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
label_19368c:
    // 0x19368c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x193690: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x193694: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19369c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1936a0; return;
}


// Function: render_pause_menuQMARK
// Address: 0x1936a0 - 0x1937a4

void entry_1937a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1937a4: 0x10400032
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193870; return;
    }
    // 0x1937ac: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1937b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1937b4
// Address: 0x1937b4 - 0x1939b4

void entry_1937b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1937b4) {
        switch (ctx->pc) {
            case 0x193818: ctx->pc = 0; goto label_193818;
            case 0x19383c: ctx->pc = 0; goto label_19383c;
            case 0x19386c: ctx->pc = 0; goto label_19386c;
            case 0x193870: ctx->pc = 0; goto label_193870;
            case 0x193894: ctx->pc = 0; goto label_193894;
            case 0x1938a8: ctx->pc = 0; goto label_1938a8;
            case 0x1938d0: ctx->pc = 0; goto label_1938d0;
            case 0x1938f8: ctx->pc = 0; goto label_1938f8;
            case 0x193908: ctx->pc = 0; goto label_193908;
            case 0x193914: ctx->pc = 0; goto label_193914;
            case 0x19391c: ctx->pc = 0; goto label_19391c;
            case 0x193940: ctx->pc = 0; goto label_193940;
            case 0x19394c: ctx->pc = 0; goto label_19394c;
            case 0x193950: ctx->pc = 0; goto label_193950;
            case 0x193954: ctx->pc = 0; goto label_193954;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1937b4: 0x8fa300b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1937b8: 0x28620431
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1073));
    // 0x1937bc: 0x1040002c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1071));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_193870;
    }
    // 0x1937c4: 0x1000002a
    SET_GPR_U32(ctx, 16, XOR32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193870;
    }
    // 0x1937cc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1937d0: 0x8c62ec58
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4294962264)));
    // 0x1937d4: 0x38420002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 2));
    // 0x1937d8: 0x10000025
    SET_GPR_U32(ctx, 16, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193870;
    }
    // 0x1937e0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1937e4: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1937e8: 0x24050304
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 772));
    // 0x1937ec: 0x8c6219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x1937f0: 0x8c6419dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x1937f4: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x1937f8: 0x441825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1937fc: 0x10650006
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 5)) {
        goto label_193818;
    }
    // 0x193804: 0x24020307
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 775));
    // 0x193808: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1282));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_193818;
    }
    // 0x193810: 0x14620017
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_193870;
    }
label_193818:
    // 0x193818: 0x10000015
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193870;
    }
    // 0x193820: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x193824: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x193828: 0x8c8319d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6616)));
    // 0x19382c: 0x14600003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_19383c;
    }
    // 0x193834: 0x1000000e
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193870;
    }
label_19383c:
    // 0x19383c: 0x1062000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_19386c;
    }
    // 0x193844: 0x8c8319dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6620)));
    // 0x193848: 0x50620009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 22));
        goto label_193870;
    }
    // 0x193850: 0x14600007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_193870;
    }
    // 0x193858: 0x8c4423c4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9156)));
    // 0x19385c: 0x8c830078
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 120)));
    // 0x193860: 0x30630001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 1));
    // 0x193864: 0x14600002
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_193870;
    }
label_19386c:
    // 0x19386c: 0x24110016
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 22));
label_193870:
    // 0x193870: 0x12000008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_193894;
    }
    // 0x193878: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x19387c: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x193880: 0x21880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 2), 2));
    // 0x193884: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x193888: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x19388c: 0xac710000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 17));
    // 0x193890: 0xae820010
    WRITE32(ADD32(GPR_U32(ctx, 20), 16), GPR_U32(ctx, 2));
label_193894:
    // 0x193894: 0x2e420008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 8));
    // 0x193898: 0x1440ffa3
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 4294941912));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x193728; return;
    }
    // 0x1938a0: 0x1000002b
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193950;
    }
label_1938a8:
    // 0x1938a8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1938ac: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1938b0: 0xae800010
    WRITE32(ADD32(GPR_U32(ctx, 20), 16), GPR_U32(ctx, 0));
    // 0x1938b4: 0x24485bc0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 23488));
    // 0x1938b8: 0x24679d18
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 3), 4294941976));
    // 0x1938bc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1938c0: 0x24160015
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 21));
    // 0x1938c4: 0x240b0007
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1938c8: 0x240a0006
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1938cc: 0x24090008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 8));
label_1938d0:
    // 0x1938d0: 0x8ce50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1938d4: 0x10ab0011
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 11)) {
        goto label_19391c;
    }
    // 0x1938dc: 0x28a20008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 8));
    // 0x1938e0: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1938f8;
    }
    // 0x1938e8: 0x50aa0007
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 10)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 48)));
        goto label_193908;
    }
    // 0x1938f0: 0x1000000a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19391c;
    }
label_1938f8:
    // 0x1938f8: 0x50a90006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 9)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 48)));
        goto label_193914;
    }
    // 0x193900: 0x10000006
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19391c;
    }
label_193908:
    // 0x193908: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x19390c: 0x10000003
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19391c;
    }
label_193914:
    // 0x193914: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x193918: 0x2182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_19391c:
    // 0x19391c: 0x10600008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_193940;
    }
    // 0x193924: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x193928: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x19392c: 0x21880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 2), 2));
    // 0x193930: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x193934: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x193938: 0xac650000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 5));
    // 0x19393c: 0xae820010
    WRITE32(ADD32(GPR_U32(ctx, 20), 16), GPR_U32(ctx, 2));
label_193940:
    // 0x193940: 0x2cc20009
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 9));
    // 0x193944: 0x1440ffe2
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1938d0;
    }
label_19394c:
    // 0x19394c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_193950:
    // 0x193950: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_193954:
    // 0x193954: 0x1220c0
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 3));
    // 0x193958: 0x2443a068
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294942824));
    // 0x19395c: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x193960: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x193964: 0x27c3a138
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 30), 4294943032));
    // 0x193968: 0x8c510000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19396c: 0x832821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x193970: 0x2643fff7
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 4294967287));
    // 0x193974: 0x2c620012
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 18));
    // 0x193978: 0x10400067
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_193b18(rdram, ctx, runtime); return;
    }
    // 0x193980: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x193984: 0x2442c480
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294952064));
    // 0x193988: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19398c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x193990: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x193998: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19399c: 0x8c439984
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294941060)));
    // 0x1939a0: 0x10600006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1939BC; return;
    }
    // 0x1939a8: 0x8ca20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x1939ac: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x1939b4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_1939b4
// Address: 0x1939b4 - 0x1939c8

void entry_1939b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1939b4) {
        switch (ctx->pc) {
            case 0x1939bc: ctx->pc = 0; goto label_1939bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1939b4: 0x10000059
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193B1C; return;
    }
label_1939bc:
    // 0x1939bc: 0x8ca20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x1939c0: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x1939c8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_1939c8
// Address: 0x1939c8 - 0x1939e0

void entry_1939c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1939c8: 0x10000054
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193B1C; return;
    }
    // 0x1939d0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1939d4: 0x8cb00004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x1939d8: 0xc069fba
    SET_GPR_U32(ctx, 31, 0x1939e0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    FUN_001A7EE8(rdram, ctx, runtime); return;
}


// Function: entry_1939e0
// Address: 0x1939e0 - 0x193a98

void entry_1939e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1939e0) {
        switch (ctx->pc) {
            case 0x193a8c: ctx->pc = 0; goto label_193a8c;
            case 0x193a90: ctx->pc = 0; goto label_193a90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1939e0: 0x26030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4));
    // 0x1939e4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1939e8: 0x10000029
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193a90;
    }
    // 0x1939f0: 0x8ca60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x1939f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1939f8: 0x8c4523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1939fc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x193a00: 0x24c30004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 4));
    // 0x193a04: 0x8ca219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6636)));
    // 0x193a08: 0x10000020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 128));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193a8c;
    }
    // 0x193a10: 0x8ca60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x193a14: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x193a18: 0x8c4523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x193a1c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x193a20: 0x24c30004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 4));
    // 0x193a24: 0x8ca219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6636)));
    // 0x193a28: 0x10000018
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193a8c;
    }
    // 0x193a30: 0x8ca60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x193a34: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x193a38: 0x8c4523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x193a3c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x193a40: 0x24c30004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 4));
    // 0x193a44: 0x8ca219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6636)));
    // 0x193a48: 0x10000010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 512));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193a8c;
    }
    // 0x193a50: 0x8ca60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x193a54: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x193a58: 0x8c4523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x193a5c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x193a60: 0x24c30004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 4));
    // 0x193a64: 0x8ca219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6636)));
    // 0x193a68: 0x10000008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1024));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193a8c;
    }
    // 0x193a70: 0x8ca60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x193a74: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x193a78: 0x8c4523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x193a7c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x193a80: 0x24c30004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 4));
    // 0x193a84: 0x8ca219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6636)));
    // 0x193a88: 0x30420800
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2048));
label_193a8c:
    // 0x193a8c: 0xc2180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 6));
label_193a90:
    // 0x193a90: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x193a98);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_193a98
// Address: 0x193a98 - 0x193ad8

void entry_193a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193a98: 0x10000020
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193B1C; return;
    }
    // 0x193aa0: 0x2644fff6
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4294967286));
    // 0x193aa4: 0x24021a5c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6748));
    // 0x193aa8: 0x822018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x193aac: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x193ab0: 0x24634a70
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 19056));
    // 0x193ab4: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x193ab8: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x193abc: 0xc480000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 12)); ctx->f[0] = *(float*)&val; }
    // 0x193ac0: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x193ac4: 0x0
    // NOP
    // 0x193ac8: 0x45010005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 18));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x193AE0; return;
    }
    // 0x193ad0: 0xc064d6c
    SET_GPR_U32(ctx, 31, 0x193ad8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001935b0(rdram, ctx, runtime); return;
}


// Function: entry_193ad8
// Address: 0x193ad8 - 0x193b00

void entry_193ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193ad8) {
        switch (ctx->pc) {
            case 0x193ae0: ctx->pc = 0; goto label_193ae0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193ad8: 0x10000010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193B1C; return;
    }
label_193ae0:
    // 0x193ae0: 0x10400009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193B08; return;
    }
    // 0x193ae8: 0x14400008
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x193B0C; return;
    }
    // 0x193af0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x193af4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x193af8: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x193b00);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4294942936)));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_193b00
// Address: 0x193b00 - 0x193b18

void entry_193b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193b00) {
        switch (ctx->pc) {
            case 0x193b08: ctx->pc = 0; goto label_193b08;
            case 0x193b0c: ctx->pc = 0; goto label_193b0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193b00: 0x10000006
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193B1C; return;
    }
label_193b08:
    // 0x193b08: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_193b0c:
    // 0x193b0c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x193b10: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x193b18);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4294942940)));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_193b18
// Address: 0x193b18 - 0x193be4

void entry_193b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193b18) {
        switch (ctx->pc) {
            case 0x193b1c: ctx->pc = 0; goto label_193b1c;
            case 0x193b78: ctx->pc = 0; goto label_193b78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193b18: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_193b1c:
    // 0x193b1c: 0x2a42001b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 27));
    // 0x193b20: 0x1440ff8c
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x193954; return;
    }
    // 0x193b28: 0x2ec20013
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), 19));
    // 0x193b2c: 0x10400038
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193C10; return;
    }
    // 0x193b34: 0x161880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 22), 2));
    // 0x193b38: 0x2442c4d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294952144));
    // 0x193b3c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x193b40: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x193b44: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x193b4c: 0xaea00264
    WRITE32(ADD32(GPR_U32(ctx, 21), 612), GPR_U32(ctx, 0));
    // 0x193b50: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x193b54: 0x24424a70
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 19056));
    // 0x193b58: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x193b5c: 0xc440000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[0] = *(float*)&val; }
    // 0x193b60: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x193b64: 0x0
    // NOP
    // 0x193b68: 0x4501002a
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x193C14; return;
    }
    // 0x193b70: 0x24041a5c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 6748));
    // 0x193b74: 0x8ea20264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 612)));
label_193b78:
    // 0x193b78: 0x24430001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 1));
    // 0x193b7c: 0x28620003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    // 0x193b80: 0x10400024
    WRITE32(ADD32(GPR_U32(ctx, 21), 612), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193C14; return;
    }
    // 0x193b88: 0x642818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x193b8c: 0xa61021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x193b90: 0xc440000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[0] = *(float*)&val; }
    // 0x193b94: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x193b98: 0x0
    // NOP
    // 0x193b9c: 0x4502fff6
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 612)));
        goto label_193b78;
    }
    // 0x193ba4: 0x1000001b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193C14; return;
    }
    // 0x193bac: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x193bb0: 0x24424a40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 19008));
    // 0x193bb4: 0x8c444f44
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 20292)));
    // 0x193bb8: 0x10800015
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 48));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193C10; return;
    }
    // 0x193bc0: 0x3c0326ff
    SET_GPR_U32(ctx, 3, ((uint32_t)9983 << 16));
    // 0x193bc4: 0x821023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x193bc8: 0x3463d927
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 55591));
    // 0x193bcc: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x193bd0: 0x21083
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 2));
    // 0x193bd4: 0x1000000f
    WRITE32(ADD32(GPR_U32(ctx, 21), 612), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193C14; return;
    }
    // 0x193bdc: 0xc06fa60
    SET_GPR_U32(ctx, 31, 0x193be4);
    FVagPlaying__Fv(rdram, ctx, runtime); return;
}


// Function: entry_193be4
// Address: 0x193be4 - 0x193bf4

void entry_193be4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193be4: 0x1440000b
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x193C14; return;
    }
    // 0x193bec: 0xc06f9ca
    SET_GPR_U32(ctx, 31, 0x193bf4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294943000));
    PreloadVag1(rdram, ctx, runtime); return;
}


// Function: entry_193bf4
// Address: 0x193bf4 - 0x193bfc

void entry_193bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193bf4: 0xc06fa60
    SET_GPR_U32(ctx, 31, 0x193bfc);
    FVagPlaying__Fv(rdram, ctx, runtime); return;
}


// Function: entry_193bfc
// Address: 0x193bfc - 0x193c38

void entry_193bfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193bfc) {
        switch (ctx->pc) {
            case 0x193c10: ctx->pc = 0; goto label_193c10;
            case 0x193c14: ctx->pc = 0; goto label_193c14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193bfc: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 21), 648), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193c14;
    }
    // 0x193c04: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x193c08: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 21), 612), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193c14;
    }
label_193c10:
    // 0x193c10: 0xaea00264
    WRITE32(ADD32(GPR_U32(ctx, 21), 612), GPR_U32(ctx, 0));
label_193c14:
    // 0x193c14: 0x4480b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 0);
    // 0x193c18: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x193c1c: 0x4600b546
    ctx->f[21] = FPU_MOV_S(ctx->f[22]);
    // 0x193c20: 0x10400014
    ctx->f[23] = FPU_MOV_S(ctx->f[22]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193C74; return;
    }
    // 0x193c28: 0xc68c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4)); ctx->f[12] = *(float*)&val; }
    // 0x193c2c: 0x8ea40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x193c30: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x193c38);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_193c38
// Address: 0x193c38 - 0x193c48

void entry_193c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193c38: 0x8e850000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x193c3c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x193c40: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x193c48);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_193c48
// Address: 0x193c48 - 0x193c60

void entry_193c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193c48: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x193c4c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x193c50: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x193c54: 0x27a500b4
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 180));
    // 0x193c58: 0xc0578a4
    SET_GPR_U32(ctx, 31, 0x193c60);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 184));
    GetExtents__9CRichTextPfT1f(rdram, ctx, runtime); return;
}


// Function: entry_193c60
// Address: 0x193c60 - 0x193c68

void entry_193c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193c60: 0xc057240
    SET_GPR_U32(ctx, 31, 0x193c68);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_193c68
// Address: 0x193c68 - 0x193c84

void entry_193c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193c68) {
        switch (ctx->pc) {
            case 0x193c74: ctx->pc = 0; goto label_193c74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193c68: 0xc7a000b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 180)); ctx->f[0] = *(float*)&val; }
    // 0x193c6c: 0xc7b700b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[23] = *(float*)&val; }
    // 0x193c70: 0x461605a8
    ctx->f[22] = std::max(ctx->f[0], ctx->f[22]);
label_193c74:
    // 0x193c74: 0xc68c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 8)); ctx->f[12] = *(float*)&val; }
    // 0x193c78: 0x8ea40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x193c7c: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x193c84);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_193c84
// Address: 0x193c84 - 0x193d48

void entry_193c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193c84) {
        switch (ctx->pc) {
            case 0x193cb4: ctx->pc = 0; goto label_193cb4;
            case 0x193cc8: ctx->pc = 0; goto label_193cc8;
            case 0x193cf8: ctx->pc = 0; goto label_193cf8;
            case 0x193d28: ctx->pc = 0; goto label_193d28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193c84: 0x8e82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x193c88: 0x1040000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_193cb4;
    }
    // 0x193c90: 0x8e830010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x193c94: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x193c98: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x193c9c: 0xc4410048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[1] = *(float*)&val; }
    // 0x193ca0: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x193ca4: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x193ca8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x193cac: 0x10000006
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193cc8;
    }
label_193cb4:
    // 0x193cb4: 0x8e830010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x193cb8: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x193cbc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x193cc0: 0xc4410048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[1] = *(float*)&val; }
    // 0x193cc4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
label_193cc8:
    // 0x193cc8: 0x4600bdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[0]);
    // 0x193ccc: 0x18600048
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x193DF0; return;
    }
    // 0x193cd4: 0x8e820014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x193cd8: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x193cdc: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x193ce0: 0x10640043
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x193DF0; return;
    }
    // 0x193ce8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x193cec: 0x2417ffff
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x193cf0: 0x2456a138
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 2), 4294943032));
    // 0x193cf4: 0x0
    // NOP
label_193cf8:
    // 0x193cf8: 0x131080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 19), 2));
    // 0x193cfc: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x193d00: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x193d04: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x193d08: 0x418c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 3));
    // 0x193d0c: 0x768821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 22)));
    // 0x193d10: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x193d14: 0x10600014
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193D68; return;
    }
    // 0x193d1c: 0x1860001b
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x193D8C; return;
    }
    // 0x193d24: 0x0
    // NOP
label_193d28:
    // 0x193d28: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x193d2c: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x193d30: 0x8ea60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x193d34: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x193d38: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x193d3c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x193d40: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x193d48);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_193d48
// Address: 0x193d48 - 0x193d50

void entry_193d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193d48: 0xc0577fe
    SET_GPR_U32(ctx, 31, 0x193d50);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Dx__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_193d50
// Address: 0x193d50 - 0x193d70

void entry_193d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193d50) {
        switch (ctx->pc) {
            case 0x193d68: ctx->pc = 0; goto label_193d68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193d50: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x193d54: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x193d58: 0x1440fff3
    ctx->f[20] = std::max(ctx->f[0], ctx->f[20]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x193D28; return;
    }
    // 0x193d60: 0x1000000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193D90; return;
    }
label_193d68:
    // 0x193d68: 0xc064d66
    SET_GPR_U32(ctx, 31, 0x193d70);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 1));
    AchzFromRespk(rdram, ctx, runtime); return;
}


// Function: entry_193d70
// Address: 0x193d70 - 0x193d80

void entry_193d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193d70: 0x8ea60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x193d74: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x193d78: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x193d80);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_193d80
// Address: 0x193d80 - 0x193d88

void entry_193d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193d80: 0xc0577fe
    SET_GPR_U32(ctx, 31, 0x193d88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Dx__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_193d88
// Address: 0x193d88 - 0x193dfc

void entry_193d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193d88) {
        switch (ctx->pc) {
            case 0x193d8c: ctx->pc = 0; goto label_193d8c;
            case 0x193d90: ctx->pc = 0; goto label_193d90;
            case 0x193da0: ctx->pc = 0; goto label_193da0;
            case 0x193dc8: ctx->pc = 0; goto label_193dc8;
            case 0x193df0: ctx->pc = 0; goto label_193df0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193d88: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
label_193d8c:
    // 0x193d8c: 0x8e82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
label_193d90:
    // 0x193d90: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_193da0;
    }
    // 0x193d98: 0x1000000b
    ctx->f[21] = std::max(ctx->f[21], ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_193dc8;
    }
label_193da0:
    // 0x193da0: 0x52600009
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
        goto label_193dc8;
    }
    // 0x193da8: 0x8ea20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x193dac: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x193db0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x193db4: 0xc4410044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 68)); ctx->f[1] = *(float*)&val; }
    // 0x193db8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x193dbc: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x193dc0: 0x4600ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    // 0x193dc4: 0x4614ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[20]);
label_193dc8:
    // 0x193dc8: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x193dcc: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x193dd0: 0x10400007
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_193df0;
    }
    // 0x193dd8: 0x8e820014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x193ddc: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x193de0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x193de4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x193de8: 0x1497ffc3
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 23)) {
        ctx->pc = 0x193CF8; return;
    }
label_193df0:
    // 0x193df0: 0x8ea40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x193df4: 0xc057240
    SET_GPR_U32(ctx, 31, 0x193dfc);
    ctx->f[22] = std::max(ctx->f[21], ctx->f[22]);
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_193dfc
// Address: 0x193dfc - 0x193e14

void entry_193dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193dfc: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x193e00: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x193e04: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x193e08: 0x4600bb46
    ctx->f[13] = FPU_MOV_S(ctx->f[23]);
    // 0x193e0c: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x193e14);
    ctx->f[12] = FPU_ADD_S(ctx->f[22], ctx->f[12]);
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_193e14
// Address: 0x193e14 - 0x193e58

void entry_193e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193e14: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x193e18: 0x7bbe0140
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x193e1c: 0x7bb70130
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x193e20: 0x7bb60120
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x193e24: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x193e28: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x193e2c: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x193e30: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x193e34: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x193e38: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x193e3c: 0xc7b70178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[23] = *(float*)&val; }
    // 0x193e40: 0xc7b60170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[22] = *(float*)&val; }
    // 0x193e44: 0xc7b50168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 360)); ctx->f[21] = *(float*)&val; }
    // 0x193e48: 0xc7b40160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[20] = *(float*)&val; }
    // 0x193e4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x193e54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x193e58; return;
}


// Function: FUN_00193e58
// Address: 0x193e58 - 0x193e6c

void FUN_00193e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193e58: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x193e5c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x193e60: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x193e64: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x193e6c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_193e6c
// Address: 0x193e6c - 0x193e74

void entry_193e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193e6c: 0xc057062
    SET_GPR_U32(ctx, 31, 0x193e74);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c188(rdram, ctx, runtime); return;
}


// Function: entry_193e74
// Address: 0x193e74 - 0x193e8c

void entry_193e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193e74: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193E94; return;
    }
    // 0x193e7c: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x193e80: 0x2442a210
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294943248));
    // 0x193e84: 0xc057070
    SET_GPR_U32(ctx, 31, 0x193e8c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 528), GPR_U32(ctx, 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_193e8c
// Address: 0x193e8c - 0x193ee8

void entry_193e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193e8c) {
        switch (ctx->pc) {
            case 0x193e94: ctx->pc = 0; goto label_193e94;
            case 0x193eb0: ctx->pc = 0; goto label_193eb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193e8c: 0x8e030210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 528)));
    // 0x193e90: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_193e94:
    // 0x193e94: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x193e98: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x193e9c: 0xae02027c
    WRITE32(ADD32(GPR_U32(ctx, 16), 636), GPR_U32(ctx, 2));
    // 0x193ea0: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x193ea4: 0xae020260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 2));
    // 0x193ea8: 0x26030268
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 616));
    // 0x193eac: 0x0
    // NOP
label_193eb0:
    // 0x193eb0: 0xac650000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 5));
    // 0x193eb4: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x193eb8: 0x2c820003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 3));
    // 0x193ebc: 0x0
    // NOP
    // 0x193ec0: 0x0
    // NOP
    // 0x193ec4: 0x1440fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_193eb0;
    }
    // 0x193ecc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x193ed0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x193ed4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x193ed8: 0xe6000284
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 644), *(uint32_t*)&val); }
    // 0x193edc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x193ee0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00193ee8
// Address: 0x193ee8 - 0x193f20

void FUN_00193ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193ee8: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x193eec: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x193ef0: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x193ef4: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x193ef8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x193efc: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x193f00: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x193f04: 0x12120072
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 18)) {
        entry_1940d0(rdram, ctx, runtime); return;
    }
    // 0x193f0c: 0x8e220288
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 648)));
    // 0x193f10: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193F28; return;
    }
    // 0x193f18: 0xc06fa66
    SET_GPR_U32(ctx, 31, 0x193f20);
    StopVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_193f20
// Address: 0x193f20 - 0x193f60

void entry_193f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193f20) {
        switch (ctx->pc) {
            case 0x193f28: ctx->pc = 0; goto label_193f28;
            case 0x193f4c: ctx->pc = 0; goto label_193f4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193f20: 0xae200288
    WRITE32(ADD32(GPR_U32(ctx, 17), 648), GPR_U32(ctx, 0));
    // 0x193f24: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
label_193f28:
    // 0x193f28: 0x12020008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 11));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_193f4c;
    }
    // 0x193f30: 0x1440000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x193F64; return;
    }
    // 0x193f38: 0x2a020012
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 18));
    // 0x193f3c: 0x10400009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x193F64; return;
    }
    // 0x193f44: 0x14400008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 26));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x193F68; return;
    }
label_193f4c:
    // 0x193f4c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x193f50: 0x8c83ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294962288)));
    // 0x193f54: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x193f58: 0x40f809
    SET_GPR_U32(ctx, 31, 0x193f60);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294962288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_193f60
// Address: 0x193f60 - 0x193f9c

void entry_193f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193f60) {
        switch (ctx->pc) {
            case 0x193f64: ctx->pc = 0; goto label_193f64;
            case 0x193f68: ctx->pc = 0; goto label_193f68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193f60: 0x26430001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 1));
label_193f64:
    // 0x193f64: 0x2c62001a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 26));
label_193f68:
    // 0x193f68: 0x10400059
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1940d0(rdram, ctx, runtime); return;
    }
    // 0x193f70: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x193f74: 0x2442c520
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294952224));
    // 0x193f78: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x193f7c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x193f80: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x193f88: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x193f8c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x193f90: 0x2610ec70
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294962288));
    // 0x193f94: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x193f9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_193f9c
// Address: 0x193f9c - 0x193fb0

void entry_193f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x193f9c: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x193fa0: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x193fa4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x193fa8: 0xc06a9e2
    SET_GPR_U32(ctx, 31, 0x193fb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotFontScale__FfP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_193fb0
// Address: 0x193fb0 - 0x194080

void entry_193fb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x193fb0) {
        switch (ctx->pc) {
            case 0x193ff0: ctx->pc = 0; goto label_193ff0;
            case 0x19400c: ctx->pc = 0; goto label_19400c;
            case 0x194048: ctx->pc = 0; goto label_194048;
            case 0x194064: ctx->pc = 0; goto label_194064;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x193fb0: 0x10000048
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1940D4; return;
    }
    // 0x193fb8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x193fbc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x193fc0: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x193fc4: 0x2467a700
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 3), 4294944512));
    // 0x193fc8: 0x24422490
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 9360));
    // 0x193fcc: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x193fd0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x193fd4: 0x30830fff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), 4095));
    // 0x193fd8: 0x4600005
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 4294944520));
    if (GPR_S32(ctx, 3) < 0) {
        goto label_193ff0;
    }
    // 0x193fe0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x193fe4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x193fe8: 0x10000008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 9360));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19400c;
    }
label_193ff0:
    // 0x193ff0: 0x30820001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 1));
    // 0x193ff4: 0x31842
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 1));
    // 0x193ff8: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x193ffc: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x194000: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x194004: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x194008: 0x24a22490
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 9360));
label_19400c:
    // 0x19400c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x194010: 0xdc440018
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x194014: 0x2466a704
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 4294944516));
    // 0x194018: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19401c: 0xe4e00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 0), *(uint32_t*)&val); }
    // 0x194020: 0x42538
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 20);
    // 0x194024: 0x4203f
    SET_GPR_S64(ctx, 4, GPR_S64(ctx, 4) >> (32 + 0));
    // 0x194028: 0x2445a70c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294944524));
    // 0x19402c: 0x308307ff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), 2047));
    // 0x194030: 0x4600005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 8), 0), *(uint32_t*)&val); }
    if (GPR_S32(ctx, 3) < 0) {
        goto label_194048;
    }
    // 0x194038: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x19403c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x194040: 0x10000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 6), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_194064;
    }
label_194048:
    // 0x194048: 0x30820001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 1));
    // 0x19404c: 0x31842
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 1));
    // 0x194050: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x194054: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x194058: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x19405c: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x194060: 0xe4c00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 6), 0), *(uint32_t*)&val); }
label_194064:
    // 0x194064: 0x1000001a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 0), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1940d0(rdram, ctx, runtime); return;
    }
    // 0x19406c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x194070: 0x8c83c6c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294952648)));
    // 0x194074: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x194078: 0x40f809
    SET_GPR_U32(ctx, 31, 0x194080);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294952648));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_194080
// Address: 0x194080 - 0x194094

void entry_194080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194080: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x194084: 0x8c83c948
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294953288)));
    // 0x194088: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x19408c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x194094);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294953288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_194094
// Address: 0x194094 - 0x1940a8

void entry_194094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194094: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x194098: 0x8c83cbc8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294953928)));
    // 0x19409c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1940a0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1940a8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294953928));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1940a8
// Address: 0x1940a8 - 0x1940bc

void entry_1940a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1940a8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1940ac: 0x8c83ce48
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294954568)));
    // 0x1940b0: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1940b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1940bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294954568));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1940bc
// Address: 0x1940bc - 0x1940d0

void entry_1940bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1940bc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1940c0: 0x8c834118
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 16664)));
    // 0x1940c4: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1940c8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1940d0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16664));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1940d0
// Address: 0x1940d0 - 0x1940e8

void entry_1940d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1940d0) {
        switch (ctx->pc) {
            case 0x1940d4: ctx->pc = 0; goto label_1940d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1940d0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1940d4:
    // 0x1940d4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1940d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1940dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1940e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001940e8
// Address: 0x1940e8 - 0x19413c

void FUN_001940e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1940e8: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1940ec: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1940f0: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1940f4: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1940f8: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1940fc: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x194100: 0x8e02025c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 604)));
    // 0x194104: 0x10510057
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x194264; return;
    }
    // 0x19410c: 0x12200030
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1941D0; return;
    }
    // 0x194114: 0x24050308
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 776));
    // 0x194118: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x19411c: 0x8c6219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x194120: 0x8c6419dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x194124: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x194128: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x19412c: 0x14450005
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        ctx->pc = 0x194144; return;
    }
    // 0x194134: 0xc06fb52
    SET_GPR_U32(ctx, 31, 0x19413c);
    SfxhMusicUnknown1(rdram, ctx, runtime); return;
}


// Function: entry_19413c
// Address: 0x19413c - 0x19415c

void entry_19413c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19413c) {
        switch (ctx->pc) {
            case 0x194144: ctx->pc = 0; goto label_194144;
            case 0x194150: ctx->pc = 0; goto label_194150;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19413c: 0x10000004
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_194150;
    }
label_194144:
    // 0x194144: 0x8c43051c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1308)));
    // 0x194148: 0x10600006
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194164; return;
    }
label_194150:
    // 0x194150: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x194154: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x19415c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_19415c
// Address: 0x19415c - 0x194184

void entry_19415c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19415c) {
        switch (ctx->pc) {
            case 0x194164: ctx->pc = 0; goto label_194164;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19415c: 0x1000000e
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194198; return;
    }
label_194164:
    // 0x194164: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x194168: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x19416c: 0x24425bc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23488));
    // 0x194170: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x194174: 0x14640005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x19418C; return;
    }
    // 0x19417c: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x194184);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_194184
// Address: 0x194184 - 0x194194

void entry_194184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194184) {
        switch (ctx->pc) {
            case 0x19418c: ctx->pc = 0; goto label_19418c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194184: 0x10000004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194198; return;
    }
label_19418c:
    // 0x19418c: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x194194);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_194194
// Address: 0x194194 - 0x1941a4

void entry_194194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194194) {
        switch (ctx->pc) {
            case 0x194198: ctx->pc = 0; goto label_194198;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194194: 0x8e060260
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 608)));
label_194198:
    // 0x194198: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19419c: 0xc064fba
    SET_GPR_U32(ctx, 31, 0x1941a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00193ee8(rdram, ctx, runtime); return;
}


// Function: entry_1941a4
// Address: 0x1941a4 - 0x1941b4

void entry_1941a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1941a4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1941a8: 0x8c430038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 56)));
    // 0x1941ac: 0x60f809
    SET_GPR_U32(ctx, 31, 0x1941b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_1941b4
// Address: 0x1941b4 - 0x1941bc

void entry_1941b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1941b4: 0xc05b83c
    SET_GPR_U32(ctx, 31, 0x1941bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    AddGrfusr__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1941bc
// Address: 0x1941bc - 0x1941c8

void entry_1941bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1941bc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1941c0: 0xc05bb22
    SET_GPR_U32(ctx, 31, 0x1941c8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    StartJoySelection__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_1941c8
// Address: 0x1941c8 - 0x1941f8

void entry_1941c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1941c8) {
        switch (ctx->pc) {
            case 0x1941d0: ctx->pc = 0; goto label_1941d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1941c8: 0x10000025
    WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194260; return;
    }
label_1941d0:
    // 0x1941d0: 0x24050308
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 776));
    // 0x1941d4: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1941d8: 0x8c6219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x1941dc: 0x8c6419dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x1941e0: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x1941e4: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1941e8: 0x14450005
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        ctx->pc = 0x194200; return;
    }
    // 0x1941f0: 0xc06fb5c
    SET_GPR_U32(ctx, 31, 0x1941f8);
    SfxhMusicUnknown2(rdram, ctx, runtime); return;
}


// Function: entry_1941f8
// Address: 0x1941f8 - 0x194224

void entry_1941f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1941f8) {
        switch (ctx->pc) {
            case 0x194200: ctx->pc = 0; goto label_194200;
            case 0x194218: ctx->pc = 0; goto label_194218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1941f8: 0x10000007
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_194218;
    }
label_194200:
    // 0x194200: 0x8c43051c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1308)));
    // 0x194204: 0x14600004
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_194218;
    }
    // 0x19420c: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x194210: 0x10400006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19422C; return;
    }
label_194218:
    // 0x194218: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x19421c: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x194224);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_194224
// Address: 0x194224 - 0x194234

void entry_194224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194224) {
        switch (ctx->pc) {
            case 0x19422c: ctx->pc = 0; goto label_19422c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194224: 0x10000004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194238; return;
    }
label_19422c:
    // 0x19422c: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x194234);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_194234
// Address: 0x194234 - 0x194244

void entry_194234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194234) {
        switch (ctx->pc) {
            case 0x194238: ctx->pc = 0; goto label_194238;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194234: 0x8e050260
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 608)));
label_194238:
    // 0x194238: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19423c: 0xc064fba
    SET_GPR_U32(ctx, 31, 0x194244);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00193ee8(rdram, ctx, runtime); return;
}


// Function: entry_194244
// Address: 0x194244 - 0x194254

void entry_194244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194244: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x194248: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x19424c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x194254);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_194254
// Address: 0x194254 - 0x19425c

void entry_194254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194254: 0xc05b846
    SET_GPR_U32(ctx, 31, 0x19425c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    RemoveGrfusr__Fi(rdram, ctx, runtime); return;
}


// Function: entry_19425c
// Address: 0x19425c - 0x194278

void entry_19425c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19425c) {
        switch (ctx->pc) {
            case 0x194260: ctx->pc = 0; goto label_194260;
            case 0x194264: ctx->pc = 0; goto label_194264;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19425c: 0xae11025c
    WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
label_194260:
    // 0x194260: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_194264:
    // 0x194264: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x194268: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19426c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x194274: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x194278; return;
}


// Function: FUN_00194278
// Address: 0x194278 - 0x19429c

void FUN_00194278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194278: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x19427c: 0x7fb10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 17));
    // 0x194280: 0x7fb00020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 16));
    // 0x194284: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x194288: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x19428c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x194290: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x194294: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x19429c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_19429c
// Address: 0x19429c - 0x1942fc

void entry_19429c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19429c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1942a0: 0x24050106
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 262));
    // 0x1942a4: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1942a8: 0x8c6219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x1942ac: 0x8c6419dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x1942b0: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x1942b4: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1942b8: 0x1445001d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        ctx->pc = 0x194330; return;
    }
    // 0x1942c0: 0x12200010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194304; return;
    }
    // 0x1942c8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1942cc: 0x24425b04
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23300));
    // 0x1942d0: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1942d4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1942d8: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1942dc: 0xafa50008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 5));
    // 0x1942e0: 0x24845f80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    // 0x1942e4: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1942e8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1942ec: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1942f0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1942f4: 0xc07bfe8
    SET_GPR_U32(ctx, 31, 0x1942fc);
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    ActivateWipe__FP4WIPEP5TRANS5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_1942fc
// Address: 0x1942fc - 0x19431c

void entry_1942fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1942fc) {
        switch (ctx->pc) {
            case 0x194304: ctx->pc = 0; goto label_194304;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1942fc: 0x10000022
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194388; return;
    }
label_194304:
    // 0x194304: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x194308: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x19430c: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x194310: 0x2406005f
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 95));
    // 0x194314: 0xc056a0e
    SET_GPR_U32(ctx, 31, 0x19431c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObjectByClass__FP2SWi3CIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19431c
// Address: 0x19431c - 0x194328

void entry_19431c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19431c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x194320: 0xc0693bc
    SET_GPR_U32(ctx, 31, 0x194328);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    SetRobRobs__FP3ROB4ROBS(rdram, ctx, runtime); return;
}


// Function: entry_194328
// Address: 0x194328 - 0x194370

void entry_194328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194328) {
        switch (ctx->pc) {
            case 0x194330: ctx->pc = 0; goto label_194330;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194328: 0x10000017
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194388; return;
    }
label_194330:
    // 0x194330: 0x12200011
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194378; return;
    }
    // 0x194338: 0x2407ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19433c: 0x24425b04
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23300));
    // 0x194340: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x194344: 0x24080010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 16));
    // 0x194348: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x19434c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x194350: 0x24845f80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    // 0x194354: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x194358: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19435c: 0xafa7000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 7));
    // 0x194360: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x194364: 0xafa80010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 8));
    // 0x194368: 0xc07bfe8
    SET_GPR_U32(ctx, 31, 0x194370);
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 7));
    ActivateWipe__FP4WIPEP5TRANS5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_194370
// Address: 0x194370 - 0x194384

void entry_194370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194370) {
        switch (ctx->pc) {
            case 0x194378: ctx->pc = 0; goto label_194378;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194370: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194388; return;
    }
label_194378:
    // 0x194378: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19437c: 0xc07d102
    SET_GPR_U32(ctx, 31, 0x194384);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TriggerDefaultExit__Fi5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_194384
// Address: 0x194384 - 0x194398

void entry_194384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194384) {
        switch (ctx->pc) {
            case 0x194388: ctx->pc = 0; goto label_194388;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194384: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_194388:
    // 0x194388: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19438c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x194390: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00194398
// Address: 0x194398 - 0x1943dc

void FUN_00194398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194398: 0x3c020024
    SET_GPR_U32(ctx, 2, ((uint32_t)36 << 16));
    // 0x19439c: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1943a0: 0x2407ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1943a4: 0x24427ab0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 31408));
    // 0x1943a8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1943ac: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1943b0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1943b4: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x1943b8: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1943bc: 0x24845f80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    // 0x1943c0: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x1943c4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1943c8: 0xafa7000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 7));
    // 0x1943cc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1943d0: 0xafa80010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 8));
    // 0x1943d4: 0xc07bfe8
    SET_GPR_U32(ctx, 31, 0x1943dc);
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 7));
    ActivateWipe__FP4WIPEP5TRANS5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_1943dc
// Address: 0x1943dc - 0x1943e8

void entry_1943dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1943dc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1943e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: update_pausemenu_active
// Address: 0x1943e8 - 0x1944b4

void entry_1944b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1944b4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1944b8: 0x8c83c948
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294953288)));
    // 0x1944bc: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1944c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1944c8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294953288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1944c8
// Address: 0x1944c8 - 0x1944dc

void entry_1944c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1944c8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1944cc: 0x8c83cbc8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294953928)));
    // 0x1944d0: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1944d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1944dc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294953928));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1944dc
// Address: 0x1944dc - 0x1944f0

void entry_1944dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1944dc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1944e0: 0x8c83ce48
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294954568)));
    // 0x1944e4: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1944e8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1944f0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294954568));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1944f0
// Address: 0x1944f0 - 0x194508

void entry_1944f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1944f0) {
        switch (ctx->pc) {
            case 0x1944f8: ctx->pc = 0; goto label_1944f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1944f0: 0x10000015
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194548; return;
    }
label_1944f8:
    // 0x1944f8: 0x8c83c6c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294952648)));
    // 0x1944fc: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x194500: 0x40f809
    SET_GPR_U32(ctx, 31, 0x194508);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294952648));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_194508
// Address: 0x194508 - 0x19451c

void entry_194508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194508: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x19450c: 0x8c83c948
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294953288)));
    // 0x194510: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x194514: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19451c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294953288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19451c
// Address: 0x19451c - 0x194530

void entry_19451c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19451c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x194520: 0x8c83cbc8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294953928)));
    // 0x194524: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x194528: 0x40f809
    SET_GPR_U32(ctx, 31, 0x194530);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294953928));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_194530
// Address: 0x194530 - 0x194544

void entry_194530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194530: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x194534: 0x8c83ce48
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294954568)));
    // 0x194538: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x19453c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x194544);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294954568));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_194544
// Address: 0x194544 - 0x19457c

void entry_194544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194544) {
        switch (ctx->pc) {
            case 0x194548: ctx->pc = 0; goto label_194548;
            case 0x19456c: ctx->pc = 0; goto label_19456c;
            case 0x194574: ctx->pc = 0; goto label_194574;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194544: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
label_194548:
    // 0x194548: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x19454c: 0x10620009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 12));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_194574;
    }
    // 0x194554: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 17));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19456c;
    }
    // 0x19455c: 0x10600005
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_194574;
    }
    // 0x194564: 0x10000011
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 16664)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1945AC; return;
    }
label_19456c:
    // 0x19456c: 0x1462000e
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1945A8; return;
    }
label_194574:
    // 0x194574: 0xc0582ca
    SET_GPR_U32(ctx, 31, 0x19457c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9152)));
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime); return;
}


// Function: entry_19457c
// Address: 0x19457c - 0x1945a0

void entry_19457c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19457c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x194580: 0x24644118
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 16664));
    // 0x194584: 0x8c664118
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 16664)));
    // 0x194588: 0x2485027c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 636));
    // 0x19458c: 0xac82027c
    WRITE32(ADD32(GPR_U32(ctx, 4), 636), GPR_U32(ctx, 2));
    // 0x194590: 0xac850264
    WRITE32(ADD32(GPR_U32(ctx, 4), 612), GPR_U32(ctx, 5));
    // 0x194594: 0x8cc20038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 56)));
    // 0x194598: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1945a0);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1945a0
// Address: 0x1945a0 - 0x1945b8

void entry_1945a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1945a0) {
        switch (ctx->pc) {
            case 0x1945a8: ctx->pc = 0; goto label_1945a8;
            case 0x1945ac: ctx->pc = 0; goto label_1945ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1945a0: 0x10000006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 648)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1945BC; return;
    }
label_1945a8:
    // 0x1945a8: 0x8c834118
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 16664)));
label_1945ac:
    // 0x1945ac: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x1945b0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1945b8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16664));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1945b8
// Address: 0x1945b8 - 0x1945cc

void entry_1945b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1945b8) {
        switch (ctx->pc) {
            case 0x1945bc: ctx->pc = 0; goto label_1945bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1945b8: 0x8e020288
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 648)));
label_1945bc:
    // 0x1945bc: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 628)));
        ctx->pc = 0x1945EC; return;
    }
    // 0x1945c4: 0xc06fa04
    SET_GPR_U32(ctx, 31, 0x1945cc);
    FPauseForVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1945cc
// Address: 0x1945cc - 0x1945dc

void entry_1945cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1945cc: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1945dc(rdram, ctx, runtime); return;
    }
    // 0x1945d4: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x1945dc);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_1945dc
// Address: 0x1945dc - 0x1945e4

void entry_1945dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1945dc: 0xc06fa60
    SET_GPR_U32(ctx, 31, 0x1945e4);
    FVagPlaying__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1945e4
// Address: 0x1945e4 - 0x194660

void entry_1945e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1945e4) {
        switch (ctx->pc) {
            case 0x1945ec: ctx->pc = 0; goto label_1945ec;
            case 0x194630: ctx->pc = 0; goto label_194630;
            case 0x194634: ctx->pc = 0; goto label_194634;
            case 0x194638: ctx->pc = 0; goto label_194638;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1945e4: 0xae020288
    WRITE32(ADD32(GPR_U32(ctx, 16), 648), GPR_U32(ctx, 2));
    // 0x1945e8: 0x8e020274
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 628)));
label_1945ec:
    // 0x1945ec: 0x14400010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_194630;
    }
    // 0x1945f4: 0x8e030250
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 592)));
    // 0x1945f8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1945fc: 0x5462000d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_194634;
    }
    // 0x194604: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x194608: 0xc6020254
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 596)); ctx->f[2] = *(float*)&val; }
    // 0x19460c: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x194610: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x194614: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x194618: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19461c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x194620: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x194624: 0x0
    // NOP
    // 0x194628: 0x45030003
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
        goto label_194638;
    }
label_194630:
    // 0x194630: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_194634:
    // 0x194634: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_194638:
    // 0x194638: 0x8e630010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x19463c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x194640: 0x24512c70
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 11376));
    // 0x194644: 0x1060000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_194670(rdram, ctx, runtime); return;
    }
    // 0x19464c: 0x8e62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 12)));
    // 0x194650: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194668; return;
    }
    // 0x194658: 0xc05bbb4
    SET_GPR_U32(ctx, 31, 0x194660);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DySelectionJoy__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_194660
// Address: 0x194660 - 0x194670

void entry_194660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194660) {
        switch (ctx->pc) {
            case 0x194668: ctx->pc = 0; goto label_194668;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194660: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_194670(rdram, ctx, runtime); return;
    }
label_194668:
    // 0x194668: 0xc05bb26
    SET_GPR_U32(ctx, 31, 0x194670);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DxSelectionJoy__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_194670
// Address: 0x194670 - 0x194724

void entry_194670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194670) {
        switch (ctx->pc) {
            case 0x194698: ctx->pc = 0; goto label_194698;
            case 0x1946c0: ctx->pc = 0; goto label_1946c0;
            case 0x1946dc: ctx->pc = 0; goto label_1946dc;
            case 0x19470c: ctx->pc = 0; goto label_19470c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194670: 0x18400013
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 121));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1946c0;
    }
    // 0x194678: 0x8e020264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 612)));
    // 0x19467c: 0x8e630010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x194680: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x194684: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x194688: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x19468c: 0x43001a
    { int32_t divisor = GPR_S32(ctx, 3); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 3) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,3); } }
    // 0x194690: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_194698;
    }
label_194698:
    // 0x194698: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x19469c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1946a0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1946a4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1946a8: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1946ac: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1946b0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1946b4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1946b8: 0x10000014
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19470c;
    }
label_1946c0:
    // 0x1946c0: 0x441001a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        ctx->pc = 0x19472C; return;
    }
    // 0x1946c8: 0x8e630010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1946cc: 0x8e020264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 612)));
    // 0x1946d0: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1946d4: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_1946dc;
    }
label_1946dc:
    // 0x1946dc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1946e0: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1946e4: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1946e8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1946ec: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1946f0: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1946f4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1946f8: 0x43001a
    { int32_t divisor = GPR_S32(ctx, 3); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 3) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,3); } }
    // 0x1946fc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x194700: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x194704: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x194708: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_19470c:
    // 0x19470c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x194710: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x194714: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x194718: 0x5010
    SET_GPR_U32(ctx, 10, ctx->hi);
    // 0x19471c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x194724);
    WRITE32(ADD32(GPR_U32(ctx, 16), 612), GPR_U32(ctx, 10));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_194724
// Address: 0x194724 - 0x19474c

void entry_194724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194724) {
        switch (ctx->pc) {
            case 0x19472c: ctx->pc = 0; goto label_19472c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194724: 0x10000179
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
label_19472c:
    // 0x19472c: 0x12800177
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194734: 0x962300aa
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 170)));
    // 0x194738: 0x30620810
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 2064));
    // 0x19473c: 0x10400005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 11376));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194754; return;
    }
    // 0x194744: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x19474c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2064));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_19474c
// Address: 0x19474c - 0x194768

void entry_19474c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19474c) {
        switch (ctx->pc) {
            case 0x194754: ctx->pc = 0; goto label_194754;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19474c: 0x100000f2
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194B18; return;
    }
label_194754:
    // 0x194754: 0x30620080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 128));
    // 0x194758: 0x10400021
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1947E0; return;
    }
    // 0x194760: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x194768);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 128));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_194768
// Address: 0x194768 - 0x1947d8

void entry_194768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194768) {
        switch (ctx->pc) {
            case 0x194780: ctx->pc = 0; goto label_194780;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194768: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x19476c: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x194770: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_194780;
    }
    // 0x194778: 0x14620164
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x194D0C; return;
    }
label_194780:
    // 0x194780: 0x8e030264
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 612)));
    // 0x194784: 0x24051a5c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6748));
    // 0x194788: 0x8e620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x19478c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x194790: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x194794: 0x248442d8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 17112));
    // 0x194798: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19479c: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1947a0: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1947a4: 0x451018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1947a8: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1947ac: 0xc460000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1947b0: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1947b4: 0x0
    // NOP
    // 0x1947b8: 0x45010154
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x1947c0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1947c4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1947c8: 0xac43998c
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294941068), GPR_U32(ctx, 3));
    // 0x1947cc: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1947d0: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1947d8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 18));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1947d8
// Address: 0x1947d8 - 0x1947f0

void entry_1947d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1947d8) {
        switch (ctx->pc) {
            case 0x1947e0: ctx->pc = 0; goto label_1947e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1947d8: 0x1000014c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
label_1947e0:
    // 0x1947e0: 0x10400007
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 11376));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194800; return;
    }
    // 0x1947e8: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1947f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1947f0
// Address: 0x1947f0 - 0x1947f8

void entry_1947f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1947f0: 0xc065656
    SET_GPR_U32(ctx, 31, 0x1947f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00195958(rdram, ctx, runtime); return;
}


// Function: entry_1947f8
// Address: 0x1947f8 - 0x19483c

void entry_1947f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1947f8) {
        switch (ctx->pc) {
            case 0x194800: ctx->pc = 0; goto label_194800;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1947f8: 0x10000144
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
label_194800:
    // 0x194800: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x194804: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x194808: 0x2463fffd
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967293));
    // 0x19480c: 0x2c62001e
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 30));
    // 0x194810: 0x1040013d
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_194d08(rdram, ctx, runtime); return;
    }
    // 0x194818: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x19481c: 0x2442c620
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294952480));
    // 0x194820: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x194824: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x194828: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x194830: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x194834: 0xc05bc42
    SET_GPR_U32(ctx, 31, 0x19483c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UBtnpJoy__FP3JOY4BTNP(rdram, ctx, runtime); return;
}


// Function: entry_19483c
// Address: 0x19483c - 0x19484c

void entry_19483c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19483c: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x194840: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x194844: 0xc05bc42
    SET_GPR_U32(ctx, 31, 0x19484c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    UBtnpJoy__FP3JOY4BTNP(rdram, ctx, runtime); return;
}


// Function: entry_19484c
// Address: 0x19484c - 0x19485c

void entry_19484c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19484c: 0x4600a541
    ctx->f[21] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x194850: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x194854: 0xc05bc42
    SET_GPR_U32(ctx, 31, 0x19485c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    UBtnpJoy__FP3JOY4BTNP(rdram, ctx, runtime); return;
}


// Function: entry_19485c
// Address: 0x19485c - 0x19486c

void entry_19485c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19485c: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x194860: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x194864: 0xc05bc42
    SET_GPR_U32(ctx, 31, 0x19486c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    UBtnpJoy__FP3JOY4BTNP(rdram, ctx, runtime); return;
}


// Function: entry_19486c
// Address: 0x19486c - 0x194954

void entry_19486c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19486c) {
        switch (ctx->pc) {
            case 0x194898: ctx->pc = 0; goto label_194898;
            case 0x1948d4: ctx->pc = 0; goto label_1948d4;
            case 0x1948e8: ctx->pc = 0; goto label_1948e8;
            case 0x19492c: ctx->pc = 0; goto label_19492c;
            case 0x194940: ctx->pc = 0; goto label_194940;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19486c: 0x4600a101
    ctx->f[4] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x194870: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x194874: 0x4600a832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x194878: 0x0
    // NOP
    // 0x19487c: 0x45000006
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_194898;
    }
    // 0x194884: 0x46002032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x194888: 0x0
    // NOP
    // 0x19488c: 0x4501011f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194894: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_194898:
    // 0x194898: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x19489c: 0xc440a22c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294943276)); ctx->f[0] = *(float*)&val; }
    // 0x1948a0: 0xc461a700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944512)); ctx->f[1] = *(float*)&val; }
    // 0x1948a4: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x1948a8: 0x3c0143d4
    SET_GPR_U32(ctx, 1, ((uint32_t)17364 << 16));
    // 0x1948ac: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1948b0: 0x3c014454
    SET_GPR_U32(ctx, 1, ((uint32_t)17492 << 16));
    // 0x1948b4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1948b8: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x1948bc: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1948c0: 0x0
    // NOP
    // 0x1948c4: 0x45000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1948d4;
    }
    // 0x1948cc: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1948e8;
    }
label_1948d4:
    // 0x1948d4: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1948d8: 0x0
    // NOP
    // 0x1948dc: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1948e8;
    }
    // 0x1948e4: 0x46001d06
    ctx->f[20] = FPU_MOV_S(ctx->f[3]);
label_1948e8:
    // 0x1948e8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1948ec: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1948f0: 0xc440a230
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294943280)); ctx->f[0] = *(float*)&val; }
    // 0x1948f4: 0xc461a704
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944516)); ctx->f[1] = *(float*)&val; }
    // 0x1948f8: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1948fc: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x194900: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x194904: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x194908: 0x3c0142b4
    SET_GPR_U32(ctx, 1, ((uint32_t)17076 << 16));
    // 0x19490c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x194910: 0x46000b00
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x194914: 0x46026034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x194918: 0x0
    // NOP
    // 0x19491c: 0x45000003
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 4), 4294944512), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19492c;
    }
    // 0x194924: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_194940;
    }
label_19492c:
    // 0x19492c: 0x460c1834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x194930: 0x0
    // NOP
    // 0x194934: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_194940;
    }
    // 0x19493c: 0x46001d06
    ctx->f[20] = FPU_MOV_S(ctx->f[3]);
label_194940:
    // 0x194940: 0xc48ca700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4294944512)); ctx->f[12] = *(float*)&val; }
    // 0x194944: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x194948: 0x26522490
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 9360));
    // 0x19494c: 0xc07f5e8
    SET_GPR_U32(ctx, 31, 0x194954);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 4294944516), *(uint32_t*)&val); }
    FUN_001fd7a0(rdram, ctx, runtime); return;
}


// Function: entry_194954
// Address: 0x194954 - 0x194988

void entry_194954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194954: 0xde510040
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 18), 64)));
    // 0x194958: 0x2403f000
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294963200));
    // 0x19495c: 0xde500018
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x194960: 0x30440fff
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 2), 4095));
    // 0x194964: 0x2238824
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x194968: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19496c: 0x2038024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x194970: 0x2228825
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x194974: 0x2048025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 4)));
    // 0x194978: 0xfe510040
    WRITE64(ADD32(GPR_U32(ctx, 18), 64), GPR_U64(ctx, 17));
    // 0x19497c: 0xfe500018
    WRITE64(ADD32(GPR_U32(ctx, 18), 24), GPR_U64(ctx, 16));
    // 0x194980: 0xc07f5e8
    SET_GPR_U32(ctx, 31, 0x194988);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    FUN_001fd7a0(rdram, ctx, runtime); return;
}


// Function: entry_194988
// Address: 0x194988 - 0x194ab0

void entry_194988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194988) {
        switch (ctx->pc) {
            case 0x194a34: ctx->pc = 0; goto label_194a34;
            case 0x194a44: ctx->pc = 0; goto label_194a44;
            case 0x194a74: ctx->pc = 0; goto label_194a74;
            case 0x194a84: ctx->pc = 0; goto label_194a84;
            case 0x194aa4: ctx->pc = 0; goto label_194aa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194988: 0x304307fe
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 2), 2046));
    // 0x19498c: 0x3c04ff80
    SET_GPR_U32(ctx, 4, ((uint32_t)65408 << 16));
    // 0x194990: 0x34840fff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 4095));
    // 0x194994: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x194998: 0x2048024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 4)));
    // 0x19499c: 0x21338
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 12);
    // 0x1949a0: 0x2248824
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    // 0x1949a4: 0x31b38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 12);
    // 0x1949a8: 0x2228825
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1949ac: 0x2038025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1949b0: 0xfe510040
    WRITE64(ADD32(GPR_U32(ctx, 18), 64), GPR_U64(ctx, 17));
    // 0x1949b4: 0x100000d4
    WRITE64(ADD32(GPR_U32(ctx, 18), 24), GPR_U64(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_194d08(rdram, ctx, runtime); return;
    }
    // 0x1949bc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1949c0: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1949c4: 0x8c434a58
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 19032)));
    // 0x1949c8: 0x14640053
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x194B18; return;
    }
    // 0x1949d0: 0x8e020264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 612)));
    // 0x1949d4: 0x8e630014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x1949d8: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1949dc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1949e0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1949e4: 0x2483fff6
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 4294967286));
    // 0x1949e8: 0x2c630003
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 3), 3));
    // 0x1949ec: 0x1060003e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6748));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194AE8; return;
    }
    // 0x1949f4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1949f8: 0x831818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1949fc: 0x244242d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 17112));
    // 0x194a00: 0x24040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    // 0x194a04: 0x14a4000f
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 4)) {
        goto label_194a44;
    }
    // 0x194a0c: 0xc461000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 12)); ctx->f[1] = *(float*)&val; }
    // 0x194a10: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x194a14: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x194a18: 0x0
    // NOP
    // 0x194a1c: 0x45010005
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_194a34;
    }
    // 0x194a24: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x194a28: 0x8e03ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294962288)));
    // 0x194a2c: 0x1000001d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952328));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_194aa4;
    }
label_194a34:
    // 0x194a34: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x194a38: 0x8e03ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294962288)));
    // 0x194a3c: 0x10000019
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952352));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_194aa4;
    }
label_194a44:
    // 0x194a44: 0x24020011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 17));
    // 0x194a48: 0x14a2000e
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 12)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_194a84;
    }
    // 0x194a50: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x194a54: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x194a58: 0x0
    // NOP
    // 0x194a5c: 0x45010005
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_194a74;
    }
    // 0x194a64: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x194a68: 0x8e03ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294962288)));
    // 0x194a6c: 0x1000000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952376));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_194aa4;
    }
label_194a74:
    // 0x194a74: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x194a78: 0x8e03ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294962288)));
    // 0x194a7c: 0x10000009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952352));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_194aa4;
    }
label_194a84:
    // 0x194a84: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x194a88: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x194a8c: 0x0
    // NOP
    // 0x194a90: 0x45010009
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x194AB8; return;
    }
    // 0x194a98: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x194a9c: 0x8e03ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294962288)));
    // 0x194aa0: 0x24a5c5d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952400));
label_194aa4:
    // 0x194aa4: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x194aa8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x194ab0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4294962288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_194ab0
// Address: 0x194ab0 - 0x194ad0

void entry_194ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194ab0) {
        switch (ctx->pc) {
            case 0x194ab8: ctx->pc = 0; goto label_194ab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194ab0: 0x10000008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294962288)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194AD4; return;
    }
label_194ab8:
    // 0x194ab8: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x194abc: 0x8e03ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294962288)));
    // 0x194ac0: 0x24a5c600
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952448));
    // 0x194ac4: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x194ac8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x194ad0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4294962288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_194ad0
// Address: 0x194ad0 - 0x194ae0

void entry_194ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194ad0) {
        switch (ctx->pc) {
            case 0x194ad4: ctx->pc = 0; goto label_194ad4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194ad0: 0x8e03ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294962288)));
label_194ad4:
    // 0x194ad4: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x194ad8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x194ae0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 4294962288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_194ae0
// Address: 0x194ae0 - 0x194afc

void entry_194ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194ae0) {
        switch (ctx->pc) {
            case 0x194ae8: ctx->pc = 0; goto label_194ae8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194ae0: 0x1000008a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
label_194ae8:
    // 0x194ae8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x194aec: 0x8c83ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294962288)));
    // 0x194af0: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x194af4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x194afc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294962288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_194afc
// Address: 0x194afc - 0x194b20

void entry_194afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194afc) {
        switch (ctx->pc) {
            case 0x194b18: ctx->pc = 0; goto label_194b18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194afc: 0x10000083
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194b04: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x194b08: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x194b0c: 0x8c434a58
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 19032)));
    // 0x194b10: 0x1064007e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        ctx->pc = 0x194D0C; return;
    }
label_194b18:
    // 0x194b18: 0xc065870
    SET_GPR_U32(ctx, 31, 0x194b20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001961c0(rdram, ctx, runtime); return;
}


// Function: entry_194b20
// Address: 0x194b20 - 0x194b44

void entry_194b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194b20: 0x1000007a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194b28: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x194b2c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x194b30: 0x8c434a58
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 19032)));
    // 0x194b34: 0x50640004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x194B48; return;
    }
    // 0x194b3c: 0xc065870
    SET_GPR_U32(ctx, 31, 0x194b44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001961c0(rdram, ctx, runtime); return;
}


// Function: entry_194b44
// Address: 0x194b44 - 0x194b54

void entry_194b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194b44) {
        switch (ctx->pc) {
            case 0x194b48: ctx->pc = 0; goto label_194b48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194b44: 0x8e640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_194b48:
    // 0x194b48: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x194b4c: 0xc07da20
    SET_GPR_U32(ctx, 31, 0x194b54);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952472));
    FUN_001f6880(rdram, ctx, runtime); return;
}


// Function: entry_194b54
// Address: 0x194b54 - 0x194b68

void entry_194b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194b54: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x194b58: 0x1200006c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194b60: 0xc06ba82
    SET_GPR_U32(ctx, 31, 0x194b68);
    FUN_001aea08(rdram, ctx, runtime); return;
}


// Function: entry_194b68
// Address: 0x194b68 - 0x194ba4

void entry_194b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194b68: 0x10000067
    WRITE8(ADD32(GPR_U32(ctx, 16), 2), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_194d08(rdram, ctx, runtime); return;
    }
    // 0x194b70: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x194b74: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x194b78: 0x8c434a4c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 19020)));
    // 0x194b7c: 0x14640063
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194b84: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x194b88: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x194b8c: 0x10000052
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194CD8; return;
    }
    // 0x194b94: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x194b98: 0x24519990
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294941072));
    // 0x194b9c: 0xc062ddc
    SET_GPR_U32(ctx, 31, 0x194ba4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FCheckMemcardThread__FP7MEMCARD(rdram, ctx, runtime); return;
}


// Function: entry_194ba4
// Address: 0x194ba4 - 0x194bd0

void entry_194ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194ba4: 0x14400059
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194bac: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x194bb0: 0x1440000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194BE8; return;
    }
    // 0x194bb8: 0x3c050019
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    // 0x194bbc: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x194bc0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x194bc4: 0x24a5c250
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294951504));
    // 0x194bc8: 0xc062d9c
    SET_GPR_U32(ctx, 31, 0x194bd0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19008));
    CreateMemcardThread__FP7MEMCARDii(rdram, ctx, runtime); return;
}


// Function: entry_194bd0
// Address: 0x194bd0 - 0x194be0

void entry_194bd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194bd0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x194bd4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x194bd8: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x194be0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_194be0
// Address: 0x194be0 - 0x194bf4

void entry_194be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194be0) {
        switch (ctx->pc) {
            case 0x194be8: ctx->pc = 0; goto label_194be8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194be0: 0x1000004a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
label_194be8:
    // 0x194be8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x194bec: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x194bf4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_194bf4
// Address: 0x194bf4 - 0x194c0c

void entry_194bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194bf4: 0x10000045
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194bfc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x194c00: 0x24519990
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294941072));
    // 0x194c04: 0xc062ddc
    SET_GPR_U32(ctx, 31, 0x194c0c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FCheckMemcardThread__FP7MEMCARD(rdram, ctx, runtime); return;
}


// Function: entry_194c0c
// Address: 0x194c0c - 0x194c2c

void entry_194c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194c0c: 0x1440003f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194c14: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x194c18: 0x1040002d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194CD0; return;
    }
    // 0x194c20: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x194c24: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x194c2c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 9));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_194c2c
// Address: 0x194c2c - 0x194c44

void entry_194c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194c2c: 0x10000037
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194c34: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x194c38: 0x24519990
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294941072));
    // 0x194c3c: 0xc062ddc
    SET_GPR_U32(ctx, 31, 0x194c44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FCheckMemcardThread__FP7MEMCARD(rdram, ctx, runtime); return;
}


// Function: entry_194c44
// Address: 0x194c44 - 0x194c64

void entry_194c44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194c44: 0x14400031
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194c4c: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x194c50: 0x1440000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194C84; return;
    }
    // 0x194c58: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x194c5c: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x194c64);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_194c64
// Address: 0x194c64 - 0x194c7c

void entry_194c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194c64: 0x8e03027c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 636)));
    // 0x194c68: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x194c6c: 0x14620027
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194c74: 0xc0650e6
    SET_GPR_U32(ctx, 31, 0x194c7c);
    FUN_00194398(rdram, ctx, runtime); return;
}


// Function: entry_194c7c
// Address: 0x194c7c - 0x194c90

void entry_194c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194c7c) {
        switch (ctx->pc) {
            case 0x194c84: ctx->pc = 0; goto label_194c84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194c7c: 0x10000023
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
label_194c84:
    // 0x194c84: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x194c88: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x194c90);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 23));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_194c90
// Address: 0x194c90 - 0x194ca0

void entry_194c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194c90: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x194c94: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x194c98: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x194ca0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 15));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_194ca0
// Address: 0x194ca0 - 0x194cb8

void entry_194ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194ca0: 0x1000001a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194ca8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x194cac: 0x24519990
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294941072));
    // 0x194cb0: 0xc062ddc
    SET_GPR_U32(ctx, 31, 0x194cb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FCheckMemcardThread__FP7MEMCARD(rdram, ctx, runtime); return;
}


// Function: entry_194cb8
// Address: 0x194cb8 - 0x194ce0

void entry_194cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194cb8) {
        switch (ctx->pc) {
            case 0x194cd0: ctx->pc = 0; goto label_194cd0;
            case 0x194cd8: ctx->pc = 0; goto label_194cd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194cb8: 0x14400014
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
    // 0x194cc0: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x194cc4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x194cc8: 0x14600007
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294941068), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194CE8; return;
    }
label_194cd0:
    // 0x194cd0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x194cd4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
label_194cd8:
    // 0x194cd8: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x194ce0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_194ce0
// Address: 0x194ce0 - 0x194cf8

void entry_194ce0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194ce0) {
        switch (ctx->pc) {
            case 0x194ce8: ctx->pc = 0; goto label_194ce8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194ce0: 0x1000000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194D0C; return;
    }
label_194ce8:
    // 0x194ce8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x194cec: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x194cf0: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x194cf8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 23));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_194cf8
// Address: 0x194cf8 - 0x194d08

void entry_194cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194cf8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x194cfc: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x194d00: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x194d08);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 15));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_194d08
// Address: 0x194d08 - 0x194d30

void entry_194d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194d08) {
        switch (ctx->pc) {
            case 0x194d0c: ctx->pc = 0; goto label_194d0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194d08: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_194d0c:
    // 0x194d0c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x194d10: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x194d14: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x194d18: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x194d1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x194d20: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x194d24: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x194d28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00194d30
// Address: 0x194d30 - 0x194da4

void FUN_00194d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194d30) {
        switch (ctx->pc) {
            case 0x194d68: ctx->pc = 0; goto label_194d68;
            case 0x194d94: ctx->pc = 0; goto label_194d94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194d30: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x194d34: 0x52880
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 2));
    // 0x194d38: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x194d3c: 0x2407ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x194d40: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x194d44: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x194d48: 0x26020268
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 616));
    // 0x194d4c: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x194d50: 0x452821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x194d54: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x194d58: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x194d5c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x194d60: 0xacb20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 18));
    // 0x194d64: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_194d68:
    // 0x194d68: 0x8cc40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x194d6c: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x194d70: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x194d74: 0x2ca30003
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 5), 3));
    // 0x194d78: 0x871026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 4), GPR_U32(ctx, 7)));
    // 0x194d7c: 0x1460fffa
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_194d68;
    }
    // 0x194d84: 0x8e020274
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 628)));
    // 0x194d88: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 608)));
        goto label_194d94;
    }
    // 0x194d90: 0x8e110278
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 632)));
label_194d94:
    // 0x194d94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x194d98: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x194d9c: 0xc064fba
    SET_GPR_U32(ctx, 31, 0x194da4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_00193ee8(rdram, ctx, runtime); return;
}


// Function: entry_194da4
// Address: 0x194da4 - 0x194dc0

void entry_194da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194da4: 0x12320019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x194E0C; return;
    }
    // 0x194dac: 0x8e020250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 592)));
    // 0x194db0: 0x14400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194DC8; return;
    }
    // 0x194db8: 0xc06564a
    SET_GPR_U32(ctx, 31, 0x194dc0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_00195928(rdram, ctx, runtime); return;
}


// Function: entry_194dc0
// Address: 0x194dc0 - 0x194e08

void entry_194dc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194dc0) {
        switch (ctx->pc) {
            case 0x194dc8: ctx->pc = 0; goto label_194dc8;
            case 0x194dec: ctx->pc = 0; goto label_194dec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194dc0: 0x10000012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194E0C; return;
    }
label_194dc8:
    // 0x194dc8: 0x440000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 4));
    if (GPR_S32(ctx, 2) < 0) {
        entry_194e08(rdram, ctx, runtime); return;
    }
    // 0x194dd0: 0x1040000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_194e08(rdram, ctx, runtime); return;
    }
    // 0x194dd8: 0x16420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        goto label_194dec;
    }
    // 0x194de0: 0xae000274
    WRITE32(ADD32(GPR_U32(ctx, 16), 628), GPR_U32(ctx, 0));
    // 0x194de4: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 16), 632), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_194e08(rdram, ctx, runtime); return;
    }
label_194dec:
    // 0x194dec: 0xae120278
    WRITE32(ADD32(GPR_U32(ctx, 16), 632), GPR_U32(ctx, 18));
    // 0x194df0: 0xae020274
    WRITE32(ADD32(GPR_U32(ctx, 16), 628), GPR_U32(ctx, 2));
    // 0x194df4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x194df8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x194dfc: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x194e00: 0x40f809
    SET_GPR_U32(ctx, 31, 0x194e08);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_194e08
// Address: 0x194e08 - 0x194e28

void entry_194e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194e08) {
        switch (ctx->pc) {
            case 0x194e0c: ctx->pc = 0; goto label_194e0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194e08: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_194e0c:
    // 0x194e0c: 0x16420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 604)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x194E30; return;
    }
    // 0x194e14: 0x1040000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194E4C; return;
    }
    // 0x194e1c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x194e20: 0xc07a55c
    SET_GPR_U32(ctx, 31, 0x194e28);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PopUiActiveBlot__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_194e28
// Address: 0x194e28 - 0x194e48

void entry_194e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194e28) {
        switch (ctx->pc) {
            case 0x194e30: ctx->pc = 0; goto label_194e30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194e28: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x194E4C; return;
    }
label_194e30:
    // 0x194e30: 0x14400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194E4C; return;
    }
    // 0x194e38: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x194e3c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x194e40: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x194e48);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_194e48
// Address: 0x194e48 - 0x194e60

void entry_194e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194e48) {
        switch (ctx->pc) {
            case 0x194e4c: ctx->pc = 0; goto label_194e4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194e48: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_194e4c:
    // 0x194e4c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x194e50: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x194e54: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x194e58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: gui_draw_start_menuQMARK
// Address: 0x194e60 - 0x194ea0

void entry_194ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194ea0: 0x16200010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194EE4; return;
    }
    // 0x194ea8: 0x8e020274
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 628)));
    // 0x194eac: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
        ctx->pc = 0x194ED0; return;
    }
    // 0x194eb4: 0x8e050278
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 632)));
    // 0x194eb8: 0xc06564a
    SET_GPR_U32(ctx, 31, 0x194ec0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    FUN_00195928(rdram, ctx, runtime); return;
}


// Function: entry_194ec0
// Address: 0x194ec0 - 0x194ee0

void entry_194ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194ec0) {
        switch (ctx->pc) {
            case 0x194ed0: ctx->pc = 0; goto label_194ed0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194ec0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x194ec4: 0xae000274
    WRITE32(ADD32(GPR_U32(ctx, 16), 628), GPR_U32(ctx, 0));
    // 0x194ec8: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 16), 632), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_194ee0(rdram, ctx, runtime); return;
    }
label_194ed0:
    // 0x194ed0: 0x14400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194EE4; return;
    }
    // 0x194ed8: 0xc064da8
    SET_GPR_U32(ctx, 31, 0x194ee0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    render_pause_menuQMARK(rdram, ctx, runtime); return;
}


// Function: entry_194ee0
// Address: 0x194ee0 - 0x194eec

void entry_194ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194ee0) {
        switch (ctx->pc) {
            case 0x194ee4: ctx->pc = 0; goto label_194ee4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194ee0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_194ee4:
    // 0x194ee4: 0xc06aa66
    SET_GPR_U32(ctx, 31, 0x194eec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetBlotBlots__FP4BLOT5BLOTS(rdram, ctx, runtime); return;
}


// Function: entry_194eec
// Address: 0x194eec - 0x194f00

void entry_194eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194eec) {
        switch (ctx->pc) {
            case 0x194ef0: ctx->pc = 0; goto label_194ef0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194eec: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_194ef0:
    // 0x194ef0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x194ef4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x194ef8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00194f00
// Address: 0x194f00 - 0x194f2c

void FUN_00194f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194f00) {
        switch (ctx->pc) {
            case 0x194f24: ctx->pc = 0; goto label_194f24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194f00: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x194f04: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x194f08: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x194f0c: 0x8c820250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 592)));
    // 0x194f10: 0x14430004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_194f24;
    }
    // 0x194f18: 0x8c820274
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 628)));
    // 0x194f1c: 0x14400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x194F30; return;
    }
label_194f24:
    // 0x194f24: 0xc06aa3c
    SET_GPR_U32(ctx, 31, 0x194f2c);
    ShowBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_194f2c
// Address: 0x194f2c - 0x194f38

void entry_194f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194f2c) {
        switch (ctx->pc) {
            case 0x194f30: ctx->pc = 0; goto label_194f30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194f2c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_194f30:
    // 0x194f30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00194f38
// Address: 0x194f38 - 0x194f70

void FUN_00194f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x194f38) {
        switch (ctx->pc) {
            case 0x194f68: ctx->pc = 0; goto label_194f68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x194f38: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x194f3c: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x194f40: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x194f44: 0x8c820250
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 592)));
    // 0x194f48: 0x14430007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_194f68;
    }
    // 0x194f50: 0x8c820274
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 628)));
    // 0x194f54: 0x10400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_194f68;
    }
    // 0x194f5c: 0xac800274
    WRITE32(ADD32(GPR_U32(ctx, 4), 628), GPR_U32(ctx, 0));
    // 0x194f60: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 4), 632), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_194f70(rdram, ctx, runtime); return;
    }
label_194f68:
    // 0x194f68: 0xc06aa56
    SET_GPR_U32(ctx, 31, 0x194f70);
    HideBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_194f70
// Address: 0x194f70 - 0x194f80

void entry_194f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x194f70: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x194f74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x194f7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x194f80; return;
}


// Function: render_menu
// Address: 0x194f80 - 0x195058

void entry_195058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195058) {
        switch (ctx->pc) {
            case 0x1950a0: ctx->pc = 0; goto label_1950a0;
            case 0x1950a4: ctx->pc = 0; goto label_1950a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195058: 0x8e440260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    // 0x19505c: 0x24030018
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 24));
    // 0x195060: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x195064: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x195068: 0x831818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x19506c: 0x24429d50
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942032));
    // 0x195070: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x195074: 0x46140700
    ctx->f[28] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x195078: 0x14800009
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_1950a0;
    }
    // 0x195080: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x195084: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x195088: 0x8c435bec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 23532)));
    // 0x19508c: 0x14640005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 6232));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_1950a4;
    }
    // 0x195094: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x195098: 0xc4402cec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11500)); ctx->f[0] = *(float*)&val; }
    // 0x19509c: 0x46006b41
    ctx->f[13] = FPU_SUB_S(ctx->f[13], ctx->f[0]);
label_1950a0:
    // 0x1950a0: 0x26021858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 6232));
label_1950a4:
    // 0x1950a4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1950a8: 0xc44e0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[14] = *(float*)&val; }
    // 0x1950ac: 0x24840ed0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 3792));
    // 0x1950b0: 0xc64c0284
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 644)); ctx->f[12] = *(float*)&val; }
    // 0x1950b4: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1950bc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1950bc
// Address: 0x1950bc - 0x1950f4

void entry_1950bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1950bc: 0x3c01437f
    SET_GPR_U32(ctx, 1, ((uint32_t)17279 << 16));
    // 0x1950c0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1950c4: 0xe6400284
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 644), *(uint32_t*)&val); }
    // 0x1950c8: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1950cc: 0x8e430210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 528)));
    // 0x1950d0: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1950d4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1950d8: 0x106000e8
    SET_GPR_U32(ctx, 21, AND32(GPR_U32(ctx, 2), 255));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19547C; return;
    }
    // 0x1950e0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1950e4: 0x4600d306
    ctx->f[12] = FPU_MOV_S(ctx->f[26]);
    // 0x1950e8: 0x3c10ff80
    SET_GPR_U32(ctx, 16, ((uint32_t)65408 << 16));
    // 0x1950ec: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x1950f4);
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1950f4
// Address: 0x1950f4 - 0x195108

void entry_1950f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1950f4: 0x36108080
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 32896));
    // 0x1950f8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1950fc: 0x4600cb06
    ctx->f[12] = FPU_MOV_S(ctx->f[25]);
    // 0x195100: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x195108);
    ctx->f[13] = FPU_MOV_S(ctx->f[24]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_195108
// Address: 0x195108 - 0x195118

void entry_195108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195108: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19510c: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x195110: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x195118);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_195118
// Address: 0x195118 - 0x195124

void entry_195118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195118: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19511c: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x195124);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_195124
// Address: 0x195124 - 0x195130

void entry_195124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195124: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x195128: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x195130);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_195130
// Address: 0x195130 - 0x195468

void entry_195130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195130) {
        switch (ctx->pc) {
            case 0x1951c0: ctx->pc = 0; goto label_1951c0;
            case 0x195204: ctx->pc = 0; goto label_195204;
            case 0x195244: ctx->pc = 0; goto label_195244;
            case 0x19525c: ctx->pc = 0; goto label_19525c;
            case 0x1952a0: ctx->pc = 0; goto label_1952a0;
            case 0x1952e0: ctx->pc = 0; goto label_1952e0;
            case 0x1952f8: ctx->pc = 0; goto label_1952f8;
            case 0x19533c: ctx->pc = 0; goto label_19533c;
            case 0x19537c: ctx->pc = 0; goto label_19537c;
            case 0x195394: ctx->pc = 0; goto label_195394;
            case 0x1953d8: ctx->pc = 0; goto label_1953d8;
            case 0x195418: ctx->pc = 0; goto label_195418;
            case 0x195440: ctx->pc = 0; goto label_195440;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195130: 0x8e430210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 528)));
    // 0x195134: 0x8862001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 27); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x195138: 0x98620018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x19513c: 0xaba20023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195140: 0xbba20020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195144: 0x8ba70023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | ((word >> shift) & mask)); }
    // 0x195148: 0x9ba70020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | (word << shift)); }
    // 0x19514c: 0xaba70033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195150: 0xbba70030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195154: 0xa3b50033
    WRITE8(ADD32(GPR_U32(ctx, 29), 51), (uint8_t)GPR_U32(ctx, 21));
    // 0x195158: 0x8ba60033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x19515c: 0x9ba60030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x195160: 0xa866001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 27); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195164: 0xb8660018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195168: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x19516c: 0x144000b4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 528)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_195440;
    }
    // 0x195174: 0x2402006f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 111));
    // 0x195178: 0xa3a20032
    WRITE8(ADD32(GPR_U32(ctx, 29), 50), (uint8_t)GPR_U32(ctx, 2));
    // 0x19517c: 0xa3a20030
    WRITE8(ADD32(GPR_U32(ctx, 29), 48), (uint8_t)GPR_U32(ctx, 2));
    // 0x195180: 0xa3a20031
    WRITE8(ADD32(GPR_U32(ctx, 29), 49), (uint8_t)GPR_U32(ctx, 2));
    // 0x195184: 0xa3b50033
    WRITE8(ADD32(GPR_U32(ctx, 29), 51), (uint8_t)GPR_U32(ctx, 21));
    // 0x195188: 0x88a6001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 27); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x19518c: 0x98a60018
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 24); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x195190: 0xaba60053
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 83); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195194: 0xbba60050
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 80); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195198: 0x8ba40033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x19519c: 0x9ba40030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x1951a0: 0xaba40063
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 99); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1951a4: 0xbba40060
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 96); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1951a8: 0x93a40050
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1951ac: 0x93a30060
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1951b0: 0x14830003
    ctx->f[4] = FPU_MUL_S(ctx->f[28], ctx->f[28]);
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1951c0;
    }
    // 0x1951b8: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_195244;
    }
label_1951c0:
    // 0x1951c0: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1951c4: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_195204;
    }
    // 0x1951cc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1951d0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1951d4: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1951d8: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1951dc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1951e0: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1951e4: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1951e8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1951ec: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1951f0: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1951f4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1951f8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1951fc: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_195244;
    }
label_195204:
    // 0x195204: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x195208: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x19520c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x195210: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x195214: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x195218: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x19521c: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x195220: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x195224: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x195228: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x19522c: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x195230: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x195234: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x195238: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x19523c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x195240: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_195244:
    // 0x195244: 0x93a40051
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 81)));
    // 0x195248: 0x93a30061
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 97)));
    // 0x19524c: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 112), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_19525c;
    }
    // 0x195254: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1952e0;
    }
label_19525c:
    // 0x19525c: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x195260: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1952a0;
    }
    // 0x195268: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x19526c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x195270: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x195274: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x195278: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19527c: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x195280: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x195284: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x195288: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x19528c: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x195290: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x195294: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x195298: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1952e0;
    }
label_1952a0:
    // 0x1952a0: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1952a4: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1952a8: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1952ac: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1952b0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1952b4: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1952b8: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1952bc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1952c0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1952c4: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1952c8: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x1952cc: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x1952d0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1952d4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1952d8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1952dc: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_1952e0:
    // 0x1952e0: 0x93a40052
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 82)));
    // 0x1952e4: 0x93a30062
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 98)));
    // 0x1952e8: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 113), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_1952f8;
    }
    // 0x1952f0: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19537c;
    }
label_1952f8:
    // 0x1952f8: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x1952fc: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19533c;
    }
    // 0x195304: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x195308: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x19530c: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x195310: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x195314: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x195318: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x19531c: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x195320: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x195324: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x195328: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x19532c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x195330: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x195334: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19537c;
    }
label_19533c:
    // 0x19533c: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x195340: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x195344: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x195348: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x19534c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x195350: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x195354: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x195358: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19535c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x195360: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x195364: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x195368: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x19536c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x195370: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x195374: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x195378: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_19537c:
    // 0x19537c: 0x93a40053
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 83)));
    // 0x195380: 0x93a30063
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 99)));
    // 0x195384: 0x14830003
    WRITE8(ADD32(GPR_U32(ctx, 29), 114), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_195394;
    }
    // 0x19538c: 0x10000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_195418;
    }
label_195394:
    // 0x195394: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x195398: 0x1040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1953d8;
    }
    // 0x1953a0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1953a4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1953a8: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1953ac: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1953b0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1953b4: 0x44841000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 4);
    // 0x1953b8: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x1953bc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1953c0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1953c4: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x1953c8: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1953cc: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1953d0: 0x10000011
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_195418;
    }
label_1953d8:
    // 0x1953d8: 0x44840800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 4);
    // 0x1953dc: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1953e0: 0x3c013f7f
    SET_GPR_U32(ctx, 1, ((uint32_t)16255 << 16));
    // 0x1953e4: 0x3421be77
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 48759));
    // 0x1953e8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1953ec: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x1953f0: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x1953f4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1953f8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1953fc: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x195400: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x195404: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x195408: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x19540c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x195410: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x195414: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_195418:
    // 0x195418: 0xa3a20073
    WRITE8(ADD32(GPR_U32(ctx, 29), 115), (uint8_t)GPR_U32(ctx, 2));
    // 0x19541c: 0x8ba20073
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 115); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x195420: 0x9ba20070
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 112); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x195424: 0xaba20043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195428: 0xbba20040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x19542c: 0x8ba70043
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 67); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | ((word >> shift) & mask)); }
    // 0x195430: 0x9ba70040
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 64); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 7, (GPR_U32(ctx,7) & ~mask) | (word << shift)); }
    // 0x195434: 0xa8a7001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 27); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195438: 0xb8a70018
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 24); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 7) & mask); WRITE32(aligned_addr, new_data); }
    // 0x19543c: 0x8e450210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 528)));
label_195440:
    // 0x195440: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x195444: 0x8ca80000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x195448: 0x11000007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 8832));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_195468(rdram, ctx, runtime); return;
    }
    // 0x195450: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x195454: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x195458: 0x84440048
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x19545c: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x195460: 0x60f809
    SET_GPR_U32(ctx, 31, 0x195468);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_195468
// Address: 0x195468 - 0x19549c

void entry_195468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195468) {
        switch (ctx->pc) {
            case 0x19547c: ctx->pc = 0; goto label_19547c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195468: 0x8e420210
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 528)));
    // 0x19546c: 0x8ba50023
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 35); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | ((word >> shift) & mask)); }
    // 0x195470: 0x9ba50020
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 32); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 5, (GPR_U32(ctx,5) & ~mask) | (word << shift)); }
    // 0x195474: 0xa845001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 27); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195478: 0xb8450018
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 24); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 5) & mask); WRITE32(aligned_addr, new_data); }
label_19547c:
    // 0x19547c: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x195480: 0x10400031
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 572)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195548; return;
    }
    // 0x195488: 0xc68c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 4)); ctx->f[12] = *(float*)&val; }
    // 0x19548c: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x195490: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x195494: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x19549c);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_19549c
// Address: 0x19549c - 0x1954b0

void entry_19549c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19549c: 0x27b10080
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1954a0: 0x8e460004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1954a4: 0x8e850000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1954a8: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1954b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1954b0
// Address: 0x1954b0 - 0x1954d8

void entry_1954b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1954b0: 0x2403007f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 127));
    // 0x1954b4: 0xa3b50023
    WRITE8(ADD32(GPR_U32(ctx, 29), 35), (uint8_t)GPR_U32(ctx, 21));
    // 0x1954b8: 0xa3a30022
    WRITE8(ADD32(GPR_U32(ctx, 29), 34), (uint8_t)GPR_U32(ctx, 3));
    // 0x1954bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1954c0: 0xa3a30020
    WRITE8(ADD32(GPR_U32(ctx, 29), 32), (uint8_t)GPR_U32(ctx, 3));
    // 0x1954c4: 0x4600b346
    ctx->f[13] = FPU_MOV_S(ctx->f[22]);
    // 0x1954c8: 0xa3a30021
    WRITE8(ADD32(GPR_U32(ctx, 29), 33), (uint8_t)GPR_U32(ctx, 3));
    // 0x1954cc: 0x4600d306
    ctx->f[12] = FPU_MOV_S(ctx->f[26]);
    // 0x1954d0: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x1954d8);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1954d8
// Address: 0x1954d8 - 0x1954e8

void entry_1954d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1954d8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1954dc: 0x4600c346
    ctx->f[13] = FPU_MOV_S(ctx->f[24]);
    // 0x1954e0: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x1954e8);
    ctx->f[12] = FPU_MOV_S(ctx->f[25]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_1954e8
// Address: 0x1954e8 - 0x1954f8

void entry_1954e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1954e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1954ec: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1954f0: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x1954f8);
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_1954f8
// Address: 0x1954f8 - 0x195504

void entry_1954f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1954f8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1954fc: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x195504);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_195504
// Address: 0x195504 - 0x195510

void entry_195504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195504: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x195508: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x195510);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_195510
// Address: 0x195510 - 0x195528

void entry_195510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195510: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x195514: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195518: 0x24e72280
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 8832));
    // 0x19551c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x195520: 0xc0578c6
    SET_GPR_U32(ctx, 31, 0x195528);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Draw__9CRichTextP8CTextBoxT1P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_195528
// Address: 0x195528 - 0x195538

void entry_195528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195528: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x19552c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x195530: 0xc05786c
    SET_GPR_U32(ctx, 31, 0x195538);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_0015e1b0(rdram, ctx, runtime); return;
}


// Function: entry_195538
// Address: 0x195538 - 0x195544

void entry_195538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195538: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x19553c: 0xc057240
    SET_GPR_U32(ctx, 31, 0x195544);
    ctx->f[22] = FPU_ADD_S(ctx->f[22], ctx->f[0]);
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_195544
// Address: 0x195544 - 0x195568

void entry_195544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195544) {
        switch (ctx->pc) {
            case 0x195548: ctx->pc = 0; goto label_195548;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195544: 0xc640023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 572)); ctx->f[0] = *(float*)&val; }
label_195548:
    // 0x195548: 0xc68c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 8)); ctx->f[12] = *(float*)&val; }
    // 0x19554c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x195550: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x195554: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x195558: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x19555c: 0x4601b780
    ctx->f[30] = FPU_ADD_S(ctx->f[22], ctx->f[1]);
    // 0x195560: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x195568);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_195568
// Address: 0x195568 - 0x1955d4

void entry_195568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195568) {
        switch (ctx->pc) {
            case 0x195598: ctx->pc = 0; goto label_195598;
            case 0x1955c0: ctx->pc = 0; goto label_1955c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195568: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x19556c: 0x8e83000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x195570: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x195574: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x195578: 0xc4400048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[0] = *(float*)&val; }
    // 0x19557c: 0x14600024
    ctx->f[29] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x195610; return;
    }
    // 0x195584: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x195588: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x19558c: 0x1840001b
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1955FC; return;
    }
    // 0x195594: 0x0
    // NOP
label_195598:
    // 0x195598: 0x52000009
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20)));
        goto label_1955c0;
    }
    // 0x1955a0: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1955a4: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1955a8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1955ac: 0xc4410044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 68)); ctx->f[1] = *(float*)&val; }
    // 0x1955b0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1955b4: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x1955b8: 0x4600a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    // 0x1955bc: 0x8e820014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20)));
label_1955c0:
    // 0x1955c0: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1955c4: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1955c8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1955cc: 0xc064d66
    SET_GPR_U32(ctx, 31, 0x1955d4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    AchzFromRespk(rdram, ctx, runtime); return;
}


// Function: entry_1955d4
// Address: 0x1955d4 - 0x1955e4

void entry_1955d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1955d4: 0x8e460004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1955d8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1955dc: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1955e4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1955e4
// Address: 0x1955e4 - 0x1955ec

void entry_1955e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1955e4: 0xc0577fe
    SET_GPR_U32(ctx, 31, 0x1955ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Dx__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_1955ec
// Address: 0x1955ec - 0x1956d4

void entry_1955ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1955ec) {
        switch (ctx->pc) {
            case 0x1955fc: ctx->pc = 0; goto label_1955fc;
            case 0x195610: ctx->pc = 0; goto label_195610;
            case 0x195640: ctx->pc = 0; goto label_195640;
            case 0x19569c: ctx->pc = 0; goto label_19569c;
            case 0x1956c0: ctx->pc = 0; goto label_1956c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1955ec: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x1955f0: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1955f4: 0x1440ffe8
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x195598; return;
    }
label_1955fc:
    // 0x1955fc: 0x4614c801
    ctx->f[0] = FPU_SUB_S(ctx->f[25], ctx->f[20]);
    // 0x195600: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x195604: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x195608: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x19560c: 0x4600d5c0
    ctx->f[23] = FPU_ADD_S(ctx->f[26], ctx->f[0]);
label_195610:
    // 0x195610: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x195614: 0x18400082
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x195820; return;
    }
    // 0x19561c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x195620: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x195624: 0x2417006f
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 111));
    // 0x195628: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x19562c: 0x4481c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 1);
    // 0x195630: 0x2416005f
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 95));
    // 0x195634: 0x3c1e0026
    SET_GPR_U32(ctx, 30, ((uint32_t)38 << 16));
    // 0x195638: 0x8e420264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 612)));
    // 0x19563c: 0x0
    // NOP
label_195640:
    // 0x195640: 0x56620016
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        WRITE8(ADD32(GPR_U32(ctx, 29), 16), (uint8_t)GPR_U32(ctx, 22));
        goto label_19569c;
    }
    // 0x195648: 0x3c014280
    SET_GPR_U32(ctx, 1, ((uint32_t)17024 << 16));
    // 0x19564c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x195650: 0x461cd841
    ctx->f[1] = FPU_SUB_S(ctx->f[27], ctx->f[28]);
    // 0x195654: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x195658: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x19565c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x195660: 0x4600e002
    ctx->f[0] = FPU_MUL_S(ctx->f[28], ctx->f[0]);
    // 0x195664: 0xa3b70010
    WRITE8(ADD32(GPR_U32(ctx, 29), 16), (uint8_t)GPR_U32(ctx, 23));
    // 0x195668: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x19566c: 0xa3b70011
    WRITE8(ADD32(GPR_U32(ctx, 29), 17), (uint8_t)GPR_U32(ctx, 23));
    // 0x195670: 0xa3b50013
    WRITE8(ADD32(GPR_U32(ctx, 29), 19), (uint8_t)GPR_U32(ctx, 21));
    // 0x195674: 0x460000a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[0]);
    // 0x195678: 0x44021000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[2]);
    // 0x19567c: 0x2442002f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 47));
    // 0x195680: 0xa3a20012
    WRITE8(ADD32(GPR_U32(ctx, 29), 18), (uint8_t)GPR_U32(ctx, 2));
    // 0x195684: 0x8ba20013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x195688: 0x9ba20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x19568c: 0xaba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195690: 0xbba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195694: 0x1000000a
    ctx->f[20] = FPU_ADD_S(ctx->f[1], ctx->f[27]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1956c0;
    }
label_19569c:
    // 0x19569c: 0xa3b60011
    WRITE8(ADD32(GPR_U32(ctx, 29), 17), (uint8_t)GPR_U32(ctx, 22));
    // 0x1956a0: 0xa3b60012
    WRITE8(ADD32(GPR_U32(ctx, 29), 18), (uint8_t)GPR_U32(ctx, 22));
    // 0x1956a4: 0xa3b50013
    WRITE8(ADD32(GPR_U32(ctx, 29), 19), (uint8_t)GPR_U32(ctx, 21));
    // 0x1956a8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1956ac: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1956b0: 0x8ba60013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | ((word >> shift) & mask)); }
    // 0x1956b4: 0x9ba60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 6, (GPR_U32(ctx,6) & ~mask) | (word << shift)); }
    // 0x1956b8: 0xaba60003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1956bc: 0xbba60000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 6) & mask); WRITE32(aligned_addr, new_data); }
label_1956c0:
    // 0x1956c0: 0x8e820014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x1956c4: 0x131880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 2));
    // 0x1956c8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1956cc: 0xc064d66
    SET_GPR_U32(ctx, 31, 0x1956d4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    AchzFromRespk(rdram, ctx, runtime); return;
}


// Function: entry_1956d4
// Address: 0x1956d4 - 0x1956ec

void entry_1956d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1956d4: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1956d8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1956dc: 0x8e460004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1956e0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1956e4: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x1956ec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1956ec
// Address: 0x1956ec - 0x1956f4

void entry_1956ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1956ec: 0xc0577fe
    SET_GPR_U32(ctx, 31, 0x1956f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Dx__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_1956f4
// Address: 0x1956f4 - 0x195728

void entry_1956f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1956f4) {
        switch (ctx->pc) {
            case 0x19570c: ctx->pc = 0; goto label_19570c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1956f4: 0x8e82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x1956f8: 0x10400004
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19570c;
    }
    // 0x195700: 0x4615c801
    ctx->f[0] = FPU_SUB_S(ctx->f[25], ctx->f[21]);
    // 0x195704: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x195708: 0x4600d5c0
    ctx->f[23] = FPU_ADD_S(ctx->f[26], ctx->f[0]);
label_19570c:
    // 0x19570c: 0xc640023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 572)); ctx->f[0] = *(float*)&val; }
    // 0x195710: 0xc68c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 8)); ctx->f[12] = *(float*)&val; }
    // 0x195714: 0x8e440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x195718: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x19571c: 0x46146302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    // 0x195720: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x195728);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_195728
// Address: 0x195728 - 0x195738

void entry_195728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195728: 0x8e460004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x19572c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x195730: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x195738);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_195738
// Address: 0x195738 - 0x195740

void entry_195738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195738: 0xc0577fe
    SET_GPR_U32(ctx, 31, 0x195740);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Dx__9CRichText(rdram, ctx, runtime); return;
}


// Function: entry_195740
// Address: 0x195740 - 0x195778

void entry_195740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195740: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x195744: 0x4600a801
    ctx->f[0] = FPU_SUB_S(ctx->f[21], ctx->f[0]);
    // 0x195748: 0x8fb00000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19574c: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x195750: 0xc4540008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[20] = *(float*)&val; }
    // 0x195754: 0x4680a520
    ctx->f[20] = FPU_CVT_S_W(*(int32_t*)&ctx->f[20]);
    // 0x195758: 0xc4410048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[1] = *(float*)&val; }
    // 0x19575c: 0x46180002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[24]);
    // 0x195760: 0x4601a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x195764: 0x4600bb00
    ctx->f[12] = FPU_ADD_S(ctx->f[23], ctx->f[0]);
    // 0x195768: 0x4614eb41
    ctx->f[13] = FPU_SUB_S(ctx->f[29], ctx->f[20]);
    // 0x19576c: 0x46186b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[24]);
    // 0x195770: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x195778);
    ctx->f[13] = FPU_ADD_S(ctx->f[22], ctx->f[13]);
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_195778
// Address: 0x195778 - 0x195788

void entry_195778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195778: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x19577c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x195780: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x195788);
    ctx->f[12] = FPU_MOV_S(ctx->f[25]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_195788
// Address: 0x195788 - 0x195798

void entry_195788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195788: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x19578c: 0x27a500e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 224));
    // 0x195790: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x195798);
    WRITE32(ADD32(GPR_U32(ctx, 29), 224), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_195798
// Address: 0x195798 - 0x1957a4

void entry_195798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195798: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x19579c: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x1957a4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_1957a4
// Address: 0x1957a4 - 0x1957b0

void entry_1957a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1957a4: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1957a8: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x1957b0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_1957b0
// Address: 0x1957b0 - 0x1957c4

void entry_1957b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1957b0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1957b4: 0x27a500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 192));
    // 0x1957b8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1957bc: 0xc0578c6
    SET_GPR_U32(ctx, 31, 0x1957c4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 30), 8832));
    Draw__9CRichTextP8CTextBoxT1P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1957c4
// Address: 0x1957c4 - 0x1957cc

void entry_1957c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1957c4: 0xc057240
    SET_GPR_U32(ctx, 31, 0x1957cc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_1957cc
// Address: 0x1957cc - 0x195828

void entry_1957cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1957cc) {
        switch (ctx->pc) {
            case 0x1957f0: ctx->pc = 0; goto label_1957f0;
            case 0x19580c: ctx->pc = 0; goto label_19580c;
            case 0x195820: ctx->pc = 0; goto label_195820;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1957cc: 0x8e82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x1957d0: 0x10400007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1957f0;
    }
    // 0x1957d8: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1957dc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1957e0: 0xc4410048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[1] = *(float*)&val; }
    // 0x1957e4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1957e8: 0x10000008
    ctx->f[22] = FPU_ADD_S(ctx->f[22], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19580c;
    }
label_1957f0:
    // 0x1957f0: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1957f4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1957f8: 0xc4410044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 68)); ctx->f[1] = *(float*)&val; }
    // 0x1957fc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x195800: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x195804: 0x4600a800
    ctx->f[0] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    // 0x195808: 0x4600bdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[0]);
label_19580c:
    // 0x19580c: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x195810: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x195814: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x195818: 0x5440ff89
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 612)));
        ctx->pc = 0x195640; return;
    }
label_195820:
    // 0x195820: 0xc057240
    SET_GPR_U32(ctx, 31, 0x195828);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_195828
// Address: 0x195828 - 0x1958cc

void entry_195828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195828: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x19582c: 0x10400028
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1958D0; return;
    }
    // 0x195834: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x195838: 0x10400025
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1958D0; return;
    }
    // 0x195840: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x195844: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x195848: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19584c: 0x4619d080
    ctx->f[2] = FPU_ADD_S(ctx->f[26], ctx->f[25]);
    // 0x195850: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x195854: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x195858: 0x4600f002
    ctx->f[0] = FPU_MUL_S(ctx->f[30], ctx->f[0]);
    // 0x19585c: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x195860: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x195864: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x195868: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x19586c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x195870: 0x4601d040
    ctx->f[1] = FPU_ADD_S(ctx->f[26], ctx->f[1]);
    // 0x195874: 0x2443a228
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294943272));
    // 0x195878: 0x88640003
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | ((word >> shift) & mask)); }
    // 0x19587c: 0x98640000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 4, (GPR_U32(ctx,4) & ~mask) | (word << shift)); }
    // 0x195880: 0xaba40003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195884: 0xbba40000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 4) & mask); WRITE32(aligned_addr, new_data); }
    // 0x195888: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x19588c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195890: 0x46031082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x195894: 0xa3b50003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 21));
    // 0x195898: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x19589c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1958a0: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1958a4: 0x3a0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1958a8: 0x460010e4
    *(int32_t*)&ctx->f[3] = FPU_CVT_W_S(ctx->f[2]);
    // 0x1958ac: 0x44071800
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[3]);
    // 0x1958b0: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1958b4: 0x460000a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1958b8: 0x44051000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[2]);
    // 0x1958bc: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x1958c0: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x1958c4: 0xc06b8ee
    SET_GPR_U32(ctx, 31, 0x1958cc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    DrawLineScreen__FUiUiUiUiUiUiG4RGBAi(rdram, ctx, runtime); return;
}


// Function: entry_1958cc
// Address: 0x1958cc - 0x195928

void entry_1958cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1958cc) {
        switch (ctx->pc) {
            case 0x1958d0: ctx->pc = 0; goto label_1958d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1958cc: 0x7bbf01c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 448)));
label_1958d0:
    // 0x1958d0: 0x7bbe01b0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1958d4: 0x7bb701a0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1958d8: 0x7bb60190
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1958dc: 0x7bb50180
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1958e0: 0x7bb40170
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1958e4: 0x7bb30160
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1958e8: 0x7bb20150
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1958ec: 0x7bb10140
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1958f0: 0x7bb00130
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1958f4: 0xc7be0220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 544)); ctx->f[30] = *(float*)&val; }
    // 0x1958f8: 0xc7bd0218
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 536)); ctx->f[29] = *(float*)&val; }
    // 0x1958fc: 0xc7bc0210
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 528)); ctx->f[28] = *(float*)&val; }
    // 0x195900: 0xc7bb0208
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 520)); ctx->f[27] = *(float*)&val; }
    // 0x195904: 0xc7ba0200
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 512)); ctx->f[26] = *(float*)&val; }
    // 0x195908: 0xc7b901f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 504)); ctx->f[25] = *(float*)&val; }
    // 0x19590c: 0xc7b801f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 496)); ctx->f[24] = *(float*)&val; }
    // 0x195910: 0xc7b701e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 488)); ctx->f[23] = *(float*)&val; }
    // 0x195914: 0xc7b601e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 480)); ctx->f[22] = *(float*)&val; }
    // 0x195918: 0xc7b501d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 472)); ctx->f[21] = *(float*)&val; }
    // 0x19591c: 0xc7b401d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 464)); ctx->f[20] = *(float*)&val; }
    // 0x195920: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 560));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00195928
// Address: 0x195928 - 0x19594c

void FUN_00195928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195928: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x19592c: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x195930: 0x8c820260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 608)));
    // 0x195934: 0x10450005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        entry_19594c(rdram, ctx, runtime); return;
    }
    // 0x19593c: 0x10a20003
    WRITE32(ADD32(GPR_U32(ctx, 4), 608), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        entry_19594c(rdram, ctx, runtime); return;
    }
    // 0x195944: 0xc064da8
    SET_GPR_U32(ctx, 31, 0x19594c);
    render_pause_menuQMARK(rdram, ctx, runtime); return;
}


// Function: entry_19594c
// Address: 0x19594c - 0x195958

void entry_19594c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19594c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x195950: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00195958
// Address: 0x195958 - 0x1959b8

void FUN_00195958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195958) {
        switch (ctx->pc) {
            case 0x1959a4: ctx->pc = 0; goto label_1959a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195958: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x19595c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x195960: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x195964: 0x24429d50
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294942032));
    // 0x195968: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x19596c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x195970: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x195974: 0x24040018
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 24));
    // 0x195978: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x19597c: 0x8e230260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    // 0x195980: 0x641818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x195984: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x195988: 0x8c430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x19598c: 0x10600005
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1959a4;
    }
    // 0x195994: 0x8e220264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 612)));
    // 0x195998: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x19599c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1959a0: 0x8c500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_1959a4:
    // 0x1959a4: 0x24020011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 17));
    // 0x1959a8: 0x56020005
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 608)));
        ctx->pc = 0x1959C0; return;
    }
    // 0x1959b0: 0xc065870
    SET_GPR_U32(ctx, 31, 0x1959b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001961c0(rdram, ctx, runtime); return;
}


// Function: entry_1959b8
// Address: 0x1959b8 - 0x195a38

void entry_1959b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1959b8) {
        switch (ctx->pc) {
            case 0x1959c0: ctx->pc = 0; goto label_1959c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1959b8: 0x100001fc
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
label_1959c0:
    // 0x1959c0: 0x2c620021
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 33));
    // 0x1959c4: 0x104001f8
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1961a8(rdram, ctx, runtime); return;
    }
    // 0x1959cc: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1959d0: 0x2442c6a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294952608));
    // 0x1959d4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1959d8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1959dc: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1959e4: 0x2603fffd
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4294967293));
    // 0x1959e8: 0x2c620015
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 21));
    // 0x1959ec: 0x104001ee
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1961a8(rdram, ctx, runtime); return;
    }
    // 0x1959f4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1959f8: 0x2442c730
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294952752));
    // 0x1959fc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x195a00: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x195a04: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x195a0c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195a10: 0x100001ba
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1960FC; return;
    }
    // 0x195a18: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x195a1c: 0x2450f808
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 4294965256));
    // 0x195a20: 0x8e030260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x195a24: 0x1060000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195A50; return;
    }
    // 0x195a2c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195a30: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195a38);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195a38
// Address: 0x195a38 - 0x195a48

void entry_195a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195a38: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x195a3c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x195a40: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x195a48);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_195a48
// Address: 0x195a48 - 0x195a88

void entry_195a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195a48) {
        switch (ctx->pc) {
            case 0x195a50: ctx->pc = 0; goto label_195a50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195a48: 0x100001d8
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
label_195a50:
    // 0x195a50: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x195a54: 0x2404007b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 123));
    // 0x195a58: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x195a5c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x195a60: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x195a64: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195a68: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x195a6c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x195a70: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x195a74: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x195a78: 0x10000146
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195F94; return;
    }
    // 0x195a80: 0xc064d98
    SET_GPR_U32(ctx, 31, 0x195a88);
    FUN_00193660(rdram, ctx, runtime); return;
}


// Function: entry_195a88
// Address: 0x195a88 - 0x195a90

void entry_195a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195a88: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x195a90);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_195a90
// Address: 0x195a90 - 0x195aa8

void entry_195a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195a90: 0x12400014
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_195ae4(rdram, ctx, runtime); return;
    }
    // 0x195a98: 0x12000012
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_195ae4(rdram, ctx, runtime); return;
    }
    // 0x195aa0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x195aa8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 25));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_195aa8
// Address: 0x195aa8 - 0x195ab8

void entry_195aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195aa8: 0x1040000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_195ae4(rdram, ctx, runtime); return;
    }
    // 0x195ab0: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x195ab8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_195ab8
// Address: 0x195ab8 - 0x195ad8

void entry_195ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195ab8: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x195abc: 0x28620431
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1073));
    // 0x195ac0: 0x10400008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1071));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_195ae4(rdram, ctx, runtime); return;
    }
    // 0x195ac8: 0x14400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x195AE8; return;
    }
    // 0x195ad0: 0xc0764ce
    SET_GPR_U32(ctx, 31, 0x195ad8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001d9338(rdram, ctx, runtime); return;
}


// Function: entry_195ad8
// Address: 0x195ad8 - 0x195ae4

void entry_195ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195ad8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x195adc: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x195ae4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1070));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_195ae4
// Address: 0x195ae4 - 0x195b0c

void entry_195ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195ae4) {
        switch (ctx->pc) {
            case 0x195ae8: ctx->pc = 0; goto label_195ae8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195ae4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_195ae8:
    // 0x195ae8: 0x10000184
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1960FC; return;
    }
    // 0x195af0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195af4: 0x10000079
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195CDC; return;
    }
    // 0x195afc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195b00: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195b04: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195b0c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195b0c
// Address: 0x195b0c - 0x195b18

void entry_195b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195b0c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x195b10: 0xc07d102
    SET_GPR_U32(ctx, 31, 0x195b18);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    TriggerDefaultExit__Fi5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_195b18
// Address: 0x195b18 - 0x195b30

void entry_195b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195b18: 0x100001a4
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195b20: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195b24: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195b28: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195b30);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195b30
// Address: 0x195b30 - 0x195b44

void entry_195b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195b30: 0x3c040024
    SET_GPR_U32(ctx, 4, ((uint32_t)36 << 16));
    // 0x195b34: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x195b38: 0x24847ad0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 31440));
    // 0x195b3c: 0xc07c10a
    SET_GPR_U32(ctx, 31, 0x195b44);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    WipeToWorldWarp(rdram, ctx, runtime); return;
}


// Function: entry_195b44
// Address: 0x195b44 - 0x195b5c

void entry_195b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195b44: 0x10000199
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195b4c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195b50: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195b54: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195b5c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195b5c
// Address: 0x195b5c - 0x195b9c

void entry_195b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195b5c: 0x10000193
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195b64: 0x2603fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4294967290));
    // 0x195b68: 0x2c620012
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 18));
    // 0x195b6c: 0x1040018e
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1961a8(rdram, ctx, runtime); return;
    }
    // 0x195b74: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x195b78: 0x2442c790
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294952848));
    // 0x195b7c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x195b80: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x195b84: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x195b8c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x195b90: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x195b94: 0xc06305e
    SET_GPR_U32(ctx, 31, 0x195b9c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c178_FP4SAVEi(rdram, ctx, runtime); return;
}


// Function: entry_195b9c
// Address: 0x195b9c - 0x195bac

void entry_195b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195b9c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195ba0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195ba4: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195bac);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195bac
// Address: 0x195bac - 0x195bc4

void entry_195bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195bac: 0x1000017f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195bb4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x195bb8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x195bbc: 0xc06305e
    SET_GPR_U32(ctx, 31, 0x195bc4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c178_FP4SAVEi(rdram, ctx, runtime); return;
}


// Function: entry_195bc4
// Address: 0x195bc4 - 0x195bd4

void entry_195bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195bc4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195bc8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195bcc: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195bd4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 17));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195bd4
// Address: 0x195bd4 - 0x195bec

void entry_195bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195bd4: 0x10000175
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195bdc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x195be0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x195be4: 0xc06305e
    SET_GPR_U32(ctx, 31, 0x195bec);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c178_FP4SAVEi(rdram, ctx, runtime); return;
}


// Function: entry_195bec
// Address: 0x195bec - 0x195bfc

void entry_195bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195bec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195bf0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195bf4: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195bfc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 11));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195bfc
// Address: 0x195bfc - 0x195c10

void entry_195bfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195bfc: 0x1000016b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195c04: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x195c08: 0xc069fd4
    SET_GPR_U32(ctx, 31, 0x195c10);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    FUN_001A7F50(rdram, ctx, runtime); return;
}


// Function: entry_195c10
// Address: 0x195c10 - 0x195c38

void entry_195c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195c10: 0x8e300264
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 612)));
    // 0x195c14: 0x10000083
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195E24; return;
    }
    // 0x195c1c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x195c20: 0x8c6523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x195c24: 0x8ca219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6636)));
    // 0x195c28: 0x38420080
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 128));
    // 0x195c2c: 0x30440080
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 2), 128));
    // 0x195c30: 0xc0701d8
    SET_GPR_U32(ctx, 31, 0x195c38);
    WRITE32(ADD32(GPR_U32(ctx, 5), 6636), GPR_U32(ctx, 2));
    MvgkUnknown3(rdram, ctx, runtime); return;
}


// Function: entry_195c38
// Address: 0x195c38 - 0x195c60

void entry_195c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195c38: 0x8e300264
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 612)));
    // 0x195c3c: 0x10000079
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195E24; return;
    }
    // 0x195c44: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x195c48: 0x8c6523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x195c4c: 0x8ca219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6636)));
    // 0x195c50: 0x38420040
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 64));
    // 0x195c54: 0x30440040
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 2), 64));
    // 0x195c58: 0xc0701e4
    SET_GPR_U32(ctx, 31, 0x195c60);
    WRITE32(ADD32(GPR_U32(ctx, 5), 6636), GPR_U32(ctx, 2));
    MvgkUnknown4(rdram, ctx, runtime); return;
}


// Function: entry_195c60
// Address: 0x195c60 - 0x195c7c

void entry_195c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195c60: 0x8e300264
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 612)));
    // 0x195c64: 0x1000006f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195E24; return;
    }
    // 0x195c6c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195c70: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195c74: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195c7c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195c7c
// Address: 0x195c7c - 0x195c94

void entry_195c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195c7c: 0x1000014b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195c84: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195c88: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195c8c: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195c94);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195c94
// Address: 0x195c94 - 0x195ca4

void entry_195c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195c94: 0x10000145
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195c9c: 0xc0580a8
    SET_GPR_U32(ctx, 31, 0x195ca4);
    get_game_completion__Fv(rdram, ctx, runtime); return;
}


// Function: entry_195ca4
// Address: 0x195ca4 - 0x195cb8

void entry_195ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195ca4: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x195ca8: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195CC0; return;
    }
    // 0x195cb0: 0xc05815e
    SET_GPR_U32(ctx, 31, 0x195cb8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    PlayEndingFromCompletionFlags(rdram, ctx, runtime); return;
}


// Function: entry_195cb8
// Address: 0x195cb8 - 0x195ccc

void entry_195cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195cb8) {
        switch (ctx->pc) {
            case 0x195cc0: ctx->pc = 0; goto label_195cc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195cb8: 0x1000013c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
label_195cc0:
    // 0x195cc0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195cc4: 0xc06509e
    SET_GPR_U32(ctx, 31, 0x195ccc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    FUN_00194278(rdram, ctx, runtime); return;
}


// Function: entry_195ccc
// Address: 0x195ccc - 0x195ce4

void entry_195ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195ccc) {
        switch (ctx->pc) {
            case 0x195cdc: ctx->pc = 0; goto label_195cdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195ccc: 0x10000137
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195cd4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195cd8: 0x2e050001
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 16), 1));
label_195cdc:
    // 0x195cdc: 0xc06509e
    SET_GPR_U32(ctx, 31, 0x195ce4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    FUN_00194278(rdram, ctx, runtime); return;
}


// Function: entry_195ce4
// Address: 0x195ce4 - 0x195d04

void entry_195ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195ce4: 0x10000131
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195cec: 0x8e240280
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 640)));
    // 0x195cf0: 0x24020435
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1077));
    // 0x195cf4: 0xae200280
    WRITE32(ADD32(GPR_U32(ctx, 17), 640), GPR_U32(ctx, 0));
    // 0x195cf8: 0x24050434
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1076));
    // 0x195cfc: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x195d04);
    if (GPR_U32(ctx, 16) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 2));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_195d04
// Address: 0x195d04 - 0x195d54

void entry_195d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195d04: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195d08: 0x100000fc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1960FC; return;
    }
    // 0x195d10: 0x16000022
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x195D9C; return;
    }
    // 0x195d18: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x195d1c: 0x24504a40
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 19008));
    // 0x195d20: 0x8e034f44
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20292)));
    // 0x195d24: 0x10600018
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195D88; return;
    }
    // 0x195d2c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x195d30: 0xae22027c
    WRITE32(ADD32(GPR_U32(ctx, 17), 636), GPR_U32(ctx, 2));
    // 0x195d34: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x195d38: 0x8c6219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6636)));
    // 0x195d3c: 0x30420100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 256));
    // 0x195d40: 0x14400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x195D5C; return;
    }
    // 0x195d48: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x195d4c: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195d54);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 20));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195d54
// Address: 0x195d54 - 0x195d68

void entry_195d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195d54) {
        switch (ctx->pc) {
            case 0x195d5c: ctx->pc = 0; goto label_195d5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195d54: 0x1000000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195D94; return;
    }
label_195d5c:
    // 0x195d5c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x195d60: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195d68);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195d68
// Address: 0x195d68 - 0x195d80

void entry_195d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195d68: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x195d6c: 0x3c050019
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    // 0x195d70: 0x24849990
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941072));
    // 0x195d74: 0x24a5c638
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952504));
    // 0x195d78: 0xc062d9c
    SET_GPR_U32(ctx, 31, 0x195d80);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CreateMemcardThread__FP7MEMCARDii(rdram, ctx, runtime); return;
}


// Function: entry_195d80
// Address: 0x195d80 - 0x195d90

void entry_195d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195d80) {
        switch (ctx->pc) {
            case 0x195d88: ctx->pc = 0; goto label_195d88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195d80: 0x10000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195D94; return;
    }
label_195d88:
    // 0x195d88: 0xc0650e6
    SET_GPR_U32(ctx, 31, 0x195d90);
    FUN_00194398(rdram, ctx, runtime); return;
}


// Function: entry_195d90
// Address: 0x195d90 - 0x195e2c

void entry_195d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195d90) {
        switch (ctx->pc) {
            case 0x195d94: ctx->pc = 0; goto label_195d94;
            case 0x195d9c: ctx->pc = 0; goto label_195d9c;
            case 0x195dcc: ctx->pc = 0; goto label_195dcc;
            case 0x195de0: ctx->pc = 0; goto label_195de0;
            case 0x195df4: ctx->pc = 0; goto label_195df4;
            case 0x195e08: ctx->pc = 0; goto label_195e08;
            case 0x195e1c: ctx->pc = 0; goto label_195e1c;
            case 0x195e24: ctx->pc = 0; goto label_195e24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195d90: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_195d94:
    // 0x195d94: 0x100000d9
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1960FC; return;
    }
label_195d9c:
    // 0x195d9c: 0x100000d7
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1960FC; return;
    }
    // 0x195da4: 0x24020019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 25));
    // 0x195da8: 0x12020012
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_195df4;
    }
    // 0x195db0: 0x2a02001a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 26));
    // 0x195db4: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 24));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_195dcc;
    }
    // 0x195dbc: 0x12020008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_195de0;
    }
    // 0x195dc4: 0x100000fa
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961B0; return;
    }
label_195dcc:
    // 0x195dcc: 0x2402001a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 26));
    // 0x195dd0: 0x1202000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_195e08;
    }
    // 0x195dd8: 0x100000f5
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961B0; return;
    }
label_195de0:
    // 0x195de0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195de4: 0x8c6523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x195de8: 0x8ca219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6636)));
    // 0x195dec: 0x1000000b
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 512));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_195e1c;
    }
label_195df4:
    // 0x195df4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195df8: 0x8c6523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x195dfc: 0x8ca219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6636)));
    // 0x195e00: 0x10000006
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1024));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_195e1c;
    }
label_195e08:
    // 0x195e08: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x195e0c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195e10: 0x8c6523c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x195e14: 0x8ca219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6636)));
    // 0x195e18: 0x38420800
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 2048));
label_195e1c:
    // 0x195e1c: 0xaca219ec
    WRITE32(ADD32(GPR_U32(ctx, 5), 6636), GPR_U32(ctx, 2));
    // 0x195e20: 0x8e300264
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 612)));
label_195e24:
    // 0x195e24: 0xc064da8
    SET_GPR_U32(ctx, 31, 0x195e2c);
    render_pause_menuQMARK(rdram, ctx, runtime); return;
}


// Function: entry_195e2c
// Address: 0x195e2c - 0x195e68

void entry_195e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195e2c: 0x100000de
    WRITE32(ADD32(GPR_U32(ctx, 17), 612), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1961a8(rdram, ctx, runtime); return;
    }
    // 0x195e34: 0x1200007e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x196030; return;
    }
    // 0x195e3c: 0x100000af
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1960FC; return;
    }
    // 0x195e44: 0x1600001e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x195EC0; return;
    }
    // 0x195e4c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x195e50: 0x3c050019
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    // 0x195e54: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x195e58: 0x24849990
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941072));
    // 0x195e5c: 0x24a5c1a8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294951336));
    // 0x195e60: 0xc062d9c
    SET_GPR_U32(ctx, 31, 0x195e68);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19008));
    CreateMemcardThread__FP7MEMCARDii(rdram, ctx, runtime); return;
}


// Function: entry_195e68
// Address: 0x195e68 - 0x195e78

void entry_195e68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195e68: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195e6c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x195e70: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195e78);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195e78
// Address: 0x195e78 - 0x195ea4

void entry_195e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195e78: 0x100000cc
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195e80: 0x1600000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x195EC0; return;
    }
    // 0x195e88: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x195e8c: 0x3c050019
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    // 0x195e90: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x195e94: 0x24849990
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941072));
    // 0x195e98: 0x24a5c250
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294951504));
    // 0x195e9c: 0xc062d9c
    SET_GPR_U32(ctx, 31, 0x195ea4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19008));
    CreateMemcardThread__FP7MEMCARDii(rdram, ctx, runtime); return;
}


// Function: entry_195ea4
// Address: 0x195ea4 - 0x195eb4

void entry_195ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195ea4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195ea8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x195eac: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195eb4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195eb4
// Address: 0x195eb4 - 0x195ecc

void entry_195eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195eb4) {
        switch (ctx->pc) {
            case 0x195ec0: ctx->pc = 0; goto label_195ec0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195eb4: 0x100000bd
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195ebc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_195ec0:
    // 0x195ec0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x195ec4: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195ecc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195ecc
// Address: 0x195ecc - 0x195edc

void entry_195ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195ecc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x195ed0: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x195ed4: 0xc06305e
    SET_GPR_U32(ctx, 31, 0x195edc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c178_FP4SAVEi(rdram, ctx, runtime); return;
}


// Function: entry_195edc
// Address: 0x195edc - 0x195f18

void entry_195edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195edc) {
        switch (ctx->pc) {
            case 0x195f08: ctx->pc = 0; goto label_195f08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195edc: 0x8e230268
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 616)));
    // 0x195ee0: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x195ee4: 0x10620008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 11));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_195f08;
    }
    // 0x195eec: 0x144000af
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195ef4: 0x28620012
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 18));
    // 0x195ef8: 0x104000ac
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195f00: 0x144000ab
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961B0; return;
    }
label_195f08:
    // 0x195f08: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195f0c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195f10: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195f18);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 23));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195f18
// Address: 0x195f18 - 0x195f58

void entry_195f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195f18: 0x100000a4
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195f20: 0x24031a5c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6748));
    // 0x195f24: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x195f28: 0x2031818
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x195f2c: 0x244242d8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 17112));
    // 0x195f30: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x195f34: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x195f38: 0xc600000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 12)); ctx->f[0] = *(float*)&val; }
    // 0x195f3c: 0x460f0032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[15])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x195f40: 0x0
    // NOP
    // 0x195f44: 0x45000009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x195F6C; return;
    }
    // 0x195f4c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195f50: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195f58);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195f58
// Address: 0x195f58 - 0x195fa8

void entry_195f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195f58) {
        switch (ctx->pc) {
            case 0x195f6c: ctx->pc = 0; goto label_195f6c;
            case 0x195f94: ctx->pc = 0; goto label_195f94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195f58: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x195f5c: 0x24424a40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 19008));
    // 0x195f60: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x195f64: 0x1000001f
    WRITE32(ADD32(GPR_U32(ctx, 2), 20292), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x195FE4; return;
    }
label_195f6c:
    // 0x195f6c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x195f70: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x195f74: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x195f78: 0x2404007b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 123));
    // 0x195f7c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x195f80: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x195f84: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195f88: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x195f8c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x195f90: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_195f94:
    // 0x195f94: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195f98: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x195f9c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195fa0: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x195fa8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_195fa8
// Address: 0x195fa8 - 0x195fc0

void entry_195fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195fa8: 0x10000080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195fb0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x195fb4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x195fb8: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x195fc0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_195fc0
// Address: 0x195fc0 - 0x195fec

void entry_195fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195fc0) {
        switch (ctx->pc) {
            case 0x195fe4: ctx->pc = 0; goto label_195fe4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195fc0: 0x24031a5c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6748));
    // 0x195fc4: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x195fc8: 0x2031818
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x195fcc: 0x24a542d8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 17112));
    // 0x195fd0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x195fd4: 0x24424a40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 19008));
    // 0x195fd8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x195fdc: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x195fe0: 0xac434f44
    WRITE32(ADD32(GPR_U32(ctx, 2), 20292), GPR_U32(ctx, 3));
label_195fe4:
    // 0x195fe4: 0xc06315a
    SET_GPR_U32(ctx, 31, 0x195fec);
    FUN_0018c568(rdram, ctx, runtime); return;
}


// Function: entry_195fec
// Address: 0x195fec - 0x195ff4

void entry_195fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x195fec: 0xc058252
    SET_GPR_U32(ctx, 31, 0x195ff4);
    FUN_00160948(rdram, ctx, runtime); return;
}


// Function: entry_195ff4
// Address: 0x195ff4 - 0x19606c

void entry_195ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x195ff4) {
        switch (ctx->pc) {
            case 0x196030: ctx->pc = 0; goto label_196030;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x195ff4: 0x1000006d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x195ffc: 0x24021a5c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6748));
    // 0x196000: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x196004: 0x2021018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x196008: 0x246342d8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 17112));
    // 0x19600c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x196010: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x196014: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x196018: 0xac82998c
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294941068), GPR_U32(ctx, 2));
    // 0x19601c: 0xc440000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[0] = *(float*)&val; }
    // 0x196020: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x196024: 0x0
    // NOP
    // 0x196028: 0x4500001e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1960A4; return;
    }
label_196030:
    // 0x196030: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x196034: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x196038: 0x24504a40
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 19008));
    // 0x19603c: 0x8c6423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x196040: 0x8e024f4c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20300)));
    // 0x196044: 0x2405000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 11));
    // 0x196048: 0xae024f44
    WRITE32(ADD32(GPR_U32(ctx, 16), 20292), GPR_U32(ctx, 2));
    // 0x19604c: 0xae25027c
    WRITE32(ADD32(GPR_U32(ctx, 17), 636), GPR_U32(ctx, 5));
    // 0x196050: 0x8c8219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    // 0x196054: 0x30420100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 256));
    // 0x196058: 0x14400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x196074; return;
    }
    // 0x196060: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x196064: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x19606c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 20));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_19606c
// Address: 0x19606c - 0x196080

void entry_19606c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19606c) {
        switch (ctx->pc) {
            case 0x196074: ctx->pc = 0; goto label_196074;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19606c: 0x1000000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19609C; return;
    }
label_196074:
    // 0x196074: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x196078: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x196080);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_196080
// Address: 0x196080 - 0x196098

void entry_196080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196080: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x196084: 0x3c050019
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    // 0x196088: 0x24849990
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941072));
    // 0x19608c: 0x24a5c638
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952504));
    // 0x196090: 0xc062d9c
    SET_GPR_U32(ctx, 31, 0x196098);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CreateMemcardThread__FP7MEMCARDii(rdram, ctx, runtime); return;
}


// Function: entry_196098
// Address: 0x196098 - 0x1960b0

void entry_196098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196098) {
        switch (ctx->pc) {
            case 0x19609c: ctx->pc = 0; goto label_19609c;
            case 0x1960a4: ctx->pc = 0; goto label_1960a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196098: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_19609c:
    // 0x19609c: 0x10000017
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1960FC; return;
    }
label_1960a4:
    // 0x1960a4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1960a8: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1960b0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 14));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1960b0
// Address: 0x1960b0 - 0x1960dc

void entry_1960b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1960b0: 0x1000003e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x1960b8: 0x1600000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1960F8; return;
    }
    // 0x1960c0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1960c4: 0x3c050019
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    // 0x1960c8: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1960cc: 0x24849990
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941072));
    // 0x1960d0: 0x24a5c770
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952816));
    // 0x1960d4: 0xc062d9c
    SET_GPR_U32(ctx, 31, 0x1960dc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19008));
    CreateMemcardThread__FP7MEMCARDii(rdram, ctx, runtime); return;
}


// Function: entry_1960dc
// Address: 0x1960dc - 0x1960ec

void entry_1960dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1960dc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1960e0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1960e4: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1960ec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 19));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1960ec
// Address: 0x1960ec - 0x196104

void entry_1960ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1960ec) {
        switch (ctx->pc) {
            case 0x1960f8: ctx->pc = 0; goto label_1960f8;
            case 0x1960fc: ctx->pc = 0; goto label_1960fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1960ec: 0x1000002f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x1960f4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1960f8:
    // 0x1960f8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
label_1960fc:
    // 0x1960fc: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x196104);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_196104
// Address: 0x196104 - 0x196164

void entry_196104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196104) {
        switch (ctx->pc) {
            case 0x196148: ctx->pc = 0; goto label_196148;
            case 0x196154: ctx->pc = 0; goto label_196154;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196104: 0x10000029
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1961AC; return;
    }
    // 0x19610c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x196110: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x196114: 0x8c6423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x196118: 0x8c8219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6636)));
    // 0x19611c: 0x34420100
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 256));
    // 0x196120: 0xac8219ec
    WRITE32(ADD32(GPR_U32(ctx, 4), 6636), GPR_U32(ctx, 2));
    // 0x196124: 0x8e23027c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 636)));
    // 0x196128: 0x1065000a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 5)) {
        goto label_196154;
    }
    // 0x196130: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_196148;
    }
    // 0x196138: 0x1062000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19616C; return;
    }
    // 0x196140: 0x10000013
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x196190; return;
    }
label_196148:
    // 0x196148: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x19614c: 0x14620010
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x196190; return;
    }
label_196154:
    // 0x196154: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x196158: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19615c: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x196164);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_196164
// Address: 0x196164 - 0x196178

void entry_196164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196164) {
        switch (ctx->pc) {
            case 0x19616c: ctx->pc = 0; goto label_19616c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196164: 0x1000000a
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x196190; return;
    }
label_19616c:
    // 0x19616c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x196170: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x196178);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_196178
// Address: 0x196178 - 0x19618c

void entry_196178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196178: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x19617c: 0x8c833eb0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 16048)));
    // 0x196180: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x196184: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19618c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16048));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19618c
// Address: 0x19618c - 0x1961a8

void entry_19618c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19618c) {
        switch (ctx->pc) {
            case 0x196190: ctx->pc = 0; goto label_196190;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19618c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
label_196190:
    // 0x196190: 0x3c050019
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    // 0x196194: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x196198: 0x24849990
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294941072));
    // 0x19619c: 0x24a5c638
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294952504));
    // 0x1961a0: 0xc062d9c
    SET_GPR_U32(ctx, 31, 0x1961a8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 19008));
    CreateMemcardThread__FP7MEMCARDii(rdram, ctx, runtime); return;
}


// Function: entry_1961a8
// Address: 0x1961a8 - 0x1961c0

void entry_1961a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1961a8) {
        switch (ctx->pc) {
            case 0x1961ac: ctx->pc = 0; goto label_1961ac;
            case 0x1961b0: ctx->pc = 0; goto label_1961b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1961a8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1961ac:
    // 0x1961ac: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1961b0:
    // 0x1961b0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1961b4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1961b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001961c0
// Address: 0x1961c0 - 0x196244

void FUN_001961c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1961c0: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x1961c4: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x1961c8: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x1961cc: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1961d0: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1961d4: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1961d8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1961dc: 0x8e630260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 608)));
    // 0x1961e0: 0x2c620020
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 32));
    // 0x1961e4: 0x1040004a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_196310(rdram, ctx, runtime); return;
    }
    // 0x1961ec: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1961f0: 0x2442c7e0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294952928));
    // 0x1961f4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1961f8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1961fc: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x196204: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x196208: 0x10000033
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1962D8; return;
    }
    // 0x196210: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x196214: 0x8c625bf0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 23536)));
    // 0x196218: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x19621c: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x196220: 0x10400025
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1962B8; return;
    }
    // 0x196228: 0x1000002b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1962D8; return;
    }
    // 0x196230: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x196234: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x196238: 0xc44ca708
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944520)); ctx->f[12] = *(float*)&val; }
    // 0x19623c: 0xc07f5e8
    SET_GPR_U32(ctx, 31, 0x196244);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 9360));
    FUN_001fd7a0(rdram, ctx, runtime); return;
}


// Function: entry_196244
// Address: 0x196244 - 0x19627c

void entry_196244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196244: 0xde510040
    SET_GPR_U64(ctx, 17, READ64(ADD32(GPR_U32(ctx, 18), 64)));
    // 0x196248: 0x2403f000
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294963200));
    // 0x19624c: 0xde500018
    SET_GPR_U64(ctx, 16, READ64(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x196250: 0x30440fff
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 2), 4095));
    // 0x196254: 0x2238824
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x196258: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19625c: 0x2038024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x196260: 0x2228825
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x196264: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x196268: 0x2048025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 4)));
    // 0x19626c: 0xc46ca70c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944524)); ctx->f[12] = *(float*)&val; }
    // 0x196270: 0xfe510040
    WRITE64(ADD32(GPR_U32(ctx, 18), 64), GPR_U64(ctx, 17));
    // 0x196274: 0xc07f5e8
    SET_GPR_U32(ctx, 31, 0x19627c);
    WRITE64(ADD32(GPR_U32(ctx, 18), 24), GPR_U64(ctx, 16));
    FUN_001fd7a0(rdram, ctx, runtime); return;
}


// Function: entry_19627c
// Address: 0x19627c - 0x1962c8

void entry_19627c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19627c) {
        switch (ctx->pc) {
            case 0x1962b8: ctx->pc = 0; goto label_1962b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19627c: 0x304307ff
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 2), 2047));
    // 0x196280: 0x3c04ff80
    SET_GPR_U32(ctx, 4, ((uint32_t)65408 << 16));
    // 0x196284: 0x34840fff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 4095));
    // 0x196288: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x19628c: 0x2048024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 4)));
    // 0x196290: 0x2248824
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    // 0x196294: 0x21338
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 12);
    // 0x196298: 0x31b38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 12);
    // 0x19629c: 0x2228825
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1962a0: 0x2038025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1962a4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1962a8: 0xfe500018
    WRITE64(ADD32(GPR_U32(ctx, 18), 24), GPR_U64(ctx, 16));
    // 0x1962ac: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1962b0: 0x1000000f
    WRITE64(ADD32(GPR_U32(ctx, 18), 64), GPR_U64(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1962F0; return;
    }
label_1962b8:
    // 0x1962b8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1962bc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1962c0: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1962c8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1962c8
// Address: 0x1962c8 - 0x1962e0

void entry_1962c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1962c8) {
        switch (ctx->pc) {
            case 0x1962d8: ctx->pc = 0; goto label_1962d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1962c8: 0x10000012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x196314; return;
    }
    // 0x1962d0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1962d4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
label_1962d8:
    // 0x1962d8: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1962e0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1962e0
// Address: 0x1962e0 - 0x1962f8

void entry_1962e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1962e0) {
        switch (ctx->pc) {
            case 0x1962f0: ctx->pc = 0; goto label_1962f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1962e0: 0x1000000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x196314; return;
    }
    // 0x1962e8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1962ec: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1962f0:
    // 0x1962f0: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x1962f8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 23));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_1962f8
// Address: 0x1962f8 - 0x196310

void entry_1962f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1962f8: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x196314; return;
    }
    // 0x196300: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x196304: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x196308: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x196310);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_196310
// Address: 0x196310 - 0x196330

void entry_196310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196310) {
        switch (ctx->pc) {
            case 0x196314: ctx->pc = 0; goto label_196314;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196310: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_196314:
    // 0x196314: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x196318: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19631c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x196320: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x196324: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19632c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x196330; return;
}


// Function: FUN_00196330
// Address: 0x196330 - 0x196360

void FUN_00196330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196330: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x196334: 0x3402ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    // 0x196338: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x19633c: 0x14a20015
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x196394; return;
    }
    // 0x196344: 0x10800013
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x196394; return;
    }
    // 0x19634c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x196350: 0x2610a210
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294943248));
    // 0x196354: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    // 0x196358: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x196360);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_196360
// Address: 0x196360 - 0x1963cc

void entry_196360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196360) {
        switch (ctx->pc) {
            case 0x196394: ctx->pc = 0; goto label_196394;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196360: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x196364: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x196368: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19636c: 0x3c02ff7d
    SET_GPR_U32(ctx, 2, ((uint32_t)65405 << 16));
    // 0x196370: 0x3c014170
    SET_GPR_U32(ctx, 1, ((uint32_t)16752 << 16));
    // 0x196374: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x196378: 0x2403002d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 45));
    // 0x19637c: 0x34424b00
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 19200));
    // 0x196380: 0xa2030004
    WRITE8(ADD32(GPR_U32(ctx, 16), 4), (uint8_t)GPR_U32(ctx, 3));
    // 0x196384: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    // 0x196388: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x19638c: 0xe6010014
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x196390: 0xe6010010
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
label_196394:
    // 0x196394: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x196398: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19639c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1963a4: 0x0
    // NOP
    // 0x1963a8: 0xe48c0000
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x1963ac: 0x0
    // NOP
    // 0x1963b0: 0xe48c0008
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 4), 8), *(uint32_t*)&val); }
    // 0x1963b4: 0x0
    // NOP
    // 0x1963b8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1963bc: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1963c0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1963c4: 0xc0658cc
    SET_GPR_U32(ctx, 31, 0x1963cc);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    FUN_00196330(rdram, ctx, runtime); return;
}


// Function: entry_1963cc
// Address: 0x1963cc - 0x1963d8

void entry_1963cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1963cc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1963d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitProxy__FP5PROXY
// Address: 0x1963d8 - 0x1963ec

void entry_1963ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1963ec: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1963f0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1963f4: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1963fc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7228));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1963fc
// Address: 0x1963fc - 0x196410

void entry_1963fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1963fc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x196400: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x196404: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19640c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x196410; return;
}


// Function: LoadProxyFromBrx__FP5PROXYP18CBinaryInputStream
// Address: 0x196410 - 0x196458

void entry_196458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196458: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x19645c: 0xc04dfac
    SET_GPR_U32(ctx, 31, 0x196464);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 208));
    ReadMatrix__18CBinaryInputStreamP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_196464
// Address: 0x196464 - 0x196470

void entry_196464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196464: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x196468: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x196470);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 256));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_196470
// Address: 0x196470 - 0x196478

void entry_196470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196470: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x196478);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_196478
// Address: 0x196478 - 0x196494

void entry_196478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196478: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19647c: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x196480: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x196484: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_196494(rdram, ctx, runtime); return;
    }
    // 0x19648c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x196494);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_196494
// Address: 0x196494 - 0x1964b0

void entry_196494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196494) {
        switch (ctx->pc) {
            case 0x1964a8: ctx->pc = 0; goto label_1964a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196494: 0x1ac00035
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 22) <= 0) {
        ctx->pc = 0x19656C; return;
    }
    // 0x19649c: 0x2417ffff
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1964a0: 0x3a0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1964a4: 0x2c0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_1964a8:
    // 0x1964a8: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1964b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1964b0
// Address: 0x1964b0 - 0x1964c4

void entry_1964b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1964b0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1964b4: 0x16570008
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 23)) {
        ctx->pc = 0x1964D8; return;
    }
    // 0x1964bc: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1964c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1964c4
// Address: 0x1964c4 - 0x1964d0

void entry_1964c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1964c4: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x1964c8: 0xc077082
    SET_GPR_U32(ctx, 31, 0x1964d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PloGetSwProxySource__FP2SWi(rdram, ctx, runtime); return;
}


// Function: entry_1964d0
// Address: 0x1964d0 - 0x1964e0

void entry_1964d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1964d0) {
        switch (ctx->pc) {
            case 0x1964d8: ctx->pc = 0; goto label_1964d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1964d0: 0x10000018
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_196534(rdram, ctx, runtime); return;
    }
label_1964d8:
    // 0x1964d8: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1964e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1964e0
// Address: 0x1964e0 - 0x1964ec

void entry_1964e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1964e0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1964e4: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1964ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1964ec
// Address: 0x1964ec - 0x196504

void entry_1964ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1964ec: 0x8e850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x1964f0: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1964f4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1964f8: 0x40402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1964fc: 0xc047960
    SET_GPR_U32(ctx, 31, 0x196504);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_196504
// Address: 0x196504 - 0x19651c

void entry_196504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196504: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x196508: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x19650c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x196510: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x196514: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19651c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19651c
// Address: 0x19651c - 0x196524

void entry_19651c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19651c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x196524);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_196524
// Address: 0x196524 - 0x196534

void entry_196524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196524: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x196528: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19652c: 0xc077054
    SET_GPR_U32(ctx, 31, 0x196534);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddSwProxySource__FP2SWP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_196534
// Address: 0x196534 - 0x196540

void entry_196534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196534: 0x24040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    // 0x196538: 0xc063570
    SET_GPR_U32(ctx, 31, 0x196540);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_196540
// Address: 0x196540 - 0x19655c

void entry_196540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196540: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x196544: 0x268402d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 720));
    // 0x196548: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19654c: 0x8e830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x196550: 0xac430004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 3));
    // 0x196554: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x19655c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 2));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_19655c
// Address: 0x19655c - 0x196574

void entry_19655c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19655c) {
        switch (ctx->pc) {
            case 0x19656c: ctx->pc = 0; goto label_19656c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19655c: 0xae700000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 16));
    // 0x196560: 0x1620ffd1
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1964A8; return;
    }
    // 0x196568: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_19656c:
    // 0x19656c: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x196574);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_196574
// Address: 0x196574 - 0x1965a0

void entry_196574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196574) {
        switch (ctx->pc) {
            case 0x196598: ctx->pc = 0; goto label_196598;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196574: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x196578: 0x1bc00052
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_S32(ctx, 30) <= 0) {
        ctx->pc = 0x1966C4; return;
    }
    // 0x196580: 0x3c015015
    SET_GPR_U32(ctx, 1, ((uint32_t)20501 << 16));
    // 0x196584: 0x342102f9
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 761));
    // 0x196588: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x19658c: 0xc454c860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294953056)); ctx->f[20] = *(float*)&val; }
    // 0x196590: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x196594: 0x0
    // NOP
label_196598:
    // 0x196598: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x1965a0);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1965a0
// Address: 0x1965a0 - 0x1965f8

void entry_1965a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1965a0) {
        switch (ctx->pc) {
            case 0x1965b0: ctx->pc = 0; goto label_1965b0;
            case 0x1965d8: ctx->pc = 0; goto label_1965d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1965a0: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1965a4: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1965a8: 0x26170001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 16), 1));
    // 0x1965ac: 0x0
    // NOP
label_1965b0:
    // 0x1965b0: 0x236102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 22)));
    // 0x1965b4: 0x10400013
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x196604; return;
    }
    // 0x1965bc: 0x3a21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x1965c0: 0x8c700000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1965c4: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1965c8: 0x54520003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1965d8;
    }
    // 0x1965d0: 0x1000000a
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1965FC; return;
    }
label_1965d8:
    // 0x1965d8: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1965dc: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1965e0: 0x10400006
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1965FC; return;
    }
    // 0x1965e8: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x1965ec: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x1965f0: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1965f8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1965f8
// Address: 0x1965f8 - 0x19660c

void entry_1965f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1965f8) {
        switch (ctx->pc) {
            case 0x1965fc: ctx->pc = 0; goto label_1965fc;
            case 0x196604: ctx->pc = 0; goto label_196604;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1965f8: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1965fc:
    // 0x1965fc: 0x5260ffec
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        ctx->pc = 0x1965B0; return;
    }
label_196604:
    // 0x196604: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x19660c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19660c
// Address: 0x19660c - 0x196624

void entry_19660c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19660c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x196610: 0x1043000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x19663C; return;
    }
    // 0x196618: 0x8e850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x19661c: 0xc0704e4
    SET_GPR_U32(ctx, 31, 0x196624);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PframeFromIsplice__FiP2SW(rdram, ctx, runtime); return;
}


// Function: entry_196624
// Address: 0x196624 - 0x196638

void entry_196624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196624: 0x8e65002c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 44)));
    // 0x196628: 0x10a00003
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_196638(rdram, ctx, runtime); return;
    }
    // 0x196630: 0xc0468ce
    SET_GPR_U32(ctx, 31, 0x196638);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddParent__6CFrameP6CFrame(rdram, ctx, runtime); return;
}


// Function: entry_196638
// Address: 0x196638 - 0x196644

void entry_196638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196638) {
        switch (ctx->pc) {
            case 0x19663c: ctx->pc = 0; goto label_19663c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196638: 0xae70002c
    WRITE32(ADD32(GPR_U32(ctx, 19), 44), GPR_U32(ctx, 16));
label_19663c:
    // 0x19663c: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x196644);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_196644
// Address: 0x196644 - 0x196664

void entry_196644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196644) {
        switch (ctx->pc) {
            case 0x19665c: ctx->pc = 0; goto label_19665c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196644: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x196648: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19664c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x196650: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x196654: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 19), 136), GPR_U32(ctx, 4));
        goto label_19665c;
    }
label_19665c:
    // 0x19665c: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x196664);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_196664
// Address: 0x196664 - 0x196694

void entry_196664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196664: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x196668: 0x14430010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x1966AC; return;
    }
    // 0x196670: 0xde6202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 19), 712)));
    // 0x196674: 0x3c03cfff
    SET_GPR_U32(ctx, 3, ((uint32_t)53247 << 16));
    // 0x196678: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x19667c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x196680: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x196684: 0x3c032000
    SET_GPR_U32(ctx, 3, ((uint32_t)8192 << 16));
    // 0x196688: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19668c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x196694);
    WRITE64(ADD32(GPR_U32(ctx, 19), 712), GPR_U64(ctx, 2));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_196694
// Address: 0x196694 - 0x1966b4

void entry_196694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196694) {
        switch (ctx->pc) {
            case 0x1966a8: ctx->pc = 0; goto label_1966a8;
            case 0x1966ac: ctx->pc = 0; goto label_1966ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196694: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x196698: 0x0
    // NOP
    // 0x19669c: 0x45000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 128), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1966a8;
    }
    // 0x1966a4: 0xe6750080
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 19), 128), *(uint32_t*)&val); }
label_1966a8:
    // 0x1966a8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_1966ac:
    // 0x1966ac: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x1966b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1966b4
// Address: 0x1966b4 - 0x1966f0

void entry_1966b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1966b4) {
        switch (ctx->pc) {
            case 0x1966c4: ctx->pc = 0; goto label_1966c4;
            case 0x1966d8: ctx->pc = 0; goto label_1966d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1966b4: 0x2e0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1966b8: 0x21e102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 30)));
    // 0x1966bc: 0x1440ffb6
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x196598; return;
    }
label_1966c4:
    // 0x1966c4: 0x1ac00014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 22) <= 0) {
        ctx->pc = 0x196718; return;
    }
    // 0x1966cc: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1966d0: 0x2c0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1966d4: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_1966d8:
    // 0x1966d8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1966dc: 0x8c420068
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 104)));
    // 0x1966e0: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1966f0(rdram, ctx, runtime); return;
    }
    // 0x1966e8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1966f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1966f0
// Address: 0x1966f0 - 0x19670c

void entry_1966f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1966f0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1966f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1966f8: 0x8e850018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x1966fc: 0x26520004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    // 0x196700: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x196704: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19670c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19670c
// Address: 0x19670c - 0x196734

void entry_19670c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19670c) {
        switch (ctx->pc) {
            case 0x196718: ctx->pc = 0; goto label_196718;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19670c: 0x5620fff2
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1966D8; return;
    }
    // 0x196714: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_196718:
    // 0x196718: 0x56c20028
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
        ctx->pc = 0x1967BC; return;
    }
    // 0x196720: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x196724: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x196728: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19672c: 0xc047b2e
    SET_GPR_U32(ctx, 31, 0x196734);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 52));
    LoadSwObjectsFromBrx__FP2SWP3ALOP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_196734
// Address: 0x196734 - 0x19673c

void entry_196734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196734: 0xc0549c8
    SET_GPR_U32(ctx, 31, 0x19673c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsDlEmpty__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_19673c
// Address: 0x19673c - 0x196794

void entry_19673c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19673c) {
        switch (ctx->pc) {
            case 0x196780: ctx->pc = 0; goto label_196780;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19673c: 0x5440001f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
        ctx->pc = 0x1967BC; return;
    }
    // 0x196744: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x196748: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x19674c: 0x8c45b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4294947604)));
    // 0x196750: 0x27a30100
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 256));
    // 0x196754: 0xafb00100
    WRITE32(ADD32(GPR_U32(ctx, 29), 256), GPR_U32(ctx, 16));
    // 0x196758: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19675c: 0xafa5010c
    WRITE32(ADD32(GPR_U32(ctx, 29), 268), GPR_U32(ctx, 5));
    // 0x196760: 0xac43b314
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294947604), GPR_U32(ctx, 3));
    // 0x196764: 0x8fb00000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x196768: 0x8e820034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 52)));
    // 0x19676c: 0xafa40108
    WRITE32(ADD32(GPR_U32(ctx, 29), 264), GPR_U32(ctx, 4));
    // 0x196770: 0x442021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x196774: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x196778: 0x10a0000d
    WRITE32(ADD32(GPR_U32(ctx, 29), 260), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1967B0; return;
    }
label_196780:
    // 0x196780: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x196784: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x196788: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x19678c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x196794);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_196794
// Address: 0x196794 - 0x1967c8

void entry_196794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196794) {
        switch (ctx->pc) {
            case 0x1967b0: ctx->pc = 0; goto label_1967b0;
            case 0x1967bc: ctx->pc = 0; goto label_1967bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196794: 0x8fa40104
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x196798: 0x8fa20108
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 264)));
    // 0x19679c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1967a0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1967a4: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1967a8: 0x14a0fff5
    WRITE32(ADD32(GPR_U32(ctx, 29), 260), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x196780; return;
    }
label_1967b0:
    // 0x1967b0: 0x8fa2010c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 268)));
    // 0x1967b4: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
    // 0x1967b8: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
label_1967bc:
    // 0x1967bc: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1967c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1967c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1967c8
// Address: 0x1967c8 - 0x1967d8

void entry_1967c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1967c8: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x1967cc: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1967d0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1967d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1967d8
// Address: 0x1967d8 - 0x196810

void entry_1967d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1967d8: 0x7bbf01a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x1967dc: 0x7bbe0190
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x1967e0: 0x7bb70180
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1967e4: 0x7bb60170
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1967e8: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1967ec: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1967f0: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1967f4: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1967f8: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1967fc: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x196800: 0xc7b501b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 440)); ctx->f[21] = *(float*)&val; }
    // 0x196804: 0xc7b401b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[20] = *(float*)&val; }
    // 0x196808: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 448));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneProxy__FP5PROXYT0
// Address: 0x196810 - 0x196844

void entry_196844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196844: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x196848: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x19684c: 0xb24202e3
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 739); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x196850: 0xb64202dc
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 732); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x196854: 0x6a4602d7
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 727); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x196858: 0x6e4602d0
    { uint32_t addr = ADD32(GPR_U32(ctx, 18), 720); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x19685c: 0x8e4702d8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 728)));
    // 0x196860: 0xb3a60017
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x196864: 0xb7a60010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x196868: 0xafa70018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 7));
    // 0x19686c: 0xc054910
    SET_GPR_U32(ctx, 31, 0x196874);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 720));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_196874
// Address: 0x196874 - 0x1968ac

void entry_196874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196874) {
        switch (ctx->pc) {
            case 0x196888: ctx->pc = 0; goto label_196888;
            case 0x196890: ctx->pc = 0; goto label_196890;
            case 0x1968a4: ctx->pc = 0; goto label_1968a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196874: 0x8fb10010
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x196878: 0x1220001b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1968E8; return;
    }
    // 0x196880: 0x8e420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x196884: 0x0
    // NOP
label_196888:
    // 0x196888: 0x265302d0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 720));
    // 0x19688c: 0x8c500034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 52)));
label_196890:
    // 0x196890: 0x12000004
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1968a4;
    }
    // 0x196898: 0x8e020030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 48)));
    // 0x19689c: 0x5451fffc
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 28)));
        goto label_196890;
    }
label_1968a4:
    // 0x1968a4: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1968ac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1968ac
// Address: 0x1968ac - 0x1968d8

void entry_1968ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1968ac) {
        switch (ctx->pc) {
            case 0x1968c8: ctx->pc = 0; goto label_1968c8;
            case 0x1968d0: ctx->pc = 0; goto label_1968d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1968ac: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1968b0: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1968b4: 0x12000004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_1968c8;
    }
    // 0x1968bc: 0xacb00000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 16));
    // 0x1968c0: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 48), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1968d0;
    }
label_1968c8:
    // 0x1968c8: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1968cc: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
label_1968d0:
    // 0x1968d0: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x1968d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_1968d8
// Address: 0x1968d8 - 0x196900

void entry_1968d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1968d8) {
        switch (ctx->pc) {
            case 0x1968e8: ctx->pc = 0; goto label_1968e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1968d8: 0x8e310008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1968dc: 0x5620ffea
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 24)));
        ctx->pc = 0x196888; return;
    }
    // 0x1968e4: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1968e8:
    // 0x1968e8: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1968ec: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1968f0: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1968f4: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1968f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostProxyLoad__FP5PROXY
// Address: 0x196900 - 0x196914

void entry_196914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196914: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x196918: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x19691c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x196924);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_196924
// Address: 0x196924 - 0x196938

void entry_196924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196924: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x196928: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19692c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x196934: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x196938; return;
}


// Function: InitPuffer__FP6PUFFER
// Address: 0x196938 - 0x19694c

void entry_19694c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19694c: 0x3c01c120
    SET_GPR_U32(ctx, 1, ((uint32_t)49440 << 16));
    // 0x196950: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x196954: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x196958: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x19695c: 0xc462a71c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944540)); ctx->f[2] = *(float*)&val; }
    // 0x196960: 0xe600061c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1564), *(uint32_t*)&val); }
    // 0x196964: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x196968: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x19696c: 0x3c0142f0
    SET_GPR_U32(ctx, 1, ((uint32_t)17136 << 16));
    // 0x196970: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x196974: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x196978: 0x260406a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1704));
    // 0x19697c: 0xc4c1a718
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 4294944536)); ctx->f[1] = *(float*)&val; }
    // 0x196980: 0x24050568
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1384));
    // 0x196984: 0x7e030630
    WRITE128(ADD32(GPR_U32(ctx, 16), 1584), GPR_VEC(ctx, 3));
    // 0x196988: 0xe6000688
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1672), *(uint32_t*)&val); }
    // 0x19698c: 0xe6020624
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 1572), *(uint32_t*)&val); }
    // 0x196990: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x196998);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1576), *(uint32_t*)&val); }
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_196998
// Address: 0x196998 - 0x1969a4

void entry_196998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196998: 0x2604069c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1692));
    // 0x19699c: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x1969a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1384));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_1969a4
// Address: 0x1969a4 - 0x1969c0

void entry_1969a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1969a4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1969a8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1969ac: 0xac50a904
    WRITE32(ADD32(GPR_U32(ctx, 2), 4294945028), GPR_U32(ctx, 16));
    // 0x1969b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1969b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1969bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1969c0; return;
}


// Function: LoadPufferFromBrx__FP6PUFFERP18CBinaryInputStream
// Address: 0x1969c0 - 0x1969d4

void entry_1969d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1969d4: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1969d8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1969dc: 0x24c6a728
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294944552));
    // 0x1969e0: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1969e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1969e8
// Address: 0x1969e8 - 0x1969f8

void entry_1969e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1969e8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1969ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1969f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostPufferLoad__FP6PUFFER
// Address: 0x1969f8 - 0x196a14

void entry_196a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196a14: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x196a18: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x196a1c: 0x24c6a738
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294944568));
    // 0x196a20: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x196a28);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_196a28
// Address: 0x196a28 - 0x196a34

void entry_196a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196a28: 0xc64c00d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 212)); ctx->f[12] = *(float*)&val; }
    // 0x196a2c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x196a34);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 208)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_196a34
// Address: 0x196a34 - 0x196a4c

void entry_196a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196a34: 0x8e440610
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1552)));
    // 0x196a38: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x196a3c: 0xe6400618
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1560), *(uint32_t*)&val); }
    // 0x196a40: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x196a44: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x196a4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_196a4c
// Address: 0x196a4c - 0x196a64

void entry_196a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196a4c: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x196a50: 0x3c060022
    SET_GPR_U32(ctx, 6, ((uint32_t)34 << 16));
    // 0x196a54: 0x8e45065c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1628)));
    // 0x196a58: 0x24c6a790
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294944656));
    // 0x196a5c: 0xc04848a
    SET_GPR_U32(ctx, 31, 0x196a64);
    WRITE32(ADD32(GPR_U32(ctx, 18), 1556), GPR_U32(ctx, 2));
    PactNew__FP2SWP3ALOP5VTACT(rdram, ctx, runtime); return;
}


// Function: entry_196a64
// Address: 0x196a64 - 0x196a7c

void entry_196a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196a64: 0xae420664
    WRITE32(ADD32(GPR_U32(ctx, 18), 1636), GPR_U32(ctx, 2));
    // 0x196a68: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x196a6c: 0xa0430011
    WRITE8(ADD32(GPR_U32(ctx, 2), 17), (uint8_t)GPR_U32(ctx, 3));
    // 0x196a70: 0x8e44065c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1628)));
    // 0x196a74: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x196a7c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1636)));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_196a7c
// Address: 0x196a7c - 0x196ac4

void entry_196a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196a7c: 0x8e430664
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1636)));
    // 0x196a80: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x196a84: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x196a88: 0x24050305
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 773));
    // 0x196a8c: 0xac62001c
    WRITE32(ADD32(GPR_U32(ctx, 3), 28), GPR_U32(ctx, 2));
    // 0x196a90: 0x24848d30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937904));
    // 0x196a94: 0x2406000f
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 15));
    // 0x196a98: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x196a9c: 0x8e4a0664
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 18), 1636)));
    // 0x196aa0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x196aa4: 0x8e430660
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1632)));
    // 0x196aa8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x196aac: 0xad430024
    WRITE32(ADD32(GPR_U32(ctx, 10), 36), GPR_U32(ctx, 3));
    // 0x196ab0: 0x8e430664
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1636)));
    // 0x196ab4: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x196ab8: 0x7c620030
    WRITE128(ADD32(GPR_U32(ctx, 3), 48), GPR_VEC(ctx, 2));
    // 0x196abc: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x196ac4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_196ac4
// Address: 0x196ac4 - 0x196ad0

void entry_196ac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196ac4: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x196ac8: 0xc063540
    SET_GPR_U32(ctx, 31, 0x196ad0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 1680), GPR_U32(ctx, 2));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_196ad0
// Address: 0x196ad0 - 0x196af0

void entry_196ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196ad0: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x196ad4: 0x40482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x196ad8: 0x8e480690
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 1680)));
    // 0x196adc: 0x24050105
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 261));
    // 0x196ae0: 0x2406000f
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 15));
    // 0x196ae4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x196ae8: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x196af0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 1684), GPR_U32(ctx, 2));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_196af0
// Address: 0x196af0 - 0x196b10

void entry_196af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196af0: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x196af4: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x196af8: 0xae420690
    WRITE32(ADD32(GPR_U32(ctx, 18), 1680), GPR_U32(ctx, 2));
    // 0x196afc: 0x24060044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    // 0x196b00: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x196b04: 0x24080020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 32));
    // 0x196b08: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x196b10);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_196b10
// Address: 0x196b10 - 0x196b30

void entry_196b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196b10) {
        switch (ctx->pc) {
            case 0x196b20: ctx->pc = 0; goto label_196b20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196b10: 0x18400009
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x196B38; return;
    }
    // 0x196b18: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x196b1c: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_196b20:
    // 0x196b20: 0x2644069c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 1692));
    // 0x196b24: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x196b28: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x196b30);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_196b30
// Address: 0x196b30 - 0x196b4c

void entry_196b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196b30) {
        switch (ctx->pc) {
            case 0x196b38: ctx->pc = 0; goto label_196b38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196b30: 0x5620fffb
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x196B20; return;
    }
label_196b38:
    // 0x196b38: 0x8e4406b4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1716)));
    // 0x196b3c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x196b40: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x196b44: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x196b4c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_196b4c
// Address: 0x196b4c - 0x196b5c

void entry_196b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196b4c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x196b50: 0xae4206b8
    WRITE32(ADD32(GPR_U32(ctx, 18), 1720), GPR_U32(ctx, 2));
    // 0x196b54: 0xc06db7e
    SET_GPR_U32(ctx, 31, 0x196b5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FUN_001b6df8(rdram, ctx, runtime); return;
}


// Function: entry_196b5c
// Address: 0x196b5c - 0x196b78

void entry_196b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196b5c: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x196b60: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x196b64: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x196b68: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x196b6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x196b74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x196b78; return;
}


// Function: PresetPufferAccel__FP6PUFFERf
// Address: 0x196b78 - 0x196ba0

void entry_196ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196ba0: 0x3c110025
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
    // 0x196ba4: 0xc66c0618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1560)); ctx->f[12] = *(float*)&val; }
    // 0x196ba8: 0x26318d20
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294937888));
    // 0x196bac: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x196bb0: 0xc062214
    SET_GPR_U32(ctx, 31, 0x196bb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_196bb8
// Address: 0x196bb8 - 0x196bc8

void entry_196bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196bb8: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x196bbc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x196bc0: 0xc06274e
    SET_GPR_U32(ctx, 31, 0x196bc8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 1584));
    BuildRotateVectorsMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_196bc8
// Address: 0x196bc8 - 0x196c40

void entry_196bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196bc8: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x196bcc: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x196bd0: 0xdba60040
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x196bd4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x196bd8: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x196bdc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x196be0: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x196be4: 0x24c6a7d8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294944728));
    // 0x196be8: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x196bec: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x196bf0: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x196bf4: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x196bf8: 0x4bc409bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x196bfc: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x196c00: 0x4bc4110a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x196c04: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x196c08: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x196c0c: 0x4bc530bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x196c10: 0x4bc5104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x196c14: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x196c18: 0xfba40010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x196c1c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x196c20: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x196c24: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x196c28: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x196c2c: 0xfba400a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x196c30: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x196c34: 0xfba100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x196c38: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x196c40);
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_196c40
// Address: 0x196c40 - 0x196c54

void entry_196c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196c40: 0x27b20060
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 96));
    // 0x196c44: 0x27a60090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    // 0x196c48: 0x266400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 208));
    // 0x196c4c: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x196c54);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_196c54
// Address: 0x196c54 - 0x196c68

void entry_196c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196c54: 0x27b000c0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 192));
    // 0x196c58: 0xc66c0618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1560)); ctx->f[12] = *(float*)&val; }
    // 0x196c5c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x196c60: 0xc062214
    SET_GPR_U32(ctx, 31, 0x196c68);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_196c68
// Address: 0x196c68 - 0x196c7c

void entry_196c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196c68: 0x27a400f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 240));
    // 0x196c6c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x196c70: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x196c74: 0xc062148
    SET_GPR_U32(ctx, 31, 0x196c7c);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    MatMulMatTransMat__FRC7MATRIX3T0(rdram, ctx, runtime); return;
}


// Function: entry_196c7c
// Address: 0x196c7c - 0x196ca0

void entry_196c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196c7c: 0x7ba200f0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x196c80: 0x7ba30100
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x196c84: 0x7ba40110
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x196c88: 0xc7ac0094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 148)); ctx->f[12] = *(float*)&val; }
    // 0x196c8c: 0xc7ad0090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[13] = *(float*)&val; }
    // 0x196c90: 0x7fa200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 2));
    // 0x196c94: 0x7fa300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 3));
    // 0x196c98: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x196ca0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 4));
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_196ca0
// Address: 0x196ca0 - 0x196cac

void entry_196ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196ca0: 0xc66c0618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1560)); ctx->f[12] = *(float*)&val; }
    // 0x196ca4: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x196cac);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_196cac
// Address: 0x196cac - 0x196db4

void entry_196cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196cac) {
        switch (ctx->pc) {
            case 0x196cfc: ctx->pc = 0; goto label_196cfc;
            case 0x196d10: ctx->pc = 0; goto label_196d10;
            case 0x196d70: ctx->pc = 0; goto label_196d70;
            case 0x196d84: ctx->pc = 0; goto label_196d84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196cac: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x196cb0: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x196cb4: 0x2443a7f0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294944752));
    // 0x196cb8: 0xc443a7f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944752)); ctx->f[3] = *(float*)&val; }
    // 0x196cbc: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x196cc0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x196cc4: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x196cc8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x196ccc: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x196cd0: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x196cd4: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x196cd8: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x196cdc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x196ce0: 0x46001800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x196ce4: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x196ce8: 0x0
    // NOP
    // 0x196cec: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_196cfc;
    }
    // 0x196cf4: 0x10000006
    ctx->f[6] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_196d10;
    }
label_196cfc:
    // 0x196cfc: 0x46002834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x196d00: 0x0
    // NOP
    // 0x196d04: 0x45000002
    ctx->f[6] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_196d10;
    }
    // 0x196d0c: 0x46002986
    ctx->f[6] = FPU_MOV_S(ctx->f[5]);
label_196d10:
    // 0x196d10: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x196d14: 0xc661061c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1564)); ctx->f[1] = *(float*)&val; }
    // 0x196d18: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x196d1c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x196d20: 0xc444a800
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944768)); ctx->f[4] = *(float*)&val; }
    // 0x196d24: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x196d28: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x196d2c: 0x2462a810
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294944784));
    // 0x196d30: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x196d34: 0x24a45c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 23648));
    // 0x196d38: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x196d3c: 0x46040003
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[4];
    // 0x196d40: 0xc463a810
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944784)); ctx->f[3] = *(float*)&val; }
    // 0x196d44: 0xc4a45c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x196d48: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x196d4c: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x196d50: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x196d54: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x196d58: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x196d5c: 0x0
    // NOP
    // 0x196d60: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_196d70;
    }
    // 0x196d68: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_196d84;
    }
label_196d70:
    // 0x196d70: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x196d74: 0x0
    // NOP
    // 0x196d78: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_196d84;
    }
    // 0x196d80: 0x46002d06
    ctx->f[20] = FPU_MOV_S(ctx->f[5]);
label_196d84:
    // 0x196d84: 0x46143002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[20]);
    // 0x196d88: 0xc6610620
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1568)); ctx->f[1] = *(float*)&val; }
    // 0x196d8c: 0xdba200c0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x196d90: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x196d94: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x196d98: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x196d9c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x196da0: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x196da4: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x196da8: 0xfba10100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x196dac: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x196db4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[2]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_196db4
// Address: 0x196db4 - 0x196e24

void entry_196db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196db4: 0xc6600624
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1572)); ctx->f[0] = *(float*)&val; }
    // 0x196db8: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x196dbc: 0xc6610628
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1576)); ctx->f[1] = *(float*)&val; }
    // 0x196dc0: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x196dc4: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x196dc8: 0x7a620150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 336)));
    // 0x196dcc: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x196dd0: 0x7fa20100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 2));
    // 0x196dd4: 0xafa00108
    WRITE32(ADD32(GPR_U32(ctx, 29), 264), GPR_U32(ctx, 0));
    // 0x196dd8: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x196ddc: 0xdba20100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x196de0: 0x4bc2106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x196de4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x196de8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x196dec: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x196df0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x196df4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x196df8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x196dfc: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x196e00: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x196e04: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x196e08: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x196e0c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x196e10: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x196e14: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x196e18: 0xfba10110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x196e1c: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x196e24);
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[2]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_196e24
// Address: 0x196e24 - 0x196e48

void entry_196e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196e24: 0x7bbf0160
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x196e28: 0x7bb30150
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x196e2c: 0x7bb20140
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x196e30: 0x7bb10130
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x196e34: 0x7bb00120
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x196e38: 0xc7b40170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[20] = *(float*)&val; }
    // 0x196e3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x196e44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x196e48; return;
}


// Function: FFilterPuffer__FP6PUFFERP2SO
// Address: 0x196e48 - 0x196e80

void entry_196e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196e80) {
        switch (ctx->pc) {
            case 0x196e90: ctx->pc = 0; goto label_196e90;
            case 0x196e94: ctx->pc = 0; goto label_196e94;
            case 0x196e9c: ctx->pc = 0; goto label_196e9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196e80: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        goto label_196e94;
    }
    // 0x196e88: 0x10000004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_196e9c;
    }
label_196e90:
    // 0x196e90: 0x8e020050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
label_196e94:
    // 0x196e94: 0x511026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x196e98: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_196e9c:
    // 0x196e9c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x196ea0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x196ea4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x196ea8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdatePuffer__FP6PUFFERf
// Address: 0x196eb0 - 0x196ee4

void entry_196ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196ee4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x196ee8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x196eec: 0xc06eca4
    SET_GPR_U32(ctx, 31, 0x196ef4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime); return;
}


// Function: entry_196ef4
// Address: 0x196ef4 - 0x196f98

void entry_196ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x196ef4) {
        switch (ctx->pc) {
            case 0x196f14: ctx->pc = 0; goto label_196f14;
            case 0x196f34: ctx->pc = 0; goto label_196f34;
            case 0x196f40: ctx->pc = 0; goto label_196f40;
            case 0x196f90: ctx->pc = 0; goto label_196f90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x196ef4: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_196f14;
    }
    // 0x196efc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x196f00: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x196f04: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x196f08: 0xc461a718
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944536)); ctx->f[1] = *(float*)&val; }
    // 0x196f0c: 0x10000009
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4294944540)); ctx->f[2] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_196f34;
    }
label_196f14:
    // 0x196f14: 0x8e220644
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1604)));
    // 0x196f18: 0x10400009
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_196f40;
    }
    // 0x196f20: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x196f24: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x196f28: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x196f2c: 0xc461a710
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944528)); ctx->f[1] = *(float*)&val; }
    // 0x196f30: 0xc482a714
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4294944532)); ctx->f[2] = *(float*)&val; }
label_196f34:
    // 0x196f34: 0xe620061c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1564), *(uint32_t*)&val); }
    // 0x196f38: 0xe6210628
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1576), *(uint32_t*)&val); }
    // 0x196f3c: 0xe6220624
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 1572), *(uint32_t*)&val); }
label_196f40:
    // 0x196f40: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x196f44: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x196f48: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x196f4c: 0x247e8d20
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 3), 4294937888));
    // 0x196f50: 0x78440000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x196f54: 0x27a300f0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 240));
    // 0x196f58: 0x27a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 16));
    // 0x196f5c: 0xafa300f8
    WRITE32(ADD32(GPR_U32(ctx, 29), 248), GPR_U32(ctx, 3));
    // 0x196f60: 0xafa20100
    WRITE32(ADD32(GPR_U32(ctx, 29), 256), GPR_U32(ctx, 2));
    // 0x196f64: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x196f68: 0x27a200f4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 244));
    // 0x196f6c: 0x7fa40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 4));
    // 0x196f70: 0xafa200fc
    WRITE32(ADD32(GPR_U32(ctx, 29), 252), GPR_U32(ctx, 2));
    // 0x196f74: 0x27b60040
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 64));
    // 0x196f78: 0x27b50030
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 48));
    // 0x196f7c: 0x27b40020
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 32));
    // 0x196f80: 0x27b300c0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 192));
    // 0x196f84: 0x2632064c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 1612));
    // 0x196f88: 0x8fa50100
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x196f8c: 0x0
    // NOP
label_196f90:
    // 0x196f90: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x196f98);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_196f98
// Address: 0x196f98 - 0x196fd0

void entry_196f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196f98: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x196f9c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x196fa0: 0xc463a820
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944800)); ctx->f[3] = *(float*)&val; }
    // 0x196fa4: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x196fa8: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x196fac: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x196fb0: 0xc7a10028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[1] = *(float*)&val; }
    // 0x196fb4: 0xc7a00038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[0] = *(float*)&val; }
    // 0x196fb8: 0xc442a824
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944804)); ctx->f[2] = *(float*)&val; }
    // 0x196fbc: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x196fc0: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x196fc4: 0xe7a00038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    // 0x196fc8: 0xc063582
    SET_GPR_U32(ctx, 31, 0x196fd0);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_196fd0
// Address: 0x196fd0 - 0x196ff8

void entry_196fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196fd0: 0x3c030019
    SET_GPR_U32(ctx, 3, ((uint32_t)25 << 16));
    // 0x196fd4: 0x8faa00f8
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 248)));
    // 0x196fd8: 0x8fab00fc
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 252)));
    // 0x196fdc: 0x24686e48
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 3), 28232));
    // 0x196fe0: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x196fe4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x196fe8: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x196fec: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x196ff0: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x196ff8);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_196ff8
// Address: 0x196ff8 - 0x197014

void entry_196ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x196ff8: 0x8fa700f0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x196ffc: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x197000: 0x8fa800f4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x197004: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x197008: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19700c: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x197014);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_197014
// Address: 0x197014 - 0x197030

void entry_197014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197014: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x197018: 0x1200003d
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x197110; return;
    }
    // 0x197020: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197024: 0x2405001f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 31));
    // 0x197028: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x197030);
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 2));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_197030
// Address: 0x197030 - 0x197060

void entry_197030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197030: 0x10400031
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1970F8; return;
    }
    // 0x197038: 0x8e020278
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 632)));
    // 0x19703c: 0x1040002e
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1970F8; return;
    }
    // 0x197044: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x197048: 0x24668d00
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x19704c: 0x27a400e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 224));
    // 0x197050: 0x7fa200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 2));
    // 0x197054: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x197058: 0xc07b5e0
    SET_GPR_U32(ctx, 31, 0x197060);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    GetNormalVectors__FP6VECTORN30(rdram, ctx, runtime); return;
}


// Function: entry_197060
// Address: 0x197060 - 0x197088

void entry_197060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197060: 0x8e020278
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 632)));
    // 0x197064: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x197068: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x19706c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x197070: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x197074: 0x8c44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x197078: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19707c: 0x260402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x197080: 0xc07cbbc
    SET_GPR_U32(ctx, 31, 0x197088);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2(rdram, ctx, runtime); return;
}


// Function: entry_197088
// Address: 0x197088 - 0x197144

void entry_197088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197088) {
        switch (ctx->pc) {
            case 0x1970e4: ctx->pc = 0; goto label_1970e4;
            case 0x1970f0: ctx->pc = 0; goto label_1970f0;
            case 0x1970f8: ctx->pc = 0; goto label_1970f8;
            case 0x197110: ctx->pc = 0; goto label_197110;
            case 0x197118: ctx->pc = 0; goto label_197118;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197088: 0xdba200c0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x19708c: 0xdba100d0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x197090: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x197094: 0x4bc208ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x197098: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19709c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1970a0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1970a4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1970a8: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1970ac: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1970b0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1970b4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1970b8: 0x7bc20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x1970bc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1970c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1970c4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1970c8: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1970cc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1970d0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1970d4: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1970e4;
    }
    // 0x1970dc: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1970f0;
    }
label_1970e4:
    // 0x1970e4: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1970e8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1970ec: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1970f0:
    // 0x1970f0: 0xfba100b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1970f4: 0xc7a100b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[1] = *(float*)&val; }
label_1970f8:
    // 0x1970f8: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1970fc: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x197100: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x197104: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197108: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_197118;
    }
label_197110:
    // 0x197110: 0x7a220630
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 1584)));
    // 0x197114: 0x7fa200b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 2));
label_197118:
    // 0x197118: 0x3c023e80
    SET_GPR_U32(ctx, 2, ((uint32_t)16000 << 16));
    // 0x19711c: 0x26f70001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 1));
    // 0x197120: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x197124: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x197128: 0xdba200b0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x19712c: 0x26520004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    // 0x197130: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x197134: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x197138: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19713c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x197144);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_197144
// Address: 0x197144 - 0x197188

void entry_197144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197144: 0x2ee20004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 23), 4));
    // 0x197148: 0x1440ff91
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x196F90; return;
    }
    // 0x197150: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x197154: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x197158: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19715c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x197160: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x197164: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x197168: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19716c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x197170: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x197174: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x197178: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19717c: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x197180: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x197188);
    WRITE128(ADD32(GPR_U32(ctx, 17), 1584), _mm_castps_si128(ctx->vu0_vf[2]));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_197188
// Address: 0x197188 - 0x1971b8

void entry_197188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197188: 0x7bbf01a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x19718c: 0x7bbe0190
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x197190: 0x7bb70180
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x197194: 0x7bb60170
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x197198: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x19719c: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1971a0: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1971a4: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1971a8: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1971ac: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1971b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 432));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PpufftChoosePuffer__FP6PUFFER
// Address: 0x1971b8 - 0x197208

void entry_197208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197208: 0x8e10a828
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 4294944808)));
    // 0x19720c: 0x27a50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 320));
    // 0x197210: 0xda220150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x197214: 0x48b01800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    // 0x197218: 0xda210100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x19721c: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x197220: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x197224: 0x8e240670
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1648)));
    // 0x197228: 0xfba10130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19722c: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x197234);
    WRITE128(ADD32(GPR_U32(ctx, 29), 368), _mm_castps_si128(ctx->vu0_vf[3]));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_197234
// Address: 0x197234 - 0x197290

void entry_197234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197234: 0x8e220670
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1648)));
    // 0x197238: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x19723c: 0xdba10120
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x197240: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x197244: 0xd8430040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x197248: 0x24060048
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 72));
    // 0x19724c: 0xdba50100
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x197250: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197254: 0xdba40110
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x197258: 0x24080040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 64));
    // 0x19725c: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x197260: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x197264: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x197268: 0xdba20130
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x19726c: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x197270: 0xdba10140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x197274: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x197278: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19727c: 0xfba10160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x197280: 0x3a0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x197284: 0xc474a830
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944816)); ctx->f[20] = *(float*)&val; }
    // 0x197288: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x197290);
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[3]));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_197290
// Address: 0x197290 - 0x1972dc

void entry_197290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197290) {
        switch (ctx->pc) {
            case 0x1972a8: ctx->pc = 0; goto label_1972a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197290: 0x18400043
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1973A0; return;
    }
    // 0x197298: 0x27b401b0
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 432));
    // 0x19729c: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1972a0: 0x3c160027
    SET_GPR_U32(ctx, 22, ((uint32_t)39 << 16));
    // 0x1972a4: 0x0
    // NOP
label_1972a8:
    // 0x1972a8: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1972ac: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x1972b0: 0x54400039
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
        ctx->pc = 0x197398; return;
    }
    // 0x1972b8: 0x8e020554
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x1972bc: 0x27a60170
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 368));
    // 0x1972c0: 0xc6eca828
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 4294944808)); ctx->f[12] = *(float*)&val; }
    // 0x1972c4: 0x27a70180
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 384));
    // 0x1972c8: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1972cc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1972d0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1972d4: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x1972dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1972dc
// Address: 0x1972dc - 0x1972e8

void entry_1972dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1972dc: 0x8e040554
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x1972e0: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1972e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1972e8
// Address: 0x1972e8 - 0x19733c

void entry_1972e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1972e8: 0xdba101b0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x1972ec: 0x27a40150
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 336));
    // 0x1972f0: 0xdba20160
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1972f4: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1972f8: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1972fc: 0xdba50180
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x197300: 0xfba101b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 432), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x197304: 0x27a601c0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 448));
    // 0x197308: 0xdba40190
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x19730c: 0x27a701e0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 480));
    // 0x197310: 0xdba301a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x197314: 0x27a801e4
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 484));
    // 0x197318: 0x8e020554
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x19731c: 0xdba20170
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x197320: 0xd8410040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x197324: 0x4bc129bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x197328: 0x4bc120bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19732c: 0x4bc1184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x197330: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x197334: 0xc0618c8
    SET_GPR_U32(ctx, 31, 0x19733c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 448), _mm_castps_si128(ctx->vu0_vf[1]));
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime); return;
}


// Function: entry_19733c
// Address: 0x19733c - 0x197368

void entry_19733c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19733c: 0xc7a001e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 484)); ctx->f[0] = *(float*)&val; }
    // 0x197340: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197344: 0x0
    // NOP
    // 0x197348: 0x45000012
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 432)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x197394; return;
    }
    // 0x197350: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x197354: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x197358: 0xfba101d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 464), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19735c: 0xc7ac01d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 468)); ctx->f[12] = *(float*)&val; }
    // 0x197360: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x197368);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 464)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_197368
// Address: 0x197368 - 0x197374

void entry_197368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197368: 0xc62c0618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1560)); ctx->f[12] = *(float*)&val; }
    // 0x19736c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x197374);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_197374
// Address: 0x197374 - 0x1973d8

void entry_197374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197374) {
        switch (ctx->pc) {
            case 0x197394: ctx->pc = 0; goto label_197394;
            case 0x197398: ctx->pc = 0; goto label_197398;
            case 0x1973a0: ctx->pc = 0; goto label_1973a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197374: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x197378: 0xc6c1a82c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 4294944812)); ctx->f[1] = *(float*)&val; }
    // 0x19737c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197380: 0x0
    // NOP
    // 0x197384: 0x45030004
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
        goto label_197398;
    }
    // 0x19738c: 0xc7b401e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 484)); ctx->f[20] = *(float*)&val; }
    // 0x197390: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_197394:
    // 0x197394: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
label_197398:
    // 0x197398: 0x1660ffc3
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1972A8; return;
    }
label_1973a0:
    // 0x1973a0: 0x2a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1973a4: 0x7bbf0270
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 624)));
    // 0x1973a8: 0x7bb70260
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 608)));
    // 0x1973ac: 0x7bb60250
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 592)));
    // 0x1973b0: 0x7bb50240
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x1973b4: 0x7bb40230
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x1973b8: 0x7bb30220
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x1973bc: 0x7bb20210
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x1973c0: 0x7bb10200
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x1973c4: 0x7bb001f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x1973c8: 0xc7b40280
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 640)); ctx->f[20] = *(float*)&val; }
    // 0x1973cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 656));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1973d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1973d8; return;
}


// Function: FUN_001973d8
// Address: 0x1973d8 - 0x19744c

void FUN_001973d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1973d8) {
        switch (ctx->pc) {
            case 0x197424: ctx->pc = 0; goto label_197424;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1973d8: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1973dc: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1973e0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x1973e4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1973e8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1973ec: 0xc4810684
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 1668)); ctx->f[1] = *(float*)&val; }
    // 0x1973f0: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x1973f4: 0xc4800680
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 1664)); ctx->f[0] = *(float*)&val; }
    // 0x1973f8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1973fc: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x197400: 0x460c0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197404: 0x0
    // NOP
    // 0x197408: 0x45010006
    ctx->f[1] = FPU_MOV_S(ctx->f[12]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_197424;
    }
    // 0x197410: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197414: 0x0
    // NOP
    // 0x197418: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_197424;
    }
    // 0x197420: 0x46001046
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
label_197424:
    // 0x197424: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x197428: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x19742c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x197430: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x197434: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x197438: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19743c: 0x24841ef0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    // 0x197440: 0x460c0b02
    ctx->f[12] = FPU_MUL_S(ctx->f[1], ctx->f[12]);
    // 0x197444: 0xc054788
    SET_GPR_U32(ctx, 31, 0x19744c);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    OnDifficultyPlayerDeath(rdram, ctx, runtime); return;
}


// Function: entry_19744c
// Address: 0x19744c - 0x197458

void entry_19744c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19744c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x197450: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00197458
// Address: 0x197458 - 0x197488

void FUN_00197458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197458: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x19745c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x197460: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x197464: 0x14a20017
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        entry_1974c4(rdram, ctx, runtime); return;
    }
    // 0x19746c: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x197470: 0x8e02a904
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4294945028)));
    // 0x197474: 0x8c4406b8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1720)));
    // 0x197478: 0x10800013
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1974C8; return;
    }
    // 0x197480: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x197488);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_197488
// Address: 0x197488 - 0x197498

void entry_197488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197488: 0x8e02a904
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4294945028)));
    // 0x19748c: 0x37a50004
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    // 0x197490: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x197498);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1720)));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_197498
// Address: 0x197498 - 0x1974bc

void entry_197498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197498: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19749c: 0x240303f4
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1012));
    // 0x1974a0: 0x10430008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        entry_1974c4(rdram, ctx, runtime); return;
    }
    // 0x1974a8: 0x10430006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4294945028)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        entry_1974c4(rdram, ctx, runtime); return;
    }
    // 0x1974b0: 0x240503f5
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1013));
    // 0x1974b4: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1974bc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1720)));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1974bc
// Address: 0x1974bc - 0x1974c4

void entry_1974bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1974bc: 0xc065cf6
    SET_GPR_U32(ctx, 31, 0x1974c4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4294945028)));
    FUN_001973d8(rdram, ctx, runtime); return;
}


// Function: entry_1974c4
// Address: 0x1974c4 - 0x1974d8

void entry_1974c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1974c4) {
        switch (ctx->pc) {
            case 0x1974c8: ctx->pc = 0; goto label_1974c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1974c4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1974c8:
    // 0x1974c8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1974cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1974d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1974d8; return;
}


// Function: OnPufferActive__FP6PUFFERiP2PO
// Address: 0x1974d8 - 0x1974e8

void entry_1974e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1974e8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1974ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1974f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1974f8; return;
}


// Function: UpdatePufferActive__FP6PUFFERP3JOYf
// Address: 0x1974f8 - 0x197538

void entry_197538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197538) {
        switch (ctx->pc) {
            case 0x19753c: ctx->pc = 0; goto label_19753c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197538: 0xc6200048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[0] = *(float*)&val; }
label_19753c:
    // 0x19753c: 0xc6010624
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1572)); ctx->f[1] = *(float*)&val; }
    // 0x197540: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x197544: 0xe6000620
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1568), *(uint32_t*)&val); }
    // 0x197548: 0x962200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 170)));
    // 0x19754c: 0x304200c0
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 192));
    // 0x197550: 0x5040001f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1652)));
        ctx->pc = 0x1975D0; return;
    }
    // 0x197558: 0x8e040614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x19755c: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x197564);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_197564
// Address: 0x197564 - 0x197570

void entry_197564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197564: 0x8e040614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x197568: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x197570);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 36));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_197570
// Address: 0x197570 - 0x1975b4

void entry_197570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197570: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x197574: 0x240203db
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 987));
    // 0x197578: 0x54620015
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1652)));
        ctx->pc = 0x1975D0; return;
    }
    // 0x197580: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x197584: 0x54430012
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1652)));
        ctx->pc = 0x1975D0; return;
    }
    // 0x19758c: 0x8e02067c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1660)));
    // 0x197590: 0x1840000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 988));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1975CC; return;
    }
    // 0x197598: 0x8e030668
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1640)));
    // 0x19759c: 0xae000674
    WRITE32(ADD32(GPR_U32(ctx, 16), 1652), GPR_U32(ctx, 0));
    // 0x1975a0: 0x8e040678
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1656)));
    // 0x1975a4: 0x8c6202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 720)));
    // 0x1975a8: 0xac44018c
    WRITE32(ADD32(GPR_U32(ctx, 2), 396), GPR_U32(ctx, 4));
    // 0x1975ac: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x1975b4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_1975b4
// Address: 0x1975b4 - 0x197618

void entry_1975b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1975b4) {
        switch (ctx->pc) {
            case 0x1975cc: ctx->pc = 0; goto label_1975cc;
            case 0x1975d0: ctx->pc = 0; goto label_1975d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1975b4: 0x8e02067c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1660)));
    // 0x1975b8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1975bc: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1975c0: 0xae02067c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1660), GPR_U32(ctx, 2));
    // 0x1975c4: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1975c8: 0xe600068c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1676), *(uint32_t*)&val); }
label_1975cc:
    // 0x1975cc: 0x8e040674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1652)));
label_1975d0:
    // 0x1975d0: 0x10800031
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x197698; return;
    }
    // 0x1975d8: 0xc600068c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1676)); ctx->f[0] = *(float*)&val; }
    // 0x1975dc: 0xc462a834
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944820)); ctx->f[2] = *(float*)&val; }
    // 0x1975e0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1975e4: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x1975e8: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x1975ec: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1975f0: 0x0
    // NOP
    // 0x1975f4: 0x45000028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x197698; return;
    }
    // 0x1975fc: 0xac820550
    WRITE32(ADD32(GPR_U32(ctx, 4), 1360), GPR_U32(ctx, 2));
    // 0x197600: 0x8e030674
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1652)));
    // 0x197604: 0x8c640558
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 1368)));
    // 0x197608: 0x8c850000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19760c: 0x8ca20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 24)));
    // 0x197610: 0x40f809
    SET_GPR_U32(ctx, 31, 0x197618);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_197618
// Address: 0x197618 - 0x19762c

void entry_197618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197618: 0x8e040668
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1640)));
    // 0x19761c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x197620: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x197624: 0x60f809
    SET_GPR_U32(ctx, 31, 0x19762c);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_19762c
// Address: 0x19762c - 0x197658

void entry_19762c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19762c: 0x8e020680
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1664)));
    // 0x197630: 0x8e030684
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1668)));
    // 0x197634: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x197638: 0x43182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x19763c: 0x14600015
    WRITE32(ADD32(GPR_U32(ctx, 16), 1664), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        entry_197694(rdram, ctx, runtime); return;
    }
    // 0x197644: 0x8e0406b8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1720)));
    // 0x197648: 0x50800013
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1652), GPR_U32(ctx, 0));
        ctx->pc = 0x197698; return;
    }
    // 0x197650: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x197658);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 40));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_197658
// Address: 0x197658 - 0x197664

void entry_197658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197658: 0x8e0406b8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1720)));
    // 0x19765c: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x197664);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 44));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_197664
// Address: 0x197664 - 0x197688

void entry_197664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197664: 0x8fa20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x197668: 0x240303f5
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1013));
    // 0x19766c: 0x10430006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        entry_197688(rdram, ctx, runtime); return;
    }
    // 0x197674: 0x50430005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
        ctx->pc = 0x19768C; return;
    }
    // 0x19767c: 0x8e0406b8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1720)));
    // 0x197680: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x197688);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1012));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_197688
// Address: 0x197688 - 0x197694

void entry_197688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197688) {
        switch (ctx->pc) {
            case 0x19768c: ctx->pc = 0; goto label_19768c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197688: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
label_19768c:
    // 0x19768c: 0xc06ae56
    SET_GPR_U32(ctx, 31, 0x197694);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960992));
    StopTimer__FP5TIMER(rdram, ctx, runtime); return;
}


// Function: entry_197694
// Address: 0x197694 - 0x1976a0

void entry_197694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197694) {
        switch (ctx->pc) {
            case 0x197698: ctx->pc = 0; goto label_197698;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197694: 0xae000674
    WRITE32(ADD32(GPR_U32(ctx, 16), 1652), GPR_U32(ctx, 0));
label_197698:
    // 0x197698: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1976a0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1640)));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1976a0
// Address: 0x1976a0 - 0x1976bc

void entry_1976a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1976a0: 0x50400023
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1632)));
        ctx->pc = 0x197730; return;
    }
    // 0x1976a8: 0x8e020674
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1652)));
    // 0x1976ac: 0x54400028
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1720)));
        ctx->pc = 0x197750; return;
    }
    // 0x1976b4: 0xc065c6e
    SET_GPR_U32(ctx, 31, 0x1976bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PpufftChoosePuffer__FP6PUFFER(rdram, ctx, runtime); return;
}


// Function: entry_1976bc
// Address: 0x1976bc - 0x1976d0

void entry_1976bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1976bc: 0x10400023
    WRITE32(ADD32(GPR_U32(ctx, 16), 1652), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19774C; return;
    }
    // 0x1976c4: 0x8c440554
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1364)));
    // 0x1976c8: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1976d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1976d0
// Address: 0x1976d0 - 0x1976ec

void entry_1976d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1976d0: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1976d4: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1976d8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1976dc: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1976e0: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1976e4: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1976ec);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1976ec
// Address: 0x1976ec - 0x197758

void entry_1976ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1976ec) {
        switch (ctx->pc) {
            case 0x197730: ctx->pc = 0; goto label_197730;
            case 0x19774c: ctx->pc = 0; goto label_19774c;
            case 0x197750: ctx->pc = 0; goto label_197750;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1976ec: 0xe6000618
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1560), *(uint32_t*)&val); }
    // 0x1976f0: 0x8e040674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1652)));
    // 0x1976f4: 0x8e050664
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1636)));
    // 0x1976f8: 0x8c820554
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1364)));
    // 0x1976fc: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x197700: 0xaca30024
    WRITE32(ADD32(GPR_U32(ctx, 5), 36), GPR_U32(ctx, 3));
    // 0x197704: 0x8e040674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1652)));
    // 0x197708: 0x8e050664
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1636)));
    // 0x19770c: 0x8c830554
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1364)));
    // 0x197710: 0x78620040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x197714: 0x7ca20030
    WRITE128(ADD32(GPR_U32(ctx, 5), 48), GPR_VEC(ctx, 2));
    // 0x197718: 0x8e030668
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1640)));
    // 0x19771c: 0x8e040674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1652)));
    // 0x197720: 0x8c6502d0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 720)));
    // 0x197724: 0x8c82055c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1372)));
    // 0x197728: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 5), 396), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19774c;
    }
label_197730:
    // 0x197730: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x197734: 0x8e050664
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1636)));
    // 0x197738: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x19773c: 0xaca40024
    WRITE32(ADD32(GPR_U32(ctx, 5), 36), GPR_U32(ctx, 4));
    // 0x197740: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x197744: 0x8e040664
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1636)));
    // 0x197748: 0x7c830030
    WRITE128(ADD32(GPR_U32(ctx, 4), 48), GPR_VEC(ctx, 3));
label_19774c:
    // 0x19774c: 0x8e0406b8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1720)));
label_197750:
    // 0x197750: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x197758);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_197758
// Address: 0x197758 - 0x197770

void entry_197758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197758: 0x8fa30030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19775c: 0x240203f3
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1011));
    // 0x197760: 0x14620004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x197774; return;
    }
    // 0x197768: 0xc065e12
    SET_GPR_U32(ctx, 31, 0x197770);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00197848(rdram, ctx, runtime); return;
}


// Function: entry_197770
// Address: 0x197770 - 0x197788

void entry_197770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197770) {
        switch (ctx->pc) {
            case 0x197774: ctx->pc = 0; goto label_197774;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197770: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_197774:
    // 0x197774: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x197778: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19777c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x197784: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x197788; return;
}


// Function: FUN_00197788
// Address: 0x197788 - 0x19779c

void FUN_00197788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197788: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x19778c: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x197790: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x197794: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x19779c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 1720)));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_19779c
// Address: 0x19779c - 0x1977b4

void entry_19779c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19779c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1977a0: 0x240203f3
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1011));
    // 0x1977a4: 0x14620004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1977B8; return;
    }
    // 0x1977ac: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x1977b4);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1977b4
// Address: 0x1977b4 - 0x1977d0

void entry_1977b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1977b4) {
        switch (ctx->pc) {
            case 0x1977b8: ctx->pc = 0; goto label_1977b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1977b4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_1977b8:
    // 0x1977b8: 0x10800011
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x197800; return;
    }
    // 0x1977c0: 0x8c83d348
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294955848)));
    // 0x1977c4: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1977c8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1977d0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294955848));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1977d0
// Address: 0x1977d0 - 0x1977e4

void entry_1977d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1977d0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1977d4: 0x8c83e4e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294960352)));
    // 0x1977d8: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1977dc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1977e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960352));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1977e4
// Address: 0x1977e4 - 0x1977f8

void entry_1977e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1977e4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1977e8: 0x8c83e760
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294960992)));
    // 0x1977ec: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1977f0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1977f8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960992));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1977f8
// Address: 0x1977f8 - 0x197810

void entry_1977f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1977f8) {
        switch (ctx->pc) {
            case 0x197800: ctx->pc = 0; goto label_197800;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1977f8: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19783C; return;
    }
label_197800:
    // 0x197800: 0x8c83d348
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294955848)));
    // 0x197804: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x197808: 0x40f809
    SET_GPR_U32(ctx, 31, 0x197810);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294955848));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_197810
// Address: 0x197810 - 0x197824

void entry_197810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197810: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x197814: 0x8c83e4e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294960352)));
    // 0x197818: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x19781c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x197824);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960352));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_197824
// Address: 0x197824 - 0x197838

void entry_197824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197824: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x197828: 0x8c83e760
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294960992)));
    // 0x19782c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x197830: 0x40f809
    SET_GPR_U32(ctx, 31, 0x197838);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960992));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_197838
// Address: 0x197838 - 0x197848

void entry_197838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197838) {
        switch (ctx->pc) {
            case 0x19783c: ctx->pc = 0; goto label_19783c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197838: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_19783c:
    // 0x19783c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x197844: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x197848; return;
}


// Function: FUN_00197848
// Address: 0x197848 - 0x1978c0

void FUN_00197848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197848) {
        switch (ctx->pc) {
            case 0x197898: ctx->pc = 0; goto label_197898;
            case 0x1978a0: ctx->pc = 0; goto label_1978a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197848: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x19784c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x197850: 0x7fb40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 20));
    // 0x197854: 0x7fb30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 19));
    // 0x197858: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19785c: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x197860: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x197864: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x197868: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x19786c: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x197870: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x197874: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x197878: 0xc6600698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 1688)); ctx->f[0] = *(float*)&val; }
    // 0x19787c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197880: 0x0
    // NOP
    // 0x197884: 0x45010059
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1979EC; return;
    }
    // 0x19788c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197890: 0x10000003
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1978a0;
    }
label_197898:
    // 0x197898: 0x24710004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 3), 4));
    // 0x19789c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
label_1978a0:
    // 0x1978a0: 0x8e620690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1680)));
    // 0x1978a4: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1978a8: 0x1040000c
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1978DC; return;
    }
    // 0x1978b0: 0x8e620694
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1684)));
    // 0x1978b4: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1978b8: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1978c0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1978c0
// Address: 0x1978c0 - 0x1978f8

void entry_1978c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1978c0) {
        switch (ctx->pc) {
            case 0x1978dc: ctx->pc = 0; goto label_1978dc;
            case 0x1978e4: ctx->pc = 0; goto label_1978e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1978c0: 0x1440fff5
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x197898; return;
    }
    // 0x1978c8: 0x8e620690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1680)));
    // 0x1978cc: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1978d0: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1684)));
        goto label_1978e4;
    }
    // 0x1978d8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
label_1978dc:
    // 0x1978dc: 0x10000041
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294953060)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1979E4; return;
    }
label_1978e4:
    // 0x1978e4: 0x2670069c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 1692));
    // 0x1978e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1978ec: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1978f0: 0xc0549f6
    SET_GPR_U32(ctx, 31, 0x1978f8);
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    CPvDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_1978f8
// Address: 0x1978f8 - 0x197904

void entry_1978f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1978f8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1978fc: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x197904);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294967295));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_197904
// Address: 0x197904 - 0x19793c

void entry_197904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197904) {
        switch (ctx->pc) {
            case 0x197910: ctx->pc = 0; goto label_197910;
            case 0x19792c: ctx->pc = 0; goto label_19792c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197904: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197908: 0x18400008
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 1692)));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_19792c;
    }
label_197910:
    // 0x197910: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x197914: 0x0
    // NOP
    // 0x197918: 0x0
    // NOP
    // 0x19791c: 0x0
    // NOP
    // 0x197920: 0x0
    // NOP
    // 0x197924: 0x1440fffa
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 1384)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_197910;
    }
label_19792c:
    // 0x19792c: 0x1220002f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1979EC; return;
    }
    // 0x197934: 0xc054980
    SET_GPR_U32(ctx, 31, 0x19793c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_19793c
// Address: 0x19793c - 0x197948

void entry_19793c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19793c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x197940: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x197948);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 1704));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_197948
// Address: 0x197948 - 0x197958

void entry_197948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197948: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x19794c: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x197950: 0x40f809
    SET_GPR_U32(ctx, 31, 0x197958);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_197958
// Address: 0x197958 - 0x19796c

void entry_197958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197958: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x19795c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x197960: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x197964: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19796c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19796c
// Address: 0x19796c - 0x197980

void entry_19796c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19796c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x197970: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x197974: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x197978: 0x40f809
    SET_GPR_U32(ctx, 31, 0x197980);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 272));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_197980
// Address: 0x197980 - 0x19799c

void entry_197980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197980: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x197984: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x197988: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x19798c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x197990: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x197994: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19799c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19799c
// Address: 0x19799c - 0x1979b0

void entry_19799c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19799c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1979a0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1979a4: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1979a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1979b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1979b0
// Address: 0x1979b0 - 0x1979c0

void entry_1979b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1979b0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1979b4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1979b8: 0xc0723c8
    SET_GPR_U32(ctx, 31, 0x1979c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    SetStepguardSgs__FP9STEPGUARD3SGSP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_1979c0
// Address: 0x1979c0 - 0x1979d0

void entry_1979c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1979c0: 0xae510c14
    WRITE32(ADD32(GPR_U32(ctx, 18), 3092), GPR_U32(ctx, 17));
    // 0x1979c4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1979c8: 0xc069da8
    SET_GPR_U32(ctx, 31, 0x1979d0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetRostRosts__FP4ROST5ROSTS(rdram, ctx, runtime); return;
}


// Function: entry_1979d0
// Address: 0x1979d0 - 0x197a08

void entry_1979d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1979d0) {
        switch (ctx->pc) {
            case 0x1979e4: ctx->pc = 0; goto label_1979e4;
            case 0x1979ec: ctx->pc = 0; goto label_1979ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1979d0: 0x26821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x1979d4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1979d8: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1979dc: 0xc461a838
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944824)); ctx->f[1] = *(float*)&val; }
    // 0x1979e0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
label_1979e4:
    // 0x1979e4: 0xe6600698
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 1688), *(uint32_t*)&val); }
    // 0x1979e8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_1979ec:
    // 0x1979ec: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1979f0: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1979f4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1979f8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1979fc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x197a00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00197a08
// Address: 0x197a08 - 0x197a34

void FUN_00197a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197a08: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x197a0c: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x197a10: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x197a14: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x197a18: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x197a1c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x197a20: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x197a24: 0x8e500c14
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 3092)));
    // 0x197a28: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197a2c: 0xc069da8
    SET_GPR_U32(ctx, 31, 0x197a34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetRostRosts__FP4ROST5ROSTS(rdram, ctx, runtime); return;
}


// Function: entry_197a34
// Address: 0x197a34 - 0x197a40

void entry_197a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197a34: 0x262406a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1704));
    // 0x197a38: 0xc054980
    SET_GPR_U32(ctx, 31, 0x197a40);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_197a40
// Address: 0x197a40 - 0x197a4c

void entry_197a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197a40: 0x2624069c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1692));
    // 0x197a44: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x197a4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_197a4c
// Address: 0x197a4c - 0x197a68

void entry_197a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197a4c: 0xae400c14
    WRITE32(ADD32(GPR_U32(ctx, 18), 3092), GPR_U32(ctx, 0));
    // 0x197a50: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x197a54: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x197a58: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x197a5c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x197a60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00197a68
// Address: 0x197a68 - 0x197a88

void FUN_00197a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197a68: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x197a6c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x197a70: 0xc441a83c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944828)); ctx->f[1] = *(float*)&val; }
    // 0x197a74: 0xc460a840
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944832)); ctx->f[0] = *(float*)&val; }
    // 0x197a78: 0xe4a10098
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 5), 152), *(uint32_t*)&val); }
    // 0x197a7c: 0x3e00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 148), *(uint32_t*)&val); }
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x197a84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x197a88; return;
}


// Function: AddPufferWaterAcceleration__FP6PUFFERP5WATERf
// Address: 0x197a88 - 0x197ae4

void entry_197ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197ae4: 0x8e620278
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 632)));
    // 0x197ae8: 0x10400031
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x197BB0; return;
    }
    // 0x197af0: 0x7ba20050
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x197af4: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x197af8: 0x27b10070
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 112));
    // 0x197afc: 0x26108d20
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937888));
    // 0x197b00: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x197b04: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    // 0x197b08: 0x27a40090
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 144));
    // 0x197b0c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197b10: 0x24c68d00
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937856));
    // 0x197b14: 0xc07b5e0
    SET_GPR_U32(ctx, 31, 0x197b1c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GetNormalVectors__FP6VECTORN30(rdram, ctx, runtime); return;
}


// Function: entry_197b1c
// Address: 0x197b1c - 0x197b44

void entry_197b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197b1c: 0x8e620278
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 632)));
    // 0x197b20: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x197b24: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x197b28: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x197b2c: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x197b30: 0x8c44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x197b34: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197b38: 0xc0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x197b3c: 0xc07cbbc
    SET_GPR_U32(ctx, 31, 0x197b44);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    WarpWrTransform__FP2WRfP6VECTORP7MATRIX3T2T3T2(rdram, ctx, runtime); return;
}


// Function: entry_197b44
// Address: 0x197b44 - 0x197c14

void entry_197b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197b44) {
        switch (ctx->pc) {
            case 0x197ba0: ctx->pc = 0; goto label_197ba0;
            case 0x197bac: ctx->pc = 0; goto label_197bac;
            case 0x197bb0: ctx->pc = 0; goto label_197bb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197b44: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x197b48: 0xdba10080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x197b4c: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x197b50: 0x4bc208ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x197b54: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x197b58: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x197b5c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x197b60: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x197b64: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x197b68: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x197b6c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x197b70: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x197b74: 0x7a100000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x197b78: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x197b7c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x197b80: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x197b84: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x197b88: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x197b8c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197b90: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_197ba0;
    }
    // 0x197b98: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_197bac;
    }
label_197ba0:
    // 0x197ba0: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x197ba4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x197ba8: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_197bac:
    // 0x197bac: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
label_197bb0:
    // 0x197bb0: 0xc6600360
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 864)); ctx->f[0] = *(float*)&val; }
    // 0x197bb4: 0xc6420360
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 864)); ctx->f[2] = *(float*)&val; }
    // 0x197bb8: 0x4480b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 0);
    // 0x197bbc: 0x46001082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x197bc0: 0xc6410364
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 868)); ctx->f[1] = *(float*)&val; }
    // 0x197bc4: 0xc6600364
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 868)); ctx->f[0] = *(float*)&val; }
    // 0x197bc8: 0x46161032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[2], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197bcc: 0x0
    // NOP
    // 0x197bd0: 0x45010013
    ctx->f[20] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    if ((ctx->fcr31 & 0x800000)) {
        entry_197c20(rdram, ctx, runtime); return;
    }
    // 0x197bd8: 0x46001007
    ctx->f[0] = FPU_NEG_S(ctx->f[2]);
    // 0x197bdc: 0xda420350
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 848)));
    // 0x197be0: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x197be4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x197be8: 0x26450440
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 1088));
    // 0x197bec: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197bf0: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x197bf4: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197bf8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197bfc: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x197c00: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x197c04: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x197c08: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x197c0c: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x197c14);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_197c14
// Address: 0x197c14 - 0x197c20

void entry_197c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197c14: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197c18: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x197c20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_197c20
// Address: 0x197c20 - 0x197c40

void entry_197c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197c20: 0x4616a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197c24: 0x0
    // NOP
    // 0x197c28: 0x4501007f
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        entry_197e28(rdram, ctx, runtime); return;
    }
    // 0x197c30: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x197c34: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x197c38: 0xc07bb5a
    SET_GPR_U32(ctx, 31, 0x197c40);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 320));
    CalculateWaterCurrent__FP5WATERP6VECTORN21(rdram, ctx, runtime); return;
}


// Function: entry_197c40
// Address: 0x197c40 - 0x197c64

void entry_197c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197c40: 0xda420150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x197c44: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x197c48: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x197c4c: 0x27a70080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 128));
    // 0x197c50: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x197c54: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x197c58: 0x27a60070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 112));
    // 0x197c5c: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x197c64);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_197c64
// Address: 0x197c64 - 0x197ce8

void entry_197c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197c64) {
        switch (ctx->pc) {
            case 0x197ca0: ctx->pc = 0; goto label_197ca0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197c64: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x197c68: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x197c6c: 0xc440a844
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944836)); ctx->f[0] = *(float*)&val; }
    // 0x197c70: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x197c74: 0x27a70090
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 144));
    // 0x197c78: 0x27b100a0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 160));
    // 0x197c7c: 0x46150040
    ctx->f[1] = FPU_ADD_S(ctx->f[0], ctx->f[21]);
    // 0x197c80: 0x27b40030
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 48));
    // 0x197c84: 0x27b500b0
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 176));
    // 0x197c88: 0x27b600c0
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 192));
    // 0x197c8c: 0x27b700d0
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 208));
    // 0x197c90: 0x27be00e0
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 29), 224));
    // 0x197c94: 0x2463a850
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294944848));
    // 0x197c98: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197c9c: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
label_197ca0:
    // 0x197ca0: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x197ca4: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x197ca8: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x197cac: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x197cb0: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x197cb4: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x197cb8: 0x481fff9
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_197ca0;
    }
    // 0x197cc0: 0xda410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x197cc4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x197cc8: 0xdba20070
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x197ccc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197cd0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x197cd4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197cd8: 0xfba10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x197cdc: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197ce0: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x197ce8);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_197ce8
// Address: 0x197ce8 - 0x197d44

void entry_197ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197ce8) {
        switch (ctx->pc) {
            case 0x197cf8: ctx->pc = 0; goto label_197cf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197ce8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x197cec: 0x200182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197cf0: 0x2442a850
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294944848));
    // 0x197cf4: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
label_197cf8:
    // 0x197cf8: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x197cfc: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x197d00: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x197d04: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x197d08: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x197d0c: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x197d10: 0x481fff9
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_197cf8;
    }
    // 0x197d18: 0xdba20080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x197d1c: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x197d20: 0xda410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x197d24: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x197d28: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x197d2c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197d30: 0xfba100a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x197d34: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197d38: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197d3c: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x197d44);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_197d44
// Address: 0x197d44 - 0x197d70

void entry_197d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197d44: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x197d48: 0xda420160
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x197d4c: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x197d50: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x197d54: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x197d58: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x197d5c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x197d60: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x197d64: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x197d68: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x197d70);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_197d70
// Address: 0x197d70 - 0x197dcc

void entry_197d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197d70) {
        switch (ctx->pc) {
            case 0x197d80: ctx->pc = 0; goto label_197d80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197d70: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x197d74: 0x200182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197d78: 0x2442a860
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294944864));
    // 0x197d7c: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
label_197d80:
    // 0x197d80: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x197d84: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x197d88: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x197d8c: 0x46150002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[21]);
    // 0x197d90: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x197d94: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x197d98: 0x481fff9
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_197d80;
    }
    // 0x197da0: 0xda410160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x197da4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x197da8: 0xdba200b0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x197dac: 0x2e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x197db0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x197db4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197db8: 0xfba100d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x197dbc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197dc0: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197dc4: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x197dcc);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_197dcc
// Address: 0x197dcc - 0x197e28

void entry_197dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197dcc) {
        switch (ctx->pc) {
            case 0x197de0: ctx->pc = 0; goto label_197de0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197dcc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x197dd0: 0x200182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197dd4: 0x2442a860
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294944864));
    // 0x197dd8: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x197ddc: 0x0
    // NOP
label_197de0:
    // 0x197de0: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x197de4: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x197de8: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x197dec: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x197df0: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x197df4: 0x481fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_197de0;
    }
    // 0x197dfc: 0xda410160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x197e00: 0x3c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x197e04: 0xdba200c0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x197e08: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197e0c: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x197e10: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x197e14: 0xfba100e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x197e18: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197e1c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x197e20: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x197e28);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_197e28
// Address: 0x197e28 - 0x197eb8

void entry_197e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197e28: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x197e2c: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197e30: 0x0
    // NOP
    // 0x197e34: 0x45020023
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1396)));
        ctx->pc = 0x197EC4; return;
    }
    // 0x197e3c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x197e40: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x197e44: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197e48: 0x0
    // NOP
    // 0x197e4c: 0x4500001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[1] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x197EC0; return;
    }
    // 0x197e54: 0x3c013f66
    SET_GPR_U32(ctx, 1, ((uint32_t)16230 << 16));
    // 0x197e58: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x197e5c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x197e60: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x197e64: 0x0
    // NOP
    // 0x197e68: 0x45000015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x197EC0; return;
    }
    // 0x197e70: 0xc64e0430
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1072)); ctx->f[14] = *(float*)&val; }
    // 0x197e74: 0xc6420420
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1056)); ctx->f[2] = *(float*)&val; }
    // 0x197e78: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x197e7c: 0xc6400434
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1076)); ctx->f[0] = *(float*)&val; }
    // 0x197e80: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x197e84: 0xc6410424
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1060)); ctx->f[1] = *(float*)&val; }
    // 0x197e88: 0x46027381
    ctx->f[14] = FPU_SUB_S(ctx->f[14], ctx->f[2]);
    // 0x197e8c: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x197e90: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x197e94: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x197e98: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x197e9c: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x197ea0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x197ea4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x197ea8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x197eac: 0x46007380
    ctx->f[14] = FPU_ADD_S(ctx->f[14], ctx->f[0]);
    // 0x197eb0: 0xc0558a2
    SET_GPR_U32(ctx, 31, 0x197eb8);
    ctx->f[14] = FPU_MUL_S(ctx->f[14], ctx->f[3]);
    WakeSoWater__FP2SOP5WATERfP6VECTORT3ff(rdram, ctx, runtime); return;
}


// Function: entry_197eb8
// Address: 0x197eb8 - 0x197ecc

void entry_197eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197eb8) {
        switch (ctx->pc) {
            case 0x197ec0: ctx->pc = 0; goto label_197ec0;
            case 0x197ec4: ctx->pc = 0; goto label_197ec4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197eb8: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x197ED0; return;
    }
label_197ec0:
    // 0x197ec0: 0x8e440574
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1396)));
label_197ec4:
    // 0x197ec4: 0xc06fde2
    SET_GPR_U32(ctx, 31, 0x197ecc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StopSound__FP3AMBi(rdram, ctx, runtime); return;
}


// Function: entry_197ecc
// Address: 0x197ecc - 0x197f10

void entry_197ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197ecc) {
        switch (ctx->pc) {
            case 0x197ed0: ctx->pc = 0; goto label_197ed0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197ecc: 0x7bbf0180
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 384)));
label_197ed0:
    // 0x197ed0: 0x7bbe0170
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x197ed4: 0x7bb70160
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x197ed8: 0x7bb60150
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x197edc: 0x7bb50140
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x197ee0: 0x7bb40130
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x197ee4: 0x7bb30120
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x197ee8: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x197eec: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x197ef0: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x197ef4: 0xc7b701a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 424)); ctx->f[23] = *(float*)&val; }
    // 0x197ef8: 0xc7b601a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 416)); ctx->f[22] = *(float*)&val; }
    // 0x197efc: 0xc7b50198
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 408)); ctx->f[21] = *(float*)&val; }
    // 0x197f00: 0xc7b40190
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 400)); ctx->f[20] = *(float*)&val; }
    // 0x197f04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 432));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x197f0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x197f10; return;
}


// Function: HandlePufferMessage__FP6PUFFER5MSGIDPv
// Address: 0x197f10 - 0x197f34

void entry_197f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x197f34) {
        switch (ctx->pc) {
            case 0x197f58: ctx->pc = 0; goto label_197f58;
            case 0x197f6c: ctx->pc = 0; goto label_197f6c;
            case 0x197f74: ctx->pc = 0; goto label_197f74;
            case 0x197f80: ctx->pc = 0; goto label_197f80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x197f34: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x197f38: 0x1202000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 12));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_197f6c;
    }
    // 0x197f40: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_197f58;
    }
    // 0x197f48: 0x1202000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_197f74;
    }
    // 0x197f50: 0x1000004a
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19807C; return;
    }
label_197f58:
    // 0x197f58: 0x24020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    // 0x197f5c: 0x12020008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_197f80;
    }
    // 0x197f64: 0x10000045
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19807C; return;
    }
label_197f6c:
    // 0x197f6c: 0x10000041
    WRITE32(ADD32(GPR_U32(ctx, 18), 1604), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_198074(rdram, ctx, runtime); return;
    }
label_197f74:
    // 0x197f74: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x197f78: 0x1000003e
    WRITE32(ADD32(GPR_U32(ctx, 18), 1604), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_198074(rdram, ctx, runtime); return;
    }
label_197f80:
    // 0x197f80: 0x8e4206b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1720)));
    // 0x197f84: 0x5622003d
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
        ctx->pc = 0x19807C; return;
    }
    // 0x197f8c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x197f90: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x197f98);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_197f98
// Address: 0x197f98 - 0x197fd8

void entry_197f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197f98: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x197f9c: 0x240203f3
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1011));
    // 0x197fa0: 0x1462001b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1011));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x198010; return;
    }
    // 0x197fa8: 0x2643067c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 1660));
    // 0x197fac: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x197fb0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x197fb4: 0xaca3e744
    WRITE32(ADD32(GPR_U32(ctx, 5), 4294960964), GPR_U32(ctx, 3));
    // 0x197fb8: 0x2442d348
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294955848));
    // 0x197fbc: 0x26460680
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 1664));
    // 0x197fc0: 0x26440684
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 1668));
    // 0x197fc4: 0xac460264
    WRITE32(ADD32(GPR_U32(ctx, 2), 612), GPR_U32(ctx, 6));
    // 0x197fc8: 0xac440268
    WRITE32(ADD32(GPR_U32(ctx, 2), 616), GPR_U32(ctx, 4));
    // 0x197fcc: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x197fd0: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x197fd8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_197fd8
// Address: 0x197fd8 - 0x197fec

void entry_197fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197fd8: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x197fdc: 0xc64c0688
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1672)); ctx->f[12] = *(float*)&val; }
    // 0x197fe0: 0x2610e760
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294960992));
    // 0x197fe4: 0xc06ae24
    SET_GPR_U32(ctx, 31, 0x197fec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetTimer__FP5TIMERf(rdram, ctx, runtime); return;
}


// Function: entry_197fec
// Address: 0x197fec - 0x198000

void entry_197fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x197fec: 0x3c050019
    SET_GPR_U32(ctx, 5, ((uint32_t)25 << 16));
    // 0x197ff0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x197ff4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x197ff8: 0xc06ae4a
    SET_GPR_U32(ctx, 31, 0x198000);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 29784));
    SetTimerExpire__FP5TIMERfPv(rdram, ctx, runtime); return;
}


// Function: entry_198000
// Address: 0x198000 - 0x198008

void entry_198000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198000: 0xc06ae4e
    SET_GPR_U32(ctx, 31, 0x198008);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    StartTimer__FP5TIMER(rdram, ctx, runtime); return;
}


// Function: entry_198008
// Address: 0x198008 - 0x198030

void entry_198008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198008) {
        switch (ctx->pc) {
            case 0x198010: ctx->pc = 0; goto label_198010;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198008: 0x1000001b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198078; return;
    }
label_198010:
    // 0x198010: 0x14400019
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x198078; return;
    }
    // 0x198018: 0x286203f6
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1014));
    // 0x19801c: 0x10400016
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198078; return;
    }
    // 0x198024: 0x2611e760
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 4294960992));
    // 0x198028: 0xc06ae56
    SET_GPR_U32(ctx, 31, 0x198030);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    StopTimer__FP5TIMER(rdram, ctx, runtime); return;
}


// Function: entry_198030
// Address: 0x198030 - 0x198044

void entry_198030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198030: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x198034: 0x8c83d348
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294955848)));
    // 0x198038: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x19803c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x198044);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294955848));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_198044
// Address: 0x198044 - 0x198058

void entry_198044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198044: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x198048: 0x8c83e4e0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294960352)));
    // 0x19804c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x198050: 0x40f809
    SET_GPR_U32(ctx, 31, 0x198058);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294960352));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_198058
// Address: 0x198058 - 0x198068

void entry_198058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198058: 0x8e03e760
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294960992)));
    // 0x19805c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x198060: 0x40f809
    SET_GPR_U32(ctx, 31, 0x198068);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_198068
// Address: 0x198068 - 0x198074

void entry_198068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198068: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x19806c: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x198074);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_198074
// Address: 0x198074 - 0x198090

void entry_198074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198074) {
        switch (ctx->pc) {
            case 0x198078: ctx->pc = 0; goto label_198078;
            case 0x19807c: ctx->pc = 0; goto label_19807c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198074: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_198078:
    // 0x198078: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_19807c:
    // 0x19807c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x198080: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x198084: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19808c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x198090; return;
}


// Function: PostPuffcLoad__FP5PUFFC
// Address: 0x198090 - 0x1980a0

void entry_1980a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1980a0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1980a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1980ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1980b0; return;
}


// Function: PresetPuffcAccel__FP5PUFFCf
// Address: 0x1980b0 - 0x1980f8

void entry_1980f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1980f8: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1980fc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x198100: 0x26220110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 272));
    // 0x198104: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x198108: 0x48a33800
    ctx->vu0_vf[7] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x19810c: 0xd8450020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x198110: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x198114: 0xd8440010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x198118: 0x48a33000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x19811c: 0xda220110
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x198120: 0xc62d0110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 272)); ctx->f[13] = *(float*)&val; }
    // 0x198124: 0xda230640
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1600)));
    // 0x198128: 0xda210150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x19812c: 0x4be618d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x198130: 0xfba60020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x198134: 0x4bc311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x198138: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19813c: 0x4bc328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x198140: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x198144: 0x4a6703bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x198148: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19814c: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x198150: 0xc62c0114
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 276)); ctx->f[12] = *(float*)&val; }
    // 0x198154: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x198158: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19815c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x198164);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[7]));
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_198164
// Address: 0x198164 - 0x198170

void entry_198164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198164: 0xc62c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x198168: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x198170);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_198170
// Address: 0x198170 - 0x1981e4

void entry_198170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198170) {
        switch (ctx->pc) {
            case 0x1981bc: ctx->pc = 0; goto label_1981bc;
            case 0x1981cc: ctx->pc = 0; goto label_1981cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198170: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x198174: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x198178: 0x2443a880
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294944896));
    // 0x19817c: 0xc443a880
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944896)); ctx->f[3] = *(float*)&val; }
    // 0x198180: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x198184: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x198188: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x19818c: 0x24445c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x198190: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x198194: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x198198: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x19819c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1981a0: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1981a4: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1981a8: 0x0
    // NOP
    // 0x1981ac: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1981bc;
    }
    // 0x1981b4: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1981cc;
    }
label_1981bc:
    // 0x1981bc: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1981c0: 0x0
    // NOP
    // 0x1981c4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_1981cc;
    }
label_1981cc:
    // 0x1981cc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1981d0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1981d4: 0xc44ca870
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944880)); ctx->f[12] = *(float*)&val; }
    // 0x1981d8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1981dc: 0xc07b8ac
    SET_GPR_U32(ctx, 31, 0x1981e4);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[3]);
    LimitVectorLength(rdram, ctx, runtime); return;
}


// Function: entry_1981e4
// Address: 0x1981e4 - 0x1981f0

void entry_1981e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1981e4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1981e8: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x1981f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1981f0
// Address: 0x1981f0 - 0x198230

void entry_1981f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1981f0: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x1981f4: 0x54400012
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 1200)));
        ctx->pc = 0x198240; return;
    }
    // 0x1981fc: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x198200: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x198204: 0x3193c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 4));
    // 0x198208: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19820c: 0x5440000c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 1200)));
        ctx->pc = 0x198240; return;
    }
    // 0x198214: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x198218: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19821c: 0x26250440
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1088));
    // 0x198220: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x198224: 0x26260350
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 848));
    // 0x198228: 0xc06e940
    SET_GPR_U32(ctx, 31, 0x198230);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplySoConstraintLocal__FP2SOP6CONSTRP6VECTORN22(rdram, ctx, runtime); return;
}


// Function: entry_198230
// Address: 0x198230 - 0x19823c

void entry_198230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198230: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x198234: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x19823c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_19823c
// Address: 0x19823c - 0x198264

void entry_19823c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19823c) {
        switch (ctx->pc) {
            case 0x198240: ctx->pc = 0; goto label_198240;
            case 0x198250: ctx->pc = 0; goto label_198250;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19823c: 0x8e3004b0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 1200)));
label_198240:
    // 0x198240: 0x12000011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198288; return;
    }
    // 0x198248: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19824c: 0x0
    // NOP
label_198250:
    // 0x198250: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x198254: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x198258: 0x8c6200dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 220)));
    // 0x19825c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x198264);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_198264
// Address: 0x198264 - 0x198284

void entry_198264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198264) {
        switch (ctx->pc) {
            case 0x198278: ctx->pc = 0; goto label_198278;
            case 0x19827c: ctx->pc = 0; goto label_19827c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198264: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x198268: 0x5600fff9
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x198250; return;
    }
    // 0x198270: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198288; return;
    }
label_198278:
    // 0x198278: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_19827c:
    // 0x19827c: 0xc071d6c
    SET_GPR_U32(ctx, 31, 0x198284);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    PresetStepguardAccel__FP9STEPGUARDf(rdram, ctx, runtime); return;
}


// Function: entry_198284
// Address: 0x198284 - 0x1982a0

void entry_198284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198284) {
        switch (ctx->pc) {
            case 0x198288: ctx->pc = 0; goto label_198288;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198284: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_198288:
    // 0x198288: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19828c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x198290: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x198294: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19829c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1982a0; return;
}


// Function: FUN_001982a0
// Address: 0x1982a0 - 0x1982d8

void FUN_001982a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1982a0) {
        switch (ctx->pc) {
            case 0x1982d0: ctx->pc = 0; goto label_1982d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1982a0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1982a4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1982a8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1982ac: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1982b0: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1982b4: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x1982b8: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1982d0;
    }
    // 0x1982c0: 0x50620009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3088)));
        ctx->pc = 0x1982E8; return;
    }
    // 0x1982c8: 0x1000000a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1982F4; return;
    }
label_1982d0:
    // 0x1982d0: 0xc0725ae
    SET_GPR_U32(ctx, 31, 0x1982d8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SggsGetStepguard__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1982d8
// Address: 0x1982d8 - 0x1982fc

void entry_1982d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1982d8) {
        switch (ctx->pc) {
            case 0x1982e8: ctx->pc = 0; goto label_1982e8;
            case 0x1982f4: ctx->pc = 0; goto label_1982f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1982d8: 0x14400006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1982f4;
    }
    // 0x1982e0: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198304; return;
    }
label_1982e8:
    // 0x1982e8: 0x24030010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1982ec: 0x10000004
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198300; return;
    }
label_1982f4:
    // 0x1982f4: 0xc072004
    SET_GPR_U32(ctx, 31, 0x1982fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SgsNextStepguardAI__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1982fc
// Address: 0x1982fc - 0x198318

void entry_1982fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1982fc) {
        switch (ctx->pc) {
            case 0x198300: ctx->pc = 0; goto label_198300;
            case 0x198304: ctx->pc = 0; goto label_198304;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1982fc: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_198300:
    // 0x198300: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_198304:
    // 0x198304: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x198308: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19830c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x198314: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x198318; return;
}


// Function: UpdatePuffcGoal__FP5PUFFCi
// Address: 0x198318 - 0x198370

void entry_198370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198370: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x198374: 0x26050140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 320));
    // 0x198378: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x19837c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x198380: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198384: 0x3c014448
    SET_GPR_U32(ctx, 1, ((uint32_t)17480 << 16));
    // 0x198388: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19838c: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x198390: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x198394: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x198398: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19839c: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1983a0: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1983a4: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1983a8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1983ac: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1983b0: 0x8e040928
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2344)));
    // 0x1983b4: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1983b8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1983bc: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1983c0: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1983c4: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1983c8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1983cc: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1983d0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1983d4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1983d8: 0x4be310d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1983dc: 0xc0646b2
    SET_GPR_U32(ctx, 31, 0x1983e4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    FUN_00191ac8(rdram, ctx, runtime); return;
}


// Function: entry_1983e4
// Address: 0x1983e4 - 0x198400

void entry_1983e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1983e4: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1983e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1983ec: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1983f0: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1983f4: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1983f8: 0xc072106
    SET_GPR_U32(ctx, 31, 0x198400);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_198400
// Address: 0x198400 - 0x198420

void entry_198400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198400) {
        switch (ctx->pc) {
            case 0x198408: ctx->pc = 0; goto label_198408;
            case 0x198418: ctx->pc = 0; goto label_198418;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198400: 0x10000028
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1984A4; return;
    }
label_198408:
    // 0x198408: 0x10a00025
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1984a0(rdram, ctx, runtime); return;
    }
    // 0x198410: 0x8e040928
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2344)));
    // 0x198414: 0x0
    // NOP
label_198418:
    // 0x198418: 0xc06471e
    SET_GPR_U32(ctx, 31, 0x198420);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ChoosePathzoneRandomPoint__FP8PATHZONEP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_198420
// Address: 0x198420 - 0x198484

void entry_198420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198420) {
        switch (ctx->pc) {
            case 0x198460: ctx->pc = 0; goto label_198460;
            case 0x198470: ctx->pc = 0; goto label_198470;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198420: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198424: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x198428: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x19842c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198430: 0xc621a890
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4294944912)); ctx->f[1] = *(float*)&val; }
    // 0x198434: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198438: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19843c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198440: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x198444: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x198448: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19844c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x198450: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x198454: 0x0
    // NOP
    // 0x198458: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_198460;
    }
label_198460:
    // 0x198460: 0x5040ffed
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2344)));
        ctx->pc = 0x198418; return;
    }
    // 0x198468: 0x10000007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198488; return;
    }
label_198470:
    // 0x198470: 0x10a0000b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 320));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1984a0(rdram, ctx, runtime); return;
    }
    // 0x198478: 0x8e040928
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2344)));
    // 0x19847c: 0xc0646a2
    SET_GPR_U32(ctx, 31, 0x198484);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FindPathzoneClosestPoint__FP8PATHZONEP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_198484
// Address: 0x198484 - 0x198490

void entry_198484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198484) {
        switch (ctx->pc) {
            case 0x198488: ctx->pc = 0; goto label_198488;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198484: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_198488:
    // 0x198488: 0xc072106
    SET_GPR_U32(ctx, 31, 0x198490);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetStepguardGoal__FP9STEPGUARDP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_198490
// Address: 0x198490 - 0x1984a0

void entry_198490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198490) {
        switch (ctx->pc) {
            case 0x198498: ctx->pc = 0; goto label_198498;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198490: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1984A4; return;
    }
label_198498:
    // 0x198498: 0xc072302
    SET_GPR_U32(ctx, 31, 0x1984a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateStepguardGoal__FP9STEPGUARDi(rdram, ctx, runtime); return;
}


// Function: entry_1984a0
// Address: 0x1984a0 - 0x1984b8

void entry_1984a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1984a0) {
        switch (ctx->pc) {
            case 0x1984a4: ctx->pc = 0; goto label_1984a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1984a0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1984a4:
    // 0x1984a4: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1984a8: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1984ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1984b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1984b8; return;
}


// Function: OnPuffcExitingSgs__FP5PUFFC3SGS
// Address: 0x1984b8 - 0x1984e4

void entry_1984e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1984e4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1984e8: 0xc065e82
    SET_GPR_U32(ctx, 31, 0x1984f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_00197a08(rdram, ctx, runtime); return;
}


// Function: entry_1984f0
// Address: 0x1984f0 - 0x198510

void entry_1984f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1984f0: 0x7a020150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x1984f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1984f8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1984fc: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x198500: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x198504: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x198508: 0x40f809
    SET_GPR_U32(ctx, 31, 0x198510);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_198510
// Address: 0x198510 - 0x19851c

void entry_198510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198510: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x198514: 0xc072402
    SET_GPR_U32(ctx, 31, 0x19851c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    OnStepguardExitingSgs__FP9STEPGUARD3SGS(rdram, ctx, runtime); return;
}


// Function: entry_19851c
// Address: 0x19851c - 0x198530

void entry_19851c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19851c: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x198520: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x198524: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x198528: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnPuffcEnteringSgs__FP5PUFFC3SGSP4ASEG
// Address: 0x198530 - 0x198544

void entry_198544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198544: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x198548: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x19854c: 0x14620004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x198560; return;
    }
    // 0x198554: 0xc072248
    SET_GPR_U32(ctx, 31, 0x19855c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001c8920(rdram, ctx, runtime); return;
}


// Function: entry_19855c
// Address: 0x19855c - 0x198570

void entry_19855c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19855c) {
        switch (ctx->pc) {
            case 0x198560: ctx->pc = 0; goto label_198560;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19855c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_198560:
    // 0x198560: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198564: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19856c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x198570; return;
}


// Function: UpdatePuffcSgs__FP5PUFFC
// Address: 0x198570 - 0x198584

void entry_198584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198584) {
        switch (ctx->pc) {
            case 0x1985c0: ctx->pc = 0; goto label_1985c0;
            case 0x198620: ctx->pc = 0; goto label_198620;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198584: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x198588: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x19858c: 0x14620053
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1986DC; return;
    }
    // 0x198594: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x198598: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x19859c: 0x8c4623c8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x1985a0: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1985a4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1985a8: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x1985ac: 0x2463a8a0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294944928));
    // 0x1985b0: 0x2484a8c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294944960));
    // 0x1985b4: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1985b8: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1985bc: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
label_1985c0:
    // 0x1985c0: 0xc4c0000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1985c4: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x1985c8: 0xc4820000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[2] = *(float*)&val; }
    // 0x1985cc: 0x46002041
    ctx->f[1] = FPU_SUB_S(ctx->f[4], ctx->f[0]);
    // 0x1985d0: 0xc4630000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[3] = *(float*)&val; }
    // 0x1985d4: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1985d8: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1985dc: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x1985e0: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1985e4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1985e8: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x1985ec: 0x4a1fff4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_1985c0;
    }
    // 0x1985f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1985f8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1985fc: 0x8c4623c8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x198600: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x198604: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x198608: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x19860c: 0xe0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x198610: 0x2463a8b0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294944944));
    // 0x198614: 0x2484a8d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294944976));
    // 0x198618: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19861c: 0x0
    // NOP
label_198620:
    // 0x198620: 0xc4c0000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 12)); ctx->f[0] = *(float*)&val; }
    // 0x198624: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x198628: 0xc4820000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[2] = *(float*)&val; }
    // 0x19862c: 0x46002041
    ctx->f[1] = FPU_SUB_S(ctx->f[4], ctx->f[0]);
    // 0x198630: 0xc4630000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[3] = *(float*)&val; }
    // 0x198634: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x198638: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x19863c: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x198640: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x198644: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x198648: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x19864c: 0x4a1fff4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_198620;
    }
    // 0x198654: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x198658: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x198660);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_198660
// Address: 0x198660 - 0x1986d8

void entry_198660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198660) {
        switch (ctx->pc) {
            case 0x1986c0: ctx->pc = 0; goto label_1986c0;
            case 0x1986d0: ctx->pc = 0; goto label_1986d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198660: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x198664: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x198668: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19866c: 0xc7a20008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[2] = *(float*)&val; }
    // 0x198670: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198674: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198678: 0xc7a10004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[1] = *(float*)&val; }
    // 0x19867c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198680: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x198684: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x198688: 0xc7a30000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[3] = *(float*)&val; }
    // 0x19868c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x198690: 0xc7a40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[4] = *(float*)&val; }
    // 0x198694: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x198698: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x19869c: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1986a0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1986a4: 0x46001b00
    ctx->f[12] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1986a8: 0x46046034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1986ac: 0x0
    // NOP
    // 0x1986b0: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1986c0;
    }
    // 0x1986b8: 0x10000005
    ctx->f[12] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1986d0;
    }
label_1986c0:
    // 0x1986c0: 0x460c2834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1986c4: 0x0
    // NOP
    // 0x1986c8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[5]);
        goto label_1986d0;
    }
label_1986d0:
    // 0x1986d0: 0xc04bdac
    SET_GPR_U32(ctx, 31, 0x1986d8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 2016)));
    SetAsegaSpeed__FP5ASEGAf(rdram, ctx, runtime); return;
}


// Function: entry_1986d8
// Address: 0x1986d8 - 0x1986e8

void entry_1986d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1986d8) {
        switch (ctx->pc) {
            case 0x1986dc: ctx->pc = 0; goto label_1986dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1986d8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1986dc:
    // 0x1986dc: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1986e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandlePuffcMessage__FP5PUFFC5MSGIDPv
// Address: 0x1986e8 - 0x19870c

void entry_19870c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19870c) {
        switch (ctx->pc) {
            case 0x198734: ctx->pc = 0; goto label_198734;
            case 0x198748: ctx->pc = 0; goto label_198748;
            case 0x19874c: ctx->pc = 0; goto label_19874c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19870c: 0x2402000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 10));
    // 0x198710: 0x12020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_198734;
    }
    // 0x198718: 0x1602000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_198748;
    }
    // 0x198720: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x198724: 0x50520008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 18)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 3088), GPR_U32(ctx, 0));
        goto label_198748;
    }
    // 0x19872c: 0x10000007
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19874c;
    }
label_198734:
    // 0x198734: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x198738: 0x14520003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        goto label_198748;
    }
    // 0x198740: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x198744: 0xae420c10
    WRITE32(ADD32(GPR_U32(ctx, 18), 3088), GPR_U32(ctx, 2));
label_198748:
    // 0x198748: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_19874c:
    // 0x19874c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x198750: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198754: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19875c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x198760; return;
}


// Function: UpdatePuffc__FP5PUFFCf
// Address: 0x198760 - 0x198780

void entry_198780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198780: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x198784: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x198788: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x198790);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_198790
// Address: 0x198790 - 0x1987ac

void entry_198790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198790: 0x10400029
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198838; return;
    }
    // 0x198798: 0x8e040640
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1600)));
    // 0x19879c: 0x50800026
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x198838; return;
    }
    // 0x1987a4: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1987ac);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1987ac
// Address: 0x1987ac - 0x1987c0

void entry_1987ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1987ac: 0x10400022
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198838; return;
    }
    // 0x1987b4: 0x8e040640
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1600)));
    // 0x1987b8: 0xc05045c
    SET_GPR_U32(ctx, 31, 0x1987c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    FCheckVolPoint__FP3VOLP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1987c0
// Address: 0x1987c0 - 0x1987e4

void entry_1987c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1987c0: 0x1040001c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198834; return;
    }
    // 0x1987c8: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    // 0x1987cc: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    // 0x1987d0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1987d4: 0xafb10004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 17));
    // 0x1987d8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1987dc: 0xc05de0e
    SET_GPR_U32(ctx, 31, 0x1987e4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1987e4
// Address: 0x1987e4 - 0x198840

void entry_1987e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1987e4) {
        switch (ctx->pc) {
            case 0x198834: ctx->pc = 0; goto label_198834;
            case 0x198838: ctx->pc = 0; goto label_198838;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1987e4: 0x10400013
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_198834;
    }
    // 0x1987ec: 0x8e03067c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1660)));
    // 0x1987f0: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x1987f4: 0x8c45a720
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4294944544)));
    // 0x1987f8: 0xc481c868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4294953064)); ctx->f[1] = *(float*)&val; }
    // 0x1987fc: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x198800: 0xc6000698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1688)); ctx->f[0] = *(float*)&val; }
    // 0x198804: 0x65102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 5)));
    // 0x198808: 0xa2180a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 5));
    // 0x19880c: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x198810: 0x0
    // NOP
    // 0x198814: 0x45000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 1660), GPR_U32(ctx, 3));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_198834;
    }
    // 0x19881c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x198820: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x198824: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x198828: 0xc461a838
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294944824)); ctx->f[1] = *(float*)&val; }
    // 0x19882c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x198830: 0xe6000698
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1688), *(uint32_t*)&val); }
label_198834:
    // 0x198834: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_198838:
    // 0x198838: 0xc071f2e
    SET_GPR_U32(ctx, 31, 0x198840);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    UpdateStepguard__FP9STEPGUARDf(rdram, ctx, runtime); return;
}


// Function: entry_198840
// Address: 0x198840 - 0x198858

void entry_198840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198840: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x198844: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x198848: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19884c: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x198850: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FCanPuffcAttack__FP5PUFFC
// Address: 0x198858 - 0x198860

void FUN_00198860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198860: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x198864: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x198868: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x19886c: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x198870: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x198878);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_198878
// Address: 0x198878 - 0x19888c

void entry_198878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198878: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19887c: 0x12000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198894; return;
    }
    // 0x198884: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x19888c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_19888c
// Address: 0x19888c - 0x198920

void entry_19888c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19888c) {
        switch (ctx->pc) {
            case 0x198894: ctx->pc = 0; goto label_198894;
            case 0x19889c: ctx->pc = 0; goto label_19889c;
            case 0x1988e8: ctx->pc = 0; goto label_1988e8;
            case 0x198904: ctx->pc = 0; goto label_198904;
            case 0x198908: ctx->pc = 0; goto label_198908;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19888c: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
        goto label_19889c;
    }
label_198894:
    // 0x198894: 0x1000001c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_198908;
    }
label_19889c:
    // 0x19889c: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1988a0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1988a4: 0x8e220c18
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3096)));
    // 0x1988a8: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1988ac: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1988b0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1988b4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1988b8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1988bc: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1988c0: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x1988c4: 0x10400008
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1988e8;
    }
    // 0x1988cc: 0xc440a8d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944984)); ctx->f[0] = *(float*)&val; }
    // 0x1988d0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1988d4: 0x0
    // NOP
    // 0x1988d8: 0x4503000a
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 3096), GPR_U32(ctx, 0));
        goto label_198904;
    }
    // 0x1988e0: 0x10000009
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3096)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_198908;
    }
label_1988e8:
    // 0x1988e8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1988ec: 0xc440a8dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944988)); ctx->f[0] = *(float*)&val; }
    // 0x1988f0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1988f4: 0x0
    // NOP
    // 0x1988f8: 0x45000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_198904;
    }
    // 0x198900: 0xae220c18
    WRITE32(ADD32(GPR_U32(ctx, 17), 3096), GPR_U32(ctx, 2));
label_198904:
    // 0x198904: 0x8e220c18
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 3096)));
label_198908:
    // 0x198908: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19890c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x198910: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198914: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19891c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x198920; return;
}


// Function: PostPuffbLoad__FP5PUFFB
// Address: 0x198920 - 0x198940

void entry_198940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198940: 0xc049292
    SET_GPR_U32(ctx, 31, 0x198948);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PostAloLoad__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_198948
// Address: 0x198948 - 0x19895c

void entry_198948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198948: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19894c: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x198950: 0x24060018
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    // 0x198954: 0xc056a0e
    SET_GPR_U32(ctx, 31, 0x19895c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObjectByClass__FP2SWi3CIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19895c
// Address: 0x19895c - 0x198980

void entry_19895c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19895c) {
        switch (ctx->pc) {
            case 0x198974: ctx->pc = 0; goto label_198974;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19895c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x198960: 0x10600004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_198974;
    }
    // 0x198968: 0x8c620684
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1668)));
    // 0x19896c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x198970: 0xac620684
    WRITE32(ADD32(GPR_U32(ctx, 3), 1668), GPR_U32(ctx, 2));
label_198974:
    // 0x198974: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198978: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitSprize__FP6SPRIZE
// Address: 0x198980 - 0x198994

void entry_198994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198994: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x198998: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19899c: 0xae020554
    WRITE32(ADD32(GPR_U32(ctx, 16), 1364), GPR_U32(ctx, 2));
    // 0x1989a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1989a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1989ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1989b0; return;
}


// Function: LoadSprizeFromBrx__FP6SPRIZEP18CBinaryInputStream
// Address: 0x1989b0 - 0x1989cc

void entry_1989cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1989cc: 0x26040584
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1412));
    // 0x1989d0: 0xc05651e
    SET_GPR_U32(ctx, 31, 0x1989d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InferExpl__FPP4EXPLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1989d8
// Address: 0x1989d8 - 0x198a48

void entry_1989d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1989d8) {
        switch (ctx->pc) {
            case 0x198a18: ctx->pc = 0; goto label_198a18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1989d8: 0x26030034
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 52));
    // 0x1989dc: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x1989e0: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x1989e4: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1989e8: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1989ec: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x1989f0: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1989f4: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x1989f8: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x1989fc: 0x8e030034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x198a00: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x198a04: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x198a08: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x198a0c: 0x10a00015
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198A64; return;
    }
    // 0x198a14: 0x26110574
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1396));
label_198a18:
    // 0x198a18: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x198a1c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x198a20: 0x30420040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64));
    // 0x198a24: 0x10400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_198a48(rdram, ctx, runtime); return;
    }
    // 0x198a2c: 0x8e030570
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1392)));
    // 0x198a30: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x198a34: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x198a38: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x198a3c: 0xac450000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 5));
    // 0x198a40: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x198a48);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1392), GPR_U32(ctx, 3));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_198a48
// Address: 0x198a48 - 0x198a88

void entry_198a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198a48) {
        switch (ctx->pc) {
            case 0x198a64: ctx->pc = 0; goto label_198a64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198a48: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x198a4c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x198a50: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x198a54: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x198a58: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x198a5c: 0x14a0ffee
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x198A18; return;
    }
label_198a64:
    // 0x198a64: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x198a68: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x198a6c: 0xae42b314
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294947604), GPR_U32(ctx, 2));
    // 0x198a70: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x198a74: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x198a78: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x198a7c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x198a84: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x198a88; return;
}


// Function: BindSprize__FP6SPRIZE
// Address: 0x198a88 - 0x198aac

void entry_198aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198aac) {
        switch (ctx->pc) {
            case 0x198ac0: ctx->pc = 0; goto label_198ac0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198aac: 0x8e02055c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
    // 0x198ab0: 0x18400015
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 1396));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x198B08; return;
    }
    // 0x198ab8: 0x26110560
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1376));
    // 0x198abc: 0x0
    // NOP
label_198ac0:
    // 0x198ac0: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x198ac4: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x198ac8: 0xc056912
    SET_GPR_U32(ctx, 31, 0x198ad0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_198ad0
// Address: 0x198ad0 - 0x198b28

void entry_198ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198ad0) {
        switch (ctx->pc) {
            case 0x198af8: ctx->pc = 0; goto label_198af8;
            case 0x198b08: ctx->pc = 0; goto label_198b08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198ad0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x198ad4: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
        goto label_198af8;
    }
    // 0x198adc: 0x8e030570
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1392)));
    // 0x198ae0: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x198ae4: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x198ae8: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x198aec: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
    // 0x198af0: 0xae030570
    WRITE32(ADD32(GPR_U32(ctx, 16), 1392), GPR_U32(ctx, 3));
    // 0x198af4: 0x8e02055c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
label_198af8:
    // 0x198af8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x198afc: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x198b00: 0x1440ffef
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x198AC0; return;
    }
label_198b08:
    // 0x198b08: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x198b0c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x198b10: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x198b14: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x198b18: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198b1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x198b24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x198b28; return;
}


// Function: PostSprizeLoad__FP6SPRIZE
// Address: 0x198b28 - 0x198b50

void entry_198b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198b50) {
        switch (ctx->pc) {
            case 0x198b60: ctx->pc = 0; goto label_198b60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198b50: 0x8e220570
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1392)));
    // 0x198b54: 0x1840000e
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x198B90; return;
    }
    // 0x198b5c: 0x26320574
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 1396));
label_198b60:
    // 0x198b60: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x198b64: 0xc04b26a
    SET_GPR_U32(ctx, 31, 0x198b6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FWipingAseg__FP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_198b6c
// Address: 0x198b6c - 0x198b80

void entry_198b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198b6c) {
        switch (ctx->pc) {
            case 0x198b74: ctx->pc = 0; goto label_198b74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198b6c: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1368), GPR_U32(ctx, 20));
        goto label_198b74;
    }
label_198b74:
    // 0x198b74: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x198b78: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x198b80);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_198b80
// Address: 0x198b80 - 0x198ba0

void entry_198b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198b80) {
        switch (ctx->pc) {
            case 0x198b90: ctx->pc = 0; goto label_198b90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198b80: 0x8e220570
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1392)));
    // 0x198b84: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x198b88: 0x1440fff5
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x198B60; return;
    }
label_198b90:
    // 0x198b90: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x198b94: 0x8c620130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 304)));
    // 0x198b98: 0x40f809
    SET_GPR_U32(ctx, 31, 0x198ba0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_198ba0
// Address: 0x198ba0 - 0x198bb8

void entry_198ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198ba0: 0x14400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x198BBC; return;
    }
    // 0x198ba8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x198bac: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x198bb0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x198bb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_198bb8
// Address: 0x198bb8 - 0x198bd8

void entry_198bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198bb8) {
        switch (ctx->pc) {
            case 0x198bbc: ctx->pc = 0; goto label_198bbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198bb8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_198bbc:
    // 0x198bbc: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x198bc0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x198bc4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x198bc8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x198bcc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198bd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateSprize__FP6SPRIZEf
// Address: 0x198bd8 - 0x198bf4

void entry_198bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198bf4: 0x8e32059c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 1436)));
    // 0x198bf8: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x198c00);
    WRITE32(ADD32(GPR_U32(ctx, 17), 1436), GPR_U32(ctx, 0));
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_198c00
// Address: 0x198c00 - 0x198c1c

void entry_198c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198c00: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x198c04: 0x12000062
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198D90; return;
    }
    // 0x198c0c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x198c10: 0x8c620130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 304)));
    // 0x198c14: 0x40f809
    SET_GPR_U32(ctx, 31, 0x198c1c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_198c1c
// Address: 0x198c1c - 0x198ca8

void entry_198c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198c1c) {
        switch (ctx->pc) {
            case 0x198c8c: ctx->pc = 0; goto label_198c8c;
            case 0x198c98: ctx->pc = 0; goto label_198c98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198c1c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x198c20: 0x1443005b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x198D90; return;
    }
    // 0x198c28: 0x8e020580
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1408)));
    // 0x198c2c: 0x10400058
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1408));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198D90; return;
    }
    // 0x198c34: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x198c38: 0x50400056
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
        ctx->pc = 0x198D94; return;
    }
    // 0x198c40: 0x56400015
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        goto label_198c98;
    }
    // 0x198c48: 0xc6200550
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1360)); ctx->f[0] = *(float*)&val; }
    // 0x198c4c: 0xc6010014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[1] = *(float*)&val; }
    // 0x198c50: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x198c54: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x198c58: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x198c5c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198c60: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198c64: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x198c68: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198c6c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x198c70: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x198c74: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x198c78: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x198c7c: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x198c80: 0x0
    // NOP
    // 0x198c84: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_198c8c;
    }
label_198c8c:
    // 0x198c8c: 0x14600040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x198D90; return;
    }
    // 0x198c94: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_198c98:
    // 0x198c98: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x198c9c: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x198ca0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x198ca8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_198ca8
// Address: 0x198ca8 - 0x198d7c

void entry_198ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198ca8) {
        switch (ctx->pc) {
            case 0x198d30: ctx->pc = 0; goto label_198d30;
            case 0x198d3c: ctx->pc = 0; goto label_198d3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198ca8: 0x8e030018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x198cac: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x198cb0: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x198cb4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x198cb8: 0xd8620140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x198cbc: 0x8c42a910
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4294945040)));
    // 0x198cc0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198cc4: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x198cc8: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x198ccc: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x198cd0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x198cd4: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x198cd8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x198cdc: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x198ce0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x198ce4: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x198ce8: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x198cec: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198cf0: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x198cf4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x198cf8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198cfc: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x198d00: 0xd8440150
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 336)));
    // 0x198d04: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x198d08: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x198d0c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x198d10: 0xfba50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x198d14: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x198d18: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x198d1c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x198d20: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_198d30;
    }
    // 0x198d28: 0x10000004
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_198d3c;
    }
label_198d30:
    // 0x198d30: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x198d34: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x198d38: 0x4be018dc
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_198d3c:
    // 0x198d3c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x198d40: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x198d44: 0x8c63a914
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4294945044)));
    // 0x198d48: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x198d4c: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x198d50: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x198d54: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x198d58: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x198d5c: 0x4be518bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x198d60: 0x4be20848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x198d64: 0xf8a10000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x198d68: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x198d6c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x198d70: 0x8c430090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x198d74: 0x60f809
    SET_GPR_U32(ctx, 31, 0x198d7c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_198d7c
// Address: 0x198d7c - 0x198d8c

void entry_198d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198d7c: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x198d80: 0x8ca20134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 308)));
    // 0x198d84: 0x40f809
    SET_GPR_U32(ctx, 31, 0x198d8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_198d8c
// Address: 0x198d8c - 0x198da8

void entry_198d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198d8c) {
        switch (ctx->pc) {
            case 0x198d90: ctx->pc = 0; goto label_198d90;
            case 0x198d94: ctx->pc = 0; goto label_198d94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198d8c: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_198d90:
    // 0x198d90: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_198d94:
    // 0x198d94: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x198d98: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x198d9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x198da4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x198da8; return;
}


// Function: CollectSprize__FP6SPRIZE
// Address: 0x198da8 - 0x198dd0

void entry_198dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198dd0) {
        switch (ctx->pc) {
            case 0x198df0: ctx->pc = 0; goto label_198df0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198dd0: 0x8e500570
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 1392)));
    // 0x198dd4: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x198dd8: 0x6000010
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    if (GPR_S32(ctx, 16) < 0) {
        ctx->pc = 0x198E1C; return;
    }
    // 0x198de0: 0x24420574
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1396));
    // 0x198de4: 0x528821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x198de8: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x198dec: 0x0
    // NOP
label_198df0:
    // 0x198df0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x198df4: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x198df8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x198dfc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x198e00: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x198e04: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x198e08: 0x2631fffc
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967292));
    // 0x198e0c: 0xc04b23e
    SET_GPR_U32(ctx, 31, 0x198e14);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    PasegaEnsureAseg__FP4ASEGP3ALO4SEEKffi(rdram, ctx, runtime); return;
}


// Function: entry_198e14
// Address: 0x198e14 - 0x198e2c

void entry_198e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198e14) {
        switch (ctx->pc) {
            case 0x198e1c: ctx->pc = 0; goto label_198e1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198e14: 0x603fff6
    if (GPR_S32(ctx, 16) >= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x198DF0; return;
    }
label_198e1c:
    // 0x198e1c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x198e20: 0x8c620138
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 312)));
    // 0x198e24: 0x40f809
    SET_GPR_U32(ctx, 31, 0x198e2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_198e2c
// Address: 0x198e2c - 0x198e40

void entry_198e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198e2c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x198e30: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x198e34: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x198e38: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x198e40);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_198e40
// Address: 0x198e40 - 0x198e58

void entry_198e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198e40: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x198e44: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x198e48: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x198e4c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198e50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EmitSprizeExplosion__FP6SPRIZE
// Address: 0x198e58 - 0x198e88

void entry_198e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198e88: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x198e8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x198e94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x198e98; return;
}


// Function: PcsFromSprize__FP6SPRIZE
// Address: 0x198e98 - 0x198eac

void entry_198eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198eac) {
        switch (ctx->pc) {
            case 0x198ec4: ctx->pc = 0; goto label_198ec4;
            case 0x198ec8: ctx->pc = 0; goto label_198ec8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198eac: 0x10400005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_198ec4;
    }
    // 0x198eb4: 0x8e040554
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x198eb8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x198ebc: 0x10000002
    if (GPR_U32(ctx, 4) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_198ec8;
    }
label_198ec4:
    // 0x198ec4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_198ec8:
    // 0x198ec8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x198ecc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198ed0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddSprizeAseg__FP6SPRIZE3OID
// Address: 0x198ed8 - 0x198ef8

void entry_198f1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198f1c) {
        switch (ctx->pc) {
            case 0x198f40: ctx->pc = 0; goto label_198f40;
            case 0x198f50: ctx->pc = 0; goto label_198f50;
            case 0x198f64: ctx->pc = 0; goto label_198f64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198f1c: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x198f20: 0x1602001e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x198F9C; return;
    }
    // 0x198f28: 0x8e220570
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1392)));
    // 0x198f2c: 0x1840000d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_198f64;
    }
    // 0x198f34: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x198f38: 0x26240588
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1416));
    // 0x198f3c: 0x0
    // NOP
label_198f40:
    // 0x198f40: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x198f44: 0x8c82ffec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294967276)));
    // 0x198f48: 0x50620001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 6));
        goto label_198f50;
    }
label_198f50:
    // 0x198f50: 0x8e220570
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1392)));
    // 0x198f54: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x198f58: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x198f5c: 0x1440fff8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_198f40;
    }
label_198f64:
    // 0x198f64: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x198f68: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x198f6c: 0x1080000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x198F9C; return;
    }
    // 0x198f74: 0x8c822230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8752)));
    // 0x198f78: 0x16420009
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x198FA0; return;
    }
    // 0x198f80: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x198f84: 0x8c430070
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 112)));
    // 0x198f88: 0x60f809
    SET_GPR_U32(ctx, 31, 0x198f90);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_198f90
// Address: 0x198f90 - 0x198fb0

void entry_198f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198f90) {
        switch (ctx->pc) {
            case 0x198f9c: ctx->pc = 0; goto label_198f9c;
            case 0x198fa0: ctx->pc = 0; goto label_198fa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198f90: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x198f94: 0xae220598
    WRITE32(ADD32(GPR_U32(ctx, 17), 1432), GPR_U32(ctx, 2));
    // 0x198f98: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_198f9c:
    // 0x198f9c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_198fa0:
    // 0x198fa0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x198fa4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198fa8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FIgnoreSprizeIntersection__FP6SPRIZEP2SO
// Address: 0x198fb0 - 0x198fcc

void entry_198fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x198fcc: 0x14400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x198FEC; return;
    }
    // 0x198fd4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x198fd8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x198fe0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 59));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_198fe0
// Address: 0x198fe0 - 0x199000

void entry_198fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x198fe0) {
        switch (ctx->pc) {
            case 0x198fec: ctx->pc = 0; goto label_198fec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x198fe0: 0x14400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_198fec;
    }
    // 0x198fe8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_198fec:
    // 0x198fec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x198ff0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x198ff4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x198ffc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x199000; return;
}


// Function: FUN_00199000
// Address: 0x199000 - 0x199028

void FUN_00199000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199000: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x199004: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x199008: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x19900c: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x199010: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x199014: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x199018: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x19901c: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x199020: 0xc064a7e
    SET_GPR_U32(ctx, 31, 0x199028);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    PpziCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_199028
// Address: 0x199028 - 0x199048

void entry_199028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199028: 0x8c450018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x19902c: 0x10a00008
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x199050; return;
    }
    // 0x199034: 0x2501023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
    // 0x199038: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x19903c: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x199040: 0xc060bd0
    SET_GPR_U32(ctx, 31, 0x199048);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    FFindLoParent__FP2LOP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_199048
// Address: 0x199048 - 0x199070

void entry_199048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199048) {
        switch (ctx->pc) {
            case 0x199050: ctx->pc = 0; goto label_199050;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199048: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 19), 1436), GPR_U32(ctx, 18));
        goto label_199050;
    }
label_199050:
    // 0x199050: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x199054: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x199058: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19905c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x199060: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x199064: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19906c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x199070; return;
}


// Function: InitScprize__FP7SCPRIZE
// Address: 0x199070 - 0x199084

void entry_199084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199084: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x199088: 0xc0503fe
    SET_GPR_U32(ctx, 31, 0x199090);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    IchkAllocChkmgr__FP6CHKMGR(rdram, ctx, runtime); return;
}


// Function: entry_199090
// Address: 0x199090 - 0x1990a8

void entry_199090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199090: 0xae0205a0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1440), GPR_U32(ctx, 2));
    // 0x199094: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x199098: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19909c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1990a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1990a8; return;
}


// Function: CloneScprize__FP7SCPRIZET0
// Address: 0x1990a8 - 0x1990c4

void entry_1990c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1990c4: 0xae1105a0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1440), GPR_U32(ctx, 17));
    // 0x1990c8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1990cc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1990d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1990d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1990dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1990e0; return;
}


// Function: PcsFromScprize__FP7SCPRIZE
// Address: 0x1990e0 - 0x1990f8

void entry_1990f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1990f8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1990fc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x199100: 0x16020007
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x199120; return;
    }
    // 0x199108: 0x8e2505a0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1440)));
    // 0x19910c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x199110: 0xc050402
    SET_GPR_U32(ctx, 31, 0x199118);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    FGetChkmgrIchk__FP6CHKMGRi(rdram, ctx, runtime); return;
}


// Function: entry_199118
// Address: 0x199118 - 0x199138

void entry_199118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199118) {
        switch (ctx->pc) {
            case 0x199120: ctx->pc = 0; goto label_199120;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199118: 0x2800b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 0));
    // 0x19911c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_199120:
    // 0x199120: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x199124: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x199128: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19912c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x199134: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x199138; return;
}


// Function: CollectScprize__FP7SCPRIZE
// Address: 0x199138 - 0x199158

void entry_199158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199158: 0xc06636a
    SET_GPR_U32(ctx, 31, 0x199160);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CollectSprize__FP6SPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_199160
// Address: 0x199160 - 0x199170

void entry_199160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199160: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x199164: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x199168: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadLockFromBrx__FP4LOCKP18CBinaryInputStream
// Address: 0x199170 - 0x199184

void entry_199184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199184: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x199188: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19918c: 0x24c6a918
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294945048));
    // 0x199190: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x199198);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_199198
// Address: 0x199198 - 0x1991a8

void entry_199198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199198: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19919c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1991a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostLockLoad__FP4LOCK
// Address: 0x1991a8 - 0x1991bc

void entry_1991bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1991bc: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1991c0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1991c4: 0x24c6a928
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294945064));
    // 0x1991c8: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x1991d0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_1991d0
// Address: 0x1991d0 - 0x1991e0

void entry_1991d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1991d0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1991d4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1991d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadLockgFromBrx__FP5LOCKGP18CBinaryInputStream
// Address: 0x1991e0 - 0x1991f4

void entry_1991f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1991f4: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x1991f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1991fc: 0x24c6a938
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294945080));
    // 0x199200: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x199208);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_199208
// Address: 0x199208 - 0x199218

void entry_199208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199208: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19920c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x199210: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostLockgLoad__FP5LOCKG
// Address: 0x199218 - 0x199244

void entry_199244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199244: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x199248: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19924c: 0x2406005c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 92));
    // 0x199250: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x199254: 0x24080008
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 8));
    // 0x199258: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x199260);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_199260
// Address: 0x199260 - 0x19928c

void entry_199260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199260) {
        switch (ctx->pc) {
            case 0x199278: ctx->pc = 0; goto label_199278;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199260: 0x8e2302dc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 732)));
    // 0x199264: 0x18600019
    WRITE32(ADD32(GPR_U32(ctx, 17), 768), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1992CC; return;
    }
    // 0x19926c: 0x200a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x199270: 0x263202e0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 736));
    // 0x199274: 0x0
    // NOP
label_199278:
    // 0x199278: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x19927c: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x199280: 0x8e460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x199284: 0xc056906
    SET_GPR_U32(ctx, 31, 0x19928c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19928c
// Address: 0x19928c - 0x19931c

void entry_19928c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19928c) {
        switch (ctx->pc) {
            case 0x1992b8: ctx->pc = 0; goto label_1992b8;
            case 0x1992bc: ctx->pc = 0; goto label_1992bc;
            case 0x1992cc: ctx->pc = 0; goto label_1992cc;
            case 0x199300: ctx->pc = 0; goto label_199300;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19928c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x199290: 0x5200000a
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 732)));
        goto label_1992bc;
    }
    // 0x199298: 0x8e230300
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 768)));
    // 0x19929c: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x1992a0: 0x10400005
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1992b8;
    }
    // 0x1992a8: 0x2821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x1992ac: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x1992b0: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x1992b4: 0xae230300
    WRITE32(ADD32(GPR_U32(ctx, 17), 768), GPR_U32(ctx, 3));
label_1992b8:
    // 0x1992b8: 0x8e2202dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 732)));
label_1992bc:
    // 0x1992bc: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1992c0: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1992c4: 0x1440ffec
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x199278; return;
    }
label_1992cc:
    // 0x1992cc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1992d0: 0x8e2402d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 720)));
    // 0x1992d4: 0x8c4323c4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9156)));
    // 0x1992d8: 0x2414022e
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 558));
    // 0x1992dc: 0x2405022f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 559));
    // 0x1992e0: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1992e4: 0x8c620448
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1096)));
    // 0x1992e8: 0x8e230300
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 768)));
    // 0x1992ec: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1992f0: 0x18600012
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 5));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x19933C; return;
    }
    // 0x1992f8: 0x26320304
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 772));
    // 0x1992fc: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_199300:
    // 0x199300: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x199304: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199308: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x19930c: 0x8e0402d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x199310: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x199314: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x19931c);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_19931c
// Address: 0x19931c - 0x19932c

void entry_19931c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19931c: 0xae0202d4
    WRITE32(ADD32(GPR_U32(ctx, 16), 724), GPR_U32(ctx, 2));
    // 0x199320: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x199324: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19932c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19932c
// Address: 0x19932c - 0x199350

void entry_19932c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19932c) {
        switch (ctx->pc) {
            case 0x19933c: ctx->pc = 0; goto label_19933c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19932c: 0x8e220300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 768)));
    // 0x199330: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x199334: 0x5440fff2
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x199300; return;
    }
label_19933c:
    // 0x19933c: 0x8e2402d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 724)));
    // 0x199340: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x199344: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x199348: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x199350);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_199350
// Address: 0x199350 - 0x199360

void entry_199350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199350: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x199354: 0xae2202d8
    WRITE32(ADD32(GPR_U32(ctx, 17), 728), GPR_U32(ctx, 2));
    // 0x199358: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x199360);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_199360
// Address: 0x199360 - 0x199380

void entry_199360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199360: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x199364: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x199368: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19936c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x199370: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x199374: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x199378: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetLockgIndex__FP5LOCKGi
// Address: 0x199380 - 0x199398

void entry_1993e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1993e0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1993e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1993ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1993f0; return;
}


// Function: InitClue__FP4CLUE
// Address: 0x1993f0 - 0x199404

void entry_199404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199404: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x199408: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19940c: 0x8c622300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8960)));
    // 0x199410: 0xae0205a0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1440), GPR_U32(ctx, 2));
    // 0x199414: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x199418: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19941c: 0xac622300
    WRITE32(ADD32(GPR_U32(ctx, 3), 8960), GPR_U32(ctx, 2));
    // 0x199420: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadClueFromBrx__FP4CLUEP18CBinaryInputStream
// Address: 0x199428 - 0x199440

void entry_199440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199440: 0x24110318
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 792));
    // 0x199444: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x199448: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19944c: 0x24c6a948
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294945096));
    // 0x199450: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x199458);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_199458
// Address: 0x199458 - 0x199460

void entry_199458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199458: 0xc063540
    SET_GPR_U32(ctx, 31, 0x199460);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 128));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_199460
// Address: 0x199460 - 0x19948c

void entry_199460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199460) {
        switch (ctx->pc) {
            case 0x199468: ctx->pc = 0; goto label_199468;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199460: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 16), 1456), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_19948c(rdram, ctx, runtime); return;
    }
label_199468:
    // 0x199468: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x19946c: 0x8e0505b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1456)));
    // 0x199470: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x199474: 0x21880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 2), 2));
    // 0x199478: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x19947c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x199480: 0xac660000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 6));
    // 0x199484: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x19948c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1452), GPR_U32(ctx, 2));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19948c
// Address: 0x19948c - 0x1994a8

void entry_19948c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19948c: 0x2a220338
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 824));
    // 0x199490: 0x10400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1994B4; return;
    }
    // 0x199498: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19949c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1994a0: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1994a8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1994a8
// Address: 0x1994a8 - 0x1994c8

void entry_1994a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1994a8) {
        switch (ctx->pc) {
            case 0x1994b4: ctx->pc = 0; goto label_1994b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1994a8: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1994ac: 0x54c0ffee
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1452)));
        ctx->pc = 0x199468; return;
    }
label_1994b4:
    // 0x1994b4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1994b8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1994bc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1994c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneClue__FP4CLUET0
// Address: 0x1994c8 - 0x1994e4

void entry_1994e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1994e4: 0xae1105a0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1440), GPR_U32(ctx, 17));
    // 0x1994e8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1994ec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1994f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1994f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1994fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x199500; return;
}


// Function: PostClueLoad__FP4CLUE
// Address: 0x199500 - 0x199520

void entry_199520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199520: 0x3c01c049
    SET_GPR_U32(ctx, 1, ((uint32_t)49225 << 16));
    // 0x199524: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x199528: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19952c: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x199530: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x199534: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x199538: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x199540);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_199540
// Address: 0x199540 - 0x199558

void entry_199540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199540: 0xe60005b8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1464), *(uint32_t*)&val); }
    // 0x199544: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x199548: 0x2443a958
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294945112));
    // 0x19954c: 0xc44ca958
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294945112)); ctx->f[12] = *(float*)&val; }
    // 0x199550: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x199558);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_199558
// Address: 0x199558 - 0x199568

void entry_199558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199558: 0xe60005b4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1460), *(uint32_t*)&val); }
    // 0x19955c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199560: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x199568);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_199568
// Address: 0x199568 - 0x199598

void entry_199568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199568) {
        switch (ctx->pc) {
            case 0x19957c: ctx->pc = 0; goto label_19957c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199568: 0x10400004
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19957c;
    }
    // 0x199570: 0xc60005b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1460)); ctx->f[0] = *(float*)&val; }
    // 0x199574: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x199578: 0xe60005b4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1460), *(uint32_t*)&val); }
label_19957c:
    // 0x19957c: 0x2412ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x199580: 0x2443a960
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294945120));
    // 0x199584: 0xc44ca960
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294945120)); ctx->f[12] = *(float*)&val; }
    // 0x199588: 0xc46d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[13] = *(float*)&val; }
    // 0x19958c: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x199590: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x199598);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_199598
// Address: 0x199598 - 0x1995b0

void entry_199598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199598: 0xc60105a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1448)); ctx->f[1] = *(float*)&val; }
    // 0x19959c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x1995a0: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1995a4: 0x46010b40
    ctx->f[13] = FPU_ADD_S(ctx->f[1], ctx->f[1]);
    // 0x1995a8: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x1995b0);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1448), *(uint32_t*)&val); }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_1995b0
// Address: 0x1995b0 - 0x1995f8

void entry_1995b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1995b0: 0x8e0305a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1440)));
    // 0x1995b4: 0x8e2523c8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 9160)));
    // 0x1995b8: 0x24620007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 7));
    // 0x1995bc: 0x243202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 3)));
    // 0x1995c0: 0x64100b
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 3));
    // 0x1995c4: 0xe60005a4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1444), *(uint32_t*)&val); }
    // 0x1995c8: 0x210c3
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 3));
    // 0x1995cc: 0x30630007
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 7));
    // 0x1995d0: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1995d4: 0x731804
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), GPR_U32(ctx, 3) & 0x1F));
    // 0x1995d8: 0x90a20068
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 104)));
    // 0x1995dc: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1995e0: 0x10400006
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1995FC; return;
    }
    // 0x1995e8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1995ec: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1995f0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1995f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1995f8
// Address: 0x1995f8 - 0x199614

void entry_1995f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1995f8) {
        switch (ctx->pc) {
            case 0x1995fc: ctx->pc = 0; goto label_1995fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1995f8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_1995fc:
    // 0x1995fc: 0x8c435c34
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 23604)));
    // 0x199600: 0x1060001e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19967C; return;
    }
    // 0x199608: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19960c: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x199614);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 100));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_199614
// Address: 0x199614 - 0x199678

void entry_199614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199614) {
        switch (ctx->pc) {
            case 0x199668: ctx->pc = 0; goto label_199668;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199614: 0x28420014
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 20));
    // 0x199618: 0x10400017
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 9160)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_199678(rdram, ctx, runtime); return;
    }
    // 0x199620: 0x8e0305a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1440)));
    // 0x199624: 0x243202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 3)));
    // 0x199628: 0x24620007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 7));
    // 0x19962c: 0x64100b
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 3));
    // 0x199630: 0x24c50068
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 6), 104));
    // 0x199634: 0x210c3
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 3));
    // 0x199638: 0x30630007
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 7));
    // 0x19963c: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x199640: 0x731804
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), GPR_U32(ctx, 3) & 0x1F));
    // 0x199644: 0x90a40000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x199648: 0x831024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x19964c: 0x10400006
    SET_GPR_U32(ctx, 2, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_199668;
    }
    // 0x199654: 0x821024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x199658: 0xa0a20000
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x19965c: 0x8cc30064
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 100)));
    // 0x199660: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x199664: 0xacc30064
    WRITE32(ADD32(GPR_U32(ctx, 6), 100), GPR_U32(ctx, 3));
label_199668:
    // 0x199668: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19966c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x199670: 0x40f809
    SET_GPR_U32(ctx, 31, 0x199678);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_199678
// Address: 0x199678 - 0x199698

void entry_199678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199678) {
        switch (ctx->pc) {
            case 0x19967c: ctx->pc = 0; goto label_19967c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199678: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_19967c:
    // 0x19967c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x199680: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x199684: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x199688: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19968c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x199694: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x199698; return;
}


// Function: UpdateClue
// Address: 0x199698 - 0x1996b4

void entry_1996b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1996b4: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1996bc);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1996bc
// Address: 0x1996bc - 0x1996dc

void entry_1996bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1996bc: 0x3c030002
    SET_GPR_U32(ctx, 3, ((uint32_t)2 << 16));
    // 0x1996c0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1996c4: 0x1040005d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19983C; return;
    }
    // 0x1996cc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1996d0: 0x8c620130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 304)));
    // 0x1996d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1996dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1996dc
// Address: 0x1996dc - 0x1996f0

void entry_1996dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1996dc: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1996e0: 0x14430056
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x19983C; return;
    }
    // 0x1996e8: 0xc064a7e
    SET_GPR_U32(ctx, 31, 0x1996f0);
    PpziCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1996f0
// Address: 0x1996f0 - 0x199768

void entry_1996f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1996f0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1996f4: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1996f8: 0x10400050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19983C; return;
    }
    // 0x199700: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x199704: 0x1080004d
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19983C; return;
    }
    // 0x19970c: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x199710: 0xc441a968
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294945128)); ctx->f[1] = *(float*)&val; }
    // 0x199714: 0x26120140
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 320));
    // 0x199718: 0xd8810140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x19971c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x199720: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x199724: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x199728: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19972c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x199730: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x199734: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x199738: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x19973c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x199740: 0x0
    // NOP
    // 0x199744: 0x4503003e
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
        ctx->pc = 0x199840; return;
    }
    // 0x19974c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x199750: 0x24860140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 320));
    // 0x199754: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199758: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19975c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199760: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x199768);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_199768
// Address: 0x199768 - 0x199788

void entry_199768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199768: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19976c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x199770: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199774: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x199778: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19977c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199780: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x199788);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_199788
// Address: 0x199788 - 0x199838

void entry_199788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199788) {
        switch (ctx->pc) {
            case 0x1997f8: ctx->pc = 0; goto label_1997f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199788: 0x8e230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x19978c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x199790: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x199794: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x199798: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x19979c: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1997a0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1997a4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1997a8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1997ac: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1997b0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1997b4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1997b8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1997bc: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1997c0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1997c4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1997c8: 0x4b000120
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1997cc: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1997d0: 0x48232000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1997d4: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1997d8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1997dc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1997e0: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1997e4: 0x45010004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1997f8;
    }
    // 0x1997ec: 0x4a6403bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1997f0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1997f4: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_1997f8:
    // 0x1997f8: 0x4bc1106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1997fc: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x199800: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x199804: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x199808: 0x3c01c248
    SET_GPR_U32(ctx, 1, ((uint32_t)49736 << 16));
    // 0x19980c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x199810: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x199814: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x199818: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19981c: 0x0
    // NOP
    // 0x199820: 0x45000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19983C; return;
    }
    // 0x199828: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19982c: 0x8c620134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 308)));
    // 0x199830: 0x40f809
    SET_GPR_U32(ctx, 31, 0x199838);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_199838
// Address: 0x199838 - 0x199850

void entry_199838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199838) {
        switch (ctx->pc) {
            case 0x19983c: ctx->pc = 0; goto label_19983c;
            case 0x199840: ctx->pc = 0; goto label_199840;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199838: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_19983c:
    // 0x19983c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_199840:
    // 0x199840: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x199844: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x199848: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnClueSmack__FP4CLUE
// Address: 0x199850 - 0x19997c

void entry_19997c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19997c) {
        switch (ctx->pc) {
            case 0x199980: ctx->pc = 0; goto label_199980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19997c: 0x8e6323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 9152)));
label_199980:
    // 0x199980: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x199984: 0x8e445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 22288)));
    // 0x199988: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19998c: 0x8c6219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6636)));
    // 0x199990: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199994: 0x511025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x199998: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1999a0);
    WRITE32(ADD32(GPR_U32(ctx, 3), 6636), GPR_U32(ctx, 2));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1999a0
// Address: 0x1999a0 - 0x1999b0

void entry_1999a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1999a0: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1999B4; return;
    }
    // 0x1999a8: 0xc05462e
    SET_GPR_U32(ctx, 31, 0x1999b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    TriggerDialog__FP6DIALOG(rdram, ctx, runtime); return;
}


// Function: entry_1999b0
// Address: 0x1999b0 - 0x1999d0

void entry_1999b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1999b0) {
        switch (ctx->pc) {
            case 0x1999b4: ctx->pc = 0; goto label_1999b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1999b0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1999b4:
    // 0x1999b4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1999b8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1999bc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1999c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1999c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1999cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1999d0; return;
}


// Function: CollectClue__FP4CLUE
// Address: 0x1999d0 - 0x1999f8

void entry_1999f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1999f8: 0x24040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1999fc: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x199a04);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_199a04
// Address: 0x199a04 - 0x199a74

void entry_199a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199a04: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x199a08: 0x1200002f
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x199AC8; return;
    }
    // 0x199a10: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x199a14: 0x8c4423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x199a18: 0x8c655710
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    // 0x199a1c: 0x8c820064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 100)));
    // 0x199a20: 0x8ca32300
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 8960)));
    // 0x199a24: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x199a28: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x199a2c: 0x14400012
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x199A78; return;
    }
    // 0x199a34: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x199a38: 0x24040021
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 33));
    // 0x199a3c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x199a40: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x199a44: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x199a48: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199a4c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x199a50: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x199a54: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199a58: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x199a5c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x199a60: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199a64: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x199a68: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199a6c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x199a74);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_199a74
// Address: 0x199a74 - 0x199a9c

void entry_199a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199a74) {
        switch (ctx->pc) {
            case 0x199a78: ctx->pc = 0; goto label_199a78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199a74: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_199a78:
    // 0x199a78: 0xae110134
    WRITE32(ADD32(GPR_U32(ctx, 16), 308), GPR_U32(ctx, 17));
    // 0x199a7c: 0x2442a970
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945136));
    // 0x199a80: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x199a84: 0xae020130
    WRITE32(ADD32(GPR_U32(ctx, 16), 304), GPR_U32(ctx, 2));
    // 0x199a88: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199a8c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x199a90: 0x8e2605bc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1468)));
    // 0x199a94: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x199a9c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 256));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_199a9c
// Address: 0x199a9c - 0x199abc

void entry_199a9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199a9c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x199aa0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x199aa4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x199aa8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x199aac: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x199ab0: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x199ab4: 0x60f809
    SET_GPR_U32(ctx, 31, 0x199abc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_199abc
// Address: 0x199abc - 0x199ad0

void entry_199abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199abc) {
        switch (ctx->pc) {
            case 0x199ac8: ctx->pc = 0; goto label_199ac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199abc: 0x8e2205bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1468)));
    // 0x199ac0: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_199ad0(rdram, ctx, runtime); return;
    }
label_199ac8:
    // 0x199ac8: 0xc066614
    SET_GPR_U32(ctx, 31, 0x199ad0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    OnClueSmack__FP4CLUE(rdram, ctx, runtime); return;
}


// Function: entry_199ad0
// Address: 0x199ad0 - 0x199ad8

void entry_199ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199ad0: 0xc06636a
    SET_GPR_U32(ctx, 31, 0x199ad8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CollectSprize__FP6SPRIZE(rdram, ctx, runtime); return;
}


// Function: entry_199ad8
// Address: 0x199ad8 - 0x199af0

void entry_199ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199ad8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x199adc: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x199ae0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x199ae4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x199aec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x199af0; return;
}


// Function: BreakClue__FP4CLUE
// Address: 0x199af0 - 0x199b08

void entry_199b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199b08: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x199b0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x199b14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x199b18; return;
}


// Function: CollectClueSilent__FP4CLUE
// Address: 0x199b18 - 0x199b40

void entry_199b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199b40) {
        switch (ctx->pc) {
            case 0x199b9c: ctx->pc = 0; goto label_199b9c;
            case 0x199bb8: ctx->pc = 0; goto label_199bb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199b40: 0x8e4405a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1440)));
    // 0x199b44: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x199b48: 0x8c6823c8
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 3), 9160)));
    // 0x199b4c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x199b50: 0x44102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 4)));
    // 0x199b54: 0x24830007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 7));
    // 0x199b58: 0x82180b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 4));
    // 0x199b5c: 0x25060068
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 8), 104));
    // 0x199b60: 0x318c3
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 3));
    // 0x199b64: 0x30840007
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 7));
    // 0x199b68: 0xc33021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x199b6c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x199b70: 0x90c70000
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x199b74: 0x851804
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), GPR_U32(ctx, 4) & 0x1F));
    // 0x199b78: 0xe31024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 7), GPR_U32(ctx, 3)));
    // 0x199b7c: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 1392)));
        goto label_199b9c;
    }
    // 0x199b84: 0xe31825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 7), GPR_U32(ctx, 3)));
    // 0x199b88: 0xa0c30000
    WRITE8(ADD32(GPR_U32(ctx, 6), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x199b8c: 0x8d020064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 100)));
    // 0x199b90: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x199b94: 0xad020064
    WRITE32(ADD32(GPR_U32(ctx, 8), 100), GPR_U32(ctx, 2));
    // 0x199b98: 0x8e500570
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 1392)));
label_199b9c:
    // 0x199b9c: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x199ba0: 0x6000010
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    if (GPR_S32(ctx, 16) < 0) {
        ctx->pc = 0x199BE4; return;
    }
    // 0x199ba8: 0x24420574
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1396));
    // 0x199bac: 0x528821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x199bb0: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x199bb4: 0x0
    // NOP
label_199bb8:
    // 0x199bb8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199bbc: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x199bc0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x199bc4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x199bc8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x199bcc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199bd0: 0x2631fffc
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967292));
    // 0x199bd4: 0xc04b23e
    SET_GPR_U32(ctx, 31, 0x199bdc);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    PasegaEnsureAseg__FP4ASEGP3ALO4SEEKffi(rdram, ctx, runtime); return;
}


// Function: entry_199bdc
// Address: 0x199bdc - 0x199bf8

void entry_199bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199bdc) {
        switch (ctx->pc) {
            case 0x199be4: ctx->pc = 0; goto label_199be4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199bdc: 0x603fff6
    if (GPR_S32(ctx, 16) >= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x199BB8; return;
    }
label_199be4:
    // 0x199be4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x199be8: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x199bec: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199bf0: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x199bf8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_199bf8
// Address: 0x199bf8 - 0x199c10

void entry_199bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199bf8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x199bfc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x199c00: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x199c04: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x199c08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00199c10
// Address: 0x199c10 - 0x199c58

void FUN_00199c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199c10: 0x8c8605a0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 1440)));
    // 0x199c14: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x199c18: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x199c1c: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x199c20: 0x66182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 6)));
    // 0x199c24: 0x24c20007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 7));
    // 0x199c28: 0x8d0423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 8), 9160)));
    // 0x199c2c: 0xc3100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 6));
    // 0x199c30: 0x210c3
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 3));
    // 0x199c34: 0x30c60007
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), 7));
    // 0x199c38: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x199c3c: 0xc73804
    SET_GPR_U32(ctx, 7, SLL32(GPR_U32(ctx, 7), GPR_U32(ctx, 6) & 0x1F));
    // 0x199c40: 0x90820068
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 104)));
    // 0x199c44: 0x471024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x199c48: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x199c4c: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x199c54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x199c58; return;
}


// Function: ImpactClue__FP4CLUEi
// Address: 0x199c58 - 0x199c68

void entry_199c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199c68: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x199c6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x199c74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x199c78; return;
}


// Function: FAbsorbClueWkr__FP4CLUEP3WKR
// Address: 0x199c78 - 0x199cac

void entry_199cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199cac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x199cb0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199cb4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x199cb8: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x199cbc: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x199cc4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_199cc4
// Address: 0x199cc4 - 0x199cd0

void entry_199cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199cc4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x199cc8: 0xc06f0c8
    SET_GPR_U32(ctx, 31, 0x199cd0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FAbsorbSoWkr__FP2SOP3WKR(rdram, ctx, runtime); return;
}


// Function: entry_199cd0
// Address: 0x199cd0 - 0x199cf0

void entry_199cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199cd0: 0x8e23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x199cd4: 0x30630010
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 16));
    // 0x199cd8: 0x10600006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x199CF4; return;
    }
    // 0x199ce0: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x199ce4: 0x8c620134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 308)));
    // 0x199ce8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x199cf0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_199cf0
// Address: 0x199cf0 - 0x199d08

void entry_199cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199cf0) {
        switch (ctx->pc) {
            case 0x199cf4: ctx->pc = 0; goto label_199cf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199cf0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_199cf4:
    // 0x199cf4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x199cf8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x199cfc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x199d00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderClueAll__FP4CLUEP2CMP2RO
// Address: 0x199d08 - 0x199d7c

void entry_199d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199d7c: 0x26220110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 272));
    // 0x199d80: 0xda220110
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x199d84: 0xd8440020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x199d88: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x199d8c: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x199d90: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x199d94: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x199d98: 0x4bc311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x199d9c: 0x4bc308bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x199da0: 0x4bc320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x199da4: 0x4bc511bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x199da8: 0x4bc508bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x199dac: 0x4bc5214a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x199db0: 0xdba60020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x199db4: 0x8e220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x199db8: 0x4bc611bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x199dbc: 0x4bc608bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x199dc0: 0x4bc6208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x199dc4: 0xfba30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x199dc8: 0xfba50040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x199dcc: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x199dd0: 0xfba300e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x199dd4: 0xfba300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x199dd8: 0xfba500f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x199ddc: 0xfba500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x199de0: 0xfba20100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x199de4: 0x10400005
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_199dfc(rdram, ctx, runtime); return;
    }
    // 0x199dec: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x199df0: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x199df4: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x199dfc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_199dfc
// Address: 0x199dfc - 0x199e10

void entry_199dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199dfc: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x199e00: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x199e04: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x199e08: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x199e10);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_199e10
// Address: 0x199e10 - 0x199e24

void entry_199e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199e10: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x199e14: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x199e18: 0x26240140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 320));
    // 0x199e1c: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x199e24);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_199e24
// Address: 0x199e24 - 0x199ed0

void entry_199e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199e24) {
        switch (ctx->pc) {
            case 0x199e60: ctx->pc = 0; goto label_199e60;
            case 0x199e74: ctx->pc = 0; goto label_199e74;
            case 0x199eb4: ctx->pc = 0; goto label_199eb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199e24: 0x8e2205ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1452)));
    // 0x199e28: 0x18400035
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 176));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x199F00; return;
    }
    // 0x199e30: 0xc6820008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 8)); ctx->f[2] = *(float*)&val; }
    // 0x199e34: 0xc62105a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1444)); ctx->f[1] = *(float*)&val; }
    // 0x199e38: 0x27b20110
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 272));
    // 0x199e3c: 0xc62305a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1448)); ctx->f[3] = *(float*)&val; }
    // 0x199e40: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x199e44: 0x46031800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[3]);
    // 0x199e48: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x199e4c: 0x0
    // NOP
    // 0x199e50: 0x45000008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1444), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_199e74;
    }
    // 0x199e58: 0x46031800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[3]);
    // 0x199e5c: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
label_199e60:
    // 0x199e60: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x199e64: 0x0
    // NOP
    // 0x199e68: 0x4503fffd
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
        goto label_199e60;
    }
    // 0x199e70: 0xe62105a4
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1444), *(uint32_t*)&val); }
label_199e74:
    // 0x199e74: 0x8e2305ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1452)));
    // 0x199e78: 0xc62205a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1444)); ctx->f[2] = *(float*)&val; }
    // 0x199e7c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x199e80: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x199e84: 0xc62105a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1448)); ctx->f[1] = *(float*)&val; }
    // 0x199e88: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x199e8c: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x199e90: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x199e94: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x199e98: 0x83102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x199e9c: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1456)));
        goto label_199eb4;
    }
    // 0x199ea4: 0x31840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 1));
    // 0x199ea8: 0x24820001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 1));
    // 0x199eac: 0x622023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x199eb0: 0x8e2305b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1456)));
label_199eb4:
    // 0x199eb4: 0x41080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    // 0x199eb8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x199ebc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x199ec0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x199ec4: 0x24850050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 80));
    // 0x199ec8: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x199ed0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 64));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_199ed0
// Address: 0x199ed0 - 0x199ee0

void entry_199ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199ed0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x199ed4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x199ed8: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x199ee0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_199ee0
// Address: 0x199ee0 - 0x199f10

void entry_199ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199ee0) {
        switch (ctx->pc) {
            case 0x199f00: ctx->pc = 0; goto label_199f00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199ee0: 0x7ba20110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x199ee4: 0x7ba30120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x199ee8: 0x7ba40130
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x199eec: 0x7ba50140
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x199ef0: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x199ef4: 0x7fa30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 3));
    // 0x199ef8: 0x7fa40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 4));
    // 0x199efc: 0x7fa50090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 5));
label_199f00:
    // 0x199f00: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x199f04: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x199f08: 0xc049724
    SET_GPR_U32(ctx, 31, 0x199f10);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RenderAloAll__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_199f10
// Address: 0x199f10 - 0x199f38

void entry_199f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199f10: 0x7bbf01b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x199f14: 0x7bb501a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x199f18: 0x7bb40190
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x199f1c: 0x7bb30180
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x199f20: 0x7bb20170
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x199f24: 0x7bb10160
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x199f28: 0x7bb00150
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x199f2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 448));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x199f34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x199f38; return;
}


// Function: CollectAllClues__Fi
// Address: 0x199f38 - 0x199f6c

void entry_199f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199f6c) {
        switch (ctx->pc) {
            case 0x199f80: ctx->pc = 0; goto label_199f80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199f6c: 0x2451ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x199f70: 0x6200015
    SET_GPR_U32(ctx, 18, ((uint32_t)39 << 16));
    if (GPR_S32(ctx, 17) < 0) {
        ctx->pc = 0x199FC8; return;
    }
    // 0x199f78: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x199f7c: 0x5d8021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 29)));
label_199f80:
    // 0x199f80: 0xc0666c6
    SET_GPR_U32(ctx, 31, 0x199f88);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    CollectClueSilent__FP4CLUE(rdram, ctx, runtime); return;
}


// Function: entry_199f88
// Address: 0x199f88 - 0x199fa0

void entry_199f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199f88: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x199f8c: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x199f90: 0x5080000b
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        entry_199fc0(rdram, ctx, runtime); return;
    }
    // 0x199f98: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x199fa0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_199fa0
// Address: 0x199fa0 - 0x199fc0

void entry_199fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199fa0: 0x10400007
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_199fc0(rdram, ctx, runtime); return;
    }
    // 0x199fa8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x199fac: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x199fb0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x199fb4: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x199fb8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x199fc0);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_199fc0
// Address: 0x199fc0 - 0x199fd8

void entry_199fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x199fc0) {
        switch (ctx->pc) {
            case 0x199fc8: ctx->pc = 0; goto label_199fc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x199fc0: 0x621ffef
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967292));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x199F80; return;
    }
label_199fc8:
    // 0x199fc8: 0x8e43c948
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4294953288)));
    // 0x199fcc: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x199fd0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x199fd8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4294953288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_199fd8
// Address: 0x199fd8 - 0x199ff0

void entry_199fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x199fd8: 0x7bbf0430
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x199fdc: 0x7bb20420
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x199fe0: 0x7bb10410
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1040)));
    // 0x199fe4: 0x7bb00400
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1024)));
    // 0x199fe8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1088));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetGrfvault__Fi
// Address: 0x199ff0 - 0x19a000

void FUN_0019a000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a000: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x19a004: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x19a008: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x19a00c: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x19a010: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x19a014: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x19a018: 0x3410f000
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 0), 61440));
    // 0x19a01c: 0x108438
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << 16);
    // 0x19a020: 0x3610ffff
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 65535));
    // 0x19a024: 0x8e4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9152)));
    // 0x19a028: 0x8c6219f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6640)));
    // 0x19a02c: 0x501024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x19a030: 0x1050000e
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x19A06C; return;
    }
    // 0x19a038: 0xc0580a8
    SET_GPR_U32(ctx, 31, 0x19a040);
    get_game_completion__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19a040
// Address: 0x19a040 - 0x19a088

void entry_19a040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a040) {
        switch (ctx->pc) {
            case 0x19a06c: ctx->pc = 0; goto label_19a06c;
            case 0x19a070: ctx->pc = 0; goto label_19a070;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a040: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x19a044: 0x5440000a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_19a070;
    }
    // 0x19a04c: 0x8e4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9152)));
    // 0x19a050: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19a054: 0x8c8319f0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6640)));
    // 0x19a058: 0x711825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x19a05c: 0x702024
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x19a060: 0x902026
    SET_GPR_U32(ctx, 4, XOR32(GPR_U32(ctx, 4), GPR_U32(ctx, 16)));
    // 0x19a064: 0x10000002
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19a070;
    }
label_19a06c:
    // 0x19a06c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_19a070:
    // 0x19a070: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19a074: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19a078: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19a07c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19a080: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0019a088
// Address: 0x19a088 - 0x19a0f0

void FUN_0019a088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a088) {
        switch (ctx->pc) {
            case 0x19a09c: ctx->pc = 0; goto label_19a09c;
            case 0x19a0c0: ctx->pc = 0; goto label_19a0c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a088: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19a08c: 0x14820003
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_19a09c;
    }
    // 0x19a094: 0x8c6223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x19a098: 0x8c4419d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6616)));
label_19a09c:
    // 0x19a09c: 0x2402044c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x19a0a0: 0x8c6323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x19a0a4: 0x821018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x19a0a8: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x19a0ac: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19a0b0: 0x24640438
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 1080));
    // 0x19a0b4: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x19a0b8: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x19a0bc: 0x0
    // NOP
label_19a0c0:
    // 0x19a0c0: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x19a0c4: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x19a0c8: 0x24a50078
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 120));
    // 0x19a0cc: 0xa4102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 4)));
    // 0x19a0d0: 0x0
    // NOP
    // 0x19a0d4: 0x5440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
        goto label_19a0c0;
    }
    // 0x19a0dc: 0x8c620448
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1096)));
    // 0x19a0e0: 0x3442001f
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 31));
    // 0x19a0e4: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 3), 1096), GPR_U32(ctx, 2));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19a0ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19a0f0; return;
}


// Function: FUN_0019a0f0
// Address: 0x19a0f0 - 0x19a108

void FUN_0019a0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a0f0) {
        switch (ctx->pc) {
            case 0x19a100: ctx->pc = 0; goto label_19a100;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a0f0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x19a0f4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x19a0f8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x19a0fc: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_19a100:
    // 0x19a100: 0xc066822
    SET_GPR_U32(ctx, 31, 0x19a108);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0019a088(rdram, ctx, runtime); return;
}


// Function: entry_19a108
// Address: 0x19a108 - 0x19a134

void entry_19a108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a108: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x19a10c: 0x2a020006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 6));
    // 0x19a110: 0x1440fffb
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19A100; return;
    }
    // 0x19a118: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x19a11c: 0x24425bc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23488));
    // 0x19a120: 0x8c430030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x19a124: 0x14640004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x19A138; return;
    }
    // 0x19a12c: 0xc07949e
    SET_GPR_U32(ctx, 31, 0x19a134);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ResetWorld__F6FTRANS(rdram, ctx, runtime); return;
}


// Function: entry_19a134
// Address: 0x19a134 - 0x19a148

void entry_19a134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a134) {
        switch (ctx->pc) {
            case 0x19a138: ctx->pc = 0; goto label_19a138;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a134: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_19a138:
    // 0x19a138: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19a13c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19a144: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19a148; return;
}


// Function: InitVault__FP5VAULT
// Address: 0x19a148 - 0x19a15c

void entry_19a15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a15c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19a160: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19a164: 0xae020644
    WRITE32(ADD32(GPR_U32(ctx, 16), 1604), GPR_U32(ctx, 2));
    // 0x19a168: 0xae02064c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1612), GPR_U32(ctx, 2));
    // 0x19a16c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19a170: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostTmblLoad__FP4TMBL3OID
// Address: 0x19a178 - 0x19a1a8

void entry_19a1a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a1a8: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19a1ac: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x19a1b4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19a1b4
// Address: 0x19a1b4 - 0x19a1c8

void entry_19a1b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a1b4: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x19a1b8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19a1bc: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19a1c0: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x19a1c8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_19a1c8
// Address: 0x19a1c8 - 0x19a1e0

void entry_19a1c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a1c8: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x19a1cc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19a1d0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19a1d4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19a1d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostVaultLoad__FP5VAULT
// Address: 0x19a1e0 - 0x19a218

void entry_19a218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a218: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x19a21c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19a220: 0x24c6aa50
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294945360));
    // 0x19a224: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x19a22c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 26));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_19a22c
// Address: 0x19a22c - 0x19a23c

void entry_19a22c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a22c) {
        switch (ctx->pc) {
            case 0x19a230: ctx->pc = 0; goto label_19a230;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a22c: 0x0
    // NOP
label_19a230:
    // 0x19a230: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19a234: 0xc06685e
    SET_GPR_U32(ctx, 31, 0x19a23c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 912));
    PostTmblLoad__FP4TMBL3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a23c
// Address: 0x19a23c - 0x19a260

void entry_19a23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a23c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x19a240: 0x2e220003
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 3));
    // 0x19a244: 0x1440fffa
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19A230; return;
    }
    // 0x19a24c: 0x8e440610
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1552)));
    // 0x19a250: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19a254: 0x24060384
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 900));
    // 0x19a258: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x19a260);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_19a260
// Address: 0x19a260 - 0x19a290

void entry_19a260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a260: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19a264: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x19a268: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19a26c: 0x8c6423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 9160)));
    // 0x19a270: 0xae420764
    WRITE32(ADD32(GPR_U32(ctx, 18), 1892), GPR_U32(ctx, 2));
    // 0x19a274: 0xae450614
    WRITE32(ADD32(GPR_U32(ctx, 18), 1556), GPR_U32(ctx, 5));
    // 0x19a278: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19a27c: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x19a280: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19A298; return;
    }
    // 0x19a288: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19a290);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 911));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a290
// Address: 0x19a290 - 0x19a2e0

void entry_19a290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a290) {
        switch (ctx->pc) {
            case 0x19a298: ctx->pc = 0; goto label_19a298;
            case 0x19a2b0: ctx->pc = 0; goto label_19a2b0;
            case 0x19a2d0: ctx->pc = 0; goto label_19a2d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a290: 0x10000099
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19A4F8; return;
    }
label_19a298:
    // 0x19a298: 0x8e420014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x19a29c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19a2a0: 0x3c170026
    SET_GPR_U32(ctx, 23, ((uint32_t)38 << 16));
    // 0x19a2a4: 0x2416002c
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 44));
    // 0x19a2a8: 0xac521ce4
    WRITE32(ADD32(GPR_U32(ctx, 2), 7396), GPR_U32(ctx, 18));
    // 0x19a2ac: 0x961818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
label_19a2b0:
    // 0x19a2b0: 0x24950001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 4), 1));
    // 0x19a2b4: 0x24630658
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1624));
    // 0x19a2b8: 0x2438021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x19a2bc: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19a2c0: 0x18400015
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x19A318; return;
    }
    // 0x19a2c8: 0x26140018
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 16), 24));
    // 0x19a2cc: 0x26110004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 4));
label_19a2d0:
    // 0x19a2d0: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x19a2d4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19a2d8: 0xc056912
    SET_GPR_U32(ctx, 31, 0x19a2e0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19a2e0
// Address: 0x19a2e0 - 0x19a32c

void entry_19a2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a2e0) {
        switch (ctx->pc) {
            case 0x19a308: ctx->pc = 0; goto label_19a308;
            case 0x19a318: ctx->pc = 0; goto label_19a318;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a2e0: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19a2e4: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_19a308;
    }
    // 0x19a2ec: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19a2f0: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x19a2f4: 0x2821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x19a2f8: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x19a2fc: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
    // 0x19a300: 0xae030014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 3));
    // 0x19a304: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_19a308:
    // 0x19a308: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x19a30c: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x19a310: 0x1440ffef
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19A2D0; return;
    }
label_19a318:
    // 0x19a318: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19a31c: 0x18a00004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    if (GPR_S32(ctx, 5) <= 0) {
        ctx->pc = 0x19A330; return;
    }
    // 0x19a324: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x19a32c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_19a32c
// Address: 0x19a32c - 0x19a350

void entry_19a32c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a32c) {
        switch (ctx->pc) {
            case 0x19a330: ctx->pc = 0; goto label_19a330;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a32c: 0xae020028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 2));
label_19a330:
    // 0x19a330: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x19a334: 0x28820006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 6));
    // 0x19a338: 0x1440ffdd
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19A2B0; return;
    }
    // 0x19a340: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x19a344: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19a348: 0xc056912
    SET_GPR_U32(ctx, 31, 0x19a350);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1604)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19a350
// Address: 0x19a350 - 0x19a364

void entry_19a350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a350: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x19a354: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19a358: 0x8e45064c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1612)));
    // 0x19a35c: 0xc056912
    SET_GPR_U32(ctx, 31, 0x19a364);
    WRITE32(ADD32(GPR_U32(ctx, 18), 1608), GPR_U32(ctx, 2));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19a364
// Address: 0x19a364 - 0x19a380

void entry_19a364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a364: 0x10400006
    WRITE32(ADD32(GPR_U32(ctx, 18), 1616), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_19a380(rdram, ctx, runtime); return;
    }
    // 0x19a36c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19a370: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19a374: 0x8c62006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 108)));
    // 0x19a378: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19a380);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19a380
// Address: 0x19a380 - 0x19a3b0

void entry_19a380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a380) {
        switch (ctx->pc) {
            case 0x19a3a8: ctx->pc = 0; goto label_19a3a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a380: 0x8ee323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 9152)));
    // 0x19a384: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x19a388: 0x8c6219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x19a38c: 0x8c6419dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x19a390: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x19a394: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x19a398: 0x14450003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        goto label_19a3a8;
    }
    // 0x19a3a0: 0x10000037
    WRITE32(ADD32(GPR_U32(ctx, 18), 1888), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19A480; return;
    }
label_19a3a8:
    // 0x19a3a8: 0xc05834c
    SET_GPR_U32(ctx, 31, 0x19a3b0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 1888));
    GetBlueprintInfo__FPiT0(rdram, ctx, runtime); return;
}


// Function: entry_19a3b0
// Address: 0x19a3b0 - 0x19a520

void entry_19a3b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a3b0) {
        switch (ctx->pc) {
            case 0x19a3d8: ctx->pc = 0; goto label_19a3d8;
            case 0x19a400: ctx->pc = 0; goto label_19a400;
            case 0x19a41c: ctx->pc = 0; goto label_19a41c;
            case 0x19a448: ctx->pc = 0; goto label_19a448;
            case 0x19a46c: ctx->pc = 0; goto label_19a46c;
            case 0x19a470: ctx->pc = 0; goto label_19a470;
            case 0x19a480: ctx->pc = 0; goto label_19a480;
            case 0x19a4a0: ctx->pc = 0; goto label_19a4a0;
            case 0x19a4b8: ctx->pc = 0; goto label_19a4b8;
            case 0x19a4e0: ctx->pc = 0; goto label_19a4e0;
            case 0x19a4ec: ctx->pc = 0; goto label_19a4ec;
            case 0x19a4f8: ctx->pc = 0; goto label_19a4f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a3b0: 0x8e420760
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1888)));
    // 0x19a3b4: 0x3403f000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 61440));
    // 0x19a3b8: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x19a3bc: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x19a3c0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19a3c4: 0x10400015
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19a41c;
    }
    // 0x19a3cc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19a3d0: 0x8c4523c4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 9156)));
    // 0x19a3d4: 0x24a70438
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 5), 1080));
label_19a3d8:
    // 0x19a3d8: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x19a3dc: 0x24c40001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 1));
    // 0x19a3e0: 0x24a50078
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 120));
    // 0x19a3e4: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x19a3e8: 0xa7182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 5), GPR_U32(ctx, 7)));
    // 0x19a3ec: 0x1460fffa
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_19a3d8;
    }
    // 0x19a3f4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x19a3f8: 0x54c20001
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 1888), GPR_U32(ctx, 0));
        goto label_19a400;
    }
label_19a400:
    // 0x19a400: 0x8e420760
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1888)));
    // 0x19a404: 0x3403f000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 61440));
    // 0x19a408: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x19a40c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x19a410: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19a414: 0x54400022
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 1892), GPR_U32(ctx, 0));
        goto label_19a4a0;
    }
label_19a41c:
    // 0x19a41c: 0x8ee423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 23), 9152)));
    // 0x19a420: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x19a424: 0xae430760
    WRITE32(ADD32(GPR_U32(ctx, 18), 1888), GPR_U32(ctx, 3));
    // 0x19a428: 0x8c8219f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6640)));
    // 0x19a42c: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x19a430: 0x5040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1888)));
        goto label_19a470;
    }
    // 0x19a438: 0x3405f000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 61440));
    // 0x19a43c: 0x52c38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 16);
    // 0x19a440: 0x34a5ffff
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 65535));
    // 0x19a444: 0x8e420760
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1888)));
label_19a448:
    // 0x19a448: 0x21840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 2), 1));
    // 0x19a44c: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x19a450: 0x451024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x19a454: 0x10400005
    WRITE32(ADD32(GPR_U32(ctx, 18), 1888), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19a46c;
    }
    // 0x19a45c: 0x8c8219f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6640)));
    // 0x19a460: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19a464: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1888)));
        goto label_19a448;
    }
label_19a46c:
    // 0x19a46c: 0x8e430760
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1888)));
label_19a470:
    // 0x19a470: 0x3c02f000
    SET_GPR_U32(ctx, 2, ((uint32_t)61440 << 16));
    // 0x19a474: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x19a478: 0x621824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19a47c: 0xae430760
    WRITE32(ADD32(GPR_U32(ctx, 18), 1888), GPR_U32(ctx, 3));
label_19a480:
    // 0x19a480: 0x8e420760
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1888)));
    // 0x19a484: 0x3403f000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 61440));
    // 0x19a488: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x19a48c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x19a490: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19a494: 0x10400018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19a4f8;
    }
    // 0x19a49c: 0xae400764
    WRITE32(ADD32(GPR_U32(ctx, 18), 1892), GPR_U32(ctx, 0));
label_19a4a0:
    // 0x19a4a0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x19a4a4: 0x8e430760
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1888)));
    // 0x19a4a8: 0x8c82a9e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4294945248)));
    // 0x19a4ac: 0x1043000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1892)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_19a4e0;
    }
    // 0x19a4b4: 0x2485a9e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 4294945248));
label_19a4b8:
    // 0x19a4b8: 0x24430001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 1));
    // 0x19a4bc: 0x2862001c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 28));
    // 0x19a4c0: 0x1040000a
    WRITE32(ADD32(GPR_U32(ctx, 18), 1892), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19a4ec;
    }
    // 0x19a4c8: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x19a4cc: 0x8e440760
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1888)));
    // 0x19a4d0: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x19a4d4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19a4d8: 0x1464fff7
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1892)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_19a4b8;
    }
label_19a4e0:
    // 0x19a4e0: 0x2842001c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 28));
    // 0x19a4e4: 0x14400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_19a4f8;
    }
label_19a4ec:
    // 0x19a4ec: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19a4f0: 0xae420764
    WRITE32(ADD32(GPR_U32(ctx, 18), 1892), GPR_U32(ctx, 2));
    // 0x19a4f4: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_19a4f8:
    // 0x19a4f8: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19a4fc: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19a500: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19a504: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19a508: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19a50c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19a510: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19a514: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19a518: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnVaultActive__FP5VAULTiP2PO
// Address: 0x19a520 - 0x19a544

void entry_19a544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a544: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19a548: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19a54c: 0x14620004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        entry_19a560(rdram, ctx, runtime); return;
    }
    // 0x19a554: 0x8e040614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x19a558: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x19a560);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a560
// Address: 0x19a560 - 0x19a580

void entry_19a560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a560: 0x1220003e
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19A65C; return;
    }
    // 0x19a568: 0x2402038f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 911));
    // 0x19a56c: 0x50620005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
        ctx->pc = 0x19A584; return;
    }
    // 0x19a574: 0x8e040614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x19a578: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19a580);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 901));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a580
// Address: 0x19a580 - 0x19a58c

void entry_19a580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a580) {
        switch (ctx->pc) {
            case 0x19a584: ctx->pc = 0; goto label_19a584;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a580: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
label_19a584:
    // 0x19a584: 0xc05bb22
    SET_GPR_U32(ctx, 31, 0x19a58c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    StartJoySelection__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_19a58c
// Address: 0x19a58c - 0x19a5cc

void entry_19a58c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a58c) {
        switch (ctx->pc) {
            case 0x19a5b0: ctx->pc = 0; goto label_19a5b0;
            case 0x19a5c0: ctx->pc = 0; goto label_19a5c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a58c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19a590: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x19a594: 0x8c6319ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 6636)));
    // 0x19a598: 0x30620008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 8));
    // 0x19a59c: 0x14400004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_19a5b0;
    }
    // 0x19a5a4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19a5a8: 0x10000005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 922));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19a5c0;
    }
label_19a5b0:
    // 0x19a5b0: 0x54400010
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1608)));
        ctx->pc = 0x19A5F4; return;
    }
    // 0x19a5b8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19a5bc: 0x2405039b
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 923));
label_19a5c0:
    // 0x19a5c0: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x19a5c4: 0xc056912
    SET_GPR_U32(ctx, 31, 0x19a5cc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19a5cc
// Address: 0x19a5cc - 0x19a674

void entry_19a5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a5cc) {
        switch (ctx->pc) {
            case 0x19a5f4: ctx->pc = 0; goto label_19a5f4;
            case 0x19a618: ctx->pc = 0; goto label_19a618;
            case 0x19a630: ctx->pc = 0; goto label_19a630;
            case 0x19a65c: ctx->pc = 0; goto label_19a65c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a5cc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19a5d0: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1608)));
        goto label_19a5f4;
    }
    // 0x19a5d8: 0x8e0307d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2008)));
    // 0x19a5dc: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x19a5e0: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x19a5e4: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x19a5e8: 0xac4407dc
    WRITE32(ADD32(GPR_U32(ctx, 2), 2012), GPR_U32(ctx, 4));
    // 0x19a5ec: 0xae0307d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 2008), GPR_U32(ctx, 3));
    // 0x19a5f0: 0x8e040648
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1608)));
label_19a5f4:
    // 0x19a5f4: 0x10800008
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_19a618;
    }
    // 0x19a5fc: 0x8e0307d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2008)));
    // 0x19a600: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x19a604: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x19a608: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x19a60c: 0xac4407dc
    WRITE32(ADD32(GPR_U32(ctx, 2), 2012), GPR_U32(ctx, 4));
    // 0x19a610: 0xae0307d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 2008), GPR_U32(ctx, 3));
    // 0x19a614: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_19a618:
    // 0x19a618: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19a61c: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x19a620: 0x1040001b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 1408));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_19a690(rdram, ctx, runtime); return;
    }
    // 0x19a628: 0x24440600
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 1536));
    // 0x19a62c: 0x24420580
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1408));
label_19a630:
    // 0x19a630: 0x78460000
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19a634: 0x78470010
    SET_GPR_VEC(ctx, 7, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x19a638: 0x7c660000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 6));
    // 0x19a63c: 0x7c670010
    WRITE128(ADD32(GPR_U32(ctx, 3), 16), GPR_VEC(ctx, 7));
    // 0x19a640: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x19a644: 0x1444fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        goto label_19a630;
    }
    // 0x19a64c: 0x8ca22e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 11792)));
    // 0x19a650: 0x8c430604
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1540)));
    // 0x19a654: 0x1000000e
    WRITE32(ADD32(GPR_U32(ctx, 16), 1540), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_19a690(rdram, ctx, runtime); return;
    }
label_19a65c:
    // 0x19a65c: 0x2402038f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 911));
    // 0x19a660: 0x10620004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        entry_19a674(rdram, ctx, runtime); return;
    }
    // 0x19a668: 0x8e040614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x19a66c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19a674);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 900));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a674
// Address: 0x19a674 - 0x19a67c

void entry_19a674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a674: 0xc0580a8
    SET_GPR_U32(ctx, 31, 0x19a67c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 2008), GPR_U32(ctx, 0));
    get_game_completion__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19a67c
// Address: 0x19a67c - 0x19a690

void entry_19a67c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a67c: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x19a680: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19A694; return;
    }
    // 0x19a688: 0xc05815e
    SET_GPR_U32(ctx, 31, 0x19a690);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    PlayEndingFromCompletionFlags(rdram, ctx, runtime); return;
}


// Function: entry_19a690
// Address: 0x19a690 - 0x19a6a8

void entry_19a690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a690) {
        switch (ctx->pc) {
            case 0x19a694: ctx->pc = 0; goto label_19a694;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a690: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_19a694:
    // 0x19a694: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19a698: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19a69c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19a6a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19a6a8; return;
}


// Function: UpdateVaultActive__FP5VAULTP3JOYf
// Address: 0x19a6a8 - 0x19a6dc

void entry_19a6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a6dc: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
    // 0x19a6e0: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x19a6e8);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a6e8
// Address: 0x19a6e8 - 0x19a710

void entry_19a6e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a6e8: 0x8fa50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x19a6ec: 0x2403038f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 911));
    // 0x19a6f0: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19a6f4: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x19a6f8: 0x101027
    SET_GPR_U32(ctx, 2, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 16)));
    // 0x19a6fc: 0x14830006
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x19A718; return;
    }
    // 0x19a704: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19a708: 0xc064a74
    SET_GPR_U32(ctx, 31, 0x19a710);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    SwitchToPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_19a710
// Address: 0x19a710 - 0x19a754

void entry_19a710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a710) {
        switch (ctx->pc) {
            case 0x19a718: ctx->pc = 0; goto label_19a718;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a710: 0x10000111
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB58; return;
    }
label_19a718:
    // 0x19a718: 0x2402038e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 910));
    // 0x19a71c: 0x14820050
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x19A860; return;
    }
    // 0x19a724: 0x1464004f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 911));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x19A864; return;
    }
    // 0x19a72c: 0x8e6207d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    // 0x19a730: 0x144000fa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
    // 0x19a738: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19a73c: 0x8c43051c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1308)));
    // 0x19a740: 0x546000f6
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
        ctx->pc = 0x19AB1C; return;
    }
    // 0x19a748: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
    // 0x19a74c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19a754);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 911));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a754
// Address: 0x19a754 - 0x19a7f8

void entry_19a754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a754) {
        switch (ctx->pc) {
            case 0x19a78c: ctx->pc = 0; goto label_19a78c;
            case 0x19a7a8: ctx->pc = 0; goto label_19a7a8;
            case 0x19a7d4: ctx->pc = 0; goto label_19a7d4;
            case 0x19a7f0: ctx->pc = 0; goto label_19a7f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a754: 0x8e630760
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 1888)));
    // 0x19a758: 0x24020040
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 64));
    // 0x19a75c: 0x1062003c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 65));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19A850; return;
    }
    // 0x19a764: 0x10400010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19a7a8;
    }
    // 0x19a76c: 0x1062002c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19A820; return;
    }
    // 0x19a774: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19a78c;
    }
    // 0x19a77c: 0x1062001c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_19a7f0;
    }
    // 0x19a784: 0x100000e5
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
label_19a78c:
    // 0x19a78c: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x19a790: 0x1062001f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19A810; return;
    }
    // 0x19a798: 0x10620015
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_19a7f0;
    }
    // 0x19a7a0: 0x100000de
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
label_19a7a8:
    // 0x19a7a8: 0x24020400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1024));
    // 0x19a7ac: 0x1062001c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1025));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19A820; return;
    }
    // 0x19a7b4: 0x10400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 128));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19a7d4;
    }
    // 0x19a7bc: 0x10620010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 512));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19A800; return;
    }
    // 0x19a7c4: 0x1062001a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19A830; return;
    }
    // 0x19a7cc: 0x100000d3
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
label_19a7d4:
    // 0x19a7d4: 0x24021000
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4096));
    // 0x19a7d8: 0x1062000d
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19A810; return;
    }
    // 0x19a7e0: 0x10620017
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19A840; return;
    }
    // 0x19a7e8: 0x100000cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
label_19a7f0:
    // 0x19a7f0: 0xc074a72
    SET_GPR_U32(ctx, 31, 0x19a7f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetFsp__F3FSP(rdram, ctx, runtime); return;
}


// Function: entry_19a7f8
// Address: 0x19a7f8 - 0x19a808

void entry_19a7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a7f8) {
        switch (ctx->pc) {
            case 0x19a800: ctx->pc = 0; goto label_19a800;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a7f8: 0x100000c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
label_19a800:
    // 0x19a800: 0xc074a72
    SET_GPR_U32(ctx, 31, 0x19a808);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    SetFsp__F3FSP(rdram, ctx, runtime); return;
}


// Function: entry_19a808
// Address: 0x19a808 - 0x19a818

void entry_19a808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a808) {
        switch (ctx->pc) {
            case 0x19a810: ctx->pc = 0; goto label_19a810;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a808: 0x100000c4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
label_19a810:
    // 0x19a810: 0xc074a72
    SET_GPR_U32(ctx, 31, 0x19a818);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    SetFsp__F3FSP(rdram, ctx, runtime); return;
}


// Function: entry_19a818
// Address: 0x19a818 - 0x19a828

void entry_19a818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a818) {
        switch (ctx->pc) {
            case 0x19a820: ctx->pc = 0; goto label_19a820;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a818: 0x100000c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
label_19a820:
    // 0x19a820: 0xc074a72
    SET_GPR_U32(ctx, 31, 0x19a828);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    SetFsp__F3FSP(rdram, ctx, runtime); return;
}


// Function: entry_19a828
// Address: 0x19a828 - 0x19a838

void entry_19a828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a828) {
        switch (ctx->pc) {
            case 0x19a830: ctx->pc = 0; goto label_19a830;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a828: 0x100000bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
label_19a830:
    // 0x19a830: 0xc074a72
    SET_GPR_U32(ctx, 31, 0x19a838);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    SetFsp__F3FSP(rdram, ctx, runtime); return;
}


// Function: entry_19a838
// Address: 0x19a838 - 0x19a848

void entry_19a838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a838) {
        switch (ctx->pc) {
            case 0x19a840: ctx->pc = 0; goto label_19a840;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a838: 0x100000b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
label_19a840:
    // 0x19a840: 0xc074a72
    SET_GPR_U32(ctx, 31, 0x19a848);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 6));
    SetFsp__F3FSP(rdram, ctx, runtime); return;
}


// Function: entry_19a848
// Address: 0x19a848 - 0x19a858

void entry_19a848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a848) {
        switch (ctx->pc) {
            case 0x19a850: ctx->pc = 0; goto label_19a850;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a848: 0x100000b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
label_19a850:
    // 0x19a850: 0xc074a72
    SET_GPR_U32(ctx, 31, 0x19a858);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    SetFsp__F3FSP(rdram, ctx, runtime); return;
}


// Function: entry_19a858
// Address: 0x19a858 - 0x19a87c

void entry_19a858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a858) {
        switch (ctx->pc) {
            case 0x19a860: ctx->pc = 0; goto label_19a860;
            case 0x19a864: ctx->pc = 0; goto label_19a864;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a858: 0x100000b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB1C; return;
    }
label_19a860:
    // 0x19a860: 0x2402038f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 911));
label_19a864:
    // 0x19a864: 0x106200ac
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 910));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19AB18; return;
    }
    // 0x19a86c: 0x106200b9
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        entry_19ab54(rdram, ctx, runtime); return;
    }
    // 0x19a874: 0xc05bb26
    SET_GPR_U32(ctx, 31, 0x19a87c);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 4294967295));
    DxSelectionJoy__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_19a87c
// Address: 0x19a87c - 0x19a888

void entry_19a87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a87c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19a880: 0xc05bbb4
    SET_GPR_U32(ctx, 31, 0x19a888);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    DySelectionJoy__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_19a888
// Address: 0x19a888 - 0x19a8f8

void entry_19a888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a888) {
        switch (ctx->pc) {
            case 0x19a8b0: ctx->pc = 0; goto label_19a8b0;
            case 0x19a8c4: ctx->pc = 0; goto label_19a8c4;
            case 0x19a8d4: ctx->pc = 0; goto label_19a8d4;
            case 0x19a8e4: ctx->pc = 0; goto label_19a8e4;
            case 0x19a8ec: ctx->pc = 0; goto label_19a8ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a888: 0x6220018
    if (GPR_S32(ctx, 17) < 0) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
        goto label_19a8ec;
    }
    // 0x19a890: 0x5e200016
    if (GPR_S32(ctx, 17) > 0) {
        SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_19a8ec;
    }
    // 0x19a898: 0x4420014
    if (GPR_S32(ctx, 2) < 0) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
        goto label_19a8ec;
    }
    // 0x19a8a0: 0x58400003
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 20), 170)));
        goto label_19a8b0;
    }
    // 0x19a8a8: 0x10000010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19a8ec;
    }
label_19a8b0:
    // 0x19a8b0: 0x30620020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 32));
    // 0x19a8b4: 0x10400003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 128));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19a8c4;
    }
    // 0x19a8bc: 0x1000000b
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19a8ec;
    }
label_19a8c4:
    // 0x19a8c4: 0x10400003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19a8d4;
    }
    // 0x19a8cc: 0x10000007
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19a8ec;
    }
label_19a8d4:
    // 0x19a8d4: 0x10400003
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19a8e4;
    }
    // 0x19a8dc: 0x10000003
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19a8ec;
    }
label_19a8e4:
    // 0x19a8e4: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x19a8e8: 0x43900b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 2));
label_19a8ec:
    // 0x19a8ec: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19a8f0: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x19a8f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 240));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_19a8f8
// Address: 0x19a8f8 - 0x19a964

void entry_19a8f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a8f8) {
        switch (ctx->pc) {
            case 0x19a91c: ctx->pc = 0; goto label_19a91c;
            case 0x19a934: ctx->pc = 0; goto label_19a934;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a8f8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19a8fc: 0x1242001b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 2));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19A96C; return;
    }
    // 0x19a904: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19a91c;
    }
    // 0x19a90c: 0x12400009
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_19a934;
    }
    // 0x19a914: 0x10000059
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 1600)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA7C; return;
    }
label_19a91c:
    // 0x19a91c: 0x12420025
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19A9B4; return;
    }
    // 0x19a924: 0x1242003c
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19AA18; return;
    }
    // 0x19a92c: 0x10000053
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 1600)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA7C; return;
    }
label_19a934:
    // 0x19a934: 0x2a020385
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 901));
    // 0x19a938: 0x54400050
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 1600)));
        ctx->pc = 0x19AA7C; return;
    }
    // 0x19a940: 0x2a020388
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 904));
    // 0x19a944: 0x54400017
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
        ctx->pc = 0x19A9A4; return;
    }
    // 0x19a94c: 0x2a02038b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 907));
    // 0x19a950: 0x5040004a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 1600)));
        ctx->pc = 0x19AA7C; return;
    }
    // 0x19a958: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
    // 0x19a95c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19a964);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 907));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a964
// Address: 0x19a964 - 0x19a990

void entry_19a964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a964) {
        switch (ctx->pc) {
            case 0x19a96c: ctx->pc = 0; goto label_19a96c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a964: 0x10000044
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA78; return;
    }
label_19a96c:
    // 0x19a96c: 0x2a020388
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 904));
    // 0x19a970: 0x14400041
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA78; return;
    }
    // 0x19a978: 0x2a02038b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 907));
    // 0x19a97c: 0x10400006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 910));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19A998; return;
    }
    // 0x19a984: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
    // 0x19a988: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19a990);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 901));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a990
// Address: 0x19a990 - 0x19a9ac

void entry_19a990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a990) {
        switch (ctx->pc) {
            case 0x19a998: ctx->pc = 0; goto label_19a998;
            case 0x19a9a4: ctx->pc = 0; goto label_19a9a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a990: 0x10000039
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA78; return;
    }
label_19a998:
    // 0x19a998: 0x10400037
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA78; return;
    }
    // 0x19a9a0: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
label_19a9a4:
    // 0x19a9a4: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19a9ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 904));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a9ac
// Address: 0x19a9ac - 0x19a9e8

void entry_19a9ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19a9ac) {
        switch (ctx->pc) {
            case 0x19a9b4: ctx->pc = 0; goto label_19a9b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19a9ac: 0x10000032
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA78; return;
    }
label_19a9b4:
    // 0x19a9b4: 0x2603fc7b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4294966395));
    // 0x19a9b8: 0x2c620009
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 9));
    // 0x19a9bc: 0x1040002d
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_19aa74(rdram, ctx, runtime); return;
    }
    // 0x19a9c4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x19a9c8: 0x2442c870
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294953072));
    // 0x19a9cc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19a9d0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x19a9d4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x19a9dc: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
    // 0x19a9e0: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19a9e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 902));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a9e8
// Address: 0x19a9e8 - 0x19a9fc

void entry_19a9e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a9e8: 0x10000023
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA78; return;
    }
    // 0x19a9f0: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
    // 0x19a9f4: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19a9fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 905));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19a9fc
// Address: 0x19a9fc - 0x19aa10

void entry_19a9fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19a9fc: 0x1000001e
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA78; return;
    }
    // 0x19aa04: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
    // 0x19aa08: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19aa10);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 908));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19aa10
// Address: 0x19aa10 - 0x19aa4c

void entry_19aa10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19aa10) {
        switch (ctx->pc) {
            case 0x19aa18: ctx->pc = 0; goto label_19aa18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19aa10: 0x10000019
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA78; return;
    }
label_19aa18:
    // 0x19aa18: 0x2603fc7b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4294966395));
    // 0x19aa1c: 0x2c620009
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 9));
    // 0x19aa20: 0x10400014
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_19aa74(rdram, ctx, runtime); return;
    }
    // 0x19aa28: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x19aa2c: 0x2442c8a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294953120));
    // 0x19aa30: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19aa34: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x19aa38: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x19aa40: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
    // 0x19aa44: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19aa4c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 903));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19aa4c
// Address: 0x19aa4c - 0x19aa60

void entry_19aa4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19aa4c: 0x1000000a
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA78; return;
    }
    // 0x19aa54: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
    // 0x19aa58: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19aa60);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 906));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19aa60
// Address: 0x19aa60 - 0x19aa74

void entry_19aa60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19aa60: 0x10000005
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AA78; return;
    }
    // 0x19aa68: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
    // 0x19aa6c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x19aa74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 909));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_19aa74
// Address: 0x19aa74 - 0x19aac0

void entry_19aa74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19aa74) {
        switch (ctx->pc) {
            case 0x19aa78: ctx->pc = 0; goto label_19aa78;
            case 0x19aa7c: ctx->pc = 0; goto label_19aa7c;
            case 0x19aa90: ctx->pc = 0; goto label_19aa90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19aa74: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_19aa78:
    // 0x19aa78: 0x8e710640
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 19), 1600)));
label_19aa7c:
    // 0x19aa7c: 0x2415ffff
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19aa80: 0x24140064
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 100));
    // 0x19aa84: 0x10000010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 1564));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AAC8; return;
    }
    // 0x19aa8c: 0x0
    // NOP
label_19aa90:
    // 0x19aa90: 0x2248818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x19aa94: 0x2a420003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 3));
    // 0x19aa98: 0x1440000b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AAC8; return;
    }
    // 0x19aaa0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19aaa4: 0x8c4423c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9160)));
    // 0x19aaa8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19aaac: 0x30630004
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 4));
    // 0x19aab0: 0x5460001a
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
        ctx->pc = 0x19AB1C; return;
    }
    // 0x19aab8: 0xc066b5a
    SET_GPR_U32(ctx, 31, 0x19aac0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    OpenVault__FP5VAULT(rdram, ctx, runtime); return;
}


// Function: entry_19aac0
// Address: 0x19aac0 - 0x19aad4

void entry_19aac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19aac0) {
        switch (ctx->pc) {
            case 0x19aac8: ctx->pc = 0; goto label_19aac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19aac0: 0x10000025
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB58; return;
    }
label_19aac8:
    // 0x19aac8: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x19aacc: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x19aad4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 8));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_19aad4
// Address: 0x19aad4 - 0x19aaec

void entry_19aad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19aad4: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x19aad8: 0x54550010
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
        ctx->pc = 0x19AB1C; return;
    }
    // 0x19aae0: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x19aae4: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x19aaec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 12));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_19aaec
// Address: 0x19aaec - 0x19ab38

void entry_19aaec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19aaec) {
        switch (ctx->pc) {
            case 0x19ab00: ctx->pc = 0; goto label_19ab00;
            case 0x19ab18: ctx->pc = 0; goto label_19ab18;
            case 0x19ab1c: ctx->pc = 0; goto label_19ab1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19aaec: 0x234001a
    { int32_t divisor = GPR_S32(ctx, 20); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 17) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 20) % divisor); } else { ctx->lo = (GPR_S32(ctx,17) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,20); } }
    // 0x19aaf0: 0x2404000a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 10));
    // 0x19aaf4: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x19aaf8: 0x52800001
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_19ab00;
    }
label_19ab00:
    // 0x19ab00: 0x2463fc70
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294966384));
    // 0x19ab04: 0x2812
    SET_GPR_U32(ctx, 5, ctx->lo);
    // 0x19ab08: 0xa4001a
    { int32_t divisor = GPR_S32(ctx, 4); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 5) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 4) % divisor); } else { ctx->lo = (GPR_S32(ctx,5) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,4); } }
    // 0x19ab0c: 0x1010
    SET_GPR_U32(ctx, 2, ctx->hi);
    // 0x19ab10: 0x5062ffdf
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
        ctx->pc = 0x19AA90; return;
    }
label_19ab18:
    // 0x19ab18: 0x8e6207d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
label_19ab1c:
    // 0x19ab1c: 0x1840000d
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_19ab54(rdram, ctx, runtime); return;
    }
    // 0x19ab24: 0x8c43051c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1308)));
    // 0x19ab28: 0x1460000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AB58; return;
    }
    // 0x19ab30: 0xc05462e
    SET_GPR_U32(ctx, 31, 0x19ab38);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 2012)));
    TriggerDialog__FP6DIALOG(rdram, ctx, runtime); return;
}


// Function: entry_19ab38
// Address: 0x19ab38 - 0x19ab54

void entry_19ab38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ab38: 0x8e6207d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 2008)));
    // 0x19ab3c: 0x266507e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 2016));
    // 0x19ab40: 0x266407dc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 2012));
    // 0x19ab44: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x19ab48: 0x23080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 2), 2));
    // 0x19ab4c: 0xc063600
    SET_GPR_U32(ctx, 31, 0x19ab54);
    WRITE32(ADD32(GPR_U32(ctx, 19), 2008), GPR_U32(ctx, 2));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_19ab54
// Address: 0x19ab54 - 0x19ab78

void entry_19ab54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19ab54) {
        switch (ctx->pc) {
            case 0x19ab58: ctx->pc = 0; goto label_19ab58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19ab54: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_19ab58:
    // 0x19ab58: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19ab5c: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19ab60: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19ab64: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19ab68: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19ab6c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19ab70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HandleVaultMessage__FP5VAULT5MSGIDPv
// Address: 0x19ab78 - 0x19ab9c

void entry_19ab9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ab9c: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x19aba0: 0x1602005d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x19AD18; return;
    }
    // 0x19aba8: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x19abac: 0x8e420650
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1616)));
    // 0x19abb0: 0x5462005a
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        ctx->pc = 0x19AD1C; return;
    }
    // 0x19abb8: 0x8e420654
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1620)));
    // 0x19abbc: 0x1040000b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19ABEC; return;
    }
    // 0x19abc4: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x19abc8: 0x10800008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19ABEC; return;
    }
    // 0x19abd0: 0xac9223cc
    WRITE32(ADD32(GPR_U32(ctx, 4), 9164), GPR_U32(ctx, 18));
    // 0x19abd4: 0xac82239c
    WRITE32(ADD32(GPR_U32(ctx, 4), 9116), GPR_U32(ctx, 2));
    // 0x19abd8: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x19abdc: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x19abe4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_19abe4
// Address: 0x19abe4 - 0x19ac00

void entry_19abe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19abe4) {
        switch (ctx->pc) {
            case 0x19abec: ctx->pc = 0; goto label_19abec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19abe4: 0x1000004c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AD18; return;
    }
label_19abec:
    // 0x19abec: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x19abf0: 0x8c83c948
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294953288)));
    // 0x19abf4: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x19abf8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19ac00);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294953288));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19ac00
// Address: 0x19ac00 - 0x19ac28

void entry_19ac00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ac00: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x19ac04: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x19ac08: 0x8c6523c8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 9160)));
    // 0x19ac0c: 0x8c825710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 22288)));
    // 0x19ac10: 0x8ca60064
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 5), 100)));
    // 0x19ac14: 0x8c472300
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 8960)));
    // 0x19ac18: 0x14c70007
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 7)) {
        ctx->pc = 0x19AC38; return;
    }
    // 0x19ac20: 0xc066800
    SET_GPR_U32(ctx, 31, 0x19ac28);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1888)));
    FUN_0019a000(rdram, ctx, runtime); return;
}


// Function: entry_19ac28
// Address: 0x19ac28 - 0x19acf4

void entry_19ac28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19ac28) {
        switch (ctx->pc) {
            case 0x19ac38: ctx->pc = 0; goto label_19ac38;
            case 0x19acac: ctx->pc = 0; goto label_19acac;
            case 0x19acb0: ctx->pc = 0; goto label_19acb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19ac28: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x19ac2c: 0x24030005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 5));
    // 0x19ac30: 0x1000001e
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19acac;
    }
label_19ac38:
    // 0x19ac38: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x19ac3c: 0x3c05f000
    SET_GPR_U32(ctx, 5, ((uint32_t)61440 << 16));
    // 0x19ac40: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x19ac44: 0x8c6219f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6640)));
    // 0x19ac48: 0x451024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x19ac4c: 0x14400018
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_19acb0;
    }
    // 0x19ac54: 0x24e2ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 7), 4294967295));
    // 0x19ac58: 0x10c20014
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        goto label_19acac;
    }
    // 0x19ac60: 0x44860000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 6);
    // 0x19ac64: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x19ac68: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x19ac6c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x19ac70: 0x44870800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 7);
    // 0x19ac74: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x19ac78: 0x46010043
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[1] = ctx->f[0] / ctx->f[1];
    // 0x19ac7c: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19ac80: 0x0
    // NOP
    // 0x19ac84: 0x45010009
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_19acac;
    }
    // 0x19ac8c: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x19ac90: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x19ac94: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19ac98: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19ac9c: 0x0
    // NOP
    // 0x19aca0: 0x45000002
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19acac;
    }
    // 0x19aca8: 0x24080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
label_19acac:
    // 0x19acac: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_19acb0:
    // 0x19acb0: 0x11020018
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 44));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19AD14; return;
    }
    // 0x19acb8: 0x1108018
    { int64_t result = (int64_t)GPR_S32(ctx, 8) * (int64_t)GPR_S32(ctx, 16); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x19acbc: 0x26100658
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1624));
    // 0x19acc0: 0x2508021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
    // 0x19acc4: 0x8e020028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    // 0x19acc8: 0x26050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 24));
    // 0x19accc: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x19acd0: 0xa21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x19acd4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19acd8: 0x8c640304
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 772)));
    // 0x19acdc: 0xac800000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 0));
    // 0x19ace0: 0x8e020028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    // 0x19ace4: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x19ace8: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x19acec: 0xc05462e
    SET_GPR_U32(ctx, 31, 0x19acf4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    TriggerDialog__FP6DIALOG(rdram, ctx, runtime); return;
}


// Function: entry_19acf4
// Address: 0x19acf4 - 0x19ad30

void entry_19acf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19acf4) {
        switch (ctx->pc) {
            case 0x19ad0c: ctx->pc = 0; goto label_19ad0c;
            case 0x19ad14: ctx->pc = 0; goto label_19ad14;
            case 0x19ad18: ctx->pc = 0; goto label_19ad18;
            case 0x19ad1c: ctx->pc = 0; goto label_19ad1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19acf4: 0x8e020028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    // 0x19acf8: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19acfc: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x19ad00: 0x43001a
    { int32_t divisor = GPR_S32(ctx, 3); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 3) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,3); } }
    // 0x19ad04: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_19ad0c;
    }
label_19ad0c:
    // 0x19ad0c: 0x2010
    SET_GPR_U32(ctx, 4, ctx->hi);
    // 0x19ad10: 0xae040028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 4));
label_19ad14:
    // 0x19ad14: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_19ad18:
    // 0x19ad18: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_19ad1c:
    // 0x19ad1c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19ad20: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19ad24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19ad2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19ad30; return;
}


// Function: AddVaultGoadDialog__FP5VAULT5GOADK3OID
// Address: 0x19ad30 - 0x19ad68

void entry_19ad88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ad88: 0x8e040650
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1616)));
    // 0x19ad8c: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 2008), GPR_U32(ctx, 0));
        ctx->pc = 0x19ADAC; return;
    }
    // 0x19ad94: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19ad98: 0x8c620070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x19ad9c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19ada4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19ada4
// Address: 0x19ada4 - 0x19adc8

void entry_19ada4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19ada4) {
        switch (ctx->pc) {
            case 0x19adac: ctx->pc = 0; goto label_19adac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19ada4: 0xae000650
    WRITE32(ADD32(GPR_U32(ctx, 16), 1616), GPR_U32(ctx, 0));
    // 0x19ada8: 0xae0007d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 2008), GPR_U32(ctx, 0));
label_19adac:
    // 0x19adac: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19adb0: 0x8c430454
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1108)));
    // 0x19adb4: 0x50600005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1888)));
        ctx->pc = 0x19ADCC; return;
    }
    // 0x19adbc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x19adc0: 0xc07a55c
    SET_GPR_U32(ctx, 31, 0x19adc8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PopUiActiveBlot__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_19adc8
// Address: 0x19adc8 - 0x19ae54

void entry_19adc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19adc8) {
        switch (ctx->pc) {
            case 0x19adcc: ctx->pc = 0; goto label_19adcc;
            case 0x19ae40: ctx->pc = 0; goto label_19ae40;
            case 0x19ae48: ctx->pc = 0; goto label_19ae48;
            case 0x19ae4c: ctx->pc = 0; goto label_19ae4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19adc8: 0x8e020760
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1888)));
label_19adcc:
    // 0x19adcc: 0x3403f000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 61440));
    // 0x19add0: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x19add4: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x19add8: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19addc: 0x10400042
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19AEE8; return;
    }
    // 0x19ade4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x19ade8: 0x8c4523c4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 9156)));
    // 0x19adec: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x19adf0: 0x8c6723c0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x19adf4: 0x8ca2043c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 1084)));
    // 0x19adf8: 0x8c8623c8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 9160)));
    // 0x19adfc: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x19ae00: 0xaca2043c
    WRITE32(ADD32(GPR_U32(ctx, 5), 1084), GPR_U32(ctx, 2));
    // 0x19ae04: 0x8e020760
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1888)));
    // 0x19ae08: 0x8ce319f0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 6640)));
    // 0x19ae0c: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19ae10: 0xace319f0
    WRITE32(ADD32(GPR_U32(ctx, 7), 6640), GPR_U32(ctx, 3));
    // 0x19ae14: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19ae18: 0xac801ce4
    WRITE32(ADD32(GPR_U32(ctx, 4), 7396), GPR_U32(ctx, 0));
    // 0x19ae1c: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x19ae20: 0x34420004
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 4));
    // 0x19ae24: 0xacc20000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    // 0x19ae28: 0x8ce319ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 6636)));
    // 0x19ae2c: 0x30620008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 8));
    // 0x19ae30: 0x14400003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_19ae40;
    }
    // 0x19ae38: 0x10000003
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), 8));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19ae48;
    }
label_19ae40:
    // 0x19ae40: 0x14400002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 3), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_19ae4c;
    }
label_19ae48:
    // 0x19ae48: 0xace219ec
    WRITE32(ADD32(GPR_U32(ctx, 7), 6636), GPR_U32(ctx, 2));
label_19ae4c:
    // 0x19ae4c: 0xc0580a8
    SET_GPR_U32(ctx, 31, 0x19ae54);
    get_game_completion__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19ae54
// Address: 0x19ae54 - 0x19ae68

void entry_19ae54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ae54: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x19ae58: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1888)));
        ctx->pc = 0x19AE6C; return;
    }
    // 0x19ae60: 0xc05812e
    SET_GPR_U32(ctx, 31, 0x19ae68);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    UnlockEndgameCutscenesFromFgs(rdram, ctx, runtime); return;
}


// Function: entry_19ae68
// Address: 0x19ae68 - 0x19ae88

void entry_19ae68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19ae68) {
        switch (ctx->pc) {
            case 0x19ae6c: ctx->pc = 0; goto label_19ae6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19ae68: 0x8e030760
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1888)));
label_19ae6c:
    // 0x19ae6c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19ae70: 0x10620005
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 894));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        entry_19ae88(rdram, ctx, runtime); return;
    }
    // 0x19ae78: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x19ae7c: 0x2411037f
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 895));
    // 0x19ae80: 0xc0631fe
    SET_GPR_U32(ctx, 31, 0x19ae88);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c7f8__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_19ae88
// Address: 0x19ae88 - 0x19ae9c

void entry_19ae88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ae88: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19ae8c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19ae90: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x19ae94: 0xc056906
    SET_GPR_U32(ctx, 31, 0x19ae9c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19ae9c
// Address: 0x19ae9c - 0x19aeb4

void entry_19ae9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ae9c: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_19aeb4(rdram, ctx, runtime); return;
    }
    // 0x19aea4: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19aea8: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x19aeac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19aeb4);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19aeb4
// Address: 0x19aeb4 - 0x19af00

void entry_19aeb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19aeb4) {
        switch (ctx->pc) {
            case 0x19aee8: ctx->pc = 0; goto label_19aee8;
            case 0x19aeec: ctx->pc = 0; goto label_19aeec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19aeb4: 0x8e020764
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1892)));
    // 0x19aeb8: 0x440000b
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    if (GPR_S32(ctx, 2) < 0) {
        goto label_19aee8;
    }
    // 0x19aec0: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x19aec4: 0x8c440768
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1896)));
    // 0x19aec8: 0x10800008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_19aeec;
    }
    // 0x19aed0: 0x8e0307d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 2008)));
    // 0x19aed4: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x19aed8: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x19aedc: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x19aee0: 0xac4407dc
    WRITE32(ADD32(GPR_U32(ctx, 2), 2012), GPR_U32(ctx, 4));
    // 0x19aee4: 0xae0307d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 2008), GPR_U32(ctx, 3));
label_19aee8:
    // 0x19aee8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_19aeec:
    // 0x19aeec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19aef0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19aef4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19aefc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19af00; return;
}


// Function: InitRail__FP4RAIL
// Address: 0x19af00 - 0x19af14

void entry_19af14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19af14: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x19af18: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19af1c: 0xc440c8c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294953156)); ctx->f[0] = *(float*)&val; }
    // 0x19af20: 0xae030054
    WRITE32(ADD32(GPR_U32(ctx, 16), 84), GPR_U32(ctx, 3));
    // 0x19af24: 0xe600004c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 76), *(uint32_t*)&val); }
    // 0x19af28: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19af2c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19af30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnRailAdd__FP4RAIL
// Address: 0x19af38 - 0x19af4c

void entry_19af4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19af4c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19af50: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19af54: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x19af5c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7312));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_19af5c
// Address: 0x19af5c - 0x19af70

void entry_19af5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19af5c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19af60: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19af64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19af6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19af70; return;
}


// Function: OnRailRemove__FP4RAIL
// Address: 0x19af70 - 0x19af84

void entry_19af84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19af84: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19af88: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19af8c: 0xc054980
    SET_GPR_U32(ctx, 31, 0x19af94);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7312));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_19af94
// Address: 0x19af94 - 0x19afa8

void entry_19af94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19af94: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19af98: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19af9c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19afa4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19afa8; return;
}


// Function: PostLoadRail__FP4RAIL
// Address: 0x19afa8 - 0x19afbc

void entry_19afbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19afbc: 0x8e060054
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 84)));
    // 0x19afc0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19afc4: 0x10c20005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19AFDC; return;
    }
    // 0x19afcc: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19afd0: 0xc056906
    SET_GPR_U32(ctx, 31, 0x19afd8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19afd8
// Address: 0x19afd8 - 0x19aff0

void entry_19afd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19afd8) {
        switch (ctx->pc) {
            case 0x19afdc: ctx->pc = 0; goto label_19afdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19afd8: 0xae020058
    WRITE32(ADD32(GPR_U32(ctx, 16), 88), GPR_U32(ctx, 2));
label_19afdc:
    // 0x19afdc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19afe0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19afe4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19afec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19aff0; return;
}


// Function: CloneRail__FP4RAILT0
// Address: 0x19aff0 - 0x19b018

void entry_19b018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b018: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x19b01c: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x19b020: 0xb202003f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 63); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x19b024: 0xb6020038
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 56); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x19b028: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19b02c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19b030: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitRat__FP3RAT
// Address: 0x19b038 - 0x19b04c

void entry_19b04c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b04c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19b050: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x19b054: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19b058: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x19b05c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19b060: 0xe60d060c
    { float val = ctx->f[13]; WRITE32(ADD32(GPR_U32(ctx, 16), 1548), *(uint32_t*)&val); }
    // 0x19b064: 0xe6000608
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1544), *(uint32_t*)&val); }
    // 0x19b068: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x19b06c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19b070: 0xc44c185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[12] = *(float*)&val; }
    // 0x19b074: 0x3c014020
    SET_GPR_U32(ctx, 1, ((uint32_t)16416 << 16));
    // 0x19b078: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x19b07c: 0xc07aad2
    SET_GPR_U32(ctx, 31, 0x19b084);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[1]);
    GRandGaussian__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_19b084
// Address: 0x19b084 - 0x19b0a0

void entry_19b084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b084: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19b088: 0xe600055c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1372), *(uint32_t*)&val); }
    // 0x19b08c: 0xae020664
    WRITE32(ADD32(GPR_U32(ctx, 16), 1636), GPR_U32(ctx, 2));
    // 0x19b090: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19b094: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19b098: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadRatFromBrx__FP3RATP18CBinaryInputStream
// Address: 0x19b0a0 - 0x19b0d0

void entry_19b0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b0d0: 0x262405f8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1528));
    // 0x19b0d4: 0xc05651e
    SET_GPR_U32(ctx, 31, 0x19b0dc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    InferExpl__FPP4EXPLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_19b0dc
// Address: 0x19b0dc - 0x19b0f0

void entry_19b0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b0dc: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x19b0e0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19b0e4: 0x24c6ab90
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294945680));
    // 0x19b0e8: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x19b0f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_19b0f0
// Address: 0x19b0f0 - 0x19b104

void entry_19b0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b0f0) {
        switch (ctx->pc) {
            case 0x19b0f8: ctx->pc = 0; goto label_19b0f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b0f0: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x19b0f4: 0x0
    // NOP
label_19b0f8:
    // 0x19b0f8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19b0fc: 0xc056920
    SET_GPR_U32(ctx, 31, 0x19b104);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PloFindSwChild__FP2SW3OIDP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_19b104
// Address: 0x19b104 - 0x19b118

void entry_19b104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b104: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19b108: 0x12000012
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B154; return;
    }
    // 0x19b110: 0xc060bb6
    SET_GPR_U32(ctx, 31, 0x19b118);
    SnipLo__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19b118
// Address: 0x19b118 - 0x19b188

void entry_19b118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b118) {
        switch (ctx->pc) {
            case 0x19b140: ctx->pc = 0; goto label_19b140;
            case 0x19b154: ctx->pc = 0; goto label_19b154;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b118: 0x2a420279
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 633));
    // 0x19b11c: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1448)));
        goto label_19b140;
    }
    // 0x19b124: 0x8e230564
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1380)));
    // 0x19b128: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x19b12c: 0x2821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x19b130: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x19b134: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x19b138: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 17), 1380), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19b154;
    }
label_19b140:
    // 0x19b140: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x19b144: 0x2621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x19b148: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x19b14c: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x19b150: 0xae2305a8
    WRITE32(ADD32(GPR_U32(ctx, 17), 1448), GPR_U32(ctx, 3));
label_19b154:
    // 0x19b154: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x19b158: 0x2a420288
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 648));
    // 0x19b15c: 0x5440ffe6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x19B0F8; return;
    }
    // 0x19b164: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19b168: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19b16c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19b170: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19b174: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19b178: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19b17c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19b184: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19b188; return;
}


// Function: PostRatLoad__FP3RAT
// Address: 0x19b188 - 0x19b1a8

void entry_19b1a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b1a8: 0xc049292
    SET_GPR_U32(ctx, 31, 0x19b1b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PostAloLoad__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_19b1b0
// Address: 0x19b1b0 - 0x19b1c4

void entry_19b1b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b1b0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19b1b4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19b1b8: 0xae020550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 2));
    // 0x19b1bc: 0xc067070
    SET_GPR_U32(ctx, 31, 0x19b1c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetRatRats__FP3RAT4RATS(rdram, ctx, runtime); return;
}


// Function: entry_19b1c4
// Address: 0x19b1c4 - 0x19b1e0

void entry_19b1c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b1c4: 0x7a020140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x19b1c8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19b1cc: 0x7e020650
    WRITE128(ADD32(GPR_U32(ctx, 16), 1616), GPR_VEC(ctx, 2));
    // 0x19b1d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19b1d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19b1dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19b1e0; return;
}


// Function: OnRatAdd__FP3RAT
// Address: 0x19b1e0 - 0x19b1f4

void entry_19b1f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b1f4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19b1f8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19b1fc: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x19b204);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7264));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_19b204
// Address: 0x19b204 - 0x19b218

void entry_19b204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b204: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19b208: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19b20c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19b214: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19b218; return;
}


// Function: OnRatRemove__FP3RAT
// Address: 0x19b218 - 0x19b22c

void entry_19b22c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b22c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19b230: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19b234: 0xc054980
    SET_GPR_U32(ctx, 31, 0x19b23c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7264));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_19b23c
// Address: 0x19b23c - 0x19b250

void entry_19b23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b23c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19b240: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19b244: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19b24c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19b250; return;
}


// Function: CloneRat__FP3RATT0
// Address: 0x19b250 - 0x19b278

void entry_19b278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b278: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x19b27c: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x19b280: 0xb2020607
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1543); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x19b284: 0xb6020600
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1536); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x19b288: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19b28c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19b290: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PresetRatAccel__FP3RATf
// Address: 0x19b298 - 0x19b2b8

void entry_19b2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b2b8) {
        switch (ctx->pc) {
            case 0x19b2d8: ctx->pc = 0; goto label_19b2d8;
            case 0x19b2e8: ctx->pc = 0; goto label_19b2e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b2b8: 0x8e230550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x19b2bc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19b2c0: 0x10620005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_19b2d8;
    }
    // 0x19b2c8: 0x10620007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_19b2e8;
    }
    // 0x19b2d0: 0x1000001c
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B344; return;
    }
label_19b2d8:
    // 0x19b2d8: 0xda210640
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1600)));
    // 0x19b2dc: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x19b2e0: 0x1000000a
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B30C; return;
    }
label_19b2e8:
    // 0x19b2e8: 0x8e260660
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1632)));
    // 0x19b2ec: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19b2f0: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x19b2f4: 0x8cc40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x19b2f8: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x19b300);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_19b300
// Address: 0x19b300 - 0x19b324

void entry_19b300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b300) {
        switch (ctx->pc) {
            case 0x19b30c: ctx->pc = 0; goto label_19b30c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b300: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x19b304: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x19b308: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_19b30c:
    // 0x19b30c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19b310: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b314: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19b318: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19b31c: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x19b324);
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_19b324
// Address: 0x19b324 - 0x19b33c

void entry_19b324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b324: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x19b328: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19b32c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x19b330: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19b334: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x19b33c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294945712));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_19b33c
// Address: 0x19b33c - 0x19b35c

void entry_19b33c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b33c) {
        switch (ctx->pc) {
            case 0x19b344: ctx->pc = 0; goto label_19b344;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b33c: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B360; return;
    }
label_19b344:
    // 0x19b344: 0x8c880214
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 4), 532)));
    // 0x19b348: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x19b34c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x19b350: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19b354: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x19b35c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_19b35c
// Address: 0x19b35c - 0x19b378

void entry_19b35c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b35c) {
        switch (ctx->pc) {
            case 0x19b360: ctx->pc = 0; goto label_19b360;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b35c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_19b360:
    // 0x19b360: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19b364: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19b368: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x19b36c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19b374: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19b378; return;
}


// Function: UpdateRat__FP3RATf
// Address: 0x19b378 - 0x19b3a4

void entry_19b3a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b3a4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19b3a8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x19b3ac: 0xc06e4fe
    SET_GPR_U32(ctx, 31, 0x19b3b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateSo__FP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_19b3b4
// Address: 0x19b3b4 - 0x19b454

void entry_19b3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b3b4) {
        switch (ctx->pc) {
            case 0x19b3e4: ctx->pc = 0; goto label_19b3e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b3b4: 0x1200000b
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_19b3e4;
    }
    // 0x19b3bc: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x19b3c0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19b3c4: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x19b3c8: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x19b3cc: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19b3d0: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19b3d4: 0xda020150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x19b3d8: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x19b3dc: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19b3e0: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
label_19b3e4:
    // 0x19b3e4: 0x2a420003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 3));
    // 0x19b3e8: 0x10400023
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B478; return;
    }
    // 0x19b3f0: 0x6400021
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 18) < 0) {
        ctx->pc = 0x19B478; return;
    }
    // 0x19b3f8: 0xc621055c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1372)); ctx->f[1] = *(float*)&val; }
    // 0x19b3fc: 0x24531858
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x19b400: 0xc6600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[0] = *(float*)&val; }
    // 0x19b404: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b408: 0x0
    // NOP
    // 0x19b40c: 0x4500001a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 59));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19B478; return;
    }
    // 0x19b414: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x19b418: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19b41c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x19b420: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19b424: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x19b428: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x19b42c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19b430: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x19b434: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x19b438: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x19b43c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19b440: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19b444: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x19b448: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19b44c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x19b454);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_19b454
// Address: 0x19b454 - 0x19b474

void entry_19b454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b454: 0xc6600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 4)); ctx->f[0] = *(float*)&val; }
    // 0x19b458: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x19b45c: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x19b460: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19b464: 0x3c014020
    SET_GPR_U32(ctx, 1, ((uint32_t)16416 << 16));
    // 0x19b468: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x19b46c: 0xc07aad2
    SET_GPR_U32(ctx, 31, 0x19b474);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    GRandGaussian__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_19b474
// Address: 0x19b474 - 0x19b554

void entry_19b474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b474) {
        switch (ctx->pc) {
            case 0x19b478: ctx->pc = 0; goto label_19b478;
            case 0x19b500: ctx->pc = 0; goto label_19b500;
            case 0x19b544: ctx->pc = 0; goto label_19b544;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b474: 0xe620055c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1372), *(uint32_t*)&val); }
label_19b478:
    // 0x19b478: 0x12000041
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B580; return;
    }
    // 0x19b480: 0x1040003f
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B580; return;
    }
    // 0x19b488: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x19b48c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b490: 0x3c0147af
    SET_GPR_U32(ctx, 1, ((uint32_t)18351 << 16));
    // 0x19b494: 0x3421c800
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 51200));
    // 0x19b498: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19b49c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b4a0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19b4a4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b4a8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19b4ac: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19b4b0: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x19b4b4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b4b8: 0x0
    // NOP
    // 0x19b4bc: 0x45000030
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19B580; return;
    }
    // 0x19b4c4: 0x8e270014
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x19b4c8: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x19b4cc: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x19b4d0: 0x24e21c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 7), 7264));
    // 0x19b4d4: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19b4d8: 0xafa20024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    // 0x19b4dc: 0xafa20020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    // 0x19b4e0: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x19b4e4: 0xafa5002c
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 5));
    // 0x19b4e8: 0xafa30028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 3));
    // 0x19b4ec: 0xac86b314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 6));
    // 0x19b4f0: 0x8ce21c60
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 7264)));
    // 0x19b4f4: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19b4f8: 0x1040001d
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B570; return;
    }
label_19b500:
    // 0x19b500: 0x12220014
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        entry_19b554(rdram, ctx, runtime); return;
    }
    // 0x19b508: 0xc6210624
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1572)); ctx->f[1] = *(float*)&val; }
    // 0x19b50c: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x19b510: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x19b514: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x19b518: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b51c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b520: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19b524: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b528: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19b52c: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19b530: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x19b534: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b538: 0x0
    // NOP
    // 0x19b53c: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_19b544;
    }
label_19b544:
    // 0x19b544: 0x10600003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_19b554(rdram, ctx, runtime); return;
    }
    // 0x19b54c: 0xc067070
    SET_GPR_U32(ctx, 31, 0x19b554);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetRatRats__FP3RAT4RATS(rdram, ctx, runtime); return;
}


// Function: entry_19b554
// Address: 0x19b554 - 0x19b650

void entry_19b554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b554) {
        switch (ctx->pc) {
            case 0x19b570: ctx->pc = 0; goto label_19b570;
            case 0x19b580: ctx->pc = 0; goto label_19b580;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b554: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x19b558: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x19b55c: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19b560: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x19b564: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19b568: 0x1440ffe5
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B500; return;
    }
label_19b570:
    // 0x19b570: 0x8fa2002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x19b574: 0x24120002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    // 0x19b578: 0x100000ff
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_19b978(rdram, ctx, runtime); return;
    }
label_19b580:
    // 0x19b580: 0x2e420005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 5));
    // 0x19b584: 0x104000fc
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_19b978(rdram, ctx, runtime); return;
    }
    // 0x19b58c: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x19b590: 0x2442c8d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294953168));
    // 0x19b594: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19b598: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x19b59c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x19b5a4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19b5a8: 0xc6210558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1368)); ctx->f[1] = *(float*)&val; }
    // 0x19b5ac: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x19b5b0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b5b4: 0x0
    // NOP
    // 0x19b5b8: 0x450000f0
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19B97C; return;
    }
    // 0x19b5c0: 0x100000ee
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B97C; return;
    }
    // 0x19b5c8: 0x8e220560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1376)));
    // 0x19b5cc: 0x14400021
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B654; return;
    }
    // 0x19b5d4: 0xc6200554
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1364)); ctx->f[0] = *(float*)&val; }
    // 0x19b5d8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19b5dc: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x19b5e0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19b5e4: 0xc442185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[2] = *(float*)&val; }
    // 0x19b5e8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x19b5ec: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b5f0: 0x45000018
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19B654; return;
    }
    // 0x19b5f8: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x19b5fc: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x19b600: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19b604: 0xc6210614
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1556)); ctx->f[1] = *(float*)&val; }
    // 0x19b608: 0xda210150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x19b60c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b610: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19b614: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b618: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19b61c: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x19b620: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b624: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19b628: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19b62c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19b630: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x19b634: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b638: 0x0
    // NOP
    // 0x19b63c: 0x45000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19B654; return;
    }
    // 0x19b644: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19b648: 0xc06eca4
    SET_GPR_U32(ctx, 31, 0x19b650);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime); return;
}


// Function: entry_19b650
// Address: 0x19b650 - 0x19b754

void entry_19b650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b650) {
        switch (ctx->pc) {
            case 0x19b654: ctx->pc = 0; goto label_19b654;
            case 0x19b670: ctx->pc = 0; goto label_19b670;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b650: 0x2182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_19b654:
    // 0x19b654: 0x10600006
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_19b670;
    }
    // 0x19b65c: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x19b660: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x19b664: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19b668: 0x10000040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1556)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B76C; return;
    }
label_19b670:
    // 0x19b670: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19b674: 0xc6210558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1368)); ctx->f[1] = *(float*)&val; }
    // 0x19b678: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x19b67c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b680: 0x0
    // NOP
    // 0x19b684: 0x450300bc
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        entry_19b978(rdram, ctx, runtime); return;
    }
    // 0x19b68c: 0xda210640
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1600)));
    // 0x19b690: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x19b694: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b698: 0x3c0143c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17352 << 16));
    // 0x19b69c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19b6a0: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b6a4: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b6a8: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19b6ac: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x19b6b0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b6b4: 0x0
    // NOP
    // 0x19b6b8: 0x450000b0
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19B97C; return;
    }
    // 0x19b6c0: 0x100000ae
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B97C; return;
    }
    // 0x19b6c8: 0x8e220560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1376)));
    // 0x19b6cc: 0x14400022
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B758; return;
    }
    // 0x19b6d4: 0xc6200554
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1364)); ctx->f[0] = *(float*)&val; }
    // 0x19b6d8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19b6dc: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x19b6e0: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x19b6e4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19b6e8: 0xc442185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[2] = *(float*)&val; }
    // 0x19b6ec: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x19b6f0: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b6f4: 0x45000018
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19B758; return;
    }
    // 0x19b6fc: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x19b700: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x19b704: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19b708: 0xc6210618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1560)); ctx->f[1] = *(float*)&val; }
    // 0x19b70c: 0xda210150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x19b710: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b714: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19b718: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b71c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19b720: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x19b724: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b728: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19b72c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19b730: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19b734: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x19b738: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b73c: 0x0
    // NOP
    // 0x19b740: 0x45000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19B758; return;
    }
    // 0x19b748: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19b74c: 0xc06eca4
    SET_GPR_U32(ctx, 31, 0x19b754);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    PxpFindSoGround__FP2SOT0Pi(rdram, ctx, runtime); return;
}


// Function: entry_19b754
// Address: 0x19b754 - 0x19b7b8

void entry_19b754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b754) {
        switch (ctx->pc) {
            case 0x19b758: ctx->pc = 0; goto label_19b758;
            case 0x19b76c: ctx->pc = 0; goto label_19b76c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b754: 0x2182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_19b758:
    // 0x19b758: 0x10600019
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B7C0; return;
    }
    // 0x19b760: 0xc6200618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1560)); ctx->f[0] = *(float*)&val; }
    // 0x19b764: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x19b768: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
label_19b76c:
    // 0x19b76c: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x19b770: 0xd8430000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19b774: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x19b778: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x19b77c: 0x8e240620
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1568)));
    // 0x19b780: 0xda210110
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x19b784: 0x48a42000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x19b788: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x19b78c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19b790: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x19b794: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19b798: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19b79c: 0x4be209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x19b7a0: 0x4be41848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19b7a4: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19b7a8: 0xfba40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19b7ac: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x19b7b0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19b7b8);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19b7b8
// Address: 0x19b7b8 - 0x19b7f0

void entry_19b7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b7b8) {
        switch (ctx->pc) {
            case 0x19b7c0: ctx->pc = 0; goto label_19b7c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b7b8: 0x10000070
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19B97C; return;
    }
label_19b7c0:
    // 0x19b7c0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19b7c4: 0xc6210558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1368)); ctx->f[1] = *(float*)&val; }
    // 0x19b7c8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x19b7cc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b7d0: 0x0
    // NOP
    // 0x19b7d4: 0x45030068
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
        entry_19b978(rdram, ctx, runtime); return;
    }
    // 0x19b7dc: 0x8e240660
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1632)));
    // 0x19b7e0: 0x50800066
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x19B97C; return;
    }
    // 0x19b7e8: 0xc05045c
    SET_GPR_U32(ctx, 31, 0x19b7f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    FCheckVolPoint__FP3VOLP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_19b7f0
// Address: 0x19b7f0 - 0x19b92c

void entry_19b7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b7f0) {
        switch (ctx->pc) {
            case 0x19b7fc: ctx->pc = 0; goto label_19b7fc;
            case 0x19b8c8: ctx->pc = 0; goto label_19b8c8;
            case 0x19b908: ctx->pc = 0; goto label_19b908;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b7f0: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x19b7f4: 0x10000060
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_19b978(rdram, ctx, runtime); return;
    }
label_19b7fc:
    // 0x19b7fc: 0x10000042
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19b908;
    }
    // 0x19b804: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19b808: 0xc6210558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1368)); ctx->f[1] = *(float*)&val; }
    // 0x19b80c: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19b810: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x19b814: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x19b818: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b81c: 0x0
    // NOP
    // 0x19b820: 0x4502004a
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x19B94C; return;
    }
    // 0x19b828: 0x52000048
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x19B94C; return;
    }
    // 0x19b830: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x19b834: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x19b838: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b83c: 0x3c0148af
    SET_GPR_U32(ctx, 1, ((uint32_t)18607 << 16));
    // 0x19b840: 0x3421c800
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 51200));
    // 0x19b844: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19b848: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b84c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19b850: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b854: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19b858: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19b85c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x19b860: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b864: 0x0
    // NOP
    // 0x19b868: 0x45000037
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19B948; return;
    }
    // 0x19b870: 0x8e260014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x19b874: 0x8c64b314
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 4294947604)));
    // 0x19b878: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x19b87c: 0x24c21c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 7264));
    // 0x19b880: 0x60982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x19b884: 0xafa20024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    // 0x19b888: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19b88c: 0xafa20020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 2));
    // 0x19b890: 0x8c470008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x19b894: 0xafa4002c
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 4));
    // 0x19b898: 0xac65b314
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294947604), GPR_U32(ctx, 5));
    // 0x19b89c: 0xafa70028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 7));
    // 0x19b8a0: 0x8cc31c60
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 7264)));
    // 0x19b8a4: 0x671021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x19b8a8: 0x10600017
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_19b908;
    }
    // 0x19b8b0: 0xda230140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x19b8b4: 0xe0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x19b8b8: 0x3c0147af
    SET_GPR_U32(ctx, 1, ((uint32_t)18351 << 16));
    // 0x19b8bc: 0x3421c800
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 51200));
    // 0x19b8c0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19b8c4: 0x0
    // NOP
label_19b8c8:
    // 0x19b8c8: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x19b8cc: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19b8d0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b8d4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19b8d8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b8dc: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19b8e0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19b8e4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x19b8e8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19b8ec: 0x0
    // NOP
    // 0x19b8f0: 0x4501ffc2
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_19b7fc;
    }
    // 0x19b8f8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19b8fc: 0x851821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x19b900: 0x1480fff1
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_19b8c8;
    }
label_19b908:
    // 0x19b908: 0x5100000c
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
        ctx->pc = 0x19B93C; return;
    }
    // 0x19b910: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x19b914: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x19b918: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19b91c: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x19b920: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x19b924: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x19b92c);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_19b92c
// Address: 0x19b92c - 0x19b964

void entry_19b92c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b92c) {
        switch (ctx->pc) {
            case 0x19b93c: ctx->pc = 0; goto label_19b93c;
            case 0x19b948: ctx->pc = 0; goto label_19b948;
            case 0x19b94c: ctx->pc = 0; goto label_19b94c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b92c: 0x26821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 6232));
    // 0x19b930: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x19b934: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x19b938: 0xe6210558
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1368), *(uint32_t*)&val); }
label_19b93c:
    // 0x19b93c: 0x8fa2002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x19b940: 0x1000000d
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_19b978(rdram, ctx, runtime); return;
    }
label_19b948:
    // 0x19b948: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_19b94c:
    // 0x19b94c: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x19b950: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x19b954: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19b958: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x19b95c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19b964);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19b964
// Address: 0x19b964 - 0x19b978

void entry_19b964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19b964: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x19b968: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19b96c: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x19b970: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19b978);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19b978
// Address: 0x19b978 - 0x19b984

void entry_19b978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b978) {
        switch (ctx->pc) {
            case 0x19b97c: ctx->pc = 0; goto label_19b97c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b978: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_19b97c:
    // 0x19b97c: 0xc067070
    SET_GPR_U32(ctx, 31, 0x19b984);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetRatRats__FP3RAT4RATS(rdram, ctx, runtime); return;
}


// Function: entry_19b984
// Address: 0x19b984 - 0x19b9e4

void entry_19b984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b984) {
        switch (ctx->pc) {
            case 0x19b9cc: ctx->pc = 0; goto label_19b9cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b984: 0x2e420005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 5));
    // 0x19b988: 0x10400058
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19BAEC; return;
    }
    // 0x19b990: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x19b994: 0x2442c8f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294953200));
    // 0x19b998: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19b99c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x19b9a0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x19b9a8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19b9ac: 0x56420007
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1632)));
        goto label_19b9cc;
    }
    // 0x19b9b4: 0xda210640
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1600)));
    // 0x19b9b8: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x19b9bc: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19b9c0: 0xc6340614
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1556)); ctx->f[20] = *(float*)&val; }
    // 0x19b9c4: 0x10000022
    WRITE128(ADD32(GPR_U32(ctx, 17), 1584), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19BA50; return;
    }
label_19b9cc:
    // 0x19b9cc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19b9d0: 0xc6340618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1560)); ctx->f[20] = *(float*)&val; }
    // 0x19b9d4: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x19b9d8: 0x8cc40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x19b9dc: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x19b9e4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_19b9e4
// Address: 0x19b9e4 - 0x19bae0

void entry_19b9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19b9e4) {
        switch (ctx->pc) {
            case 0x19ba4c: ctx->pc = 0; goto label_19ba4c;
            case 0x19ba50: ctx->pc = 0; goto label_19ba50;
            case 0x19bac0: ctx->pc = 0; goto label_19bac0;
            case 0x19bad0: ctx->pc = 0; goto label_19bad0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19b9e4: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x19b9e8: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19b9ec: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19b9f0: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x19b9f4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19b9f8: 0x4b82106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19b9fc: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19ba00: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19ba04: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19ba08: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19ba0c: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19ba10: 0x44842000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 4);
    // 0x19ba14: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19ba18: 0x0
    // NOP
    // 0x19ba1c: 0x4500000b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19ba4c;
    }
    // 0x19ba24: 0xc6230618
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1560)); ctx->f[3] = *(float*)&val; }
    // 0x19ba28: 0x2443abc0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294945728));
    // 0x19ba2c: 0xc442abc0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294945728)); ctx->f[2] = *(float*)&val; }
    // 0x19ba30: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x19ba34: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x19ba38: 0x46012042
    ctx->f[1] = FPU_MUL_S(ctx->f[4], ctx->f[1]);
    // 0x19ba3c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x19ba40: 0x46002002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x19ba44: 0x46001080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x19ba48: 0x46021d29
    ctx->f[20] = std::min(ctx->f[3], ctx->f[2]);
label_19ba4c:
    // 0x19ba4c: 0xfa220630
    WRITE128(ADD32(GPR_U32(ctx, 17), 1584), _mm_castps_si128(ctx->vu0_vf[2]));
label_19ba50:
    // 0x19ba50: 0xda220630
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1584)));
    // 0x19ba54: 0x4bc2106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19ba58: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19ba5c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19ba60: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19ba64: 0xda230110
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 272)));
    // 0x19ba68: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19ba6c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19ba70: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19ba74: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x19ba78: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x19ba7c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19ba80: 0x4be0105c
    ctx->vu0_vf[2] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x19ba84: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19ba88: 0x4bc118ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19ba8c: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19ba90: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19ba94: 0x4b0320ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19ba98: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19ba9c: 0x48221800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19baa0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19baa4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19baa8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x19baac: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19bab0: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19bac0;
    }
    // 0x19bab8: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19bad0;
    }
label_19bac0:
    // 0x19bac0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19bac4: 0x0
    // NOP
    // 0x19bac8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[1]);
        goto label_19bad0;
    }
label_19bad0:
    // 0x19bad0: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x19bad4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19bad8: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x19bae0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1564), *(uint32_t*)&val); }
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_19bae0
// Address: 0x19bae0 - 0x19bb10

void entry_19bae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19bae0) {
        switch (ctx->pc) {
            case 0x19baec: ctx->pc = 0; goto label_19baec;
            case 0x19baf0: ctx->pc = 0; goto label_19baf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19bae0: 0x10000003
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19baf0;
    }
    // 0x19bae8: 0xae20061c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1564), GPR_U32(ctx, 0));
label_19baec:
    // 0x19baec: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_19baf0:
    // 0x19baf0: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x19baf4: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19baf8: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19bafc: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19bb00: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19bb04: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x19bb08: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AdjustRatNewXp__FP3RATP2XPi
// Address: 0x19bb10 - 0x19bb90

void entry_19bc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19bc88) {
        switch (ctx->pc) {
            case 0x19bcb0: ctx->pc = 0; goto label_19bcb0;
            case 0x19bcc0: ctx->pc = 0; goto label_19bcc0;
            case 0x19bcd0: ctx->pc = 0; goto label_19bcd0;
            case 0x19bd10: ctx->pc = 0; goto label_19bd10;
            case 0x19bd2c: ctx->pc = 0; goto label_19bd2c;
            case 0x19bd3c: ctx->pc = 0; goto label_19bd3c;
            case 0x19bd50: ctx->pc = 0; goto label_19bd50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19bc88: 0x8e030550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x19bc8c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19bc90: 0x1062000f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_19bcd0;
    }
    // 0x19bc98: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_19bcb0;
    }
    // 0x19bca0: 0x10600007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_19bcc0;
    }
    // 0x19bca8: 0x10000054
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19BDFC; return;
    }
label_19bcb0:
    // 0x19bcb0: 0x1062002d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x19BD68; return;
    }
    // 0x19bcb8: 0x10000050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19BDFC; return;
    }
label_19bcc0:
    // 0x19bcc0: 0x8e0405ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1516)));
    // 0x19bcc4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19bcc8: 0x10000021
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19bd50;
    }
label_19bcd0:
    // 0x19bcd0: 0xc60105f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1520)); ctx->f[1] = *(float*)&val; }
    // 0x19bcd4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19bcd8: 0xda030140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x19bcdc: 0xda010650
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1616)));
    // 0x19bce0: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x19bce4: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19bce8: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19bcec: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19bcf0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19bcf4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19bcf8: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19bcfc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x19bd00: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19bd04: 0x0
    // NOP
    // 0x19bd08: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_19bd10;
    }
label_19bd10:
    // 0x19bd10: 0x1040000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19bd3c;
    }
    // 0x19bd18: 0x8e030564
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1380)));
    // 0x19bd1c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x19bd20: 0x43001a
    { int32_t divisor = GPR_S32(ctx, 3); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 3) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,3); } }
    // 0x19bd24: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_19bd2c;
    }
label_19bd2c:
    // 0x19bd2c: 0xfa030650
    WRITE128(ADD32(GPR_U32(ctx, 16), 1616), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19bd30: 0x2010
    SET_GPR_U32(ctx, 4, ctx->hi);
    // 0x19bd34: 0xae040560
    WRITE32(ADD32(GPR_U32(ctx, 16), 1376), GPR_U32(ctx, 4));
    // 0x19bd38: 0x8e020560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
label_19bd3c:
    // 0x19bd3c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19bd40: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19bd44: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x19bd48: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x19bd4c: 0x8c440568
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1384)));
label_19bd50:
    // 0x19bd50: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19bd54: 0x8c6200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 160)));
    // 0x19bd58: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19bd60);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19bd60
// Address: 0x19bd60 - 0x19bdf4

void entry_19bd60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19bd60) {
        switch (ctx->pc) {
            case 0x19bd68: ctx->pc = 0; goto label_19bd68;
            case 0x19bda8: ctx->pc = 0; goto label_19bda8;
            case 0x19bdc4: ctx->pc = 0; goto label_19bdc4;
            case 0x19bdd4: ctx->pc = 0; goto label_19bdd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19bd60: 0x10000025
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19BDF8; return;
    }
label_19bd68:
    // 0x19bd68: 0xc60105f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1524)); ctx->f[1] = *(float*)&val; }
    // 0x19bd6c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19bd70: 0xda030140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x19bd74: 0xda010650
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 1616)));
    // 0x19bd78: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x19bd7c: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19bd80: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19bd84: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19bd88: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19bd8c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19bd90: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19bd94: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x19bd98: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19bd9c: 0x0
    // NOP
    // 0x19bda0: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_19bda8;
    }
label_19bda8:
    // 0x19bda8: 0x1040000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19bdd4;
    }
    // 0x19bdb0: 0x8e0305a8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1448)));
    // 0x19bdb4: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x19bdb8: 0x43001a
    { int32_t divisor = GPR_S32(ctx, 3); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 3) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,3); } }
    // 0x19bdbc: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_19bdc4;
    }
label_19bdc4:
    // 0x19bdc4: 0xfa030650
    WRITE128(ADD32(GPR_U32(ctx, 16), 1616), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19bdc8: 0x2010
    SET_GPR_U32(ctx, 4, ctx->hi);
    // 0x19bdcc: 0xae040560
    WRITE32(ADD32(GPR_U32(ctx, 16), 1376), GPR_U32(ctx, 4));
    // 0x19bdd0: 0x8e020560
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
label_19bdd4:
    // 0x19bdd4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19bdd8: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x19bddc: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x19bde0: 0x8c4405ac
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1452)));
    // 0x19bde4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19bde8: 0x8c6200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 160)));
    // 0x19bdec: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19bdf4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19bdf4
// Address: 0x19bdf4 - 0x19be08

void entry_19bdf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19bdf4) {
        switch (ctx->pc) {
            case 0x19bdf8: ctx->pc = 0; goto label_19bdf8;
            case 0x19bdfc: ctx->pc = 0; goto label_19bdfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19bdf4: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_19bdf8:
    // 0x19bdf8: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_19bdfc:
    // 0x19bdfc: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19be00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FAbsorbRatWkr__FP3RATP3WKR
// Address: 0x19be08 - 0x19be34

void entry_19be34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19be34: 0x8e0705f8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 1528)));
    // 0x19be38: 0x10e0000b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_19be68(rdram, ctx, runtime); return;
    }
    // 0x19be40: 0x7a220020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x19be44: 0x7a260030
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 17), 48)));
    // 0x19be48: 0xe0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x19be4c: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x19be50: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x19be54: 0x7fa60010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 6));
    // 0x19be58: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x19be5c: 0x8c43007c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 124)));
    // 0x19be60: 0x60f809
    SET_GPR_U32(ctx, 31, 0x19be68);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_19be68
// Address: 0x19be68 - 0x19be80

void entry_19be68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19be68: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19be6c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19be70: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19be74: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19be78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ChooseRatFleeTarget__FP3RAT
// Address: 0x19be80 - 0x19beb4

void entry_19beb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19beb4) {
        switch (ctx->pc) {
            case 0x19bf08: ctx->pc = 0; goto label_19bf08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19beb4: 0x10400060
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C038; return;
    }
    // 0x19bebc: 0x8e260014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x19bec0: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x19bec4: 0x80a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19bec8: 0x24c21c6c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 7276));
    // 0x19becc: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19bed0: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x19bed4: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x19bed8: 0x4480b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 0);
    // 0x19bedc: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x19bee0: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x19bee4: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x19bee8: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x19beec: 0x8cc21c6c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 7276)));
    // 0x19bef0: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19bef4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19bef8: 0x1200004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C02C; return;
    }
    // 0x19bf00: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    // 0x19bf04: 0x26340140
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 320));
label_19bf08:
    // 0x19bf08: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x19bf0c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19bf10: 0x26060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 64));
    // 0x19bf14: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x19bf1c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_19bf1c
// Address: 0x19bf1c - 0x19bf6c

void entry_19bf1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19bf1c) {
        switch (ctx->pc) {
            case 0x19bf5c: ctx->pc = 0; goto label_19bf5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19bf1c: 0xc6210624
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1572)); ctx->f[1] = *(float*)&val; }
    // 0x19bf20: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19bf24: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19bf28: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x19bf2c: 0x46010842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[1]);
    // 0x19bf30: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19bf34: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19bf38: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19bf3c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19bf40: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19bf44: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19bf48: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x19bf4c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19bf50: 0x0
    // NOP
    // 0x19bf54: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_19bf5c;
    }
label_19bf5c:
    // 0x19bf5c: 0x1440002d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C014; return;
    }
    // 0x19bf64: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x19bf6c);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19bf6c
// Address: 0x19bf6c - 0x19bf84

void entry_19bf6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19bf6c: 0x24440140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 320));
    // 0x19bf70: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19bf74: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19bf78: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x19bf7c: 0xc0618c8
    SET_GPR_U32(ctx, 31, 0x19bf84);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 36));
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime); return;
}


// Function: entry_19bf84
// Address: 0x19bf84 - 0x19c068

void entry_19bf84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19bf84) {
        switch (ctx->pc) {
            case 0x19c004: ctx->pc = 0; goto label_19c004;
            case 0x19c014: ctx->pc = 0; goto label_19c014;
            case 0x19c018: ctx->pc = 0; goto label_19c018;
            case 0x19c02c: ctx->pc = 0; goto label_19c02c;
            case 0x19c038: ctx->pc = 0; goto label_19c038;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19bf84: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19bf88: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x19bf8c: 0xc7a30024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[3] = *(float*)&val; }
    // 0x19bf90: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19bf94: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19bf98: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19bf9c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19bfa0: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19bfa4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19bfa8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19bfac: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19bfb0: 0x4603b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19bfb4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19bfb8: 0x44821000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 2);
    // 0x19bfbc: 0x45030011
    if ((ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[21] = *(float*)&val; }
        goto label_19c004;
    }
    // 0x19bfc4: 0xc7a00020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[0] = *(float*)&val; }
    // 0x19bfc8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x19bfcc: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x19bfd0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19bfd4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19bfd8: 0x0
    // NOP
    // 0x19bfdc: 0x4500000d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19c014;
    }
    // 0x19bfe4: 0x4601a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19bfe8: 0x0
    // NOP
    // 0x19bfec: 0x4500000a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19c018;
    }
    // 0x19bff4: 0x46141034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19bff8: 0x45000007
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19c018;
    }
    // 0x19c000: 0xc7b50020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[21] = *(float*)&val; }
label_19c004:
    // 0x19c004: 0x46001d86
    ctx->f[22] = FPU_MOV_S(ctx->f[3]);
    // 0x19c008: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19c00c: 0x46001506
    ctx->f[20] = FPU_MOV_S(ctx->f[2]);
    // 0x19c010: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_19c014:
    // 0x19c014: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
label_19c018:
    // 0x19c018: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19c01c: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x19c020: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19c024: 0x1600ffb8
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19BF08; return;
    }
label_19c02c:
    // 0x19c02c: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x19c030: 0xae330660
    WRITE32(ADD32(GPR_U32(ctx, 17), 1632), GPR_U32(ctx, 19));
    // 0x19c034: 0xaea2b314
    WRITE32(ADD32(GPR_U32(ctx, 21), 4294947604), GPR_U32(ctx, 2));
label_19c038:
    // 0x19c038: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x19c03c: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19c040: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19c044: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19c048: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19c04c: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19c050: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19c054: 0xc7b600b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[22] = *(float*)&val; }
    // 0x19c058: 0xc7b500a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 168)); ctx->f[21] = *(float*)&val; }
    // 0x19c05c: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x19c060: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: HideRat__FP3RATi
// Address: 0x19c068 - 0x19c098

void entry_19c098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c098: 0x8e2405fc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1532)));
    // 0x19c09c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19c0a0: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x19c0a4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19c0ac);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19c0ac
// Address: 0x19c0ac - 0x19c0c4

void entry_19c0ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c0ac) {
        switch (ctx->pc) {
            case 0x19c0b4: ctx->pc = 0; goto label_19c0b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c0ac: 0x10000016
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C108; return;
    }
label_19c0b4:
    // 0x19c0b4: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x19c0b8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19c0bc: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x19c0c4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7264));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_19c0c4
// Address: 0x19c0c4 - 0x19c0d8

void entry_19c0c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c0c4: 0x8e2405fc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1532)));
    // 0x19c0c8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19c0cc: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x19c0d0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19c0d8);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19c0d8
// Address: 0x19c0d8 - 0x19c0f0

void entry_19c0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c0d8: 0x8e260660
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1632)));
    // 0x19c0dc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c0e0: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19c0e4: 0x8cc40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x19c0e8: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x19c0f0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_19c0f0
// Address: 0x19c0f0 - 0x19c104

void entry_19c0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c0f0: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x19c0f4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19c0f8: 0x24c68d20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937888));
    // 0x19c0fc: 0xc06e618
    SET_GPR_U32(ctx, 31, 0x19c104);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    TranslateSoToPosSafe__FP2SOP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_19c104
// Address: 0x19c104 - 0x19c114

void entry_19c104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c104) {
        switch (ctx->pc) {
            case 0x19c108: ctx->pc = 0; goto label_19c108;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c104: 0x2e050001
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 16), 1));
label_19c108:
    // 0x19c108: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19c10c: 0xc06df10
    SET_GPR_U32(ctx, 31, 0x19c114);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    EnableSoPhys__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_19c114
// Address: 0x19c114 - 0x19c158

void entry_19c114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c114) {
        switch (ctx->pc) {
            case 0x19c150: ctx->pc = 0; goto label_19c150;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c114: 0x262302d8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 728));
    // 0x19c118: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x19c11c: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x19c120: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19c124: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x19c128: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x19c12c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x19c130: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x19c134: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x19c138: 0x8e2302d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 728)));
    // 0x19c13c: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x19c140: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19c144: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x19c148: 0x10800009
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C170; return;
    }
label_19c150:
    // 0x19c150: 0xc06df10
    SET_GPR_U32(ctx, 31, 0x19c158);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EnableSoPhys__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_19c158
// Address: 0x19c158 - 0x19c18c

void entry_19c158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c158) {
        switch (ctx->pc) {
            case 0x19c170: ctx->pc = 0; goto label_19c170;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c158: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x19c15c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x19c160: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19c164: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x19c168: 0x1480fff9
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C150; return;
    }
label_19c170:
    // 0x19c170: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x19c174: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x19c178: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x19c17c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19c180: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x19c184: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19c18c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19c18c
// Address: 0x19c18c - 0x19c1a0

void entry_19c18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c18c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x19c190: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19c194: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x19c198: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19c1a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19c1a0
// Address: 0x19c1a0 - 0x19c1c0

void entry_19c1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c1a0: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x19c1a4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19c1a8: 0xae43b314
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294947604), GPR_U32(ctx, 3));
    // 0x19c1ac: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19c1b0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19c1b4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19c1b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetRatRats__FP3RAT4RATS
// Address: 0x19c1c0 - 0x19c204

void entry_19c204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c204) {
        switch (ctx->pc) {
            case 0x19c20c: ctx->pc = 0; goto label_19c20c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c204: 0xae200660
    WRITE32(ADD32(GPR_U32(ctx, 17), 1632), GPR_U32(ctx, 0));
    // 0x19c208: 0x8e2405fc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1532)));
label_19c20c:
    // 0x19c20c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19c210: 0x2403000e
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 14));
    // 0x19c214: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19c218: 0xac830088
    WRITE32(ADD32(GPR_U32(ctx, 4), 136), GPR_U32(ctx, 3));
    // 0x19c21c: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x19c220: 0x2e450005
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 18), 5));
    // 0x19c224: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x19c228: 0x10a0005c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1368), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C39C; return;
    }
    // 0x19c230: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x19c234: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x19c238: 0x2442c910
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294953232));
    // 0x19c23c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19c240: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x19c244: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x19c24c: 0xc62c0608
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1544)); ctx->f[12] = *(float*)&val; }
    // 0x19c250: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x19c258);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1548)); ctx->f[13] = *(float*)&val; }
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_19c258
// Address: 0x19c258 - 0x19c288

void entry_19c258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c258: 0xc6210558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1368)); ctx->f[1] = *(float*)&val; }
    // 0x19c25c: 0x7a220140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x19c260: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x19c264: 0xae200560
    WRITE32(ADD32(GPR_U32(ctx, 17), 1376), GPR_U32(ctx, 0));
    // 0x19c268: 0x1000004b
    WRITE128(ADD32(GPR_U32(ctx, 17), 1616), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C398; return;
    }
    // 0x19c270: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x19c274: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x19c278: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x19c27c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x19c280: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x19c288);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_19c288
// Address: 0x19c288 - 0x19c298

void entry_19c288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c288: 0xc62d0610
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1552)); ctx->f[13] = *(float*)&val; }
    // 0x19c28c: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x19c290: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x19c298);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_19c298
// Address: 0x19c298 - 0x19c2ac

void entry_19c298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c298: 0x46000346
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    // 0x19c29c: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x19c2a0: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x19c2a4: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x19c2ac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_19c2ac
// Address: 0x19c2ac - 0x19c2dc

void entry_19c2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c2ac: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19c2b0: 0xda220190
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 400)));
    // 0x19c2b4: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19c2b8: 0xae200560
    WRITE32(ADD32(GPR_U32(ctx, 17), 1376), GPR_U32(ctx, 0));
    // 0x19c2bc: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x19c2c0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19c2c4: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x19c2c8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x19c2cc: 0x1000002e
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C388; return;
    }
    // 0x19c2d4: 0xc066fa0
    SET_GPR_U32(ctx, 31, 0x19c2dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ChooseRatFleeTarget__FP3RAT(rdram, ctx, runtime); return;
}


// Function: entry_19c2dc
// Address: 0x19c2dc - 0x19c33c

void entry_19c2dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c2dc: 0xc6200558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1368)); ctx->f[0] = *(float*)&val; }
    // 0x19c2e0: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x19c2e4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19c2e8: 0xae200560
    WRITE32(ADD32(GPR_U32(ctx, 17), 1376), GPR_U32(ctx, 0));
    // 0x19c2ec: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x19c2f0: 0x1000002a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1368), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C39C; return;
    }
    // 0x19c2f8: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x19c2fc: 0x26300140
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 320));
    // 0x19c300: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x19c304: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x19c308: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19c30c: 0x2404003a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 58));
    // 0x19c310: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x19c314: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x19c318: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x19c31c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19c320: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x19c324: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c328: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c32c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19c330: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c334: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x19c33c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_19c33c
// Address: 0x19c33c - 0x19c354

void entry_19c33c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c33c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x19c340: 0x8e260664
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1636)));
    // 0x19c344: 0x8e270668
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 1640)));
    // 0x19c348: 0x24841ef0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    // 0x19c34c: 0xc054804
    SET_GPR_U32(ctx, 31, 0x19c354);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OnDifficultyBreak(rdram, ctx, runtime); return;
}


// Function: entry_19c354
// Address: 0x19c354 - 0x19c364

void entry_19c354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c354: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x19c358: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x19c35c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19c364);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19c364
// Address: 0x19c364 - 0x19c378

void entry_19c364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c364: 0x1000000e
    WRITE32(ADD32(GPR_U32(ctx, 17), 1360), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C3A0; return;
    }
    // 0x19c36c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19c370: 0xc06701a
    SET_GPR_U32(ctx, 31, 0x19c378);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    HideRat__FP3RATi(rdram, ctx, runtime); return;
}


// Function: entry_19c378
// Address: 0x19c378 - 0x19c390

void entry_19c378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c378) {
        switch (ctx->pc) {
            case 0x19c388: ctx->pc = 0; goto label_19c388;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c378: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x19c37c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19c380: 0x3c014170
    SET_GPR_U32(ctx, 1, ((uint32_t)16752 << 16));
    // 0x19c384: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
label_19c388:
    // 0x19c388: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x19c390);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_19c390
// Address: 0x19c390 - 0x19c3d0

void entry_19c390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c390) {
        switch (ctx->pc) {
            case 0x19c398: ctx->pc = 0; goto label_19c398;
            case 0x19c39c: ctx->pc = 0; goto label_19c39c;
            case 0x19c3a0: ctx->pc = 0; goto label_19c3a0;
            case 0x19c3ac: ctx->pc = 0; goto label_19c3ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c390: 0xc6210558
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1368)); ctx->f[1] = *(float*)&val; }
    // 0x19c394: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
label_19c398:
    // 0x19c398: 0xe6210558
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 1368), *(uint32_t*)&val); }
label_19c39c:
    // 0x19c39c: 0xae320550
    WRITE32(ADD32(GPR_U32(ctx, 17), 1360), GPR_U32(ctx, 18));
label_19c3a0:
    // 0x19c3a0: 0x26621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 6232));
    // 0x19c3a4: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x19c3a8: 0xe6200554
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1364), *(uint32_t*)&val); }
label_19c3ac:
    // 0x19c3ac: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19c3b0: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19c3b4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19c3b8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19c3bc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19c3c0: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x19c3c4: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x19c3c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnRatholeAdd__FP7RATHOLE
// Address: 0x19c3d0 - 0x19c3e4

void entry_19c3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c3e4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19c3e8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19c3ec: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x19c3f4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7276));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_19c3f4
// Address: 0x19c3f4 - 0x19c408

void entry_19c3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c3f4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19c3f8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19c3fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19c404: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19c408; return;
}


// Function: OnRatholeRemove__FP7RATHOLE
// Address: 0x19c408 - 0x19c41c

void entry_19c41c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c41c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19c420: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19c424: 0xc054980
    SET_GPR_U32(ctx, 31, 0x19c42c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7276));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_19c42c
// Address: 0x19c42c - 0x19c440

void entry_19c42c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c42c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19c430: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19c434: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19c43c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19c440; return;
}


// Function: InitRchm__FP4RCHM
// Address: 0x19c440 - 0x19c454

void entry_19c454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c454: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19c458: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19c45c: 0xae020034
    WRITE32(ADD32(GPR_U32(ctx, 16), 52), GPR_U32(ctx, 2));
    // 0x19c460: 0xae020038
    WRITE32(ADD32(GPR_U32(ctx, 16), 56), GPR_U32(ctx, 2));
    // 0x19c464: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19c468: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadRchmFromBrx__FP4RCHMP18CBinaryInputStream
// Address: 0x19c470 - 0x19c4bc

void entry_19c4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c4bc: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x19c4c0: 0x621fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x19C4B0; return;
    }
    // 0x19c4c8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19c4cc: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x19c4d4);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19c4d4
// Address: 0x19c4d4 - 0x19c4e4

void entry_19c4d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c4d4: 0xae420048
    WRITE32(ADD32(GPR_U32(ctx, 18), 72), GPR_U32(ctx, 2));
    // 0x19c4d8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19c4dc: 0xc04dfec
    SET_GPR_U32(ctx, 31, 0x19c4e4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 160));
    ReadGeom__18CBinaryInputStreamP4GEOM(rdram, ctx, runtime); return;
}


// Function: entry_19c4e4
// Address: 0x19c4e4 - 0x19c4f4

void entry_19c4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c4e4: 0x8e4200a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 164)));
    // 0x19c4e8: 0x24040064
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 100));
    // 0x19c4ec: 0xc063570
    SET_GPR_U32(ctx, 31, 0x19c4f4);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_19c4f4
// Address: 0x19c4f4 - 0x19c514

void entry_19c4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c4f4) {
        switch (ctx->pc) {
            case 0x19c508: ctx->pc = 0; goto label_19c508;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c4f4: 0x8e4300a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 164)));
    // 0x19c4f8: 0x1860001b
    WRITE32(ADD32(GPR_U32(ctx, 18), 196), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x19C568; return;
    }
    // 0x19c500: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c504: 0x8e5000c4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 196)));
label_19c508:
    // 0x19c508: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19c50c: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x19c514);
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 19)));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19c514
// Address: 0x19c514 - 0x19c538

void entry_19c514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c514: 0x8e4300c4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 196)));
    // 0x19c518: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19c51c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19c520: 0x27a70004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 4));
    // 0x19c524: 0x2631821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 3)));
    // 0x19c528: 0x27a80008
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 8));
    // 0x19c52c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x19c530: 0xc067364
    SET_GPR_U32(ctx, 31, 0x19c538);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertRchmIposToRclIoLhub__FP4RCHMiPfN22(rdram, ctx, runtime); return;
}


// Function: entry_19c538
// Address: 0x19c538 - 0x19c558

void entry_19c538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c538: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x19c53c: 0xc7ad0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[13] = *(float*)&val; }
    // 0x19c540: 0x26050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 4));
    // 0x19c544: 0xc7ae0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[14] = *(float*)&val; }
    // 0x19c548: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19c54c: 0xc7ac0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[12] = *(float*)&val; }
    // 0x19c550: 0xc067304
    SET_GPR_U32(ctx, 31, 0x19c558);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 100));
    BuildRchmCoefficients__FP4RCHMfffPf(rdram, ctx, runtime); return;
}


// Function: entry_19c558
// Address: 0x19c558 - 0x19c570

void entry_19c558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c558) {
        switch (ctx->pc) {
            case 0x19c568: ctx->pc = 0; goto label_19c568;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c558: 0x8e4200a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 164)));
    // 0x19c55c: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x19c560: 0x5440ffe9
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 196)));
        ctx->pc = 0x19C508; return;
    }
label_19c568:
    // 0x19c568: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x19c570);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19c570
// Address: 0x19c570 - 0x19c57c

void entry_19c570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c570: 0x22100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 4));
    // 0x19c574: 0xc063570
    SET_GPR_U32(ctx, 31, 0x19c57c);
    WRITE32(ADD32(GPR_U32(ctx, 18), 200), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_19c57c
// Address: 0x19c57c - 0x19c5ac

void entry_19c57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c57c) {
        switch (ctx->pc) {
            case 0x19c590: ctx->pc = 0; goto label_19c590;
            case 0x19c5a0: ctx->pc = 0; goto label_19c5a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c57c: 0x8e4300c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 200)));
    // 0x19c580: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c584: 0x18600011
    WRITE32(ADD32(GPR_U32(ctx, 18), 204), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x19C5CC; return;
    }
    // 0x19c58c: 0x8e4300cc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 204)));
label_19c590:
    // 0x19c590: 0x41100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    // 0x19c594: 0x24930001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 4), 1));
    // 0x19c598: 0x24110003
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 3));
    // 0x19c59c: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
label_19c5a0:
    // 0x19c5a0: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19c5a4: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x19c5ac);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19c5ac
// Address: 0x19c5ac - 0x19c5d8

void entry_19c5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c5ac) {
        switch (ctx->pc) {
            case 0x19c5cc: ctx->pc = 0; goto label_19c5cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c5ac: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x19c5b0: 0x621fffb
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->pc = 0x19C5A0; return;
    }
    // 0x19c5b8: 0x8e4200c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 200)));
    // 0x19c5bc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19c5c0: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x19c5c4: 0x5440fff2
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 204)));
        ctx->pc = 0x19C590; return;
    }
label_19c5cc:
    // 0x19c5cc: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19c5d0: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x19c5d8);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19c5d8
// Address: 0x19c5d8 - 0x19c5ec

void entry_19c5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c5d8: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x19c5dc: 0xae4200d4
    WRITE32(ADD32(GPR_U32(ctx, 18), 212), GPR_U32(ctx, 2));
    // 0x19c5e0: 0x442018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x19c5e4: 0xc063570
    SET_GPR_U32(ctx, 31, 0x19c5ec);
    WRITE32(ADD32(GPR_U32(ctx, 18), 208), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_19c5ec
// Address: 0x19c5ec - 0x19c5fc

void entry_19c5ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c5ec: 0x8e4400d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 208)));
    // 0x19c5f0: 0xae4200d8
    WRITE32(ADD32(GPR_U32(ctx, 18), 216), GPR_U32(ctx, 2));
    // 0x19c5f4: 0xc063570
    SET_GPR_U32(ctx, 31, 0x19c5fc);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 3));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_19c5fc
// Address: 0x19c5fc - 0x19c62c

void entry_19c5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c5fc) {
        switch (ctx->pc) {
            case 0x19c610: ctx->pc = 0; goto label_19c610;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c5fc: 0x8e4300d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 208)));
    // 0x19c600: 0x18600036
    WRITE32(ADD32(GPR_U32(ctx, 18), 220), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x19C6DC; return;
    }
    // 0x19c608: 0x241e000c
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 12));
    // 0x19c60c: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_19c610:
    // 0x19c610: 0x8e4300d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 216)));
    // 0x19c614: 0x1528c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 21), 3));
    // 0x19c618: 0x8e4200dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 220)));
    // 0x19c61c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19c620: 0x779821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 23)));
    // 0x19c624: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x19c62c);
    SET_GPR_U32(ctx, 22, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19c62c
// Address: 0x19c62c - 0x19c638

void entry_19c62c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c62c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19c630: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x19c638);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19c638
// Address: 0x19c638 - 0x19c644

void entry_19c638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c638: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19c63c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x19c644);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19c644
// Address: 0x19c644 - 0x19c6e4

void entry_19c644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c644) {
        switch (ctx->pc) {
            case 0x19c674: ctx->pc = 0; goto label_19c674;
            case 0x19c68c: ctx->pc = 0; goto label_19c68c;
            case 0x19c6ac: ctx->pc = 0; goto label_19c6ac;
            case 0x19c6c8: ctx->pc = 0; goto label_19c6c8;
            case 0x19c6cc: ctx->pc = 0; goto label_19c6cc;
            case 0x19c6dc: ctx->pc = 0; goto label_19c6dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c644: 0x8e4300b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 176)));
    // 0x19c648: 0x108140
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 5));
    // 0x19c64c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19c650: 0x701821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x19c654: 0x1a200007
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 17) <= 0) {
        goto label_19c674;
    }
    // 0x19c65c: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x19c660: 0x8e4200d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 216)));
    // 0x19c664: 0x23e1818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 30); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x19c668: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19c66c: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 19), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19c68c;
    }
label_19c674:
    // 0x19c674: 0x6210005
    SET_GPR_U32(ctx, 17, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 17)));
    if (GPR_S32(ctx, 17) >= 0) {
        goto label_19c68c;
    }
    // 0x19c67c: 0x8e4300cc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 204)));
    // 0x19c680: 0x111100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 4));
    // 0x19c684: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19c688: 0xaec30000
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 3));
label_19c68c:
    // 0x19c68c: 0x18800007
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_19c6ac;
    }
    // 0x19c694: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x19c698: 0x8e4200d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 216)));
    // 0x19c69c: 0x9e1818
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 30); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x19c6a0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19c6a4: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 19), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19c6c8;
    }
label_19c6ac:
    // 0x19c6ac: 0x4830007
    if (GPR_S32(ctx, 4) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 208)));
        goto label_19c6cc;
    }
    // 0x19c6b4: 0x8e4300cc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 204)));
    // 0x19c6b8: 0x42027
    SET_GPR_U32(ctx, 4, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 4)));
    // 0x19c6bc: 0x41100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    // 0x19c6c0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19c6c4: 0xaec30004
    WRITE32(ADD32(GPR_U32(ctx, 22), 4), GPR_U32(ctx, 3));
label_19c6c8:
    // 0x19c6c8: 0x8e4200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 208)));
label_19c6cc:
    // 0x19c6cc: 0x26b50001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    // 0x19c6d0: 0x2a2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 2)));
    // 0x19c6d4: 0x1440ffce
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 12));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C610; return;
    }
label_19c6dc:
    // 0x19c6dc: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x19c6e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19c6e4
// Address: 0x19c6e4 - 0x19c6f4

void entry_19c6e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c6e4: 0xe64000e0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 224), *(uint32_t*)&val); }
    // 0x19c6e8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19c6ec: 0xc047b10
    SET_GPR_U32(ctx, 31, 0x19c6f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    LoadOptionsFromBrx__FPvP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_19c6f4
// Address: 0x19c6f4 - 0x19c728

void entry_19c6f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c6f4: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x19c6f8: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x19c6fc: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19c700: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19c704: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19c708: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19c70c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19c710: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19c714: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19c718: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19c71c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19c724: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19c728; return;
}


// Function: PostRchmLoad__FP4RCHM
// Address: 0x19c728 - 0x19c750

void entry_19c750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c750: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x19c754: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19c758: 0xc056912
    SET_GPR_U32(ctx, 31, 0x19c760);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19c760
// Address: 0x19c760 - 0x19c778

void entry_19c760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c760: 0x10400090
    WRITE32(ADD32(GPR_U32(ctx, 17), 60), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C9A4; return;
    }
    // 0x19c768: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x19c76c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19c770: 0xc056920
    SET_GPR_U32(ctx, 31, 0x19c778);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 56)));
    PloFindSwChild__FP2SW3OIDP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_19c778
// Address: 0x19c778 - 0x19c7a8

void entry_19c778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c778) {
        switch (ctx->pc) {
            case 0x19c798: ctx->pc = 0; goto label_19c798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c778: 0x1040008a
    WRITE32(ADD32(GPR_U32(ctx, 17), 64), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C9A4; return;
    }
    // 0x19c780: 0x263300e4
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 228));
    // 0x19c784: 0x263403e4
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 17), 996));
    // 0x19c788: 0x26350070
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 17), 112));
    // 0x19c78c: 0x260802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19c790: 0x24120017
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 23));
    // 0x19c794: 0x0
    // NOP
label_19c798:
    // 0x19c798: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x19c79c: 0x8e05000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x19c7a0: 0xc056920
    SET_GPR_U32(ctx, 31, 0x19c7a8);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    PloFindSwChild__FP2SW3OIDP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_19c7a8
// Address: 0x19c7a8 - 0x19c7c4

void entry_19c7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c7a8: 0x10400006
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_19c7c4(rdram, ctx, runtime); return;
    }
    // 0x19c7b0: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19c7b4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19c7b8: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x19c7bc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19c7c4);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19c7c4
// Address: 0x19c7c4 - 0x19c7f0

void entry_19c7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c7c4: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x19c7c8: 0x641fff3
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    if (GPR_S32(ctx, 18) >= 0) {
        ctx->pc = 0x19C798; return;
    }
    // 0x19c7d0: 0x3c090027
    SET_GPR_U32(ctx, 9, ((uint32_t)39 << 16));
    // 0x19c7d4: 0x24040020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 32));
    // 0x19c7d8: 0x2529abd0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294945744));
    // 0x19c7dc: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x19c7e0: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19c7e4: 0x24070010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 16));
    // 0x19c7e8: 0xc04e580
    SET_GPR_U32(ctx, 31, 0x19c7f0);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    FillBlAmrsg__FiiPviiP3OID(rdram, ctx, runtime); return;
}


// Function: entry_19c7f0
// Address: 0x19c7f0 - 0x19c81c

void entry_19c7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c7f0: 0x8e24003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    // 0x19c7f4: 0x3c090027
    SET_GPR_U32(ctx, 9, ((uint32_t)39 << 16));
    // 0x19c7f8: 0x3c0a0027
    SET_GPR_U32(ctx, 10, ((uint32_t)39 << 16));
    // 0x19c7fc: 0x2529abe0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294945760));
    // 0x19c800: 0x254aabd8
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4294945752));
    // 0x19c804: 0x280582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19c808: 0x24050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    // 0x19c80c: 0x24060018
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    // 0x19c810: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19c814: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x19c81c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_19c81c
// Address: 0x19c81c - 0x19c844

void entry_19c81c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c81c) {
        switch (ctx->pc) {
            case 0x19c838: ctx->pc = 0; goto label_19c838;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c81c: 0x8e2303e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 996)));
    // 0x19c820: 0x8c620078
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 120)));
    // 0x19c824: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_19c838;
    }
    // 0x19c82c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19c830: 0xac620078
    WRITE32(ADD32(GPR_U32(ctx, 3), 120), GPR_U32(ctx, 2));
    // 0x19c834: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_19c838:
    // 0x19c838: 0x24050036
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 54));
    // 0x19c83c: 0xc056920
    SET_GPR_U32(ctx, 31, 0x19c844);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    PloFindSwChild__FP2SW3OIDP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_19c844
// Address: 0x19c844 - 0x19c858

void entry_19c844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c844: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 84)); ctx->f[12] = *(float*)&val; }
        ctx->pc = 0x19C85C; return;
    }
    // 0x19c84c: 0x8e2403e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 996)));
    // 0x19c850: 0xc04e6ce
    SET_GPR_U32(ctx, 31, 0x19c858);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    SetAsegblSlerp__FP6ASEGBLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_19c858
// Address: 0x19c858 - 0x19c874

void entry_19c858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c858) {
        switch (ctx->pc) {
            case 0x19c85c: ctx->pc = 0; goto label_19c85c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c858: 0xc62c0054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 84)); ctx->f[12] = *(float*)&val; }
label_19c85c:
    // 0x19c85c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19c860: 0xc62d0058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 88)); ctx->f[13] = *(float*)&val; }
    // 0x19c864: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19c868: 0xc62e005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 92)); ctx->f[14] = *(float*)&val; }
    // 0x19c86c: 0xc067304
    SET_GPR_U32(ctx, 31, 0x19c874);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 23));
    BuildRchmCoefficients__FP4RCHMfffPf(rdram, ctx, runtime); return;
}


// Function: entry_19c874
// Address: 0x19c874 - 0x19c8b0

void entry_19c874(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c874) {
        switch (ctx->pc) {
            case 0x19c880: ctx->pc = 0; goto label_19c880;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c874: 0x260182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19c878: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19c87c: 0x0
    // NOP
label_19c880:
    // 0x19c880: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x19c884: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x19c888: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x19c88c: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x19c890: 0x0
    // NOP
    // 0x19c894: 0x641fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_S32(ctx, 18) >= 0) {
        goto label_19c880;
    }
    // 0x19c89c: 0x8e2403e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 996)));
    // 0x19c8a0: 0x24050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    // 0x19c8a4: 0x24060018
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    // 0x19c8a8: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x19c8b0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_19c8b0
// Address: 0x19c8b0 - 0x19c8e4

void entry_19c8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c8b0: 0x8e2403e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 996)));
    // 0x19c8b4: 0x2a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x19c8b8: 0x8e250040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x19c8bc: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19c8c0: 0x8c8200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 192)));
    // 0x19c8c4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c8c8: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x19c8cc: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c8d0: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x19c8d4: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c8d8: 0x8e26003c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    // 0x19c8dc: 0xc04b35e
    SET_GPR_U32(ctx, 31, 0x19c8e4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[12] = *(float*)&val; }
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime); return;
}


// Function: entry_19c8e4
// Address: 0x19c8e4 - 0x19c920

void entry_19c8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c8e4: 0x8e2403e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 996)));
    // 0x19c8e8: 0x8e250080
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 128)));
    // 0x19c8ec: 0x8c8200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 192)));
    // 0x19c8f0: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x19c8f4: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x19c8f8: 0x10a00026
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 96), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19C994; return;
    }
    // 0x19c900: 0xc62c0084
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 132)); ctx->f[12] = *(float*)&val; }
    // 0x19c904: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19c908: 0xc62d0088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 136)); ctx->f[13] = *(float*)&val; }
    // 0x19c90c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19c910: 0xc62e008c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 140)); ctx->f[14] = *(float*)&val; }
    // 0x19c914: 0x26300090
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 144));
    // 0x19c918: 0xc067304
    SET_GPR_U32(ctx, 31, 0x19c920);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 23));
    BuildRchmCoefficients__FP4RCHMfffPf(rdram, ctx, runtime); return;
}


// Function: entry_19c920
// Address: 0x19c920 - 0x19c958

void entry_19c920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c920) {
        switch (ctx->pc) {
            case 0x19c928: ctx->pc = 0; goto label_19c928;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c920: 0x260182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19c924: 0x3a0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_19c928:
    // 0x19c928: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x19c92c: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x19c930: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x19c934: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x19c938: 0x0
    // NOP
    // 0x19c93c: 0x641fffa
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_S32(ctx, 18) >= 0) {
        goto label_19c928;
    }
    // 0x19c944: 0x8e2403e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 996)));
    // 0x19c948: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19c94c: 0x24050020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    // 0x19c950: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x19c958);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_19c958
// Address: 0x19c958 - 0x19c98c

void entry_19c958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19c958: 0x8e2403e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 996)));
    // 0x19c95c: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19c960: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x19c964: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19c968: 0x8c8200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 192)));
    // 0x19c96c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c970: 0x8e250040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x19c974: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c978: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x19c97c: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19c980: 0x8e26003c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 60)));
    // 0x19c984: 0xc04b35e
    SET_GPR_U32(ctx, 31, 0x19c98c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[12] = *(float*)&val; }
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime); return;
}


// Function: entry_19c98c
// Address: 0x19c98c - 0x19c9c8

void entry_19c98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19c98c) {
        switch (ctx->pc) {
            case 0x19c994: ctx->pc = 0; goto label_19c994;
            case 0x19c9a0: ctx->pc = 0; goto label_19c9a0;
            case 0x19c9a4: ctx->pc = 0; goto label_19c9a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19c98c: 0x10000004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19c9a0;
    }
label_19c994:
    // 0x19c994: 0x7a220070
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 112)));
    // 0x19c998: 0x7e220090
    WRITE128(ADD32(GPR_U32(ctx, 17), 144), GPR_VEC(ctx, 2));
    // 0x19c99c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_19c9a0:
    // 0x19c9a0: 0xae220050
    WRITE32(ADD32(GPR_U32(ctx, 17), 80), GPR_U32(ctx, 2));
label_19c9a4:
    // 0x19c9a4: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x19c9a8: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x19c9ac: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x19c9b0: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x19c9b4: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19c9b8: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19c9bc: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19c9c0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 208));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ReblendRchm__FP4RCHMP3TWRP6VECTOR
// Address: 0x19c9c8 - 0x19cc00

void entry_19cc00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19cc00: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19cc04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19cc0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19cc10; return;
}


// Function: BuildRchmCoefficients__FP4RCHMfffPf
// Address: 0x19cc10 - 0x19cd90

void entry_19ce84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ce84: 0xda030040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x19ce88: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19ce8c: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19ce90: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19ce94: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19ce98: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x19ce9c: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19cea0: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19cea4: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19cea8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19ceac: 0xfa230000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19ceb0: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19ceb4: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19ceb8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PredictRchmTargetLocalPos__FP4RCHMP6TARGETfP6VECTOR
// Address: 0x19cec0 - 0x19cee8

void entry_19cee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19cee8: 0x8e04003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x19ceec: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x19cef0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19cef4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19cef8: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x19cefc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19cf00: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x19cf08);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_19cf08
// Address: 0x19cf08 - 0x19cf68

void entry_19cf08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19cf08: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19cf0c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19cf10: 0x4be1212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x19cf14: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19cf18: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19cf1c: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19cf20: 0x4be41a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19cf24: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x19cf28: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19cf2c: 0x4be409aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19cf30: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x19cf34: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19cf38: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x19cf3c: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19cf40: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x19cf44: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19cf48: 0xfba40010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19cf4c: 0xfa250000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x19cf50: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19cf54: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19cf58: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19cf5c: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x19cf60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR
// Address: 0x19cf68 - 0x19d07c

void entry_19d07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19d07c) {
        switch (ctx->pc) {
            case 0x19d09c: ctx->pc = 0; goto label_19d09c;
            case 0x19d0b8: ctx->pc = 0; goto label_19d0b8;
            case 0x19d0bc: ctx->pc = 0; goto label_19d0bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19d07c: 0x1440000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_19d0bc;
    }
    // 0x19d084: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x19d088: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 216)));
        goto label_19d09c;
    }
    // 0x19d090: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19d094: 0x1000ffca
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19CFC0; return;
    }
label_19d09c:
    // 0x19d09c: 0x8e2200dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 220)));
    // 0x19d0a0: 0x2031823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x19d0a4: 0x721818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x19d0a8: 0x31883
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 3), 2));
    // 0x19d0ac: 0x318c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 3));
    // 0x19d0b0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19d0b4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
label_19d0b8:
    // 0x19d0b8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_19d0bc:
    // 0x19d0bc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19d0c0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19d0c4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19d0c8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19d0cc: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x19d0d0: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x19d0d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19d0dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19d0e0; return;
}


// Function: FindRchmClosestPoint__FP4RCHMP6VECTORT1PP3TWRPf
// Address: 0x19d0e0 - 0x19d138

void entry_19d138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19d138) {
        switch (ctx->pc) {
            case 0x19d154: ctx->pc = 0; goto label_19d154;
            case 0x19d15c: ctx->pc = 0; goto label_19d15c;
            case 0x19d16c: ctx->pc = 0; goto label_19d16c;
            case 0x19d190: ctx->pc = 0; goto label_19d190;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19d138: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19d13c: 0x1060000b
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_19d16c;
    }
    // 0x19d144: 0x12600003
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_19d154;
    }
    // 0x19d14c: 0x7a420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x19d150: 0x7e620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 2));
label_19d154:
    // 0x19d154: 0x56800001
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 3));
        goto label_19d15c;
    }
label_19d15c:
    // 0x19d15c: 0x56c00042
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 0));
        ctx->pc = 0x19D268; return;
    }
    // 0x19d164: 0x10000041
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19D26C; return;
    }
label_19d16c:
    // 0x19d16c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19d170: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x19d174: 0x4480b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 0);
    // 0x19d178: 0x24110009
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 9));
    // 0x19d17c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x19d180: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x19d184: 0x4600ae06
    ctx->f[24] = FPU_MOV_S(ctx->f[21]);
    // 0x19d188: 0x4615b000
    ctx->f[0] = FPU_ADD_S(ctx->f[22], ctx->f[21]);
    // 0x19d18c: 0x0
    // NOP
label_19d190:
    // 0x19d190: 0xda020090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x19d194: 0xda440000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x19d198: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d19c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19d1a0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19d1a4: 0x46170502
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x19d1a8: 0x4614c001
    ctx->f[0] = FPU_SUB_S(ctx->f[24], ctx->f[20]);
    // 0x19d1ac: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x19d1b0: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19d1b4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x19d1b8: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19d1bc: 0x4be111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x19d1c0: 0x4be32088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19d1c4: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19d1c8: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19d1cc: 0xc0673da
    SET_GPR_U32(ctx, 31, 0x19d1d4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_19d1d4
// Address: 0x19d1d4 - 0x19d21c

void entry_19d1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19d1d4) {
        switch (ctx->pc) {
            case 0x19d1f0: ctx->pc = 0; goto label_19d1f0;
            case 0x19d1f4: ctx->pc = 0; goto label_19d1f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19d1d4: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19d1d8: 0x10600005
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_19d1f0;
    }
    // 0x19d1e0: 0x60a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x19d1e4: 0x4600a586
    ctx->f[22] = FPU_MOV_S(ctx->f[20]);
    // 0x19d1e8: 0x10000002
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19d1f4;
    }
label_19d1f0:
    // 0x19d1f0: 0x4600a546
    ctx->f[21] = FPU_MOV_S(ctx->f[20]);
label_19d1f4:
    // 0x19d1f4: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x19d1f8: 0x623ffe5
    if (GPR_S32(ctx, 17) >= 0) {
        ctx->f[0] = FPU_ADD_S(ctx->f[22], ctx->f[21]);
        ctx->pc = 0x19D190; return;
    }
    // 0x19d200: 0x16a00007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19D220; return;
    }
    // 0x19d208: 0x7a020070
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 112)));
    // 0x19d20c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19d210: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x19d214: 0xc0673da
    SET_GPR_U32(ctx, 31, 0x19d21c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_19d21c
// Address: 0x19d21c - 0x19d2a8

void entry_19d21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19d21c) {
        switch (ctx->pc) {
            case 0x19d220: ctx->pc = 0; goto label_19d220;
            case 0x19d22c: ctx->pc = 0; goto label_19d22c;
            case 0x19d234: ctx->pc = 0; goto label_19d234;
            case 0x19d268: ctx->pc = 0; goto label_19d268;
            case 0x19d26c: ctx->pc = 0; goto label_19d26c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19d21c: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_19d220:
    // 0x19d220: 0x12600002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_19d22c;
    }
    // 0x19d228: 0x7e620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 2));
label_19d22c:
    // 0x19d22c: 0x56800001
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 20), 0), GPR_U32(ctx, 21));
        goto label_19d234;
    }
label_19d234:
    // 0x19d234: 0x12c0000c
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_19d268;
    }
    // 0x19d23c: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x19d240: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19d244: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19d248: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19d24c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19d250: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19d254: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19d258: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19d25c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19d260: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19d264: 0xaec20000
    WRITE32(ADD32(GPR_U32(ctx, 22), 0), GPR_U32(ctx, 2));
label_19d268:
    // 0x19d268: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_19d26c:
    // 0x19d26c: 0x7bb60090
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x19d270: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19d274: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19d278: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19d27c: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19d280: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19d284: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19d288: 0xc7b800d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[24] = *(float*)&val; }
    // 0x19d28c: 0xc7b700c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[23] = *(float*)&val; }
    // 0x19d290: 0xc7b600c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[22] = *(float*)&val; }
    // 0x19d294: 0xc7b500b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[21] = *(float*)&val; }
    // 0x19d298: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x19d29c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19d2a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19d2a8; return;
}


// Function: TrackJtTarget__FP2JTP4RCHMP6TARGET
// Address: 0x19d2a8 - 0x19d2f8

void entry_19d2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d2f8: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x19d2fc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19d300: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19d304: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d308: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x19d30c: 0xc067438
    SET_GPR_U32(ctx, 31, 0x19d314);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 36));
    FindRchmClosestPoint__FP4RCHMP6VECTORT1PP3TWRPf(rdram, ctx, runtime); return;
}


// Function: entry_19d314
// Address: 0x19d314 - 0x19d324

void entry_19d314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d314: 0x8fa50020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19d318: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19d31c: 0xc067272
    SET_GPR_U32(ctx, 31, 0x19d324);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ReblendRchm__FP4RCHMP3TWRP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_19d324
// Address: 0x19d324 - 0x19d338

void entry_19d324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d324: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19d328: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19d32c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19d330: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TrackJtPipe__FP2JTP4RCHMP4PIPEPf
// Address: 0x19d338 - 0x19d378

void entry_19d378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d378: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x19d37c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19d380: 0x8c420030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x19d384: 0x10400009
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_19d3ac(rdram, ctx, runtime); return;
    }
    // 0x19d38c: 0xc64c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 0)); ctx->f[12] = *(float*)&val; }
    // 0x19d390: 0x240502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19d394: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19d398: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19d39c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19d3a0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19d3a4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19d3ac);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19d3ac
// Address: 0x19d3ac - 0x19d3c4

void entry_19d3ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d3ac: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x19d3b0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19d3b4: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x19d3b8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19d3bc: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x19d3c4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_19d3c4
// Address: 0x19d3c4 - 0x19d3e0

void entry_19d3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d3c4: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x19d3c8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d3cc: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19d3d0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19d3d4: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x19d3d8: 0xc067438
    SET_GPR_U32(ctx, 31, 0x19d3e0);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 68));
    FindRchmClosestPoint__FP4RCHMP6VECTORT1PP3TWRPf(rdram, ctx, runtime); return;
}


// Function: entry_19d3e0
// Address: 0x19d3e0 - 0x19d3f0

void entry_19d3e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d3e0: 0x8fa50040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19d3e4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19d3e8: 0xc067272
    SET_GPR_U32(ctx, 31, 0x19d3f0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ReblendRchm__FP4RCHMP3TWRP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_19d3f0
// Address: 0x19d3f0 - 0x19d410

void entry_19d3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d3f0: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x19d3f4: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x19d3f8: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19d3fc: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19d400: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19d404: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19d408: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SubmitRpl__FP3RPL
// Address: 0x19d410 - 0x19d468

void entry_19d648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d648: 0x8fa20070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19d64c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d650: 0x8fa500c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x19d654: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x19d658: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x19d65c: 0xa22823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x19d660: 0xc06f82a
    SET_GPR_U32(ctx, 31, 0x19d668);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    HeapSort__FPviiPFPvPv_i(rdram, ctx, runtime); return;
}


// Function: entry_19d668
// Address: 0x19d668 - 0x19d688

void entry_19d668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d668: 0x8fa20084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 132)));
    // 0x19d66c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d670: 0x8fa500d4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 212)));
    // 0x19d674: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x19d678: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x19d67c: 0xa22823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x19d680: 0xc06f82a
    SET_GPR_U32(ctx, 31, 0x19d688);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    HeapSort__FPviiPFPvPv_i(rdram, ctx, runtime); return;
}


// Function: entry_19d688
// Address: 0x19d688 - 0x19d6a8

void entry_19d688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d688: 0x8fa50054
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x19d68c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d690: 0x8fa200a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 164)));
    // 0x19d694: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x19d698: 0x52080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 5), 2));
    // 0x19d69c: 0x2242021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    // 0x19d6a0: 0xc06f82a
    SET_GPR_U32(ctx, 31, 0x19d6a8);
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    HeapSort__FPviiPFPvPv_i(rdram, ctx, runtime); return;
}


// Function: entry_19d6a8
// Address: 0x19d6a8 - 0x19d6c0

void entry_19d6a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d6a8: 0x8fa200e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x19d6ac: 0x7bbf0110
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x19d6b0: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x19d6b4: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x19d6b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 288));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderSw__FP2SWP2CM
// Address: 0x19d6c0 - 0x19d758

void entry_19d758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19d758) {
        switch (ctx->pc) {
            case 0x19d774: ctx->pc = 0; goto label_19d774;
            case 0x19d7b0: ctx->pc = 0; goto label_19d7b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19d758: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x19d75c: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x19d760: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19d764: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19d768: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x19d76c: 0x14a0fff4
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19D740; return;
    }
label_19d774:
    // 0x19d774: 0x26020078
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 120));
    // 0x19d778: 0x8e64b314
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4294947604)));
    // 0x19d77c: 0xafa20014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    // 0x19d780: 0x26121cd8
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 7384));
    // 0x19d784: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    // 0x19d788: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x19d78c: 0xae74b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 20));
    // 0x19d790: 0xafa4001c
    WRITE32(ADD32(GPR_U32(ctx, 29), 28), GPR_U32(ctx, 4));
    // 0x19d794: 0x8e020078
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 120)));
    // 0x19d798: 0xafa30018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 3));
    // 0x19d79c: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19d7a0: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19d7a4: 0x10a0000f
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19D7E4; return;
    }
    // 0x19d7ac: 0x0
    // NOP
label_19d7b0:
    // 0x19d7b0: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x19d7b4: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x19d7b8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19d7bc: 0x8c6200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 160)));
    // 0x19d7c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19d7c8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19d7c8
// Address: 0x19d7c8 - 0x19d818

void entry_19d7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19d7c8) {
        switch (ctx->pc) {
            case 0x19d7e4: ctx->pc = 0; goto label_19d7e4;
            case 0x19d810: ctx->pc = 0; goto label_19d810;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19d7c8: 0x8fa40014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x19d7cc: 0x8fa20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x19d7d0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19d7d4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19d7d8: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x19d7dc: 0x14a0fff4
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19D7B0; return;
    }
label_19d7e4:
    // 0x19d7e4: 0x8e62b314
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4294947604)));
    // 0x19d7e8: 0x8e440008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x19d7ec: 0xafa2002c
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 2));
    // 0x19d7f0: 0xae75b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 21));
    // 0x19d7f4: 0x8e031cd8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 7384)));
    // 0x19d7f8: 0xafb20020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 18));
    // 0x19d7fc: 0x641021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x19d800: 0x60282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x19d804: 0xafa20024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    // 0x19d808: 0x10a0000a
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19D834; return;
    }
label_19d810:
    // 0x19d810: 0xc056740
    SET_GPR_U32(ctx, 31, 0x19d818);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    FUN_00159d00(rdram, ctx, runtime); return;
}


// Function: entry_19d818
// Address: 0x19d818 - 0x19d860

void entry_19d818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19d818) {
        switch (ctx->pc) {
            case 0x19d834: ctx->pc = 0; goto label_19d834;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19d818: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x19d81c: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x19d820: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19d824: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x19d828: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19d82c: 0x14a0fff8
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19D810; return;
    }
label_19d834:
    // 0x19d834: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x19d838: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x19d83c: 0xae62b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    // 0x19d840: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19d844: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19d848: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19d84c: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19d850: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19d854: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19d858: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnsureRenderGlobals__Fv
// Address: 0x19d860 - 0x19d890

void entry_19d890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d890: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d894: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19d898: 0xc07b8ee
    SET_GPR_U32(ctx, 31, 0x19d8a0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifBaseOffset__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_19d8a0
// Address: 0x19d8a0 - 0x19d8bc

void entry_19d8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d8a0: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x19d8a4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d8a8: 0x24e7abf0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294945776));
    // 0x19d8ac: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x19d8b0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19d8b4: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x19d8bc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_19d8bc
// Address: 0x19d8bc - 0x19d8d8

void entry_19d8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d8bc: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x19d8c0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d8c4: 0x24e7ac00
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294945792));
    // 0x19d8c8: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x19d8cc: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19d8d0: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x19d8d8);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_19d8d8
// Address: 0x19d8d8 - 0x19d8f4

void entry_19d8d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d8d8: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    // 0x19d8dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d8e0: 0x24e7ac20
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294945824));
    // 0x19d8e4: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x19d8e8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19d8ec: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x19d8f4);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 12));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_19d8f4
// Address: 0x19d8f4 - 0x19d914

void entry_19d8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d8f4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19d8f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d8fc: 0x8c475710
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x19d900: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x19d904: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19d908: 0x24080003
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 3));
    // 0x19d90c: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x19d914);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 7528));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_19d914
// Address: 0x19d914 - 0x19d91c

void entry_19d914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d914: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x19d91c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_19d91c
// Address: 0x19d91c - 0x19d930

void entry_19d91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d91c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19d920: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19d924: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19d92c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19d930; return;
}


// Function: EnsureCameraGlobals__Fv
// Address: 0x19d930 - 0x19d958

void entry_19d958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d958: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19d95c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19d964: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19d968; return;
}


// Function: EnsureScreenCleared__Fv
// Address: 0x19d968 - 0x19d994

void entry_19d994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d994: 0x3c06002c
    SET_GPR_U32(ctx, 6, ((uint32_t)44 << 16));
    // 0x19d998: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d99c: 0x24c6dc20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294958112));
    // 0x19d9a0: 0x2405002c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 44));
    // 0x19d9a4: 0xc07b9f4
    SET_GPR_U32(ctx, 31, 0x19d9ac);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifDirect__4VIFSiP2QWi(rdram, ctx, runtime); return;
}


// Function: entry_19d9ac
// Address: 0x19d9ac - 0x19d9b4

void entry_19d9ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d9ac: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x19d9b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_19d9b4
// Address: 0x19d9b4 - 0x19d9e8

void entry_19d9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19d9b4) {
        switch (ctx->pc) {
            case 0x19d9c8: ctx->pc = 0; goto label_19d9c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19d9b4: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19d9b8: 0x3c020060
    SET_GPR_U32(ctx, 2, ((uint32_t)96 << 16));
    // 0x19d9bc: 0xac434784
    WRITE32(ADD32(GPR_U32(ctx, 2), 18308), GPR_U32(ctx, 3));
    // 0x19d9c0: 0x10000015
    WRITE32(ADD32(GPR_U32(ctx, 17), 18304), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19DA18; return;
    }
label_19d9c8:
    // 0x19d9c8: 0x3c110060
    SET_GPR_U32(ctx, 17, ((uint32_t)96 << 16));
    // 0x19d9cc: 0x8e224784
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 18308)));
    // 0x19d9d0: 0x14400012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19DA1C; return;
    }
    // 0x19d9d8: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x19d9dc: 0x261022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8872));
    // 0x19d9e0: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x19d9e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_19d9e8
// Address: 0x19d9e8 - 0x19d9f0

void entry_19d9e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d9e8: 0xc07b914
    SET_GPR_U32(ctx, 31, 0x19d9f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifFlush__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_19d9f0
// Address: 0x19d9f0 - 0x19da08

void entry_19d9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19d9f0: 0x3c06002c
    SET_GPR_U32(ctx, 6, ((uint32_t)44 << 16));
    // 0x19d9f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19d9f8: 0x24c6dee0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294958816));
    // 0x19d9fc: 0x2405002c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 44));
    // 0x19da00: 0xc07b9f4
    SET_GPR_U32(ctx, 31, 0x19da08);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifDirect__4VIFSiP2QWi(rdram, ctx, runtime); return;
}


// Function: entry_19da08
// Address: 0x19da08 - 0x19da10

void entry_19da08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19da08: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x19da10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_19da10
// Address: 0x19da10 - 0x19da30

void entry_19da10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19da10) {
        switch (ctx->pc) {
            case 0x19da18: ctx->pc = 0; goto label_19da18;
            case 0x19da1c: ctx->pc = 0; goto label_19da1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19da10: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19da14: 0xae224784
    WRITE32(ADD32(GPR_U32(ctx, 17), 18308), GPR_U32(ctx, 2));
label_19da18:
    // 0x19da18: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_19da1c:
    // 0x19da1c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19da20: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19da24: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19da2c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19da30; return;
}


// Function: SetupRpDynamicTexture__FP3RPL
// Address: 0x19da30 - 0x19da54

void entry_19da54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19da54: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19da58: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetupRpBackground__FP3RPL
// Address: 0x19da60 - 0x19da70

void entry_19da70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19da70: 0xc06764c
    SET_GPR_U32(ctx, 31, 0x19da78);
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    EnsureCameraGlobals__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19da78
// Address: 0x19da78 - 0x19da94

void entry_19da78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19da78: 0x3c050021
    SET_GPR_U32(ctx, 5, ((uint32_t)33 << 16));
    // 0x19da7c: 0x261022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8872));
    // 0x19da80: 0x3c060021
    SET_GPR_U32(ctx, 6, ((uint32_t)33 << 16));
    // 0x19da84: 0x24a52160
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8544));
    // 0x19da88: 0x24c65c50
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 23632));
    // 0x19da8c: 0xc057ab8
    SET_GPR_U32(ctx, 31, 0x19da94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EnsureVu1Code__FP4VIFSPvT1(rdram, ctx, runtime); return;
}


// Function: entry_19da94
// Address: 0x19da94 - 0x19dab4

void entry_19da94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19da94: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x19da98: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19da9c: 0x8c6622d8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 8920)));
    // 0x19daa0: 0x3c020060
    SET_GPR_U32(ctx, 2, ((uint32_t)96 << 16));
    // 0x19daa4: 0xac454780
    WRITE32(ADD32(GPR_U32(ctx, 2), 18304), GPR_U32(ctx, 5));
    // 0x19daa8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19daac: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x19dab4);
    WRITE32(ADD32(GPR_U32(ctx, 6), 28), GPR_U32(ctx, 5));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_19dab4
// Address: 0x19dab4 - 0x19dabc

void entry_19dab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dab4: 0xc07b91a
    SET_GPR_U32(ctx, 31, 0x19dabc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifFlusha__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_19dabc
// Address: 0x19dabc - 0x19dac4

void entry_19dabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dabc: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x19dac4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_19dac4
// Address: 0x19dac4 - 0x19dad8

void entry_19dac4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dac4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19dac8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19dacc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19dad4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19dad8; return;
}


// Function: SetupRpBlotContext__FP3RPL
// Address: 0x19dad8 - 0x19dae8

void entry_19dae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dae8: 0xc06765a
    SET_GPR_U32(ctx, 31, 0x19daf0);
    EnsureScreenCleared__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19daf0
// Address: 0x19daf0 - 0x19db0c

void entry_19daf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19daf0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x19daf4: 0x3c050021
    SET_GPR_U32(ctx, 5, ((uint32_t)33 << 16));
    // 0x19daf8: 0x3c060021
    SET_GPR_U32(ctx, 6, ((uint32_t)33 << 16));
    // 0x19dafc: 0x248422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8872));
    // 0x19db00: 0x24a52160
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8544));
    // 0x19db04: 0xc057ab8
    SET_GPR_U32(ctx, 31, 0x19db0c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 23632));
    EnsureVu1Code__FP4VIFSPvT1(rdram, ctx, runtime); return;
}


// Function: entry_19db0c
// Address: 0x19db0c - 0x19db20

void entry_19db0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19db0c: 0x3c020060
    SET_GPR_U32(ctx, 2, ((uint32_t)96 << 16));
    // 0x19db10: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19db14: 0xac404788
    WRITE32(ADD32(GPR_U32(ctx, 2), 18312), GPR_U32(ctx, 0));
    // 0x19db18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetupRpGlob__FP3RPL
// Address: 0x19db20 - 0x19db30

void entry_19db30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19db30: 0xc06764c
    SET_GPR_U32(ctx, 31, 0x19db38);
    EnsureCameraGlobals__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19db38
// Address: 0x19db38 - 0x19db40

void entry_19db38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19db38: 0xc06765a
    SET_GPR_U32(ctx, 31, 0x19db40);
    EnsureScreenCleared__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19db40
// Address: 0x19db40 - 0x19db5c

void entry_19db40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19db40: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x19db44: 0x3c050021
    SET_GPR_U32(ctx, 5, ((uint32_t)33 << 16));
    // 0x19db48: 0x3c060021
    SET_GPR_U32(ctx, 6, ((uint32_t)33 << 16));
    // 0x19db4c: 0x248422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8872));
    // 0x19db50: 0x24a52160
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8544));
    // 0x19db54: 0xc057ab8
    SET_GPR_U32(ctx, 31, 0x19db5c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 23632));
    EnsureVu1Code__FP4VIFSPvT1(rdram, ctx, runtime); return;
}


// Function: entry_19db5c
// Address: 0x19db5c - 0x19db68

void entry_19db5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19db5c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19db60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetupRpBlip__FP3RPL
// Address: 0x19db68 - 0x19db78

void entry_19db78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19db78: 0xc06764c
    SET_GPR_U32(ctx, 31, 0x19db80);
    EnsureCameraGlobals__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19db80
// Address: 0x19db80 - 0x19db88

void entry_19db80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19db80: 0xc06765a
    SET_GPR_U32(ctx, 31, 0x19db88);
    EnsureScreenCleared__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19db88
// Address: 0x19db88 - 0x19dba4

void entry_19db88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19db88: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x19db8c: 0x3c050021
    SET_GPR_U32(ctx, 5, ((uint32_t)33 << 16));
    // 0x19db90: 0x3c060021
    SET_GPR_U32(ctx, 6, ((uint32_t)33 << 16));
    // 0x19db94: 0x248422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8872));
    // 0x19db98: 0x24a55c60
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 23648));
    // 0x19db9c: 0xc057ab8
    SET_GPR_U32(ctx, 31, 0x19dba4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 29512));
    EnsureVu1Code__FP4VIFSPvT1(rdram, ctx, runtime); return;
}


// Function: entry_19dba4
// Address: 0x19dba4 - 0x19dbb0

void entry_19dba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dba4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19dba8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetupRpWorldMap__FP3RPL
// Address: 0x19dbb0 - 0x19dbe4

void entry_19dbe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dbe4: 0xc067618
    SET_GPR_U32(ctx, 31, 0x19dbec);
    EnsureRenderGlobals__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19dbec
// Address: 0x19dbec - 0x19dbf4

void entry_19dbec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dbec: 0xc06764c
    SET_GPR_U32(ctx, 31, 0x19dbf4);
    EnsureCameraGlobals__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19dbf4
// Address: 0x19dbf4 - 0x19dc60

void entry_19dbf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19dbf4) {
        switch (ctx->pc) {
            case 0x19dc40: ctx->pc = 0; goto label_19dc40;
            case 0x19dc44: ctx->pc = 0; goto label_19dc44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19dbf4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19dbf8: 0x8c42fa68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4294965864)));
    // 0x19dbfc: 0x50400011
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
        goto label_19dc44;
    }
    // 0x19dc04: 0x8c4302f4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 756)));
    // 0x19dc08: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19dc0c: 0x24424520
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 17696));
    // 0x19dc10: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x19dc14: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19dc18: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x19dc1c: 0x10600008
    SET_GPR_U32(ctx, 2, ((uint32_t)20480 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_19dc40;
    }
    // 0x19dc24: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x19dc28: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x19dc2c: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19dc30: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x19dc34: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x19dc38: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x19dc3c: 0xae02000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
label_19dc40:
    // 0x19dc40: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
label_19dc44:
    // 0x19dc44: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19dc48: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19dc4c: 0x8e021990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x19dc50: 0xc45401c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 452)); ctx->f[20] = *(float*)&val; }
    // 0x19dc54: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19dc58: 0xc050e50
    SET_GPR_U32(ctx, 31, 0x19dc60);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 456)); ctx->f[21] = *(float*)&val; }
    SetCmFov__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_19dc60
// Address: 0x19dc60 - 0x19dc68

void entry_19dc60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dc60: 0xc051212
    SET_GPR_U32(ctx, 31, 0x19dc68);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    DrawCm__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_19dc68
// Address: 0x19dc68 - 0x19dc74

void entry_19dc68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dc68: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x19dc6c: 0xc050e50
    SET_GPR_U32(ctx, 31, 0x19dc74);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetCmFov__FP2CMf(rdram, ctx, runtime); return;
}


// Function: entry_19dc74
// Address: 0x19dc74 - 0x19dc98

void entry_19dc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dc74: 0x8e021990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x19dc78: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19dc7c: 0xe45501c8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 2), 456), *(uint32_t*)&val); }
    // 0x19dc80: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19dc84: 0xc7b50028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[21] = *(float*)&val; }
    // 0x19dc88: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x19dc8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19dc94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19dc98; return;
}


// Function: DrawSw__FP2SWP2CM
// Address: 0x19dc98 - 0x19dcc0

void entry_19dcc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dcc0: 0x8e04ac10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4294945808)));
    // 0x19dcc4: 0x3c05005e
    SET_GPR_U32(ctx, 5, ((uint32_t)94 << 16));
    // 0x19dcc8: 0x24a54700
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 18176));
    // 0x19dccc: 0x3c060060
    SET_GPR_U32(ctx, 6, ((uint32_t)96 << 16));
    // 0x19dcd0: 0x3c070060
    SET_GPR_U32(ctx, 7, ((uint32_t)96 << 16));
    // 0x19dcd4: 0x852023
    SET_GPR_U32(ctx, 4, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x19dcd8: 0x3c080060
    SET_GPR_U32(ctx, 8, ((uint32_t)96 << 16));
    // 0x19dcdc: 0x3c090060
    SET_GPR_U32(ctx, 9, ((uint32_t)96 << 16));
    // 0x19dce0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x19dce4: 0x24020214
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 532));
    // 0x19dce8: 0xacc04784
    WRITE32(ADD32(GPR_U32(ctx, 6), 18308), GPR_U32(ctx, 0));
    // 0x19dcec: 0x421c3
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 4), 7));
    // 0x19dcf0: 0xac622474
    WRITE32(ADD32(GPR_U32(ctx, 3), 9332), GPR_U32(ctx, 2));
    // 0x19dcf4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19dcf8: 0xace04780
    WRITE32(ADD32(GPR_U32(ctx, 7), 18304), GPR_U32(ctx, 0));
    // 0x19dcfc: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x19dd00: 0xad004788
    WRITE32(ADD32(GPR_U32(ctx, 8), 18312), GPR_U32(ctx, 0));
    // 0x19dd04: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19dd08: 0xc06752c
    SET_GPR_U32(ctx, 31, 0x19dd10);
    WRITE32(ADD32(GPR_U32(ctx, 9), 18316), GPR_U32(ctx, 0));
    CprplPartitionArpl__FiP3RPLPP3RPL(rdram, ctx, runtime); return;
}


// Function: entry_19dd10
// Address: 0x19dd10 - 0x19dd28

void entry_19dd10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dd10: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19dd14: 0x261022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8872));
    // 0x19dd18: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19dd1c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19dd20: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x19dd28);
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_19dd28
// Address: 0x19dd28 - 0x19dd48

void entry_19dd28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19dd28) {
        switch (ctx->pc) {
            case 0x19dd38: ctx->pc = 0; goto label_19dd38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19dd28: 0x1a400009
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 18) <= 0) {
        ctx->pc = 0x19DD50; return;
    }
    // 0x19dd30: 0x240802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19dd34: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_19dd38:
    // 0x19dd38: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x19dd3c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19dd40: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19dd48);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19dd48
// Address: 0x19dd48 - 0x19dd5c

void entry_19dd48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19dd48) {
        switch (ctx->pc) {
            case 0x19dd50: ctx->pc = 0; goto label_19dd50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19dd48: 0x5600fffb
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x19DD38; return;
    }
label_19dd50:
    // 0x19dd50: 0x267022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 19), 8872));
    // 0x19dd54: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x19dd5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_19dd5c
// Address: 0x19dd5c - 0x19dd7c

void entry_19dd5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19dd5c: 0x56400008
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 20), 4294945808), GPR_U32(ctx, 0));
        ctx->pc = 0x19DD80; return;
    }
    // 0x19dd64: 0x3c06002c
    SET_GPR_U32(ctx, 6, ((uint32_t)44 << 16));
    // 0x19dd68: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19dd6c: 0x24c6dc20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294958112));
    // 0x19dd70: 0x2405002c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 44));
    // 0x19dd74: 0xc07b9f4
    SET_GPR_U32(ctx, 31, 0x19dd7c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifDirect__4VIFSiP2QWi(rdram, ctx, runtime); return;
}


// Function: entry_19dd7c
// Address: 0x19dd7c - 0x19dda0

void entry_19dd7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19dd7c) {
        switch (ctx->pc) {
            case 0x19dd80: ctx->pc = 0; goto label_19dd80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19dd7c: 0xae80ac10
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294945808), GPR_U32(ctx, 0));
label_19dd80:
    // 0x19dd80: 0x7bbf10a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 4256)));
    // 0x19dd84: 0x7bb41090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 4240)));
    // 0x19dd88: 0x7bb31080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 4224)));
    // 0x19dd8c: 0x7bb21070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 4208)));
    // 0x19dd90: 0x7bb11060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 4192)));
    // 0x19dd94: 0x7bb01050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 4176)));
    // 0x19dd98: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4272));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FillScreenRect__FiiiiffffP4GIFS
// Address: 0x19dda0 - 0x19de28

void entry_19de28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19de28: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x19de2c: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x19de30: 0x4481d000
    *(uint32_t*)&ctx->f[26] = GPR_U32(ctx, 1);
    // 0x19de34: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x19de38: 0x118c00
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 17), 16));
    // 0x19de3c: 0x321001fe
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 510));
    // 0x19de40: 0x129200
    SET_GPR_U32(ctx, 18, SLL32(GPR_U32(ctx, 18), 8));
    // 0x19de44: 0x1085c0
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 23));
    // 0x19de48: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19de4c: 0x2118025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x19de50: 0x24050047
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    // 0x19de54: 0x2128025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 18)));
    // 0x19de58: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x19de5c: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x19de60: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x19de64: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x19de68: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x19de70);
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 20)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_19de70
// Address: 0x19de70 - 0x19de90

void entry_19de70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19de70: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x19de74: 0x4481c800
    *(uint32_t*)&ctx->f[25] = GPR_U32(ctx, 1);
    // 0x19de78: 0x24060044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    // 0x19de7c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19de80: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x19de84: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x19de88: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x19de90);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_19de90
// Address: 0x19de90 - 0x19de9c

void entry_19de90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19de90: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19de94: 0xc058516
    SET_GPR_U32(ctx, 31, 0x19de9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PackRGBA__4GIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_19de9c
// Address: 0x19de9c - 0x19ded0

void entry_19de9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19de9c: 0x461aa502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[26]);
    // 0x19dea0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19dea4: 0x461bbdc0
    ctx->f[23] = FPU_ADD_S(ctx->f[23], ctx->f[27]);
    // 0x19dea8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19deac: 0x4619a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[25]);
    // 0x19deb0: 0x4616bdc2
    ctx->f[23] = FPU_MUL_S(ctx->f[23], ctx->f[22]);
    // 0x19deb4: 0x4616a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[22]);
    // 0x19deb8: 0x4600b824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[23]);
    // 0x19debc: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x19dec0: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x19dec4: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x19dec8: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x19ded0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_19ded0
// Address: 0x19ded0 - 0x19df04

void entry_19ded0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ded0: 0x461aad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[26]);
    // 0x19ded4: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19ded8: 0x461bc600
    ctx->f[24] = FPU_ADD_S(ctx->f[24], ctx->f[27]);
    // 0x19dedc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19dee0: 0x4619ad40
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[25]);
    // 0x19dee4: 0x4616c602
    ctx->f[24] = FPU_MUL_S(ctx->f[24], ctx->f[22]);
    // 0x19dee8: 0x4616ad42
    ctx->f[21] = FPU_MUL_S(ctx->f[21], ctx->f[22]);
    // 0x19deec: 0x4600c024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[24]);
    // 0x19def0: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x19def4: 0x4600a824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[21]);
    // 0x19def8: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x19defc: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x19df04);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_19df04
// Address: 0x19df04 - 0x19df48

void entry_19df04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19df04: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19df08: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19df0c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19df10: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19df14: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19df18: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19df1c: 0xc7bb0098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[27] = *(float*)&val; }
    // 0x19df20: 0xc7ba0090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[26] = *(float*)&val; }
    // 0x19df24: 0xc7b90088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[25] = *(float*)&val; }
    // 0x19df28: 0xc7b80080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[24] = *(float*)&val; }
    // 0x19df2c: 0xc7b70078
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 120)); ctx->f[23] = *(float*)&val; }
    // 0x19df30: 0xc7b60070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[22] = *(float*)&val; }
    // 0x19df34: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x19df38: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x19df3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19df44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19df48; return;
}


// Function: StartupRender__Fv
// Address: 0x19df48 - 0x19df58

void entry_19df58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19df58: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x19df5c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19df60: 0x24c6ac20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294945824));
    // 0x19df64: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x19df6c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_19df6c
// Address: 0x19df6c - 0x19df88

void entry_19df6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19df6c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19df70: 0x2405007d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 125));
    // 0x19df74: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19df78: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x19df7c: 0x24080412
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 1042));
    // 0x19df80: 0xc0584be
    SET_GPR_U32(ctx, 31, 0x19df88);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddPrimBulk__4GIFSiiiUlPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_19df88
// Address: 0x19df88 - 0x19e040

void entry_19df88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19df88) {
        switch (ctx->pc) {
            case 0x19e018: ctx->pc = 0; goto label_19e018;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19df88: 0x3c04001a
    SET_GPR_U32(ctx, 4, ((uint32_t)26 << 16));
    // 0x19df8c: 0x3c090027
    SET_GPR_U32(ctx, 9, ((uint32_t)39 << 16));
    // 0x19df90: 0x2484da30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294957616));
    // 0x19df94: 0x3c05001a
    SET_GPR_U32(ctx, 5, ((uint32_t)26 << 16));
    // 0x19df98: 0x3c06001a
    SET_GPR_U32(ctx, 6, ((uint32_t)26 << 16));
    // 0x19df9c: 0x3c03001a
    SET_GPR_U32(ctx, 3, ((uint32_t)26 << 16));
    // 0x19dfa0: 0x3c08001a
    SET_GPR_U32(ctx, 8, ((uint32_t)26 << 16));
    // 0x19dfa4: 0x3c07001a
    SET_GPR_U32(ctx, 7, ((uint32_t)26 << 16));
    // 0x19dfa8: 0x2522ac30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 9), 4294945840));
    // 0x19dfac: 0xad24ac30
    WRITE32(ADD32(GPR_U32(ctx, 9), 4294945840), GPR_U32(ctx, 4));
    // 0x19dfb0: 0x2463db20
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294957856));
    // 0x19dfb4: 0x2508db68
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294957928));
    // 0x19dfb8: 0x24a5da60
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294957664));
    // 0x19dfbc: 0x24c6dad8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294957784));
    // 0x19dfc0: 0x24e7dbb0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294958000));
    // 0x19dfc4: 0xac450080
    WRITE32(ADD32(GPR_U32(ctx, 2), 128), GPR_U32(ctx, 5));
    // 0x19dfc8: 0xac460100
    WRITE32(ADD32(GPR_U32(ctx, 2), 256), GPR_U32(ctx, 6));
    // 0x19dfcc: 0x240affff
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x19dfd0: 0xac480780
    WRITE32(ADD32(GPR_U32(ctx, 2), 1920), GPR_U32(ctx, 8));
    // 0x19dfd4: 0x24450888
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 2184));
    // 0x19dfd8: 0xac430800
    WRITE32(ADD32(GPR_U32(ctx, 2), 2048), GPR_U32(ctx, 3));
    // 0x19dfdc: 0x24040011
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 17));
    // 0x19dfe0: 0xac470880
    WRITE32(ADD32(GPR_U32(ctx, 2), 2176), GPR_U32(ctx, 7));
    // 0x19dfe4: 0xac430180
    WRITE32(ADD32(GPR_U32(ctx, 2), 384), GPR_U32(ctx, 3));
    // 0x19dfe8: 0xac430200
    WRITE32(ADD32(GPR_U32(ctx, 2), 512), GPR_U32(ctx, 3));
    // 0x19dfec: 0xac480280
    WRITE32(ADD32(GPR_U32(ctx, 2), 640), GPR_U32(ctx, 8));
    // 0x19dff0: 0xac430300
    WRITE32(ADD32(GPR_U32(ctx, 2), 768), GPR_U32(ctx, 3));
    // 0x19dff4: 0xac430380
    WRITE32(ADD32(GPR_U32(ctx, 2), 896), GPR_U32(ctx, 3));
    // 0x19dff8: 0xac430400
    WRITE32(ADD32(GPR_U32(ctx, 2), 1024), GPR_U32(ctx, 3));
    // 0x19dffc: 0xac480480
    WRITE32(ADD32(GPR_U32(ctx, 2), 1152), GPR_U32(ctx, 8));
    // 0x19e000: 0xac430600
    WRITE32(ADD32(GPR_U32(ctx, 2), 1536), GPR_U32(ctx, 3));
    // 0x19e004: 0xac430580
    WRITE32(ADD32(GPR_U32(ctx, 2), 1408), GPR_U32(ctx, 3));
    // 0x19e008: 0xac430500
    WRITE32(ADD32(GPR_U32(ctx, 2), 1280), GPR_U32(ctx, 3));
    // 0x19e00c: 0xac430680
    WRITE32(ADD32(GPR_U32(ctx, 2), 1664), GPR_U32(ctx, 3));
    // 0x19e010: 0xac480700
    WRITE32(ADD32(GPR_U32(ctx, 2), 1792), GPR_U32(ctx, 8));
    // 0x19e014: 0x0
    // NOP
label_19e018:
    // 0x19e018: 0xacaa0000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 10));
    // 0x19e01c: 0x2484ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967295));
    // 0x19e020: 0x0
    // NOP
    // 0x19e024: 0x0
    // NOP
    // 0x19e028: 0x0
    // NOP
    // 0x19e02c: 0x481fffa
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967168));
    if (GPR_S32(ctx, 4) >= 0) {
        goto label_19e018;
    }
    // 0x19e034: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19e038: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PripgNew__FP2SW5RIPGT
// Address: 0x19e040 - 0x19e094

void entry_19e094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e094) {
        switch (ctx->pc) {
            case 0x19e09c: ctx->pc = 0; goto label_19e09c;
            case 0x19e0a0: ctx->pc = 0; goto label_19e0a0;
            case 0x19e0a4: ctx->pc = 0; goto label_19e0a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e094: 0x52400001
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 6972), GPR_U32(ctx, 16));
        goto label_19e09c;
    }
label_19e09c:
    // 0x19e09c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_19e0a0:
    // 0x19e0a0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_19e0a4:
    // 0x19e0a4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19e0a8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19e0ac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19e0b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitRipg__FP4RIPG
// Address: 0x19e0b8 - 0x19e0cc

void entry_19e0cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19e0cc: 0x26040558
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1368));
    // 0x19e0d0: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x19e0d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_19e0d8
// Address: 0x19e0d8 - 0x19e158

void entry_19e0d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19e0d8: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x19e0dc: 0x3c03cfff
    SET_GPR_U32(ctx, 3, ((uint32_t)53247 << 16));
    // 0x19e0e0: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x19e0e4: 0x3c052000
    SET_GPR_U32(ctx, 5, ((uint32_t)8192 << 16));
    // 0x19e0e8: 0xde040538
    SET_GPR_U64(ctx, 4, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x19e0ec: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19e0f0: 0x34068000
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 0), 32768));
    // 0x19e0f4: 0x636f8
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 27);
    // 0x19e0f8: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x19e0fc: 0x2403fcff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294966527));
    // 0x19e100: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x19e104: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x19e108: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x19e10c: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x19e110: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19e114: 0x862025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x19e118: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x19e11c: 0x5293c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 4));
    // 0x19e120: 0x3c015015
    SET_GPR_U32(ctx, 1, ((uint32_t)20501 << 16));
    // 0x19e124: 0x342102f9
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 761));
    // 0x19e128: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19e12c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x19e130: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x19e134: 0x852025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    // 0x19e138: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19e13c: 0xfe040538
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 4));
    // 0x19e140: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    // 0x19e144: 0xe6000080
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 128), *(uint32_t*)&val); }
    // 0x19e148: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19e14c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19e150: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetRipgEmitb__FP4RIPGP5EMITB
// Address: 0x19e158 - 0x19e168

void entry_19e1c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e1c0) {
        switch (ctx->pc) {
            case 0x19e1dc: ctx->pc = 0; goto label_19e1dc;
            case 0x19e1fc: ctx->pc = 0; goto label_19e1fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e1c0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x19e1c4: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x19e1c8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19e1cc: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x19e1d0: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19e1d4: 0x1440fff8
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19E1B8; return;
    }
label_19e1dc:
    // 0x19e1dc: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19e1e0: 0x8c431b38
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6968)));
    // 0x19e1e4: 0xae030564
    WRITE32(ADD32(GPR_U32(ctx, 16), 1380), GPR_U32(ctx, 3));
    // 0x19e1e8: 0xac501b38
    WRITE32(ADD32(GPR_U32(ctx, 2), 6968), GPR_U32(ctx, 16));
    // 0x19e1ec: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x19e1f0: 0x8c621b3c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6972)));
    // 0x19e1f4: 0x52020001
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 3), 6972), GPR_U32(ctx, 0));
        goto label_19e1fc;
    }
label_19e1fc:
    // 0x19e1fc: 0xc06dede
    SET_GPR_U32(ctx, 31, 0x19e204);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OnSoRemove__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_19e204
// Address: 0x19e204 - 0x19e220

void entry_19e204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19e204: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x19e208: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19e20c: 0xae22b314
    WRITE32(ADD32(GPR_U32(ctx, 17), 4294947604), GPR_U32(ctx, 2));
    // 0x19e210: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19e214: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19e218: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ProjectRipgTransform__FP4RIPGfi
// Address: 0x19e220 - 0x19e2e0

void entry_19e2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e2e0) {
        switch (ctx->pc) {
            case 0x19e32c: ctx->pc = 0; goto label_19e32c;
            case 0x19e36c: ctx->pc = 0; goto label_19e36c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e2e0: 0xda010090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x19e2e4: 0xda030080
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x19e2e8: 0xda220420
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1056)));
    // 0x19e2ec: 0x4bc118ef
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19e2f0: 0x4bc310af
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19e2f4: 0xda240430
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1072)));
    // 0x19e2f8: 0xfa220420
    WRITE128(ADD32(GPR_U32(ctx, 17), 1056), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19e2fc: 0xda020090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x19e300: 0xda010080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x19e304: 0x4bc2086b
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19e308: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x19e30c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x19e310: 0x4bc1212b
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x19e314: 0xfa240430
    WRITE128(ADD32(GPR_U32(ctx, 17), 1072), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19e318: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19e31c: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19e320: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19e324: 0x1600ffe4
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19E2B8; return;
    }
label_19e32c:
    // 0x19e32c: 0xc6210554
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1364)); ctx->f[1] = *(float*)&val; }
    // 0x19e330: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x19e334: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19e338: 0x4501000c
    if ((ctx->fcr31 & 0x800000)) {
        goto label_19e36c;
    }
    // 0x19e340: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x19e344: 0x70421488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 2), GPR_VEC(ctx, 2)));
    // 0x19e348: 0x70421488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 2), GPR_VEC(ctx, 2)));
    // 0x19e34c: 0xda220420
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1056)));
    // 0x19e350: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19e354: 0xda230430
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1072)));
    // 0x19e358: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19e35c: 0x4be118e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19e360: 0xfa220420
    WRITE128(ADD32(GPR_U32(ctx, 17), 1056), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19e364: 0xfa230430
    WRITE128(ADD32(GPR_U32(ctx, 17), 1072), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19e368: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
label_19e36c:
    // 0x19e36c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x19e370: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19e374: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19e378: 0xda230430
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1072)));
    // 0x19e37c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19e380: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x19e384: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x19e388: 0xda210420
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1056)));
    // 0x19e38c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x19e390: 0x4be209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x19e394: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19e398: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19e39c: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19e3a0: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x19e3a4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19e3ac);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19e3ac
// Address: 0x19e3ac - 0x19e418

void entry_19e3ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19e3ac: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19e3b0: 0xda220430
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1072)));
    // 0x19e3b4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19e3b8: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x19e3bc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19e3c0: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19e3c4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19e3c8: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19e3cc: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19e3d0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19e3d4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19e3d8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19e3dc: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19e3e0: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19e3e4: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19e3e8: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x19e3ec: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19e3f0: 0xe62002a4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 676), *(uint32_t*)&val); }
    // 0x19e3f4: 0xe62003d0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 976), *(uint32_t*)&val); }
    // 0x19e3f8: 0xe62003cc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 972), *(uint32_t*)&val); }
    // 0x19e3fc: 0xe62002a8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 680), *(uint32_t*)&val); }
    // 0x19e400: 0xae82b314
    WRITE32(ADD32(GPR_U32(ctx, 20), 4294947604), GPR_U32(ctx, 2));
    // 0x19e404: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19e408: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19e40c: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x19e410: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateRipgBounds__FP4RIPG
// Address: 0x19e418 - 0x19e420

void FUN_0019e420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e420) {
        switch (ctx->pc) {
            case 0x19e488: ctx->pc = 0; goto label_19e488;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e420: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x19e424: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x19e428: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19e42c: 0x7fb30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 19));
    // 0x19e430: 0x26230558
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 1368));
    // 0x19e434: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x19e438: 0xe7b40060
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    // 0x19e43c: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x19e440: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x19e444: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19e448: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x19e44c: 0x46006506
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    // 0x19e450: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x19e454: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x19e458: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x19e45c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x19e460: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x19e464: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x19e468: 0x8e230558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1368)));
    // 0x19e46c: 0xafa20008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    // 0x19e470: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x19e474: 0x60802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x19e478: 0x12000019
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19E4E0; return;
    }
    // 0x19e480: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x19e484: 0x24521858
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 2), 6232));
label_19e488:
    // 0x19e488: 0xc6010018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[1] = *(float*)&val; }
    // 0x19e48c: 0xc6400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[0] = *(float*)&val; }
    // 0x19e490: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19e494: 0x0
    // NOP
    // 0x19e498: 0x4501000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19E4C8; return;
    }
    // 0x19e4a0: 0xc067b08
    SET_GPR_U32(ctx, 31, 0x19e4a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddRipRef__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_19e4a8
// Address: 0x19e4a8 - 0x19e4bc

void entry_19e4a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19e4a8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19e4ac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19e4b0: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x19e4b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19e4bc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19e4bc
// Address: 0x19e4bc - 0x19e4c4

void entry_19e4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19e4bc: 0xc067b0c
    SET_GPR_U32(ctx, 31, 0x19e4c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ReleaseRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_19e4c4
// Address: 0x19e4c4 - 0x19e500

void entry_19e4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e4c4) {
        switch (ctx->pc) {
            case 0x19e4c8: ctx->pc = 0; goto label_19e4c8;
            case 0x19e4e0: ctx->pc = 0; goto label_19e4e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e4c4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_19e4c8:
    // 0x19e4c8: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x19e4cc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19e4d0: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x19e4d4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19e4d8: 0x1600ffeb
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19E488; return;
    }
label_19e4e0:
    // 0x19e4e0: 0xde2202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 712)));
    // 0x19e4e4: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x19e4e8: 0x31df8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 23);
    // 0x19e4ec: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19e4f0: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x19E50C; return;
    }
    // 0x19e4f8: 0xc0549c8
    SET_GPR_U32(ctx, 31, 0x19e500);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1368));
    FIsDlEmpty__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_19e500
// Address: 0x19e500 - 0x19e518

void entry_19e500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e500) {
        switch (ctx->pc) {
            case 0x19e50c: ctx->pc = 0; goto label_19e50c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e500: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19E520; return;
    }
    // 0x19e508: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_19e50c:
    // 0x19e50c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x19e510: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19e518);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19e518
// Address: 0x19e518 - 0x19e528

void entry_19e518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e518) {
        switch (ctx->pc) {
            case 0x19e520: ctx->pc = 0; goto label_19e520;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e518: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_19e528(rdram, ctx, runtime); return;
    }
label_19e520:
    // 0x19e520: 0xc067956
    SET_GPR_U32(ctx, 31, 0x19e528);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    BounceRipgRips__FP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_19e528
// Address: 0x19e528 - 0x19e530

void entry_19e528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19e528: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x19e530);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_19e530
// Address: 0x19e530 - 0x19e558

void entry_19e530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19e530: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x19e534: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19e538: 0xae62b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 2));
    // 0x19e53c: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19e540: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19e544: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19e548: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19e54c: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x19e550: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BounceRipgRips__FP4RIPG
// Address: 0x19e558 - 0x19e68c

void entry_19e68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19e68c: 0x8e4203f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1008)));
    // 0x19e690: 0x18400010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x19E6D4; return;
    }
    // 0x19e698: 0x8e4203f4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1012)));
    // 0x19e69c: 0xc063596
    SET_GPR_U32(ctx, 31, 0x19e6a4);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_19e6a4
// Address: 0x19e6a4 - 0x19e6bc

void entry_19e6a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19e6a4: 0x8e4403f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1016)));
    // 0x19e6a8: 0x27c50140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 320));
    // 0x19e6ac: 0xc7cc03d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 976)); ctx->f[12] = *(float*)&val; }
    // 0x19e6b0: 0x27a601e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 480));
    // 0x19e6b4: 0xc04f90c
    SET_GPR_U32(ctx, 31, 0x19e6bc);
    WRITE32(ADD32(GPR_U32(ctx, 29), 480), GPR_U32(ctx, 2));
    PruneBsp__FP3BSPP6VECTORfPP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_19e6bc
// Address: 0x19e6bc - 0x19e73c

void entry_19e6bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e6bc) {
        switch (ctx->pc) {
            case 0x19e6d4: ctx->pc = 0; goto label_19e6d4;
            case 0x19e6d8: ctx->pc = 0; goto label_19e6d8;
            case 0x19e700: ctx->pc = 0; goto label_19e700;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e6bc: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x19e6c0: 0x14430039
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 480)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x19E7A8; return;
    }
    // 0x19e6c8: 0x2442fff4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967284));
    // 0x19e6cc: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 29), 480), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19e6d8;
    }
label_19e6d4:
    // 0x19e6d4: 0xafa001e0
    WRITE32(ADD32(GPR_U32(ctx, 29), 480), GPR_U32(ctx, 0));
label_19e6d8:
    // 0x19e6d8: 0x8fa40014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x19e6dc: 0x8fa30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x19e6e0: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19e6e4: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19e6e8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19e6ec: 0x1200002e
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19E7A8; return;
    }
    // 0x19e6f4: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x19e6f8: 0x24160070
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 112));
    // 0x19e6fc: 0x0
    // NOP
label_19e700:
    // 0x19e700: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x19e704: 0xc6010018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[1] = *(float*)&val; }
    // 0x19e708: 0x24631858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x19e70c: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x19e710: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19e714: 0x0
    // NOP
    // 0x19e718: 0x4501001d
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19E790; return;
    }
    // 0x19e720: 0x8fa501e0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x19e724: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19e728: 0x26060090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 144));
    // 0x19e72c: 0x26070080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 128));
    // 0x19e730: 0x24080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4));
    // 0x19e734: 0xc050724
    SET_GPR_U32(ctx, 31, 0x19e73c);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 32));
    ClsgClipEdgeToObjectPruned__FP2SOP3BSPP6VECTORT2iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_19e73c
// Address: 0x19e73c - 0x19e784

void entry_19e73c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e73c) {
        switch (ctx->pc) {
            case 0x19e748: ctx->pc = 0; goto label_19e748;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e73c: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19e740: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19e744: 0x27b40020
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 32));
label_19e748:
    // 0x19e748: 0x233102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 19)));
    // 0x19e74c: 0x1040000f
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19E78C; return;
    }
    // 0x19e754: 0x543021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x19e758: 0xc4c00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 64)); ctx->f[0] = *(float*)&val; }
    // 0x19e75c: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19e760: 0x0
    // NOP
    // 0x19e764: 0x4503fff8
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        goto label_19e748;
    }
    // 0x19e76c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19e770: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19e774: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19e778: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x19e77c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19e784);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 32));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19e784
// Address: 0x19e784 - 0x19e7b0

void entry_19e784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e784) {
        switch (ctx->pc) {
            case 0x19e78c: ctx->pc = 0; goto label_19e78c;
            case 0x19e790: ctx->pc = 0; goto label_19e790;
            case 0x19e7a8: ctx->pc = 0; goto label_19e7a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e784: 0x5040fff0
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
        ctx->pc = 0x19E748; return;
    }
label_19e78c:
    // 0x19e78c: 0x8fa40014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 20)));
label_19e790:
    // 0x19e790: 0x8fa30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x19e794: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19e798: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19e79c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19e7a0: 0x1600ffd7
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19E700; return;
    }
label_19e7a8:
    // 0x19e7a8: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x19e7b0);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_19e7b0
// Address: 0x19e7b0 - 0x19e7f8

void entry_19e7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e7b0) {
        switch (ctx->pc) {
            case 0x19e7bc: ctx->pc = 0; goto label_19e7bc;
            case 0x19e7d8: ctx->pc = 0; goto label_19e7d8;
            case 0x19e7e4: ctx->pc = 0; goto label_19e7e4;
            case 0x19e7f0: ctx->pc = 0; goto label_19e7f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e7b0: 0x8fa2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x19e7b4: 0x3c030028
    SET_GPR_U32(ctx, 3, ((uint32_t)40 << 16));
    // 0x19e7b8: 0xac62b314
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294947604), GPR_U32(ctx, 2));
label_19e7bc:
    // 0x19e7bc: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x19e7c0: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x19e7c4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x19e7c8: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x19e7cc: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19e7d0: 0x1640ff95
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19E628; return;
    }
label_19e7d8:
    // 0x19e7d8: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x19e7dc: 0x3c050028
    SET_GPR_U32(ctx, 5, ((uint32_t)40 << 16));
    // 0x19e7e0: 0xaca2b314
    WRITE32(ADD32(GPR_U32(ctx, 5), 4294947604), GPR_U32(ctx, 2));
label_19e7e4:
    // 0x19e7e4: 0x8ef70004
    SET_GPR_U32(ctx, 23, READ32(ADD32(GPR_U32(ctx, 23), 4)));
    // 0x19e7e8: 0x56e0ff73
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 23), 12)));
        ctx->pc = 0x19E5B8; return;
    }
label_19e7f0:
    // 0x19e7f0: 0xc0549c8
    SET_GPR_U32(ctx, 31, 0x19e7f8);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 488)));
    FIsDlEmpty__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_19e7f8
// Address: 0x19e7f8 - 0x19e810

void entry_19e7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19e7f8: 0x10400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 640)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19E814; return;
    }
    // 0x19e800: 0x8fc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x19e804: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x19e808: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19e810);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19e810
// Address: 0x19e810 - 0x19e848

void entry_19e810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e810) {
        switch (ctx->pc) {
            case 0x19e814: ctx->pc = 0; goto label_19e814;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e810: 0x7bbf0280
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 640)));
label_19e814:
    // 0x19e814: 0x7bbe0270
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 624)));
    // 0x19e818: 0x7bb70260
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 608)));
    // 0x19e81c: 0x7bb60250
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 592)));
    // 0x19e820: 0x7bb50240
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x19e824: 0x7bb40230
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x19e828: 0x7bb30220
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 544)));
    // 0x19e82c: 0x7bb20210
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x19e830: 0x7bb10200
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x19e834: 0x7bb001f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x19e838: 0xc7b40290
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 656)); ctx->f[20] = *(float*)&val; }
    // 0x19e83c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 672));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19e844: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19e848; return;
}


// Function: RenderRipgSelf__FP4RIPGP2CMP2RO
// Address: 0x19e848 - 0x19e8d0

void entry_19e8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19e8d0) {
        switch (ctx->pc) {
            case 0x19e8d4: ctx->pc = 0; goto label_19e8d4;
            case 0x19e8e8: ctx->pc = 0; goto label_19e8e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19e8d0: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_19e8d4:
    // 0x19e8d4: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x19e8d8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19e8dc: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x19e8e0: 0x1480fff1
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19E8A8; return;
    }
label_19e8e8:
    // 0x19e8e8: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x19e8ec: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19e8f0: 0xae42b314
    WRITE32(ADD32(GPR_U32(ctx, 18), 4294947604), GPR_U32(ctx, 2));
    // 0x19e8f4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19e8f8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19e8fc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19e900: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PvtripFromRipt__F4RIPT
// Address: 0x19e908 - 0x19ea78

void entry_19eaa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19eaa8) {
        switch (ctx->pc) {
            case 0x19eabc: ctx->pc = 0; goto label_19eabc;
            case 0x19eac0: ctx->pc = 0; goto label_19eac0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19eaa8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19eaac: 0x56200004
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_19eac0;
    }
    // 0x19eab4: 0x10000016
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19EB10; return;
    }
label_19eabc:
    // 0x19eabc: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_19eac0:
    // 0x19eac0: 0xc06d7a8
    SET_GPR_U32(ctx, 31, 0x19eac8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6956));
    PvAllocSlotheapUnsafe__FP8SLOTHEAP(rdram, ctx, runtime); return;
}


// Function: entry_19eac8
// Address: 0x19eac8 - 0x19eae4

void entry_19eac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19eac8: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19eacc: 0x1200000f
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        entry_19eb0c(rdram, ctx, runtime); return;
    }
    // 0x19ead4: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x19ead8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19eadc: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x19eae4);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 6956)));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_19eae4
// Address: 0x19eae4 - 0x19eaec

void entry_19eae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19eae4: 0xc067a42
    SET_GPR_U32(ctx, 31, 0x19eaec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PvtripFromRipt__F4RIPT(rdram, ctx, runtime); return;
}


// Function: entry_19eaec
// Address: 0x19eaec - 0x19eb04

void entry_19eaec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19eaec: 0xae120004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 18));
    // 0x19eaf0: 0x26240558
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 1368));
    // 0x19eaf4: 0xae11000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 17));
    // 0x19eaf8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19eafc: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x19eb04);
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_19eb04
// Address: 0x19eb04 - 0x19eb0c

void entry_19eb04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19eb04: 0xc067b08
    SET_GPR_U32(ctx, 31, 0x19eb0c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddRipRef__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_19eb0c
// Address: 0x19eb0c - 0x19eb28

void entry_19eb0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19eb0c) {
        switch (ctx->pc) {
            case 0x19eb10: ctx->pc = 0; goto label_19eb10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19eb0c: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_19eb10:
    // 0x19eb10: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19eb14: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19eb18: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19eb1c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19eb20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitRip__FP3RIPP6VECTORfP2SO
// Address: 0x19eb28 - 0x19ebe8

void entry_19ec08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ec08: 0xc067b0c
    SET_GPR_U32(ctx, 31, 0x19ec10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ReleaseRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_19ec10
// Address: 0x19ec10 - 0x19ec20

void entry_19ec10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ec10: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19ec14: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19ec18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddRipRef__FP3RIP
// Address: 0x19ec20 - 0x19ec30

void entry_19ec70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19ec70) {
        switch (ctx->pc) {
            case 0x19ec74: ctx->pc = 0; goto label_19ec74;
            case 0x19ec88: ctx->pc = 0; goto label_19ec88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19ec70: 0x8e320118
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 280)));
label_19ec74:
    // 0x19ec74: 0x1240000f
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_19ecb4(rdram, ctx, runtime); return;
    }
    // 0x19ec7c: 0xae200118
    WRITE32(ADD32(GPR_U32(ctx, 17), 280), GPR_U32(ctx, 0));
    // 0x19ec80: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19ec84: 0x0
    // NOP
label_19ec88:
    // 0x19ec88: 0x24050010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16));
    // 0x19ec8c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x19ec90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19ec98);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19ec98
// Address: 0x19ec98 - 0x19ecb4

void entry_19ec98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ec98: 0x8e100010
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x19ec9c: 0x5600fffa
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x19EC88; return;
    }
    // 0x19eca4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19eca8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19ecac: 0xc076f06
    SET_GPR_U32(ctx, 31, 0x19ecb4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    FreeSwMqList__FP2SWP2MQ(rdram, ctx, runtime); return;
}


// Function: entry_19ecb4
// Address: 0x19ecb4 - 0x19ecc8

void entry_19ecb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ecb4: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x19ecb8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19ecbc: 0x8c440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x19ecc0: 0xc06d7ca
    SET_GPR_U32(ctx, 31, 0x19ecc8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6956));
    FreeSlotheapPv__FP8SLOTHEAPPv(rdram, ctx, runtime); return;
}


// Function: entry_19ecc8
// Address: 0x19ecc8 - 0x19ece0

void entry_19ecc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ecc8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19eccc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19ecd0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19ecd4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19ecd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TouchRip__FP3RIPi
// Address: 0x19ece0 - 0x19ecf4

void entry_19ecf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ecf4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19ecf8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ForceRipFade__FP3RIPf
// Address: 0x19ed00 - 0x19ed58

void entry_19ee38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ee38: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19ee3c: 0xda0300a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x19ee40: 0x8c42b544
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4294948164)));
    // 0x19ee44: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19ee48: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19ee4c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19ee50: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19ee54: 0x4be308ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19ee58: 0xc44cb540
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948160)); ctx->f[12] = *(float*)&val; }
    // 0x19ee5c: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x19ee60: 0x4be410c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19ee64: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19ee68: 0xfba40010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19ee6c: 0x44026000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[12]);
    // 0x19ee70: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19ee74: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x19ee78: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19ee7c: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x19ee80: 0xfa0100c0
    WRITE128(ADD32(GPR_U32(ctx, 16), 192), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19ee84: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19ee88: 0xc067b40
    SET_GPR_U32(ctx, 31, 0x19ee90);
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    ForceRipFade__FP3RIPf(rdram, ctx, runtime); return;
}


// Function: entry_19ee90
// Address: 0x19ee90 - 0x19eea8

void entry_19ee90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ee90: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19ee94: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19ee98: 0xc44cb548
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948168)); ctx->f[12] = *(float*)&val; }
    // 0x19ee9c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19eea0: 0xc056042
    SET_GPR_U32(ctx, 31, 0x19eea8);
    ctx->f[12] = FPU_MUL_S(ctx->f[20], ctx->f[12]);
    StockSplashSmall__FP6VECTORfP2SO(rdram, ctx, runtime); return;
}


// Function: entry_19eea8
// Address: 0x19eea8 - 0x19f030

void entry_19eea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19eea8) {
        switch (ctx->pc) {
            case 0x19eeb0: ctx->pc = 0; goto label_19eeb0;
            case 0x19ef68: ctx->pc = 0; goto label_19ef68;
            case 0x19ef98: ctx->pc = 0; goto label_19ef98;
            case 0x19efa8: ctx->pc = 0; goto label_19efa8;
            case 0x19efc8: ctx->pc = 0; goto label_19efc8;
            case 0x19eff8: ctx->pc = 0; goto label_19eff8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19eea8: 0x10000129
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19F350; return;
    }
label_19eeb0:
    // 0x19eeb0: 0x8e060020
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x19eeb4: 0xd8e80000
    ctx->vu0_vf[8] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x19eeb8: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x19eebc: 0xfba80050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x19eec0: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x19eec4: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x19eec8: 0x1040003f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 80));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19efc8;
    }
    // 0x19eed0: 0xda030050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x19eed4: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x19eed8: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x19eedc: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x19eee0: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19eee4: 0x4be819aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19eee8: 0x4be001d3
    // Unhandled VU0 Special1 function: 0x13
    // 0x19eeec: 0x4be8116a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19eef0: 0x4be8092a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19eef4: 0x4b06303d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x19eef8: 0x4b063a4a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19eefc: 0x4a85283c
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x19ef00: 0x4a853a4a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19ef04: 0x4a44203c
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x19ef08: 0x4a443a49
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19ef0c: 0x24828d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4294937904));
    // 0x19ef10: 0x4be14b3c
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x19ef14: 0x80f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x19ef18: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x19ef1c: 0x46002d47
    ctx->f[21] = FPU_NEG_S(ctx->f[5]);
    // 0x19ef20: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19ef24: 0x3c170025
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    // 0x19ef28: 0xc4a1c9b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4294953392)); ctx->f[1] = *(float*)&val; }
    // 0x19ef2c: 0x27b30010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 16));
    // 0x19ef30: 0x27b40020
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 32));
    // 0x19ef34: 0x27b50040
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 64));
    // 0x19ef38: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19ef3c: 0x8cc20384
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 900)));
    // 0x19ef40: 0x8cc40388
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 904)));
    // 0x19ef44: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x19ef48: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x19ef4c: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x19ef50: 0x8cc30388
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 904)));
    // 0x19ef54: 0x64102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x19ef58: 0x10400013
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 68));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19efa8;
    }
    // 0x19ef60: 0x4be40b3c
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x19ef64: 0xd8630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
label_19ef68:
    // 0x19ef68: 0x4bc3206a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x19ef6c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19ef70: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19ef74: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19ef78: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19ef7c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x19ef80: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19ef84: 0x0
    // NOP
    // 0x19ef88: 0x45000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19ef98;
    }
    // 0x19ef90: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19ef94: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
label_19ef98:
    // 0x19ef98: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x19ef9c: 0x64102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x19efa0: 0x5440fff1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
        goto label_19ef68;
    }
label_19efa8:
    // 0x19efa8: 0xd8e40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 7), 32)));
    // 0x19efac: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19efb0: 0xda020050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x19efb4: 0xd8e10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 7), 16)));
    // 0x19efb8: 0x4bc311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x19efbc: 0x4bc308bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19efc0: 0x1000000d
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19eff8;
    }
label_19efc8:
    // 0x19efc8: 0x4600a007
    ctx->f[0] = FPU_NEG_S(ctx->f[20]);
    // 0x19efcc: 0x3c1e0025
    SET_GPR_U32(ctx, 30, ((uint32_t)37 << 16));
    // 0x19efd0: 0x46002d47
    ctx->f[21] = FPU_NEG_S(ctx->f[5]);
    // 0x19efd4: 0x3c170025
    SET_GPR_U32(ctx, 23, ((uint32_t)37 << 16));
    // 0x19efd8: 0x27b30010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 16));
    // 0x19efdc: 0x27b40020
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 32));
    // 0x19efe0: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x19efe4: 0x27b50040
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 64));
    // 0x19efe8: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x19efec: 0x27b60044
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 68));
    // 0x19eff0: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19eff4: 0x4be14298
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
label_19eff8:
    // 0x19eff8: 0x4bc852fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[8] = READ32(addr); }
    // 0x19effc: 0x4bca406e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[10]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f000: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f004: 0xfba800a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x19f008: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f00c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19f010: 0xfbaa00b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[10]));
    // 0x19f014: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19f018: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19f01c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19f020: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19f024: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19f028: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x19f030);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_19f030
// Address: 0x19f030 - 0x19f260

void entry_19f030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f030) {
        switch (ctx->pc) {
            case 0x19f164: ctx->pc = 0; goto label_19f164;
            case 0x19f170: ctx->pc = 0; goto label_19f170;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f030: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x19f034: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19f038: 0xda030100
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x19f03c: 0x46140528
    ctx->f[20] = std::max(ctx->f[0], ctx->f[20]);
    // 0x19f040: 0xdbaa00b0
    ctx->vu0_vf[10] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x19f044: 0x4614a0c2
    ctx->f[3] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    // 0x19f048: 0x3c014020
    SET_GPR_U32(ctx, 1, ((uint32_t)16416 << 16));
    // 0x19f04c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19f050: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19f054: 0x4bca1afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[10] = READ32(addr); }
    // 0x19f058: 0x4bc350ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f05c: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19f060: 0xda0200a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x19f064: 0x4bca0afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[10] = READ32(addr); }
    // 0x19f068: 0x4bc1512e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f06c: 0x4a24212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x19f070: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x19f074: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19f078: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19f07c: 0xdba800a0
    ctx->vu0_vf[8] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x19f080: 0x4be1126c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19f084: 0x4bc8486a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); }
    // 0x19f088: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19f08c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f090: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f094: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x19f098: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x19f09c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f0a0: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x19f0a4: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x19f0a8: 0x46161081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[22]);
    // 0x19f0ac: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x19f0b0: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19f0b4: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x19f0b8: 0x26e28d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 23), 4294937856));
    // 0x19f0bc: 0x4be802bc
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x19f0c0: 0x4be22108
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f0c4: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x19f0c8: 0x4bc8206a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x19f0cc: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19f0d0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f0d4: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f0d8: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19f0dc: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f0e0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x19f0e4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x19f0e8: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x19f0ec: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x19f0f0: 0x4be6433c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x19f0f4: 0x46000d43
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[21] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[21] = ctx->f[1] / ctx->f[0];
    // 0x19f0f8: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x19f0fc: 0x4403a800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[21]);
    // 0x19f100: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x19f104: 0x4be902bc
    ctx->vu0_i = (float)ctx->vi[9];
    // 0x19f108: 0x4be22108
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f10c: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19f110: 0x4bc8206a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x19f114: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19f118: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f11c: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f120: 0xfba50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x19f124: 0x4be14058
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x19f128: 0x4be121ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x19f12c: 0x4bc738aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[7]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x19f130: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19f134: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19f138: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f13c: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19f140: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19f144: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19f148: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f14c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x19f150: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19f154: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19f164;
    }
    // 0x19f15c: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19f170;
    }
label_19f164:
    // 0x19f164: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x19f168: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19f16c: 0x4be0385c
    ctx->vu0_vf[7] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_19f170:
    // 0x19f170: 0x4614a082
    ctx->f[2] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    // 0x19f174: 0x3c014020
    SET_GPR_U32(ctx, 1, ((uint32_t)16416 << 16));
    // 0x19f178: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19f17c: 0x4be602bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x19f180: 0x4be50948
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f184: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x19f188: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19f18c: 0x4bc552fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[5] = READ32(addr); }
    // 0x19f190: 0x4bca286e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[10]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f194: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f198: 0xfba50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x19f19c: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x19f1a0: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f1a4: 0x4bc8486a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); }
    // 0x19f1a8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19f1ac: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f1b0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f1b4: 0x46160841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[22]);
    // 0x19f1b8: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f1bc: 0x27c48d30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 4294937904));
    // 0x19f1c0: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19f1c4: 0x4483a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 3);
    // 0x19f1c8: 0x4bca0afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[10] = READ32(addr); }
    // 0x19f1cc: 0x4bc150ae
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f1d0: 0x4a2210ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19f1d4: 0x4601a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x19f1d8: 0xfba800a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x19f1dc: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19f1e0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x19f1e4: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x19f1e8: 0x48a23000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19f1ec: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x19f1f0: 0x4be502bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x19f1f4: 0x4be61088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f1f8: 0xfba60010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x19f1fc: 0x4bc8106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19f200: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19f204: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f208: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f20c: 0xfba60090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x19f210: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f214: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x19f218: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x19f21c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19f220: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x19f224: 0x4600a503
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[20] = ctx->f[20] / ctx->f[0];
    // 0x19f228: 0x4403a000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[20]);
    // 0x19f22c: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x19f230: 0x4be902bc
    ctx->vu0_i = (float)ctx->vi[9];
    // 0x19f234: 0x4be31088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f238: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19f23c: 0x4bc8106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19f240: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19f244: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f248: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f24c: 0xfba70010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x19f250: 0x4be14058
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x19f254: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19f258: 0xc0618c8
    SET_GPR_U32(ctx, 31, 0x19f260);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime); return;
}


// Function: entry_19f260
// Address: 0x19f260 - 0x19f300

void entry_19f260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19f260: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x19f264: 0xdba50080
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19f268: 0x4600b041
    ctx->f[1] = FPU_SUB_S(ctx->f[22], ctx->f[0]);
    // 0x19f26c: 0xdba70050
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19f270: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x19f274: 0xda0300a0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x19f278: 0xda040100
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x19f27c: 0x46150842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
    // 0x19f280: 0xdba90060
    ctx->vu0_vf[9] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19f284: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x19f288: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19f28c: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x19f290: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19f294: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x19f298: 0x4be139bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x19f29c: 0x4be22948
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f2a0: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f2a4: 0x4be518e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19f2a8: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19f2ac: 0xdba50070
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19f2b0: 0xfa0300a0
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19f2b4: 0x4be149bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x19f2b8: 0x4be22848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f2bc: 0xdba60090
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x19f2c0: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x19f2c4: 0x4be60908
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f2c8: 0xfba60030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x19f2cc: 0xc441b54c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948172)); ctx->f[1] = *(float*)&val; }
    // 0x19f2d0: 0xc60000a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 168)); ctx->f[0] = *(float*)&val; }
    // 0x19f2d4: 0xfa040100
    WRITE128(ADD32(GPR_U32(ctx, 16), 256), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19f2d8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19f2dc: 0x0
    // NOP
    // 0x19f2e0: 0x45000008
    ctx->vu0_vf[8] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19F304; return;
    }
    // 0x19f2e8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19f2ec: 0xe60100a8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 168), *(uint32_t*)&val); }
    // 0x19f2f0: 0xc44cb550
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294948176)); ctx->f[12] = *(float*)&val; }
    // 0x19f2f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19f2f8: 0xc067b40
    SET_GPR_U32(ctx, 31, 0x19f300);
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[8]));
    ForceRipFade__FP3RIPf(rdram, ctx, runtime); return;
}


// Function: entry_19f300
// Address: 0x19f300 - 0x19f390

void entry_19f300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f300) {
        switch (ctx->pc) {
            case 0x19f304: ctx->pc = 0; goto label_19f304;
            case 0x19f350: ctx->pc = 0; goto label_19f350;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f300: 0xdba800a0
    ctx->vu0_vf[8] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_19f304:
    // 0x19f304: 0xda020080
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x19f308: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19f30c: 0xda410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x19f310: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f314: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x19f318: 0x4bc8086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f31c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19f320: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f324: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f328: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f32c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x19f330: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x19f334: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x19f338: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x19f33c: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x19f340: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x19f344: 0x4be14088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f348: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f34c: 0xfa020080
    WRITE128(ADD32(GPR_U32(ctx, 16), 128), _mm_castps_si128(ctx->vu0_vf[2]));
label_19f350:
    // 0x19f350: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x19f354: 0x7bbe0140
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x19f358: 0x7bb70130
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x19f35c: 0x7bb60120
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x19f360: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x19f364: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x19f368: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x19f36c: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x19f370: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x19f374: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x19f378: 0xc7b60170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[22] = *(float*)&val; }
    // 0x19f37c: 0xc7b50168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 360)); ctx->f[21] = *(float*)&val; }
    // 0x19f380: 0xc7b40160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[20] = *(float*)&val; }
    // 0x19f384: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19f38c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19f390; return;
}


// Function: ProjectRipTransform__FP3RIPf
// Address: 0x19f390 - 0x19f3b0

void entry_19f3b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19f3b0: 0x54400042
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 128)));
        ctx->pc = 0x19F4BC; return;
    }
    // 0x19f3b8: 0xc6000110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 272)); ctx->f[0] = *(float*)&val; }
    // 0x19f3bc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19f3c0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x19f3c4: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x19f3c8: 0xda010100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x19f3cc: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x19f3d0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x19f3d4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19f3d8: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x19f3dc: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x19f3e0: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19f3e4: 0x4be20918
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f3e8: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19f3ec: 0x4bc4206a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x19f3f0: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19f3f4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f3f8: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f3fc: 0xfa040100
    WRITE128(ADD32(GPR_U32(ctx, 16), 256), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19f400: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f404: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19f408: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19f40c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f410: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x19f414: 0x460c0834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19f418: 0x0
    // NOP
    // 0x19f41c: 0x45000026
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19F4B8; return;
    }
    // 0x19f424: 0x460c1003
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[0] = ctx->f[2] / ctx->f[12];
    // 0x19f428: 0x46146302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    // 0x19f42c: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x19f430: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x19f434: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19f438: 0x4be12098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x19f43c: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f440: 0xc062214
    SET_GPR_U32(ctx, 31, 0x19f448);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_19f448
// Address: 0x19f448 - 0x19f4c8

void entry_19f448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f448) {
        switch (ctx->pc) {
            case 0x19f4b8: ctx->pc = 0; goto label_19f4b8;
            case 0x19f4bc: ctx->pc = 0; goto label_19f4bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f448: 0xda040050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x19f44c: 0x26020050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 80));
    // 0x19f450: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19f454: 0xdba60020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19f458: 0xdba50030
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19f45c: 0x4bc411bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x19f460: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x19f464: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f468: 0xfba40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19f46c: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19f470: 0xd8430010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x19f474: 0x4bc311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x19f478: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x19f47c: 0x4bc328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f480: 0xfba30090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19f484: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19f488: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x19f48c: 0x4bc111bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x19f490: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19f494: 0x4bc1288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f498: 0xfa040050
    WRITE128(ADD32(GPR_U32(ctx, 16), 80), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19f49c: 0xfa030060
    WRITE128(ADD32(GPR_U32(ctx, 16), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19f4a0: 0xfa020070
    WRITE128(ADD32(GPR_U32(ctx, 16), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19f4a4: 0xfba200d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19f4a8: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19f4ac: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19f4b0: 0xfba30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19f4b4: 0xfba20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
label_19f4b8:
    // 0x19f4b8: 0x7a020080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 128)));
label_19f4bc:
    // 0x19f4bc: 0x260400a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 160));
    // 0x19f4c0: 0xc048f70
    SET_GPR_U32(ctx, 31, 0x19f4c8);
    WRITE128(ADD32(GPR_U32(ctx, 16), 144), GPR_VEC(ctx, 2));
    FIsZeroV__FP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_19f4c8
// Address: 0x19f4c8 - 0x19f4d8

void entry_19f4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19f4c8: 0x10400006
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 176));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19F4E4; return;
    }
    // 0x19f4d0: 0xc048f92
    SET_GPR_U32(ctx, 31, 0x19f4d8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 192));
    FIsZeroDv__FP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_19f4d8
// Address: 0x19f4d8 - 0x19f4f0

void entry_19f4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f4d8) {
        switch (ctx->pc) {
            case 0x19f4e4: ctx->pc = 0; goto label_19f4e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f4d8: 0x1440001c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19F54C; return;
    }
    // 0x19f4e0: 0x260400b0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 176));
label_19f4e4:
    // 0x19f4e4: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x19f4e8: 0xc056120
    SET_GPR_U32(ctx, 31, 0x19f4f0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CalculateEmitdvMatrix__FP6EMITDVfP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_19f4f0
// Address: 0x19f4f0 - 0x19f560

void entry_19f4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f4f0) {
        switch (ctx->pc) {
            case 0x19f54c: ctx->pc = 0; goto label_19f54c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f4f0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19f4f4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19f4f8: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x19f4fc: 0x48a24000
    ctx->vu0_vf[8] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19f500: 0xda0600a0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x19f504: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x19f508: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19f50c: 0x48a23800
    ctx->vu0_vf[7] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19f510: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19f514: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19f518: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19f51c: 0xda010080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x19f520: 0x4bc619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x19f524: 0x4bc628bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x19f528: 0x4bc620be
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[6] = READ32(addr); }
    // 0x19f52c: 0x4bc710c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f530: 0xfba70040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x19f534: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x19f538: 0x4be81848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19f53c: 0xfa010080
    WRITE128(ADD32(GPR_U32(ctx, 16), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19f540: 0xfa0300a0
    WRITE128(ADD32(GPR_U32(ctx, 16), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19f544: 0xfba80040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x19f548: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
label_19f54c:
    // 0x19f54c: 0x7bb000e0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x19f550: 0xc7b40100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[20] = *(float*)&val; }
    // 0x19f554: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19f55c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19f560; return;
}


// Function: UpdateRip__FP3RIPf
// Address: 0x19f560 - 0x19f5a4

void entry_19f5a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f5a4) {
        switch (ctx->pc) {
            case 0x19f5ac: ctx->pc = 0; goto label_19f5ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f5a4: 0x10000019
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19F60C; return;
    }
label_19f5ac:
    // 0x19f5ac: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x19f5b0: 0x8c620550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1360)));
    // 0x19f5b4: 0x10520015
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x19F60C; return;
    }
    // 0x19f5bc: 0x8e040024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x19f5c0: 0x50800013
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        ctx->pc = 0x19F610; return;
    }
    // 0x19f5c8: 0x8c8203f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1016)));
    // 0x19f5cc: 0x50400010
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        ctx->pc = 0x19F610; return;
    }
    // 0x19f5d4: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x19f5dc);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_19f5dc
// Address: 0x19f5dc - 0x19f5f0

void entry_19f5dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19f5dc: 0x10400005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 128));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19F5F4; return;
    }
    // 0x19f5e4: 0x8e020024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x19f5e8: 0xc04f996
    SET_GPR_U32(ctx, 31, 0x19f5f0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 1016)));
    PbspPointInBspQuick__FP6VECTORP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_19f5f0
// Address: 0x19f5f0 - 0x19f608

void entry_19f5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f5f0) {
        switch (ctx->pc) {
            case 0x19f5f4: ctx->pc = 0; goto label_19f5f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f5f0: 0x242880b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 18));
label_19f5f4:
    // 0x19f5f4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19f5f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19f5fc: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x19f600: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19f608);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19f608
// Address: 0x19f608 - 0x19f620

void entry_19f608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f608) {
        switch (ctx->pc) {
            case 0x19f60c: ctx->pc = 0; goto label_19f60c;
            case 0x19f610: ctx->pc = 0; goto label_19f610;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f608: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_19f60c:
    // 0x19f60c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_19f610:
    // 0x19f610: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19f614: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19f618: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FRenderRipPosMat__FP3RIPP2CMP6VECTORP7MATRIX3
// Address: 0x19f620 - 0x19f770

void entry_19f770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f770) {
        switch (ctx->pc) {
            case 0x19f7a0: ctx->pc = 0; goto label_19f7a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f770: 0x1040002e
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19F82C; return;
    }
    // 0x19f778: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x19f77c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x19f780: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19f784: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19f788: 0x45000005
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19f7a0;
    }
    // 0x19f790: 0x4600a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19f794: 0x0
    // NOP
    // 0x19f798: 0x45010024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19F82C; return;
    }
label_19f7a0:
    // 0x19f7a0: 0x4403a800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[21]);
    // 0x19f7a4: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x19f7a8: 0x70631c88
    SET_GPR_VEC(ctx, 3, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x19f7ac: 0x70631488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 3)));
    // 0x19f7b0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19f7b4: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x19f7b8: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19f7bc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x19f7c0: 0xc062304
    SET_GPR_U32(ctx, 31, 0x19f7c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRotScale__FP6VECTORP7MATRIX3T0P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_19f7c8
// Address: 0x19f7c8 - 0x19f7f8

void entry_19f7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19f7c8: 0xc7a00060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[0] = *(float*)&val; }
    // 0x19f7cc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19f7d0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19f7d4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19f7d8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19f7dc: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x19f7e0: 0xe7a10054
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 84), *(uint32_t*)&val); }
    // 0x19f7e4: 0xe7a00050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x19f7e8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19f7ec: 0x8c4300a8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 168)));
    // 0x19f7f0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x19f7f8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_19f7f8
// Address: 0x19f7f8 - 0x19f824

void entry_19f7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19f7f8: 0xc614028c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 652)); ctx->f[20] = *(float*)&val; }
    // 0x19f7fc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x19f800: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19f804: 0x0
    // NOP
    // 0x19f808: 0x45000007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x19F828; return;
    }
    // 0x19f810: 0x4615a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[21]);
    // 0x19f814: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19f818: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19f81c: 0xc0496fc
    SET_GPR_U32(ctx, 31, 0x19f824);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 652), *(uint32_t*)&val); }
    RenderFastShadow__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_19f824
// Address: 0x19f824 - 0x19f858

void entry_19f824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f824) {
        switch (ctx->pc) {
            case 0x19f828: ctx->pc = 0; goto label_19f828;
            case 0x19f82c: ctx->pc = 0; goto label_19f82c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f824: 0xe614028c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 652), *(uint32_t*)&val); }
label_19f828:
    // 0x19f828: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_19f82c:
    // 0x19f82c: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x19f830: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x19f834: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x19f838: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x19f83c: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x19f840: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19f844: 0xc7b500d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[21] = *(float*)&val; }
    // 0x19f848: 0xc7b400d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    // 0x19f84c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19f854: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19f858; return;
}


// Function: RenderRip__FP3RIPP2CM
// Address: 0x19f858 - 0x19f8a0

void entry_19f8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f8a0) {
        switch (ctx->pc) {
            case 0x19f8ac: ctx->pc = 0; goto label_19f8ac;
            case 0x19f8b4: ctx->pc = 0; goto label_19f8b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f8a0: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19f8a4: 0x10000003
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19f8b4;
    }
label_19f8ac:
    // 0x19f8ac: 0x26260080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 128));
    // 0x19f8b0: 0x26270050
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 80));
label_19f8b4:
    // 0x19f8b4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x19f8b8: 0xc067d88
    SET_GPR_U32(ctx, 31, 0x19f8c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FRenderRipPosMat__FP3RIPP2CMP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_19f8c0
// Address: 0x19f8c0 - 0x19f8d0

void entry_19f8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19f8c0: 0x14400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x19F8D4; return;
    }
    // 0x19f8c8: 0xc067afa
    SET_GPR_U32(ctx, 31, 0x19f8d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_19f8d0
// Address: 0x19f8d0 - 0x19f8e8

void entry_19f8d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19f8d0) {
        switch (ctx->pc) {
            case 0x19f8d4: ctx->pc = 0; goto label_19f8d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19f8d0: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_19f8d4:
    // 0x19f8d4: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19f8d8: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x19f8dc: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x19f8e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SubscribeRipObject__FP3RIPP2LO
// Address: 0x19f8e8 - 0x19f90c

void entry_19f90c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19f90c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19f910: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SubscribeRipStruct__FP3RIPPFPv5MSGIDPv_vPv
// Address: 0x19f918 - 0x19f940

void entry_19f940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19f940: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19f944: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19f94c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19f950; return;
}


// Function: UnsubscribeRipStruct__FP3RIPPFPv5MSGIDPv_vPv
// Address: 0x19f950 - 0x19f978

void entry_19f978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19f978: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19f97c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19f984: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19f988; return;
}


// Function: InitDroplet__FP7DROPLETP6VECTORfP2SO
// Address: 0x19f988 - 0x19f99c

void entry_19f99c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19f99c: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x19f9a0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19f9a4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19f9a8: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x19f9ac: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x19f9b0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19f9b4: 0x8c831cec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 7404)));
    // 0x19f9b8: 0xae030020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 3));
    // 0x19f9bc: 0x78821ee0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 7904)));
    // 0x19f9c0: 0x7e0200c0
    WRITE128(ADD32(GPR_U32(ctx, 16), 192), GPR_VEC(ctx, 2));
    // 0x19f9c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19f9c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TouchDroplet__FP7DROPLETi
// Address: 0x19f9d0 - 0x19fa14

void entry_19fa14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fa14: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x19fa18: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x19fa20);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_19fa20
// Address: 0x19fa20 - 0x19fa48

void entry_19fa20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fa20: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x19fa24: 0x12000014
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19FA78; return;
    }
    // 0x19fa2c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x19fa30: 0x3c014220
    SET_GPR_U32(ctx, 1, ((uint32_t)16928 << 16));
    // 0x19fa34: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19fa38: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19fa3c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x19fa40: 0x40f809
    SET_GPR_U32(ctx, 31, 0x19fa48);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_19fa48
// Address: 0x19fa48 - 0x19fa80

void entry_19fa48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19fa48) {
        switch (ctx->pc) {
            case 0x19fa78: ctx->pc = 0; goto label_19fa78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19fa48: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x19fa4c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19fa50: 0x3c0141f0
    SET_GPR_U32(ctx, 1, ((uint32_t)16880 << 16));
    // 0x19fa54: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19fa58: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x19fa5c: 0xe6010034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x19fa60: 0x8e220024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 36)));
    // 0x19fa64: 0x8c420278
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 632)));
    // 0x19fa68: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_19fa78;
    }
    // 0x19fa70: 0x8c42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x19fa74: 0xae020114
    WRITE32(ADD32(GPR_U32(ctx, 16), 276), GPR_U32(ctx, 2));
label_19fa78:
    // 0x19fa78: 0xc067afa
    SET_GPR_U32(ctx, 31, 0x19fa80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveRip__FP3RIP(rdram, ctx, runtime); return;
}


// Function: entry_19fa80
// Address: 0x19fa80 - 0x19fa98

void entry_19fa80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fa80: 0x7bbf0720
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1824)));
    // 0x19fa84: 0x7bb10710
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1808)));
    // 0x19fa88: 0x7bb00700
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1792)));
    // 0x19fa8c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1840));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19fa94: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19fa98; return;
}


// Function: InitBublet__FP6BUBLETP6VECTORfP2SO
// Address: 0x19fa98 - 0x19faac

void entry_19faac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19faac: 0x3c01be4c
    SET_GPR_U32(ctx, 1, ((uint32_t)48716 << 16));
    // 0x19fab0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x19fab4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19fab8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19fabc: 0x3c013ea8
    SET_GPR_U32(ctx, 1, ((uint32_t)16040 << 16));
    // 0x19fac0: 0x3421f5c3
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 62915));
    // 0x19fac4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19fac8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x19facc: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x19fad0: 0x3c01c100
    SET_GPR_U32(ctx, 1, ((uint32_t)49408 << 16));
    // 0x19fad4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19fad8: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x19fadc: 0xe6010030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
    // 0x19fae0: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19fae4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19fae8: 0xd8611ee0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 7904)));
    // 0x19faec: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19faf0: 0xe60000b0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 176), *(uint32_t*)&val); }
    // 0x19faf4: 0xfa0200c0
    WRITE128(ADD32(GPR_U32(ctx, 16), 192), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19faf8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19fafc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19fb04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19fb08; return;
}


// Function: ProjectBubletTransform__FP6BUBLETf
// Address: 0x19fb08 - 0x19fb28

void entry_19fb28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fb28: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x19fb2c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19fb30: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x19fb34: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x19fb3c);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_19fb3c
// Address: 0x19fb3c - 0x19fc18

void entry_19fb3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19fb3c) {
        switch (ctx->pc) {
            case 0x19fba0: ctx->pc = 0; goto label_19fba0;
            case 0x19fbc4: ctx->pc = 0; goto label_19fbc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19fb3c: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x19fb40: 0x7a0200a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x19fb44: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x19fb48: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x19fb4c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x19fb50: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19fb54: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x19fb58: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x19fb5c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19fb60: 0x0
    // NOP
    // 0x19fb64: 0x4500000e
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19fba0;
    }
    // 0x19fb6c: 0x70022fc9
    SET_GPR_VEC(ctx, 5, _mm_shuffle_epi32(GPR_VEC(ctx, 0), _MM_SHUFFLE(0,3,2,1)));
    // 0x19fb70: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x19fb74: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x19fb78: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19fb7c: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19fba0;
    }
    // 0x19fb84: 0x70022ca8
    SET_GPR_VEC(ctx, 5, PS2_PEXTUW(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x19fb88: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x19fb8c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x19fb90: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19fb94: 0x0
    // NOP
    // 0x19fb98: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_19fba0;
    }
label_19fba0:
    // 0x19fba0: 0x14600008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_19fbc4;
    }
    // 0x19fba8: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x19fbac: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x19fbb0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19fbb4: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19fbb8: 0x0
    // NOP
    // 0x19fbbc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
        goto label_19fbc4;
    }
label_19fbc4:
    // 0x19fbc4: 0x10800042
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19FCD0; return;
    }
    // 0x19fbcc: 0xda0100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 160)));
    // 0x19fbd0: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19fbd4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19fbd8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19fbdc: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19fbe0: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x19fbe4: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x19fbe8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19fbec: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x19fbf0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x19fbf4: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x19fbf8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x19fbfc: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x19fc00: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19fc04: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19fc08: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x19fc0c: 0x24c68d00
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937856));
    // 0x19fc10: 0xc07b5e0
    SET_GPR_U32(ctx, 31, 0x19fc18);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937888));
    GetNormalVectors__FP6VECTORN30(rdram, ctx, runtime); return;
}


// Function: entry_19fc18
// Address: 0x19fc18 - 0x19fc50

void entry_19fc18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fc18: 0x3c014055
    SET_GPR_U32(ctx, 1, ((uint32_t)16469 << 16));
    // 0x19fc1c: 0x34215555
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 21845));
    // 0x19fc20: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19fc24: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x19fc28: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x19fc2c: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x19fc30: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x19fc34: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19fc38: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x19fc3c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19fc40: 0x46006b41
    ctx->f[13] = FPU_SUB_S(ctx->f[13], ctx->f[0]);
    // 0x19fc44: 0x46016b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[1]);
    // 0x19fc48: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x19fc50);
    ctx->f[13] = FPU_ADD_S(ctx->f[13], ctx->f[12]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_19fc50
// Address: 0x19fc50 - 0x19fc68

void entry_19fc50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fc50: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x19fc54: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x19fc58: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x19fc5c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x19fc60: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x19fc68);
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_19fc68
// Address: 0x19fc68 - 0x19fc78

void entry_19fc68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fc68: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x19fc6c: 0x27a50054
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 84));
    // 0x19fc70: 0xc07ab62
    SET_GPR_U32(ctx, 31, 0x19fc78);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    CalculateSinCos__FfPfT1(rdram, ctx, runtime); return;
}


// Function: entry_19fc78
// Address: 0x19fc78 - 0x19fce8

void entry_19fc78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19fc78) {
        switch (ctx->pc) {
            case 0x19fcd0: ctx->pc = 0; goto label_19fcd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19fc78: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x19fc7c: 0xc7a00054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[0] = *(float*)&val; }
    // 0x19fc80: 0x46140842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[20]);
    // 0x19fc84: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19fc88: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x19fc8c: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19fc90: 0x4402a800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[21]);
    // 0x19fc94: 0x44050800
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[1]);
    // 0x19fc98: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19fc9c: 0x48a51800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x19fca0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x19fca4: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x19fca8: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x19fcac: 0x4be311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x19fcb0: 0x4be40888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19fcb4: 0xda010080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x19fcb8: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x19fcbc: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x19fcc0: 0x4be51048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19fcc4: 0xfa010080
    WRITE128(ADD32(GPR_U32(ctx, 16), 128), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19fcc8: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19fccc: 0xfba50040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
label_19fcd0:
    // 0x19fcd0: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x19fcd4: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x19fcd8: 0xc7b50088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[21] = *(float*)&val; }
    // 0x19fcdc: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x19fce0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: TouchBublet__FP6BUBLETi
// Address: 0x19fce8 - 0x19fcf8

void entry_19fcf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fcf8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19fcfc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19fd04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19fd08; return;
}


// Function: InitRipple__FP6RIPPLEP6VECTORfP2SO
// Address: 0x19fd08 - 0x19fd24

void entry_19fd24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fd24: 0x3c014348
    SET_GPR_U32(ctx, 1, ((uint32_t)17224 << 16));
    // 0x19fd28: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19fd2c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x19fd30: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x19fd34: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x19fd38: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19fd3c: 0x8c625710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    // 0x19fd40: 0x46140029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[20]);
    // 0x19fd44: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x19fd48: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19fd4c: 0x8c431cf0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 7408)));
    // 0x19fd50: 0xe6000030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
    // 0x19fd54: 0xe6010034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x19fd58: 0xae030020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 3));
    // 0x19fd5c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19fd60: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x19fd64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19fd6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19fd70; return;
}


// Function: InitPuff__FP4PUFFP6VECTORfP2SO
// Address: 0x19fd70 - 0x19fd84

void entry_19fd84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fd84: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x19fd88: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19fd8c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19fd90: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x19fd94: 0xe601001c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x19fd98: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x19fd9c: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x19fda0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19fda4: 0x8c621cf4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 7412)));
    // 0x19fda8: 0xe6000034
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x19fdac: 0xae020020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    // 0x19fdb0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19fdb4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19fdb8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitDablet__FP6DABLETP6VECTORfP2SO
// Address: 0x19fdc0 - 0x19fdd4

void entry_19fdd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fdd4: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x19fdd8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19fddc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19fde0: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x19fde4: 0xe601001c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x19fde8: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x19fdec: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19fdf0: 0x78621ee0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 7904)));
    // 0x19fdf4: 0xe6000038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    // 0x19fdf8: 0x7e0200c0
    WRITE128(ADD32(GPR_U32(ctx, 16), 192), GPR_VEC(ctx, 2));
    // 0x19fdfc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19fe00: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19fe04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19fe0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19fe10; return;
}


// Function: InitFlake__FP5FLAKEP6VECTORfP2SO
// Address: 0x19fe10 - 0x19fe24

void entry_19fe24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19fe24: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x19fe28: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x19fe2c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19fe30: 0x8c625710
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 22288)));
    // 0x19fe34: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19fe38: 0x8c441d00
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 7424)));
    // 0x19fe3c: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x19fe40: 0xae040020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 4));
    // 0x19fe44: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x19fe48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateFlake__FP5FLAKEf
// Address: 0x19fe50 - 0x19fe98

void entry_19fe98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19fe98) {
        switch (ctx->pc) {
            case 0x19fea0: ctx->pc = 0; goto label_19fea0;
            case 0x19fef8: ctx->pc = 0; goto label_19fef8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19fe98: 0x1040fff7
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 6232));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x19FE78; return;
    }
label_19fea0:
    // 0x19fea0: 0xc6020018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[2] = *(float*)&val; }
    // 0x19fea4: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x19fea8: 0x3c013e19
    SET_GPR_U32(ctx, 1, ((uint32_t)15897 << 16));
    // 0x19feac: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x19feb0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19feb4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x19feb8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19febc: 0x0
    // NOP
    // 0x19fec0: 0x4500000d
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19fef8;
    }
    // 0x19fec8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x19fecc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x19fed0: 0x3c01c100
    SET_GPR_U32(ctx, 1, ((uint32_t)49408 << 16));
    // 0x19fed4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19fed8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x19fedc: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x19fee0: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x19fee4: 0xe60100b0
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 176), *(uint32_t*)&val); }
    // 0x19fee8: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x19feec: 0xd8611ee0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 7904)));
    // 0x19fef0: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19fef4: 0xfa0200c0
    WRITE128(ADD32(GPR_U32(ctx, 16), 192), _mm_castps_si128(ctx->vu0_vf[2]));
label_19fef8:
    // 0x19fef8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x19fefc: 0xc067d58
    SET_GPR_U32(ctx, 31, 0x19ff04);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    UpdateRip__FP3RIPf(rdram, ctx, runtime); return;
}


// Function: entry_19ff04
// Address: 0x19ff04 - 0x19ff20

void entry_19ff04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x19ff04: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x19ff08: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x19ff0c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x19ff10: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x19ff14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x19ff1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x19ff20; return;
}


// Function: RenderFlake__FP5FLAKEP2CM
// Address: 0x19ff20 - 0x19ff3c

void entry_19ff3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x19ff3c) {
        switch (ctx->pc) {
            case 0x19ffd0: ctx->pc = 0; goto label_19ffd0;
            case 0x19ffe0: ctx->pc = 0; goto label_19ffe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x19ff3c: 0xda020090
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 144)));
    // 0x19ff40: 0xda010080
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x19ff44: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19ff48: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x19ff4c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x19ff50: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19ff54: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x19ff58: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x19ff5c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x19ff60: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x19ff64: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x19ff68: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19ff6c: 0x0
    // NOP
    // 0x19ff70: 0x45000025
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_1a0008(rdram, ctx, runtime); return;
    }
    // 0x19ff78: 0xc6020018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[2] = *(float*)&val; }
    // 0x19ff7c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x19ff80: 0x26030040
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 64));
    // 0x19ff84: 0xc603001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[3] = *(float*)&val; }
    // 0x19ff88: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x19ff8c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x19ff90: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x19ff94: 0xc4620004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[2] = *(float*)&val; }
    // 0x19ff98: 0x24825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x19ff9c: 0xc6040040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[4] = *(float*)&val; }
    // 0x19ffa0: 0x46030003
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[3];
    // 0x19ffa4: 0xc4835c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[3] = *(float*)&val; }
    // 0x19ffa8: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x19ffac: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x19ffb0: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x19ffb4: 0x46002340
    ctx->f[13] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x19ffb8: 0x46036834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19ffbc: 0x0
    // NOP
    // 0x19ffc0: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_19ffd0;
    }
    // 0x19ffc8: 0x10000005
    ctx->f[13] = FPU_MOV_S(ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_19ffe0;
    }
label_19ffd0:
    // 0x19ffd0: 0x460d2834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x19ffd4: 0x0
    // NOP
    // 0x19ffd8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[13] = FPU_MOV_S(ctx->f[5]);
        goto label_19ffe0;
    }
label_19ffe0:
    // 0x19ffe0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x19ffe4: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x19ffe8: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x19ffec: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x19fff0: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x19fff4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x19fff8: 0x26070080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 128));
    // 0x19fffc: 0x26060090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 144));
    // 0x1a0000: 0xc049a2e
    SET_GPR_U32(ctx, 31, 0x1a0008);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 7428)));
    RenderAloLine__FP3ALOP2CMP6VECTORT2ff(rdram, ctx, runtime); return;
}


// Function: entry_1a0008
// Address: 0x1a0008 - 0x1a0020

void entry_19000c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19000c inside FUN_0018ffb0 (0x18ffb0 - 0x190058)
    ctx->pc = 0x19000c;
    FUN_0018ffb0(rdram, ctx, runtime);
}

void entry_190018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190018 inside FUN_0018ffb0 (0x18ffb0 - 0x190058)
    ctx->pc = 0x190018;
    FUN_0018ffb0(rdram, ctx, runtime);
}

void entry_190030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190030 inside FUN_0018ffb0 (0x18ffb0 - 0x190058)
    ctx->pc = 0x190030;
    FUN_0018ffb0(rdram, ctx, runtime);
}

void entry_190044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190044 inside FUN_0018ffb0 (0x18ffb0 - 0x190058)
    ctx->pc = 0x190044;
    FUN_0018ffb0(rdram, ctx, runtime);
}

void entry_19005c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19005c inside entry_190058 (0x190058 - 0x190068)
    ctx->pc = 0x19005c;
    entry_190058(rdram, ctx, runtime);
}

void entry_190060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190060 inside entry_190058 (0x190058 - 0x190068)
    ctx->pc = 0x190060;
    entry_190058(rdram, ctx, runtime);
}

void entry_190080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190080 inside entry_190068 (0x190068 - 0x1900a0)
    ctx->pc = 0x190080;
    entry_190068(rdram, ctx, runtime);
}

void entry_190088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190088 inside entry_190068 (0x190068 - 0x1900a0)
    ctx->pc = 0x190088;
    entry_190068(rdram, ctx, runtime);
}

void entry_1900f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1900f0 inside entry_1900e8 (0x1900e8 - 0x190114)
    ctx->pc = 0x1900f0;
    entry_1900e8(rdram, ctx, runtime);
}

void entry_190118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190118 inside entry_190114 (0x190114 - 0x190128)
    ctx->pc = 0x190118;
    entry_190114(rdram, ctx, runtime);
}

void entry_19011c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19011c inside entry_190114 (0x190114 - 0x190128)
    ctx->pc = 0x19011c;
    entry_190114(rdram, ctx, runtime);
}

void entry_19016c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19016c inside UpdateMurrayGoal__FP6MURRAYi (0x190128 - 0x1901bc)
    ctx->pc = 0x19016c;
    UpdateMurrayGoal__FP6MURRAYi(rdram, ctx, runtime);
}

void entry_190188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190188 inside UpdateMurrayGoal__FP6MURRAYi (0x190128 - 0x1901bc)
    ctx->pc = 0x190188;
    UpdateMurrayGoal__FP6MURRAYi(rdram, ctx, runtime);
}

void entry_190198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190198 inside UpdateMurrayGoal__FP6MURRAYi (0x190128 - 0x1901bc)
    ctx->pc = 0x190198;
    UpdateMurrayGoal__FP6MURRAYi(rdram, ctx, runtime);
}

void entry_1901a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1901a0 inside UpdateMurrayGoal__FP6MURRAYi (0x190128 - 0x1901bc)
    ctx->pc = 0x1901a0;
    UpdateMurrayGoal__FP6MURRAYi(rdram, ctx, runtime);
}

void entry_1901d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1901d4 inside entry_1901cc (0x1901cc - 0x1901f4)
    ctx->pc = 0x1901d4;
    entry_1901cc(rdram, ctx, runtime);
}

void entry_1901fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1901fc inside entry_1901f4 (0x1901f4 - 0x190204)
    ctx->pc = 0x1901fc;
    entry_1901f4(rdram, ctx, runtime);
}

void entry_19020c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19020c inside entry_190204 (0x190204 - 0x19021c)
    ctx->pc = 0x19020c;
    entry_190204(rdram, ctx, runtime);
}

void entry_190214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190214 inside entry_190204 (0x190204 - 0x19021c)
    ctx->pc = 0x190214;
    entry_190204(rdram, ctx, runtime);
}

void entry_190230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190230 inside entry_190228 (0x190228 - 0x190238)
    ctx->pc = 0x190230;
    entry_190228(rdram, ctx, runtime);
}

void entry_19023c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19023c inside entry_190238 (0x190238 - 0x190258)
    ctx->pc = 0x19023c;
    entry_190238(rdram, ctx, runtime);
}

void entry_1902c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1902c0 inside entry_1902b8 (0x1902b8 - 0x1902d0)
    ctx->pc = 0x1902c0;
    entry_1902b8(rdram, ctx, runtime);
}

void entry_1902c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1902c8 inside entry_1902b8 (0x1902b8 - 0x1902d0)
    ctx->pc = 0x1902c8;
    entry_1902b8(rdram, ctx, runtime);
}

void entry_1902e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1902e4 inside entry_1902dc (0x1902dc - 0x1902ec)
    ctx->pc = 0x1902e4;
    entry_1902dc(rdram, ctx, runtime);
}

void entry_1903a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1903a8 inside entry_1903a0 (0x1903a0 - 0x1903bc)
    ctx->pc = 0x1903a8;
    entry_1903a0(rdram, ctx, runtime);
}

void entry_1903d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1903d4 inside entry_1903cc (0x1903cc - 0x1903dc)
    ctx->pc = 0x1903d4;
    entry_1903cc(rdram, ctx, runtime);
}

void entry_1903e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1903e0 inside entry_1903dc (0x1903dc - 0x1903f0)
    ctx->pc = 0x1903e0;
    entry_1903dc(rdram, ctx, runtime);
}

void entry_1903e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1903e4 inside entry_1903dc (0x1903dc - 0x1903f0)
    ctx->pc = 0x1903e4;
    entry_1903dc(rdram, ctx, runtime);
}

void entry_190428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190428 inside entry_190420 (0x190420 - 0x190438)
    ctx->pc = 0x190428;
    entry_190420(rdram, ctx, runtime);
}

void entry_190430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190430 inside entry_190420 (0x190420 - 0x190438)
    ctx->pc = 0x190430;
    entry_190420(rdram, ctx, runtime);
}

void entry_1904bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1904bc inside entry_1904b0 (0x1904b0 - 0x1904c8)
    ctx->pc = 0x1904bc;
    entry_1904b0(rdram, ctx, runtime);
}

void entry_1904c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1904c0 inside entry_1904b0 (0x1904b0 - 0x1904c8)
    ctx->pc = 0x1904c0;
    entry_1904b0(rdram, ctx, runtime);
}

void entry_190518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190518 inside entry_1904fc (0x1904fc - 0x190524)
    ctx->pc = 0x190518;
    entry_1904fc(rdram, ctx, runtime);
}

void entry_190554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190554 inside entry_19054c (0x19054c - 0x190570)
    ctx->pc = 0x190554;
    entry_19054c(rdram, ctx, runtime);
}

void entry_190558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190558 inside entry_19054c (0x19054c - 0x190570)
    ctx->pc = 0x190558;
    entry_19054c(rdram, ctx, runtime);
}

void entry_1905b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1905b8 inside FDetectMurray__FP6MURRAY (0x190570 - 0x1905dc)
    ctx->pc = 0x1905b8;
    FDetectMurray__FP6MURRAY(rdram, ctx, runtime);
}

void entry_1905bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1905bc inside FDetectMurray__FP6MURRAY (0x190570 - 0x1905dc)
    ctx->pc = 0x1905bc;
    FDetectMurray__FP6MURRAY(rdram, ctx, runtime);
}

void entry_1905c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1905c0 inside FDetectMurray__FP6MURRAY (0x190570 - 0x1905dc)
    ctx->pc = 0x1905c0;
    FDetectMurray__FP6MURRAY(rdram, ctx, runtime);
}

void entry_190608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190608 inside entry_1905f8 (0x1905f8 - 0x190610)
    ctx->pc = 0x190608;
    entry_1905f8(rdram, ctx, runtime);
}

void entry_190628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190628 inside entry_190610 (0x190610 - 0x190658)
    ctx->pc = 0x190628;
    entry_190610(rdram, ctx, runtime);
}

void entry_19062c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19062c inside entry_190610 (0x190610 - 0x190658)
    ctx->pc = 0x19062c;
    entry_190610(rdram, ctx, runtime);
}

void entry_190630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190630 inside entry_190610 (0x190610 - 0x190658)
    ctx->pc = 0x190630;
    entry_190610(rdram, ctx, runtime);
}

void entry_1906a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1906a8 inside entry_190694 (0x190694 - 0x1906e8)
    ctx->pc = 0x1906a8;
    entry_190694(rdram, ctx, runtime);
}

void entry_1906d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1906d0 inside entry_190694 (0x190694 - 0x1906e8)
    ctx->pc = 0x1906d0;
    entry_190694(rdram, ctx, runtime);
}

void entry_1906d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1906d4 inside entry_190694 (0x190694 - 0x1906e8)
    ctx->pc = 0x1906d4;
    entry_190694(rdram, ctx, runtime);
}

void entry_190730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190730 inside entry_19072c (0x19072c - 0x190740)
    ctx->pc = 0x190730;
    entry_19072c(rdram, ctx, runtime);
}

void entry_190760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190760 inside FUN_00190740 (0x190740 - 0x190770)
    ctx->pc = 0x190760;
    FUN_00190740(rdram, ctx, runtime);
}

void entry_190768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190768 inside FUN_00190740 (0x190740 - 0x190770)
    ctx->pc = 0x190768;
    FUN_00190740(rdram, ctx, runtime);
}

void entry_1907cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1907cc inside entry_1907c8 (0x1907c8 - 0x1907e0)
    ctx->pc = 0x1907cc;
    entry_1907c8(rdram, ctx, runtime);
}

void entry_1907d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1907d0 inside entry_1907c8 (0x1907c8 - 0x1907e0)
    ctx->pc = 0x1907d0;
    entry_1907c8(rdram, ctx, runtime);
}

void entry_1907d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1907d4 inside entry_1907c8 (0x1907c8 - 0x1907e0)
    ctx->pc = 0x1907d4;
    entry_1907c8(rdram, ctx, runtime);
}

void entry_190804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190804 inside PcgtExtract__FP3CGT (0x1907f0 - 0x190810)
    ctx->pc = 0x190804;
    PcgtExtract__FP3CGT(rdram, ctx, runtime);
}

void entry_190840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190840 inside PcgtPointInCbspQuick__FP4CBSPP6VECTOR (0x190810 - 0x190878)
    ctx->pc = 0x190840;
    PcgtPointInCbspQuick__FP4CBSPP6VECTOR(rdram, ctx, runtime);
}

void entry_190888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190888 inside entry_190878 (0x190878 - 0x190890)
    ctx->pc = 0x190888;
    entry_190878(rdram, ctx, runtime);
}

void entry_19089c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19089c inside entry_190890 (0x190890 - 0x1908c0)
    ctx->pc = 0x19089c;
    entry_190890(rdram, ctx, runtime);
}

void entry_1908a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1908a4 inside entry_190890 (0x190890 - 0x1908c0)
    ctx->pc = 0x1908a4;
    entry_190890(rdram, ctx, runtime);
}

void entry_1908ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1908ac inside entry_190890 (0x190890 - 0x1908c0)
    ctx->pc = 0x1908ac;
    entry_190890(rdram, ctx, runtime);
}

void entry_1908f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1908f8 inside PcgtPointInCbspSafe__FP4CBSPP6VECTOR (0x1908c0 - 0x19093c)
    ctx->pc = 0x1908f8;
    PcgtPointInCbspSafe__FP4CBSPP6VECTOR(rdram, ctx, runtime);
}

void entry_19094c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19094c inside entry_19093c (0x19093c - 0x190954)
    ctx->pc = 0x19094c;
    entry_19093c(rdram, ctx, runtime);
}

void entry_190970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190970 inside entry_190968 (0x190968 - 0x190978)
    ctx->pc = 0x190970;
    entry_190968(rdram, ctx, runtime);
}

void entry_190984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190984 inside entry_190978 (0x190978 - 0x1909b0)
    ctx->pc = 0x190984;
    entry_190978(rdram, ctx, runtime);
}

void entry_19098c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19098c inside entry_190978 (0x190978 - 0x1909b0)
    ctx->pc = 0x19098c;
    entry_190978(rdram, ctx, runtime);
}

void entry_190994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190994 inside entry_190978 (0x190978 - 0x1909b0)
    ctx->pc = 0x190994;
    entry_190978(rdram, ctx, runtime);
}

void entry_1909e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1909e8 inside CbskFromG__Ff (0x1909b0 - 0x1909f0)
    ctx->pc = 0x1909e8;
    CbskFromG__Ff(rdram, ctx, runtime);
}

void entry_190a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190a90 inside ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG (0x1909f0 - 0x190c40)
    ctx->pc = 0x190a90;
    ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG(rdram, ctx, runtime);
}

void entry_190ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190ab8 inside ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG (0x1909f0 - 0x190c40)
    ctx->pc = 0x190ab8;
    ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG(rdram, ctx, runtime);
}

void entry_190b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190b20 inside ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG (0x1909f0 - 0x190c40)
    ctx->pc = 0x190b20;
    ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG(rdram, ctx, runtime);
}

void entry_190b24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190b24 inside ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG (0x1909f0 - 0x190c40)
    ctx->pc = 0x190b24;
    ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG(rdram, ctx, runtime);
}

void entry_190bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190bbc inside ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG (0x1909f0 - 0x190c40)
    ctx->pc = 0x190bbc;
    ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG(rdram, ctx, runtime);
}

void entry_190bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190bc0 inside ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG (0x1909f0 - 0x190c40)
    ctx->pc = 0x190bc0;
    ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG(rdram, ctx, runtime);
}

void entry_190bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190bf4 inside ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG (0x1909f0 - 0x190c40)
    ctx->pc = 0x190bf4;
    ClsgClipEdgeToCbsp__FP4CBSPP6VECTORT1iP3LSG(rdram, ctx, runtime);
}

void entry_190c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190c64 inside entry_190c4c (0x190c4c - 0x190cac)
    ctx->pc = 0x190c64;
    entry_190c4c(rdram, ctx, runtime);
}

void entry_190c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190c7c inside entry_190c4c (0x190c4c - 0x190cac)
    ctx->pc = 0x190c7c;
    entry_190c4c(rdram, ctx, runtime);
}

void entry_190c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190c84 inside entry_190c4c (0x190c4c - 0x190cac)
    ctx->pc = 0x190c84;
    entry_190c4c(rdram, ctx, runtime);
}

void entry_190c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190c90 inside entry_190c4c (0x190c4c - 0x190cac)
    ctx->pc = 0x190c90;
    entry_190c4c(rdram, ctx, runtime);
}

void entry_190ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190ca4 inside entry_190c4c (0x190c4c - 0x190cac)
    ctx->pc = 0x190ca4;
    entry_190c4c(rdram, ctx, runtime);
}

void entry_190cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190cbc inside entry_190cac (0x190cac - 0x190d38)
    ctx->pc = 0x190cbc;
    entry_190cac(rdram, ctx, runtime);
}

void entry_190cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190cc0 inside entry_190cac (0x190cac - 0x190d38)
    ctx->pc = 0x190cc0;
    entry_190cac(rdram, ctx, runtime);
}

void entry_190cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190cd4 inside entry_190cac (0x190cac - 0x190d38)
    ctx->pc = 0x190cd4;
    entry_190cac(rdram, ctx, runtime);
}

void entry_190d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190d4c inside entry_190d38 (0x190d38 - 0x190d70)
    ctx->pc = 0x190d4c;
    entry_190d38(rdram, ctx, runtime);
}

void entry_190d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190d5c inside entry_190d38 (0x190d38 - 0x190d70)
    ctx->pc = 0x190d5c;
    entry_190d38(rdram, ctx, runtime);
}

void entry_190d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190d74 inside entry_190d70 (0x190d70 - 0x190dac)
    ctx->pc = 0x190d74;
    entry_190d70(rdram, ctx, runtime);
}

void entry_190da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190da0 inside entry_190d70 (0x190d70 - 0x190dac)
    ctx->pc = 0x190da0;
    entry_190d70(rdram, ctx, runtime);
}

void entry_190da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190da4 inside entry_190d70 (0x190d70 - 0x190dac)
    ctx->pc = 0x190da4;
    entry_190d70(rdram, ctx, runtime);
}

void entry_190db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190db4 inside entry_190dac (0x190dac - 0x190dbc)
    ctx->pc = 0x190db4;
    entry_190dac(rdram, ctx, runtime);
}

void entry_190dc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190dc4 inside entry_190dbc (0x190dbc - 0x190e30)
    ctx->pc = 0x190dc4;
    entry_190dbc(rdram, ctx, runtime);
}

void entry_190dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190dd0 inside entry_190dbc (0x190dbc - 0x190e30)
    ctx->pc = 0x190dd0;
    entry_190dbc(rdram, ctx, runtime);
}

void entry_190dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190dd4 inside entry_190dbc (0x190dbc - 0x190e30)
    ctx->pc = 0x190dd4;
    entry_190dbc(rdram, ctx, runtime);
}

void entry_190de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190de0 inside entry_190dbc (0x190dbc - 0x190e30)
    ctx->pc = 0x190de0;
    entry_190dbc(rdram, ctx, runtime);
}

void entry_190dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190dec inside entry_190dbc (0x190dbc - 0x190e30)
    ctx->pc = 0x190dec;
    entry_190dbc(rdram, ctx, runtime);
}

void entry_190df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190df0 inside entry_190dbc (0x190dbc - 0x190e30)
    ctx->pc = 0x190df0;
    entry_190dbc(rdram, ctx, runtime);
}

void entry_190e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190e64 inside entry_190e44 (0x190e44 - 0x190ea8)
    ctx->pc = 0x190e64;
    entry_190e44(rdram, ctx, runtime);
}

void entry_190e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190e94 inside entry_190e44 (0x190e44 - 0x190ea8)
    ctx->pc = 0x190e94;
    entry_190e44(rdram, ctx, runtime);
}

void entry_190e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190e98 inside entry_190e44 (0x190e44 - 0x190ea8)
    ctx->pc = 0x190e98;
    entry_190e44(rdram, ctx, runtime);
}

void entry_190f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190f68 inside entry_190f08 (0x190f08 - 0x190fb0)
    ctx->pc = 0x190f68;
    entry_190f08(rdram, ctx, runtime);
}

void entry_190f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190f80 inside entry_190f08 (0x190f08 - 0x190fb0)
    ctx->pc = 0x190f80;
    entry_190f08(rdram, ctx, runtime);
}

void entry_190f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190f98 inside entry_190f08 (0x190f08 - 0x190fb0)
    ctx->pc = 0x190f98;
    entry_190f08(rdram, ctx, runtime);
}

void entry_190fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190fa8 inside entry_190f08 (0x190f08 - 0x190fb0)
    ctx->pc = 0x190fa8;
    entry_190f08(rdram, ctx, runtime);
}

void entry_190fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x190fcc inside entry_190fb0 (0x190fb0 - 0x190fdc)
    ctx->pc = 0x190fcc;
    entry_190fb0(rdram, ctx, runtime);
}

void entry_191050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191050 inside entry_190fdc (0x190fdc - 0x1910f8)
    ctx->pc = 0x191050;
    entry_190fdc(rdram, ctx, runtime);
}

void entry_191064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191064 inside entry_190fdc (0x190fdc - 0x1910f8)
    ctx->pc = 0x191064;
    entry_190fdc(rdram, ctx, runtime);
}

void entry_191078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191078 inside entry_190fdc (0x190fdc - 0x1910f8)
    ctx->pc = 0x191078;
    entry_190fdc(rdram, ctx, runtime);
}

void entry_19107c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19107c inside entry_190fdc (0x190fdc - 0x1910f8)
    ctx->pc = 0x19107c;
    entry_190fdc(rdram, ctx, runtime);
}

void entry_19108c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19108c inside entry_190fdc (0x190fdc - 0x1910f8)
    ctx->pc = 0x19108c;
    entry_190fdc(rdram, ctx, runtime);
}

void entry_1910ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1910ac inside entry_190fdc (0x190fdc - 0x1910f8)
    ctx->pc = 0x1910ac;
    entry_190fdc(rdram, ctx, runtime);
}

void entry_1910c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1910c0 inside entry_190fdc (0x190fdc - 0x1910f8)
    ctx->pc = 0x1910c0;
    entry_190fdc(rdram, ctx, runtime);
}

void entry_1910e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1910e8 inside entry_190fdc (0x190fdc - 0x1910f8)
    ctx->pc = 0x1910e8;
    entry_190fdc(rdram, ctx, runtime);
}

void entry_1910ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1910ec inside entry_190fdc (0x190fdc - 0x1910f8)
    ctx->pc = 0x1910ec;
    entry_190fdc(rdram, ctx, runtime);
}

void entry_1910f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1910f0 inside entry_190fdc (0x190fdc - 0x1910f8)
    ctx->pc = 0x1910f0;
    entry_190fdc(rdram, ctx, runtime);
}

void entry_1911a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1911a0 inside entry_191180 (0x191180 - 0x1911ac)
    ctx->pc = 0x1911a0;
    entry_191180(rdram, ctx, runtime);
}

void entry_1911e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1911e0 inside entry_1911ac (0x1911ac - 0x191240)
    ctx->pc = 0x1911e0;
    entry_1911ac(rdram, ctx, runtime);
}

void entry_1911e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1911e8 inside entry_1911ac (0x1911ac - 0x191240)
    ctx->pc = 0x1911e8;
    entry_1911ac(rdram, ctx, runtime);
}

void entry_1911f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1911f4 inside entry_1911ac (0x1911ac - 0x191240)
    ctx->pc = 0x1911f4;
    entry_1911ac(rdram, ctx, runtime);
}

void entry_191244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191244 inside entry_191240 (0x191240 - 0x191254)
    ctx->pc = 0x191244;
    entry_191240(rdram, ctx, runtime);
}

void entry_1912f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1912f0 inside entry_1912d8 (0x1912d8 - 0x1912fc)
    ctx->pc = 0x1912f0;
    entry_1912d8(rdram, ctx, runtime);
}

void entry_19130c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19130c inside entry_191308 (0x191308 - 0x191318)
    ctx->pc = 0x19130c;
    entry_191308(rdram, ctx, runtime);
}

void entry_191330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191330 inside entry_191318 (0x191318 - 0x191340)
    ctx->pc = 0x191330;
    entry_191318(rdram, ctx, runtime);
}

void entry_191350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191350 inside entry_19134c (0x19134c - 0x191374)
    ctx->pc = 0x191350;
    entry_19134c(rdram, ctx, runtime);
}

void entry_19136c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19136c inside entry_19134c (0x19134c - 0x191374)
    ctx->pc = 0x19136c;
    entry_19134c(rdram, ctx, runtime);
}

void entry_1913c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1913c0 inside entry_19139c (0x19139c - 0x1914b0)
    ctx->pc = 0x1913c0;
    entry_19139c(rdram, ctx, runtime);
}

void entry_191438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191438 inside entry_19139c (0x19139c - 0x1914b0)
    ctx->pc = 0x191438;
    entry_19139c(rdram, ctx, runtime);
}

void entry_1914d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1914d4 inside entry_1914d0 (0x1914d0 - 0x19153c)
    ctx->pc = 0x1914d4;
    entry_1914d0(rdram, ctx, runtime);
}

void entry_1914f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1914f0 inside entry_1914d0 (0x1914d0 - 0x19153c)
    ctx->pc = 0x1914f0;
    entry_1914d0(rdram, ctx, runtime);
}

void entry_19150c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19150c inside entry_1914d0 (0x1914d0 - 0x19153c)
    ctx->pc = 0x19150c;
    entry_1914d0(rdram, ctx, runtime);
}

void entry_191518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191518 inside entry_1914d0 (0x1914d0 - 0x19153c)
    ctx->pc = 0x191518;
    entry_1914d0(rdram, ctx, runtime);
}

void entry_191540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191540 inside entry_19153c (0x19153c - 0x191570)
    ctx->pc = 0x191540;
    entry_19153c(rdram, ctx, runtime);
}

void entry_1915c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1915c4 inside entry_1915b0 (0x1915b0 - 0x19162c)
    ctx->pc = 0x1915c4;
    entry_1915b0(rdram, ctx, runtime);
}

void entry_1915e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1915e8 inside entry_1915b0 (0x1915b0 - 0x19162c)
    ctx->pc = 0x1915e8;
    entry_1915b0(rdram, ctx, runtime);
}

void entry_19164c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19164c inside entry_19162c (0x19162c - 0x1916d0)
    ctx->pc = 0x19164c;
    entry_19162c(rdram, ctx, runtime);
}

void entry_19165c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19165c inside entry_19162c (0x19162c - 0x1916d0)
    ctx->pc = 0x19165c;
    entry_19162c(rdram, ctx, runtime);
}

void entry_19169c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19169c inside entry_19162c (0x19162c - 0x1916d0)
    ctx->pc = 0x19169c;
    entry_19162c(rdram, ctx, runtime);
}

void entry_191778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191778 inside entry_191760 (0x191760 - 0x191794)
    ctx->pc = 0x191778;
    entry_191760(rdram, ctx, runtime);
}

void entry_1917c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1917c0 inside entry_1917ac (0x1917ac - 0x1917c8)
    ctx->pc = 0x1917c0;
    entry_1917ac(rdram, ctx, runtime);
}

void entry_1917f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1917f8 inside entry_1917c8 (0x1917c8 - 0x19183c)
    ctx->pc = 0x1917f8;
    entry_1917c8(rdram, ctx, runtime);
}

void entry_191810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191810 inside entry_1917c8 (0x1917c8 - 0x19183c)
    ctx->pc = 0x191810;
    entry_1917c8(rdram, ctx, runtime);
}

void entry_191820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191820 inside entry_1917c8 (0x1917c8 - 0x19183c)
    ctx->pc = 0x191820;
    entry_1917c8(rdram, ctx, runtime);
}

void entry_191830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191830 inside entry_1917c8 (0x1917c8 - 0x19183c)
    ctx->pc = 0x191830;
    entry_1917c8(rdram, ctx, runtime);
}

void entry_191868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191868 inside entry_19183c (0x19183c - 0x19189c)
    ctx->pc = 0x191868;
    entry_19183c(rdram, ctx, runtime);
}

void entry_191880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191880 inside entry_19183c (0x19183c - 0x19189c)
    ctx->pc = 0x191880;
    entry_19183c(rdram, ctx, runtime);
}

void entry_191890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191890 inside entry_19183c (0x19183c - 0x19189c)
    ctx->pc = 0x191890;
    entry_19183c(rdram, ctx, runtime);
}

void entry_1918c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1918c8 inside entry_19189c (0x19189c - 0x1918d4)
    ctx->pc = 0x1918c8;
    entry_19189c(rdram, ctx, runtime);
}

void entry_1918f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1918f8 inside entry_1918e0 (0x1918e0 - 0x19190c)
    ctx->pc = 0x1918f8;
    entry_1918e0(rdram, ctx, runtime);
}

void entry_191934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191934 inside entry_191920 (0x191920 - 0x191970)
    ctx->pc = 0x191934;
    entry_191920(rdram, ctx, runtime);
}

void entry_19194c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19194c inside entry_191920 (0x191920 - 0x191970)
    ctx->pc = 0x19194c;
    entry_191920(rdram, ctx, runtime);
}

void entry_191968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191968 inside entry_191920 (0x191920 - 0x191970)
    ctx->pc = 0x191968;
    entry_191920(rdram, ctx, runtime);
}

void entry_191984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191984 inside entry_191970 (0x191970 - 0x1919d4)
    ctx->pc = 0x191984;
    entry_191970(rdram, ctx, runtime);
}

void entry_19199c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19199c inside entry_191970 (0x191970 - 0x1919d4)
    ctx->pc = 0x19199c;
    entry_191970(rdram, ctx, runtime);
}

void entry_1919b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1919b8 inside entry_191970 (0x191970 - 0x1919d4)
    ctx->pc = 0x1919b8;
    entry_191970(rdram, ctx, runtime);
}

void entry_1919cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1919cc inside entry_191970 (0x191970 - 0x1919d4)
    ctx->pc = 0x1919cc;
    entry_191970(rdram, ctx, runtime);
}

void entry_191a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191a10 inside HookupCg__FP2CG (0x1919f8 - 0x191a68)
    ctx->pc = 0x191a10;
    HookupCg__FP2CG(rdram, ctx, runtime);
}

void entry_191a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191a5c inside HookupCg__FP2CG (0x1919f8 - 0x191a68)
    ctx->pc = 0x191a5c;
    HookupCg__FP2CG(rdram, ctx, runtime);
}

void entry_191b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191b38 inside FUN_00191ac8 (0x191ac8 - 0x191b50)
    ctx->pc = 0x191b38;
    FUN_00191ac8(rdram, ctx, runtime);
}

void entry_191c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191c0c inside entry_191bdc (0x191bdc - 0x191c78)
    ctx->pc = 0x191c0c;
    entry_191bdc(rdram, ctx, runtime);
}

void entry_191c1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191c1c inside entry_191bdc (0x191bdc - 0x191c78)
    ctx->pc = 0x191c1c;
    entry_191bdc(rdram, ctx, runtime);
}

void entry_191cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191cb8 inside ChoosePathzoneRandomPoint__FP8PATHZONEP6VECTOR (0x191c78 - 0x191d24)
    ctx->pc = 0x191cb8;
    ChoosePathzoneRandomPoint__FP8PATHZONEP6VECTOR(rdram, ctx, runtime);
}

void entry_191d18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191d18 inside ChoosePathzoneRandomPoint__FP8PATHZONEP6VECTOR (0x191c78 - 0x191d24)
    ctx->pc = 0x191d18;
    ChoosePathzoneRandomPoint__FP8PATHZONEP6VECTOR(rdram, ctx, runtime);
}

void entry_191d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191d40 inside entry_191d24 (0x191d24 - 0x191dc8)
    ctx->pc = 0x191d40;
    entry_191d24(rdram, ctx, runtime);
}

void entry_191db0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191db0 inside entry_191d24 (0x191d24 - 0x191dc8)
    ctx->pc = 0x191db0;
    entry_191d24(rdram, ctx, runtime);
}

void entry_191df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191df4 inside entry_191dd8 (0x191dd8 - 0x191e70)
    ctx->pc = 0x191df4;
    entry_191dd8(rdram, ctx, runtime);
}

void entry_191e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x191e9c inside entry_191e98 (0x191e98 - 0x191eb0)
    ctx->pc = 0x191e9c;
    entry_191e98(rdram, ctx, runtime);
}

void entry_19200c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19200c inside entry_192008 (0x192008 - 0x192020)
    ctx->pc = 0x19200c;
    entry_192008(rdram, ctx, runtime);
}

void entry_192220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192220 inside entry_19221c (0x19221c - 0x192230)
    ctx->pc = 0x192220;
    entry_19221c(rdram, ctx, runtime);
}

void entry_192270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192270 inside entry_192254 (0x192254 - 0x19227c)
    ctx->pc = 0x192270;
    entry_192254(rdram, ctx, runtime);
}

void entry_192284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192284 inside entry_19227c (0x19227c - 0x1922e8)
    ctx->pc = 0x192284;
    entry_19227c(rdram, ctx, runtime);
}

void entry_1922a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1922a8 inside entry_19227c (0x19227c - 0x1922e8)
    ctx->pc = 0x1922a8;
    entry_19227c(rdram, ctx, runtime);
}

void entry_1922cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1922cc inside entry_19227c (0x19227c - 0x1922e8)
    ctx->pc = 0x1922cc;
    entry_19227c(rdram, ctx, runtime);
}

void entry_1922d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1922d0 inside entry_19227c (0x19227c - 0x1922e8)
    ctx->pc = 0x1922d0;
    entry_19227c(rdram, ctx, runtime);
}

void entry_1922d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1922d4 inside entry_19227c (0x19227c - 0x1922e8)
    ctx->pc = 0x1922d4;
    entry_19227c(rdram, ctx, runtime);
}

void entry_192330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192330 inside entry_192328 (0x192328 - 0x192358)
    ctx->pc = 0x192330;
    entry_192328(rdram, ctx, runtime);
}

void entry_192340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192340 inside entry_192328 (0x192328 - 0x192358)
    ctx->pc = 0x192340;
    entry_192328(rdram, ctx, runtime);
}

void entry_19236c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19236c inside entry_192358 (0x192358 - 0x192380)
    ctx->pc = 0x19236c;
    entry_192358(rdram, ctx, runtime);
}

void entry_1923bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1923bc inside entry_1923a4 (0x1923a4 - 0x1923e8)
    ctx->pc = 0x1923bc;
    entry_1923a4(rdram, ctx, runtime);
}

void entry_1923f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1923f0 inside entry_1923e8 (0x1923e8 - 0x192410)
    ctx->pc = 0x1923f0;
    entry_1923e8(rdram, ctx, runtime);
}

void entry_1923f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1923f4 inside entry_1923e8 (0x1923e8 - 0x192410)
    ctx->pc = 0x1923f4;
    entry_1923e8(rdram, ctx, runtime);
}

void entry_192440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192440 inside entry_19243c (0x19243c - 0x192450)
    ctx->pc = 0x192440;
    entry_19243c(rdram, ctx, runtime);
}

void entry_192478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192478 inside entry_192470 (0x192470 - 0x192488)
    ctx->pc = 0x192478;
    entry_192470(rdram, ctx, runtime);
}

void entry_19247c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19247c inside entry_192470 (0x192470 - 0x192488)
    ctx->pc = 0x19247c;
    entry_192470(rdram, ctx, runtime);
}

void entry_1924fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1924fc inside CollectPoPrize__FP2PO3PCKP3ALO (0x1924c8 - 0x192510)
    ctx->pc = 0x1924fc;
    CollectPoPrize__FP2PO3PCKP3ALO(rdram, ctx, runtime);
}

void entry_192578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192578 inside entry_19255c (0x19255c - 0x19258c)
    ctx->pc = 0x192578;
    entry_19255c(rdram, ctx, runtime);
}

void entry_192594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192594 inside entry_19258c (0x19258c - 0x1925a8)
    ctx->pc = 0x192594;
    entry_19258c(rdram, ctx, runtime);
}

void entry_1925ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1925ac inside entry_1925a8 (0x1925a8 - 0x1925c0)
    ctx->pc = 0x1925ac;
    entry_1925a8(rdram, ctx, runtime);
}

void entry_1925b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1925b0 inside entry_1925a8 (0x1925a8 - 0x1925c0)
    ctx->pc = 0x1925b0;
    entry_1925a8(rdram, ctx, runtime);
}

void entry_1925e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1925e0 inside FUN_001925C0 (0x1925c0 - 0x1925f0)
    ctx->pc = 0x1925e0;
    FUN_001925C0(rdram, ctx, runtime);
}

void entry_1925e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1925e8 inside FUN_001925C0 (0x1925c0 - 0x1925f0)
    ctx->pc = 0x1925e8;
    FUN_001925C0(rdram, ctx, runtime);
}

void entry_192614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192614 inside PpoCur__Fv (0x1925f0 - 0x192620)
    ctx->pc = 0x192614;
    PpoCur__Fv(rdram, ctx, runtime);
}

void entry_192658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192658 inside entry_192630 (0x192630 - 0x192688)
    ctx->pc = 0x192658;
    entry_192630(rdram, ctx, runtime);
}

void entry_192678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192678 inside entry_192630 (0x192630 - 0x192688)
    ctx->pc = 0x192678;
    entry_192630(rdram, ctx, runtime);
}

void entry_1926a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1926a8 inside _IppoFindPo__FP2PO (0x192688 - 0x1926d0)
    ctx->pc = 0x1926a8;
    fn__IppoFindPo__FP2PO(rdram, ctx, runtime);
}

void entry_1926bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1926bc inside _IppoFindPo__FP2PO (0x192688 - 0x1926d0)
    ctx->pc = 0x1926bc;
    fn__IppoFindPo__FP2PO(rdram, ctx, runtime);
}

void entry_1926c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1926c8 inside _IppoFindPo__FP2PO (0x192688 - 0x1926d0)
    ctx->pc = 0x1926c8;
    fn__IppoFindPo__FP2PO(rdram, ctx, runtime);
}

void entry_192748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192748 inside entry_192710 (0x192710 - 0x192780)
    ctx->pc = 0x192748;
    entry_192710(rdram, ctx, runtime);
}

void entry_192774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192774 inside entry_192710 (0x192710 - 0x192780)
    ctx->pc = 0x192774;
    entry_192710(rdram, ctx, runtime);
}

void entry_192778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192778 inside entry_192710 (0x192710 - 0x192780)
    ctx->pc = 0x192778;
    entry_192710(rdram, ctx, runtime);
}

void entry_1927bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1927bc inside entry_1927b8 (0x1927b8 - 0x1927e8)
    ctx->pc = 0x1927bc;
    entry_1927b8(rdram, ctx, runtime);
}

void entry_1927fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1927fc inside entry_1927e8 (0x1927e8 - 0x192820)
    ctx->pc = 0x1927fc;
    entry_1927e8(rdram, ctx, runtime);
}

void entry_192808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192808 inside entry_1927e8 (0x1927e8 - 0x192820)
    ctx->pc = 0x192808;
    entry_1927e8(rdram, ctx, runtime);
}

void entry_1928f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1928f8 inside SwitchToIppo__Fi (0x192880 - 0x19290c)
    ctx->pc = 0x1928f8;
    SwitchToIppo__Fi(rdram, ctx, runtime);
}

void entry_1928fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1928fc inside SwitchToIppo__Fi (0x192880 - 0x19290c)
    ctx->pc = 0x1928fc;
    SwitchToIppo__Fi(rdram, ctx, runtime);
}

void entry_19295c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19295c inside entry_19290c (0x19290c - 0x192970)
    ctx->pc = 0x19295c;
    entry_19290c(rdram, ctx, runtime);
}

void entry_192960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192960 inside entry_19290c (0x19290c - 0x192970)
    ctx->pc = 0x192960;
    entry_19290c(rdram, ctx, runtime);
}

void entry_1929bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1929bc inside entry_1929b4 (0x1929b4 - 0x1929c4)
    ctx->pc = 0x1929bc;
    entry_1929b4(rdram, ctx, runtime);
}

void entry_1929c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1929c8 inside entry_1929c4 (0x1929c4 - 0x1929d0)
    ctx->pc = 0x1929c8;
    entry_1929c4(rdram, ctx, runtime);
}

void entry_192a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192a18 inside entry_192a08 (0x192a08 - 0x192a28)
    ctx->pc = 0x192a18;
    entry_192a08(rdram, ctx, runtime);
}

void entry_192ab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192ab4 inside entry_192a90 (0x192a90 - 0x192b0c)
    ctx->pc = 0x192ab4;
    entry_192a90(rdram, ctx, runtime);
}

void entry_192abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192abc inside entry_192a90 (0x192a90 - 0x192b0c)
    ctx->pc = 0x192abc;
    entry_192a90(rdram, ctx, runtime);
}

void entry_192b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192b14 inside entry_192b0c (0x192b0c - 0x192b38)
    ctx->pc = 0x192b14;
    entry_192b0c(rdram, ctx, runtime);
}

void entry_192b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192b18 inside entry_192b0c (0x192b0c - 0x192b38)
    ctx->pc = 0x192b18;
    entry_192b0c(rdram, ctx, runtime);
}

void entry_192b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192b3c inside entry_192b38 (0x192b38 - 0x192b44)
    ctx->pc = 0x192b3c;
    entry_192b38(rdram, ctx, runtime);
}

void entry_192b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192b48 inside entry_192b44 (0x192b44 - 0x192b58)
    ctx->pc = 0x192b48;
    entry_192b44(rdram, ctx, runtime);
}

void entry_192ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192ba0 inside entry_192b7c (0x192b7c - 0x192be4)
    ctx->pc = 0x192ba0;
    entry_192b7c(rdram, ctx, runtime);
}

void entry_192bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192bb8 inside entry_192b7c (0x192b7c - 0x192be4)
    ctx->pc = 0x192bb8;
    entry_192b7c(rdram, ctx, runtime);
}

void entry_192bec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192bec inside entry_192be4 (0x192be4 - 0x192c04)
    ctx->pc = 0x192bec;
    entry_192be4(rdram, ctx, runtime);
}

void entry_192c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192c08 inside entry_192c04 (0x192c04 - 0x192c34)
    ctx->pc = 0x192c08;
    entry_192c04(rdram, ctx, runtime);
}

void entry_192c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192c2c inside entry_192c04 (0x192c04 - 0x192c34)
    ctx->pc = 0x192c2c;
    entry_192c04(rdram, ctx, runtime);
}

void entry_192c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192c38 inside entry_192c34 (0x192c34 - 0x192c58)
    ctx->pc = 0x192c38;
    entry_192c34(rdram, ctx, runtime);
}

void entry_192c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192c9c inside UsePoCharm__FP2PO (0x192c58 - 0x192cb8)
    ctx->pc = 0x192c9c;
    UsePoCharm__FP2PO(rdram, ctx, runtime);
}

void entry_192d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192d7c inside entry_192d74 (0x192d74 - 0x192db4)
    ctx->pc = 0x192d7c;
    entry_192d74(rdram, ctx, runtime);
}

void entry_192db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192db8 inside entry_192db4 (0x192db4 - 0x192dd0)
    ctx->pc = 0x192db8;
    entry_192db4(rdram, ctx, runtime);
}

void entry_192e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192e28 inside FUN_00192dd0 (0x192dd0 - 0x192e4c)
    ctx->pc = 0x192e28;
    FUN_00192dd0(rdram, ctx, runtime);
}

void entry_192e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192e2c inside FUN_00192dd0 (0x192dd0 - 0x192e4c)
    ctx->pc = 0x192e2c;
    FUN_00192dd0(rdram, ctx, runtime);
}

void entry_192e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192e58 inside entry_192e4c (0x192e4c - 0x193038)
    ctx->pc = 0x192e58;
    entry_192e4c(rdram, ctx, runtime);
}

void entry_192ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192ebc inside entry_192e4c (0x192e4c - 0x193038)
    ctx->pc = 0x192ebc;
    entry_192e4c(rdram, ctx, runtime);
}

void entry_192ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192ec4 inside entry_192e4c (0x192e4c - 0x193038)
    ctx->pc = 0x192ec4;
    entry_192e4c(rdram, ctx, runtime);
}

void entry_192ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192ed4 inside entry_192e4c (0x192e4c - 0x193038)
    ctx->pc = 0x192ed4;
    entry_192e4c(rdram, ctx, runtime);
}

void entry_192ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192ef8 inside entry_192e4c (0x192e4c - 0x193038)
    ctx->pc = 0x192ef8;
    entry_192e4c(rdram, ctx, runtime);
}

void entry_192f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192f30 inside entry_192e4c (0x192e4c - 0x193038)
    ctx->pc = 0x192f30;
    entry_192e4c(rdram, ctx, runtime);
}

void entry_192f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192f38 inside entry_192e4c (0x192e4c - 0x193038)
    ctx->pc = 0x192f38;
    entry_192e4c(rdram, ctx, runtime);
}

void entry_192f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192f60 inside entry_192e4c (0x192e4c - 0x193038)
    ctx->pc = 0x192f60;
    entry_192e4c(rdram, ctx, runtime);
}

void entry_192fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192fbc inside entry_192e4c (0x192e4c - 0x193038)
    ctx->pc = 0x192fbc;
    entry_192e4c(rdram, ctx, runtime);
}

void entry_192fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192fcc inside entry_192e4c (0x192e4c - 0x193038)
    ctx->pc = 0x192fcc;
    entry_192e4c(rdram, ctx, runtime);
}

void entry_192ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x192ff0 inside entry_192e4c (0x192e4c - 0x193038)
    ctx->pc = 0x192ff0;
    entry_192e4c(rdram, ctx, runtime);
}

void entry_193048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193048 inside entry_193038 (0x193038 - 0x193064)
    ctx->pc = 0x193048;
    entry_193038(rdram, ctx, runtime);
}

void entry_193078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193078 inside entry_193064 (0x193064 - 0x1930b0)
    ctx->pc = 0x193078;
    entry_193064(rdram, ctx, runtime);
}

void entry_193108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193108 inside entry_1930ec (0x1930ec - 0x19313c)
    ctx->pc = 0x193108;
    entry_1930ec(rdram, ctx, runtime);
}

void entry_1931c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1931c0 inside entry_19313c (0x19313c - 0x1931f0)
    ctx->pc = 0x1931c0;
    entry_19313c(rdram, ctx, runtime);
}

void entry_1931dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1931dc inside entry_19313c (0x19313c - 0x1931f0)
    ctx->pc = 0x1931dc;
    entry_19313c(rdram, ctx, runtime);
}

void entry_1932cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1932cc inside entry_1932c4 (0x1932c4 - 0x1932ec)
    ctx->pc = 0x1932cc;
    entry_1932c4(rdram, ctx, runtime);
}

void entry_1932e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1932e0 inside entry_1932c4 (0x1932c4 - 0x1932ec)
    ctx->pc = 0x1932e0;
    entry_1932c4(rdram, ctx, runtime);
}

void entry_1932e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1932e4 inside entry_1932c4 (0x1932c4 - 0x1932ec)
    ctx->pc = 0x1932e4;
    entry_1932c4(rdram, ctx, runtime);
}

void entry_193474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193474 inside entry_193450 (0x193450 - 0x1934d0)
    ctx->pc = 0x193474;
    entry_193450(rdram, ctx, runtime);
}

void entry_193494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193494 inside entry_193450 (0x193450 - 0x1934d0)
    ctx->pc = 0x193494;
    entry_193450(rdram, ctx, runtime);
}

void entry_1934a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1934a4 inside entry_193450 (0x193450 - 0x1934d0)
    ctx->pc = 0x1934a4;
    entry_193450(rdram, ctx, runtime);
}

void entry_193604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193604 inside entry_1935e8 (0x1935e8 - 0x193644)
    ctx->pc = 0x193604;
    entry_1935e8(rdram, ctx, runtime);
}

void entry_19368c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19368c inside entry_193680 (0x193680 - 0x1936a0)
    ctx->pc = 0x19368c;
    entry_193680(rdram, ctx, runtime);
}

void entry_193710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193710 inside render_pause_menuQMARK (0x1936a0 - 0x1937a4)
    ctx->pc = 0x193710;
    render_pause_menuQMARK(rdram, ctx, runtime);
}

void entry_193728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193728 inside render_pause_menuQMARK (0x1936a0 - 0x1937a4)
    ctx->pc = 0x193728;
    render_pause_menuQMARK(rdram, ctx, runtime);
}

void entry_19379c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19379c inside render_pause_menuQMARK (0x1936a0 - 0x1937a4)
    ctx->pc = 0x19379c;
    render_pause_menuQMARK(rdram, ctx, runtime);
}

void entry_193818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193818 inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x193818;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_19383c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19383c inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x19383c;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_19386c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19386c inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x19386c;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_193870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193870 inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x193870;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_193894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193894 inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x193894;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_1938a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1938a8 inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x1938a8;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_1938d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1938d0 inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x1938d0;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_1938f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1938f8 inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x1938f8;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_193908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193908 inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x193908;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_193914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193914 inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x193914;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_19391c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19391c inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x19391c;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_193940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193940 inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x193940;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_19394c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19394c inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x19394c;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_193950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193950 inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x193950;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_193954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193954 inside entry_1937b4 (0x1937b4 - 0x1939b4)
    ctx->pc = 0x193954;
    entry_1937b4(rdram, ctx, runtime);
}

void entry_1939bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1939bc inside entry_1939b4 (0x1939b4 - 0x1939c8)
    ctx->pc = 0x1939bc;
    entry_1939b4(rdram, ctx, runtime);
}

void entry_193a8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193a8c inside entry_1939e0 (0x1939e0 - 0x193a98)
    ctx->pc = 0x193a8c;
    entry_1939e0(rdram, ctx, runtime);
}

void entry_193a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193a90 inside entry_1939e0 (0x1939e0 - 0x193a98)
    ctx->pc = 0x193a90;
    entry_1939e0(rdram, ctx, runtime);
}

void entry_193ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193ae0 inside entry_193ad8 (0x193ad8 - 0x193b00)
    ctx->pc = 0x193ae0;
    entry_193ad8(rdram, ctx, runtime);
}

void entry_193b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193b08 inside entry_193b00 (0x193b00 - 0x193b18)
    ctx->pc = 0x193b08;
    entry_193b00(rdram, ctx, runtime);
}

void entry_193b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193b0c inside entry_193b00 (0x193b00 - 0x193b18)
    ctx->pc = 0x193b0c;
    entry_193b00(rdram, ctx, runtime);
}

void entry_193b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193b1c inside entry_193b18 (0x193b18 - 0x193be4)
    ctx->pc = 0x193b1c;
    entry_193b18(rdram, ctx, runtime);
}

void entry_193b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193b78 inside entry_193b18 (0x193b18 - 0x193be4)
    ctx->pc = 0x193b78;
    entry_193b18(rdram, ctx, runtime);
}

void entry_193c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193c10 inside entry_193bfc (0x193bfc - 0x193c38)
    ctx->pc = 0x193c10;
    entry_193bfc(rdram, ctx, runtime);
}

void entry_193c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193c14 inside entry_193bfc (0x193bfc - 0x193c38)
    ctx->pc = 0x193c14;
    entry_193bfc(rdram, ctx, runtime);
}

void entry_193c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193c74 inside entry_193c68 (0x193c68 - 0x193c84)
    ctx->pc = 0x193c74;
    entry_193c68(rdram, ctx, runtime);
}

void entry_193cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193cb4 inside entry_193c84 (0x193c84 - 0x193d48)
    ctx->pc = 0x193cb4;
    entry_193c84(rdram, ctx, runtime);
}

void entry_193cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193cc8 inside entry_193c84 (0x193c84 - 0x193d48)
    ctx->pc = 0x193cc8;
    entry_193c84(rdram, ctx, runtime);
}

void entry_193cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193cf8 inside entry_193c84 (0x193c84 - 0x193d48)
    ctx->pc = 0x193cf8;
    entry_193c84(rdram, ctx, runtime);
}

void entry_193d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193d28 inside entry_193c84 (0x193c84 - 0x193d48)
    ctx->pc = 0x193d28;
    entry_193c84(rdram, ctx, runtime);
}

void entry_193d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193d68 inside entry_193d50 (0x193d50 - 0x193d70)
    ctx->pc = 0x193d68;
    entry_193d50(rdram, ctx, runtime);
}

void entry_193d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193d8c inside entry_193d88 (0x193d88 - 0x193dfc)
    ctx->pc = 0x193d8c;
    entry_193d88(rdram, ctx, runtime);
}

void entry_193d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193d90 inside entry_193d88 (0x193d88 - 0x193dfc)
    ctx->pc = 0x193d90;
    entry_193d88(rdram, ctx, runtime);
}

void entry_193da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193da0 inside entry_193d88 (0x193d88 - 0x193dfc)
    ctx->pc = 0x193da0;
    entry_193d88(rdram, ctx, runtime);
}

void entry_193dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193dc8 inside entry_193d88 (0x193d88 - 0x193dfc)
    ctx->pc = 0x193dc8;
    entry_193d88(rdram, ctx, runtime);
}

void entry_193df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193df0 inside entry_193d88 (0x193d88 - 0x193dfc)
    ctx->pc = 0x193df0;
    entry_193d88(rdram, ctx, runtime);
}

void entry_193e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193e94 inside entry_193e8c (0x193e8c - 0x193ee8)
    ctx->pc = 0x193e94;
    entry_193e8c(rdram, ctx, runtime);
}

void entry_193eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193eb0 inside entry_193e8c (0x193e8c - 0x193ee8)
    ctx->pc = 0x193eb0;
    entry_193e8c(rdram, ctx, runtime);
}

void entry_193f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193f28 inside entry_193f20 (0x193f20 - 0x193f60)
    ctx->pc = 0x193f28;
    entry_193f20(rdram, ctx, runtime);
}

void entry_193f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193f4c inside entry_193f20 (0x193f20 - 0x193f60)
    ctx->pc = 0x193f4c;
    entry_193f20(rdram, ctx, runtime);
}

void entry_193f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193f64 inside entry_193f60 (0x193f60 - 0x193f9c)
    ctx->pc = 0x193f64;
    entry_193f60(rdram, ctx, runtime);
}

void entry_193f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193f68 inside entry_193f60 (0x193f60 - 0x193f9c)
    ctx->pc = 0x193f68;
    entry_193f60(rdram, ctx, runtime);
}

void entry_193ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x193ff0 inside entry_193fb0 (0x193fb0 - 0x194080)
    ctx->pc = 0x193ff0;
    entry_193fb0(rdram, ctx, runtime);
}

void entry_19400c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19400c inside entry_193fb0 (0x193fb0 - 0x194080)
    ctx->pc = 0x19400c;
    entry_193fb0(rdram, ctx, runtime);
}

void entry_194048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194048 inside entry_193fb0 (0x193fb0 - 0x194080)
    ctx->pc = 0x194048;
    entry_193fb0(rdram, ctx, runtime);
}

void entry_194064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194064 inside entry_193fb0 (0x193fb0 - 0x194080)
    ctx->pc = 0x194064;
    entry_193fb0(rdram, ctx, runtime);
}

void entry_1940d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1940d4 inside entry_1940d0 (0x1940d0 - 0x1940e8)
    ctx->pc = 0x1940d4;
    entry_1940d0(rdram, ctx, runtime);
}

void entry_194144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194144 inside entry_19413c (0x19413c - 0x19415c)
    ctx->pc = 0x194144;
    entry_19413c(rdram, ctx, runtime);
}

void entry_194150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194150 inside entry_19413c (0x19413c - 0x19415c)
    ctx->pc = 0x194150;
    entry_19413c(rdram, ctx, runtime);
}

void entry_194164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194164 inside entry_19415c (0x19415c - 0x194184)
    ctx->pc = 0x194164;
    entry_19415c(rdram, ctx, runtime);
}

void entry_19418c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19418c inside entry_194184 (0x194184 - 0x194194)
    ctx->pc = 0x19418c;
    entry_194184(rdram, ctx, runtime);
}

void entry_194198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194198 inside entry_194194 (0x194194 - 0x1941a4)
    ctx->pc = 0x194198;
    entry_194194(rdram, ctx, runtime);
}

void entry_1941d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1941d0 inside entry_1941c8 (0x1941c8 - 0x1941f8)
    ctx->pc = 0x1941d0;
    entry_1941c8(rdram, ctx, runtime);
}

void entry_194200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194200 inside entry_1941f8 (0x1941f8 - 0x194224)
    ctx->pc = 0x194200;
    entry_1941f8(rdram, ctx, runtime);
}

void entry_194218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194218 inside entry_1941f8 (0x1941f8 - 0x194224)
    ctx->pc = 0x194218;
    entry_1941f8(rdram, ctx, runtime);
}

void entry_19422c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19422c inside entry_194224 (0x194224 - 0x194234)
    ctx->pc = 0x19422c;
    entry_194224(rdram, ctx, runtime);
}

void entry_194238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194238 inside entry_194234 (0x194234 - 0x194244)
    ctx->pc = 0x194238;
    entry_194234(rdram, ctx, runtime);
}

void entry_194260(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194260 inside entry_19425c (0x19425c - 0x194278)
    ctx->pc = 0x194260;
    entry_19425c(rdram, ctx, runtime);
}

void entry_194264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194264 inside entry_19425c (0x19425c - 0x194278)
    ctx->pc = 0x194264;
    entry_19425c(rdram, ctx, runtime);
}

void entry_194304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194304 inside entry_1942fc (0x1942fc - 0x19431c)
    ctx->pc = 0x194304;
    entry_1942fc(rdram, ctx, runtime);
}

void entry_194330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194330 inside entry_194328 (0x194328 - 0x194370)
    ctx->pc = 0x194330;
    entry_194328(rdram, ctx, runtime);
}

void entry_194378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194378 inside entry_194370 (0x194370 - 0x194384)
    ctx->pc = 0x194378;
    entry_194370(rdram, ctx, runtime);
}

void entry_194388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194388 inside entry_194384 (0x194384 - 0x194398)
    ctx->pc = 0x194388;
    entry_194384(rdram, ctx, runtime);
}

void entry_194474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194474 inside update_pausemenu_active (0x1943e8 - 0x1944b4)
    ctx->pc = 0x194474;
    update_pausemenu_active(rdram, ctx, runtime);
}

void entry_19448c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19448c inside update_pausemenu_active (0x1943e8 - 0x1944b4)
    ctx->pc = 0x19448c;
    update_pausemenu_active(rdram, ctx, runtime);
}

void entry_19449c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19449c inside update_pausemenu_active (0x1943e8 - 0x1944b4)
    ctx->pc = 0x19449c;
    update_pausemenu_active(rdram, ctx, runtime);
}

void entry_1944f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1944f8 inside entry_1944f0 (0x1944f0 - 0x194508)
    ctx->pc = 0x1944f8;
    entry_1944f0(rdram, ctx, runtime);
}

void entry_194548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194548 inside entry_194544 (0x194544 - 0x19457c)
    ctx->pc = 0x194548;
    entry_194544(rdram, ctx, runtime);
}

void entry_19456c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19456c inside entry_194544 (0x194544 - 0x19457c)
    ctx->pc = 0x19456c;
    entry_194544(rdram, ctx, runtime);
}

void entry_194574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194574 inside entry_194544 (0x194544 - 0x19457c)
    ctx->pc = 0x194574;
    entry_194544(rdram, ctx, runtime);
}

void entry_1945a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1945a8 inside entry_1945a0 (0x1945a0 - 0x1945b8)
    ctx->pc = 0x1945a8;
    entry_1945a0(rdram, ctx, runtime);
}

void entry_1945ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1945ac inside entry_1945a0 (0x1945a0 - 0x1945b8)
    ctx->pc = 0x1945ac;
    entry_1945a0(rdram, ctx, runtime);
}

void entry_1945bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1945bc inside entry_1945b8 (0x1945b8 - 0x1945cc)
    ctx->pc = 0x1945bc;
    entry_1945b8(rdram, ctx, runtime);
}

void entry_1945ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1945ec inside entry_1945e4 (0x1945e4 - 0x194660)
    ctx->pc = 0x1945ec;
    entry_1945e4(rdram, ctx, runtime);
}

void entry_194630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194630 inside entry_1945e4 (0x1945e4 - 0x194660)
    ctx->pc = 0x194630;
    entry_1945e4(rdram, ctx, runtime);
}

void entry_194634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194634 inside entry_1945e4 (0x1945e4 - 0x194660)
    ctx->pc = 0x194634;
    entry_1945e4(rdram, ctx, runtime);
}

void entry_194638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194638 inside entry_1945e4 (0x1945e4 - 0x194660)
    ctx->pc = 0x194638;
    entry_1945e4(rdram, ctx, runtime);
}

void entry_194668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194668 inside entry_194660 (0x194660 - 0x194670)
    ctx->pc = 0x194668;
    entry_194660(rdram, ctx, runtime);
}

void entry_194698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194698 inside entry_194670 (0x194670 - 0x194724)
    ctx->pc = 0x194698;
    entry_194670(rdram, ctx, runtime);
}

void entry_1946c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1946c0 inside entry_194670 (0x194670 - 0x194724)
    ctx->pc = 0x1946c0;
    entry_194670(rdram, ctx, runtime);
}

void entry_1946dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1946dc inside entry_194670 (0x194670 - 0x194724)
    ctx->pc = 0x1946dc;
    entry_194670(rdram, ctx, runtime);
}

void entry_19470c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19470c inside entry_194670 (0x194670 - 0x194724)
    ctx->pc = 0x19470c;
    entry_194670(rdram, ctx, runtime);
}

void entry_19472c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19472c inside entry_194724 (0x194724 - 0x19474c)
    ctx->pc = 0x19472c;
    entry_194724(rdram, ctx, runtime);
}

void entry_194754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194754 inside entry_19474c (0x19474c - 0x194768)
    ctx->pc = 0x194754;
    entry_19474c(rdram, ctx, runtime);
}

void entry_194780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194780 inside entry_194768 (0x194768 - 0x1947d8)
    ctx->pc = 0x194780;
    entry_194768(rdram, ctx, runtime);
}

void entry_1947e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1947e0 inside entry_1947d8 (0x1947d8 - 0x1947f0)
    ctx->pc = 0x1947e0;
    entry_1947d8(rdram, ctx, runtime);
}

void entry_194800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194800 inside entry_1947f8 (0x1947f8 - 0x19483c)
    ctx->pc = 0x194800;
    entry_1947f8(rdram, ctx, runtime);
}

void entry_194898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194898 inside entry_19486c (0x19486c - 0x194954)
    ctx->pc = 0x194898;
    entry_19486c(rdram, ctx, runtime);
}

void entry_1948d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1948d4 inside entry_19486c (0x19486c - 0x194954)
    ctx->pc = 0x1948d4;
    entry_19486c(rdram, ctx, runtime);
}

void entry_1948e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1948e8 inside entry_19486c (0x19486c - 0x194954)
    ctx->pc = 0x1948e8;
    entry_19486c(rdram, ctx, runtime);
}

void entry_19492c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19492c inside entry_19486c (0x19486c - 0x194954)
    ctx->pc = 0x19492c;
    entry_19486c(rdram, ctx, runtime);
}

void entry_194940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194940 inside entry_19486c (0x19486c - 0x194954)
    ctx->pc = 0x194940;
    entry_19486c(rdram, ctx, runtime);
}

void entry_194a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194a34 inside entry_194988 (0x194988 - 0x194ab0)
    ctx->pc = 0x194a34;
    entry_194988(rdram, ctx, runtime);
}

void entry_194a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194a44 inside entry_194988 (0x194988 - 0x194ab0)
    ctx->pc = 0x194a44;
    entry_194988(rdram, ctx, runtime);
}

void entry_194a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194a74 inside entry_194988 (0x194988 - 0x194ab0)
    ctx->pc = 0x194a74;
    entry_194988(rdram, ctx, runtime);
}

void entry_194a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194a84 inside entry_194988 (0x194988 - 0x194ab0)
    ctx->pc = 0x194a84;
    entry_194988(rdram, ctx, runtime);
}

void entry_194aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194aa4 inside entry_194988 (0x194988 - 0x194ab0)
    ctx->pc = 0x194aa4;
    entry_194988(rdram, ctx, runtime);
}

void entry_194ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194ab8 inside entry_194ab0 (0x194ab0 - 0x194ad0)
    ctx->pc = 0x194ab8;
    entry_194ab0(rdram, ctx, runtime);
}

void entry_194ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194ad4 inside entry_194ad0 (0x194ad0 - 0x194ae0)
    ctx->pc = 0x194ad4;
    entry_194ad0(rdram, ctx, runtime);
}

void entry_194ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194ae8 inside entry_194ae0 (0x194ae0 - 0x194afc)
    ctx->pc = 0x194ae8;
    entry_194ae0(rdram, ctx, runtime);
}

void entry_194b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194b18 inside entry_194afc (0x194afc - 0x194b20)
    ctx->pc = 0x194b18;
    entry_194afc(rdram, ctx, runtime);
}

void entry_194b48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194b48 inside entry_194b44 (0x194b44 - 0x194b54)
    ctx->pc = 0x194b48;
    entry_194b44(rdram, ctx, runtime);
}

void entry_194be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194be8 inside entry_194be0 (0x194be0 - 0x194bf4)
    ctx->pc = 0x194be8;
    entry_194be0(rdram, ctx, runtime);
}

void entry_194c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194c84 inside entry_194c7c (0x194c7c - 0x194c90)
    ctx->pc = 0x194c84;
    entry_194c7c(rdram, ctx, runtime);
}

void entry_194cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194cd0 inside entry_194cb8 (0x194cb8 - 0x194ce0)
    ctx->pc = 0x194cd0;
    entry_194cb8(rdram, ctx, runtime);
}

void entry_194cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194cd8 inside entry_194cb8 (0x194cb8 - 0x194ce0)
    ctx->pc = 0x194cd8;
    entry_194cb8(rdram, ctx, runtime);
}

void entry_194ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194ce8 inside entry_194ce0 (0x194ce0 - 0x194cf8)
    ctx->pc = 0x194ce8;
    entry_194ce0(rdram, ctx, runtime);
}

void entry_194d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194d0c inside entry_194d08 (0x194d08 - 0x194d30)
    ctx->pc = 0x194d0c;
    entry_194d08(rdram, ctx, runtime);
}

void entry_194d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194d68 inside FUN_00194d30 (0x194d30 - 0x194da4)
    ctx->pc = 0x194d68;
    FUN_00194d30(rdram, ctx, runtime);
}

void entry_194d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194d94 inside FUN_00194d30 (0x194d30 - 0x194da4)
    ctx->pc = 0x194d94;
    FUN_00194d30(rdram, ctx, runtime);
}

void entry_194dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194dc8 inside entry_194dc0 (0x194dc0 - 0x194e08)
    ctx->pc = 0x194dc8;
    entry_194dc0(rdram, ctx, runtime);
}

void entry_194dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194dec inside entry_194dc0 (0x194dc0 - 0x194e08)
    ctx->pc = 0x194dec;
    entry_194dc0(rdram, ctx, runtime);
}

void entry_194e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194e0c inside entry_194e08 (0x194e08 - 0x194e28)
    ctx->pc = 0x194e0c;
    entry_194e08(rdram, ctx, runtime);
}

void entry_194e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194e30 inside entry_194e28 (0x194e28 - 0x194e48)
    ctx->pc = 0x194e30;
    entry_194e28(rdram, ctx, runtime);
}

void entry_194e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194e4c inside entry_194e48 (0x194e48 - 0x194e60)
    ctx->pc = 0x194e4c;
    entry_194e48(rdram, ctx, runtime);
}

void entry_194ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194ed0 inside entry_194ec0 (0x194ec0 - 0x194ee0)
    ctx->pc = 0x194ed0;
    entry_194ec0(rdram, ctx, runtime);
}

void entry_194ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194ee4 inside entry_194ee0 (0x194ee0 - 0x194eec)
    ctx->pc = 0x194ee4;
    entry_194ee0(rdram, ctx, runtime);
}

void entry_194ef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194ef0 inside entry_194eec (0x194eec - 0x194f00)
    ctx->pc = 0x194ef0;
    entry_194eec(rdram, ctx, runtime);
}

void entry_194f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194f24 inside FUN_00194f00 (0x194f00 - 0x194f2c)
    ctx->pc = 0x194f24;
    FUN_00194f00(rdram, ctx, runtime);
}

void entry_194f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194f30 inside entry_194f2c (0x194f2c - 0x194f38)
    ctx->pc = 0x194f30;
    entry_194f2c(rdram, ctx, runtime);
}

void entry_194f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x194f68 inside FUN_00194f38 (0x194f38 - 0x194f70)
    ctx->pc = 0x194f68;
    FUN_00194f38(rdram, ctx, runtime);
}

void entry_1950a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1950a0 inside entry_195058 (0x195058 - 0x1950bc)
    ctx->pc = 0x1950a0;
    entry_195058(rdram, ctx, runtime);
}

void entry_1950a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1950a4 inside entry_195058 (0x195058 - 0x1950bc)
    ctx->pc = 0x1950a4;
    entry_195058(rdram, ctx, runtime);
}

void entry_1951c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1951c0 inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x1951c0;
    entry_195130(rdram, ctx, runtime);
}

void entry_195204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195204 inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x195204;
    entry_195130(rdram, ctx, runtime);
}

void entry_195244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195244 inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x195244;
    entry_195130(rdram, ctx, runtime);
}

void entry_19525c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19525c inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x19525c;
    entry_195130(rdram, ctx, runtime);
}

void entry_1952a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1952a0 inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x1952a0;
    entry_195130(rdram, ctx, runtime);
}

void entry_1952e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1952e0 inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x1952e0;
    entry_195130(rdram, ctx, runtime);
}

void entry_1952f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1952f8 inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x1952f8;
    entry_195130(rdram, ctx, runtime);
}

void entry_19533c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19533c inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x19533c;
    entry_195130(rdram, ctx, runtime);
}

void entry_19537c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19537c inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x19537c;
    entry_195130(rdram, ctx, runtime);
}

void entry_195394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195394 inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x195394;
    entry_195130(rdram, ctx, runtime);
}

void entry_1953d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1953d8 inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x1953d8;
    entry_195130(rdram, ctx, runtime);
}

void entry_195418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195418 inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x195418;
    entry_195130(rdram, ctx, runtime);
}

void entry_195440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195440 inside entry_195130 (0x195130 - 0x195468)
    ctx->pc = 0x195440;
    entry_195130(rdram, ctx, runtime);
}

void entry_19547c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19547c inside entry_195468 (0x195468 - 0x19549c)
    ctx->pc = 0x19547c;
    entry_195468(rdram, ctx, runtime);
}

void entry_195548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195548 inside entry_195544 (0x195544 - 0x195568)
    ctx->pc = 0x195548;
    entry_195544(rdram, ctx, runtime);
}

void entry_195598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195598 inside entry_195568 (0x195568 - 0x1955d4)
    ctx->pc = 0x195598;
    entry_195568(rdram, ctx, runtime);
}

void entry_1955c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1955c0 inside entry_195568 (0x195568 - 0x1955d4)
    ctx->pc = 0x1955c0;
    entry_195568(rdram, ctx, runtime);
}

void entry_1955fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1955fc inside entry_1955ec (0x1955ec - 0x1956d4)
    ctx->pc = 0x1955fc;
    entry_1955ec(rdram, ctx, runtime);
}

void entry_195610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195610 inside entry_1955ec (0x1955ec - 0x1956d4)
    ctx->pc = 0x195610;
    entry_1955ec(rdram, ctx, runtime);
}

void entry_195640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195640 inside entry_1955ec (0x1955ec - 0x1956d4)
    ctx->pc = 0x195640;
    entry_1955ec(rdram, ctx, runtime);
}

void entry_19569c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19569c inside entry_1955ec (0x1955ec - 0x1956d4)
    ctx->pc = 0x19569c;
    entry_1955ec(rdram, ctx, runtime);
}

void entry_1956c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1956c0 inside entry_1955ec (0x1955ec - 0x1956d4)
    ctx->pc = 0x1956c0;
    entry_1955ec(rdram, ctx, runtime);
}

void entry_19570c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19570c inside entry_1956f4 (0x1956f4 - 0x195728)
    ctx->pc = 0x19570c;
    entry_1956f4(rdram, ctx, runtime);
}

void entry_1957f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1957f0 inside entry_1957cc (0x1957cc - 0x195828)
    ctx->pc = 0x1957f0;
    entry_1957cc(rdram, ctx, runtime);
}

void entry_19580c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19580c inside entry_1957cc (0x1957cc - 0x195828)
    ctx->pc = 0x19580c;
    entry_1957cc(rdram, ctx, runtime);
}

void entry_195820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195820 inside entry_1957cc (0x1957cc - 0x195828)
    ctx->pc = 0x195820;
    entry_1957cc(rdram, ctx, runtime);
}

void entry_1958d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1958d0 inside entry_1958cc (0x1958cc - 0x195928)
    ctx->pc = 0x1958d0;
    entry_1958cc(rdram, ctx, runtime);
}

void entry_1959a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1959a4 inside FUN_00195958 (0x195958 - 0x1959b8)
    ctx->pc = 0x1959a4;
    FUN_00195958(rdram, ctx, runtime);
}

void entry_1959c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1959c0 inside entry_1959b8 (0x1959b8 - 0x195a38)
    ctx->pc = 0x1959c0;
    entry_1959b8(rdram, ctx, runtime);
}

void entry_195a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195a50 inside entry_195a48 (0x195a48 - 0x195a88)
    ctx->pc = 0x195a50;
    entry_195a48(rdram, ctx, runtime);
}

void entry_195ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195ae8 inside entry_195ae4 (0x195ae4 - 0x195b0c)
    ctx->pc = 0x195ae8;
    entry_195ae4(rdram, ctx, runtime);
}

void entry_195cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195cc0 inside entry_195cb8 (0x195cb8 - 0x195ccc)
    ctx->pc = 0x195cc0;
    entry_195cb8(rdram, ctx, runtime);
}

void entry_195cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195cdc inside entry_195ccc (0x195ccc - 0x195ce4)
    ctx->pc = 0x195cdc;
    entry_195ccc(rdram, ctx, runtime);
}

void entry_195d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195d5c inside entry_195d54 (0x195d54 - 0x195d68)
    ctx->pc = 0x195d5c;
    entry_195d54(rdram, ctx, runtime);
}

void entry_195d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195d88 inside entry_195d80 (0x195d80 - 0x195d90)
    ctx->pc = 0x195d88;
    entry_195d80(rdram, ctx, runtime);
}

void entry_195d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195d94 inside entry_195d90 (0x195d90 - 0x195e2c)
    ctx->pc = 0x195d94;
    entry_195d90(rdram, ctx, runtime);
}

void entry_195d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195d9c inside entry_195d90 (0x195d90 - 0x195e2c)
    ctx->pc = 0x195d9c;
    entry_195d90(rdram, ctx, runtime);
}

void entry_195dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195dcc inside entry_195d90 (0x195d90 - 0x195e2c)
    ctx->pc = 0x195dcc;
    entry_195d90(rdram, ctx, runtime);
}

void entry_195de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195de0 inside entry_195d90 (0x195d90 - 0x195e2c)
    ctx->pc = 0x195de0;
    entry_195d90(rdram, ctx, runtime);
}

void entry_195df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195df4 inside entry_195d90 (0x195d90 - 0x195e2c)
    ctx->pc = 0x195df4;
    entry_195d90(rdram, ctx, runtime);
}

void entry_195e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195e08 inside entry_195d90 (0x195d90 - 0x195e2c)
    ctx->pc = 0x195e08;
    entry_195d90(rdram, ctx, runtime);
}

void entry_195e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195e1c inside entry_195d90 (0x195d90 - 0x195e2c)
    ctx->pc = 0x195e1c;
    entry_195d90(rdram, ctx, runtime);
}

void entry_195e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195e24 inside entry_195d90 (0x195d90 - 0x195e2c)
    ctx->pc = 0x195e24;
    entry_195d90(rdram, ctx, runtime);
}

void entry_195ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195ec0 inside entry_195eb4 (0x195eb4 - 0x195ecc)
    ctx->pc = 0x195ec0;
    entry_195eb4(rdram, ctx, runtime);
}

void entry_195f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195f08 inside entry_195edc (0x195edc - 0x195f18)
    ctx->pc = 0x195f08;
    entry_195edc(rdram, ctx, runtime);
}

void entry_195f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195f6c inside entry_195f58 (0x195f58 - 0x195fa8)
    ctx->pc = 0x195f6c;
    entry_195f58(rdram, ctx, runtime);
}

void entry_195f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195f94 inside entry_195f58 (0x195f58 - 0x195fa8)
    ctx->pc = 0x195f94;
    entry_195f58(rdram, ctx, runtime);
}

void entry_195fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x195fe4 inside entry_195fc0 (0x195fc0 - 0x195fec)
    ctx->pc = 0x195fe4;
    entry_195fc0(rdram, ctx, runtime);
}

void entry_196030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196030 inside entry_195ff4 (0x195ff4 - 0x19606c)
    ctx->pc = 0x196030;
    entry_195ff4(rdram, ctx, runtime);
}

void entry_196074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196074 inside entry_19606c (0x19606c - 0x196080)
    ctx->pc = 0x196074;
    entry_19606c(rdram, ctx, runtime);
}

void entry_19609c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19609c inside entry_196098 (0x196098 - 0x1960b0)
    ctx->pc = 0x19609c;
    entry_196098(rdram, ctx, runtime);
}

void entry_1960a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1960a4 inside entry_196098 (0x196098 - 0x1960b0)
    ctx->pc = 0x1960a4;
    entry_196098(rdram, ctx, runtime);
}

void entry_1960f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1960f8 inside entry_1960ec (0x1960ec - 0x196104)
    ctx->pc = 0x1960f8;
    entry_1960ec(rdram, ctx, runtime);
}

void entry_1960fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1960fc inside entry_1960ec (0x1960ec - 0x196104)
    ctx->pc = 0x1960fc;
    entry_1960ec(rdram, ctx, runtime);
}

void entry_196148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196148 inside entry_196104 (0x196104 - 0x196164)
    ctx->pc = 0x196148;
    entry_196104(rdram, ctx, runtime);
}

void entry_196154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196154 inside entry_196104 (0x196104 - 0x196164)
    ctx->pc = 0x196154;
    entry_196104(rdram, ctx, runtime);
}

void entry_19616c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19616c inside entry_196164 (0x196164 - 0x196178)
    ctx->pc = 0x19616c;
    entry_196164(rdram, ctx, runtime);
}

void entry_196190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196190 inside entry_19618c (0x19618c - 0x1961a8)
    ctx->pc = 0x196190;
    entry_19618c(rdram, ctx, runtime);
}

void entry_1961ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1961ac inside entry_1961a8 (0x1961a8 - 0x1961c0)
    ctx->pc = 0x1961ac;
    entry_1961a8(rdram, ctx, runtime);
}

void entry_1961b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1961b0 inside entry_1961a8 (0x1961a8 - 0x1961c0)
    ctx->pc = 0x1961b0;
    entry_1961a8(rdram, ctx, runtime);
}

void entry_1962b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1962b8 inside entry_19627c (0x19627c - 0x1962c8)
    ctx->pc = 0x1962b8;
    entry_19627c(rdram, ctx, runtime);
}

void entry_1962d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1962d8 inside entry_1962c8 (0x1962c8 - 0x1962e0)
    ctx->pc = 0x1962d8;
    entry_1962c8(rdram, ctx, runtime);
}

void entry_1962f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1962f0 inside entry_1962e0 (0x1962e0 - 0x1962f8)
    ctx->pc = 0x1962f0;
    entry_1962e0(rdram, ctx, runtime);
}

void entry_196314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196314 inside entry_196310 (0x196310 - 0x196330)
    ctx->pc = 0x196314;
    entry_196310(rdram, ctx, runtime);
}

void entry_196394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196394 inside entry_196360 (0x196360 - 0x1963cc)
    ctx->pc = 0x196394;
    entry_196360(rdram, ctx, runtime);
}

void entry_1964a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1964a8 inside entry_196494 (0x196494 - 0x1964b0)
    ctx->pc = 0x1964a8;
    entry_196494(rdram, ctx, runtime);
}

void entry_1964d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1964d8 inside entry_1964d0 (0x1964d0 - 0x1964e0)
    ctx->pc = 0x1964d8;
    entry_1964d0(rdram, ctx, runtime);
}

void entry_19656c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19656c inside entry_19655c (0x19655c - 0x196574)
    ctx->pc = 0x19656c;
    entry_19655c(rdram, ctx, runtime);
}

void entry_196598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196598 inside entry_196574 (0x196574 - 0x1965a0)
    ctx->pc = 0x196598;
    entry_196574(rdram, ctx, runtime);
}

void entry_1965b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1965b0 inside entry_1965a0 (0x1965a0 - 0x1965f8)
    ctx->pc = 0x1965b0;
    entry_1965a0(rdram, ctx, runtime);
}

void entry_1965d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1965d8 inside entry_1965a0 (0x1965a0 - 0x1965f8)
    ctx->pc = 0x1965d8;
    entry_1965a0(rdram, ctx, runtime);
}

void entry_1965fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1965fc inside entry_1965f8 (0x1965f8 - 0x19660c)
    ctx->pc = 0x1965fc;
    entry_1965f8(rdram, ctx, runtime);
}

void entry_196604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196604 inside entry_1965f8 (0x1965f8 - 0x19660c)
    ctx->pc = 0x196604;
    entry_1965f8(rdram, ctx, runtime);
}

void entry_19663c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19663c inside entry_196638 (0x196638 - 0x196644)
    ctx->pc = 0x19663c;
    entry_196638(rdram, ctx, runtime);
}

void entry_19665c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19665c inside entry_196644 (0x196644 - 0x196664)
    ctx->pc = 0x19665c;
    entry_196644(rdram, ctx, runtime);
}

void entry_1966a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1966a8 inside entry_196694 (0x196694 - 0x1966b4)
    ctx->pc = 0x1966a8;
    entry_196694(rdram, ctx, runtime);
}

void entry_1966ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1966ac inside entry_196694 (0x196694 - 0x1966b4)
    ctx->pc = 0x1966ac;
    entry_196694(rdram, ctx, runtime);
}

void entry_1966c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1966c4 inside entry_1966b4 (0x1966b4 - 0x1966f0)
    ctx->pc = 0x1966c4;
    entry_1966b4(rdram, ctx, runtime);
}

void entry_1966d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1966d8 inside entry_1966b4 (0x1966b4 - 0x1966f0)
    ctx->pc = 0x1966d8;
    entry_1966b4(rdram, ctx, runtime);
}

void entry_196718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196718 inside entry_19670c (0x19670c - 0x196734)
    ctx->pc = 0x196718;
    entry_19670c(rdram, ctx, runtime);
}

void entry_196780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196780 inside entry_19673c (0x19673c - 0x196794)
    ctx->pc = 0x196780;
    entry_19673c(rdram, ctx, runtime);
}

void entry_1967b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1967b0 inside entry_196794 (0x196794 - 0x1967c8)
    ctx->pc = 0x1967b0;
    entry_196794(rdram, ctx, runtime);
}

void entry_1967bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1967bc inside entry_196794 (0x196794 - 0x1967c8)
    ctx->pc = 0x1967bc;
    entry_196794(rdram, ctx, runtime);
}

void entry_196888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196888 inside entry_196874 (0x196874 - 0x1968ac)
    ctx->pc = 0x196888;
    entry_196874(rdram, ctx, runtime);
}

void entry_196890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196890 inside entry_196874 (0x196874 - 0x1968ac)
    ctx->pc = 0x196890;
    entry_196874(rdram, ctx, runtime);
}

void entry_1968a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1968a4 inside entry_196874 (0x196874 - 0x1968ac)
    ctx->pc = 0x1968a4;
    entry_196874(rdram, ctx, runtime);
}

void entry_1968c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1968c8 inside entry_1968ac (0x1968ac - 0x1968d8)
    ctx->pc = 0x1968c8;
    entry_1968ac(rdram, ctx, runtime);
}

void entry_1968d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1968d0 inside entry_1968ac (0x1968ac - 0x1968d8)
    ctx->pc = 0x1968d0;
    entry_1968ac(rdram, ctx, runtime);
}

void entry_1968e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1968e8 inside entry_1968d8 (0x1968d8 - 0x196900)
    ctx->pc = 0x1968e8;
    entry_1968d8(rdram, ctx, runtime);
}

void entry_196b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196b20 inside entry_196b10 (0x196b10 - 0x196b30)
    ctx->pc = 0x196b20;
    entry_196b10(rdram, ctx, runtime);
}

void entry_196b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196b38 inside entry_196b30 (0x196b30 - 0x196b4c)
    ctx->pc = 0x196b38;
    entry_196b30(rdram, ctx, runtime);
}

void entry_196cfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196cfc inside entry_196cac (0x196cac - 0x196db4)
    ctx->pc = 0x196cfc;
    entry_196cac(rdram, ctx, runtime);
}

void entry_196d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196d10 inside entry_196cac (0x196cac - 0x196db4)
    ctx->pc = 0x196d10;
    entry_196cac(rdram, ctx, runtime);
}

void entry_196d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196d70 inside entry_196cac (0x196cac - 0x196db4)
    ctx->pc = 0x196d70;
    entry_196cac(rdram, ctx, runtime);
}

void entry_196d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196d84 inside entry_196cac (0x196cac - 0x196db4)
    ctx->pc = 0x196d84;
    entry_196cac(rdram, ctx, runtime);
}

void entry_196e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196e90 inside entry_196e80 (0x196e80 - 0x196eb0)
    ctx->pc = 0x196e90;
    entry_196e80(rdram, ctx, runtime);
}

void entry_196e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196e94 inside entry_196e80 (0x196e80 - 0x196eb0)
    ctx->pc = 0x196e94;
    entry_196e80(rdram, ctx, runtime);
}

void entry_196e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196e9c inside entry_196e80 (0x196e80 - 0x196eb0)
    ctx->pc = 0x196e9c;
    entry_196e80(rdram, ctx, runtime);
}

void entry_196f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196f14 inside entry_196ef4 (0x196ef4 - 0x196f98)
    ctx->pc = 0x196f14;
    entry_196ef4(rdram, ctx, runtime);
}

void entry_196f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196f34 inside entry_196ef4 (0x196ef4 - 0x196f98)
    ctx->pc = 0x196f34;
    entry_196ef4(rdram, ctx, runtime);
}

void entry_196f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196f40 inside entry_196ef4 (0x196ef4 - 0x196f98)
    ctx->pc = 0x196f40;
    entry_196ef4(rdram, ctx, runtime);
}

void entry_196f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x196f90 inside entry_196ef4 (0x196ef4 - 0x196f98)
    ctx->pc = 0x196f90;
    entry_196ef4(rdram, ctx, runtime);
}

void entry_1970e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1970e4 inside entry_197088 (0x197088 - 0x197144)
    ctx->pc = 0x1970e4;
    entry_197088(rdram, ctx, runtime);
}

void entry_1970f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1970f0 inside entry_197088 (0x197088 - 0x197144)
    ctx->pc = 0x1970f0;
    entry_197088(rdram, ctx, runtime);
}

void entry_1970f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1970f8 inside entry_197088 (0x197088 - 0x197144)
    ctx->pc = 0x1970f8;
    entry_197088(rdram, ctx, runtime);
}

void entry_197110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197110 inside entry_197088 (0x197088 - 0x197144)
    ctx->pc = 0x197110;
    entry_197088(rdram, ctx, runtime);
}

void entry_197118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197118 inside entry_197088 (0x197088 - 0x197144)
    ctx->pc = 0x197118;
    entry_197088(rdram, ctx, runtime);
}

void entry_1972a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1972a8 inside entry_197290 (0x197290 - 0x1972dc)
    ctx->pc = 0x1972a8;
    entry_197290(rdram, ctx, runtime);
}

void entry_197394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197394 inside entry_197374 (0x197374 - 0x1973d8)
    ctx->pc = 0x197394;
    entry_197374(rdram, ctx, runtime);
}

void entry_197398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197398 inside entry_197374 (0x197374 - 0x1973d8)
    ctx->pc = 0x197398;
    entry_197374(rdram, ctx, runtime);
}

void entry_1973a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1973a0 inside entry_197374 (0x197374 - 0x1973d8)
    ctx->pc = 0x1973a0;
    entry_197374(rdram, ctx, runtime);
}

void entry_197424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197424 inside FUN_001973d8 (0x1973d8 - 0x19744c)
    ctx->pc = 0x197424;
    FUN_001973d8(rdram, ctx, runtime);
}

void entry_1974c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1974c8 inside entry_1974c4 (0x1974c4 - 0x1974d8)
    ctx->pc = 0x1974c8;
    entry_1974c4(rdram, ctx, runtime);
}

void entry_19753c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19753c inside entry_197538 (0x197538 - 0x197564)
    ctx->pc = 0x19753c;
    entry_197538(rdram, ctx, runtime);
}

void entry_1975cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1975cc inside entry_1975b4 (0x1975b4 - 0x197618)
    ctx->pc = 0x1975cc;
    entry_1975b4(rdram, ctx, runtime);
}

void entry_1975d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1975d0 inside entry_1975b4 (0x1975b4 - 0x197618)
    ctx->pc = 0x1975d0;
    entry_1975b4(rdram, ctx, runtime);
}

void entry_19768c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19768c inside entry_197688 (0x197688 - 0x197694)
    ctx->pc = 0x19768c;
    entry_197688(rdram, ctx, runtime);
}

void entry_197698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197698 inside entry_197694 (0x197694 - 0x1976a0)
    ctx->pc = 0x197698;
    entry_197694(rdram, ctx, runtime);
}

void entry_197730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197730 inside entry_1976ec (0x1976ec - 0x197758)
    ctx->pc = 0x197730;
    entry_1976ec(rdram, ctx, runtime);
}

void entry_19774c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19774c inside entry_1976ec (0x1976ec - 0x197758)
    ctx->pc = 0x19774c;
    entry_1976ec(rdram, ctx, runtime);
}

void entry_197750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197750 inside entry_1976ec (0x1976ec - 0x197758)
    ctx->pc = 0x197750;
    entry_1976ec(rdram, ctx, runtime);
}

void entry_197774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197774 inside entry_197770 (0x197770 - 0x197788)
    ctx->pc = 0x197774;
    entry_197770(rdram, ctx, runtime);
}

void entry_1977b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1977b8 inside entry_1977b4 (0x1977b4 - 0x1977d0)
    ctx->pc = 0x1977b8;
    entry_1977b4(rdram, ctx, runtime);
}

void entry_197800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197800 inside entry_1977f8 (0x1977f8 - 0x197810)
    ctx->pc = 0x197800;
    entry_1977f8(rdram, ctx, runtime);
}

void entry_19783c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19783c inside entry_197838 (0x197838 - 0x197848)
    ctx->pc = 0x19783c;
    entry_197838(rdram, ctx, runtime);
}

void entry_197898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197898 inside FUN_00197848 (0x197848 - 0x1978c0)
    ctx->pc = 0x197898;
    FUN_00197848(rdram, ctx, runtime);
}

void entry_1978a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1978a0 inside FUN_00197848 (0x197848 - 0x1978c0)
    ctx->pc = 0x1978a0;
    FUN_00197848(rdram, ctx, runtime);
}

void entry_1978dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1978dc inside entry_1978c0 (0x1978c0 - 0x1978f8)
    ctx->pc = 0x1978dc;
    entry_1978c0(rdram, ctx, runtime);
}

void entry_1978e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1978e4 inside entry_1978c0 (0x1978c0 - 0x1978f8)
    ctx->pc = 0x1978e4;
    entry_1978c0(rdram, ctx, runtime);
}

void entry_197910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197910 inside entry_197904 (0x197904 - 0x19793c)
    ctx->pc = 0x197910;
    entry_197904(rdram, ctx, runtime);
}

void entry_19792c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19792c inside entry_197904 (0x197904 - 0x19793c)
    ctx->pc = 0x19792c;
    entry_197904(rdram, ctx, runtime);
}

void entry_1979e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1979e4 inside entry_1979d0 (0x1979d0 - 0x197a08)
    ctx->pc = 0x1979e4;
    entry_1979d0(rdram, ctx, runtime);
}

void entry_1979ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1979ec inside entry_1979d0 (0x1979d0 - 0x197a08)
    ctx->pc = 0x1979ec;
    entry_1979d0(rdram, ctx, runtime);
}

void entry_197ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197ba0 inside entry_197b44 (0x197b44 - 0x197c14)
    ctx->pc = 0x197ba0;
    entry_197b44(rdram, ctx, runtime);
}

void entry_197bac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197bac inside entry_197b44 (0x197b44 - 0x197c14)
    ctx->pc = 0x197bac;
    entry_197b44(rdram, ctx, runtime);
}

void entry_197bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197bb0 inside entry_197b44 (0x197b44 - 0x197c14)
    ctx->pc = 0x197bb0;
    entry_197b44(rdram, ctx, runtime);
}

void entry_197ca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197ca0 inside entry_197c64 (0x197c64 - 0x197ce8)
    ctx->pc = 0x197ca0;
    entry_197c64(rdram, ctx, runtime);
}

void entry_197cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197cf8 inside entry_197ce8 (0x197ce8 - 0x197d44)
    ctx->pc = 0x197cf8;
    entry_197ce8(rdram, ctx, runtime);
}

void entry_197d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197d80 inside entry_197d70 (0x197d70 - 0x197dcc)
    ctx->pc = 0x197d80;
    entry_197d70(rdram, ctx, runtime);
}

void entry_197de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197de0 inside entry_197dcc (0x197dcc - 0x197e28)
    ctx->pc = 0x197de0;
    entry_197dcc(rdram, ctx, runtime);
}

void entry_197ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197ec0 inside entry_197eb8 (0x197eb8 - 0x197ecc)
    ctx->pc = 0x197ec0;
    entry_197eb8(rdram, ctx, runtime);
}

void entry_197ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197ec4 inside entry_197eb8 (0x197eb8 - 0x197ecc)
    ctx->pc = 0x197ec4;
    entry_197eb8(rdram, ctx, runtime);
}

void entry_197ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197ed0 inside entry_197ecc (0x197ecc - 0x197f10)
    ctx->pc = 0x197ed0;
    entry_197ecc(rdram, ctx, runtime);
}

void entry_197f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197f58 inside entry_197f34 (0x197f34 - 0x197f98)
    ctx->pc = 0x197f58;
    entry_197f34(rdram, ctx, runtime);
}

void entry_197f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197f6c inside entry_197f34 (0x197f34 - 0x197f98)
    ctx->pc = 0x197f6c;
    entry_197f34(rdram, ctx, runtime);
}

void entry_197f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197f74 inside entry_197f34 (0x197f34 - 0x197f98)
    ctx->pc = 0x197f74;
    entry_197f34(rdram, ctx, runtime);
}

void entry_197f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x197f80 inside entry_197f34 (0x197f34 - 0x197f98)
    ctx->pc = 0x197f80;
    entry_197f34(rdram, ctx, runtime);
}

void entry_198010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198010 inside entry_198008 (0x198008 - 0x198030)
    ctx->pc = 0x198010;
    entry_198008(rdram, ctx, runtime);
}

void entry_198078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198078 inside entry_198074 (0x198074 - 0x198090)
    ctx->pc = 0x198078;
    entry_198074(rdram, ctx, runtime);
}

void entry_19807c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19807c inside entry_198074 (0x198074 - 0x198090)
    ctx->pc = 0x19807c;
    entry_198074(rdram, ctx, runtime);
}

void entry_1981bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1981bc inside entry_198170 (0x198170 - 0x1981e4)
    ctx->pc = 0x1981bc;
    entry_198170(rdram, ctx, runtime);
}

void entry_1981cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1981cc inside entry_198170 (0x198170 - 0x1981e4)
    ctx->pc = 0x1981cc;
    entry_198170(rdram, ctx, runtime);
}

void entry_198240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198240 inside entry_19823c (0x19823c - 0x198264)
    ctx->pc = 0x198240;
    entry_19823c(rdram, ctx, runtime);
}

void entry_198250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198250 inside entry_19823c (0x19823c - 0x198264)
    ctx->pc = 0x198250;
    entry_19823c(rdram, ctx, runtime);
}

void entry_198278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198278 inside entry_198264 (0x198264 - 0x198284)
    ctx->pc = 0x198278;
    entry_198264(rdram, ctx, runtime);
}

void entry_19827c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19827c inside entry_198264 (0x198264 - 0x198284)
    ctx->pc = 0x19827c;
    entry_198264(rdram, ctx, runtime);
}

void entry_198288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198288 inside entry_198284 (0x198284 - 0x1982a0)
    ctx->pc = 0x198288;
    entry_198284(rdram, ctx, runtime);
}

void entry_1982d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1982d0 inside FUN_001982a0 (0x1982a0 - 0x1982d8)
    ctx->pc = 0x1982d0;
    FUN_001982a0(rdram, ctx, runtime);
}

void entry_1982e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1982e8 inside entry_1982d8 (0x1982d8 - 0x1982fc)
    ctx->pc = 0x1982e8;
    entry_1982d8(rdram, ctx, runtime);
}

void entry_1982f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1982f4 inside entry_1982d8 (0x1982d8 - 0x1982fc)
    ctx->pc = 0x1982f4;
    entry_1982d8(rdram, ctx, runtime);
}

void entry_198300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198300 inside entry_1982fc (0x1982fc - 0x198318)
    ctx->pc = 0x198300;
    entry_1982fc(rdram, ctx, runtime);
}

void entry_198304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198304 inside entry_1982fc (0x1982fc - 0x198318)
    ctx->pc = 0x198304;
    entry_1982fc(rdram, ctx, runtime);
}

void entry_198354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198354 inside UpdatePuffcGoal__FP5PUFFCi (0x198318 - 0x198370)
    ctx->pc = 0x198354;
    UpdatePuffcGoal__FP5PUFFCi(rdram, ctx, runtime);
}

void entry_198368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198368 inside UpdatePuffcGoal__FP5PUFFCi (0x198318 - 0x198370)
    ctx->pc = 0x198368;
    UpdatePuffcGoal__FP5PUFFCi(rdram, ctx, runtime);
}

void entry_198408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198408 inside entry_198400 (0x198400 - 0x198420)
    ctx->pc = 0x198408;
    entry_198400(rdram, ctx, runtime);
}

void entry_198418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198418 inside entry_198400 (0x198400 - 0x198420)
    ctx->pc = 0x198418;
    entry_198400(rdram, ctx, runtime);
}

void entry_198460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198460 inside entry_198420 (0x198420 - 0x198484)
    ctx->pc = 0x198460;
    entry_198420(rdram, ctx, runtime);
}

void entry_198470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198470 inside entry_198420 (0x198420 - 0x198484)
    ctx->pc = 0x198470;
    entry_198420(rdram, ctx, runtime);
}

void entry_198488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198488 inside entry_198484 (0x198484 - 0x198490)
    ctx->pc = 0x198488;
    entry_198484(rdram, ctx, runtime);
}

void entry_198498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198498 inside entry_198490 (0x198490 - 0x1984a0)
    ctx->pc = 0x198498;
    entry_198490(rdram, ctx, runtime);
}

void entry_1984a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1984a4 inside entry_1984a0 (0x1984a0 - 0x1984b8)
    ctx->pc = 0x1984a4;
    entry_1984a0(rdram, ctx, runtime);
}

void entry_198560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198560 inside entry_19855c (0x19855c - 0x198570)
    ctx->pc = 0x198560;
    entry_19855c(rdram, ctx, runtime);
}

void entry_1985c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1985c0 inside entry_198584 (0x198584 - 0x198660)
    ctx->pc = 0x1985c0;
    entry_198584(rdram, ctx, runtime);
}

void entry_198620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198620 inside entry_198584 (0x198584 - 0x198660)
    ctx->pc = 0x198620;
    entry_198584(rdram, ctx, runtime);
}

void entry_1986c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1986c0 inside entry_198660 (0x198660 - 0x1986d8)
    ctx->pc = 0x1986c0;
    entry_198660(rdram, ctx, runtime);
}

void entry_1986d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1986d0 inside entry_198660 (0x198660 - 0x1986d8)
    ctx->pc = 0x1986d0;
    entry_198660(rdram, ctx, runtime);
}

void entry_1986dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1986dc inside entry_1986d8 (0x1986d8 - 0x1986e8)
    ctx->pc = 0x1986dc;
    entry_1986d8(rdram, ctx, runtime);
}

void entry_198734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198734 inside entry_19870c (0x19870c - 0x198760)
    ctx->pc = 0x198734;
    entry_19870c(rdram, ctx, runtime);
}

void entry_198748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198748 inside entry_19870c (0x19870c - 0x198760)
    ctx->pc = 0x198748;
    entry_19870c(rdram, ctx, runtime);
}

void entry_19874c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19874c inside entry_19870c (0x19870c - 0x198760)
    ctx->pc = 0x19874c;
    entry_19870c(rdram, ctx, runtime);
}

void entry_198834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198834 inside entry_1987e4 (0x1987e4 - 0x198840)
    ctx->pc = 0x198834;
    entry_1987e4(rdram, ctx, runtime);
}

void entry_198838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198838 inside entry_1987e4 (0x1987e4 - 0x198840)
    ctx->pc = 0x198838;
    entry_1987e4(rdram, ctx, runtime);
}

void entry_198894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198894 inside entry_19888c (0x19888c - 0x198920)
    ctx->pc = 0x198894;
    entry_19888c(rdram, ctx, runtime);
}

void entry_19889c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19889c inside entry_19888c (0x19888c - 0x198920)
    ctx->pc = 0x19889c;
    entry_19888c(rdram, ctx, runtime);
}

void entry_1988e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1988e8 inside entry_19888c (0x19888c - 0x198920)
    ctx->pc = 0x1988e8;
    entry_19888c(rdram, ctx, runtime);
}

void entry_198904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198904 inside entry_19888c (0x19888c - 0x198920)
    ctx->pc = 0x198904;
    entry_19888c(rdram, ctx, runtime);
}

void entry_198908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198908 inside entry_19888c (0x19888c - 0x198920)
    ctx->pc = 0x198908;
    entry_19888c(rdram, ctx, runtime);
}

void entry_198974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198974 inside entry_19895c (0x19895c - 0x198980)
    ctx->pc = 0x198974;
    entry_19895c(rdram, ctx, runtime);
}

void entry_198a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198a18 inside entry_1989d8 (0x1989d8 - 0x198a48)
    ctx->pc = 0x198a18;
    entry_1989d8(rdram, ctx, runtime);
}

void entry_198a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198a64 inside entry_198a48 (0x198a48 - 0x198a88)
    ctx->pc = 0x198a64;
    entry_198a48(rdram, ctx, runtime);
}

void entry_198ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198ac0 inside entry_198aac (0x198aac - 0x198ad0)
    ctx->pc = 0x198ac0;
    entry_198aac(rdram, ctx, runtime);
}

void entry_198af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198af8 inside entry_198ad0 (0x198ad0 - 0x198b28)
    ctx->pc = 0x198af8;
    entry_198ad0(rdram, ctx, runtime);
}

void entry_198b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198b08 inside entry_198ad0 (0x198ad0 - 0x198b28)
    ctx->pc = 0x198b08;
    entry_198ad0(rdram, ctx, runtime);
}

void entry_198b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198b60 inside entry_198b50 (0x198b50 - 0x198b6c)
    ctx->pc = 0x198b60;
    entry_198b50(rdram, ctx, runtime);
}

void entry_198b74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198b74 inside entry_198b6c (0x198b6c - 0x198b80)
    ctx->pc = 0x198b74;
    entry_198b6c(rdram, ctx, runtime);
}

void entry_198b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198b90 inside entry_198b80 (0x198b80 - 0x198ba0)
    ctx->pc = 0x198b90;
    entry_198b80(rdram, ctx, runtime);
}

void entry_198bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198bbc inside entry_198bb8 (0x198bb8 - 0x198bd8)
    ctx->pc = 0x198bbc;
    entry_198bb8(rdram, ctx, runtime);
}

void entry_198c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198c8c inside entry_198c1c (0x198c1c - 0x198ca8)
    ctx->pc = 0x198c8c;
    entry_198c1c(rdram, ctx, runtime);
}

void entry_198c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198c98 inside entry_198c1c (0x198c1c - 0x198ca8)
    ctx->pc = 0x198c98;
    entry_198c1c(rdram, ctx, runtime);
}

void entry_198d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198d30 inside entry_198ca8 (0x198ca8 - 0x198d7c)
    ctx->pc = 0x198d30;
    entry_198ca8(rdram, ctx, runtime);
}

void entry_198d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198d3c inside entry_198ca8 (0x198ca8 - 0x198d7c)
    ctx->pc = 0x198d3c;
    entry_198ca8(rdram, ctx, runtime);
}

void entry_198d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198d90 inside entry_198d8c (0x198d8c - 0x198da8)
    ctx->pc = 0x198d90;
    entry_198d8c(rdram, ctx, runtime);
}

void entry_198d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198d94 inside entry_198d8c (0x198d8c - 0x198da8)
    ctx->pc = 0x198d94;
    entry_198d8c(rdram, ctx, runtime);
}

void entry_198df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198df0 inside entry_198dd0 (0x198dd0 - 0x198e14)
    ctx->pc = 0x198df0;
    entry_198dd0(rdram, ctx, runtime);
}

void entry_198e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198e1c inside entry_198e14 (0x198e14 - 0x198e2c)
    ctx->pc = 0x198e1c;
    entry_198e14(rdram, ctx, runtime);
}

void entry_198ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198ec4 inside entry_198eac (0x198eac - 0x198ed8)
    ctx->pc = 0x198ec4;
    entry_198eac(rdram, ctx, runtime);
}

void entry_198ec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198ec8 inside entry_198eac (0x198eac - 0x198ed8)
    ctx->pc = 0x198ec8;
    entry_198eac(rdram, ctx, runtime);
}

void entry_198f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198f40 inside entry_198f1c (0x198f1c - 0x198f90)
    ctx->pc = 0x198f40;
    entry_198f1c(rdram, ctx, runtime);
}

void entry_198f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198f50 inside entry_198f1c (0x198f1c - 0x198f90)
    ctx->pc = 0x198f50;
    entry_198f1c(rdram, ctx, runtime);
}

void entry_198f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198f64 inside entry_198f1c (0x198f1c - 0x198f90)
    ctx->pc = 0x198f64;
    entry_198f1c(rdram, ctx, runtime);
}

void entry_198f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198f9c inside entry_198f90 (0x198f90 - 0x198fb0)
    ctx->pc = 0x198f9c;
    entry_198f90(rdram, ctx, runtime);
}

void entry_198fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198fa0 inside entry_198f90 (0x198f90 - 0x198fb0)
    ctx->pc = 0x198fa0;
    entry_198f90(rdram, ctx, runtime);
}

void entry_198fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x198fec inside entry_198fe0 (0x198fe0 - 0x199000)
    ctx->pc = 0x198fec;
    entry_198fe0(rdram, ctx, runtime);
}

void entry_199050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199050 inside entry_199048 (0x199048 - 0x199070)
    ctx->pc = 0x199050;
    entry_199048(rdram, ctx, runtime);
}

void entry_199120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199120 inside entry_199118 (0x199118 - 0x199138)
    ctx->pc = 0x199120;
    entry_199118(rdram, ctx, runtime);
}

void entry_199278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199278 inside entry_199260 (0x199260 - 0x19928c)
    ctx->pc = 0x199278;
    entry_199260(rdram, ctx, runtime);
}

void entry_1992b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1992b8 inside entry_19928c (0x19928c - 0x19931c)
    ctx->pc = 0x1992b8;
    entry_19928c(rdram, ctx, runtime);
}

void entry_1992bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1992bc inside entry_19928c (0x19928c - 0x19931c)
    ctx->pc = 0x1992bc;
    entry_19928c(rdram, ctx, runtime);
}

void entry_1992cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1992cc inside entry_19928c (0x19928c - 0x19931c)
    ctx->pc = 0x1992cc;
    entry_19928c(rdram, ctx, runtime);
}

void entry_199300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199300 inside entry_19928c (0x19928c - 0x19931c)
    ctx->pc = 0x199300;
    entry_19928c(rdram, ctx, runtime);
}

void entry_19933c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19933c inside entry_19932c (0x19932c - 0x199350)
    ctx->pc = 0x19933c;
    entry_19932c(rdram, ctx, runtime);
}

void entry_1993b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1993b8 inside AddLockgLock__FP5LOCKG3OID (0x199398 - 0x1993c0)
    ctx->pc = 0x1993b8;
    AddLockgLock__FP5LOCKG3OID(rdram, ctx, runtime);
}

void entry_199468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199468 inside entry_199460 (0x199460 - 0x19948c)
    ctx->pc = 0x199468;
    entry_199460(rdram, ctx, runtime);
}

void entry_1994b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1994b4 inside entry_1994a8 (0x1994a8 - 0x1994c8)
    ctx->pc = 0x1994b4;
    entry_1994a8(rdram, ctx, runtime);
}

void entry_19957c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19957c inside entry_199568 (0x199568 - 0x199598)
    ctx->pc = 0x19957c;
    entry_199568(rdram, ctx, runtime);
}

void entry_1995fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1995fc inside entry_1995f8 (0x1995f8 - 0x199614)
    ctx->pc = 0x1995fc;
    entry_1995f8(rdram, ctx, runtime);
}

void entry_199668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199668 inside entry_199614 (0x199614 - 0x199678)
    ctx->pc = 0x199668;
    entry_199614(rdram, ctx, runtime);
}

void entry_19967c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19967c inside entry_199678 (0x199678 - 0x199698)
    ctx->pc = 0x19967c;
    entry_199678(rdram, ctx, runtime);
}

void entry_1997f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1997f8 inside entry_199788 (0x199788 - 0x199838)
    ctx->pc = 0x1997f8;
    entry_199788(rdram, ctx, runtime);
}

void entry_19983c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19983c inside entry_199838 (0x199838 - 0x199850)
    ctx->pc = 0x19983c;
    entry_199838(rdram, ctx, runtime);
}

void entry_199840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199840 inside entry_199838 (0x199838 - 0x199850)
    ctx->pc = 0x199840;
    entry_199838(rdram, ctx, runtime);
}

void entry_1998c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1998c4 inside OnClueSmack__FP4CLUE (0x199850 - 0x19997c)
    ctx->pc = 0x1998c4;
    OnClueSmack__FP4CLUE(rdram, ctx, runtime);
}

void entry_199900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199900 inside OnClueSmack__FP4CLUE (0x199850 - 0x19997c)
    ctx->pc = 0x199900;
    OnClueSmack__FP4CLUE(rdram, ctx, runtime);
}

void entry_199928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199928 inside OnClueSmack__FP4CLUE (0x199850 - 0x19997c)
    ctx->pc = 0x199928;
    OnClueSmack__FP4CLUE(rdram, ctx, runtime);
}

void entry_199980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199980 inside entry_19997c (0x19997c - 0x1999a0)
    ctx->pc = 0x199980;
    entry_19997c(rdram, ctx, runtime);
}

void entry_1999b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1999b4 inside entry_1999b0 (0x1999b0 - 0x1999d0)
    ctx->pc = 0x1999b4;
    entry_1999b0(rdram, ctx, runtime);
}

void entry_199a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199a78 inside entry_199a74 (0x199a74 - 0x199a9c)
    ctx->pc = 0x199a78;
    entry_199a74(rdram, ctx, runtime);
}

void entry_199ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199ac8 inside entry_199abc (0x199abc - 0x199ad0)
    ctx->pc = 0x199ac8;
    entry_199abc(rdram, ctx, runtime);
}

void entry_199b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199b9c inside entry_199b40 (0x199b40 - 0x199bdc)
    ctx->pc = 0x199b9c;
    entry_199b40(rdram, ctx, runtime);
}

void entry_199bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199bb8 inside entry_199b40 (0x199b40 - 0x199bdc)
    ctx->pc = 0x199bb8;
    entry_199b40(rdram, ctx, runtime);
}

void entry_199be4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199be4 inside entry_199bdc (0x199bdc - 0x199bf8)
    ctx->pc = 0x199be4;
    entry_199bdc(rdram, ctx, runtime);
}

void entry_199cf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199cf4 inside entry_199cf0 (0x199cf0 - 0x199d08)
    ctx->pc = 0x199cf4;
    entry_199cf0(rdram, ctx, runtime);
}

void entry_199e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199e60 inside entry_199e24 (0x199e24 - 0x199ed0)
    ctx->pc = 0x199e60;
    entry_199e24(rdram, ctx, runtime);
}

void entry_199e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199e74 inside entry_199e24 (0x199e24 - 0x199ed0)
    ctx->pc = 0x199e74;
    entry_199e24(rdram, ctx, runtime);
}

void entry_199eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199eb4 inside entry_199e24 (0x199e24 - 0x199ed0)
    ctx->pc = 0x199eb4;
    entry_199e24(rdram, ctx, runtime);
}

void entry_199f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199f00 inside entry_199ee0 (0x199ee0 - 0x199f10)
    ctx->pc = 0x199f00;
    entry_199ee0(rdram, ctx, runtime);
}

void entry_199f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199f80 inside entry_199f6c (0x199f6c - 0x199f88)
    ctx->pc = 0x199f80;
    entry_199f6c(rdram, ctx, runtime);
}

void entry_199fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x199fc8 inside entry_199fc0 (0x199fc0 - 0x199fd8)
    ctx->pc = 0x199fc8;
    entry_199fc0(rdram, ctx, runtime);
}

void entry_19a06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a06c inside entry_19a040 (0x19a040 - 0x19a088)
    ctx->pc = 0x19a06c;
    entry_19a040(rdram, ctx, runtime);
}

void entry_19a070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a070 inside entry_19a040 (0x19a040 - 0x19a088)
    ctx->pc = 0x19a070;
    entry_19a040(rdram, ctx, runtime);
}

void entry_19a09c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a09c inside FUN_0019a088 (0x19a088 - 0x19a0f0)
    ctx->pc = 0x19a09c;
    FUN_0019a088(rdram, ctx, runtime);
}

void entry_19a0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a0c0 inside FUN_0019a088 (0x19a088 - 0x19a0f0)
    ctx->pc = 0x19a0c0;
    FUN_0019a088(rdram, ctx, runtime);
}

void entry_19a100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a100 inside FUN_0019a0f0 (0x19a0f0 - 0x19a108)
    ctx->pc = 0x19a100;
    FUN_0019a0f0(rdram, ctx, runtime);
}

void entry_19a138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a138 inside entry_19a134 (0x19a134 - 0x19a148)
    ctx->pc = 0x19a138;
    entry_19a134(rdram, ctx, runtime);
}

void entry_19a230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a230 inside entry_19a22c (0x19a22c - 0x19a23c)
    ctx->pc = 0x19a230;
    entry_19a22c(rdram, ctx, runtime);
}

void entry_19a298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a298 inside entry_19a290 (0x19a290 - 0x19a2e0)
    ctx->pc = 0x19a298;
    entry_19a290(rdram, ctx, runtime);
}

void entry_19a2b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a2b0 inside entry_19a290 (0x19a290 - 0x19a2e0)
    ctx->pc = 0x19a2b0;
    entry_19a290(rdram, ctx, runtime);
}

void entry_19a2d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a2d0 inside entry_19a290 (0x19a290 - 0x19a2e0)
    ctx->pc = 0x19a2d0;
    entry_19a290(rdram, ctx, runtime);
}

void entry_19a308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a308 inside entry_19a2e0 (0x19a2e0 - 0x19a32c)
    ctx->pc = 0x19a308;
    entry_19a2e0(rdram, ctx, runtime);
}

void entry_19a318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a318 inside entry_19a2e0 (0x19a2e0 - 0x19a32c)
    ctx->pc = 0x19a318;
    entry_19a2e0(rdram, ctx, runtime);
}

void entry_19a330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a330 inside entry_19a32c (0x19a32c - 0x19a350)
    ctx->pc = 0x19a330;
    entry_19a32c(rdram, ctx, runtime);
}

void entry_19a3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a3a8 inside entry_19a380 (0x19a380 - 0x19a3b0)
    ctx->pc = 0x19a3a8;
    entry_19a380(rdram, ctx, runtime);
}

void entry_19a3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a3d8 inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a3d8;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a400 inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a400;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a41c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a41c inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a41c;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a448 inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a448;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a46c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a46c inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a46c;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a470 inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a470;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a480 inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a480;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a4a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a4a0 inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a4a0;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a4b8 inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a4b8;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a4e0 inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a4e0;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a4ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a4ec inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a4ec;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a4f8 inside entry_19a3b0 (0x19a3b0 - 0x19a520)
    ctx->pc = 0x19a4f8;
    entry_19a3b0(rdram, ctx, runtime);
}

void entry_19a584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a584 inside entry_19a580 (0x19a580 - 0x19a58c)
    ctx->pc = 0x19a584;
    entry_19a580(rdram, ctx, runtime);
}

void entry_19a5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a5b0 inside entry_19a58c (0x19a58c - 0x19a5cc)
    ctx->pc = 0x19a5b0;
    entry_19a58c(rdram, ctx, runtime);
}

void entry_19a5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a5c0 inside entry_19a58c (0x19a58c - 0x19a5cc)
    ctx->pc = 0x19a5c0;
    entry_19a58c(rdram, ctx, runtime);
}

void entry_19a5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a5f4 inside entry_19a5cc (0x19a5cc - 0x19a674)
    ctx->pc = 0x19a5f4;
    entry_19a5cc(rdram, ctx, runtime);
}

void entry_19a618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a618 inside entry_19a5cc (0x19a5cc - 0x19a674)
    ctx->pc = 0x19a618;
    entry_19a5cc(rdram, ctx, runtime);
}

void entry_19a630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a630 inside entry_19a5cc (0x19a5cc - 0x19a674)
    ctx->pc = 0x19a630;
    entry_19a5cc(rdram, ctx, runtime);
}

void entry_19a65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a65c inside entry_19a5cc (0x19a5cc - 0x19a674)
    ctx->pc = 0x19a65c;
    entry_19a5cc(rdram, ctx, runtime);
}

void entry_19a694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a694 inside entry_19a690 (0x19a690 - 0x19a6a8)
    ctx->pc = 0x19a694;
    entry_19a690(rdram, ctx, runtime);
}

void entry_19a718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a718 inside entry_19a710 (0x19a710 - 0x19a754)
    ctx->pc = 0x19a718;
    entry_19a710(rdram, ctx, runtime);
}

void entry_19a78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a78c inside entry_19a754 (0x19a754 - 0x19a7f8)
    ctx->pc = 0x19a78c;
    entry_19a754(rdram, ctx, runtime);
}

void entry_19a7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a7a8 inside entry_19a754 (0x19a754 - 0x19a7f8)
    ctx->pc = 0x19a7a8;
    entry_19a754(rdram, ctx, runtime);
}

void entry_19a7d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a7d4 inside entry_19a754 (0x19a754 - 0x19a7f8)
    ctx->pc = 0x19a7d4;
    entry_19a754(rdram, ctx, runtime);
}

void entry_19a7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a7f0 inside entry_19a754 (0x19a754 - 0x19a7f8)
    ctx->pc = 0x19a7f0;
    entry_19a754(rdram, ctx, runtime);
}

void entry_19a800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a800 inside entry_19a7f8 (0x19a7f8 - 0x19a808)
    ctx->pc = 0x19a800;
    entry_19a7f8(rdram, ctx, runtime);
}

void entry_19a810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a810 inside entry_19a808 (0x19a808 - 0x19a818)
    ctx->pc = 0x19a810;
    entry_19a808(rdram, ctx, runtime);
}

void entry_19a820(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a820 inside entry_19a818 (0x19a818 - 0x19a828)
    ctx->pc = 0x19a820;
    entry_19a818(rdram, ctx, runtime);
}

void entry_19a830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a830 inside entry_19a828 (0x19a828 - 0x19a838)
    ctx->pc = 0x19a830;
    entry_19a828(rdram, ctx, runtime);
}

void entry_19a840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a840 inside entry_19a838 (0x19a838 - 0x19a848)
    ctx->pc = 0x19a840;
    entry_19a838(rdram, ctx, runtime);
}

void entry_19a850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a850 inside entry_19a848 (0x19a848 - 0x19a858)
    ctx->pc = 0x19a850;
    entry_19a848(rdram, ctx, runtime);
}

void entry_19a860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a860 inside entry_19a858 (0x19a858 - 0x19a87c)
    ctx->pc = 0x19a860;
    entry_19a858(rdram, ctx, runtime);
}

void entry_19a864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a864 inside entry_19a858 (0x19a858 - 0x19a87c)
    ctx->pc = 0x19a864;
    entry_19a858(rdram, ctx, runtime);
}

void entry_19a8b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a8b0 inside entry_19a888 (0x19a888 - 0x19a8f8)
    ctx->pc = 0x19a8b0;
    entry_19a888(rdram, ctx, runtime);
}

void entry_19a8c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a8c4 inside entry_19a888 (0x19a888 - 0x19a8f8)
    ctx->pc = 0x19a8c4;
    entry_19a888(rdram, ctx, runtime);
}

void entry_19a8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a8d4 inside entry_19a888 (0x19a888 - 0x19a8f8)
    ctx->pc = 0x19a8d4;
    entry_19a888(rdram, ctx, runtime);
}

void entry_19a8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a8e4 inside entry_19a888 (0x19a888 - 0x19a8f8)
    ctx->pc = 0x19a8e4;
    entry_19a888(rdram, ctx, runtime);
}

void entry_19a8ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a8ec inside entry_19a888 (0x19a888 - 0x19a8f8)
    ctx->pc = 0x19a8ec;
    entry_19a888(rdram, ctx, runtime);
}

void entry_19a91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a91c inside entry_19a8f8 (0x19a8f8 - 0x19a964)
    ctx->pc = 0x19a91c;
    entry_19a8f8(rdram, ctx, runtime);
}

void entry_19a934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a934 inside entry_19a8f8 (0x19a8f8 - 0x19a964)
    ctx->pc = 0x19a934;
    entry_19a8f8(rdram, ctx, runtime);
}

void entry_19a96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a96c inside entry_19a964 (0x19a964 - 0x19a990)
    ctx->pc = 0x19a96c;
    entry_19a964(rdram, ctx, runtime);
}

void entry_19a998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a998 inside entry_19a990 (0x19a990 - 0x19a9ac)
    ctx->pc = 0x19a998;
    entry_19a990(rdram, ctx, runtime);
}

void entry_19a9a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a9a4 inside entry_19a990 (0x19a990 - 0x19a9ac)
    ctx->pc = 0x19a9a4;
    entry_19a990(rdram, ctx, runtime);
}

void entry_19a9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19a9b4 inside entry_19a9ac (0x19a9ac - 0x19a9e8)
    ctx->pc = 0x19a9b4;
    entry_19a9ac(rdram, ctx, runtime);
}

void entry_19aa18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19aa18 inside entry_19aa10 (0x19aa10 - 0x19aa4c)
    ctx->pc = 0x19aa18;
    entry_19aa10(rdram, ctx, runtime);
}

void entry_19aa78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19aa78 inside entry_19aa74 (0x19aa74 - 0x19aac0)
    ctx->pc = 0x19aa78;
    entry_19aa74(rdram, ctx, runtime);
}

void entry_19aa7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19aa7c inside entry_19aa74 (0x19aa74 - 0x19aac0)
    ctx->pc = 0x19aa7c;
    entry_19aa74(rdram, ctx, runtime);
}

void entry_19aa90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19aa90 inside entry_19aa74 (0x19aa74 - 0x19aac0)
    ctx->pc = 0x19aa90;
    entry_19aa74(rdram, ctx, runtime);
}

void entry_19aac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19aac8 inside entry_19aac0 (0x19aac0 - 0x19aad4)
    ctx->pc = 0x19aac8;
    entry_19aac0(rdram, ctx, runtime);
}

void entry_19ab00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ab00 inside entry_19aaec (0x19aaec - 0x19ab38)
    ctx->pc = 0x19ab00;
    entry_19aaec(rdram, ctx, runtime);
}

void entry_19ab18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ab18 inside entry_19aaec (0x19aaec - 0x19ab38)
    ctx->pc = 0x19ab18;
    entry_19aaec(rdram, ctx, runtime);
}

void entry_19ab1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ab1c inside entry_19aaec (0x19aaec - 0x19ab38)
    ctx->pc = 0x19ab1c;
    entry_19aaec(rdram, ctx, runtime);
}

void entry_19ab58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ab58 inside entry_19ab54 (0x19ab54 - 0x19ab78)
    ctx->pc = 0x19ab58;
    entry_19ab54(rdram, ctx, runtime);
}

void entry_19abec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19abec inside entry_19abe4 (0x19abe4 - 0x19ac00)
    ctx->pc = 0x19abec;
    entry_19abe4(rdram, ctx, runtime);
}

void entry_19ac38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ac38 inside entry_19ac28 (0x19ac28 - 0x19acf4)
    ctx->pc = 0x19ac38;
    entry_19ac28(rdram, ctx, runtime);
}

void entry_19acac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19acac inside entry_19ac28 (0x19ac28 - 0x19acf4)
    ctx->pc = 0x19acac;
    entry_19ac28(rdram, ctx, runtime);
}

void entry_19acb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19acb0 inside entry_19ac28 (0x19ac28 - 0x19acf4)
    ctx->pc = 0x19acb0;
    entry_19ac28(rdram, ctx, runtime);
}

void entry_19ad0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ad0c inside entry_19acf4 (0x19acf4 - 0x19ad30)
    ctx->pc = 0x19ad0c;
    entry_19acf4(rdram, ctx, runtime);
}

void entry_19ad14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ad14 inside entry_19acf4 (0x19acf4 - 0x19ad30)
    ctx->pc = 0x19ad14;
    entry_19acf4(rdram, ctx, runtime);
}

void entry_19ad18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ad18 inside entry_19acf4 (0x19acf4 - 0x19ad30)
    ctx->pc = 0x19ad18;
    entry_19acf4(rdram, ctx, runtime);
}

void entry_19ad1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ad1c inside entry_19acf4 (0x19acf4 - 0x19ad30)
    ctx->pc = 0x19ad1c;
    entry_19acf4(rdram, ctx, runtime);
}

void entry_19ad60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ad60 inside AddVaultGoadDialog__FP5VAULT5GOADK3OID (0x19ad30 - 0x19ad68)
    ctx->pc = 0x19ad60;
    AddVaultGoadDialog__FP5VAULT5GOADK3OID(rdram, ctx, runtime);
}

void entry_19adac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19adac inside entry_19ada4 (0x19ada4 - 0x19adc8)
    ctx->pc = 0x19adac;
    entry_19ada4(rdram, ctx, runtime);
}

void entry_19adcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19adcc inside entry_19adc8 (0x19adc8 - 0x19ae54)
    ctx->pc = 0x19adcc;
    entry_19adc8(rdram, ctx, runtime);
}

void entry_19ae40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ae40 inside entry_19adc8 (0x19adc8 - 0x19ae54)
    ctx->pc = 0x19ae40;
    entry_19adc8(rdram, ctx, runtime);
}

void entry_19ae48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ae48 inside entry_19adc8 (0x19adc8 - 0x19ae54)
    ctx->pc = 0x19ae48;
    entry_19adc8(rdram, ctx, runtime);
}

void entry_19ae4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ae4c inside entry_19adc8 (0x19adc8 - 0x19ae54)
    ctx->pc = 0x19ae4c;
    entry_19adc8(rdram, ctx, runtime);
}

void entry_19ae6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ae6c inside entry_19ae68 (0x19ae68 - 0x19ae88)
    ctx->pc = 0x19ae6c;
    entry_19ae68(rdram, ctx, runtime);
}

void entry_19aee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19aee8 inside entry_19aeb4 (0x19aeb4 - 0x19af00)
    ctx->pc = 0x19aee8;
    entry_19aeb4(rdram, ctx, runtime);
}

void entry_19aeec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19aeec inside entry_19aeb4 (0x19aeb4 - 0x19af00)
    ctx->pc = 0x19aeec;
    entry_19aeb4(rdram, ctx, runtime);
}

void entry_19afdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19afdc inside entry_19afd8 (0x19afd8 - 0x19aff0)
    ctx->pc = 0x19afdc;
    entry_19afd8(rdram, ctx, runtime);
}

void entry_19b0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b0f8 inside entry_19b0f0 (0x19b0f0 - 0x19b104)
    ctx->pc = 0x19b0f8;
    entry_19b0f0(rdram, ctx, runtime);
}

void entry_19b140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b140 inside entry_19b118 (0x19b118 - 0x19b188)
    ctx->pc = 0x19b140;
    entry_19b118(rdram, ctx, runtime);
}

void entry_19b154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b154 inside entry_19b118 (0x19b118 - 0x19b188)
    ctx->pc = 0x19b154;
    entry_19b118(rdram, ctx, runtime);
}

void entry_19b2d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b2d8 inside entry_19b2b8 (0x19b2b8 - 0x19b300)
    ctx->pc = 0x19b2d8;
    entry_19b2b8(rdram, ctx, runtime);
}

void entry_19b2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b2e8 inside entry_19b2b8 (0x19b2b8 - 0x19b300)
    ctx->pc = 0x19b2e8;
    entry_19b2b8(rdram, ctx, runtime);
}

void entry_19b30c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b30c inside entry_19b300 (0x19b300 - 0x19b324)
    ctx->pc = 0x19b30c;
    entry_19b300(rdram, ctx, runtime);
}

void entry_19b344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b344 inside entry_19b33c (0x19b33c - 0x19b35c)
    ctx->pc = 0x19b344;
    entry_19b33c(rdram, ctx, runtime);
}

void entry_19b360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b360 inside entry_19b35c (0x19b35c - 0x19b378)
    ctx->pc = 0x19b360;
    entry_19b35c(rdram, ctx, runtime);
}

void entry_19b3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b3e4 inside entry_19b3b4 (0x19b3b4 - 0x19b454)
    ctx->pc = 0x19b3e4;
    entry_19b3b4(rdram, ctx, runtime);
}

void entry_19b478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b478 inside entry_19b474 (0x19b474 - 0x19b554)
    ctx->pc = 0x19b478;
    entry_19b474(rdram, ctx, runtime);
}

void entry_19b500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b500 inside entry_19b474 (0x19b474 - 0x19b554)
    ctx->pc = 0x19b500;
    entry_19b474(rdram, ctx, runtime);
}

void entry_19b544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b544 inside entry_19b474 (0x19b474 - 0x19b554)
    ctx->pc = 0x19b544;
    entry_19b474(rdram, ctx, runtime);
}

void entry_19b570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b570 inside entry_19b554 (0x19b554 - 0x19b650)
    ctx->pc = 0x19b570;
    entry_19b554(rdram, ctx, runtime);
}

void entry_19b580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b580 inside entry_19b554 (0x19b554 - 0x19b650)
    ctx->pc = 0x19b580;
    entry_19b554(rdram, ctx, runtime);
}

void entry_19b654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b654 inside entry_19b650 (0x19b650 - 0x19b754)
    ctx->pc = 0x19b654;
    entry_19b650(rdram, ctx, runtime);
}

void entry_19b670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b670 inside entry_19b650 (0x19b650 - 0x19b754)
    ctx->pc = 0x19b670;
    entry_19b650(rdram, ctx, runtime);
}

void entry_19b758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b758 inside entry_19b754 (0x19b754 - 0x19b7b8)
    ctx->pc = 0x19b758;
    entry_19b754(rdram, ctx, runtime);
}

void entry_19b76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b76c inside entry_19b754 (0x19b754 - 0x19b7b8)
    ctx->pc = 0x19b76c;
    entry_19b754(rdram, ctx, runtime);
}

void entry_19b7c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b7c0 inside entry_19b7b8 (0x19b7b8 - 0x19b7f0)
    ctx->pc = 0x19b7c0;
    entry_19b7b8(rdram, ctx, runtime);
}

void entry_19b7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b7fc inside entry_19b7f0 (0x19b7f0 - 0x19b92c)
    ctx->pc = 0x19b7fc;
    entry_19b7f0(rdram, ctx, runtime);
}

void entry_19b8c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b8c8 inside entry_19b7f0 (0x19b7f0 - 0x19b92c)
    ctx->pc = 0x19b8c8;
    entry_19b7f0(rdram, ctx, runtime);
}

void entry_19b908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b908 inside entry_19b7f0 (0x19b7f0 - 0x19b92c)
    ctx->pc = 0x19b908;
    entry_19b7f0(rdram, ctx, runtime);
}

void entry_19b93c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b93c inside entry_19b92c (0x19b92c - 0x19b964)
    ctx->pc = 0x19b93c;
    entry_19b92c(rdram, ctx, runtime);
}

void entry_19b948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b948 inside entry_19b92c (0x19b92c - 0x19b964)
    ctx->pc = 0x19b948;
    entry_19b92c(rdram, ctx, runtime);
}

void entry_19b94c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b94c inside entry_19b92c (0x19b92c - 0x19b964)
    ctx->pc = 0x19b94c;
    entry_19b92c(rdram, ctx, runtime);
}

void entry_19b97c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b97c inside entry_19b978 (0x19b978 - 0x19b984)
    ctx->pc = 0x19b97c;
    entry_19b978(rdram, ctx, runtime);
}

void entry_19b9cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19b9cc inside entry_19b984 (0x19b984 - 0x19b9e4)
    ctx->pc = 0x19b9cc;
    entry_19b984(rdram, ctx, runtime);
}

void entry_19ba4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ba4c inside entry_19b9e4 (0x19b9e4 - 0x19bae0)
    ctx->pc = 0x19ba4c;
    entry_19b9e4(rdram, ctx, runtime);
}

void entry_19ba50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ba50 inside entry_19b9e4 (0x19b9e4 - 0x19bae0)
    ctx->pc = 0x19ba50;
    entry_19b9e4(rdram, ctx, runtime);
}

void entry_19bac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bac0 inside entry_19b9e4 (0x19b9e4 - 0x19bae0)
    ctx->pc = 0x19bac0;
    entry_19b9e4(rdram, ctx, runtime);
}

void entry_19bad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bad0 inside entry_19b9e4 (0x19b9e4 - 0x19bae0)
    ctx->pc = 0x19bad0;
    entry_19b9e4(rdram, ctx, runtime);
}

void entry_19baec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19baec inside entry_19bae0 (0x19bae0 - 0x19bb10)
    ctx->pc = 0x19baec;
    entry_19bae0(rdram, ctx, runtime);
}

void entry_19baf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19baf0 inside entry_19bae0 (0x19bae0 - 0x19bb10)
    ctx->pc = 0x19baf0;
    entry_19bae0(rdram, ctx, runtime);
}

void entry_19bb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bb74 inside AdjustRatNewXp__FP3RATP2XPi (0x19bb10 - 0x19bb90)
    ctx->pc = 0x19bb74;
    AdjustRatNewXp__FP3RATP2XPi(rdram, ctx, runtime);
}

void entry_19bb84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bb84 inside AdjustRatNewXp__FP3RATP2XPi (0x19bb10 - 0x19bb90)
    ctx->pc = 0x19bb84;
    AdjustRatNewXp__FP3RATP2XPi(rdram, ctx, runtime);
}

void entry_19bc34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bc34 inside AdjustRatXpVelocity__FP3RATP2XPi (0x19bb90 - 0x19bc40)
    ctx->pc = 0x19bc34;
    AdjustRatXpVelocity__FP3RATP2XPi(rdram, ctx, runtime);
}

void entry_19bcb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bcb0 inside entry_19bc88 (0x19bc88 - 0x19bd60)
    ctx->pc = 0x19bcb0;
    entry_19bc88(rdram, ctx, runtime);
}

void entry_19bcc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bcc0 inside entry_19bc88 (0x19bc88 - 0x19bd60)
    ctx->pc = 0x19bcc0;
    entry_19bc88(rdram, ctx, runtime);
}

void entry_19bcd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bcd0 inside entry_19bc88 (0x19bc88 - 0x19bd60)
    ctx->pc = 0x19bcd0;
    entry_19bc88(rdram, ctx, runtime);
}

void entry_19bd10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bd10 inside entry_19bc88 (0x19bc88 - 0x19bd60)
    ctx->pc = 0x19bd10;
    entry_19bc88(rdram, ctx, runtime);
}

void entry_19bd2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bd2c inside entry_19bc88 (0x19bc88 - 0x19bd60)
    ctx->pc = 0x19bd2c;
    entry_19bc88(rdram, ctx, runtime);
}

void entry_19bd3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bd3c inside entry_19bc88 (0x19bc88 - 0x19bd60)
    ctx->pc = 0x19bd3c;
    entry_19bc88(rdram, ctx, runtime);
}

void entry_19bd50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bd50 inside entry_19bc88 (0x19bc88 - 0x19bd60)
    ctx->pc = 0x19bd50;
    entry_19bc88(rdram, ctx, runtime);
}

void entry_19bd68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bd68 inside entry_19bd60 (0x19bd60 - 0x19bdf4)
    ctx->pc = 0x19bd68;
    entry_19bd60(rdram, ctx, runtime);
}

void entry_19bda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bda8 inside entry_19bd60 (0x19bd60 - 0x19bdf4)
    ctx->pc = 0x19bda8;
    entry_19bd60(rdram, ctx, runtime);
}

void entry_19bdc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bdc4 inside entry_19bd60 (0x19bd60 - 0x19bdf4)
    ctx->pc = 0x19bdc4;
    entry_19bd60(rdram, ctx, runtime);
}

void entry_19bdd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bdd4 inside entry_19bd60 (0x19bd60 - 0x19bdf4)
    ctx->pc = 0x19bdd4;
    entry_19bd60(rdram, ctx, runtime);
}

void entry_19bdf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bdf8 inside entry_19bdf4 (0x19bdf4 - 0x19be08)
    ctx->pc = 0x19bdf8;
    entry_19bdf4(rdram, ctx, runtime);
}

void entry_19bdfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bdfc inside entry_19bdf4 (0x19bdf4 - 0x19be08)
    ctx->pc = 0x19bdfc;
    entry_19bdf4(rdram, ctx, runtime);
}

void entry_19bf08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bf08 inside entry_19beb4 (0x19beb4 - 0x19bf1c)
    ctx->pc = 0x19bf08;
    entry_19beb4(rdram, ctx, runtime);
}

void entry_19bf5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19bf5c inside entry_19bf1c (0x19bf1c - 0x19bf6c)
    ctx->pc = 0x19bf5c;
    entry_19bf1c(rdram, ctx, runtime);
}

void entry_19c004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c004 inside entry_19bf84 (0x19bf84 - 0x19c068)
    ctx->pc = 0x19c004;
    entry_19bf84(rdram, ctx, runtime);
}

void entry_19c014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c014 inside entry_19bf84 (0x19bf84 - 0x19c068)
    ctx->pc = 0x19c014;
    entry_19bf84(rdram, ctx, runtime);
}

void entry_19c018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c018 inside entry_19bf84 (0x19bf84 - 0x19c068)
    ctx->pc = 0x19c018;
    entry_19bf84(rdram, ctx, runtime);
}

void entry_19c02c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c02c inside entry_19bf84 (0x19bf84 - 0x19c068)
    ctx->pc = 0x19c02c;
    entry_19bf84(rdram, ctx, runtime);
}

void entry_19c038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c038 inside entry_19bf84 (0x19bf84 - 0x19c068)
    ctx->pc = 0x19c038;
    entry_19bf84(rdram, ctx, runtime);
}

void entry_19c0b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c0b4 inside entry_19c0ac (0x19c0ac - 0x19c0c4)
    ctx->pc = 0x19c0b4;
    entry_19c0ac(rdram, ctx, runtime);
}

void entry_19c108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c108 inside entry_19c104 (0x19c104 - 0x19c114)
    ctx->pc = 0x19c108;
    entry_19c104(rdram, ctx, runtime);
}

void entry_19c150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c150 inside entry_19c114 (0x19c114 - 0x19c158)
    ctx->pc = 0x19c150;
    entry_19c114(rdram, ctx, runtime);
}

void entry_19c170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c170 inside entry_19c158 (0x19c158 - 0x19c18c)
    ctx->pc = 0x19c170;
    entry_19c158(rdram, ctx, runtime);
}

void entry_19c20c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c20c inside entry_19c204 (0x19c204 - 0x19c258)
    ctx->pc = 0x19c20c;
    entry_19c204(rdram, ctx, runtime);
}

void entry_19c388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c388 inside entry_19c378 (0x19c378 - 0x19c390)
    ctx->pc = 0x19c388;
    entry_19c378(rdram, ctx, runtime);
}

void entry_19c398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c398 inside entry_19c390 (0x19c390 - 0x19c3d0)
    ctx->pc = 0x19c398;
    entry_19c390(rdram, ctx, runtime);
}

void entry_19c39c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c39c inside entry_19c390 (0x19c390 - 0x19c3d0)
    ctx->pc = 0x19c39c;
    entry_19c390(rdram, ctx, runtime);
}

void entry_19c3a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c3a0 inside entry_19c390 (0x19c390 - 0x19c3d0)
    ctx->pc = 0x19c3a0;
    entry_19c390(rdram, ctx, runtime);
}

void entry_19c3ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c3ac inside entry_19c390 (0x19c390 - 0x19c3d0)
    ctx->pc = 0x19c3ac;
    entry_19c390(rdram, ctx, runtime);
}

void entry_19c4b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c4b0 inside LoadRchmFromBrx__FP4RCHMP18CBinaryInputStream (0x19c470 - 0x19c4bc)
    ctx->pc = 0x19c4b0;
    LoadRchmFromBrx__FP4RCHMP18CBinaryInputStream(rdram, ctx, runtime);
}

void entry_19c508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c508 inside entry_19c4f4 (0x19c4f4 - 0x19c514)
    ctx->pc = 0x19c508;
    entry_19c4f4(rdram, ctx, runtime);
}

void entry_19c568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c568 inside entry_19c558 (0x19c558 - 0x19c570)
    ctx->pc = 0x19c568;
    entry_19c558(rdram, ctx, runtime);
}

void entry_19c590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c590 inside entry_19c57c (0x19c57c - 0x19c5ac)
    ctx->pc = 0x19c590;
    entry_19c57c(rdram, ctx, runtime);
}

void entry_19c5a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c5a0 inside entry_19c57c (0x19c57c - 0x19c5ac)
    ctx->pc = 0x19c5a0;
    entry_19c57c(rdram, ctx, runtime);
}

void entry_19c5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c5cc inside entry_19c5ac (0x19c5ac - 0x19c5d8)
    ctx->pc = 0x19c5cc;
    entry_19c5ac(rdram, ctx, runtime);
}

void entry_19c610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c610 inside entry_19c5fc (0x19c5fc - 0x19c62c)
    ctx->pc = 0x19c610;
    entry_19c5fc(rdram, ctx, runtime);
}

void entry_19c674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c674 inside entry_19c644 (0x19c644 - 0x19c6e4)
    ctx->pc = 0x19c674;
    entry_19c644(rdram, ctx, runtime);
}

void entry_19c68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c68c inside entry_19c644 (0x19c644 - 0x19c6e4)
    ctx->pc = 0x19c68c;
    entry_19c644(rdram, ctx, runtime);
}

void entry_19c6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c6ac inside entry_19c644 (0x19c644 - 0x19c6e4)
    ctx->pc = 0x19c6ac;
    entry_19c644(rdram, ctx, runtime);
}

void entry_19c6c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c6c8 inside entry_19c644 (0x19c644 - 0x19c6e4)
    ctx->pc = 0x19c6c8;
    entry_19c644(rdram, ctx, runtime);
}

void entry_19c6cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c6cc inside entry_19c644 (0x19c644 - 0x19c6e4)
    ctx->pc = 0x19c6cc;
    entry_19c644(rdram, ctx, runtime);
}

void entry_19c6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c6dc inside entry_19c644 (0x19c644 - 0x19c6e4)
    ctx->pc = 0x19c6dc;
    entry_19c644(rdram, ctx, runtime);
}

void entry_19c798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c798 inside entry_19c778 (0x19c778 - 0x19c7a8)
    ctx->pc = 0x19c798;
    entry_19c778(rdram, ctx, runtime);
}

void entry_19c838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c838 inside entry_19c81c (0x19c81c - 0x19c844)
    ctx->pc = 0x19c838;
    entry_19c81c(rdram, ctx, runtime);
}

void entry_19c85c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c85c inside entry_19c858 (0x19c858 - 0x19c874)
    ctx->pc = 0x19c85c;
    entry_19c858(rdram, ctx, runtime);
}

void entry_19c880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c880 inside entry_19c874 (0x19c874 - 0x19c8b0)
    ctx->pc = 0x19c880;
    entry_19c874(rdram, ctx, runtime);
}

void entry_19c928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c928 inside entry_19c920 (0x19c920 - 0x19c958)
    ctx->pc = 0x19c928;
    entry_19c920(rdram, ctx, runtime);
}

void entry_19c994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c994 inside entry_19c98c (0x19c98c - 0x19c9c8)
    ctx->pc = 0x19c994;
    entry_19c98c(rdram, ctx, runtime);
}

void entry_19c9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c9a0 inside entry_19c98c (0x19c98c - 0x19c9c8)
    ctx->pc = 0x19c9a0;
    entry_19c98c(rdram, ctx, runtime);
}

void entry_19c9a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c9a4 inside entry_19c98c (0x19c98c - 0x19c9c8)
    ctx->pc = 0x19c9a4;
    entry_19c98c(rdram, ctx, runtime);
}

void entry_19c9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19c9f0 inside ReblendRchm__FP4RCHMP3TWRP6VECTOR (0x19c9c8 - 0x19cc00)
    ctx->pc = 0x19c9f0;
    ReblendRchm__FP4RCHMP3TWRP6VECTOR(rdram, ctx, runtime);
}

void entry_19ca08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ca08 inside ReblendRchm__FP4RCHMP3TWRP6VECTOR (0x19c9c8 - 0x19cc00)
    ctx->pc = 0x19ca08;
    ReblendRchm__FP4RCHMP3TWRP6VECTOR(rdram, ctx, runtime);
}

void entry_19cb58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cb58 inside ReblendRchm__FP4RCHMP3TWRP6VECTOR (0x19c9c8 - 0x19cc00)
    ctx->pc = 0x19cb58;
    ReblendRchm__FP4RCHMP3TWRP6VECTOR(rdram, ctx, runtime);
}

void entry_19cb88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cb88 inside ReblendRchm__FP4RCHMP3TWRP6VECTOR (0x19c9c8 - 0x19cc00)
    ctx->pc = 0x19cb88;
    ReblendRchm__FP4RCHMP3TWRP6VECTOR(rdram, ctx, runtime);
}

void entry_19cbb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cbb8 inside ReblendRchm__FP4RCHMP3TWRP6VECTOR (0x19c9c8 - 0x19cc00)
    ctx->pc = 0x19cbb8;
    ReblendRchm__FP4RCHMP3TWRP6VECTOR(rdram, ctx, runtime);
}

void entry_19cc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cc40 inside BuildRchmCoefficients__FP4RCHMfffPf (0x19cc10 - 0x19cd90)
    ctx->pc = 0x19cc40;
    BuildRchmCoefficients__FP4RCHMfffPf(rdram, ctx, runtime);
}

void entry_19cc48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cc48 inside BuildRchmCoefficients__FP4RCHMfffPf (0x19cc10 - 0x19cd90)
    ctx->pc = 0x19cc48;
    BuildRchmCoefficients__FP4RCHMfffPf(rdram, ctx, runtime);
}

void entry_19cc6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cc6c inside BuildRchmCoefficients__FP4RCHMfffPf (0x19cc10 - 0x19cd90)
    ctx->pc = 0x19cc6c;
    BuildRchmCoefficients__FP4RCHMfffPf(rdram, ctx, runtime);
}

void entry_19cc90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cc90 inside BuildRchmCoefficients__FP4RCHMfffPf (0x19cc10 - 0x19cd90)
    ctx->pc = 0x19cc90;
    BuildRchmCoefficients__FP4RCHMfffPf(rdram, ctx, runtime);
}

void entry_19cca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cca4 inside BuildRchmCoefficients__FP4RCHMfffPf (0x19cc10 - 0x19cd90)
    ctx->pc = 0x19cca4;
    BuildRchmCoefficients__FP4RCHMfffPf(rdram, ctx, runtime);
}

void entry_19cca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cca8 inside BuildRchmCoefficients__FP4RCHMfffPf (0x19cc10 - 0x19cd90)
    ctx->pc = 0x19cca8;
    BuildRchmCoefficients__FP4RCHMfffPf(rdram, ctx, runtime);
}

void entry_19cdbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cdbc inside ConvertRchmIposToRclIoLhub__FP4RCHMiPfN22 (0x19cd90 - 0x19ce28)
    ctx->pc = 0x19cdbc;
    ConvertRchmIposToRclIoLhub__FP4RCHMiPfN22(rdram, ctx, runtime);
}

void entry_19cf9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cf9c inside PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR (0x19cf68 - 0x19d07c)
    ctx->pc = 0x19cf9c;
    PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR(rdram, ctx, runtime);
}

void entry_19cfc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19cfc0 inside PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR (0x19cf68 - 0x19d07c)
    ctx->pc = 0x19cfc0;
    PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR(rdram, ctx, runtime);
}

void entry_19d008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d008 inside PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR (0x19cf68 - 0x19d07c)
    ctx->pc = 0x19d008;
    PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR(rdram, ctx, runtime);
}

void entry_19d048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d048 inside PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR (0x19cf68 - 0x19d07c)
    ctx->pc = 0x19d048;
    PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR(rdram, ctx, runtime);
}

void entry_19d074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d074 inside PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR (0x19cf68 - 0x19d07c)
    ctx->pc = 0x19d074;
    PtwrMapRchmSafe__FP4RCHMP3BSPP6VECTOR(rdram, ctx, runtime);
}

void entry_19d09c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d09c inside entry_19d07c (0x19d07c - 0x19d0e0)
    ctx->pc = 0x19d09c;
    entry_19d07c(rdram, ctx, runtime);
}

void entry_19d0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d0b8 inside entry_19d07c (0x19d07c - 0x19d0e0)
    ctx->pc = 0x19d0b8;
    entry_19d07c(rdram, ctx, runtime);
}

void entry_19d0bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d0bc inside entry_19d07c (0x19d07c - 0x19d0e0)
    ctx->pc = 0x19d0bc;
    entry_19d07c(rdram, ctx, runtime);
}

void entry_19d154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d154 inside entry_19d138 (0x19d138 - 0x19d1d4)
    ctx->pc = 0x19d154;
    entry_19d138(rdram, ctx, runtime);
}

void entry_19d15c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d15c inside entry_19d138 (0x19d138 - 0x19d1d4)
    ctx->pc = 0x19d15c;
    entry_19d138(rdram, ctx, runtime);
}

void entry_19d16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d16c inside entry_19d138 (0x19d138 - 0x19d1d4)
    ctx->pc = 0x19d16c;
    entry_19d138(rdram, ctx, runtime);
}

void entry_19d190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d190 inside entry_19d138 (0x19d138 - 0x19d1d4)
    ctx->pc = 0x19d190;
    entry_19d138(rdram, ctx, runtime);
}

void entry_19d1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d1f0 inside entry_19d1d4 (0x19d1d4 - 0x19d21c)
    ctx->pc = 0x19d1f0;
    entry_19d1d4(rdram, ctx, runtime);
}

void entry_19d1f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d1f4 inside entry_19d1d4 (0x19d1d4 - 0x19d21c)
    ctx->pc = 0x19d1f4;
    entry_19d1d4(rdram, ctx, runtime);
}

void entry_19d220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d220 inside entry_19d21c (0x19d21c - 0x19d2a8)
    ctx->pc = 0x19d220;
    entry_19d21c(rdram, ctx, runtime);
}

void entry_19d22c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d22c inside entry_19d21c (0x19d21c - 0x19d2a8)
    ctx->pc = 0x19d22c;
    entry_19d21c(rdram, ctx, runtime);
}

void entry_19d234(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d234 inside entry_19d21c (0x19d21c - 0x19d2a8)
    ctx->pc = 0x19d234;
    entry_19d21c(rdram, ctx, runtime);
}

void entry_19d268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d268 inside entry_19d21c (0x19d21c - 0x19d2a8)
    ctx->pc = 0x19d268;
    entry_19d21c(rdram, ctx, runtime);
}

void entry_19d26c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d26c inside entry_19d21c (0x19d21c - 0x19d2a8)
    ctx->pc = 0x19d26c;
    entry_19d21c(rdram, ctx, runtime);
}

void entry_19d2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d2ec inside TrackJtTarget__FP2JTP4RCHMP6TARGET (0x19d2a8 - 0x19d2f8)
    ctx->pc = 0x19d2ec;
    TrackJtTarget__FP2JTP4RCHMP6TARGET(rdram, ctx, runtime);
}

void entry_19d444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d444 inside SubmitRpl__FP3RPL (0x19d410 - 0x19d468)
    ctx->pc = 0x19d444;
    SubmitRpl__FP3RPL(rdram, ctx, runtime);
}

void entry_19d460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d460 inside SubmitRpl__FP3RPL (0x19d410 - 0x19d468)
    ctx->pc = 0x19d460;
    SubmitRpl__FP3RPL(rdram, ctx, runtime);
}

void entry_19d48c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d48c inside NCmpPrplReverseZ__FPP3RPLT0 (0x19d468 - 0x19d4b0)
    ctx->pc = 0x19d48c;
    NCmpPrplReverseZ__FPP3RPLT0(rdram, ctx, runtime);
}

void entry_19d4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d4a4 inside NCmpPrplReverseZ__FPP3RPLT0 (0x19d468 - 0x19d4b0)
    ctx->pc = 0x19d4a4;
    NCmpPrplReverseZ__FPP3RPLT0(rdram, ctx, runtime);
}

void entry_19d4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d4d8 inside CprplPartitionArpl__FiP3RPLPP3RPL (0x19d4b0 - 0x19d648)
    ctx->pc = 0x19d4d8;
    CprplPartitionArpl__FiP3RPLPP3RPL(rdram, ctx, runtime);
}

void entry_19d508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d508 inside CprplPartitionArpl__FiP3RPLPP3RPL (0x19d4b0 - 0x19d648)
    ctx->pc = 0x19d508;
    CprplPartitionArpl__FiP3RPLPP3RPL(rdram, ctx, runtime);
}

void entry_19d52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d52c inside CprplPartitionArpl__FiP3RPLPP3RPL (0x19d4b0 - 0x19d648)
    ctx->pc = 0x19d52c;
    CprplPartitionArpl__FiP3RPLPP3RPL(rdram, ctx, runtime);
}

void entry_19d55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d55c inside CprplPartitionArpl__FiP3RPLPP3RPL (0x19d4b0 - 0x19d648)
    ctx->pc = 0x19d55c;
    CprplPartitionArpl__FiP3RPLPP3RPL(rdram, ctx, runtime);
}

void entry_19d580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d580 inside CprplPartitionArpl__FiP3RPLPP3RPL (0x19d4b0 - 0x19d648)
    ctx->pc = 0x19d580;
    CprplPartitionArpl__FiP3RPLPP3RPL(rdram, ctx, runtime);
}

void entry_19d5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d5b0 inside CprplPartitionArpl__FiP3RPLPP3RPL (0x19d4b0 - 0x19d648)
    ctx->pc = 0x19d5b0;
    CprplPartitionArpl__FiP3RPLPP3RPL(rdram, ctx, runtime);
}

void entry_19d5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d5b8 inside CprplPartitionArpl__FiP3RPLPP3RPL (0x19d4b0 - 0x19d648)
    ctx->pc = 0x19d5b8;
    CprplPartitionArpl__FiP3RPLPP3RPL(rdram, ctx, runtime);
}

void entry_19d5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d5f0 inside CprplPartitionArpl__FiP3RPLPP3RPL (0x19d4b0 - 0x19d648)
    ctx->pc = 0x19d5f0;
    CprplPartitionArpl__FiP3RPLPP3RPL(rdram, ctx, runtime);
}

void entry_19d620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d620 inside CprplPartitionArpl__FiP3RPLPP3RPL (0x19d4b0 - 0x19d648)
    ctx->pc = 0x19d620;
    CprplPartitionArpl__FiP3RPLPP3RPL(rdram, ctx, runtime);
}

void entry_19d740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d740 inside RenderSw__FP2SWP2CM (0x19d6c0 - 0x19d758)
    ctx->pc = 0x19d740;
    RenderSw__FP2SWP2CM(rdram, ctx, runtime);
}

void entry_19d774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d774 inside entry_19d758 (0x19d758 - 0x19d7c8)
    ctx->pc = 0x19d774;
    entry_19d758(rdram, ctx, runtime);
}

void entry_19d7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d7b0 inside entry_19d758 (0x19d758 - 0x19d7c8)
    ctx->pc = 0x19d7b0;
    entry_19d758(rdram, ctx, runtime);
}

void entry_19d7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d7e4 inside entry_19d7c8 (0x19d7c8 - 0x19d818)
    ctx->pc = 0x19d7e4;
    entry_19d7c8(rdram, ctx, runtime);
}

void entry_19d810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d810 inside entry_19d7c8 (0x19d7c8 - 0x19d818)
    ctx->pc = 0x19d810;
    entry_19d7c8(rdram, ctx, runtime);
}

void entry_19d834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d834 inside entry_19d818 (0x19d818 - 0x19d860)
    ctx->pc = 0x19d834;
    entry_19d818(rdram, ctx, runtime);
}

void entry_19d9c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19d9c8 inside entry_19d9b4 (0x19d9b4 - 0x19d9e8)
    ctx->pc = 0x19d9c8;
    entry_19d9b4(rdram, ctx, runtime);
}

void entry_19da18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19da18 inside entry_19da10 (0x19da10 - 0x19da30)
    ctx->pc = 0x19da18;
    entry_19da10(rdram, ctx, runtime);
}

void entry_19da1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19da1c inside entry_19da10 (0x19da10 - 0x19da30)
    ctx->pc = 0x19da1c;
    entry_19da10(rdram, ctx, runtime);
}

void entry_19dc40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19dc40 inside entry_19dbf4 (0x19dbf4 - 0x19dc60)
    ctx->pc = 0x19dc40;
    entry_19dbf4(rdram, ctx, runtime);
}

void entry_19dc44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19dc44 inside entry_19dbf4 (0x19dbf4 - 0x19dc60)
    ctx->pc = 0x19dc44;
    entry_19dbf4(rdram, ctx, runtime);
}

void entry_19dd38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19dd38 inside entry_19dd28 (0x19dd28 - 0x19dd48)
    ctx->pc = 0x19dd38;
    entry_19dd28(rdram, ctx, runtime);
}

void entry_19dd50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19dd50 inside entry_19dd48 (0x19dd48 - 0x19dd5c)
    ctx->pc = 0x19dd50;
    entry_19dd48(rdram, ctx, runtime);
}

void entry_19dd80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19dd80 inside entry_19dd7c (0x19dd7c - 0x19dda0)
    ctx->pc = 0x19dd80;
    entry_19dd7c(rdram, ctx, runtime);
}

void entry_19e018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e018 inside entry_19df88 (0x19df88 - 0x19e040)
    ctx->pc = 0x19e018;
    entry_19df88(rdram, ctx, runtime);
}

void entry_19e06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e06c inside PripgNew__FP2SW5RIPGT (0x19e040 - 0x19e094)
    ctx->pc = 0x19e06c;
    PripgNew__FP2SW5RIPGT(rdram, ctx, runtime);
}

void entry_19e09c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e09c inside entry_19e094 (0x19e094 - 0x19e0b8)
    ctx->pc = 0x19e09c;
    entry_19e094(rdram, ctx, runtime);
}

void entry_19e0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e0a0 inside entry_19e094 (0x19e094 - 0x19e0b8)
    ctx->pc = 0x19e0a0;
    entry_19e094(rdram, ctx, runtime);
}

void entry_19e0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e0a4 inside entry_19e094 (0x19e094 - 0x19e0b8)
    ctx->pc = 0x19e0a4;
    entry_19e094(rdram, ctx, runtime);
}

void entry_19e1b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e1b8 inside OnRipgRemove__FP4RIPG (0x19e168 - 0x19e1c0)
    ctx->pc = 0x19e1b8;
    OnRipgRemove__FP4RIPG(rdram, ctx, runtime);
}

void entry_19e1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e1dc inside entry_19e1c0 (0x19e1c0 - 0x19e204)
    ctx->pc = 0x19e1dc;
    entry_19e1c0(rdram, ctx, runtime);
}

void entry_19e1fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e1fc inside entry_19e1c0 (0x19e1c0 - 0x19e204)
    ctx->pc = 0x19e1fc;
    entry_19e1c0(rdram, ctx, runtime);
}

void entry_19e2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e2b8 inside ProjectRipgTransform__FP4RIPGfi (0x19e220 - 0x19e2e0)
    ctx->pc = 0x19e2b8;
    ProjectRipgTransform__FP4RIPGfi(rdram, ctx, runtime);
}

void entry_19e32c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e32c inside entry_19e2e0 (0x19e2e0 - 0x19e3ac)
    ctx->pc = 0x19e32c;
    entry_19e2e0(rdram, ctx, runtime);
}

void entry_19e36c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e36c inside entry_19e2e0 (0x19e2e0 - 0x19e3ac)
    ctx->pc = 0x19e36c;
    entry_19e2e0(rdram, ctx, runtime);
}

void entry_19e488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e488 inside FUN_0019e420 (0x19e420 - 0x19e4a8)
    ctx->pc = 0x19e488;
    FUN_0019e420(rdram, ctx, runtime);
}

void entry_19e4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e4c8 inside entry_19e4c4 (0x19e4c4 - 0x19e500)
    ctx->pc = 0x19e4c8;
    entry_19e4c4(rdram, ctx, runtime);
}

void entry_19e4e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e4e0 inside entry_19e4c4 (0x19e4c4 - 0x19e500)
    ctx->pc = 0x19e4e0;
    entry_19e4c4(rdram, ctx, runtime);
}

void entry_19e50c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e50c inside entry_19e500 (0x19e500 - 0x19e518)
    ctx->pc = 0x19e50c;
    entry_19e500(rdram, ctx, runtime);
}

void entry_19e520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e520 inside entry_19e518 (0x19e518 - 0x19e528)
    ctx->pc = 0x19e520;
    entry_19e518(rdram, ctx, runtime);
}

void entry_19e5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e5b8 inside BounceRipgRips__FP4RIPG (0x19e558 - 0x19e68c)
    ctx->pc = 0x19e5b8;
    BounceRipgRips__FP4RIPG(rdram, ctx, runtime);
}

void entry_19e604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e604 inside BounceRipgRips__FP4RIPG (0x19e558 - 0x19e68c)
    ctx->pc = 0x19e604;
    BounceRipgRips__FP4RIPG(rdram, ctx, runtime);
}

void entry_19e628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e628 inside BounceRipgRips__FP4RIPG (0x19e558 - 0x19e68c)
    ctx->pc = 0x19e628;
    BounceRipgRips__FP4RIPG(rdram, ctx, runtime);
}

void entry_19e684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e684 inside BounceRipgRips__FP4RIPG (0x19e558 - 0x19e68c)
    ctx->pc = 0x19e684;
    BounceRipgRips__FP4RIPG(rdram, ctx, runtime);
}

void entry_19e6d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e6d4 inside entry_19e6bc (0x19e6bc - 0x19e73c)
    ctx->pc = 0x19e6d4;
    entry_19e6bc(rdram, ctx, runtime);
}

void entry_19e6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e6d8 inside entry_19e6bc (0x19e6bc - 0x19e73c)
    ctx->pc = 0x19e6d8;
    entry_19e6bc(rdram, ctx, runtime);
}

void entry_19e700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e700 inside entry_19e6bc (0x19e6bc - 0x19e73c)
    ctx->pc = 0x19e700;
    entry_19e6bc(rdram, ctx, runtime);
}

void entry_19e748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e748 inside entry_19e73c (0x19e73c - 0x19e784)
    ctx->pc = 0x19e748;
    entry_19e73c(rdram, ctx, runtime);
}

void entry_19e78c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e78c inside entry_19e784 (0x19e784 - 0x19e7b0)
    ctx->pc = 0x19e78c;
    entry_19e784(rdram, ctx, runtime);
}

void entry_19e790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e790 inside entry_19e784 (0x19e784 - 0x19e7b0)
    ctx->pc = 0x19e790;
    entry_19e784(rdram, ctx, runtime);
}

void entry_19e7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e7a8 inside entry_19e784 (0x19e784 - 0x19e7b0)
    ctx->pc = 0x19e7a8;
    entry_19e784(rdram, ctx, runtime);
}

void entry_19e7bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e7bc inside entry_19e7b0 (0x19e7b0 - 0x19e7f8)
    ctx->pc = 0x19e7bc;
    entry_19e7b0(rdram, ctx, runtime);
}

void entry_19e7d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e7d8 inside entry_19e7b0 (0x19e7b0 - 0x19e7f8)
    ctx->pc = 0x19e7d8;
    entry_19e7b0(rdram, ctx, runtime);
}

void entry_19e7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e7e4 inside entry_19e7b0 (0x19e7b0 - 0x19e7f8)
    ctx->pc = 0x19e7e4;
    entry_19e7b0(rdram, ctx, runtime);
}

void entry_19e7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e7f0 inside entry_19e7b0 (0x19e7b0 - 0x19e7f8)
    ctx->pc = 0x19e7f0;
    entry_19e7b0(rdram, ctx, runtime);
}

void entry_19e814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e814 inside entry_19e810 (0x19e810 - 0x19e848)
    ctx->pc = 0x19e814;
    entry_19e810(rdram, ctx, runtime);
}

void entry_19e8a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e8a8 inside RenderRipgSelf__FP4RIPGP2CMP2RO (0x19e848 - 0x19e8d0)
    ctx->pc = 0x19e8a8;
    RenderRipgSelf__FP4RIPGP2CMP2RO(rdram, ctx, runtime);
}

void entry_19e8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e8d4 inside entry_19e8d0 (0x19e8d0 - 0x19e908)
    ctx->pc = 0x19e8d4;
    entry_19e8d0(rdram, ctx, runtime);
}

void entry_19e8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19e8e8 inside entry_19e8d0 (0x19e8d0 - 0x19e908)
    ctx->pc = 0x19e8e8;
    entry_19e8d0(rdram, ctx, runtime);
}

void entry_19ea70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ea70 inside PvtripFromRipt__F4RIPT (0x19e908 - 0x19ea78)
    ctx->pc = 0x19ea70;
    PvtripFromRipt__F4RIPT(rdram, ctx, runtime);
}

void entry_19eabc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19eabc inside entry_19eaa8 (0x19eaa8 - 0x19eac8)
    ctx->pc = 0x19eabc;
    entry_19eaa8(rdram, ctx, runtime);
}

void entry_19eac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19eac0 inside entry_19eaa8 (0x19eaa8 - 0x19eac8)
    ctx->pc = 0x19eac0;
    entry_19eaa8(rdram, ctx, runtime);
}

void entry_19eb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19eb10 inside entry_19eb0c (0x19eb0c - 0x19eb28)
    ctx->pc = 0x19eb10;
    entry_19eb0c(rdram, ctx, runtime);
}

void entry_19ebdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ebdc inside InitRip__FP3RIPP6VECTORfP2SO (0x19eb28 - 0x19ebe8)
    ctx->pc = 0x19ebdc;
    InitRip__FP3RIPP6VECTORfP2SO(rdram, ctx, runtime);
}

void entry_19ec74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ec74 inside entry_19ec70 (0x19ec70 - 0x19ec98)
    ctx->pc = 0x19ec74;
    entry_19ec70(rdram, ctx, runtime);
}

void entry_19ec88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ec88 inside entry_19ec70 (0x19ec70 - 0x19ec98)
    ctx->pc = 0x19ec88;
    entry_19ec70(rdram, ctx, runtime);
}

void entry_19ed50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ed50 inside ForceRipFade__FP3RIPf (0x19ed00 - 0x19ed58)
    ctx->pc = 0x19ed50;
    ForceRipFade__FP3RIPf(rdram, ctx, runtime);
}

void entry_19edb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19edb8 inside FBounceRip__FP3RIPP2SOP6VECTORT2 (0x19ed58 - 0x19ee38)
    ctx->pc = 0x19edb8;
    FBounceRip__FP3RIPP2SOP6VECTORT2(rdram, ctx, runtime);
}

void entry_19edd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19edd8 inside FBounceRip__FP3RIPP2SOP6VECTORT2 (0x19ed58 - 0x19ee38)
    ctx->pc = 0x19edd8;
    FBounceRip__FP3RIPP2SOP6VECTORT2(rdram, ctx, runtime);
}

void entry_19eeb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19eeb0 inside entry_19eea8 (0x19eea8 - 0x19f030)
    ctx->pc = 0x19eeb0;
    entry_19eea8(rdram, ctx, runtime);
}

void entry_19ef68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ef68 inside entry_19eea8 (0x19eea8 - 0x19f030)
    ctx->pc = 0x19ef68;
    entry_19eea8(rdram, ctx, runtime);
}

void entry_19ef98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ef98 inside entry_19eea8 (0x19eea8 - 0x19f030)
    ctx->pc = 0x19ef98;
    entry_19eea8(rdram, ctx, runtime);
}

void entry_19efa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19efa8 inside entry_19eea8 (0x19eea8 - 0x19f030)
    ctx->pc = 0x19efa8;
    entry_19eea8(rdram, ctx, runtime);
}

void entry_19efc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19efc8 inside entry_19eea8 (0x19eea8 - 0x19f030)
    ctx->pc = 0x19efc8;
    entry_19eea8(rdram, ctx, runtime);
}

void entry_19eff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19eff8 inside entry_19eea8 (0x19eea8 - 0x19f030)
    ctx->pc = 0x19eff8;
    entry_19eea8(rdram, ctx, runtime);
}

void entry_19f164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f164 inside entry_19f030 (0x19f030 - 0x19f260)
    ctx->pc = 0x19f164;
    entry_19f030(rdram, ctx, runtime);
}

void entry_19f170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f170 inside entry_19f030 (0x19f030 - 0x19f260)
    ctx->pc = 0x19f170;
    entry_19f030(rdram, ctx, runtime);
}

void entry_19f304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f304 inside entry_19f300 (0x19f300 - 0x19f390)
    ctx->pc = 0x19f304;
    entry_19f300(rdram, ctx, runtime);
}

void entry_19f350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f350 inside entry_19f300 (0x19f300 - 0x19f390)
    ctx->pc = 0x19f350;
    entry_19f300(rdram, ctx, runtime);
}

void entry_19f4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f4b8 inside entry_19f448 (0x19f448 - 0x19f4c8)
    ctx->pc = 0x19f4b8;
    entry_19f448(rdram, ctx, runtime);
}

void entry_19f4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f4bc inside entry_19f448 (0x19f448 - 0x19f4c8)
    ctx->pc = 0x19f4bc;
    entry_19f448(rdram, ctx, runtime);
}

void entry_19f4e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f4e4 inside entry_19f4d8 (0x19f4d8 - 0x19f4f0)
    ctx->pc = 0x19f4e4;
    entry_19f4d8(rdram, ctx, runtime);
}

void entry_19f54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f54c inside entry_19f4f0 (0x19f4f0 - 0x19f560)
    ctx->pc = 0x19f54c;
    entry_19f4f0(rdram, ctx, runtime);
}

void entry_19f5ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f5ac inside entry_19f5a4 (0x19f5a4 - 0x19f5dc)
    ctx->pc = 0x19f5ac;
    entry_19f5a4(rdram, ctx, runtime);
}

void entry_19f5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f5f4 inside entry_19f5f0 (0x19f5f0 - 0x19f608)
    ctx->pc = 0x19f5f4;
    entry_19f5f0(rdram, ctx, runtime);
}

void entry_19f60c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f60c inside entry_19f608 (0x19f608 - 0x19f620)
    ctx->pc = 0x19f60c;
    entry_19f608(rdram, ctx, runtime);
}

void entry_19f610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f610 inside entry_19f608 (0x19f608 - 0x19f620)
    ctx->pc = 0x19f610;
    entry_19f608(rdram, ctx, runtime);
}

void entry_19f6cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f6cc inside FRenderRipPosMat__FP3RIPP2CMP6VECTORP7MATRIX3 (0x19f620 - 0x19f770)
    ctx->pc = 0x19f6cc;
    FRenderRipPosMat__FP3RIPP2CMP6VECTORP7MATRIX3(rdram, ctx, runtime);
}

void entry_19f6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f6e0 inside FRenderRipPosMat__FP3RIPP2CMP6VECTORP7MATRIX3 (0x19f620 - 0x19f770)
    ctx->pc = 0x19f6e0;
    FRenderRipPosMat__FP3RIPP2CMP6VECTORP7MATRIX3(rdram, ctx, runtime);
}

void entry_19f7a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f7a0 inside entry_19f770 (0x19f770 - 0x19f7c8)
    ctx->pc = 0x19f7a0;
    entry_19f770(rdram, ctx, runtime);
}

void entry_19f828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f828 inside entry_19f824 (0x19f824 - 0x19f858)
    ctx->pc = 0x19f828;
    entry_19f824(rdram, ctx, runtime);
}

void entry_19f82c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f82c inside entry_19f824 (0x19f824 - 0x19f858)
    ctx->pc = 0x19f82c;
    entry_19f824(rdram, ctx, runtime);
}

void entry_19f8ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f8ac inside entry_19f8a0 (0x19f8a0 - 0x19f8c0)
    ctx->pc = 0x19f8ac;
    entry_19f8a0(rdram, ctx, runtime);
}

void entry_19f8b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f8b4 inside entry_19f8a0 (0x19f8a0 - 0x19f8c0)
    ctx->pc = 0x19f8b4;
    entry_19f8a0(rdram, ctx, runtime);
}

void entry_19f8d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19f8d4 inside entry_19f8d0 (0x19f8d0 - 0x19f8e8)
    ctx->pc = 0x19f8d4;
    entry_19f8d0(rdram, ctx, runtime);
}

void entry_19fa78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19fa78 inside entry_19fa48 (0x19fa48 - 0x19fa80)
    ctx->pc = 0x19fa78;
    entry_19fa48(rdram, ctx, runtime);
}

void entry_19fba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19fba0 inside entry_19fb3c (0x19fb3c - 0x19fc18)
    ctx->pc = 0x19fba0;
    entry_19fb3c(rdram, ctx, runtime);
}

void entry_19fbc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19fbc4 inside entry_19fb3c (0x19fb3c - 0x19fc18)
    ctx->pc = 0x19fbc4;
    entry_19fb3c(rdram, ctx, runtime);
}

void entry_19fcd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19fcd0 inside entry_19fc78 (0x19fc78 - 0x19fce8)
    ctx->pc = 0x19fcd0;
    entry_19fc78(rdram, ctx, runtime);
}

void entry_19fe78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19fe78 inside UpdateFlake__FP5FLAKEf (0x19fe50 - 0x19fe98)
    ctx->pc = 0x19fe78;
    UpdateFlake__FP5FLAKEf(rdram, ctx, runtime);
}

void entry_19fe84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19fe84 inside UpdateFlake__FP5FLAKEf (0x19fe50 - 0x19fe98)
    ctx->pc = 0x19fe84;
    UpdateFlake__FP5FLAKEf(rdram, ctx, runtime);
}

void entry_19fea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19fea0 inside entry_19fe98 (0x19fe98 - 0x19ff04)
    ctx->pc = 0x19fea0;
    entry_19fe98(rdram, ctx, runtime);
}

void entry_19fef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19fef8 inside entry_19fe98 (0x19fe98 - 0x19ff04)
    ctx->pc = 0x19fef8;
    entry_19fe98(rdram, ctx, runtime);
}

void entry_19ffd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ffd0 inside entry_19ff3c (0x19ff3c - 0x1a0008)
    ctx->pc = 0x19ffd0;
    entry_19ff3c(rdram, ctx, runtime);
}

void entry_19ffe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x19ffe0 inside entry_19ff3c (0x19ff3c - 0x1a0008)
    ctx->pc = 0x19ffe0;
    entry_19ff3c(rdram, ctx, runtime);
}

