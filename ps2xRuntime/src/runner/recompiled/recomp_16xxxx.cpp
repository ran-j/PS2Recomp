// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_160030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160030: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x160034: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x160038: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16003c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x160040: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x160044: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x160048: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddFrzgObject__FP4FRZG3OID
// Address: 0x160050 - 0x160070

void entry_160080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160080: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x160084: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16008c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x160090; return;
}


// Function: junk_00160090
// Address: 0x160090 - 0x1600a0

void entry_160158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160158) {
        switch (ctx->pc) {
            case 0x160168: ctx->pc = 0; goto label_160168;
            case 0x16016c: ctx->pc = 0; goto label_16016c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160158: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
        goto label_160168;
    }
    // 0x160160: 0x10000002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16016c;
    }
label_160168:
    // 0x160168: 0x244223d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 9168));
label_16016c:
    // 0x16016c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x160170: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00160178
// Address: 0x160178 - 0x160180

void entry_160190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160190: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x160194: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16019c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1601a0; return;
}


// Function: FFindLevel
// Address: 0x1601a0 - 0x1601b0

void entry_1601b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1601b0) {
        switch (ctx->pc) {
            case 0x1601bc: ctx->pc = 0; goto label_1601bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1601b0: 0x10400002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1601bc;
    }
    // 0x1601b8: 0x8c430020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 32)));
label_1601bc:
    // 0x1601bc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1601c0: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1601c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1601cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1601d0; return;
}


// Function: junk_001601D0
// Address: 0x1601d0 - 0x1601d8

void entry_1601e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1601e8) {
        switch (ctx->pc) {
            case 0x1601f4: ctx->pc = 0; goto label_1601f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1601e8: 0x10400002
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1601f4;
    }
    // 0x1601f0: 0x8c430028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 40)));
label_1601f4:
    // 0x1601f4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1601f8: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1601fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x160204: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x160208; return;
}


// Function: tally_world_completion
// Address: 0x160208 - 0x1602a0

void entry_1602d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1602d0) {
        switch (ctx->pc) {
            case 0x160308: ctx->pc = 0; goto label_160308;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1602d0: 0x8e030028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 40)));
    // 0x1602d4: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1602d8: 0x2610002c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 44));
    // 0x1602dc: 0x31827
    SET_GPR_U32(ctx, 3, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x1602e0: 0x212102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), GPR_U32(ctx, 18)));
    // 0x1602e4: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1602e8: 0x1440fff7
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1602C8; return;
    }
    // 0x1602f0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1602f4: 0x2406fffd
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967293));
    // 0x1602f8: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x1602fc: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x160300: 0x246408a4
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 2212));
    // 0x160304: 0x0
    // NOP
label_160308:
    // 0x160308: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x16030c: 0x2261824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 17), GPR_U32(ctx, 6)));
    // 0x160310: 0x2484044c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1100));
    // 0x160314: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x160318: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x16031c: 0x4a1fffa
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 3));
    if (GPR_S32(ctx, 5) >= 0) {
        goto label_160308;
    }
    // 0x160324: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x160328: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16032c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x160330: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x160334: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x160338: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UnlockIntroCutsceneFromWid__Fi
// Address: 0x160340 - 0x1603e8

void entry_1604a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1604a8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1604ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1604b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1604b8; return;
}


// Function: UnlockEndgameCutscenesFromFgs
// Address: 0x1604b8 - 0x16051c

void entry_16051c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16051c) {
        switch (ctx->pc) {
            case 0x16053c: ctx->pc = 0; goto label_16053c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16051c: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x160520: 0x10400012
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16056C; return;
    }
    // 0x160528: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x16052c: 0x8c8319f4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6644)));
    // 0x160530: 0x3463c000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 49152));
    // 0x160534: 0x1000000d
    WRITE32(ADD32(GPR_U32(ctx, 4), 6644), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16056C; return;
    }
label_16053c:
    // 0x16053c: 0xc0580a8
    SET_GPR_U32(ctx, 31, 0x160544);
    get_game_completion__Fv(rdram, ctx, runtime); return;
}


// Function: entry_160544
// Address: 0x160544 - 0x160578

void entry_160544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160544) {
        switch (ctx->pc) {
            case 0x160564: ctx->pc = 0; goto label_160564;
            case 0x16056c: ctx->pc = 0; goto label_16056c;
            case 0x160570: ctx->pc = 0; goto label_160570;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160544: 0x30420008
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8));
    // 0x160548: 0x10400008
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16056c;
    }
    // 0x160550: 0x8c4423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x160554: 0x8c8319f4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 6644)));
    // 0x160558: 0x8c8219f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6648)));
    // 0x16055c: 0x3463000c
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 12));
    // 0x160560: 0x3442000c
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 12));
label_160564:
    // 0x160564: 0xac8319f4
    WRITE32(ADD32(GPR_U32(ctx, 4), 6644), GPR_U32(ctx, 3));
    // 0x160568: 0xac8219f8
    WRITE32(ADD32(GPR_U32(ctx, 4), 6648), GPR_U32(ctx, 2));
label_16056c:
    // 0x16056c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_160570:
    // 0x160570: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PlayEndingFromCompletionFlags
// Address: 0x160578 - 0x1605c0

void entry_1605c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1605c0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1605c4: 0x12020003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        entry_1605d4(rdram, ctx, runtime); return;
    }
    // 0x1605cc: 0xc06393c
    SET_GPR_U32(ctx, 31, 0x1605d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    FUN_0018e4f0(rdram, ctx, runtime); return;
}


// Function: entry_1605d4
// Address: 0x1605d4 - 0x1605e8

void entry_1605d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1605d4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1605d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1605dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1605e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1605e8; return;
}


// Function: InitGameState__FP2GS
// Address: 0x1605e8 - 0x160604

void entry_160604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160604: 0x24030012
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 18));
    // 0x160608: 0x24021a00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6656));
    // 0x16060c: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x160610: 0x24060005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    // 0x160614: 0x2407ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x160618: 0xae0019d8
    WRITE32(ADD32(GPR_U32(ctx, 16), 6616), GPR_U32(ctx, 0));
    // 0x16061c: 0xae0019f0
    WRITE32(ADD32(GPR_U32(ctx, 16), 6640), GPR_U32(ctx, 0));
    // 0x160620: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x160624: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    // 0x160628: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x16062c: 0xae0519dc
    WRITE32(ADD32(GPR_U32(ctx, 16), 6620), GPR_U32(ctx, 5));
    // 0x160630: 0xae0619e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 6624), GPR_U32(ctx, 6));
    // 0x160634: 0xc069fa4
    SET_GPR_U32(ctx, 31, 0x16063c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 6652), GPR_U32(ctx, 7));
    FUN_001A7E90(rdram, ctx, runtime); return;
}


// Function: entry_16063c
// Address: 0x16063c - 0x160650

void entry_16063c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16063c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x160640: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x160644: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16064c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x160650; return;
}


// Function: FUN_00160650
// Address: 0x160650 - 0x160690

void FUN_00160650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160650) {
        switch (ctx->pc) {
            case 0x160668: ctx->pc = 0; goto label_160668;
            case 0x160684: ctx->pc = 0; goto label_160684;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160650: 0x240219f4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6644));
    // 0x160654: 0x2484000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 12));
    // 0x160658: 0x1840000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_160684;
    }
    // 0x160660: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x160664: 0x0
    // NOP
label_160668:
    // 0x160668: 0x90820000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x16066c: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x160670: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    // 0x160674: 0x0
    // NOP
    // 0x160678: 0x0
    // NOP
    // 0x16067c: 0x1460fffa
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_160668;
    }
label_160684:
    // 0x160684: 0x3e00008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16068c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x160690; return;
}


// Function: SetupGame__FPci
// Address: 0x160690 - 0x1606c0

void entry_1606c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1606c0) {
        switch (ctx->pc) {
            case 0x160728: ctx->pc = 0; goto label_160728;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1606c0: 0x23027
    SET_GPR_U32(ctx, 6, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x1606c4: 0x21a03
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 2), 8));
    // 0x1606c8: 0x66900b
    if (GPR_U32(ctx, 6) != 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 3));
    // 0x1606cc: 0x2405044c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x1606d0: 0x2452818
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1606d4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1606d8: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x1606dc: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x1606e0: 0x46880b
    if (GPR_U32(ctx, 6) != 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 2));
    // 0x1606e4: 0x80a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1606e8: 0x8c6719e0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 3), 6624)));
    // 0x1606ec: 0x24020078
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 120));
    // 0x1606f0: 0x24a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 16));
    // 0x1606f4: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1606f8: 0x651821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1606fc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x160700: 0x2222818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x160704: 0xc0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x160708: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16070c: 0xacc323c4
    WRITE32(ADD32(GPR_U32(ctx, 6), 9156), GPR_U32(ctx, 3));
    // 0x160710: 0xa31021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x160714: 0x4e00004
    WRITE32(ADD32(GPR_U32(ctx, 4), 9160), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 7) < 0) {
        goto label_160728;
    }
    // 0x16071c: 0x32020002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 2));
    // 0x160720: 0x10400005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x160738; return;
    }
label_160728:
    // 0x160728: 0xc058238
    SET_GPR_U32(ctx, 31, 0x160730);
    RetryGame__Fv(rdram, ctx, runtime); return;
}


// Function: entry_160730
// Address: 0x160730 - 0x160748

void entry_160730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160730) {
        switch (ctx->pc) {
            case 0x160738: ctx->pc = 0; goto label_160738;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160730: 0x10000011
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 9152)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x160778; return;
    }
label_160738:
    // 0x160738: 0x10400005
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x160750; return;
    }
    // 0x160740: 0xc0503d2
    SET_GPR_U32(ctx, 31, 0x160748);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    RestoreChkmgrFromCheckpoint__FP6CHKMGR(rdram, ctx, runtime); return;
}


// Function: entry_160748
// Address: 0x160748 - 0x160764

void entry_160748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160748) {
        switch (ctx->pc) {
            case 0x160750: ctx->pc = 0; goto label_160750;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160748: 0x1000000b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 9152)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x160778; return;
    }
label_160750:
    // 0x160750: 0x32020004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 4));
    // 0x160754: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16076C; return;
    }
    // 0x16075c: 0xc058220
    SET_GPR_U32(ctx, 31, 0x160764);
    UnloadGame__Fv(rdram, ctx, runtime); return;
}


// Function: entry_160764
// Address: 0x160764 - 0x160774

void entry_160764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160764) {
        switch (ctx->pc) {
            case 0x16076c: ctx->pc = 0; goto label_16076c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160764: 0x10000004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 9152)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x160778; return;
    }
label_16076c:
    // 0x16076c: 0xc050364
    SET_GPR_U32(ctx, 31, 0x160774);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    ResetChkmgrCheckpoints__FP6CHKMGR(rdram, ctx, runtime); return;
}


// Function: entry_160774
// Address: 0x160774 - 0x1607d0

void entry_160774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160774) {
        switch (ctx->pc) {
            case 0x160778: ctx->pc = 0; goto label_160778;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160774: 0x8ea323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 9152)));
label_160778:
    // 0x160778: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16077c: 0x8e8523c4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 9156)));
    // 0x160780: 0x8c6219d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x160784: 0x8e6623c8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 9160)));
    // 0x160788: 0xac8223cc
    WRITE32(ADD32(GPR_U32(ctx, 4), 9164), GPR_U32(ctx, 2));
    // 0x16078c: 0xac7119dc
    WRITE32(ADD32(GPR_U32(ctx, 3), 6620), GPR_U32(ctx, 17));
    // 0x160790: 0xac7219d8
    WRITE32(ADD32(GPR_U32(ctx, 3), 6616), GPR_U32(ctx, 18));
    // 0x160794: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x160798: 0x8ca20448
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 1096)));
    // 0x16079c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1607a0: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x1607a4: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1607a8: 0xaca20448
    WRITE32(ADD32(GPR_U32(ctx, 5), 1096), GPR_U32(ctx, 2));
    // 0x1607ac: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1607b0: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x1607b4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1607b8: 0x34630001
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 1));
    // 0x1607bc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1607c0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1607c4: 0xacc30000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 3));
    // 0x1607c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateGameState__Ff
// Address: 0x1607d0 - 0x160810

void entry_160860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160860) {
        switch (ctx->pc) {
            case 0x16086c: ctx->pc = 0; goto label_16086c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160860: 0x10400002
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16086c;
    }
    // 0x160868: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_16086c:
    // 0x16086c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x160870: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x160874: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16087c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x160880; return;
}


// Function: UnloadGame__Fv
// Address: 0x160880 - 0x160898

void entry_160898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160898: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x16089c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1608a0: 0xa8409987
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 4294941063); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 0) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1608a4: 0xb8409984
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 4294941060); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 0) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1608a8: 0xc058332
    SET_GPR_U32(ctx, 31, 0x1608b0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9176));
    clr_8_bytes_1(rdram, ctx, runtime); return;
}


// Function: entry_1608b0
// Address: 0x1608b0 - 0x1608bc

void entry_1608b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1608b0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1608b4: 0xc05469a
    SET_GPR_U32(ctx, 31, 0x1608bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    OnDifficultyGameLoad__FP10DIFFICULTY(rdram, ctx, runtime); return;
}


// Function: entry_1608bc
// Address: 0x1608bc - 0x1608d4

void entry_1608bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1608bc: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1608c0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1608c4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1608c8: 0xac602c64
    WRITE32(ADD32(GPR_U32(ctx, 3), 11364), GPR_U32(ctx, 0));
    // 0x1608cc: 0xc058238
    SET_GPR_U32(ctx, 31, 0x1608d4);
    WRITE32(ADD32(GPR_U32(ctx, 4), 9164), GPR_U32(ctx, 2));
    RetryGame__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1608d4
// Address: 0x1608d4 - 0x1608e0

void entry_1608d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1608d4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1608d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RetryGame__Fv
// Address: 0x1608e0 - 0x160908

void entry_160908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160908: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16090c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x160914: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x160918; return;
}


// Function: StartGame__Fv
// Address: 0x160918 - 0x160928

void entry_160928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160928: 0x3c040024
    SET_GPR_U32(ctx, 4, ((uint32_t)36 << 16));
    // 0x16092c: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x160930: 0x24847ab0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 31408));
    // 0x160934: 0xc07c10a
    SET_GPR_U32(ctx, 31, 0x16093c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    WipeToWorldWarp(rdram, ctx, runtime); return;
}


// Function: entry_16093c
// Address: 0x16093c - 0x160948

void entry_16093c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16093c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x160940: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00160948
// Address: 0x160948 - 0x16097c

void FUN_00160948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160948: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x16094c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x160950: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x160954: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x160958: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16095c: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x160960: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x160964: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x160968: 0x8c6419d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6616)));
    // 0x16096c: 0x8c6219dc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x160970: 0x42200
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 8));
    // 0x160974: 0xc058060
    SET_GPR_U32(ctx, 31, 0x16097c);
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    call_search_level_by_id(rdram, ctx, runtime); return;
}


// Function: entry_16097c
// Address: 0x16097c - 0x160998

void entry_16097c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16097c) {
        switch (ctx->pc) {
            case 0x160990: ctx->pc = 0; goto label_160990;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16097c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x160980: 0x16000003
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        goto label_160990;
    }
    // 0x160988: 0x3c020024
    SET_GPR_U32(ctx, 2, ((uint32_t)36 << 16));
    // 0x16098c: 0x24507ab0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 31408));
label_160990:
    // 0x160990: 0xc058332
    SET_GPR_U32(ctx, 31, 0x160998);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9176));
    clr_8_bytes_1(rdram, ctx, runtime); return;
}


// Function: entry_160998
// Address: 0x160998 - 0x160a30

void entry_160998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160998) {
        switch (ctx->pc) {
            case 0x1609e4: ctx->pc = 0; goto label_1609e4;
            case 0x1609fc: ctx->pc = 0; goto label_1609fc;
            case 0x160a18: ctx->pc = 0; goto label_160a18;
            case 0x160a20: ctx->pc = 0; goto label_160a20;
            case 0x160a24: ctx->pc = 0; goto label_160a24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160998: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x16099c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1609a0: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1609a4: 0x24425bc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23488));
    // 0x1609a8: 0x8c430030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x1609ac: 0x5464001d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        goto label_160a24;
    }
    // 0x1609b4: 0x8e2223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9152)));
    // 0x1609b8: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1609bc: 0xc440000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 12)); ctx->f[0] = *(float*)&val; }
    // 0x1609c0: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1609c4: 0x0
    // NOP
    // 0x1609c8: 0x45000015
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_160a20;
    }
    // 0x1609d0: 0x24425b04
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23300));
    // 0x1609d4: 0x16020003
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1609e4;
    }
    // 0x1609dc: 0x1000000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_160a18;
    }
label_1609e4:
    // 0x1609e4: 0x5200000c
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_160a18;
    }
    // 0x1609ec: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
        goto label_1609fc;
    }
    // 0x1609f4: 0x10000008
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_160a18;
    }
label_1609fc:
    // 0x1609fc: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x160a00: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x160a04: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x160a08: 0x641826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x160a0c: 0x451026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x160a10: 0x621826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x160a14: 0x2c620001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 1));
label_160a18:
    // 0x160a18: 0x14400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 23488));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x160A38; return;
    }
label_160a20:
    // 0x160a20: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_160a24:
    // 0x160a24: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x160a28: 0xc07c10a
    SET_GPR_U32(ctx, 31, 0x160a30);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    WipeToWorldWarp(rdram, ctx, runtime); return;
}


// Function: entry_160a30
// Address: 0x160a30 - 0x160a68

void entry_160a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160a30) {
        switch (ctx->pc) {
            case 0x160a38: ctx->pc = 0; goto label_160a38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160a30: 0x10000038
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x160B14; return;
    }
label_160a38:
    // 0x160a38: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x160a3c: 0x8c430030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 48)));
    // 0x160a40: 0x14640034
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x160B14; return;
    }
    // 0x160a48: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x160a4c: 0x8c435f84
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24452)));
    // 0x160a50: 0x54600031
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
        ctx->pc = 0x160B18; return;
    }
    // 0x160a58: 0x8e2223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9152)));
    // 0x160a5c: 0x8c4419ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6636)));
    // 0x160a60: 0xc0701d8
    SET_GPR_U32(ctx, 31, 0x160a68);
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 128));
    MvgkUnknown3(rdram, ctx, runtime); return;
}


// Function: entry_160a68
// Address: 0x160a68 - 0x160a78

void entry_160a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160a68: 0x8e2223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9152)));
    // 0x160a6c: 0x8c4419ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6636)));
    // 0x160a70: 0xc0701e4
    SET_GPR_U32(ctx, 31, 0x160a78);
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 64));
    MvgkUnknown4(rdram, ctx, runtime); return;
}


// Function: entry_160a78
// Address: 0x160a78 - 0x160a90

void entry_160a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160a78: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x160a7c: 0x24060494
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1172));
    // 0x160a80: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x160a84: 0x24050105
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 261));
    // 0x160a88: 0xc056906
    SET_GPR_U32(ctx, 31, 0x160a90);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_160a90
// Address: 0x160a90 - 0x160ad8

void entry_160a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160a90) {
        switch (ctx->pc) {
            case 0x160ad0: ctx->pc = 0; goto label_160ad0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160a90: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x160a94: 0x10c00019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 108));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x160AFC; return;
    }
    // 0x160a9c: 0x3c040028
    SET_GPR_U32(ctx, 4, ((uint32_t)40 << 16));
    // 0x160aa0: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x160aa4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x160aa8: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x160aac: 0x8c85b314
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 4294947604)));
    // 0x160ab0: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x160ab4: 0xafa5000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    // 0x160ab8: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x160abc: 0xac9db314
    WRITE32(ADD32(GPR_U32(ctx, 4), 4294947604), GPR_U32(ctx, 29));
    // 0x160ac0: 0x8cc2006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 108)));
    // 0x160ac4: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x160ac8: 0x1040000a
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x160AF4; return;
    }
label_160ad0:
    // 0x160ad0: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x160ad8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_160ad8
// Address: 0x160ad8 - 0x160b10

void entry_160ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160ad8) {
        switch (ctx->pc) {
            case 0x160af4: ctx->pc = 0; goto label_160af4;
            case 0x160afc: ctx->pc = 0; goto label_160afc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160ad8: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x160adc: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x160ae0: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x160ae4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x160ae8: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x160aec: 0x1440fff8
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x160AD0; return;
    }
label_160af4:
    // 0x160af4: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x160af8: 0xae02b314
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294947604), GPR_U32(ctx, 2));
label_160afc:
    // 0x160afc: 0x26445bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 23488));
    // 0x160b00: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x160b04: 0xac820030
    WRITE32(ADD32(GPR_U32(ctx, 4), 48), GPR_U32(ctx, 2));
    // 0x160b08: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x160b10);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_160b10
// Address: 0x160b10 - 0x160b28

void entry_160b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160b10) {
        switch (ctx->pc) {
            case 0x160b14: ctx->pc = 0; goto label_160b14;
            case 0x160b18: ctx->pc = 0; goto label_160b18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160b10: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_160b14:
    // 0x160b14: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_160b18:
    // 0x160b18: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x160b1c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x160b20: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CalculatePercentCompletion__FP2GS
// Address: 0x160b28 - 0x160c48

void FUN_00160C90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160c90: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x160c94: 0x0
    // NOP
    // 0x160c98: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x160c9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x160ca0; return;
}


// Function: PfLookupDialog__FP2LS3OID
// Address: 0x160ca0 - 0x160cc8

void entry_160cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160cdc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x160ce0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00160ce8__Fi
// Address: 0x160ce8 - 0x160cf0

void FUN_00160ce8__Fi(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160ce8: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnGameAlarmTriggered__FP4GAME
// Address: 0x160cf0 - 0x160d00

void entry_160dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160dcc: 0xc06f9c2
    SET_GPR_U32(ctx, 31, 0x160dd4);
    FUN_001be708(rdram, ctx, runtime); return;
}


// Function: entry_160dd4
// Address: 0x160dd4 - 0x160e28

void entry_160dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160dd4: 0x8e0323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9152)));
    // 0x160dd8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x160ddc: 0x8c6519dc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 6620)));
    // 0x160de0: 0x54a20013
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6624)));
        ctx->pc = 0x160E30; return;
    }
    // 0x160de8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x160dec: 0xafa50000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 5));
    // 0x160df0: 0x24635b04
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 23300));
    // 0x160df4: 0x24080010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 16));
    // 0x160df8: 0x2462ffec
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294967276));
    // 0x160dfc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x160e00: 0x8c46000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x160e04: 0x24845f80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 24448));
    // 0x160e08: 0x8c470008
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x160e0c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x160e10: 0xafa6000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 6));
    // 0x160e14: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x160e18: 0xafa70008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 7));
    // 0x160e1c: 0xafa80010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 8));
    // 0x160e20: 0xc07bfe8
    SET_GPR_U32(ctx, 31, 0x160e28);
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    ActivateWipe__FP4WIPEP5TRANS5WIPEK(rdram, ctx, runtime); return;
}


// Function: entry_160e28
// Address: 0x160e28 - 0x160e44

void entry_160e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160e28) {
        switch (ctx->pc) {
            case 0x160e30: ctx->pc = 0; goto label_160e30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160e28: 0x1000000d
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x160E60; return;
    }
label_160e30:
    // 0x160e30: 0x4420006
    if (GPR_S32(ctx, 2) < 0) {
        SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
        ctx->pc = 0x160E4C; return;
    }
    // 0x160e38: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x160e3c: 0xc0503b4
    SET_GPR_U32(ctx, 31, 0x160e44);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 5152));
    ReturnChkmgrToCheckpoint__FP6CHKMGR(rdram, ctx, runtime); return;
}


// Function: entry_160e44
// Address: 0x160e44 - 0x160e5c

void entry_160e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160e44) {
        switch (ctx->pc) {
            case 0x160e4c: ctx->pc = 0; goto label_160e4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160e44: 0x10000006
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x160E60; return;
    }
label_160e4c:
    // 0x160e4c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x160e50: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x160e54: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x160e5c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_160e5c
// Address: 0x160e5c - 0x160e70

void entry_160e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160e5c) {
        switch (ctx->pc) {
            case 0x160e60: ctx->pc = 0; goto label_160e60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160e5c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
label_160e60:
    // 0x160e60: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x160e64: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x160e68: 0xc054788
    SET_GPR_U32(ctx, 31, 0x160e70);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 7920));
    OnDifficultyPlayerDeath(rdram, ctx, runtime); return;
}


// Function: entry_160e70
// Address: 0x160e70 - 0x160e80

void entry_160e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160e70: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x160e74: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x160e78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitGeom__FP4GEOM
// Address: 0x160e80 - 0x160ea0

void entry_160edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160edc: 0xae220008
    WRITE32(ADD32(GPR_U32(ctx, 17), 8), GPR_U32(ctx, 2));
    // 0x160ee0: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x160ee4: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x160ee8: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x160eec: 0x8e050010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x160ef0: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x160ef8);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 5));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_160ef8
// Address: 0x160ef8 - 0x160f0c

void entry_160ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160ef8: 0xae220010
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 2));
    // 0x160efc: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x160f00: 0x8e05001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x160f04: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x160f0c);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_160f0c
// Address: 0x160f0c - 0x160f20

void entry_160f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160f0c: 0xae22001c
    WRITE32(ADD32(GPR_U32(ctx, 17), 28), GPR_U32(ctx, 2));
    // 0x160f10: 0x8e04000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x160f14: 0x8e050020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x160f18: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x160f20);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_160f20
// Address: 0x160f20 - 0x160f68

void entry_160f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160f20) {
        switch (ctx->pc) {
            case 0x160f48: ctx->pc = 0; goto label_160f48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160f20: 0xae220020
    WRITE32(ADD32(GPR_U32(ctx, 17), 32), GPR_U32(ctx, 2));
    // 0x160f24: 0x8e020014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x160f28: 0xae220014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 2));
    // 0x160f2c: 0x8e030018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x160f30: 0x12600035
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x161008; return;
    }
    // 0x160f38: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x160f3c: 0x1840000e
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x160F78; return;
    }
    // 0x160f44: 0x8e250008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
label_160f48:
    // 0x160f48: 0x101100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 4));
    // 0x160f4c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x160f50: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x160f54: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x160f58: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x160f5c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x160f60: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x160f68);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_160f68
// Address: 0x160f68 - 0x160fa4

void entry_160f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160f68) {
        switch (ctx->pc) {
            case 0x160f78: ctx->pc = 0; goto label_160f78;
            case 0x160f88: ctx->pc = 0; goto label_160f88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160f68: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x160f6c: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x160f70: 0x5440fff5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
        ctx->pc = 0x160F48; return;
    }
label_160f78:
    // 0x160f78: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x160f7c: 0x18400022
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x161008; return;
    }
    // 0x160f84: 0x8e300010
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 16)));
label_160f88:
    // 0x160f88: 0x121140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 5));
    // 0x160f8c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x160f90: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x160f94: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x160f98: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x160f9c: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x160fa4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_160fa4
// Address: 0x160fa4 - 0x160ff8

void entry_160fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x160fa4: 0x9602001e
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 30)));
    // 0x160fa8: 0x123100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 18), 4));
    // 0x160fac: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x160fb0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x160fb4: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x160fb8: 0xda020000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x160fbc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x160fc0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x160fc4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x160fc8: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x160fcc: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x160fd0: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x160fd4: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x160fd8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x160fdc: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x160fe0: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x160fe4: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x160fe8: 0x8e25001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x160fec: 0xa62821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x160ff0: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x160ff8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_160ff8
// Address: 0x160ff8 - 0x161028

void entry_160ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x160ff8) {
        switch (ctx->pc) {
            case 0x161008: ctx->pc = 0; goto label_161008;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x160ff8: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x160ffc: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x161000: 0x5440ffe1
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 16)));
        ctx->pc = 0x160F88; return;
    }
label_161008:
    // 0x161008: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16100c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x161010: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x161014: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161018: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16101c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x161024: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x161028; return;
}


// Function: FUN_00161028
// Address: 0x161028 - 0x161060

void FUN_00161028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161028: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x16102c: 0x7fb50060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 21));
    // 0x161030: 0x7fb30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 19));
    // 0x161034: 0xe0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x161038: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x16103c: 0xc0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x161040: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x161044: 0x100902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x161048: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x16104c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x161050: 0x7fb40050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 20));
    // 0x161054: 0x7fbf0070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 31));
    // 0x161058: 0xc063582
    SET_GPR_U32(ctx, 31, 0x161060);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_161060
// Address: 0x161060 - 0x161070

void entry_161060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161060: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x161064: 0x2404000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    // 0x161068: 0xc063596
    SET_GPR_U32(ctx, 31, 0x161070);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_161070
// Address: 0x161070 - 0x161098

void entry_161070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161070: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x161074: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x161078: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x16107c: 0x132900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 19), 4));
    // 0x161080: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x161084: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x161088: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16108c: 0x452821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x161090: 0xc04f90c
    SET_GPR_U32(ctx, 31, 0x161098);
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 20));
    PruneBsp__FP3BSPP6VECTORfPP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_161098
// Address: 0x161098 - 0x1610ac

void entry_161098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161098: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16109c: 0x10430005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x1610B4; return;
    }
    // 0x1610a4: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1610ac);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1610ac
// Address: 0x1610ac - 0x161190

void entry_1610ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1610ac) {
        switch (ctx->pc) {
            case 0x1610b4: ctx->pc = 0; goto label_1610b4;
            case 0x1610e0: ctx->pc = 0; goto label_1610e0;
            case 0x161100: ctx->pc = 0; goto label_161100;
            case 0x161114: ctx->pc = 0; goto label_161114;
            case 0x161130: ctx->pc = 0; goto label_161130;
            case 0x16114c: ctx->pc = 0; goto label_16114c;
            case 0x161154: ctx->pc = 0; goto label_161154;
            case 0x161170: ctx->pc = 0; goto label_161170;
            case 0x161178: ctx->pc = 0; goto label_161178;
            case 0x161188: ctx->pc = 0; goto label_161188;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1610ac: 0x10000039
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x161194; return;
    }
label_1610b4:
    // 0x1610b4: 0x3c03aaaa
    SET_GPR_U32(ctx, 3, ((uint32_t)43690 << 16));
    // 0x1610b8: 0x3463aaab
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 43691));
    // 0x1610bc: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1610c0: 0x541023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1610c4: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1610c8: 0x24083
    SET_GPR_S32(ctx, 8, SRA32(GPR_S32(ctx, 2), 2));
    // 0x1610cc: 0x1900002e
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 8) <= 0) {
        goto label_161188;
    }
    // 0x1610d4: 0x2409000c
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1610d8: 0x891018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 9); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1610dc: 0x0
    // NOP
label_1610e0:
    // 0x1610e0: 0x541821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x1610e4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1610e8: 0x8c450014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x1610ec: 0x10a00022
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_161178;
    }
    // 0x1610f4: 0x101080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1610f8: 0x523021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x1610fc: 0x84a20000
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 5), 0)));
label_161100:
    // 0x161100: 0x12620004
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        goto label_161114;
    }
    // 0x161108: 0x84a20002
    SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 5), 2)));
    // 0x16110c: 0x56620018
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 8)));
        goto label_161170;
    }
label_161114:
    // 0x161114: 0x1a00000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 16) <= 0) {
        goto label_161154;
    }
    // 0x16111c: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x161120: 0x10a2000a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 16)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_16114c;
    }
    // 0x161128: 0x240182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16112c: 0x24840001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
label_161130:
    // 0x161130: 0x90102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 16)));
    // 0x161134: 0x10400007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_161154;
    }
    // 0x16113c: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x161140: 0x54a2fffb
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
        goto label_161130;
    }
    // 0x161148: 0x90102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 16)));
label_16114c:
    // 0x16114c: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 8)));
        goto label_161170;
    }
label_161154:
    // 0x161154: 0x215102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 21)));
    // 0x161158: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 8)));
        goto label_161170;
    }
    // 0x161160: 0xacc50000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 5));
    // 0x161164: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x161168: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x16116c: 0x8ca50008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 8)));
label_161170:
    // 0x161170: 0x54a0ffe3
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, (int16_t)READ16(ADD32(GPR_U32(ctx, 5), 0)));
        goto label_161100;
    }
label_161178:
    // 0x161178: 0xe0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x16117c: 0x88102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 8)));
    // 0x161180: 0x1440ffd7
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 9); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1610e0;
    }
label_161188:
    // 0x161188: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x161190);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_161190
// Address: 0x161190 - 0x1611b8

void entry_161190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x161190) {
        switch (ctx->pc) {
            case 0x161194: ctx->pc = 0; goto label_161194;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x161190: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_161194:
    // 0x161194: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x161198: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16119c: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1611a0: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1611a4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1611a8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1611ac: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1611b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: fn___4GIFS
// Address: 0x1611b8 - 0x1611cc

void entry_1611cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1611cc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1611d0: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1611d4: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x1611d8: 0x2463a6f8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294944504));
    // 0x1611dc: 0xae030018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 3));
    // 0x1611e0: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1611e4: 0xae00001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 0));
    // 0x1611e8: 0xae000020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 0));
    // 0x1611ec: 0xae000024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 0));
    // 0x1611f0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1611f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1611f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddPrimEnd__4GIFS
// Address: 0x161200 - 0x161230

void entry_161230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x161230) {
        switch (ctx->pc) {
            case 0x161238: ctx->pc = 0; goto label_161238;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x161230: 0x1000000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x161268; return;
    }
label_161238:
    // 0x161238: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16123c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x161240: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x161244: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x16124c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_16124c
// Address: 0x16124c - 0x161264

void entry_16124c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16124c: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x161250: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x161254: 0x84440008
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x161258: 0x8c43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x16125c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x161264);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_161264
// Address: 0x161264 - 0x161278

void entry_161264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x161264) {
        switch (ctx->pc) {
            case 0x161268: ctx->pc = 0; goto label_161268;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x161264: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_161268:
    // 0x161268: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16126c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x161274: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x161278; return;
}


// Function: EndPrim__4GIFSi
// Address: 0x161278 - 0x1612e8

void entry_161348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x161348) {
        switch (ctx->pc) {
            case 0x161384: ctx->pc = 0; goto label_161384;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x161348: 0x8e44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x16134c: 0x1083fc
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << (32 + 15));
    // 0x161350: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x161354: 0x217f8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 31);
    // 0x161358: 0x142f3c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) << (32 + 28));
    // 0x16135c: 0x2028025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x161360: 0x24830010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 16));
    // 0x161364: 0x2b08025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 21), GPR_U32(ctx, 16)));
    // 0x161368: 0xae43000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 3));
    // 0x16136c: 0x2058025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 5)));
    // 0x161370: 0xfc910008
    WRITE64(ADD32(GPR_U32(ctx, 4), 8), GPR_U64(ctx, 17));
    // 0x161374: 0x12600003
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 16));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_161384;
    }
    // 0x16137c: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x161380: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
label_161384:
    // 0x161384: 0x2b41018
    { int64_t result = (int64_t)GPR_S32(ctx, 21) * (int64_t)GPR_S32(ctx, 20); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x161388: 0x8e43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x16138c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x161390: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x161394: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x161398: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x16139c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1613a0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1613a4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1613a8: 0xae43000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 3));
    // 0x1613ac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1613b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1613b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1613bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1613c0; return;
}


// Function: AddPrimPack__4GIFSiiUl
// Address: 0x1613c0 - 0x161400

void entry_161400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161400: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x161404: 0x12173c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) << (32 + 28));
    // 0x161408: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x16140c: 0x427f8
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 31);
    // 0x161410: 0x118bfc
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 17) << (32 + 15));
    // 0x161414: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x161418: 0x24650010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 16));
    // 0x16141c: 0xae05000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 5));
    // 0x161420: 0x2228825
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x161424: 0xfc710000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 17));
    // 0x161428: 0xfc730008
    WRITE64(ADD32(GPR_U32(ctx, 3), 8), GPR_U64(ctx, 19));
    // 0x16142c: 0xae120020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 18));
    // 0x161430: 0xae03001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 3));
    // 0x161434: 0xae000024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 0));
    // 0x161438: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16143c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x161440: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x161444: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161448: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16144c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x161454: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x161458; return;
}


// Function: PackRGBA__4GIFSUi
// Address: 0x161458 - 0x16147c

void entry_16147c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16147c: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x161480: 0x102602
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 16), 24));
    // 0x161484: 0x3205ff00
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 16), 65280));
    // 0x161488: 0x103402
    SET_GPR_U32(ctx, 6, SRL32(GPR_U32(ctx, 16), 16));
    // 0x16148c: 0x24430010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 16));
    // 0x161490: 0x321000ff
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 255));
    // 0x161494: 0xae23000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 3));
    // 0x161498: 0x52a02
    SET_GPR_U32(ctx, 5, SRL32(GPR_U32(ctx, 5), 8));
    // 0x16149c: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x1614a0: 0x30c600ff
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), 255));
    // 0x1614a4: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1614a8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1614ac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1614b0: 0xac44000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 12), GPR_U32(ctx, 4));
    // 0x1614b4: 0xac450004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 5));
    // 0x1614b8: 0xac460008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 6));
    // 0x1614bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1614c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1614c8; return;
}


// Function: PackUV__4GIFSii
// Address: 0x1614c8 - 0x1614f4

void entry_1614f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1614f4: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1614f8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1614fc: 0x24430010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 16));
    // 0x161500: 0xae03000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 3));
    // 0x161504: 0xac510004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 17));
    // 0x161508: 0xac520000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 18));
    // 0x16150c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x161510: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161514: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161518: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PackSTQ__4GIFSfff
// Address: 0x161520 - 0x161554

void entry_161554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161554: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x161558: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16155c: 0x24430010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 16));
    // 0x161560: 0xae03000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 3));
    // 0x161564: 0xe4540008
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    // 0x161568: 0xe4550000
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x16156c: 0xe4560004
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x161570: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161574: 0xc7b60030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[22] = *(float*)&val; }
    // 0x161578: 0xc7b50028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[21] = *(float*)&val; }
    // 0x16157c: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x161580: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PackXYZ__4GIFSiii
// Address: 0x161588 - 0x1615bc

void entry_1615bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1615bc: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1615c0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1615c4: 0x24430010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1615c8: 0xae03000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 3));
    // 0x1615cc: 0xfc510008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 17));
    // 0x1615d0: 0xac520000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 18));
    // 0x1615d4: 0xac530004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 19));
    // 0x1615d8: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1615dc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1615e0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1615e4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1615e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PackXYZF__4GIFSiiii
// Address: 0x1615f0 - 0x16162c

void entry_16162c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16162c: 0x8e23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x161630: 0x321000ff
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 255));
    // 0x161634: 0x108100
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 4));
    // 0x161638: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16163c: 0x24620010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 16));
    // 0x161640: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x161644: 0xac70000c
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 16));
    // 0x161648: 0xac720000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 18));
    // 0x16164c: 0xac730004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 19));
    // 0x161650: 0xac740008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 20));
    // 0x161654: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x161658: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16165c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x161660: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161664: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161668: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PackXYZFNoKick__4GIFSiiii
// Address: 0x161670 - 0x1616ac

void entry_1616ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1616ac: 0x3c0200ff
    SET_GPR_U32(ctx, 2, ((uint32_t)255 << 16));
    // 0x1616b0: 0x8e43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1616b4: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x1616b8: 0x321000ff
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 255));
    // 0x1616bc: 0x2228824
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x1616c0: 0x108100
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 4));
    // 0x1616c4: 0x24620010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1616c8: 0x118900
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 17), 4));
    // 0x1616cc: 0xae42000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 2));
    // 0x1616d0: 0x36108000
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), 32768));
    // 0x1616d4: 0xac70000c
    WRITE32(ADD32(GPR_U32(ctx, 3), 12), GPR_U32(ctx, 16));
    // 0x1616d8: 0xac730000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 19));
    // 0x1616dc: 0xac740004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 20));
    // 0x1616e0: 0xac710008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 17));
    // 0x1616e4: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1616e8: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1616ec: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1616f0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1616f4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1616f8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1616fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x161704: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x161708; return;
}


// Function: PackAD__4GIFSll
// Address: 0x161708 - 0x161734

void entry_161734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161734: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x161738: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16173c: 0x24430010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 16));
    // 0x161740: 0xae03000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 3));
    // 0x161744: 0xfc510008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 17));
    // 0x161748: 0xfc520000
    WRITE64(ADD32(GPR_U32(ctx, 2), 0), GPR_U64(ctx, 18));
    // 0x16174c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x161750: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161754: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161758: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00161760
// Address: 0x161760 - 0x161768

void entry_1617a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1617a0: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1617a4: 0x11173c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) << (32 + 28));
    // 0x1617a8: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1617ac: 0x422fc
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << (32 + 11));
    // 0x1617b0: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1617b4: 0x24650010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1617b8: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1617bc: 0xae05000c
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 5));
    // 0x1617c0: 0xfc720008
    WRITE64(ADD32(GPR_U32(ctx, 3), 8), GPR_U64(ctx, 18));
    // 0x1617c4: 0xfc620000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 2));
    // 0x1617c8: 0xae110020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 17));
    // 0x1617cc: 0xae03001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 3));
    // 0x1617d0: 0xae000024
    WRITE32(ADD32(GPR_U32(ctx, 16), 36), GPR_U32(ctx, 0));
    // 0x1617d4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1617d8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1617dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1617e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ListRGBAQ__4GIFSUif
// Address: 0x1617e8 - 0x161814

void entry_161814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161814: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x161818: 0x10803c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << (32 + 0));
    // 0x16181c: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x161820: 0x10803e
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) >> (32 + 0));
    // 0x161824: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x161828: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16182c: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x161830: 0x24820008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 8));
    // 0x161834: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x161838: 0x2038025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x16183c: 0xfc900000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 16));
    // 0x161840: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161844: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161848: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x16184c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x161854: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x161858; return;
}


// Function: junk_00161858
// Address: 0x161858 - 0x161860

void entry_16188c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16188c: 0x8e23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x161890: 0x108400
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 16));
    // 0x161894: 0x2509025
    SET_GPR_U32(ctx, 18, OR32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
    // 0x161898: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16189c: 0x24620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8));
    // 0x1618a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1618a4: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x1618a8: 0xfc720000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 18));
    // 0x1618ac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1618b0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1618b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1618bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1618c0; return;
}


// Function: ListXYZF__4GIFSiiii
// Address: 0x1618c0 - 0x1618fc

void entry_1618fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1618fc: 0x3c0200ff
    SET_GPR_U32(ctx, 2, ((uint32_t)255 << 16));
    // 0x161900: 0x8e83000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x161904: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x161908: 0x118c00
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 17), 16));
    // 0x16190c: 0x2028024
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x161910: 0x2519025
    SET_GPR_U32(ctx, 18, OR32(GPR_U32(ctx, 18), GPR_U32(ctx, 17)));
    // 0x161914: 0x10803c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << (32 + 0));
    // 0x161918: 0x139e3c
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) << (32 + 24));
    // 0x16191c: 0x2508025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 18), GPR_U32(ctx, 16)));
    // 0x161920: 0x24620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 8));
    // 0x161924: 0xae82000c
    WRITE32(ADD32(GPR_U32(ctx, 20), 12), GPR_U32(ctx, 2));
    // 0x161928: 0x2138025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 19)));
    // 0x16192c: 0xfc700000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 16));
    // 0x161930: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x161934: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x161938: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16193c: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x161940: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161944: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161948: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: junk_00161950
// Address: 0x161950 - 0x161958

void entry_161988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161988: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x16198c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x161990: 0x31b3c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 12));
    // 0x161994: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x161998: 0x24440010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 16));
    // 0x16199c: 0x2038025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x1619a0: 0xae24000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 4));
    // 0x1619a4: 0xfc500000
    WRITE64(ADD32(GPR_U32(ctx, 2), 0), GPR_U64(ctx, 16));
    // 0x1619a8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1619ac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1619b0: 0xfc400008
    WRITE64(ADD32(GPR_U32(ctx, 2), 8), GPR_U64(ctx, 0));
    // 0x1619b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1619bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1619c0; return;
}


// Function: fn___4GLBS
// Address: 0x1619c0 - 0x161a0c

void entry_161a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161a0c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161a10: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x161a14: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x161a1c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 176));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_161a1c
// Address: 0x161a1c - 0x161a74

void entry_161a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161a1c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x161a20: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x161a24: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x161a28: 0x8c451990
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x161a2c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x161a30: 0xae030098
    WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 3));
    // 0x161a34: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x161a38: 0xe6000090
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 144), *(uint32_t*)&val); }
    // 0x161a3c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161a40: 0x68a2020f
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 527); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x161a44: 0x6ca20208
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 520); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x161a48: 0x68a30217
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 535); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x161a4c: 0x6ca30210
    { uint32_t addr = ADD32(GPR_U32(ctx, 5), 528); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x161a50: 0xb2020087
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 135); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x161a54: 0xb6020080
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 128); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x161a58: 0xb203008f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 143); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x161a5c: 0xb6030088
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 136); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x161a60: 0xae0000b0
    WRITE32(ADD32(GPR_U32(ctx, 16), 176), GPR_U32(ctx, 0));
    // 0x161a64: 0xae0000b4
    WRITE32(ADD32(GPR_U32(ctx, 16), 180), GPR_U32(ctx, 0));
    // 0x161a68: 0xae060094
    WRITE32(ADD32(GPR_U32(ctx, 16), 148), GPR_U32(ctx, 6));
    // 0x161a6c: 0xc0586e0
    SET_GPR_U32(ctx, 31, 0x161a74);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 172), *(uint32_t*)&val); }
    ResetStrip__4GLBS(rdram, ctx, runtime); return;
}


// Function: entry_161a74
// Address: 0x161a74 - 0x161a88

void entry_161a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161a74: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161a78: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161a7c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161a80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00161a88
// Address: 0x161a88 - 0x161aa0

void FUN_00161a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161a88: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x161a8c: 0x30a50001
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 1));
    // 0x161a90: 0x10a00003
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_161aa0(rdram, ctx, runtime); return;
    }
    // 0x161a98: 0xc0635de
    SET_GPR_U32(ctx, 31, 0x161aa0);
    fn___builtin_delete(rdram, ctx, runtime); return;
}


// Function: entry_161aa0
// Address: 0x161aa0 - 0x161ab0

void entry_161aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161aa0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161aa4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x161aac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x161ab0; return;
}


// Function: SetTransform__4GLBSP6VECTORP7MATRIX3
// Address: 0x161ab0 - 0x161ad4

void entry_161ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161ad4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x161ad8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x161adc: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x161ae4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_161ae4
// Address: 0x161ae4 - 0x161af4

void entry_161ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161ae4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x161ae8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x161aec: 0xc0622d2
    SET_GPR_U32(ctx, 31, 0x161af4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 64));
    LoadMatrixFromPosRotInverse__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_161af4
// Address: 0x161af4 - 0x161b10

void entry_161af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161af4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x161af8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x161afc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161b00: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161b04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x161b0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x161b10; return;
}


// Function: FindLights__4GLBSP6VECTORf
// Address: 0x161b10 - 0x161b60

void entry_161b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x161b60) {
        switch (ctx->pc) {
            case 0x161b6c: ctx->pc = 0; goto label_161b6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x161b60: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x161b64: 0xae02009c
    WRITE32(ADD32(GPR_U32(ctx, 16), 156), GPR_U32(ctx, 2));
    // 0x161b68: 0xae030094
    WRITE32(ADD32(GPR_U32(ctx, 16), 148), GPR_U32(ctx, 3));
label_161b6c:
    // 0x161b6c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161b70: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161b74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x161b7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x161b80; return;
}


// Function: ResetStrip__4GLBS
// Address: 0x161b80 - 0x161ba4

void entry_161ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161ba4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161ba8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BeginStrip__4GLBSP3SHD
// Address: 0x161bb0 - 0x161bcc

void entry_161bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161bcc: 0x3c02ffff
    SET_GPR_U32(ctx, 2, ((uint32_t)65535 << 16));
    // 0x161bd0: 0xae1100f8
    WRITE32(ADD32(GPR_U32(ctx, 16), 248), GPR_U32(ctx, 17));
    // 0x161bd4: 0x3442ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 65535));
    // 0x161bd8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161bdc: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x161be0: 0xc0589aa
    SET_GPR_U32(ctx, 31, 0x161be8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetRgba__4GLBSG4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_161be8
// Address: 0x161be8 - 0x161c00

void entry_161be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161be8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x161bec: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x161bf0: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161bf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x161bfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x161c00; return;
}


// Function: DrawPrelit__4GLBS
// Address: 0x161c00 - 0x161c4c

void entry_161c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161c4c: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161c50: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x161c54: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x161c5c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_161c5c
// Address: 0x161c5c - 0x161c98

void entry_161c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161c5c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161c60: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x161c64: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161c68: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x161c6c: 0xa4620010
    WRITE16(ADD32(GPR_U32(ctx, 3), 16), (uint16_t)GPR_U32(ctx, 2));
    // 0x161c70: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x161c74: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161c78: 0xa4530000
    WRITE16(ADD32(GPR_U32(ctx, 2), 0), (uint16_t)GPR_U32(ctx, 19));
    // 0x161c7c: 0x8e430124
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x161c80: 0x8fa70000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161c84: 0x31040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 1));
    // 0x161c88: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x161c8c: 0x24530024
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 2), 36));
    // 0x161c90: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x161c98);
    WRITE16(ADD32(GPR_U32(ctx, 7), 2), (uint16_t)GPR_U32(ctx, 19));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_161c98
// Address: 0x161c98 - 0x161cb8

void entry_161c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161c98: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161c9c: 0x37a90004
    SET_GPR_U32(ctx, 9, OR32(GPR_U32(ctx, 29), 4));
    // 0x161ca0: 0x8e460124
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x161ca4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161ca8: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x161cac: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x161cb0: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x161cb8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_161cb8
// Address: 0x161cb8 - 0x161cdc

void entry_161cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161cb8: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161cbc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161cc0: 0x8e460124
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x161cc4: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x161cc8: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x161ccc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x161cd0: 0x37a90008
    SET_GPR_U32(ctx, 9, OR32(GPR_U32(ctx, 29), 8));
    // 0x161cd4: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x161cdc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 2));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_161cdc
// Address: 0x161cdc - 0x161cec

void entry_161cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161cdc: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x161ce0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161ce4: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x161cec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_161cec
// Address: 0x161cec - 0x161da8

void entry_161cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x161cec) {
        switch (ctx->pc) {
            case 0x161d10: ctx->pc = 0; goto label_161d10;
            case 0x161d64: ctx->pc = 0; goto label_161d64;
            case 0x161d94: ctx->pc = 0; goto label_161d94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x161cec: 0x8e420124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x161cf0: 0x27b1000c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 12));
    // 0x161cf4: 0x18400027
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_161d94;
    }
    // 0x161cfc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x161d00: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x161d04: 0x26460128
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 296));
    // 0x161d08: 0x3c014700
    SET_GPR_U32(ctx, 1, ((uint32_t)18176 << 16));
    // 0x161d0c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
label_161d10:
    // 0x161d10: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x161d14: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x161d18: 0xc480001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 28)); ctx->f[0] = *(float*)&val; }
    // 0x161d1c: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x161d20: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x161d24: 0xc4800020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 32)); ctx->f[0] = *(float*)&val; }
    // 0x161d28: 0xe4600004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
    // 0x161d2c: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x161d30: 0xe4420008
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    // 0x161d34: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x161d38: 0x68820007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x161d3c: 0x6c820000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x161d40: 0x8c860008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x161d44: 0xb0620007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x161d48: 0xb4620000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x161d4c: 0xac660008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 6));
    // 0x161d50: 0x8c820024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 36)));
    // 0x161d54: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x161d58: 0x10400002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 128)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_161d64;
    }
    // 0x161d60: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
label_161d64:
    // 0x161d64: 0xe460000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 12), *(uint32_t*)&val); }
    // 0x161d68: 0x24860028
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 40));
    // 0x161d6c: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x161d70: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x161d74: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x161d78: 0x8e440124
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x161d7c: 0x2442000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 12));
    // 0x161d80: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x161d84: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x161d88: 0xa4202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 4)));
    // 0x161d8c: 0x1480ffe0
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_161d10;
    }
label_161d94:
    // 0x161d94: 0x269022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 8872));
    // 0x161d98: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x161d9c: 0x24a51a50
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 6736));
    // 0x161da0: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x161da8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_161da8
// Address: 0x161da8 - 0x161db8

void entry_161da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161da8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161dac: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x161db0: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x161db8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_161db8
// Address: 0x161db8 - 0x161ddc

void entry_161db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161db8: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161dbc: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x161dc0: 0x8e460124
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x161dc4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161dc8: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x161dcc: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x161dd0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x161dd4: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x161ddc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_161ddc
// Address: 0x161ddc - 0x161dec

void entry_161ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161ddc: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x161de0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161de4: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x161dec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_161dec
// Address: 0x161dec - 0x161eb8

void entry_161dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x161dec) {
        switch (ctx->pc) {
            case 0x161e08: ctx->pc = 0; goto label_161e08;
            case 0x161e20: ctx->pc = 0; goto label_161e20;
            case 0x161e34: ctx->pc = 0; goto label_161e34;
            case 0x161e80: ctx->pc = 0; goto label_161e80;
            case 0x161e90: ctx->pc = 0; goto label_161e90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x161dec: 0x8e420124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x161df0: 0x18400023
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_161e80;
    }
    // 0x161df8: 0x240b0028
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 40));
    // 0x161dfc: 0x240801fe
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 510));
    // 0x161e00: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x161e04: 0x0
    // NOP
label_161e08:
    // 0x161e08: 0xab1018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x161e0c: 0x24a90001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 5), 1));
    // 0x161e10: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x161e14: 0x522021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x161e18: 0x24870140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 320));
    // 0x161e1c: 0x0
    // NOP
label_161e20:
    // 0x161e20: 0x8e4300f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 248)));
    // 0x161e24: 0xe61021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    // 0x161e28: 0x90450000
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x161e2c: 0x510a0001
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 10)) {
        runtime->handleBreak(rdram, ctx);
        goto label_161e34;
    }
label_161e34:
    // 0x161e34: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x161e38: 0x8fa4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x161e3c: 0x90620004
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x161e40: 0x862021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x161e44: 0x451018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x161e48: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x161e4c: 0x28c30004
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), 4));
    // 0x161e50: 0x24420100
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 256));
    // 0x161e54: 0x48001a
    { int32_t divisor = GPR_S32(ctx, 8); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 8) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,8); } }
    // 0x161e58: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x161e5c: 0x1460fff0
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_161e20;
    }
    // 0x161e64: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x161e68: 0x120282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x161e6c: 0x8e430124
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x161e70: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x161e74: 0xa3182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 3)));
    // 0x161e78: 0x1460ffe3
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_161e08;
    }
label_161e80:
    // 0x161e80: 0x8e4400f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 248)));
    // 0x161e84: 0x8c820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x161e88: 0x1840002d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x161F40; return;
    }
label_161e90:
    // 0x161e90: 0x8c83001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 28)));
    // 0x161e94: 0x1110c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 3));
    // 0x161e98: 0x268422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 8872));
    // 0x161e9c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x161ea0: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x161ea4: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x161ea8: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x161eac: 0x27a80010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    // 0x161eb0: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x161eb8);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 20));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_161eb8
// Address: 0x161eb8 - 0x161eec

void entry_161eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x161eb8) {
        switch (ctx->pc) {
            case 0x161ecc: ctx->pc = 0; goto label_161ecc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x161eb8: 0x8e4200f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 248)));
    // 0x161ebc: 0x8c420024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x161ec0: 0x10400002
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_161ecc;
    }
    // 0x161ec8: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
label_161ecc:
    // 0x161ecc: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x161ed0: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x161ed4: 0x652818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x161ed8: 0x8fa40014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x161edc: 0x8fa60010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x161ee0: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x161ee4: 0xc063600
    SET_GPR_U32(ctx, 31, 0x161eec);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_161eec
// Address: 0x161eec - 0x161f50

void entry_161eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x161eec) {
        switch (ctx->pc) {
            case 0x161f40: ctx->pc = 0; goto label_161f40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x161eec: 0x8fa50014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x161ef0: 0x113040
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 17), 1));
    // 0x161ef4: 0x8e430124
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x161ef8: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x161efc: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x161f00: 0x34428000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32768));
    // 0x161f04: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x161f08: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x161f0c: 0x8fa40014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x161f10: 0x8c820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x161f14: 0x34428000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32768));
    // 0x161f18: 0xac820010
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 2));
    // 0x161f1c: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161f20: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x161f24: 0xa4730008
    WRITE16(ADD32(GPR_U32(ctx, 3), 8), (uint16_t)GPR_U32(ctx, 19));
    // 0x161f28: 0x8e4400f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 248)));
    // 0x161f2c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x161f30: 0x8c820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x161f34: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x161f38: 0x1440ffd5
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x161E90; return;
    }
label_161f40:
    // 0x161f40: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x161f44: 0x268422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 8872));
    // 0x161f48: 0xc07b908
    SET_GPR_U32(ctx, 31, 0x161f50);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 760));
    AddVifMscalf__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_161f50
// Address: 0x161f50 - 0x161f70

void entry_161f50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161f50: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x161f54: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x161f58: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x161f5c: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x161f60: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x161f64: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x161f68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawThreeWay__4GLBS
// Address: 0x161f70 - 0x161fc8

void entry_161fc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161fc8: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161fcc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x161fd0: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x161fd8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_161fd8
// Address: 0x161fd8 - 0x16203c

void entry_161fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x161fd8: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161fdc: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x161fe0: 0x2408fffc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967292));
    // 0x161fe4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x161fe8: 0xa4620010
    WRITE16(ADD32(GPR_U32(ctx, 3), 16), (uint16_t)GPR_U32(ctx, 2));
    // 0x161fec: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x161ff0: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x161ff4: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x161ff8: 0xa4740000
    WRITE16(ADD32(GPR_U32(ctx, 3), 0), (uint16_t)GPR_U32(ctx, 20));
    // 0x161ffc: 0x8e420124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x162000: 0x8fa70000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x162004: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x162008: 0x24540024
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 2), 36));
    // 0x16200c: 0xa4f40002
    WRITE16(ADD32(GPR_U32(ctx, 7), 2), (uint16_t)GPR_U32(ctx, 20));
    // 0x162010: 0x8e430124
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x162014: 0x8fa70000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x162018: 0x24620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 3));
    // 0x16201c: 0x481024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x162020: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x162024: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x162028: 0x282a021
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    // 0x16202c: 0xa4f4000e
    WRITE16(ADD32(GPR_U32(ctx, 7), 14), (uint16_t)GPR_U32(ctx, 20));
    // 0x162030: 0x8e420124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x162034: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x16203c);
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_16203c
// Address: 0x16203c - 0x162060

void entry_16203c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16203c: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x162040: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x162044: 0x8e460124
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x162048: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16204c: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x162050: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x162054: 0x37a90004
    SET_GPR_U32(ctx, 9, OR32(GPR_U32(ctx, 29), 4));
    // 0x162058: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x162060);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 3));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_162060
// Address: 0x162060 - 0x162070

void entry_162060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162060: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x162064: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x162068: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x162070);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_162070
// Address: 0x162070 - 0x162118

void entry_162070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162070) {
        switch (ctx->pc) {
            case 0x1620a0: ctx->pc = 0; goto label_1620a0;
            case 0x1620d8: ctx->pc = 0; goto label_1620d8;
            case 0x1620e0: ctx->pc = 0; goto label_1620e0;
            case 0x162104: ctx->pc = 0; goto label_162104;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162070: 0x8e420124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x162074: 0x27b10008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 8));
    // 0x162078: 0x27b3000c
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 12));
    // 0x16207c: 0x27b60010
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 16));
    // 0x162080: 0x18400020
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_162104;
    }
    // 0x162088: 0x3c014700
    SET_GPR_U32(ctx, 1, ((uint32_t)18176 << 16));
    // 0x16208c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x162090: 0x26440128
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 296));
    // 0x162094: 0x3c0146e0
    SET_GPR_U32(ctx, 1, ((uint32_t)18144 << 16));
    // 0x162098: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16209c: 0x0
    // NOP
label_1620a0:
    // 0x1620a0: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1620a4: 0x80102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1620a8: 0x68450007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1620ac: 0x6c450000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1620b0: 0x8c460008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1620b4: 0xb0650007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1620b8: 0xb4650000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1620bc: 0xac660008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 6));
    // 0x1620c0: 0x8c420024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x1620c4: 0x10400004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1620d8;
    }
    // 0x1620cc: 0xc6400080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 128)); ctx->f[0] = *(float*)&val; }
    // 0x1620d0: 0x10000003
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1620e0;
    }
label_1620d8:
    // 0x1620d8: 0xc6400080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 128)); ctx->f[0] = *(float*)&val; }
    // 0x1620dc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
label_1620e0:
    // 0x1620e0: 0xe440000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x1620e4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x1620e8: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1620ec: 0x8e430124
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x1620f0: 0x24840028
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 40));
    // 0x1620f4: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1620f8: 0xe3182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 3)));
    // 0x1620fc: 0x1460ffe8
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1620a0;
    }
label_162104:
    // 0x162104: 0x26b022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 8872));
    // 0x162108: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x16210c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x162110: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x162118);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_162118
// Address: 0x162118 - 0x162144

void entry_162118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162118: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16211c: 0x2403fffc
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967292));
    // 0x162120: 0x8e460124
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x162124: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x162128: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16212c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x162130: 0x24c60003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 3));
    // 0x162134: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x162138: 0xc33024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x16213c: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x162144);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_162144
// Address: 0x162144 - 0x162168

void entry_162144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162144: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x162148: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16214c: 0x8e460124
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x162150: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x162154: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x162158: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16215c: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x162160: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x162168);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_162168
// Address: 0x162168 - 0x162178

void entry_162168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162168: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16216c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x162170: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x162178);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_162178
// Address: 0x162178 - 0x162188

void entry_162178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162178: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x16217c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x162180: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x162188);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 648));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_162188
// Address: 0x162188 - 0x16223c

void entry_162188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162188) {
        switch (ctx->pc) {
            case 0x1621a0: ctx->pc = 0; goto label_1621a0;
            case 0x1621b8: ctx->pc = 0; goto label_1621b8;
            case 0x1621fc: ctx->pc = 0; goto label_1621fc;
            case 0x162214: ctx->pc = 0; goto label_162214;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162188: 0x8e420124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x16218c: 0x18400033
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x16225C; return;
    }
    // 0x162194: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x162198: 0x24130028
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 40));
    // 0x16219c: 0x2651013c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 316));
label_1621a0:
    // 0x1621a0: 0xf31018
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1621a4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1621a8: 0x24f00004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 7), 4));
    // 0x1621ac: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1621b0: 0x512821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x1621b4: 0x0
    // NOP
label_1621b8:
    // 0x1621b8: 0x8e430124
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x1621bc: 0xe81021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 8)));
    // 0x1621c0: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x1621c4: 0x1040000d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1621fc;
    }
    // 0x1621cc: 0xc4a0fff8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4294967288)); ctx->f[0] = *(float*)&val; }
    // 0x1621d0: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1621d4: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x1621d8: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1621dc: 0xc4a0fffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4294967292)); ctx->f[0] = *(float*)&val; }
    // 0x1621e0: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1621e4: 0xe4600010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 16), *(uint32_t*)&val); }
    // 0x1621e8: 0x8fa20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x1621ec: 0xc4a00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1621f0: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x1621f4: 0x10000007
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 32), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_162214;
    }
label_1621fc:
    // 0x1621fc: 0x461821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x162200: 0xe4740020
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 3), 32), *(uint32_t*)&val); }
    // 0x162204: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x162208: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x16220c: 0xe4940010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 4), 16), *(uint32_t*)&val); }
    // 0x162210: 0xe4540000
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
label_162214:
    // 0x162214: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x162218: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x16221c: 0x29020004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), 4));
    // 0x162220: 0x1440ffe5
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 40));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1621b8;
    }
    // 0x162228: 0x8fa40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x16222c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x162230: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x162234: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x16223c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 48));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_16223c
// Address: 0x16223c - 0x1622f4

void entry_16223c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16223c) {
        switch (ctx->pc) {
            case 0x16225c: ctx->pc = 0; goto label_16225c;
            case 0x162270: ctx->pc = 0; goto label_162270;
            case 0x162288: ctx->pc = 0; goto label_162288;
            case 0x16229c: ctx->pc = 0; goto label_16229c;
            case 0x1622e8: ctx->pc = 0; goto label_1622e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16223c: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x162240: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x162244: 0x8e420124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x162248: 0x24630040
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 64));
    // 0x16224c: 0xe2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 2)));
    // 0x162250: 0x1440ffd3
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1621A0; return;
    }
    // 0x162258: 0x8e420124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 292)));
label_16225c:
    // 0x16225c: 0x18400022
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1622e8;
    }
    // 0x162264: 0x240b0028
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 40));
    // 0x162268: 0x240801fe
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 510));
    // 0x16226c: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_162270:
    // 0x162270: 0xeb1818
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162274: 0x24e90001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 7), 1));
    // 0x162278: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16227c: 0x721021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x162280: 0x24470140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 320));
    // 0x162284: 0x0
    // NOP
label_162288:
    // 0x162288: 0x8e4300f8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 248)));
    // 0x16228c: 0xe61021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 6)));
    // 0x162290: 0x90450000
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x162294: 0x510a0001
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 10)) {
        runtime->handleBreak(rdram, ctx);
        goto label_16229c;
    }
label_16229c:
    // 0x16229c: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1622a0: 0x8fa4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1622a4: 0x90620004
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x1622a8: 0x862021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x1622ac: 0x451018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1622b0: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1622b4: 0x28c30004
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), 4));
    // 0x1622b8: 0x24420100
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 256));
    // 0x1622bc: 0x48001a
    { int32_t divisor = GPR_S32(ctx, 8); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 2) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 8) % divisor); } else { ctx->lo = (GPR_S32(ctx,2) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,8); } }
    // 0x1622c0: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x1622c4: 0x1460fff0
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_162288;
    }
    // 0x1622cc: 0x8fa2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x1622d0: 0x120382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1622d4: 0x8e430124
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x1622d8: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x1622dc: 0xe3182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 3)));
    // 0x1622e0: 0x1460ffe3
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_162270;
    }
label_1622e8:
    // 0x1622e8: 0x26a422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 8872));
    // 0x1622ec: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1622f4);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1622f4
// Address: 0x1622f4 - 0x162320

void entry_1622f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1622f4) {
        switch (ctx->pc) {
            case 0x162308: ctx->pc = 0; goto label_162308;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1622f4: 0x8e4200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 180)));
    // 0x1622f8: 0x1840000d
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 184));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x162330; return;
    }
    // 0x162300: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x162304: 0x0
    // NOP
label_162308:
    // 0x162308: 0x26a422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 8872));
    // 0x16230c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x162310: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x162314: 0x8cc50418
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 1048)));
    // 0x162318: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x162320);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1056));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_162320
// Address: 0x162320 - 0x16233c

void entry_162320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162320) {
        switch (ctx->pc) {
            case 0x162330: ctx->pc = 0; goto label_162330;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162320: 0x8e4200b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 180)));
    // 0x162324: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x162328: 0x5440fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x162308; return;
    }
label_162330:
    // 0x162330: 0x26b022a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 8872));
    // 0x162334: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x16233c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_16233c
// Address: 0x16233c - 0x16234c

void entry_16233c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16233c: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x162340: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x162344: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x16234c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4624));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_16234c
// Address: 0x16234c - 0x162354

void entry_16234c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16234c: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x162354);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_162354
// Address: 0x162354 - 0x162364

void entry_162354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162354: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x162358: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16235c: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x162364);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_162364
// Address: 0x162364 - 0x162384

void entry_162364(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162364: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x162368: 0x2c0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x16236c: 0x8e460124
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x162370: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x162374: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x162378: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16237c: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x162384);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_162384
// Address: 0x162384 - 0x162394

void entry_162384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162384: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x162388: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16238c: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x162394);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_162394
// Address: 0x162394 - 0x1623a4

void entry_162394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162394: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x162398: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16239c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x1623a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 6832));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_1623a4
// Address: 0x1623a4 - 0x162440

void entry_1623a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1623a4) {
        switch (ctx->pc) {
            case 0x1623c0: ctx->pc = 0; goto label_1623c0;
            case 0x162400: ctx->pc = 0; goto label_162400;
            case 0x162418: ctx->pc = 0; goto label_162418;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1623a4: 0x8e420124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x1623a8: 0x18400015
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_162400;
    }
    // 0x1623b0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1623b4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1623b8: 0x26440128
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 296));
    // 0x1623bc: 0x0
    // NOP
label_1623c0:
    // 0x1623c0: 0xc480001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 28)); ctx->f[0] = *(float*)&val; }
    // 0x1623c4: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1623c8: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1623cc: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x1623d0: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1623d4: 0xc4800020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 32)); ctx->f[0] = *(float*)&val; }
    // 0x1623d8: 0x24840028
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 40));
    // 0x1623dc: 0xe4600004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
    // 0x1623e0: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1623e4: 0xe4410008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    // 0x1623e8: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1623ec: 0x8e420124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x1623f0: 0x2463000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 12));
    // 0x1623f4: 0xe2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 2)));
    // 0x1623f8: 0x1440fff1
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1623c0;
    }
label_162400:
    // 0x162400: 0x8e4400f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 248)));
    // 0x162404: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x162408: 0x8c820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x16240c: 0x1840002f
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1624CC; return;
    }
    // 0x162414: 0x0
    // NOP
label_162418:
    // 0x162418: 0x8c83001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 28)));
    // 0x16241c: 0x1110c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 3));
    // 0x162420: 0x26a422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 8872));
    // 0x162424: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x162428: 0x628021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x16242c: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x162430: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x162434: 0x27a80014
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 20));
    // 0x162438: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x162440);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 24));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_162440
// Address: 0x162440 - 0x162478

void entry_162440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162440) {
        switch (ctx->pc) {
            case 0x162454: ctx->pc = 0; goto label_162454;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162440: 0x8e4200f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 248)));
    // 0x162444: 0x8c420024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x162448: 0x10400002
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_162454;
    }
    // 0x162450: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
label_162454:
    // 0x162454: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x162458: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x16245c: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x162460: 0x652818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162464: 0x8fa40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x162468: 0x8fa60014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x16246c: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x162470: 0xc063600
    SET_GPR_U32(ctx, 31, 0x162478);
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_162478
// Address: 0x162478 - 0x1624dc

void entry_162478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162478) {
        switch (ctx->pc) {
            case 0x1624cc: ctx->pc = 0; goto label_1624cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162478: 0x8fa50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x16247c: 0x133040
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 19), 1));
    // 0x162480: 0x8e430124
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 292)));
    // 0x162484: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x162488: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x16248c: 0x34428000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32768));
    // 0x162490: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x162494: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x162498: 0x8fa40018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x16249c: 0x8c820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1624a0: 0x34428000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32768));
    // 0x1624a4: 0xac820010
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 2));
    // 0x1624a8: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1624ac: 0x661821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1624b0: 0xa4740008
    WRITE16(ADD32(GPR_U32(ctx, 3), 8), (uint16_t)GPR_U32(ctx, 20));
    // 0x1624b4: 0x8e4400f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 248)));
    // 0x1624b8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1624bc: 0x8c820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 24)));
    // 0x1624c0: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1624c4: 0x1440ffd4
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x162418; return;
    }
label_1624cc:
    // 0x1624cc: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x1624d0: 0x26a422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 21), 8872));
    // 0x1624d4: 0xc07b908
    SET_GPR_U32(ctx, 31, 0x1624dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 16));
    AddVifMscalf__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_1624dc
// Address: 0x1624dc - 0x162508

void entry_1624dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1624dc: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1624e0: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1624e4: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1624e8: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1624ec: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1624f0: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1624f4: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1624f8: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1624fc: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x162500: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EndStrip__4GLBS
// Address: 0x162508 - 0x162544

void entry_162544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162544) {
        switch (ctx->pc) {
            case 0x16254c: ctx->pc = 0; goto label_16254c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162544: 0x10000048
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162668; return;
    }
label_16254c:
    // 0x16254c: 0xc059996
    SET_GPR_U32(ctx, 31, 0x162554);
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    RotateVu1Buffer__Fv(rdram, ctx, runtime); return;
}


// Function: entry_162554
// Address: 0x162554 - 0x16256c

void entry_162554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162554: 0x261222a8
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 8872));
    // 0x162558: 0x2406000b
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 11));
    // 0x16255c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x162560: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x162564: 0xc07b958
    SET_GPR_U32(ctx, 31, 0x16256c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    CbUnpackSetup__4VIFS3UPKii(rdram, ctx, runtime); return;
}


// Function: entry_16256c
// Address: 0x16256c - 0x162608

void entry_16256c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16256c) {
        switch (ctx->pc) {
            case 0x162590: ctx->pc = 0; goto label_162590;
            case 0x1625ac: ctx->pc = 0; goto label_1625ac;
            case 0x1625b8: ctx->pc = 0; goto label_1625b8;
            case 0x1625ec: ctx->pc = 0; goto label_1625ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16256c: 0x40582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x162570: 0x8e48000c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x162574: 0xb1083
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 11), 2));
    // 0x162578: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16257c: 0x30460003
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 2), 3));
    // 0x162580: 0x10c0000a
    SET_GPR_U32(ctx, 10, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_1625ac;
    }
    // 0x162588: 0xc0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x16258c: 0x0
    // NOP
label_162590:
    // 0x162590: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x162594: 0x2529ffff
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294967295));
    // 0x162598: 0x24e70004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    // 0x16259c: 0xad020000
    WRITE32(ADD32(GPR_U32(ctx, 8), 0), GPR_U32(ctx, 2));
    // 0x1625a0: 0x0
    // NOP
    // 0x1625a4: 0x1520fffa
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4));
    if (GPR_U32(ctx, 9) != GPR_U32(ctx, 0)) {
        goto label_162590;
    }
label_1625ac:
    // 0x1625ac: 0x1940000f
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 10) <= 0) {
        goto label_1625ec;
    }
    // 0x1625b4: 0x0
    // NOP
label_1625b8:
    // 0x1625b8: 0x8ce40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1625bc: 0x25290004
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4));
    // 0x1625c0: 0x8ce50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x1625c4: 0x12a302a
    SET_GPR_U32(ctx, 6, SLT32(GPR_S32(ctx, 9), GPR_S32(ctx, 10)));
    // 0x1625c8: 0x8ce20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x1625cc: 0x8ce3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x1625d0: 0xad040000
    WRITE32(ADD32(GPR_U32(ctx, 8), 0), GPR_U32(ctx, 4));
    // 0x1625d4: 0x24e70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    // 0x1625d8: 0xad050004
    WRITE32(ADD32(GPR_U32(ctx, 8), 4), GPR_U32(ctx, 5));
    // 0x1625dc: 0xad020008
    WRITE32(ADD32(GPR_U32(ctx, 8), 8), GPR_U32(ctx, 2));
    // 0x1625e0: 0xad03000c
    WRITE32(ADD32(GPR_U32(ctx, 8), 12), GPR_U32(ctx, 3));
    // 0x1625e4: 0x14c0fff4
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 16));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_1625b8;
    }
label_1625ec:
    // 0x1625ec: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x1625f0: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x1625f4: 0x260422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 8872));
    // 0x1625f8: 0x24a518c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 6336));
    // 0x1625fc: 0x4b1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 11)));
    // 0x162600: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x162608);
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 2));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_162608
// Address: 0x162608 - 0x16264c

void entry_162608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162608) {
        switch (ctx->pc) {
            case 0x162634: ctx->pc = 0; goto label_162634;
            case 0x162644: ctx->pc = 0; goto label_162644;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162608: 0x8e2200f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 248)));
    // 0x16260c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x162610: 0x90440000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x162614: 0x1083000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_162644;
    }
    // 0x16261c: 0x10400005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 9));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_162634;
    }
    // 0x162624: 0x1080000b
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162654; return;
    }
    // 0x16262c: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_16265c(rdram, ctx, runtime); return;
    }
label_162634:
    // 0x162634: 0x10400009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 6));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_16265c(rdram, ctx, runtime); return;
    }
    // 0x16263c: 0x14400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_16265c(rdram, ctx, runtime); return;
    }
label_162644:
    // 0x162644: 0xc058700
    SET_GPR_U32(ctx, 31, 0x16264c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DrawPrelit__4GLBS(rdram, ctx, runtime); return;
}


// Function: entry_16264c
// Address: 0x16264c - 0x16265c

void entry_16264c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16264c) {
        switch (ctx->pc) {
            case 0x162654: ctx->pc = 0; goto label_162654;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16264c: 0x10000003
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_16265c(rdram, ctx, runtime); return;
    }
label_162654:
    // 0x162654: 0xc0587dc
    SET_GPR_U32(ctx, 31, 0x16265c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    DrawThreeWay__4GLBS(rdram, ctx, runtime); return;
}


// Function: entry_16265c
// Address: 0x16265c - 0x162664

void entry_16265c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16265c: 0xc0586e0
    SET_GPR_U32(ctx, 31, 0x162664);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ResetStrip__4GLBS(rdram, ctx, runtime); return;
}


// Function: entry_162664
// Address: 0x162664 - 0x162680

void entry_162664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162664) {
        switch (ctx->pc) {
            case 0x162668: ctx->pc = 0; goto label_162668;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162664: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_162668:
    // 0x162668: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16266c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x162670: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x162674: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16267c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x162680; return;
}


// Function: SetNormal__4GLBSP6VECTOR
// Address: 0x162680 - 0x1626a0

void entry_1627c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1627c8: 0xc058942
    SET_GPR_U32(ctx, 31, 0x1627d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EndStrip__4GLBS(rdram, ctx, runtime); return;
}


// Function: entry_1627d0
// Address: 0x1627d0 - 0x1627dc

void entry_1627d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1627d0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1627d4: 0xc0586ec
    SET_GPR_U32(ctx, 31, 0x1627dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BeginStrip__4GLBSP3SHD(rdram, ctx, runtime); return;
}


// Function: entry_1627dc
// Address: 0x1627dc - 0x1627ec

void entry_1627dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1627dc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1627e0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1627e4: 0xc063600
    SET_GPR_U32(ctx, 31, 0x1627ec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 80));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_1627ec
// Address: 0x1627ec - 0x162810

void entry_1627ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1627ec) {
        switch (ctx->pc) {
            case 0x1627f4: ctx->pc = 0; goto label_1627f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1627ec: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1627f0: 0xae020124
    WRITE32(ADD32(GPR_U32(ctx, 16), 292), GPR_U32(ctx, 2));
label_1627f4:
    // 0x1627f4: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1627f8: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1627fc: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x162800: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x162804: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16280c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x162810; return;
}


// Function: BuildGlobsetSaaArray__FP7GLOBSET
// Address: 0x162810 - 0x16282c

void entry_16282c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16282c) {
        switch (ctx->pc) {
            case 0x162848: ctx->pc = 0; goto label_162848;
            case 0x16286c: ctx->pc = 0; goto label_16286c;
            case 0x162880: ctx->pc = 0; goto label_162880;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16282c: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x162830: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x162834: 0xae020054
    WRITE32(ADD32(GPR_U32(ctx, 16), 84), GPR_U32(ctx, 2));
    // 0x162838: 0x18600011
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_162880;
    }
    // 0x162840: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x162844: 0x0
    // NOP
label_162848:
    // 0x162848: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x16284c: 0xc21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x162850: 0x8c440038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 56)));
    // 0x162854: 0x10800005
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 7), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_16286c;
    }
    // 0x16285c: 0x8e030054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 84)));
    // 0x162860: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x162864: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x162868: 0xac440000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 4));
label_16286c:
    // 0x16286c: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x162870: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x162874: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x162878: 0x1440fff3
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 112));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_162848;
    }
label_162880:
    // 0x162880: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x162884: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x162888: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadGlobsetFromBrx__FP7GLOBSETP18CBinaryInputStreamP3ALO
// Address: 0x162890 - 0x1628dc

void entry_1628dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1628dc: 0xafa200ec
    WRITE32(ADD32(GPR_U32(ctx, 29), 236), GPR_U32(ctx, 2));
    // 0x1628e0: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x1628e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1628e8
// Address: 0x1628e8 - 0x1628f4

void entry_1628e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1628e8: 0xafa200f0
    WRITE32(ADD32(GPR_U32(ctx, 29), 240), GPR_U32(ctx, 2));
    // 0x1628ec: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x1628f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1628f4
// Address: 0x1628f4 - 0x162908

void entry_1628f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1628f4: 0x24040090
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 144));
    // 0x1628f8: 0x8fa300e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x1628fc: 0x442018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162900: 0xc063570
    SET_GPR_U32(ctx, 31, 0x162908);
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_162908
// Address: 0x162908 - 0x16291c

void entry_162908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162908: 0x8fa500e4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x16290c: 0x8ca40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x162910: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
    // 0x162914: 0xc063570
    SET_GPR_U32(ctx, 31, 0x16291c);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16291c
// Address: 0x16291c - 0x162938

void entry_16291c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16291c) {
        switch (ctx->pc) {
            case 0x162930: ctx->pc = 0; goto label_162930;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16291c: 0x8fa600e4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x162920: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x162924: 0x1860000e
    WRITE32(ADD32(GPR_U32(ctx, 6), 8), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x162960; return;
    }
    // 0x16292c: 0x0
    // NOP
label_162930:
    // 0x162930: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x162938);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162938
// Address: 0x162938 - 0x16296c

void entry_162938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162938) {
        switch (ctx->pc) {
            case 0x162960: ctx->pc = 0; goto label_162960;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162938: 0x8fa700e4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x16293c: 0x101880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 16), 2));
    // 0x162940: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x162944: 0x8ce40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x162948: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x16294c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x162950: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x162954: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x162958: 0x1440fff5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x162930; return;
    }
label_162960:
    // 0x162960: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162964: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x16296c);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_16296c
// Address: 0x16296c - 0x16297c

void entry_16296c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16296c: 0x8fa800e4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x162970: 0x22080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 2));
    // 0x162974: 0xc063570
    SET_GPR_U32(ctx, 31, 0x16297c);
    WRITE32(ADD32(GPR_U32(ctx, 8), 64), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16297c
// Address: 0x16297c - 0x162998

void entry_16297c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16297c: 0x8fa900e4
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x162980: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x162984: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162988: 0x8d250040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 9), 64)));
    // 0x16298c: 0xad220044
    WRITE32(ADD32(GPR_U32(ctx, 9), 68), GPR_U32(ctx, 2));
    // 0x162990: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x162998);
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 2));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_162998
// Address: 0x162998 - 0x1629ac

void entry_162998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162998: 0x8fa200e4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x16299c: 0x8c440040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1629a0: 0x8c450044
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 68)));
    // 0x1629a4: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x1629ac);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_1629ac
// Address: 0x1629ac - 0x1629bc

void entry_1629ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1629ac: 0x8fa300e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x1629b0: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1629b4: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1629bc);
    WRITE32(ADD32(GPR_U32(ctx, 3), 72), GPR_U32(ctx, 2));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1629bc
// Address: 0x1629bc - 0x1629d0

void entry_1629bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1629bc: 0x24040070
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 112));
    // 0x1629c0: 0x8fa500e4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x1629c4: 0x442018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1629c8: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1629d0);
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1629d0
// Address: 0x1629d0 - 0x1629e8

void entry_1629d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1629d0: 0x8fa600e4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x1629d4: 0x24040028
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 40));
    // 0x1629d8: 0x8cc3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1629dc: 0xacc20010
    WRITE32(ADD32(GPR_U32(ctx, 6), 16), GPR_U32(ctx, 2));
    // 0x1629e0: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1629e8);
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1629e8
// Address: 0x1629e8 - 0x162a38

void entry_1629e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1629e8) {
        switch (ctx->pc) {
            case 0x162a08: ctx->pc = 0; goto label_162a08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1629e8: 0x8fa700e4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x1629ec: 0x8ce3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x1629f0: 0x186003c2
    WRITE32(ADD32(GPR_U32(ctx, 7), 20), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1638FC; return;
    }
    // 0x1629f8: 0x3c080025
    SET_GPR_U32(ctx, 8, ((uint32_t)37 << 16));
    // 0x1629fc: 0xc514a710
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 4294944528)); ctx->f[20] = *(float*)&val; }
    // 0x162a00: 0x24090070
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 112));
    // 0x162a04: 0x0
    // NOP
label_162a08:
    // 0x162a08: 0x24020028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 40));
    // 0x162a0c: 0x8fa400e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x162a10: 0x2495018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 9); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162a14: 0x2421018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162a18: 0x8c830010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x162a1c: 0x8c850014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    // 0x162a20: 0x6a1821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 10)));
    // 0x162a24: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162a28: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x162a2c: 0xafa300f4
    WRITE32(ADD32(GPR_U32(ctx, 29), 244), GPR_U32(ctx, 3));
    // 0x162a30: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x162a38);
    WRITE32(ADD32(GPR_U32(ctx, 29), 248), GPR_U32(ctx, 5));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162a38
// Address: 0x162a38 - 0x162a50

void entry_162a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162a38: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x162a3c: 0x32110001
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 16), 1));
    // 0x162a40: 0x12200045
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162B58; return;
    }
    // 0x162a48: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x162a50);
    WRITE32(ADD32(GPR_U32(ctx, 29), 344), GPR_U32(ctx, 17));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162a50
// Address: 0x162a50 - 0x162b3c

void entry_162a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162a50) {
        switch (ctx->pc) {
            case 0x162aa8: ctx->pc = 0; goto label_162aa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162a50: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x162a54: 0x32050100
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 16), 256));
    // 0x162a58: 0x24070070
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 112));
    // 0x162a5c: 0xafa5013c
    WRITE32(ADD32(GPR_U32(ctx, 29), 316), GPR_U32(ctx, 5));
    // 0x162a60: 0x32110002
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 16), 2));
    // 0x162a64: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x162a68: 0x8fa600e4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x162a6c: 0xa71018
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162a70: 0x8fa400f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162a74: 0x8cc30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 16)));
    // 0x162a78: 0x32130004
    SET_GPR_U32(ctx, 19, AND32(GPR_U32(ctx, 16), 4));
    // 0x162a7c: 0xafb2014c
    WRITE32(ADD32(GPR_U32(ctx, 29), 332), GPR_U32(ctx, 18));
    // 0x162a80: 0x24880040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 4), 64));
    // 0x162a84: 0x32120200
    SET_GPR_U32(ctx, 18, AND32(GPR_U32(ctx, 16), 512));
    // 0x162a88: 0x32140008
    SET_GPR_U32(ctx, 20, AND32(GPR_U32(ctx, 16), 8));
    // 0x162a8c: 0x32150010
    SET_GPR_U32(ctx, 21, AND32(GPR_U32(ctx, 16), 16));
    // 0x162a90: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x162a94: 0x32160020
    SET_GPR_U32(ctx, 22, AND32(GPR_U32(ctx, 16), 32));
    // 0x162a98: 0x321e0040
    SET_GPR_U32(ctx, 30, AND32(GPR_U32(ctx, 16), 64));
    // 0x162a9c: 0xafa80160
    WRITE32(ADD32(GPR_U32(ctx, 29), 352), GPR_U32(ctx, 8));
    // 0x162aa0: 0x24430060
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 96));
    // 0x162aa4: 0x32100080
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 128));
label_162aa8:
    // 0x162aa8: 0x78490000
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x162aac: 0x78460010
    SET_GPR_VEC(ctx, 6, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x162ab0: 0x7c890000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 9));
    // 0x162ab4: 0x7c860010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 6));
    // 0x162ab8: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x162abc: 0x1443fffa
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        goto label_162aa8;
    }
    // 0x162ac4: 0x78490000
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x162ac8: 0x24030028
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 40));
    // 0x162acc: 0x7c890000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 9));
    // 0x162ad0: 0xa31818
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162ad4: 0x8fa900e4
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x162ad8: 0x24040040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 64));
    // 0x162adc: 0x8d220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 20)));
    // 0x162ae0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x162ae4: 0x8fa200f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 248)));
    // 0x162ae8: 0x68650007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x162aec: 0x6c650000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x162af0: 0x6866000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x162af4: 0x6c660008
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 6, (GPR_U64(ctx, 6) & ~mask) | (aligned_data & mask)); }
    // 0x162af8: 0x68670017
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x162afc: 0x6c670010
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x162b00: 0x6868001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x162b04: 0x6c680018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x162b08: 0xb0450007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x162b0c: 0xb4450000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x162b10: 0xb046000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x162b14: 0xb4460008
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 6) & mask); WRITE64(aligned_addr, new_data); }
    // 0x162b18: 0xb0470017
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 23); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x162b1c: 0xb4470010
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 16); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x162b20: 0xb048001f
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 31); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x162b24: 0xb4480018
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 24); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x162b28: 0x68650027
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x162b2c: 0x6c650020
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x162b30: 0xb0450027
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 39); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x162b34: 0xc063540
    SET_GPR_U32(ctx, 31, 0x162b3c);
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 32); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_162b3c
// Address: 0x162b3c - 0x162b50

void entry_162b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162b3c: 0x8fa900f4
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162b40: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162b44: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x162b48: 0xc04dfc2
    SET_GPR_U32(ctx, 31, 0x162b50);
    WRITE32(ADD32(GPR_U32(ctx, 9), 104), GPR_U32(ctx, 2));
    ReadMatrix4__18CBinaryInputStreamP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_162b50
// Address: 0x162b50 - 0x162be8

void entry_162b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162b50) {
        switch (ctx->pc) {
            case 0x162b58: ctx->pc = 0; goto label_162b58;
            case 0x162bd8: ctx->pc = 0; goto label_162bd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162b50: 0x10000021
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_162bd8;
    }
label_162b58:
    // 0x162b58: 0x8fa300f4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162b5c: 0x32020100
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), 256));
    // 0x162b60: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x162b64: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x162b68: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x162b6c: 0x3c015015
    SET_GPR_U32(ctx, 1, ((uint32_t)20501 << 16));
    // 0x162b70: 0x342102f9
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 761));
    // 0x162b74: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x162b78: 0x24660040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 64));
    // 0x162b7c: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x162b80: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x162b84: 0x32110002
    SET_GPR_U32(ctx, 17, AND32(GPR_U32(ctx, 16), 2));
    // 0x162b88: 0xafb2014c
    WRITE32(ADD32(GPR_U32(ctx, 29), 332), GPR_U32(ctx, 18));
    // 0x162b8c: 0x32130004
    SET_GPR_U32(ctx, 19, AND32(GPR_U32(ctx, 16), 4));
    // 0x162b90: 0xafa2013c
    WRITE32(ADD32(GPR_U32(ctx, 29), 316), GPR_U32(ctx, 2));
    // 0x162b94: 0x32120200
    SET_GPR_U32(ctx, 18, AND32(GPR_U32(ctx, 16), 512));
    // 0x162b98: 0xafa00158
    WRITE32(ADD32(GPR_U32(ctx, 29), 344), GPR_U32(ctx, 0));
    // 0x162b9c: 0x32140008
    SET_GPR_U32(ctx, 20, AND32(GPR_U32(ctx, 16), 8));
    // 0x162ba0: 0xe461001c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 28), *(uint32_t*)&val); }
    // 0x162ba4: 0x32150010
    SET_GPR_U32(ctx, 21, AND32(GPR_U32(ctx, 16), 16));
    // 0x162ba8: 0xe4620020
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 3), 32), *(uint32_t*)&val); }
    // 0x162bac: 0x32160020
    SET_GPR_U32(ctx, 22, AND32(GPR_U32(ctx, 16), 32));
    // 0x162bb0: 0xe4740024
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 3), 36), *(uint32_t*)&val); }
    // 0x162bb4: 0x321e0040
    SET_GPR_U32(ctx, 30, AND32(GPR_U32(ctx, 16), 64));
    // 0x162bb8: 0xe460003c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 60), *(uint32_t*)&val); }
    // 0x162bbc: 0x32100080
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 128));
    // 0x162bc0: 0xe4600050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 80), *(uint32_t*)&val); }
    // 0x162bc4: 0x8fa400ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 236)));
    // 0x162bc8: 0xac640028
    WRITE32(ADD32(GPR_U32(ctx, 3), 40), GPR_U32(ctx, 4));
    // 0x162bcc: 0x8fa500f8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 248)));
    // 0x162bd0: 0xe4a00010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 16), *(uint32_t*)&val); }
    // 0x162bd4: 0xafa60160
    WRITE32(ADD32(GPR_U32(ctx, 29), 352), GPR_U32(ctx, 6));
label_162bd8:
    // 0x162bd8: 0x12200005
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162BF0; return;
    }
    // 0x162be0: 0xc04df10
    SET_GPR_U32(ctx, 31, 0x162be8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162be8
// Address: 0x162be8 - 0x162c00

void entry_162be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162be8) {
        switch (ctx->pc) {
            case 0x162bf0: ctx->pc = 0; goto label_162bf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162be8: 0x8fa700f8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 248)));
    // 0x162bec: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
label_162bf0:
    // 0x162bf0: 0x12400005
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162C08; return;
    }
    // 0x162bf8: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x162c00);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162c00
// Address: 0x162c00 - 0x162c18

void entry_162c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162c00) {
        switch (ctx->pc) {
            case 0x162c08: ctx->pc = 0; goto label_162c08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162c00: 0x8fa800f4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162c04: 0xe5000050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 8), 80), *(uint32_t*)&val); }
label_162c08:
    // 0x162c08: 0x12600010
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162C4C; return;
    }
    // 0x162c10: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x162c18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162c18
// Address: 0x162c18 - 0x162c5c

void entry_162c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162c18) {
        switch (ctx->pc) {
            case 0x162c3c: ctx->pc = 0; goto label_162c3c;
            case 0x162c4c: ctx->pc = 0; goto label_162c4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162c18: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x162c1c: 0x3c090025
    SET_GPR_U32(ctx, 9, ((uint32_t)37 << 16));
    // 0x162c20: 0xc520a710
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 4294944528)); ctx->f[0] = *(float*)&val; }
    // 0x162c24: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x162c28: 0x0
    // NOP
    // 0x162c2c: 0x45000003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_162c3c;
    }
    // 0x162c34: 0x10000005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 36), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_162c4c;
    }
label_162c3c:
    // 0x162c3c: 0x46000805
    ctx->f[0] = FPU_ABS_S(ctx->f[1]);
    // 0x162c40: 0x8fa300f4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162c44: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x162c48: 0xe4600024
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 36), *(uint32_t*)&val); }
label_162c4c:
    // 0x162c4c: 0x12800005
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162C64; return;
    }
    // 0x162c54: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x162c5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162c5c
// Address: 0x162c5c - 0x162c74

void entry_162c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162c5c) {
        switch (ctx->pc) {
            case 0x162c64: ctx->pc = 0; goto label_162c64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162c5c: 0x8fa400f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162c60: 0xe480003c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 60), *(uint32_t*)&val); }
label_162c64:
    // 0x162c64: 0x12a0000c
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162C98; return;
    }
    // 0x162c6c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x162c74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162c74
// Address: 0x162c74 - 0x162ca8

void entry_162c74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162c74) {
        switch (ctx->pc) {
            case 0x162c98: ctx->pc = 0; goto label_162c98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162c74: 0x8fa500f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162c78: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x162c7c: 0x0
    // NOP
    // 0x162c80: 0x45000005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 28), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_162c98;
    }
    // 0x162c88: 0x3c015015
    SET_GPR_U32(ctx, 1, ((uint32_t)20501 << 16));
    // 0x162c8c: 0x342102f9
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 761));
    // 0x162c90: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x162c94: 0xe4a0001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 28), *(uint32_t*)&val); }
label_162c98:
    // 0x162c98: 0x12c0000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162CCC; return;
    }
    // 0x162ca0: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x162ca8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162ca8
// Address: 0x162ca8 - 0x162ce8

void entry_162ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162ca8) {
        switch (ctx->pc) {
            case 0x162cc8: ctx->pc = 0; goto label_162cc8;
            case 0x162ccc: ctx->pc = 0; goto label_162ccc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162ca8: 0x8fa600f4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162cac: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x162cb0: 0x0
    // NOP
    // 0x162cb4: 0x45000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 6), 32), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_162cc8;
    }
    // 0x162cbc: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x162cc0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x162cc4: 0xe4c00020
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 6), 32), *(uint32_t*)&val); }
label_162cc8:
    // 0x162cc8: 0x8fa700f4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 244)));
label_162ccc:
    // 0x162ccc: 0xc4e10020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 32)); ctx->f[1] = *(float*)&val; }
    // 0x162cd0: 0xc4e0001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 28)); ctx->f[0] = *(float*)&val; }
    // 0x162cd4: 0x46010029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[1]);
    // 0x162cd8: 0x13c00009
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 32), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162D00; return;
    }
    // 0x162ce0: 0xc06d284
    SET_GPR_U32(ctx, 31, 0x162ce8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    PsaaLoadFromBrx__FP18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162ce8
// Address: 0x162ce8 - 0x162d10

void entry_162ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162ce8) {
        switch (ctx->pc) {
            case 0x162d00: ctx->pc = 0; goto label_162d00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162ce8: 0x8fa800f4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162cec: 0xad020038
    WRITE32(ADD32(GPR_U32(ctx, 8), 56), GPR_U32(ctx, 2));
    // 0x162cf0: 0x8fa900e4
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x162cf4: 0x8d220050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 80)));
    // 0x162cf8: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x162cfc: 0xad220050
    WRITE32(ADD32(GPR_U32(ctx, 9), 80), GPR_U32(ctx, 2));
label_162d00:
    // 0x162d00: 0x1200000f
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162D40; return;
    }
    // 0x162d08: 0xc063540
    SET_GPR_U32(ctx, 31, 0x162d10);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 32));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_162d10
// Address: 0x162d10 - 0x162d24

void entry_162d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162d10: 0x8fa300f4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162d14: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162d18: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x162d1c: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x162d24);
    WRITE32(ADD32(GPR_U32(ctx, 3), 48), GPR_U32(ctx, 2));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_162d24
// Address: 0x162d24 - 0x162d38

void entry_162d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162d24: 0x8fa400f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162d28: 0x8c850030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 48)));
    // 0x162d2c: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162d30: 0xc04dfa4
    SET_GPR_U32(ctx, 31, 0x162d38);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 16));
    ReadVector4__18CBinaryInputStreamP7VECTOR4(rdram, ctx, runtime); return;
}


// Function: entry_162d38
// Address: 0x162d38 - 0x162d58

void entry_162d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162d38) {
        switch (ctx->pc) {
            case 0x162d40: ctx->pc = 0; goto label_162d40;
            case 0x162d48: ctx->pc = 0; goto label_162d48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162d38: 0x10000003
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 316)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_162d48;
    }
label_162d40:
    // 0x162d40: 0xaca00030
    WRITE32(ADD32(GPR_U32(ctx, 5), 48), GPR_U32(ctx, 0));
    // 0x162d44: 0x8fa6013c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 316)));
label_162d48:
    // 0x162d48: 0x50c0002f
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 244)));
        ctx->pc = 0x162E08; return;
    }
    // 0x162d50: 0xc063570
    SET_GPR_U32(ctx, 31, 0x162d58);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 144));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_162d58
// Address: 0x162d58 - 0x162d74

void entry_162d58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162d58: 0x8fa700e8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 232)));
    // 0x162d5c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x162d60: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162d64: 0xae070000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 7));
    // 0x162d68: 0x8fa800f4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162d6c: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x162d74);
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 8));
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162d74
// Address: 0x162d74 - 0x162d80

void entry_162d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162d74: 0xae020008
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 2));
    // 0x162d78: 0xc04df30
    SET_GPR_U32(ctx, 31, 0x162d80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    S8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162d80
// Address: 0x162d80 - 0x162d94

void entry_162d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162d80: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x162d84: 0x10430010
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        entry_162dc8(rdram, ctx, runtime); return;
    }
    // 0x162d8c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x162d94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162d94
// Address: 0x162d94 - 0x162da0

void entry_162d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162d94: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162d98: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x162da0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 36), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162da0
// Address: 0x162da0 - 0x162dac

void entry_162da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162da0: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162da4: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x162dac);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 40), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162dac
// Address: 0x162dac - 0x162db8

void entry_162dac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162dac: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162db0: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x162db8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 44), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162db8
// Address: 0x162db8 - 0x162dc8

void entry_162db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162db8: 0xe6000030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
    // 0x162dbc: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162dc0: 0xc04dfc2
    SET_GPR_U32(ctx, 31, 0x162dc8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 64));
    ReadMatrix4__18CBinaryInputStreamP7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_162dc8
// Address: 0x162dc8 - 0x162dd0

void entry_162dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162dc8: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x162dd0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162dd0
// Address: 0x162dd0 - 0x162ddc

void entry_162dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162dd0: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162dd4: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x162ddc);
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162ddc
// Address: 0x162ddc - 0x162de8

void entry_162ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162ddc: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x162de0: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x162de8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162de8
// Address: 0x162de8 - 0x162e18

void entry_162de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162de8) {
        switch (ctx->pc) {
            case 0x162e08: ctx->pc = 0; goto label_162e08;
            case 0x162e0c: ctx->pc = 0; goto label_162e0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162de8: 0xae020018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 2));
    // 0x162dec: 0x8fa900f4
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162df0: 0xad300054
    WRITE32(ADD32(GPR_U32(ctx, 9), 84), GPR_U32(ctx, 16));
    // 0x162df4: 0x8fa300e4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x162df8: 0x8c62004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 76)));
    // 0x162dfc: 0xae020080
    WRITE32(ADD32(GPR_U32(ctx, 16), 128), GPR_U32(ctx, 2));
    // 0x162e00: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 3), 76), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_162e0c;
    }
label_162e08:
    // 0x162e08: 0xac800054
    WRITE32(ADD32(GPR_U32(ctx, 4), 84), GPR_U32(ctx, 0));
label_162e0c:
    // 0x162e0c: 0x8fa500f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162e10: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x162e18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_162e18
// Address: 0x162e18 - 0x162e20

void entry_162e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162e18: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x162e20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162e20
// Address: 0x162e20 - 0x162e30

void entry_162e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162e20: 0x8fa500f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162e24: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162e28: 0xc04df44
    SET_GPR_U32(ctx, 31, 0x162e30);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 16), *(uint32_t*)&val); }
    S16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162e30
// Address: 0x162e30 - 0x162e38

void entry_162e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162e30: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x162e38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162e38
// Address: 0x162e38 - 0x162e48

void entry_162e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162e38: 0x8fa600f4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162e3c: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162e40: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x162e48);
    WRITE32(ADD32(GPR_U32(ctx, 6), 52), GPR_U32(ctx, 2));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162e48
// Address: 0x162e48 - 0x162e58

void entry_162e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162e48: 0x8fa700f4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162e4c: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162e50: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x162e58);
    WRITE32(ADD32(GPR_U32(ctx, 7), 20), GPR_U32(ctx, 2));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162e58
// Address: 0x162e58 - 0x162e74

void entry_162e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162e58: 0x8fa900f4
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162e5c: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x162e60: 0x8d041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 8), 6544)));
    // 0x162e64: 0x8fa50160
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x162e68: 0xc52c003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 9), 60)); ctx->f[12] = *(float*)&val; }
    // 0x162e6c: 0xc050d32
    SET_GPR_U32(ctx, 31, 0x162e74);
    WRITE32(ADD32(GPR_U32(ctx, 9), 44), GPR_U32(ctx, 2));
    BuildCmFgfn__FP2CMfP4FGFN(rdram, ctx, runtime); return;
}


// Function: entry_162e74
// Address: 0x162e74 - 0x162e8c

void entry_162e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162e74: 0x8fa20158
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 344)));
    // 0x162e78: 0x10400006
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x162E94; return;
    }
    // 0x162e80: 0x8fa600f8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 248)));
    // 0x162e84: 0xc0596ba
    SET_GPR_U32(ctx, 31, 0x162e8c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    CloneGlob__FP7GLOBSETP4GLOBP5GLOBI(rdram, ctx, runtime); return;
}


// Function: entry_162e8c
// Address: 0x162e8c - 0x162ea0

void entry_162e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162e8c) {
        switch (ctx->pc) {
            case 0x162e94: ctx->pc = 0; goto label_162e94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162e8c: 0x10000296
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1638E8; return;
    }
label_162e94:
    // 0x162e94: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162e98: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x162ea0);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162ea0
// Address: 0x162ea0 - 0x162eb8

void entry_162ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162ea0: 0x24040050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 80));
    // 0x162ea4: 0x8fa300f4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162ea8: 0x442018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162eac: 0xafa000fc
    WRITE32(ADD32(GPR_U32(ctx, 29), 252), GPR_U32(ctx, 0));
    // 0x162eb0: 0xc063570
    SET_GPR_U32(ctx, 31, 0x162eb8);
    WRITE32(ADD32(GPR_U32(ctx, 3), 88), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_162eb8
// Address: 0x162eb8 - 0x162ed4

void entry_162eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162eb8: 0x8fa400f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162ebc: 0x8fa500f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162ec0: 0x8c830058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 88)));
    // 0x162ec4: 0x24040030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 48));
    // 0x162ec8: 0xaca2005c
    WRITE32(ADD32(GPR_U32(ctx, 5), 92), GPR_U32(ctx, 2));
    // 0x162ecc: 0xc063570
    SET_GPR_U32(ctx, 31, 0x162ed4);
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_162ed4
// Address: 0x162ed4 - 0x162f40

void entry_162ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x162ed4) {
        switch (ctx->pc) {
            case 0x162f08: ctx->pc = 0; goto label_162f08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x162ed4: 0x8fa600f8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 248)));
    // 0x162ed8: 0xacc20004
    WRITE32(ADD32(GPR_U32(ctx, 6), 4), GPR_U32(ctx, 2));
    // 0x162edc: 0x8fa700f4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162ee0: 0x8ce20058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 88)));
    // 0x162ee4: 0x184001d8
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 80));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x163648; return;
    }
    // 0x162eec: 0x27a9005c
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 92));
    // 0x162ef0: 0x27a20054
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 84));
    // 0x162ef4: 0xafa80140
    WRITE32(ADD32(GPR_U32(ctx, 29), 320), GPR_U32(ctx, 8));
    // 0x162ef8: 0xafa90148
    WRITE32(ADD32(GPR_U32(ctx, 29), 328), GPR_U32(ctx, 9));
    // 0x162efc: 0xafa20144
    WRITE32(ADD32(GPR_U32(ctx, 29), 324), GPR_U32(ctx, 2));
    // 0x162f00: 0x8fa400f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x162f04: 0x0
    // NOP
label_162f08:
    // 0x162f08: 0x24020050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
    // 0x162f0c: 0x24030030
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 48));
    // 0x162f10: 0x2021018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162f14: 0x2031818
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162f18: 0x8c8a005c
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 4), 92)));
    // 0x162f1c: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x162f20: 0x8fa500f8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 248)));
    // 0x162f24: 0xafb00150
    WRITE32(ADD32(GPR_U32(ctx, 29), 336), GPR_U32(ctx, 16));
    // 0x162f28: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x162f2c: 0x142f021
    SET_GPR_U32(ctx, 30, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 2)));
    // 0x162f30: 0x8ca40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x162f34: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x162f38: 0xc063582
    SET_GPR_U32(ctx, 31, 0x162f40);
    WRITE32(ADD32(GPR_U32(ctx, 29), 256), GPR_U32(ctx, 4));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_162f40
// Address: 0x162f40 - 0x162f4c

void entry_162f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162f40: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x162f44: 0xc04df9c
    SET_GPR_U32(ctx, 31, 0x162f4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    ReadVector__18CBinaryInputStreamP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_162f4c
// Address: 0x162f4c - 0x162f54

void entry_162f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162f4c: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x162f54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162f54
// Address: 0x162f54 - 0x162f60

void entry_162f54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162f54: 0xe7c00010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 30), 16), *(uint32_t*)&val); }
    // 0x162f58: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x162f60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162f60
// Address: 0x162f60 - 0x162f6c

void entry_162f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162f60: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x162f64: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x162f6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162f6c
// Address: 0x162f6c - 0x162f78

void entry_162f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162f6c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x162f70: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x162f78);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162f78
// Address: 0x162f78 - 0x162f84

void entry_162f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162f78: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x162f7c: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x162f84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162f84
// Address: 0x162f84 - 0x162f94

void entry_162f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162f84: 0x129080
    SET_GPR_U32(ctx, 18, SLL32(GPR_U32(ctx, 18), 2));
    // 0x162f88: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x162f8c: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x162f94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_162f94
// Address: 0x162f94 - 0x162fac

void entry_162f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162f94: 0x1398c0
    SET_GPR_U32(ctx, 19, SLL32(GPR_U32(ctx, 19), 3));
    // 0x162f98: 0xafa20114
    WRITE32(ADD32(GPR_U32(ctx, 29), 276), GPR_U32(ctx, 2));
    // 0x162f9c: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x162fa0: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162fa4: 0xc04ded8
    SET_GPR_U32(ctx, 31, 0x162fac);
    SET_GPR_U32(ctx, 20, SLL32(GPR_U32(ctx, 2), 2));
    Align__18CBinaryInputStreami(rdram, ctx, runtime); return;
}


// Function: entry_162fac
// Address: 0x162fac - 0x162fbc

void entry_162fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162fac: 0x2406000c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    // 0x162fb0: 0x2c68018
    { int64_t result = (int64_t)GPR_S32(ctx, 22) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162fb4: 0xc063596
    SET_GPR_U32(ctx, 31, 0x162fbc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_162fbc
// Address: 0x162fbc - 0x162fd0

void entry_162fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162fbc: 0xafa20104
    WRITE32(ADD32(GPR_U32(ctx, 29), 260), GPR_U32(ctx, 2));
    // 0x162fc0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x162fc4: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162fc8: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x162fd0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_162fd0
// Address: 0x162fd0 - 0x162fe0

void entry_162fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162fd0: 0x2407000c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 12));
    // 0x162fd4: 0x2278818
    { int64_t result = (int64_t)GPR_S32(ctx, 17) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x162fd8: 0xc063596
    SET_GPR_U32(ctx, 31, 0x162fe0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_162fe0
// Address: 0x162fe0 - 0x162ff4

void entry_162fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162fe0: 0xafa20108
    WRITE32(ADD32(GPR_U32(ctx, 29), 264), GPR_U32(ctx, 2));
    // 0x162fe4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x162fe8: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x162fec: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x162ff4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_162ff4
// Address: 0x162ff4 - 0x162ffc

void entry_162ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162ff4: 0xc063596
    SET_GPR_U32(ctx, 31, 0x162ffc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_162ffc
// Address: 0x162ffc - 0x163010

void entry_162ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x162ffc: 0xafa2010c
    WRITE32(ADD32(GPR_U32(ctx, 29), 268), GPR_U32(ctx, 2));
    // 0x163000: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x163004: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x163008: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x163010);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_163010
// Address: 0x163010 - 0x163018

void entry_163010(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163010: 0xc063596
    SET_GPR_U32(ctx, 31, 0x163018);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_163018
// Address: 0x163018 - 0x16302c

void entry_163018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163018: 0xafa20110
    WRITE32(ADD32(GPR_U32(ctx, 29), 272), GPR_U32(ctx, 2));
    // 0x16301c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x163020: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x163024: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x16302c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_16302c
// Address: 0x16302c - 0x163034

void entry_16302c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16302c: 0xc063596
    SET_GPR_U32(ctx, 31, 0x163034);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_163034
// Address: 0x163034 - 0x163048

void entry_163034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163034: 0xafa20118
    WRITE32(ADD32(GPR_U32(ctx, 29), 280), GPR_U32(ctx, 2));
    // 0x163038: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x16303c: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x163040: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x163048);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_163048
// Address: 0x163048 - 0x163050

void entry_163048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163048: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x163050);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_163050
// Address: 0x163050 - 0x163070

void entry_163050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163050: 0x24030028
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 40));
    // 0x163054: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x163058: 0x431018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x16305c: 0x8c8544fc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 17660)));
    // 0x163060: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x163064: 0xa29821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x163068: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x163070);
    WRITE32(ADD32(GPR_U32(ctx, 30), 24), GPR_U32(ctx, 19));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_163070
// Address: 0x163070 - 0x16307c

void entry_163070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163070: 0xafc20014
    WRITE32(ADD32(GPR_U32(ctx, 30), 20), GPR_U32(ctx, 2));
    // 0x163074: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x16307c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_16307c
// Address: 0x16307c - 0x163094

void entry_16307c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16307c) {
        switch (ctx->pc) {
            case 0x163088: ctx->pc = 0; goto label_163088;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16307c: 0x1840000a
    WRITE32(ADD32(GPR_U32(ctx, 30), 36), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1630A8; return;
    }
    // 0x163084: 0x27d00028
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 30), 40));
label_163088:
    // 0x163088: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x16308c: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x163094);
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 1));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_163094
// Address: 0x163094 - 0x1630bc

void entry_163094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163094) {
        switch (ctx->pc) {
            case 0x1630a8: ctx->pc = 0; goto label_1630a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163094: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x163098: 0x8fc20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 36)));
    // 0x16309c: 0x2a2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 2)));
    // 0x1630a0: 0x1440fff9
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x163088; return;
    }
label_1630a8:
    // 0x1630a8: 0x8fd00024
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 30), 36)));
    // 0x1630ac: 0x2168018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 22); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1630b0: 0x108080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 2));
    // 0x1630b4: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1630bc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1630bc
// Address: 0x1630bc - 0x1630d0

void entry_1630bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1630bc: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1630c0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1630c4: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1630c8: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x1630d0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_1630d0
// Address: 0x1630d0 - 0x1630e8

void entry_1630d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1630d0: 0x8fa800e4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x1630d4: 0x8d020040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 64)));
    // 0x1630d8: 0x10400037
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1631B8; return;
    }
    // 0x1630e0: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x1630e8);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1630e8
// Address: 0x1630e8 - 0x1630f8

void entry_1630e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1630e8: 0x2409000c
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1630ec: 0x498018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 9); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1630f0: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1630f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1630f8
// Address: 0x1630f8 - 0x16310c

void entry_1630f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1630f8: 0xafa20120
    WRITE32(ADD32(GPR_U32(ctx, 29), 288), GPR_U32(ctx, 2));
    // 0x1630fc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x163100: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x163104: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x16310c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_16310c
// Address: 0x16310c - 0x163114

void entry_16310c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16310c: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x163114);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_163114
// Address: 0x163114 - 0x163124

void entry_163114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163114: 0x2403000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 12));
    // 0x163118: 0x438018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x16311c: 0xc063596
    SET_GPR_U32(ctx, 31, 0x163124);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_163124
// Address: 0x163124 - 0x163138

void entry_163124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163124: 0xafa20124
    WRITE32(ADD32(GPR_U32(ctx, 29), 292), GPR_U32(ctx, 2));
    // 0x163128: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16312c: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x163130: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x163138);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_163138
// Address: 0x163138 - 0x163148

void entry_163138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163138: 0x8fa500e4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x16313c: 0x8ca40040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 64)));
    // 0x163140: 0xc063596
    SET_GPR_U32(ctx, 31, 0x163148);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 3));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_163148
// Address: 0x163148 - 0x163174

void entry_163148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163148) {
        switch (ctx->pc) {
            case 0x163168: ctx->pc = 0; goto label_163168;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163148: 0x8fa600e4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x16314c: 0xafa2011c
    WRITE32(ADD32(GPR_U32(ctx, 29), 284), GPR_U32(ctx, 2));
    // 0x163150: 0x8cc20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 64)));
    // 0x163154: 0x18400018
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 276)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1631B8; return;
    }
    // 0x16315c: 0x8fb0011c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 284)));
    // 0x163160: 0x78840
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 7), 1));
    // 0x163164: 0x0
    // NOP
label_163168:
    // 0x163168: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16316c: 0xc063596
    SET_GPR_U32(ctx, 31, 0x163174);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_163174
// Address: 0x163174 - 0x163188

void entry_163174(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163174: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163178: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16317c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x163180: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x163188);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_163188
// Address: 0x163188 - 0x163190

void entry_163188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163188: 0xc063596
    SET_GPR_U32(ctx, 31, 0x163190);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_163190
// Address: 0x163190 - 0x1631a4

void entry_163190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163190: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x163194: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x163198: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x16319c: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x1631a4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_1631a4
// Address: 0x1631a4 - 0x1631d4

void entry_1631a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1631a4) {
        switch (ctx->pc) {
            case 0x1631b8: ctx->pc = 0; goto label_1631b8;
            case 0x1631c8: ctx->pc = 0; goto label_1631c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1631a4: 0x8fa800e4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x1631a8: 0x8d020040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 64)));
    // 0x1631ac: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1631b0: 0x1440ffed
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x163168; return;
    }
label_1631b8:
    // 0x1631b8: 0x8fb00140
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1631bc: 0x24110002
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1631c0: 0x2412ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1631c4: 0x0
    // NOP
label_1631c8:
    // 0x1631c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1631cc: 0xc07b8c6
    SET_GPR_U32(ctx, 31, 0x1631d4);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    fn___4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_1631d4
// Address: 0x1631d4 - 0x163200

void entry_1631d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1631d4) {
        switch (ctx->pc) {
            case 0x1631f8: ctx->pc = 0; goto label_1631f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1631d4: 0x1632fffc
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 36));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x1631C8; return;
    }
    // 0x1631dc: 0x3c090026
    SET_GPR_U32(ctx, 9, ((uint32_t)38 << 16));
    // 0x1631e0: 0x8fb00140
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1631e4: 0x8d2926d0
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 9), 9936)));
    // 0x1631e8: 0x2611006c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 108));
    // 0x1631ec: 0xafa90128
    WRITE32(ADD32(GPR_U32(ctx, 29), 296), GPR_U32(ctx, 9));
    // 0x1631f0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1631f4: 0x0
    // NOP
label_1631f8:
    // 0x1631f8: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x163200);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1024));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_163200
// Address: 0x163200 - 0x163220

void entry_163200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163200: 0x26100024
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 36));
    // 0x163204: 0x211102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 17)));
    // 0x163208: 0x1440fffb
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1631F8; return;
    }
    // 0x163210: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x163214: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163218: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x163220);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_163220
// Address: 0x163220 - 0x163250

void entry_163220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163220: 0x8fa200f4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x163224: 0x8c440038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 56)));
    // 0x163228: 0x5080000a
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x163254; return;
    }
    // 0x163230: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x163234: 0x8c420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x163238: 0x10400005
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_163250(rdram, ctx, runtime); return;
    }
    // 0x163240: 0x27a500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 192));
    // 0x163244: 0x8fa700f4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x163248: 0x40f809
    SET_GPR_U32(ctx, 31, 0x163250);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_163250
// Address: 0x163250 - 0x1632fc

void entry_163250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163250) {
        switch (ctx->pc) {
            case 0x163254: ctx->pc = 0; goto label_163254;
            case 0x163278: ctx->pc = 0; goto label_163278;
            case 0x163288: ctx->pc = 0; goto label_163288;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163250: 0x92630000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 19), 0)));
label_163254:
    // 0x163254: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x163258: 0x1062000b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_163288;
    }
    // 0x163260: 0x10400005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 11));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_163278;
    }
    // 0x163268: 0x10600026
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x163304; return;
    }
    // 0x163270: 0x10000046
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 36));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16338C; return;
    }
label_163278:
    // 0x163278: 0x10400041
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_163380(rdram, ctx, runtime); return;
    }
    // 0x163280: 0x14400041
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x163388; return;
    }
label_163288:
    // 0x163288: 0x8fa600fc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 252)));
    // 0x16328c: 0x27a200c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 192));
    // 0x163290: 0x8fa50118
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 280)));
    // 0x163294: 0x260402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x163298: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x16329c: 0x8fa30110
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1632a0: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x1632a4: 0xafa50010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 5));
    // 0x1632a8: 0x8fa40114
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 276)));
    // 0x1632ac: 0x8fa50124
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 292)));
    // 0x1632b0: 0xafa700fc
    WRITE32(ADD32(GPR_U32(ctx, 29), 252), GPR_U32(ctx, 7));
    // 0x1632b4: 0x8fa70140
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1632b8: 0xafa30000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 3));
    // 0x1632bc: 0xafa20040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 2));
    // 0x1632c0: 0xafa40008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 4));
    // 0x1632c4: 0x8fa2011c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 284)));
    // 0x1632c8: 0x8fa30120
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1632cc: 0xafa50028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 5));
    // 0x1632d0: 0xafa70038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 7));
    // 0x1632d4: 0x8fa90104
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x1632d8: 0x3c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1632dc: 0x8faa0108
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 264)));
    // 0x1632e0: 0x8fab010c
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 268)));
    // 0x1632e4: 0x8fa400e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x1632e8: 0x8fa500f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x1632ec: 0xafb40030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 20));
    // 0x1632f0: 0xafa20018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 2));
    // 0x1632f4: 0xc058fb6
    SET_GPR_U32(ctx, 31, 0x1632fc);
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 3));
    BuildSubglobSinglePass__FP7GLOBSETP4GLOBiP7SUBGLOBP3SHDP7VECTORFT5P4RGBAP3UVFiP4VTXFP8SUBPOSEFT5T5PfP4VIFSP4SGVR(rdram, ctx, runtime); return;
}


// Function: entry_1632fc
// Address: 0x1632fc - 0x163380

void entry_1632fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1632fc) {
        switch (ctx->pc) {
            case 0x163304: ctx->pc = 0; goto label_163304;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1632fc: 0x10000022
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x163388; return;
    }
label_163304:
    // 0x163304: 0x8fa700fc
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 252)));
    // 0x163308: 0x27a200c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 192));
    // 0x16330c: 0x8fa8010c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 268)));
    // 0x163310: 0x8fa30114
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 276)));
    // 0x163314: 0xe0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x163318: 0x8fa40118
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 280)));
    // 0x16331c: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x163320: 0x8fa6011c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 284)));
    // 0x163324: 0xafa80000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 8));
    // 0x163328: 0x8fa90110
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x16332c: 0x8fa80120
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x163330: 0xafa30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 3));
    // 0x163334: 0xafa20048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 2));
    // 0x163338: 0xafa40018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 4));
    // 0x16333c: 0xafa500fc
    WRITE32(ADD32(GPR_U32(ctx, 29), 252), GPR_U32(ctx, 5));
    // 0x163340: 0xafa60020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 6));
    // 0x163344: 0x8fa20124
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 292)));
    // 0x163348: 0x8fa30140
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x16334c: 0xafa90008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 9));
    // 0x163350: 0xafa80028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 8));
    // 0x163354: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x163358: 0x8faa0104
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x16335c: 0x3c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x163360: 0x8fab0108
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 264)));
    // 0x163364: 0x8fa400e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x163368: 0x8fa500f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x16336c: 0x8fa600f0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x163370: 0xafb40038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 20));
    // 0x163374: 0xafa20030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 2));
    // 0x163378: 0xc05921a
    SET_GPR_U32(ctx, 31, 0x163380);
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 3));
    BuildSubglobThreeWay__FP7GLOBSETP4GLOBiP7SUBGLOBP3SHDP7VECTORFT5P4RGBAP3UVFiP4VTXFP8SUBPOSEFT5T5PfP4VIFSP4SGVR(rdram, ctx, runtime); return;
}


// Function: entry_163380
// Address: 0x163380 - 0x1633e8

void entry_163380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163380) {
        switch (ctx->pc) {
            case 0x163388: ctx->pc = 0; goto label_163388;
            case 0x16338c: ctx->pc = 0; goto label_16338c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163380: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163384: 0x0
    // NOP
label_163388:
    // 0x163388: 0x24020024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 36));
label_16338c:
    // 0x16338c: 0x8fa40148
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 328)));
    // 0x163390: 0x1223018
    { int64_t result = (int64_t)GPR_S32(ctx, 9) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x163394: 0x8fa50144
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 324)));
    // 0x163398: 0x861821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x16339c: 0xa62021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x1633a0: 0x8c650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1633a4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1633a8: 0x10a20091
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 9), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1635F0; return;
    }
    // 0x1633b0: 0x8fa80140
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1633b4: 0x98080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 9), 2));
    // 0x1633b8: 0x27b600d0
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 208));
    // 0x1633bc: 0x26050038
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 56));
    // 0x1633c0: 0x1062021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 6)));
    // 0x1633c4: 0x2d09021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 16)));
    // 0x1633c8: 0x26070044
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 68));
    // 0x1633cc: 0x3c52821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 5)));
    // 0x1633d0: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1633d4: 0x7fa90170
    WRITE128(ADD32(GPR_U32(ctx, 29), 368), GPR_VEC(ctx, 9));
    // 0x1633d8: 0x3c73821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 7)));
    // 0x1633dc: 0x24080013
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 19));
    // 0x1633e0: 0xc054a94
    SET_GPR_U32(ctx, 31, 0x1633e8);
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 30), 56));
    DetachCopySw__4DMASPiPP2QWT2i(rdram, ctx, runtime); return;
}


// Function: entry_1633e8
// Address: 0x1633e8 - 0x16340c

void entry_1633e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1633e8: 0x290a821
    SET_GPR_U32(ctx, 21, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 16)));
    // 0x1633ec: 0x27d30044
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 30), 68));
    // 0x1633f0: 0x8ea50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x1633f4: 0x2708821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 16)));
    // 0x1633f8: 0x8e460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1633fc: 0x8fa40128
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    // 0x163400: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x163404: 0xc05a5ae
    SET_GPR_U32(ctx, 31, 0x16340c);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    RebaseSurs__FiiPvT2(rdram, ctx, runtime); return;
}


// Function: entry_16340c
// Address: 0x16340c - 0x16362c

void entry_16340c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16340c) {
        switch (ctx->pc) {
            case 0x163450: ctx->pc = 0; goto label_163450;
            case 0x163454: ctx->pc = 0; goto label_163454;
            case 0x16349c: ctx->pc = 0; goto label_16349c;
            case 0x1634a0: ctx->pc = 0; goto label_1634a0;
            case 0x1634e8: ctx->pc = 0; goto label_1634e8;
            case 0x163518: ctx->pc = 0; goto label_163518;
            case 0x163554: ctx->pc = 0; goto label_163554;
            case 0x16355c: ctx->pc = 0; goto label_16355c;
            case 0x163560: ctx->pc = 0; goto label_163560;
            case 0x163590: ctx->pc = 0; goto label_163590;
            case 0x163594: ctx->pc = 0; goto label_163594;
            case 0x1635cc: ctx->pc = 0; goto label_1635cc;
            case 0x1635d0: ctx->pc = 0; goto label_1635d0;
            case 0x1635f0: ctx->pc = 0; goto label_1635f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16340c: 0x8ea20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x163410: 0x8fa400c4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 196)));
    // 0x163414: 0x8e520000
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x163418: 0x22900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 2), 4));
    // 0x16341c: 0x8e310000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x163420: 0x1080000b
    SET_GPR_VEC(ctx, 9, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_163450;
    }
    // 0x163428: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x16342c: 0x72102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x163430: 0x14400008
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_163454;
    }
    // 0x163438: 0x2451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 5)));
    // 0x16343c: 0x62102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x163440: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 17), GPR_U32(ctx, 18)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_163450;
    }
    // 0x163448: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x16344c: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
label_163450:
    // 0x163450: 0x2901021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 16)));
label_163454:
    // 0x163454: 0x2d01821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 16)));
    // 0x163458: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16345c: 0x2702821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 16)));
    // 0x163460: 0x8fa700c8
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 200)));
    // 0x163464: 0x8c630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x163468: 0x42100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    // 0x16346c: 0x10e0000b
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_16349c;
    }
    // 0x163474: 0x8ce60000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x163478: 0xc3102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x16347c: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 30), 32)));
        goto label_1634a0;
    }
    // 0x163484: 0x641021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x163488: 0xc2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x16348c: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16349c;
    }
    // 0x163494: 0xc21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x163498: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
label_16349c:
    // 0x16349c: 0x8fc80020
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 30), 32)));
label_1634a0:
    // 0x1634a0: 0x11000053
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 9), 1));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        goto label_1635f0;
    }
    // 0x1634a8: 0x2d01021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 16)));
    // 0x1634ac: 0x2901821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 16)));
    // 0x1634b0: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1634b4: 0x2702021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 16)));
    // 0x1634b8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1634bc: 0x8d030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x1634c0: 0x23100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 2), 4));
    // 0x1634c4: 0x65102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1634c8: 0x14400007
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1634e8;
    }
    // 0x1634d0: 0xa61021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x1634d4: 0x62102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1634d8: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1634e8;
    }
    // 0x1634e0: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1634e4: 0xad020000
    WRITE32(ADD32(GPR_U32(ctx, 8), 0), GPR_U32(ctx, 2));
label_1634e8:
    // 0x1634e8: 0x8fa200f4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x1634ec: 0x252c0001
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 9), 1));
    // 0x1634f0: 0x8c430054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 84)));
    // 0x1634f4: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1634f8: 0x1840003d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1635f0;
    }
    // 0x163500: 0x2702021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 16)));
    // 0x163504: 0x290a021
    SET_GPR_U32(ctx, 20, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 16)));
    // 0x163508: 0x2d08021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 16)));
    // 0x16350c: 0x250b0004
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 8), 4));
    // 0x163510: 0x25070024
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 8), 36));
    // 0x163514: 0x250a0014
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 8), 20));
label_163518:
    // 0x163518: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x16351c: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163520: 0x24100
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 2), 4));
    // 0x163524: 0x1160000e
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    if (GPR_U32(ctx, 11) == GPR_U32(ctx, 0)) {
        goto label_163560;
    }
    // 0x16352c: 0x8ce3ffe0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 4294967264)));
    // 0x163530: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x163534: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
        goto label_16355c;
    }
    // 0x16353c: 0xc81021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    // 0x163540: 0x62102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x163544: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 9), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_163554;
    }
    // 0x16354c: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x163550: 0xace2ffe0
    WRITE32(ADD32(GPR_U32(ctx, 7), 4294967264), GPR_U32(ctx, 2));
label_163554:
    // 0x163554: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x163558: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_16355c:
    // 0x16355c: 0x24100
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 2), 4));
label_163560:
    // 0x163560: 0x1140000b
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    if (GPR_U32(ctx, 10) == GPR_U32(ctx, 0)) {
        goto label_163590;
    }
    // 0x163568: 0x8ce3fff0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 4294967280)));
    // 0x16356c: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x163570: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
        goto label_163594;
    }
    // 0x163578: 0xc81021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    // 0x16357c: 0x62102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x163580: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 9), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_163590;
    }
    // 0x163588: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x16358c: 0xace2fff0
    WRITE32(ADD32(GPR_U32(ctx, 7), 4294967280), GPR_U32(ctx, 2));
label_163590:
    // 0x163590: 0x8e820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 0)));
label_163594:
    // 0x163594: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163598: 0x24100
    SET_GPR_U32(ctx, 8, SLL32(GPR_U32(ctx, 2), 4));
    // 0x16359c: 0x10e0000b
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        goto label_1635cc;
    }
    // 0x1635a4: 0x8ce30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1635a8: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x1635ac: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 244)));
        goto label_1635d0;
    }
    // 0x1635b4: 0xc81021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    // 0x1635b8: 0x62102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1635bc: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 9), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1635cc;
    }
    // 0x1635c4: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1635c8: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
label_1635cc:
    // 0x1635cc: 0x8fa600f4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 244)));
label_1635d0:
    // 0x1635d0: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1635d4: 0x24e70004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    // 0x1635d8: 0x254a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4));
    // 0x1635dc: 0x8cc30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 84)));
    // 0x1635e0: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1635e4: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x1635e8: 0x1440ffcb
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_163518;
    }
label_1635f0:
    // 0x1635f0: 0x180482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 12) + GPR_U64(ctx, 0));
    // 0x1635f4: 0x29220003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 9), 3));
    // 0x1635f8: 0x1440ff64
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 36));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16338C; return;
    }
    // 0x163600: 0x8fa700d0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x163604: 0x3c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x163608: 0x8fc30044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 68)));
    // 0x16360c: 0x8fc2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 28)));
    // 0x163610: 0x671823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x163614: 0x8fb00150
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x163618: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16361c: 0x8fa60100
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x163620: 0x8fa400f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x163624: 0xc059562
    SET_GPR_U32(ctx, 31, 0x16362c);
    WRITE32(ADD32(GPR_U32(ctx, 30), 28), GPR_U32(ctx, 2));
    BuildSubglobLighting__FP4GLOBP7SUBGLOBP8SUBGLOBI(rdram, ctx, runtime); return;
}


// Function: entry_16362c
// Address: 0x16362c - 0x163634

void entry_16362c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16362c: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x163634);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_163634
// Address: 0x163634 - 0x163654

void entry_163634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163634) {
        switch (ctx->pc) {
            case 0x163648: ctx->pc = 0; goto label_163648;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163634: 0x8fa700f4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x163638: 0x8ce20058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 88)));
    // 0x16363c: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x163640: 0x1440fe31
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x162F08; return;
    }
label_163648:
    // 0x163648: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x16364c: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x163654);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_163654
// Address: 0x163654 - 0x163664

void entry_163654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163654: 0x8fa800f4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x163658: 0x22140
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 5));
    // 0x16365c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x163664);
    WRITE32(ADD32(GPR_U32(ctx, 8), 96), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_163664
// Address: 0x163664 - 0x1636ac

void entry_163664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163664) {
        switch (ctx->pc) {
            case 0x163688: ctx->pc = 0; goto label_163688;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163664: 0x8fa900f4
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x163668: 0x8d230060
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 96)));
    // 0x16366c: 0x1860009d
    WRITE32(ADD32(GPR_U32(ctx, 9), 100), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1638E4; return;
    }
    // 0x163674: 0x27a20050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 80));
    // 0x163678: 0x27a300e0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 224));
    // 0x16367c: 0xafa20140
    WRITE32(ADD32(GPR_U32(ctx, 29), 320), GPR_U32(ctx, 2));
    // 0x163680: 0xafa3015c
    WRITE32(ADD32(GPR_U32(ctx, 29), 348), GPR_U32(ctx, 3));
    // 0x163684: 0x8fa400f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 244)));
label_163688:
    // 0x163688: 0x111140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 5));
    // 0x16368c: 0x8fa500fc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 252)));
    // 0x163690: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x163694: 0x8c830064
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 100)));
    // 0x163698: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x16369c: 0xafb10164
    WRITE32(ADD32(GPR_U32(ctx, 29), 356), GPR_U32(ctx, 17));
    // 0x1636a0: 0x629021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1636a4: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1636ac);
    WRITE32(ADD32(GPR_U32(ctx, 29), 340), GPR_U32(ctx, 5));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1636ac
// Address: 0x1636ac - 0x1636b8

void entry_1636ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1636ac: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1636b0: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x1636b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1636b8
// Address: 0x1636b8 - 0x1636cc

void entry_1636b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1636b8: 0x2406000c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1636bc: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1636c0: 0x2a68018
    { int64_t result = (int64_t)GPR_S32(ctx, 21) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1636c4: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1636cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1636cc
// Address: 0x1636cc - 0x1636e0

void entry_1636cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1636cc: 0xafa2012c
    WRITE32(ADD32(GPR_U32(ctx, 29), 300), GPR_U32(ctx, 2));
    // 0x1636d0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1636d4: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1636d8: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x1636e0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_1636e0
// Address: 0x1636e0 - 0x1636e8

void entry_1636e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1636e0: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x1636e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_1636e8
// Address: 0x1636e8 - 0x1636f8

void entry_1636e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1636e8: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1636ec: 0x1e8080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 30), 2));
    // 0x1636f0: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1636f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1636f8
// Address: 0x1636f8 - 0x16370c

void entry_1636f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1636f8: 0x40b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1636fc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x163700: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x163704: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x16370c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_16370c
// Address: 0x16370c - 0x163714

void entry_16370c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16370c: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x163714);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_163714
// Address: 0x163714 - 0x16372c

void entry_163714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163714) {
        switch (ctx->pc) {
            case 0x163720: ctx->pc = 0; goto label_163720;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163714: 0x1840000a
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x163740; return;
    }
    // 0x16371c: 0x26500008
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 8));
label_163720:
    // 0x163720: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x163724: 0xc04dee4
    SET_GPR_U32(ctx, 31, 0x16372c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    U8Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_16372c
// Address: 0x16372c - 0x163764

void entry_16372c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16372c) {
        switch (ctx->pc) {
            case 0x163740: ctx->pc = 0; goto label_163740;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16372c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x163730: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x163734: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x163738: 0x1440fff9
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x163720; return;
    }
label_163740:
    // 0x163740: 0x8e500004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x163744: 0x26470018
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 24));
    // 0x163748: 0x2648001c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 18), 28));
    // 0x16374c: 0xafa70168
    WRITE32(ADD32(GPR_U32(ctx, 29), 360), GPR_U32(ctx, 7));
    // 0x163750: 0x2158018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 21); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x163754: 0xafa80138
    WRITE32(ADD32(GPR_U32(ctx, 29), 312), GPR_U32(ctx, 8));
    // 0x163758: 0x108080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 16), 2));
    // 0x16375c: 0xc063596
    SET_GPR_U32(ctx, 31, 0x163764);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_163764
// Address: 0x163764 - 0x163778

void entry_163764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163764: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x163768: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16376c: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x163770: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x163778);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_163778
// Address: 0x163778 - 0x163790

void entry_163778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163778: 0x8fa900e4
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x16377c: 0x8d220040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 64)));
    // 0x163780: 0x10400025
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x163818; return;
    }
    // 0x163788: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x163790);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_163790
// Address: 0x163790 - 0x1637a0

void entry_163790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163790: 0x2403000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 12));
    // 0x163794: 0x438018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x163798: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1637a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1637a0
// Address: 0x1637a0 - 0x1637b4

void entry_1637a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1637a0: 0xafa20134
    WRITE32(ADD32(GPR_U32(ctx, 29), 308), GPR_U32(ctx, 2));
    // 0x1637a4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1637a8: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1637ac: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x1637b4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_1637b4
// Address: 0x1637b4 - 0x1637c4

void entry_1637b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1637b4: 0x8fa500e4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x1637b8: 0x8ca40040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 64)));
    // 0x1637bc: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1637c4);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 3));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1637c4
// Address: 0x1637c4 - 0x1637ec

void entry_1637c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1637c4) {
        switch (ctx->pc) {
            case 0x1637e0: ctx->pc = 0; goto label_1637e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1637c4: 0x8fa600e4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x1637c8: 0xafa20130
    WRITE32(ADD32(GPR_U32(ctx, 29), 304), GPR_U32(ctx, 2));
    // 0x1637cc: 0x8cc20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 64)));
    // 0x1637d0: 0x18400011
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x163818; return;
    }
    // 0x1637d8: 0x158840
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 21), 1));
    // 0x1637dc: 0x0
    // NOP
label_1637e0:
    // 0x1637e0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1637e4: 0xc063596
    SET_GPR_U32(ctx, 31, 0x1637ec);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1637ec
// Address: 0x1637ec - 0x163800

void entry_1637ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1637ec: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x1637f0: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1637f4: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1637f8: 0xc04de98
    SET_GPR_U32(ctx, 31, 0x163800);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    Read__18CBinaryInputStreamiPv(rdram, ctx, runtime); return;
}


// Function: entry_163800
// Address: 0x163800 - 0x163824

void entry_163800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163800) {
        switch (ctx->pc) {
            case 0x163818: ctx->pc = 0; goto label_163818;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163800: 0xae000004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 0));
    // 0x163804: 0x8fa700e4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x163808: 0x8ce20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 64)));
    // 0x16380c: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x163810: 0x1440fff3
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1637E0; return;
    }
label_163818:
    // 0x163818: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x16381c: 0xc07b8c6
    SET_GPR_U32(ctx, 31, 0x163824);
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 29), 356)));
    fn___4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_163824
// Address: 0x163824 - 0x163844

void entry_163824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163824: 0x8fa800e4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x163828: 0x3c090026
    SET_GPR_U32(ctx, 9, ((uint32_t)38 << 16));
    // 0x16382c: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x163830: 0x8d3026d0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 9), 9936)));
    // 0x163834: 0x8d050040
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 8), 64)));
    // 0x163838: 0x529c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 7));
    // 0x16383c: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x163844);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1024));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_163844
// Address: 0x163844 - 0x16387c

void entry_163844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163844: 0x8fa20134
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 308)));
    // 0x163848: 0x3c0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x16384c: 0x8fa30140
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x163850: 0x2c0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x163854: 0x8fa500fc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 252)));
    // 0x163858: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x16385c: 0x8fa400e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x163860: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x163864: 0x8fa8012c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 300)));
    // 0x163868: 0x8fab0130
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x16386c: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x163870: 0xafa30010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 3));
    // 0x163874: 0xc058e7a
    SET_GPR_U32(ctx, 31, 0x16387c);
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 20));
    BuildSubcel__FP7GLOBSETiP6SUBCELiP7VECTORFiP4TWEFP8SUBPOSEFT4PfP4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_16387c
// Address: 0x16387c - 0x16389c

void entry_16387c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16387c: 0x8fa40154
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 340)));
    // 0x163880: 0x24080013
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 19));
    // 0x163884: 0x8fa50168
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 360)));
    // 0x163888: 0xafa400fc
    WRITE32(ADD32(GPR_U32(ctx, 29), 252), GPR_U32(ctx, 4));
    // 0x16388c: 0x8fa70138
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 312)));
    // 0x163890: 0x8fa40140
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x163894: 0xc054a94
    SET_GPR_U32(ctx, 31, 0x16389c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 348)));
    DetachCopySw__4DMASPiPP2QWT2i(rdram, ctx, runtime); return;
}


// Function: entry_16389c
// Address: 0x16389c - 0x1638b4

void entry_16389c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16389c: 0x8e450018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x1638a0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1638a4: 0x8fa600e0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1638a8: 0x8e47001c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x1638ac: 0xc05a5ae
    SET_GPR_U32(ctx, 31, 0x1638b4);
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    RebaseSurs__FiiPvT2(rdram, ctx, runtime); return;
}


// Function: entry_1638b4
// Address: 0x1638b4 - 0x1638d0

void entry_1638b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1638b4: 0x8fa400e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1638b8: 0x8e42001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x1638bc: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1638c0: 0x441023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1638c4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1638c8: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1638d0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 0), GPR_U32(ctx, 3));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1638d0
// Address: 0x1638d0 - 0x163904

void entry_1638d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1638d0) {
        switch (ctx->pc) {
            case 0x1638e4: ctx->pc = 0; goto label_1638e4;
            case 0x1638e8: ctx->pc = 0; goto label_1638e8;
            case 0x1638fc: ctx->pc = 0; goto label_1638fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1638d0: 0x8fa500f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x1638d4: 0x8ca20060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 96)));
    // 0x1638d8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1638dc: 0x1440ff6a
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x163688; return;
    }
label_1638e4:
    // 0x1638e4: 0x8fa600e4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 228)));
label_1638e8:
    // 0x1638e8: 0x8fb2014c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 29), 332)));
    // 0x1638ec: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1638f0: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1638f4: 0x1440fc44
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 112));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x162A08; return;
    }
label_1638fc:
    // 0x1638fc: 0xc058a04
    SET_GPR_U32(ctx, 31, 0x163904);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    BuildGlobsetSaaArray__FP7GLOBSET(rdram, ctx, runtime); return;
}


// Function: entry_163904
// Address: 0x163904 - 0x163938

void entry_163904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163904: 0x7bbf0210
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 528)));
    // 0x163908: 0x7bbe0200
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x16390c: 0x7bb701f0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x163910: 0x7bb601e0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x163914: 0x7bb501d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x163918: 0x7bb401c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x16391c: 0x7bb301b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x163920: 0x7bb201a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x163924: 0x7bb10190
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x163928: 0x7bb00180
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x16392c: 0xc7b40220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 544)); ctx->f[20] = *(float*)&val; }
    // 0x163930: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 560));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnsureBuffer__FiP4VIFS
// Address: 0x163938 - 0x16396c

void entry_16396c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16396c) {
        switch (ctx->pc) {
            case 0x163974: ctx->pc = 0; goto label_163974;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16396c: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x163988; return;
    }
label_163974:
    // 0x163974: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x163978: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x16397c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x163984);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 6392));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_163984
// Address: 0x163984 - 0x163990

void entry_163984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163984) {
        switch (ctx->pc) {
            case 0x163988: ctx->pc = 0; goto label_163988;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163984: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_163988:
    // 0x163988: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: EnsureBufferCel__FiP4VIFS
// Address: 0x163990 - 0x1639c4

void entry_1639c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1639c4) {
        switch (ctx->pc) {
            case 0x1639cc: ctx->pc = 0; goto label_1639cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1639c4: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1639E0; return;
    }
label_1639cc:
    // 0x1639cc: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x1639d0: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1639d4: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x1639dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4056));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_1639dc
// Address: 0x1639dc - 0x1639e8

void entry_1639dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1639dc) {
        switch (ctx->pc) {
            case 0x1639e0: ctx->pc = 0; goto label_1639e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1639dc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1639e0:
    // 0x1639e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BuildSubcel__FP7GLOBSETiP6SUBCELiP7VECTORFiP4TWEFP8SUBPOSEFT4PfP4VIFS
// Address: 0x1639e8 - 0x163a58

void entry_163a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163a58: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163a5c: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x163a60: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x163a68);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_163a68
// Address: 0x163a68 - 0x163a70

void entry_163a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163a68: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x163a70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_163a70
// Address: 0x163a70 - 0x163a7c

void entry_163a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163a70: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163a74: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x163a7c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_163a7c
// Address: 0x163a7c - 0x163a90

void entry_163a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163a7c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163a80: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x163a84: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163a88: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x163a90);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_163a90
// Address: 0x163a90 - 0x163aa0

void entry_163a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163a90: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163a94: 0x24060044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    // 0x163a98: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x163aa0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 66));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_163aa0
// Address: 0x163aa0 - 0x163ae8

void entry_163aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163aa0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x163aa4: 0x34098000
    SET_GPR_U32(ctx, 9, OR32(GPR_U32(ctx, 0), 32768));
    // 0x163aa8: 0x94c78
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 9) << 17);
    // 0x163aac: 0x244823e0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 9184));
    // 0x163ab0: 0x904623e0
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 9184)));
    // 0x163ab4: 0x91030001
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 8), 1)));
    // 0x163ab8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163abc: 0x91070002
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 8), 2)));
    // 0x163ac0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x163ac4: 0x31a38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 8);
    // 0x163ac8: 0x91020003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 8), 3)));
    // 0x163acc: 0xc33025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 3)));
    // 0x163ad0: 0x73c38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 16);
    // 0x163ad4: 0x21638
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 24);
    // 0x163ad8: 0xc73025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 7)));
    // 0x163adc: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x163ae0: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x163ae8);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 9)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_163ae8
// Address: 0x163ae8 - 0x163af4

void entry_163ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163ae8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163aec: 0xc05849e
    SET_GPR_U32(ctx, 31, 0x163af4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    EndPrim__4GIFSi(rdram, ctx, runtime); return;
}


// Function: entry_163af4
// Address: 0x163af4 - 0x163b0c

void entry_163af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163af4: 0x8fa70004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x163af8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163afc: 0x24080018
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 24));
    // 0x163b00: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x163b04: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x163b0c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_163b0c
// Address: 0x163b0c - 0x163b14

void entry_163b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163b0c: 0xc054a38
    SET_GPR_U32(ctx, 31, 0x163b14);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    Reset__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_163b14
// Address: 0x163b14 - 0x163b28

void entry_163b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163b14: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163b18: 0x2407044e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1102));
    // 0x163b1c: 0x240500c1
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 193));
    // 0x163b20: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x163b28);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_163b28
// Address: 0x163b28 - 0x163b38

void entry_163b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163b28: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163b2c: 0x24050047
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    // 0x163b30: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x163b38);
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_163b38
// Address: 0x163b38 - 0x163b50

void entry_163b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163b38: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163b3c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163b40: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163b44: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163b48: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x163b50);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_163b50
// Address: 0x163b50 - 0x163b68

void entry_163b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163b50: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163b54: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163b58: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163b5c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163b60: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x163b68);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_163b68
// Address: 0x163b68 - 0x163b74

void entry_163b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163b68: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163b6c: 0xc05849e
    SET_GPR_U32(ctx, 31, 0x163b74);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EndPrim__4GIFSi(rdram, ctx, runtime); return;
}


// Function: entry_163b74
// Address: 0x163b74 - 0x163b88

void entry_163b74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163b74: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163b78: 0x2407044e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1102));
    // 0x163b7c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x163b80: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x163b88);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_163b88
// Address: 0x163b88 - 0x163b9c

void entry_163b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163b88: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163b8c: 0x3c060007
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    // 0x163b90: 0x34c62001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 8193));
    // 0x163b94: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x163b9c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_163b9c
// Address: 0x163b9c - 0x163bb4

void entry_163b9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163b9c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163ba0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163ba4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163ba8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163bac: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x163bb4);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_163bb4
// Address: 0x163bb4 - 0x163bcc

void entry_163bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163bb4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163bb8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163bbc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163bc0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163bc4: 0xc05857c
    SET_GPR_U32(ctx, 31, 0x163bcc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackXYZF__4GIFSiiii(rdram, ctx, runtime); return;
}


// Function: entry_163bcc
// Address: 0x163bcc - 0x163bd8

void entry_163bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163bcc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x163bd0: 0xc05849e
    SET_GPR_U32(ctx, 31, 0x163bd8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    EndPrim__4GIFSi(rdram, ctx, runtime); return;
}


// Function: entry_163bd8
// Address: 0x163bd8 - 0x163bf0

void entry_163bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163bd8: 0x8fa70004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x163bdc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163be0: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x163be4: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x163be8: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x163bf0);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 27));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_163bf0
// Address: 0x163bf0 - 0x163c0c

void entry_163bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163bf0: 0x8fa70004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x163bf4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163bf8: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x163bfc: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x163c00: 0x24e70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 64));
    // 0x163c04: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x163c0c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 31));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_163c0c
// Address: 0x163c0c - 0x163c24

void entry_163c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163c0c: 0x8fa70004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x163c10: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163c14: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x163c18: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x163c1c: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x163c24);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 35));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_163c24
// Address: 0x163c24 - 0x163c40

void entry_163c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163c24: 0x8fa70004
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x163c28: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163c2c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x163c30: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x163c34: 0x24e70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 64));
    // 0x163c38: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x163c40);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 39));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_163c40
// Address: 0x163c40 - 0x163c70

void entry_163c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163c40: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163c44: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163c48: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x163c4c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x163c50: 0xa4530000
    WRITE16(ADD32(GPR_U32(ctx, 2), 0), (uint16_t)GPR_U32(ctx, 19));
    // 0x163c54: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x163c58: 0x2653002b
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 43));
    // 0x163c5c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163c60: 0xa4530002
    WRITE16(ADD32(GPR_U32(ctx, 2), 2), (uint16_t)GPR_U32(ctx, 19));
    // 0x163c64: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163c68: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x163c70);
    SET_GPR_U32(ctx, 8, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 0)));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_163c70
// Address: 0x163c70 - 0x163ca4

void entry_163c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163c70: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x163c74: 0x18400026
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_163d10(rdram, ctx, runtime); return;
    }
    // 0x163c7c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163c80: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x163c84: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163c88: 0xa4730008
    WRITE16(ADD32(GPR_U32(ctx, 3), 8), (uint16_t)GPR_U32(ctx, 19));
    // 0x163c8c: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x163c90: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163c94: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x163c98: 0x2629821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x163c9c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x163ca4);
    WRITE16(ADD32(GPR_U32(ctx, 3), 10), (uint16_t)GPR_U32(ctx, 19));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_163ca4
// Address: 0x163ca4 - 0x163cb4

void entry_163ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163ca4: 0x2729821
    SET_GPR_U32(ctx, 19, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 18)));
    // 0x163ca8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163cac: 0xc07b930
    SET_GPR_U32(ctx, 31, 0x163cb4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    AddVifStrow__4VIFSP2QW(rdram, ctx, runtime); return;
}


// Function: entry_163cb4
// Address: 0x163cb4 - 0x163cd4

void entry_163cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163cb4: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x163cb8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x163cbc: 0x246323e8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 9192));
    // 0x163cc0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163cc4: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x163cc8: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x163ccc: 0xc07b94a
    SET_GPR_U32(ctx, 31, 0x163cd4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    AddVifStmask__4VIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_163cd4
// Address: 0x163cd4 - 0x163d04

void entry_163cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163cd4: 0x8e030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x163cd8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x163cdc: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163ce0: 0x24422400
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 9216));
    // 0x163ce4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x163ce8: 0x8fa70108
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 264)));
    // 0x163cec: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x163cf0: 0x9488000a
    SET_GPR_U32(ctx, 8, (uint16_t)READ16(ADD32(GPR_U32(ctx, 4), 10)));
    // 0x163cf4: 0x8c650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x163cf8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163cfc: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x163d04);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_163d04
// Address: 0x163d04 - 0x163d10

void entry_163d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163d04: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163d08: 0xc07b94a
    SET_GPR_U32(ctx, 31, 0x163d10);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifStmask__4VIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_163d10
// Address: 0x163d10 - 0x163d68

void entry_163d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163d10) {
        switch (ctx->pc) {
            case 0x163d50: ctx->pc = 0; goto label_163d50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163d10: 0x8fa3004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x163d14: 0x3c1e0000
    SET_GPR_U32(ctx, 30, ((uint32_t)0 << 16));
    // 0x163d18: 0x8e820040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 64)));
    // 0x163d1c: 0x1040004c
    SET_GPR_U32(ctx, 23, ADD32(GPR_U32(ctx, 19), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x163E50; return;
    }
    // 0x163d24: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163d28: 0xa473000a
    WRITE16(ADD32(GPR_U32(ctx, 3), 10), (uint16_t)GPR_U32(ctx, 19));
    // 0x163d2c: 0x96820040
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 20), 64)));
    // 0x163d30: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163d34: 0x531021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x163d38: 0xa462000c
    WRITE16(ADD32(GPR_U32(ctx, 3), 12), (uint16_t)GPR_U32(ctx, 2));
    // 0x163d3c: 0xafa00040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 0));
    // 0x163d40: 0x8e820040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 64)));
    // 0x163d44: 0x18400042
    SET_GPR_U32(ctx, 22, ((uint32_t)0 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x163E50; return;
    }
    // 0x163d4c: 0x0
    // NOP
label_163d50:
    // 0x163d50: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163d54: 0x27a70040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    // 0x163d58: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163d5c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x163d60: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x163d68);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 29));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_163d68
// Address: 0x163d68 - 0x163d88

void entry_163d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163d68: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163d6c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163d70: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x163d74: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x163d78: 0x9447000c
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 12)));
    // 0x163d7c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163d80: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x163d88);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 68));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_163d88
// Address: 0x163d88 - 0x163e30

void entry_163d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163d88) {
        switch (ctx->pc) {
            case 0x163db8: ctx->pc = 0; goto label_163db8;
            case 0x163e24: ctx->pc = 0; goto label_163e24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163d88: 0x8fa20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x163d8c: 0x8fa30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x163d90: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x163d94: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x163d98: 0x1a400022
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    if (GPR_S32(ctx, 18) <= 0) {
        goto label_163e24;
    }
    // 0x163da0: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x163da4: 0x2408000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 12));
    // 0x163da8: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x163dac: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163db0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x163db4: 0x0
    // NOP
label_163db8:
    // 0x163db8: 0x8fa20100
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x163dbc: 0x24a5ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x163dc0: 0x94e30000
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x163dc4: 0x400013
    ctx->lo = GPR_U32(ctx, 2);
    // 0x163dc8: 0xc4810000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[1] = *(float*)&val; }
    // 0x163dcc: 0x70681800
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 8); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x163dd0: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x163dd4: 0x24e70002
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 2));
    // 0x163dd8: 0xc21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x163ddc: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x163de0: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x163de4: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x163de8: 0xc4810004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[1] = *(float*)&val; }
    // 0x163dec: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x163df0: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x163df4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x163df8: 0xc21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x163dfc: 0xe4400004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x163e00: 0xc4800008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[0] = *(float*)&val; }
    // 0x163e04: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x163e08: 0x2484000c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 12));
    // 0x163e0c: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x163e10: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x163e14: 0xc21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x163e18: 0x24c6000c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 12));
    // 0x163e1c: 0x14a0ffe6
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_163db8;
    }
label_163e24:
    // 0x163e24: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163e28: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x163e30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 22), 4760));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_163e30
// Address: 0x163e30 - 0x163e38

void entry_163e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163e30: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x163e38);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_163e38
// Address: 0x163e38 - 0x163e7c

void entry_163e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163e38) {
        switch (ctx->pc) {
            case 0x163e50: ctx->pc = 0; goto label_163e50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163e38: 0x8fa20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x163e3c: 0x8e830040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 64)));
    // 0x163e40: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x163e44: 0x43182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x163e48: 0x1460ffc1
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x163D50; return;
    }
label_163e50:
    // 0x163e50: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163e54: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163e58: 0x8fa6004c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x163e5c: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x163e60: 0x8fa70050
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x163e64: 0xa4530004
    WRITE16(ADD32(GPR_U32(ctx, 2), 4), (uint16_t)GPR_U32(ctx, 19));
    // 0x163e68: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163e6c: 0xa4570006
    WRITE16(ADD32(GPR_U32(ctx, 2), 6), (uint16_t)GPR_U32(ctx, 23));
    // 0x163e70: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x163e74: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x163e7c);
    SET_GPR_U32(ctx, 8, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 4)));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_163e7c
// Address: 0x163e7c - 0x163e88

void entry_163e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163e7c: 0x8fa40048
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x163e80: 0xc058e64
    SET_GPR_U32(ctx, 31, 0x163e88);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    EnsureBufferCel__FiP4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_163e88
// Address: 0x163e88 - 0x163e94

void entry_163e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163e88: 0x27c51368
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 4968));
    // 0x163e8c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x163e94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_163e94
// Address: 0x163e94 - 0x163ea4

void entry_163e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163e94: 0x3c030000
    SET_GPR_U32(ctx, 3, ((uint32_t)0 << 16));
    // 0x163e98: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x163e9c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x163ea4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 3800));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_163ea4
// Address: 0x163ea4 - 0x163ed8

void entry_163ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163ea4: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x163ea8: 0x7bbe00e0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x163eac: 0x7bb700d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x163eb0: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x163eb4: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x163eb8: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x163ebc: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x163ec0: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x163ec4: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x163ec8: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x163ecc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x163ed4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x163ed8; return;
}


// Function: BuildSubglobSinglePass__FP7GLOBSETP4GLOBiP7SUBGLOBP3SHDP7VECTORFT5P4RGBAP3UVFiP4VTXFP8SUBPOSEFT5T5PfP4VIFSP4SGVR
// Address: 0x163ed8 - 0x163f3c

void entry_163f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163f3c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x163f40: 0x2405000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    // 0x163f44: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x163f48: 0x2407000b
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 11));
    // 0x163f4c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163f50: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x163f58);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 20), 28));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_163f58
// Address: 0x163f58 - 0x163f70

void entry_163f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x163f58: 0x24020024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 36));
    // 0x163f5c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x163f60: 0xafa20040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 2));
    // 0x163f64: 0x24060018
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    // 0x163f68: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x163f70);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_163f70
// Address: 0x163f70 - 0x16405c

void entry_163f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x163f70) {
        switch (ctx->pc) {
            case 0x164044: ctx->pc = 0; goto label_164044;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x163f70: 0x8e84001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x163f74: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x163f78: 0x1e1840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 30), 1));
    // 0x163f7c: 0xa4820010
    WRITE16(ADD32(GPR_U32(ctx, 4), 16), (uint16_t)GPR_U32(ctx, 2));
    // 0x163f80: 0x7e1821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 30)));
    // 0x163f84: 0x8fa40040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x163f88: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x163f8c: 0xa4440000
    WRITE16(ADD32(GPR_U32(ctx, 2), 0), (uint16_t)GPR_U32(ctx, 4));
    // 0x163f90: 0x24630024
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 36));
    // 0x163f94: 0xafa30040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 3));
    // 0x163f98: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x163f9c: 0xa4430002
    WRITE16(ADD32(GPR_U32(ctx, 2), 2), (uint16_t)GPR_U32(ctx, 3));
    // 0x163fa0: 0x92c30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 22), 0)));
    // 0x163fa4: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x163fa8: 0x2c62000a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 10));
    // 0x163fac: 0x10400025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_164044;
    }
    // 0x163fb4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x163fb8: 0x2442a720
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294944544));
    // 0x163fbc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x163fc0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x163fc4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x163fcc: 0x3c020000
    SET_GPR_U32(ctx, 2, ((uint32_t)0 << 16));
    // 0x163fd0: 0x3c030000
    SET_GPR_U32(ctx, 3, ((uint32_t)0 << 16));
    // 0x163fd4: 0x244202f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 760));
    // 0x163fd8: 0x24631a50
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 6736));
    // 0x163fdc: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x163fe0: 0xafa2004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 2));
    // 0x163fe4: 0xafa30048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 3));
    // 0x163fe8: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x163fec: 0x10000015
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_164044;
    }
    // 0x163ff4: 0x92c20001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 22), 1)));
    // 0x163ff8: 0x3c030000
    SET_GPR_U32(ctx, 3, ((uint32_t)0 << 16));
    // 0x163ffc: 0x3c040000
    SET_GPR_U32(ctx, 4, ((uint32_t)0 << 16));
    // 0x164000: 0x246336d0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 14032));
    // 0x164004: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x164008: 0x24841a80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 6784));
    // 0x16400c: 0xafa3004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 3));
    // 0x164010: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x164014: 0xafa20044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 2));
    // 0x164018: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_164044;
    }
    // 0x164020: 0x3c020000
    SET_GPR_U32(ctx, 2, ((uint32_t)0 << 16));
    // 0x164024: 0x3c030000
    SET_GPR_U32(ctx, 3, ((uint32_t)0 << 16));
    // 0x164028: 0x244202f8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 760));
    // 0x16402c: 0x24631a50
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 6736));
    // 0x164030: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x164034: 0xafa2004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 2));
    // 0x164038: 0xafa30048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 3));
    // 0x16403c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164040: 0xafa60044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 6));
label_164044:
    // 0x164044: 0xafa0002c
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 0));
    // 0x164048: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x16404c: 0xafa00010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 0));
    // 0x164050: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x164054: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x16405c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_16405c
// Address: 0x16405c - 0x164080

void entry_16405c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16405c: 0x12400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_164080(rdram, ctx, runtime); return;
    }
    // 0x164064: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x164068: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x16406c: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x164070: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x164074: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164078: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x164080);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_164080
// Address: 0x164080 - 0x1640a4

void entry_164080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164080: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x164084: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x164088: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x16408c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x164090: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x164094: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164098: 0x27a90014
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 20));
    // 0x16409c: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x1640a4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 2));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_1640a4
// Address: 0x1640a4 - 0x1640b4

void entry_1640a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1640a4: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1640a8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1640ac: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x1640b4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_1640b4
// Address: 0x1640b4 - 0x1640f4

void entry_1640b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1640b4) {
        switch (ctx->pc) {
            case 0x1640c0: ctx->pc = 0; goto label_1640c0;
            case 0x1640d0: ctx->pc = 0; goto label_1640d0;
            case 0x1640e0: ctx->pc = 0; goto label_1640e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1640b4: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1640b8: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 30));
        goto label_1640c0;
    }
label_1640c0:
    // 0x1640c0: 0x8e230004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1640c4: 0x10600002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1640d0;
    }
    // 0x1640cc: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_1640d0:
    // 0x1640d0: 0x8e230008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1640d4: 0x10600002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1640e0;
    }
    // 0x1640dc: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_1640e0:
    // 0x1640e0: 0x8ee20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 84)));
    // 0x1640e4: 0x10400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x164100; return;
    }
    // 0x1640ec: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1640f4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 52));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1640f4
// Address: 0x1640f4 - 0x16421c

void entry_1640f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1640f4) {
        switch (ctx->pc) {
            case 0x164100: ctx->pc = 0; goto label_164100;
            case 0x164130: ctx->pc = 0; goto label_164130;
            case 0x164154: ctx->pc = 0; goto label_164154;
            case 0x164180: ctx->pc = 0; goto label_164180;
            case 0x164194: ctx->pc = 0; goto label_164194;
            case 0x1641d8: ctx->pc = 0; goto label_1641d8;
            case 0x1641e0: ctx->pc = 0; goto label_1641e0;
            case 0x164200: ctx->pc = 0; goto label_164200;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1640f4: 0x8fa30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1640f8: 0xae820020
    WRITE32(ADD32(GPR_U32(ctx, 20), 32), GPR_U32(ctx, 2));
    // 0x1640fc: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_164100:
    // 0x164100: 0x1bc0003f
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 30) <= 0) {
        goto label_164200;
    }
    // 0x164108: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x16410c: 0x240900ff
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 255));
    // 0x164110: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x164114: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x164118: 0x2408000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16411c: 0x3c014700
    SET_GPR_U32(ctx, 1, ((uint32_t)18176 << 16));
    // 0x164120: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x164124: 0x8fa50110
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x164128: 0x3c0146e0
    SET_GPR_U32(ctx, 1, ((uint32_t)18144 << 16));
    // 0x16412c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
label_164130:
    // 0x164130: 0x12400018
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_164194;
    }
    // 0x164138: 0x90e20002
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 2)));
    // 0x16413c: 0x14490005
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 9)) {
        goto label_164154;
    }
    // 0x164144: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x164148: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x16414c: 0x1000000c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_164180;
    }
label_164154:
    // 0x164154: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x164158: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16415c: 0x4a1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 10)));
    // 0x164160: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x164164: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x164168: 0x90e20002
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 2)));
    // 0x16416c: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x164170: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x164174: 0x4a1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 10)));
    // 0x164178: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x16417c: 0xe4600004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
label_164180:
    // 0x164180: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x164184: 0xe4640008
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 3), 8), *(uint32_t*)&val); }
    // 0x164188: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16418c: 0x2442000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 12));
    // 0x164190: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
label_164194:
    // 0x164194: 0x90a20000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x164198: 0x8fa40014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x16419c: 0x481818
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 8); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1641a0: 0x701021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x1641a4: 0x68470007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1641a8: 0x6c470000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 7, (GPR_U64(ctx, 7) & ~mask) | (aligned_data & mask)); }
    // 0x1641ac: 0x8c4a0008
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1641b0: 0xb0870007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1641b4: 0xb4870000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 7) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1641b8: 0xac8a0008
    WRITE32(ADD32(GPR_U32(ctx, 4), 8), GPR_U32(ctx, 10));
    // 0x1641bc: 0x90a30003
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 3)));
    // 0x1641c0: 0x319c2
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 7));
    // 0x1641c4: 0x10600004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1641d8;
    }
    // 0x1641cc: 0xc6e00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 64)); ctx->f[0] = *(float*)&val; }
    // 0x1641d0: 0x10000003
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1641e0;
    }
label_1641d8:
    // 0x1641d8: 0xc6e00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 64)); ctx->f[0] = *(float*)&val; }
    // 0x1641dc: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
label_1641e0:
    // 0x1641e0: 0xe440000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x1641e4: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x1641e8: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1641ec: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1641f0: 0xde182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 30)));
    // 0x1641f4: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1641f8: 0x1460ffcd
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_164130;
    }
label_164200:
    // 0x164200: 0x8ee40038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 23), 56)));
    // 0x164204: 0x10800006
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x164220; return;
    }
    // 0x16420c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x164210: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x164214: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16421c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16421c
// Address: 0x16421c - 0x164248

void entry_16421c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16421c) {
        switch (ctx->pc) {
            case 0x164220: ctx->pc = 0; goto label_164220;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16421c: 0xafa20050
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 2));
label_164220:
    // 0x164220: 0x8fa40050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x164224: 0x1480000a
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x164250; return;
    }
    // 0x16422c: 0x8ec40024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 22), 36)));
    // 0x164230: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 56)));
        ctx->pc = 0x164250; return;
    }
    // 0x164238: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x16423c: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x164240: 0x40f809
    SET_GPR_U32(ctx, 31, 0x164248);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_164248
// Address: 0x164248 - 0x164258

void entry_164248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164248) {
        switch (ctx->pc) {
            case 0x164250: ctx->pc = 0; goto label_164250;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164248: 0xafa20050
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 2));
    // 0x16424c: 0x8fa40038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 56)));
label_164250:
    // 0x164250: 0xc058e4e
    SET_GPR_U32(ctx, 31, 0x164258);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    EnsureBuffer__FiP4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_164258
// Address: 0x164258 - 0x16428c

void entry_164258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164258: 0x8fa50050
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16425c: 0x50a00014
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 36)));
        ctx->pc = 0x1642B0; return;
    }
    // 0x164264: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x164268: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x16426c: 0x1040000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1642ac(rdram, ctx, runtime); return;
    }
    // 0x164274: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x164278: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16427c: 0x24070016
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 22));
    // 0x164280: 0x27a80018
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 24));
    // 0x164284: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x16428c);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 28));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_16428c
// Address: 0x16428c - 0x16429c

void entry_16428c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16428c: 0x8fa50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x164290: 0x8fa4001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x164294: 0xc05a582
    SET_GPR_U32(ctx, 31, 0x16429c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    ReferenceUVAnimation__FP2QWiP3SAI(rdram, ctx, runtime); return;
}


// Function: entry_16429c
// Address: 0x16429c - 0x1642ac

void entry_16429c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16429c: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x1642a0: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1642a4: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x1642ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 10176));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_1642ac
// Address: 0x1642ac - 0x1642ec

void entry_1642ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1642ac) {
        switch (ctx->pc) {
            case 0x1642b0: ctx->pc = 0; goto label_1642b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1642ac: 0x8e820024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 36)));
label_1642b0:
    // 0x1642b0: 0x1840004a
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_1643dc(rdram, ctx, runtime); return;
    }
    // 0x1642b8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1642bc: 0x8e83001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x1642c0: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1642c4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1642c8: 0xa4670004
    WRITE16(ADD32(GPR_U32(ctx, 3), 4), (uint16_t)GPR_U32(ctx, 7));
    // 0x1642cc: 0x8e820024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 36)));
    // 0x1642d0: 0x8e83001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x1642d4: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x1642d8: 0xe23821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x1642dc: 0xa4670006
    WRITE16(ADD32(GPR_U32(ctx, 3), 6), (uint16_t)GPR_U32(ctx, 7));
    // 0x1642e0: 0xfe3821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 30)));
    // 0x1642e4: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x1642ec);
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 7));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_1642ec
// Address: 0x1642ec - 0x1642f8

void entry_1642ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1642ec: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1642f0: 0xc07b930
    SET_GPR_U32(ctx, 31, 0x1642f8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddVifStrow__4VIFSP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1642f8
// Address: 0x1642f8 - 0x164318

void entry_1642f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1642f8: 0x8e820024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 36)));
    // 0x1642fc: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x164300: 0x24632418
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 9240));
    // 0x164304: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x164308: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x16430c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x164310: 0xc07b94a
    SET_GPR_U32(ctx, 31, 0x164318);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    AddVifStmask__4VIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_164318
// Address: 0x164318 - 0x16434c

void entry_164318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164318: 0x8e830024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 36)));
    // 0x16431c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x164320: 0x8e85001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x164324: 0x24422430
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 9264));
    // 0x164328: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x16432c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x164330: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x164334: 0x94a70006
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 6)));
    // 0x164338: 0x8c650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16433c: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x164340: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164344: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x16434c);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 32));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_16434c
// Address: 0x16434c - 0x164358

void entry_16434c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16434c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x164350: 0xc07b94a
    SET_GPR_U32(ctx, 31, 0x164358);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifStmask__4VIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_164358
// Address: 0x164358 - 0x1643dc

void entry_164358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164358) {
        switch (ctx->pc) {
            case 0x164368: ctx->pc = 0; goto label_164368;
            case 0x164380: ctx->pc = 0; goto label_164380;
            case 0x1643bc: ctx->pc = 0; goto label_1643bc;
            case 0x1643cc: ctx->pc = 0; goto label_1643cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164358: 0x1bc0001c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 30) <= 0) {
        goto label_1643cc;
    }
    // 0x164360: 0x8faa0110
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x164364: 0x0
    // NOP
label_164368:
    // 0x164368: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x16436c: 0x8e840024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 36)));
    // 0x164370: 0x24c90001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 6), 1));
    // 0x164374: 0x1423821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 2)));
    // 0x164378: 0x18800010
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_1643bc;
    }
label_164380:
    // 0x164380: 0x90e20000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x164384: 0x8faa0130
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x164388: 0x443018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x16438c: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x164390: 0xc51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    // 0x164394: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x164398: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x16439c: 0x4a1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 10)));
    // 0x1643a0: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1643a4: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1643a8: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1643ac: 0x8e840024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 36)));
    // 0x1643b0: 0xa4102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 4)));
    // 0x1643b4: 0x1440fff2
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_164380;
    }
label_1643bc:
    // 0x1643bc: 0x120302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x1643c0: 0xde102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 30)));
    // 0x1643c4: 0x1440ffe8
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_164368;
    }
label_1643cc:
    // 0x1643cc: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x1643d0: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1643d4: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x1643dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8200));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_1643dc
// Address: 0x1643dc - 0x164428

void entry_1643dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1643dc) {
        switch (ctx->pc) {
            case 0x164418: ctx->pc = 0; goto label_164418;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1643dc: 0x8e620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 64)));
    // 0x1643e0: 0x1040005b
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x164550; return;
    }
    // 0x1643e8: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x1643ec: 0xa44b0006
    WRITE16(ADD32(GPR_U32(ctx, 2), 6), (uint16_t)GPR_U32(ctx, 11));
    // 0x1643f0: 0x8e630040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 64)));
    // 0x1643f4: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x1643f8: 0x1635821
    SET_GPR_U32(ctx, 11, ADD32(GPR_U32(ctx, 11), GPR_U32(ctx, 3)));
    // 0x1643fc: 0xafab0040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 11));
    // 0x164400: 0xa44b000e
    WRITE16(ADD32(GPR_U32(ctx, 2), 14), (uint16_t)GPR_U32(ctx, 11));
    // 0x164404: 0xafa00024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 0));
    // 0x164408: 0x8e620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 64)));
    // 0x16440c: 0x18400050
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x164550; return;
    }
    // 0x164414: 0x0
    // NOP
label_164418:
    // 0x164418: 0x18800004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x16442C; return;
    }
    // 0x164420: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x164428);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_164428
// Address: 0x164428 - 0x164440

void entry_164428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164428) {
        switch (ctx->pc) {
            case 0x16442c: ctx->pc = 0; goto label_16442c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164428: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_16442c:
    // 0x16442c: 0x27a70024
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 36));
    // 0x164430: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164434: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x164438: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x164440);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 22));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_164440
// Address: 0x164440 - 0x164460

void entry_164440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164440: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x164444: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x164448: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x16444c: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x164450: 0x9447000e
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 14)));
    // 0x164454: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164458: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x164460);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 40));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_164460
// Address: 0x164460 - 0x164534

void entry_164460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164460) {
        switch (ctx->pc) {
            case 0x164490: ctx->pc = 0; goto label_164490;
            case 0x164528: ctx->pc = 0; goto label_164528;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164460: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x164464: 0x3c0c0000
    SET_GPR_U32(ctx, 12, ((uint32_t)0 << 16));
    // 0x164468: 0x8fa30118
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 280)));
    // 0x16446c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164470: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x164474: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x164478: 0x1bc0002b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    if (GPR_S32(ctx, 30) <= 0) {
        goto label_164528;
    }
    // 0x164480: 0x8faa0110
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x164484: 0x40482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x164488: 0x240b000c
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16448c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_164490:
    // 0x164490: 0x8fa20120
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x164494: 0x140382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x164498: 0x95240000
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x16449c: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1644a0: 0x90e30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1644a4: 0x400013
    ctx->lo = GPR_U32(ctx, 2);
    // 0x1644a8: 0x708b2000
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 11); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1644ac: 0x8fa20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1644b0: 0x24ea0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 7), 4));
    // 0x1644b4: 0x25290002
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 2));
    // 0x1644b8: 0x6b2818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1644bc: 0x1021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x1644c0: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1644c4: 0xb01821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 16)));
    // 0x1644c8: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x1644cc: 0xde282a
    SET_GPR_U32(ctx, 5, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 30)));
    // 0x1644d0: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x1644d4: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x1644d8: 0x90e30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x1644dc: 0xc4810004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1644e0: 0x6b1018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1644e4: 0x501821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x1644e8: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1644ec: 0x8fa20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1644f0: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1644f4: 0x1021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x1644f8: 0xe4410004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x1644fc: 0x90e30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x164500: 0xc4810008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[1] = *(float*)&val; }
    // 0x164504: 0x6b1018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164508: 0x501821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x16450c: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x164510: 0x8fa20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x164514: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x164518: 0x1021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x16451c: 0x2508000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 12));
    // 0x164520: 0x14a0ffdb
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_164490;
    }
label_164528:
    // 0x164528: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x16452c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x164534);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 12), 9144));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_164534
// Address: 0x164534 - 0x16459c

void entry_164534(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164534) {
        switch (ctx->pc) {
            case 0x164550: ctx->pc = 0; goto label_164550;
            case 0x164580: ctx->pc = 0; goto label_164580;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164534: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x164538: 0x8e630040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 64)));
    // 0x16453c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x164540: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x164544: 0x83182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 3)));
    // 0x164548: 0x1460ffb3
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x164418; return;
    }
label_164550:
    // 0x164550: 0x8e890020
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 20), 32)));
    // 0x164554: 0x1120003e
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 9) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x164650; return;
    }
    // 0x16455c: 0x8ee30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 84)));
    // 0x164560: 0x9e2021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 30)));
    // 0x164564: 0xafa40054
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 4));
    // 0x164568: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x16456c: 0x18400033
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x16463C; return;
    }
    // 0x164574: 0x25320024
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 9), 36));
    // 0x164578: 0x25310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 9), 4));
    // 0x16457c: 0x25300014
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 9), 20));
label_164580:
    // 0x164580: 0x8fa70040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x164584: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x164588: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16458c: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x164590: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164594: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x16459c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_16459c
// Address: 0x16459c - 0x1645c4

void entry_16459c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16459c: 0x8ee20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 84)));
    // 0x1645a0: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1645a4: 0x1060000e
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1645E0; return;
    }
    // 0x1645ac: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1645b0: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1645b4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1645b8: 0x24080016
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 22));
    // 0x1645bc: 0xc07b9c6
    SET_GPR_U32(ctx, 31, 0x1645c4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifUnpackRefs__4VIFS3UPKiPviPPPv(rdram, ctx, runtime); return;
}


// Function: entry_1645c4
// Address: 0x1645c4 - 0x1645d4

void entry_1645c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1645c4: 0x3c060000
    SET_GPR_U32(ctx, 6, ((uint32_t)0 << 16));
    // 0x1645c8: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1645cc: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x1645d4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 6), 14976));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_1645d4
// Address: 0x1645d4 - 0x1645dc

void entry_1645d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1645d4: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x1645dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_1645dc
// Address: 0x1645dc - 0x164604

void entry_1645dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1645dc) {
        switch (ctx->pc) {
            case 0x1645e0: ctx->pc = 0; goto label_1645e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1645dc: 0x8ee20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 84)));
label_1645e0:
    // 0x1645e0: 0x8c430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x1645e4: 0x1060000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_16461c(rdram, ctx, runtime); return;
    }
    // 0x1645ec: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1645f0: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1645f4: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1645f8: 0x24080016
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 22));
    // 0x1645fc: 0xc07b9c6
    SET_GPR_U32(ctx, 31, 0x164604);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddVifUnpackRefs__4VIFS3UPKiPviPPPv(rdram, ctx, runtime); return;
}


// Function: entry_164604
// Address: 0x164604 - 0x164614

void entry_164604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164604: 0x3c070000
    SET_GPR_U32(ctx, 7, ((uint32_t)0 << 16));
    // 0x164608: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x16460c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x164614);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 7), 14992));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_164614
// Address: 0x164614 - 0x16461c

void entry_164614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164614: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x16461c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_16461c
// Address: 0x16461c - 0x16465c

void entry_16461c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16461c) {
        switch (ctx->pc) {
            case 0x16463c: ctx->pc = 0; goto label_16463c;
            case 0x164650: ctx->pc = 0; goto label_164650;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16461c: 0x8ee30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 84)));
    // 0x164620: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x164624: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x164628: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x16462c: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x164630: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x164634: 0x1440ffd2
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x164580; return;
    }
label_16463c:
    // 0x16463c: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x164640: 0x8faa0040
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x164644: 0xa44a0006
    WRITE16(ADD32(GPR_U32(ctx, 2), 6), (uint16_t)GPR_U32(ctx, 10));
    // 0x164648: 0x8fab0054
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x16464c: 0xafab0040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 11));
label_164650:
    // 0x164650: 0x8fa50048
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x164654: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x16465c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_16465c
// Address: 0x16465c - 0x164674

void entry_16465c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16465c: 0x8fa20044
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x164660: 0x1040004a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16478C; return;
    }
    // 0x164668: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16466c: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x164674);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_164674
// Address: 0x164674 - 0x164698

void entry_164674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164674: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x164678: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x16467c: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x164680: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x164684: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x164688: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16468c: 0x27a9002c
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 44));
    // 0x164690: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x164698);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_164698
// Address: 0x164698 - 0x1646a8

void entry_164698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164698: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16469c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1646a0: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x1646a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_1646a8
// Address: 0x1646a8 - 0x1647c0

void entry_1646a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1646a8) {
        switch (ctx->pc) {
            case 0x1646b8: ctx->pc = 0; goto label_1646b8;
            case 0x1646e0: ctx->pc = 0; goto label_1646e0;
            case 0x164710: ctx->pc = 0; goto label_164710;
            case 0x164720: ctx->pc = 0; goto label_164720;
            case 0x164730: ctx->pc = 0; goto label_164730;
            case 0x164778: ctx->pc = 0; goto label_164778;
            case 0x16478c: ctx->pc = 0; goto label_16478c;
            case 0x164798: ctx->pc = 0; goto label_164798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1646a8: 0x1bc00038
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 30) <= 0) {
        goto label_16478c;
    }
    // 0x1646b0: 0x240c007f
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 127));
    // 0x1646b4: 0x0
    // NOP
label_1646b8:
    // 0x1646b8: 0x8fa40110
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1646bc: 0x61880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    // 0x1646c0: 0x833821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1646c4: 0x90e20003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 3)));
    // 0x1646c8: 0x3042007f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 127));
    // 0x1646cc: 0x144c0010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 6), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 12)) {
        goto label_164710;
    }
    // 0x1646d4: 0x26c50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 22), 4));
    // 0x1646d8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1646dc: 0x0
    // NOP
label_1646e0:
    // 0x1646e0: 0xa61821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x1646e4: 0x8fa4002c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x1646e8: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1646ec: 0x862021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x1646f0: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1646f4: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1646f8: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x1646fc: 0x28c30004
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), 4));
    // 0x164700: 0x1460fff7
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1646e0;
    }
    // 0x164708: 0x1000001b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_164778;
    }
label_164710:
    // 0x164710: 0x26ca0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 22), 4));
    // 0x164714: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164718: 0x240801fe
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 510));
    // 0x16471c: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_164720:
    // 0x164720: 0x1461821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 6)));
    // 0x164724: 0x90e20003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 3)));
    // 0x164728: 0x510b0001
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 11)) {
        runtime->handleBreak(rdram, ctx);
        goto label_164730;
    }
label_164730:
    // 0x164730: 0x90640000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x164734: 0x8fa3003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x164738: 0x3042007f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 127));
    // 0x16473c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x164740: 0x8fa5002c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x164744: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x164748: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x16474c: 0xa62821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x164750: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x164754: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x164758: 0x28c20004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 4));
    // 0x16475c: 0x832018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164760: 0x24840100
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 256));
    // 0x164764: 0x88001a
    { int32_t divisor = GPR_S32(ctx, 8); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 4) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 8) % divisor); } else { ctx->lo = (GPR_S32(ctx,4) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,8); } }
    // 0x164768: 0x2012
    SET_GPR_U32(ctx, 4, ctx->lo);
    // 0x16476c: 0x1440ffec
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_164720;
    }
    // 0x164774: 0x8fa2002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
label_164778:
    // 0x164778: 0x120302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x16477c: 0xde182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 30)));
    // 0x164780: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x164784: 0x1460ffcc
    WRITE32(ADD32(GPR_U32(ctx, 29), 44), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1646b8;
    }
label_16478c:
    // 0x16478c: 0x8ec20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 24)));
    // 0x164790: 0x1840001f
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x164810; return;
    }
label_164798:
    // 0x164798: 0x8ed0001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 22), 28)));
    // 0x16479c: 0x1110c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 3));
    // 0x1647a0: 0x8fa70040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1647a4: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1647a8: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1647ac: 0x27a80030
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1647b0: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1647b4: 0x27a90034
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 52));
    // 0x1647b8: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x1647c0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_1647c0
// Address: 0x1647c0 - 0x1647dc

void entry_1647c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1647c0: 0x8fa60034
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x1647c4: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1647c8: 0x8fa70030
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1647cc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1647d0: 0x8fa90050
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1647d4: 0xc05a53e
    SET_GPR_U32(ctx, 31, 0x1647dc);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI(rdram, ctx, runtime); return;
}


// Function: entry_1647dc
// Address: 0x1647dc - 0x16481c

void entry_1647dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1647dc) {
        switch (ctx->pc) {
            case 0x164810: ctx->pc = 0; goto label_164810;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1647dc: 0x8e82001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 28)));
    // 0x1647e0: 0x111840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 1));
    // 0x1647e4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1647e8: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1647ec: 0x8fa30040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1647f0: 0xa4430008
    WRITE16(ADD32(GPR_U32(ctx, 2), 8), (uint16_t)GPR_U32(ctx, 3));
    // 0x1647f4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1647f8: 0x8fa40040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1647fc: 0x8ec20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 24)));
    // 0x164800: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x164804: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x164808: 0x1440ffe3
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x164798; return;
    }
label_164810:
    // 0x164810: 0x8fa5004c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x164814: 0xc07b908
    SET_GPR_U32(ctx, 31, 0x16481c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    AddVifMscalf__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_16481c
// Address: 0x16481c - 0x164830

void entry_16481c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16481c: 0x8ee20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 84)));
    // 0x164820: 0x10400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16483C; return;
    }
    // 0x164828: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x164830);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_164830
// Address: 0x164830 - 0x164838

void entry_164830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164830: 0xc054b28
    SET_GPR_U32(ctx, 31, 0x164838);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    AddDmaRet__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_164838
// Address: 0x164838 - 0x164868

void entry_164838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164838) {
        switch (ctx->pc) {
            case 0x16483c: ctx->pc = 0; goto label_16483c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164838: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
label_16483c:
    // 0x16483c: 0x7bbe00e0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x164840: 0x7bb700d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x164844: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x164848: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x16484c: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x164850: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x164854: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x164858: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x16485c: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x164860: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BuildSubglobThreeWay__FP7GLOBSETP4GLOBiP7SUBGLOBP3SHDP7VECTORFT5P4RGBAP3UVFiP4VTXFP8SUBPOSEFT5T5PfP4VIFSP4SGVR
// Address: 0x164868 - 0x1648cc

void entry_1648cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1648cc: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1648d0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1648d4: 0xafd40018
    WRITE32(ADD32(GPR_U32(ctx, 30), 24), GPR_U32(ctx, 20));
    // 0x1648d8: 0x2405000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    // 0x1648dc: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1648e0: 0x2407000b
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 11));
    // 0x1648e4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1648e8: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x1648f0);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 19), 28));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_1648f0
// Address: 0x1648f0 - 0x164908

void entry_1648f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1648f0: 0x24020024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 36));
    // 0x1648f4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1648f8: 0xafa2004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 2));
    // 0x1648fc: 0x24060018
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 24));
    // 0x164900: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x164908);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_164908
// Address: 0x164908 - 0x1649c4

void entry_164908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164908) {
        switch (ctx->pc) {
            case 0x164928: ctx->pc = 0; goto label_164928;
            case 0x164978: ctx->pc = 0; goto label_164978;
            case 0x16497c: ctx->pc = 0; goto label_16497c;
            case 0x1649a0: ctx->pc = 0; goto label_1649a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164908: 0x8e64001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x16490c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x164910: 0x240300ff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 255));
    // 0x164914: 0x24057fa6
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32678));
    // 0x164918: 0xa4820010
    WRITE16(ADD32(GPR_U32(ctx, 4), 16), (uint16_t)GPR_U32(ctx, 2));
    // 0x16491c: 0x153080
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 21), 2));
    // 0x164920: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        runtime->handleBreak(rdram, ctx);
        goto label_164928;
    }
label_164928:
    // 0x164928: 0x8e620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x16492c: 0x8e64001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x164930: 0x451018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 5); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164934: 0x43001b
    { uint32_t divisor = GPR_U32(ctx, 3); if (divisor != 0) { ctx->lo = GPR_U32(ctx, 2) / divisor; ctx->hi = GPR_U32(ctx, 3) % divisor; } else { ctx->lo = 0xFFFFFFFF; ctx->hi = GPR_U32(ctx,2); } }
    // 0x164938: 0x1012
    SET_GPR_U32(ctx, 2, ctx->lo);
    // 0x16493c: 0xa4820012
    WRITE16(ADD32(GPR_U32(ctx, 4), 18), (uint16_t)GPR_U32(ctx, 2));
    // 0x164940: 0x8fa2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x164944: 0x8e63001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x164948: 0xa4620000
    WRITE16(ADD32(GPR_U32(ctx, 3), 0), (uint16_t)GPR_U32(ctx, 2));
    // 0x16494c: 0x24c60024
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 36));
    // 0x164950: 0xafa6004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 6));
    // 0x164954: 0x8e62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x164958: 0xa4460002
    WRITE16(ADD32(GPR_U32(ctx, 2), 2), (uint16_t)GPR_U32(ctx, 6));
    // 0x16495c: 0x8e630024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x164960: 0x54600005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 30), 40), GPR_U32(ctx, 20));
        goto label_164978;
    }
    // 0x164968: 0x8ee20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 64)));
    // 0x16496c: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 40)));
        goto label_16497c;
    }
    // 0x164974: 0xafd40028
    WRITE32(ADD32(GPR_U32(ctx, 30), 40), GPR_U32(ctx, 20));
label_164978:
    // 0x164978: 0x8fc20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 40)));
label_16497c:
    // 0x16497c: 0x10400008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967292));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1649a0;
    }
    // 0x164984: 0x26a20003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 3));
    // 0x164988: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16498c: 0x8fa3004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x164990: 0x551023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x164994: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x164998: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x16499c: 0xafa3004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 3));
label_1649a0:
    // 0x1649a0: 0x8fa7004c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x1649a4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1649a8: 0x8e62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x1649ac: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1649b0: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1649b4: 0xa447000e
    WRITE16(ADD32(GPR_U32(ctx, 2), 14), (uint16_t)GPR_U32(ctx, 7));
    // 0x1649b8: 0xf53821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 21)));
    // 0x1649bc: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x1649c4);
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 7));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_1649c4
// Address: 0x1649c4 - 0x1649e8

void entry_1649c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1649c4: 0x8e62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x1649c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1649cc: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1649d0: 0x27a90010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1649d4: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1649d8: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1649dc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1649e0: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x1649e8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 3));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_1649e8
// Address: 0x1649e8 - 0x1649f8

void entry_1649e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1649e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1649ec: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1649f0: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x1649f8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_1649f8
// Address: 0x1649f8 - 0x164a30

void entry_1649f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1649f8) {
        switch (ctx->pc) {
            case 0x164a08: ctx->pc = 0; goto label_164a08;
            case 0x164a1c: ctx->pc = 0; goto label_164a1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1649f8: 0x8fa90158
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 344)));
    // 0x1649fc: 0x8d220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x164a00: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 21));
        goto label_164a08;
    }
label_164a08:
    // 0x164a08: 0x8faa0158
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 344)));
    // 0x164a0c: 0x8d430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 4)));
    // 0x164a10: 0x10600002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_164a1c;
    }
    // 0x164a18: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_164a1c:
    // 0x164a1c: 0x8fc20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 84)));
    // 0x164a20: 0x10400007
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 40));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x164A40; return;
    }
    // 0x164a28: 0xc063570
    SET_GPR_U32(ctx, 31, 0x164a30);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 52));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_164a30
// Address: 0x164a30 - 0x164af4

void entry_164a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164a30) {
        switch (ctx->pc) {
            case 0x164a40: ctx->pc = 0; goto label_164a40;
            case 0x164a78: ctx->pc = 0; goto label_164a78;
            case 0x164ac0: ctx->pc = 0; goto label_164ac0;
            case 0x164ac8: ctx->pc = 0; goto label_164ac8;
            case 0x164ae8: ctx->pc = 0; goto label_164ae8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164a30: 0x8fa30010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x164a34: 0xae620020
    WRITE32(ADD32(GPR_U32(ctx, 19), 32), GPR_U32(ctx, 2));
    // 0x164a38: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
    // 0x164a3c: 0x27ab0028
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 40));
label_164a40:
    // 0x164a40: 0x27a20030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 48));
    // 0x164a44: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164a48: 0x26160048
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 16), 72));
    // 0x164a4c: 0x26140024
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 16), 36));
    // 0x164a50: 0xafab0050
    WRITE32(ADD32(GPR_U32(ctx, 29), 80), GPR_U32(ctx, 11));
    // 0x164a54: 0x1aa00024
    WRITE32(ADD32(GPR_U32(ctx, 29), 84), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 21) <= 0) {
        goto label_164ae8;
    }
    // 0x164a5c: 0x3c014700
    SET_GPR_U32(ctx, 1, ((uint32_t)18176 << 16));
    // 0x164a60: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x164a64: 0x2408000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 12));
    // 0x164a68: 0x3c0146e0
    SET_GPR_U32(ctx, 1, ((uint32_t)18144 << 16));
    // 0x164a6c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x164a70: 0x8fa50128
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    // 0x164a74: 0x0
    // NOP
label_164a78:
    // 0x164a78: 0xa0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x164a7c: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x164a80: 0x90e30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x164a84: 0x682018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 8); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164a88: 0x911821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 17)));
    // 0x164a8c: 0x68690007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x164a90: 0x6c690000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x164a94: 0x8c6a0008
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x164a98: 0xb0490007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x164a9c: 0xb4490000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x164aa0: 0xac4a0008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 10));
    // 0x164aa4: 0x90e40003
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 3)));
    // 0x164aa8: 0x421c2
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 4), 7));
    // 0x164aac: 0x10800004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_164ac0;
    }
    // 0x164ab4: 0xc7c00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 64)); ctx->f[0] = *(float*)&val; }
    // 0x164ab8: 0x10000003
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_164ac8;
    }
label_164ac0:
    // 0x164ac0: 0xc7c00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 64)); ctx->f[0] = *(float*)&val; }
    // 0x164ac4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
label_164ac8:
    // 0x164ac8: 0xe440000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x164acc: 0x8fa20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x164ad0: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x164ad4: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x164ad8: 0xd5182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 21)));
    // 0x164adc: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x164ae0: 0x1460ffe5
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_164a78;
    }
label_164ae8:
    // 0x164ae8: 0x8fa40044
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x164aec: 0xc058e4e
    SET_GPR_U32(ctx, 31, 0x164af4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    EnsureBuffer__FiP4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_164af4
// Address: 0x164af4 - 0x164b34

void entry_164af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164af4: 0x8e620024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x164af8: 0x1840004a
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_164c24(rdram, ctx, runtime); return;
    }
    // 0x164b00: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x164b04: 0x8e63001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x164b08: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x164b0c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164b10: 0xa4670004
    WRITE16(ADD32(GPR_U32(ctx, 3), 4), (uint16_t)GPR_U32(ctx, 7));
    // 0x164b14: 0x8e620024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x164b18: 0x8e63001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x164b1c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x164b20: 0xe23821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x164b24: 0xa4670006
    WRITE16(ADD32(GPR_U32(ctx, 3), 6), (uint16_t)GPR_U32(ctx, 7));
    // 0x164b28: 0xf53821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 21)));
    // 0x164b2c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x164b34);
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 7));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_164b34
// Address: 0x164b34 - 0x164b40

void entry_164b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164b34: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x164b38: 0xc07b930
    SET_GPR_U32(ctx, 31, 0x164b40);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddVifStrow__4VIFSP2QW(rdram, ctx, runtime); return;
}


// Function: entry_164b40
// Address: 0x164b40 - 0x164b60

void entry_164b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164b40: 0x8e620024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x164b44: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x164b48: 0x24632448
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 9288));
    // 0x164b4c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x164b50: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x164b54: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x164b58: 0xc07b94a
    SET_GPR_U32(ctx, 31, 0x164b60);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    AddVifStmask__4VIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_164b60
// Address: 0x164b60 - 0x164b94

void entry_164b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164b60: 0x8e630024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x164b64: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x164b68: 0x8e65001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x164b6c: 0x24422460
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 9312));
    // 0x164b70: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x164b74: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x164b78: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x164b7c: 0x94a70006
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 6)));
    // 0x164b80: 0x8c650000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x164b84: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x164b88: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164b8c: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x164b94);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 20));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_164b94
// Address: 0x164b94 - 0x164ba0

void entry_164b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164b94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x164b98: 0xc07b94a
    SET_GPR_U32(ctx, 31, 0x164ba0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifStmask__4VIFSUi(rdram, ctx, runtime); return;
}


// Function: entry_164ba0
// Address: 0x164ba0 - 0x164c24

void entry_164ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164ba0) {
        switch (ctx->pc) {
            case 0x164bb0: ctx->pc = 0; goto label_164bb0;
            case 0x164bc8: ctx->pc = 0; goto label_164bc8;
            case 0x164c04: ctx->pc = 0; goto label_164c04;
            case 0x164c14: ctx->pc = 0; goto label_164c14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164ba0: 0x1aa0001c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        goto label_164c14;
    }
    // 0x164ba8: 0x8fa90128
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    // 0x164bac: 0x0
    // NOP
label_164bb0:
    // 0x164bb0: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x164bb4: 0x8e640024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x164bb8: 0x24ca0001
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 6), 1));
    // 0x164bbc: 0x1223821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 2)));
    // 0x164bc0: 0x18800010
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_164c04;
    }
label_164bc8:
    // 0x164bc8: 0x90e20000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x164bcc: 0x8fa90148
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 328)));
    // 0x164bd0: 0x443018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164bd4: 0x8fa30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x164bd8: 0xc51021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 5)));
    // 0x164bdc: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x164be0: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x164be4: 0x491021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x164be8: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x164bec: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x164bf0: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x164bf4: 0x8e640024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x164bf8: 0xa4102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 4)));
    // 0x164bfc: 0x1440fff2
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_164bc8;
    }
label_164c04:
    // 0x164c04: 0x140302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x164c08: 0xd5102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 21)));
    // 0x164c0c: 0x1440ffe8
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_164bb0;
    }
label_164c14:
    // 0x164c14: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x164c18: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x164c1c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x164c24);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8200));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_164c24
// Address: 0x164c24 - 0x164c68

void entry_164c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164c24) {
        switch (ctx->pc) {
            case 0x164c50: ctx->pc = 0; goto label_164c50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164c24: 0x8ee20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 64)));
    // 0x164c28: 0x10400055
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x164D80; return;
    }
    // 0x164c30: 0x8e62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x164c34: 0xa44a0006
    WRITE16(ADD32(GPR_U32(ctx, 2), 6), (uint16_t)GPR_U32(ctx, 10));
    // 0x164c38: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x164c3c: 0x8ee20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 64)));
    // 0x164c40: 0x1425021
    SET_GPR_U32(ctx, 10, ADD32(GPR_U32(ctx, 10), GPR_U32(ctx, 2)));
    // 0x164c44: 0x1840004e
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 10));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x164D80; return;
    }
    // 0x164c4c: 0x0
    // NOP
label_164c50:
    // 0x164c50: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x164c54: 0x27a70018
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 24));
    // 0x164c58: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164c5c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x164c60: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x164c68);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 22));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_164c68
// Address: 0x164c68 - 0x164c88

void entry_164c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164c68: 0x8e62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x164c6c: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x164c70: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x164c74: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x164c78: 0x9447000e
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 14)));
    // 0x164c7c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164c80: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x164c88);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 28));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_164c88
// Address: 0x164c88 - 0x164d60

void entry_164c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164c88) {
        switch (ctx->pc) {
            case 0x164cb8: ctx->pc = 0; goto label_164cb8;
            case 0x164d50: ctx->pc = 0; goto label_164d50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164c88: 0x8fa20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x164c8c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164c90: 0x8fab0130
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x164c94: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x164c98: 0x4b1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 11)));
    // 0x164c9c: 0x1aa0002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    if (GPR_S32(ctx, 21) <= 0) {
        goto label_164d50;
    }
    // 0x164ca4: 0x8faa0128
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    // 0x164ca8: 0x40482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x164cac: 0x240b000c
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 12));
    // 0x164cb0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164cb4: 0x0
    // NOP
label_164cb8:
    // 0x164cb8: 0x8fa20138
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 312)));
    // 0x164cbc: 0x140382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x164cc0: 0x95240000
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x164cc4: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x164cc8: 0x90e30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x164ccc: 0x400013
    ctx->lo = GPR_U32(ctx, 2);
    // 0x164cd0: 0x708b2000
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 11); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164cd4: 0x8fa2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x164cd8: 0x24ea0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 7), 4));
    // 0x164cdc: 0x25290002
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 2));
    // 0x164ce0: 0x6b2818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164ce4: 0x1021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x164ce8: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x164cec: 0xb11821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 17)));
    // 0x164cf0: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x164cf4: 0xd5282a
    SET_GPR_U32(ctx, 5, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 21)));
    // 0x164cf8: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x164cfc: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x164d00: 0x90e30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x164d04: 0xc4810004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[1] = *(float*)&val; }
    // 0x164d08: 0x6b1018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164d0c: 0x511821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x164d10: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x164d14: 0x8fa2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x164d18: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x164d1c: 0x1021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x164d20: 0xe4410004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x164d24: 0x90e30000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x164d28: 0xc4810008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[1] = *(float*)&val; }
    // 0x164d2c: 0x6b1018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164d30: 0x511821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x164d34: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x164d38: 0x8fa2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x164d3c: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x164d40: 0x1021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x164d44: 0x2508000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 12));
    // 0x164d48: 0x14a0ffdb
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_164cb8;
    }
label_164d50:
    // 0x164d50: 0x3c030000
    SET_GPR_U32(ctx, 3, ((uint32_t)0 << 16));
    // 0x164d54: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x164d58: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x164d60);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 9144));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_164d60
// Address: 0x164d60 - 0x164d68

void entry_164d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164d60: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x164d68);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_164d68
// Address: 0x164d68 - 0x164d90

void entry_164d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164d68) {
        switch (ctx->pc) {
            case 0x164d80: ctx->pc = 0; goto label_164d80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164d68: 0x8fa20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x164d6c: 0x8ee30040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 64)));
    // 0x164d70: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x164d74: 0x43182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x164d78: 0x1460ffb5
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x164C50; return;
    }
label_164d80:
    // 0x164d80: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x164d84: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x164d88: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x164d90);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_164d90
// Address: 0x164d90 - 0x164dd8

void entry_164d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164d90: 0x8fc20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 40)));
    // 0x164d94: 0x50400012
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
        ctx->pc = 0x164DE0; return;
    }
    // 0x164d9c: 0x8e620024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x164da0: 0x5440000f
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
        ctx->pc = 0x164DE0; return;
    }
    // 0x164da8: 0x8ee20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 64)));
    // 0x164dac: 0x1440000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x164DE0; return;
    }
    // 0x164db4: 0x26a30003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 21), 3));
    // 0x164db8: 0x2406fffc
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967292));
    // 0x164dbc: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x164dc0: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x164dc4: 0x663024
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x164dc8: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x164dcc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164dd0: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x164dd8);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 32));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_164dd8
// Address: 0x164dd8 - 0x164dfc

void entry_164dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164dd8) {
        switch (ctx->pc) {
            case 0x164de0: ctx->pc = 0; goto label_164de0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164dd8: 0x10000009
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x164E00; return;
    }
label_164de0:
    // 0x164de0: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x164de4: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x164de8: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x164dec: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x164df0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164df4: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x164dfc);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 36));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_164dfc
// Address: 0x164dfc - 0x164e24

void entry_164dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164dfc) {
        switch (ctx->pc) {
            case 0x164e00: ctx->pc = 0; goto label_164e00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164dfc: 0xafa00020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 0));
label_164e00:
    // 0x164e00: 0x8e62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x164e04: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x164e08: 0x8fa90050
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x164e0c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x164e10: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x164e14: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x164e18: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164e1c: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x164e24);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_164e24
// Address: 0x164e24 - 0x164e34

void entry_164e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164e24: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x164e28: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x164e2c: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x164e34);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_164e34
// Address: 0x164e34 - 0x164e4c

void entry_164e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x164e34: 0x8e620024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 36)));
    // 0x164e38: 0x18400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_164e4c(rdram, ctx, runtime); return;
    }
    // 0x164e40: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x164e44: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x164e4c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8328));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_164e4c
// Address: 0x164e4c - 0x164e70

void entry_164e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164e4c) {
        switch (ctx->pc) {
            case 0x164e60: ctx->pc = 0; goto label_164e60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164e4c: 0x8ee20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 64)));
    // 0x164e50: 0x5840004e
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
        ctx->pc = 0x164F8C; return;
    }
    // 0x164e58: 0x18400047
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x164F78; return;
    }
label_164e60:
    // 0x164e60: 0x5a000004
    if (GPR_S32(ctx, 16) <= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
        ctx->pc = 0x164E74; return;
    }
    // 0x164e68: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x164e70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_164e70
// Address: 0x164e70 - 0x164e94

void entry_164e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164e70) {
        switch (ctx->pc) {
            case 0x164e74: ctx->pc = 0; goto label_164e74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164e70: 0x8e62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
label_164e74:
    // 0x164e74: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x164e78: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x164e7c: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x164e80: 0x9447000e
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 14)));
    // 0x164e84: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164e88: 0x27a9002c
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 44));
    // 0x164e8c: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x164e94);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_164e94
// Address: 0x164e94 - 0x164f64

void entry_164e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164e94) {
        switch (ctx->pc) {
            case 0x164ec0: ctx->pc = 0; goto label_164ec0;
            case 0x164f58: ctx->pc = 0; goto label_164f58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164e94: 0x8fa40130
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x164e98: 0x1010c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 3));
    // 0x164e9c: 0x3c0c0000
    SET_GPR_U32(ctx, 12, ((uint32_t)0 << 16));
    // 0x164ea0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164ea4: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x164ea8: 0x1aa0002b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    if (GPR_S32(ctx, 21) <= 0) {
        goto label_164f58;
    }
    // 0x164eb0: 0x8faa0128
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    // 0x164eb4: 0x40482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x164eb8: 0x240b000c
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 0), 12));
    // 0x164ebc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_164ec0:
    // 0x164ec0: 0x8fa20140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x164ec4: 0x140382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x164ec8: 0x95240000
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x164ecc: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x164ed0: 0x90e30001
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 1)));
    // 0x164ed4: 0x400013
    ctx->lo = GPR_U32(ctx, 2);
    // 0x164ed8: 0x708b2000
    { int64_t acc = ((int64_t)ctx->hi << 32) | ctx->lo; int64_t prod = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 11); int64_t result = acc + prod; ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164edc: 0x8fa2002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x164ee0: 0x24ea0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 7), 4));
    // 0x164ee4: 0x25290002
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 2));
    // 0x164ee8: 0x6b2818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164eec: 0x1021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x164ef0: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x164ef4: 0xb21821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 18)));
    // 0x164ef8: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x164efc: 0xd5282a
    SET_GPR_U32(ctx, 5, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 21)));
    // 0x164f00: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x164f04: 0xe4400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x164f08: 0x90e30001
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 1)));
    // 0x164f0c: 0xc4810004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[1] = *(float*)&val; }
    // 0x164f10: 0x6b1018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164f14: 0x521821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x164f18: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x164f1c: 0x8fa2002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x164f20: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x164f24: 0x1021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x164f28: 0xe4410004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x164f2c: 0x90e30001
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 1)));
    // 0x164f30: 0xc4810008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[1] = *(float*)&val; }
    // 0x164f34: 0x6b1018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 11); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x164f38: 0x521821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x164f3c: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x164f40: 0x8fa2002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 44)));
    // 0x164f44: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x164f48: 0x1021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x164f4c: 0x2508000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 12));
    // 0x164f50: 0x14a0ffdb
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_164ec0;
    }
label_164f58:
    // 0x164f58: 0x258523d8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 12), 9176));
    // 0x164f5c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x164f64);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_164f64
// Address: 0x164f64 - 0x164f88

void entry_164f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164f64) {
        switch (ctx->pc) {
            case 0x164f78: ctx->pc = 0; goto label_164f78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164f64: 0x220802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x164f68: 0x8ee20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 64)));
    // 0x164f6c: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x164f70: 0x1440ffbb
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x164E60; return;
    }
label_164f78:
    // 0x164f78: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x164f7c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x164f80: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x164f88);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 9200));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_164f88
// Address: 0x164f88 - 0x164f98

void entry_164f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164f88) {
        switch (ctx->pc) {
            case 0x164f8c: ctx->pc = 0; goto label_164f8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164f88: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
label_164f8c:
    // 0x164f8c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x164f90: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x164f98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 648));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_164f98
// Address: 0x164f98 - 0x165200

void entry_164f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x164f98) {
        switch (ctx->pc) {
            case 0x164fc0: ctx->pc = 0; goto label_164fc0;
            case 0x164ff0: ctx->pc = 0; goto label_164ff0;
            case 0x165020: ctx->pc = 0; goto label_165020;
            case 0x165038: ctx->pc = 0; goto label_165038;
            case 0x165048: ctx->pc = 0; goto label_165048;
            case 0x165090: ctx->pc = 0; goto label_165090;
            case 0x1650b4: ctx->pc = 0; goto label_1650b4;
            case 0x1650d0: ctx->pc = 0; goto label_1650d0;
            case 0x16510c: ctx->pc = 0; goto label_16510c;
            case 0x165120: ctx->pc = 0; goto label_165120;
            case 0x165140: ctx->pc = 0; goto label_165140;
            case 0x165158: ctx->pc = 0; goto label_165158;
            case 0x1651bc: ctx->pc = 0; goto label_1651bc;
            case 0x1651d8: ctx->pc = 0; goto label_1651d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x164f98: 0x1aa00061
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        goto label_165120;
    }
    // 0x164fa0: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x164fa4: 0x240e007f
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 0), 127));
    // 0x164fa8: 0x3c013eaa
    SET_GPR_U32(ctx, 1, ((uint32_t)16042 << 16));
    // 0x164fac: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x164fb0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x164fb4: 0x240d00ff
    SET_GPR_S32(ctx, 13, ADD32(GPR_U32(ctx, 0), 255));
    // 0x164fb8: 0x240c000c
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 0), 12));
    // 0x164fbc: 0x0
    // NOP
label_164fc0:
    // 0x164fc0: 0x8fa40128
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    // 0x164fc4: 0x61880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    // 0x164fc8: 0x833821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x164fcc: 0x90e20003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 3)));
    // 0x164fd0: 0x3042007f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 127));
    // 0x164fd4: 0x144e0012
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 14)) {
        goto label_165020;
    }
    // 0x164fdc: 0x8fa90048
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x164fe0: 0x24ca0001
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 6), 1));
    // 0x164fe4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x164fe8: 0x25250004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 9), 4));
    // 0x164fec: 0x0
    // NOP
label_164ff0:
    // 0x164ff0: 0xa61821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x164ff4: 0x8fa40028
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x164ff8: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x164ffc: 0x862021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x165000: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x165004: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x165008: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x16500c: 0x28c30004
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), 4));
    // 0x165010: 0x1460fff7
    WRITE8(ADD32(GPR_U32(ctx, 4), 0), (uint8_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_164ff0;
    }
    // 0x165018: 0x1000001d
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_165090;
    }
label_165020:
    // 0x165020: 0x24ca0001
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 6), 1));
    // 0x165024: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x165028: 0x240801fe
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 510));
    // 0x16502c: 0x25690004
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 11), 4));
    // 0x165030: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x165034: 0x0
    // NOP
label_165038:
    // 0x165038: 0x1261821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 6)));
    // 0x16503c: 0x90e20003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 3)));
    // 0x165040: 0x510b0001
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 11)) {
        runtime->handleBreak(rdram, ctx);
        goto label_165048;
    }
label_165048:
    // 0x165048: 0x90640000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16504c: 0x8fa30110
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x165050: 0x3042007f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 127));
    // 0x165054: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x165058: 0x8fa50028
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x16505c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x165060: 0x461021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x165064: 0xa62821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x165068: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16506c: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x165070: 0x28c20004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 4));
    // 0x165074: 0x832018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x165078: 0x24840100
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 256));
    // 0x16507c: 0x88001a
    { int32_t divisor = GPR_S32(ctx, 8); if (divisor != 0) { ctx->lo = (uint32_t)(GPR_S32(ctx, 4) / divisor); ctx->hi = (uint32_t)(GPR_S32(ctx, 8) % divisor); } else { ctx->lo = (GPR_S32(ctx,4) < 0) ? 1 : -1; ctx->hi = GPR_S32(ctx,8); } }
    // 0x165080: 0x2012
    SET_GPR_U32(ctx, 4, ctx->lo);
    // 0x165084: 0x1440ffec
    WRITE8(ADD32(GPR_U32(ctx, 5), 0), (uint8_t)GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_165038;
    }
    // 0x16508c: 0x8fa30024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 36)));
label_165090:
    // 0x165090: 0x1060001e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_16510c;
    }
    // 0x165098: 0x90e20001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 7), 1)));
    // 0x16509c: 0x144d0005
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 12); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 13)) {
        goto label_1650b4;
    }
    // 0x1650a4: 0xe4610000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1650a8: 0xe4610008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 8), *(uint32_t*)&val); }
    // 0x1650ac: 0x10000008
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1650d0;
    }
label_1650b4:
    // 0x1650b4: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1650b8: 0x68450007
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1650bc: 0x6c450000
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x1650c0: 0x8c460008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1650c4: 0xb0650007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1650c8: 0xb4650000
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x1650cc: 0xac660008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 6));
label_1650d0:
    // 0x1650d0: 0x8fa30028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 40)));
    // 0x1650d4: 0x8fa60024
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x1650d8: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1650dc: 0x90640001
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 1)));
    // 0x1650e0: 0x90650002
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 2)));
    // 0x1650e4: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1650e8: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1650ec: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1650f0: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x1650f4: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1650f8: 0xe4c0000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 6), 12), *(uint32_t*)&val); }
    // 0x1650fc: 0x8fa20024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 36)));
    // 0x165100: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x165104: 0xafa20024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 2));
    // 0x165108: 0x8fa20028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 40)));
label_16510c:
    // 0x16510c: 0x140302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x165110: 0xd5182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 21)));
    // 0x165114: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x165118: 0x1460ffa9
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_164fc0;
    }
label_165120:
    // 0x165120: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x165124: 0x1040003d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16521C; return;
    }
    // 0x16512c: 0x1aa0003b
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        ctx->pc = 0x16521C; return;
    }
    // 0x165134: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x165138: 0x2410000c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16513c: 0x0
    // NOP
label_165140:
    // 0x165140: 0x8faa0128
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    // 0x165144: 0x61080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 2));
    // 0x165148: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16514c: 0x24d10004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 6), 4));
    // 0x165150: 0x4a2821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 10)));
    // 0x165154: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_165158:
    // 0x165158: 0xc81021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 8)));
    // 0x16515c: 0x55102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 21)));
    // 0x165160: 0x10400016
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1651bc;
    }
    // 0x165168: 0x90a20001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 1)));
    // 0x16516c: 0x502018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 16); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x165170: 0x671821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x165174: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x165178: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x16517c: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x165180: 0x90a20001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 1)));
    // 0x165184: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x165188: 0x502018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 16); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x16518c: 0x671821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x165190: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x165194: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x165198: 0xe4600010
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 16), *(uint32_t*)&val); }
    // 0x16519c: 0x90a20001
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 1)));
    // 0x1651a0: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1651a4: 0x502018
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 16); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x1651a8: 0x671821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x1651ac: 0x921021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 18)));
    // 0x1651b0: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1651b4: 0x10000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 32), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1651d8;
    }
label_1651bc:
    // 0x1651bc: 0x8fa20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1651c0: 0x471821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1651c4: 0xe4740020
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 3), 32), *(uint32_t*)&val); }
    // 0x1651c8: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1651cc: 0x60102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x1651d0: 0xe4940010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 4), 16), *(uint32_t*)&val); }
    // 0x1651d4: 0xe4540000
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
label_1651d8:
    // 0x1651d8: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x1651dc: 0x24e70004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    // 0x1651e0: 0x29020004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), 4));
    // 0x1651e4: 0x1440ffdc
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_165158;
    }
    // 0x1651ec: 0x8fa40020
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1651f0: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x1651f4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1651f8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x165200);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 48));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_165200
// Address: 0x165200 - 0x165228

void entry_165200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165200) {
        switch (ctx->pc) {
            case 0x16521c: ctx->pc = 0; goto label_16521c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165200: 0x8fa30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x165204: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x165208: 0xd5102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 21)));
    // 0x16520c: 0x24630040
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 64));
    // 0x165210: 0x1440ffcb
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x165140; return;
    }
    // 0x165218: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_16521c:
    // 0x16521c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x165220: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x165228);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_165228
// Address: 0x165228 - 0x165248

void entry_165228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165228: 0x8e62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x16522c: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x165230: 0x8fa90054
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 84)));
    // 0x165234: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x165238: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16523c: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x165240: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x165248);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_165248
// Address: 0x165248 - 0x165258

void entry_165248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165248: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16524c: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x165250: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x165258);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_165258
// Address: 0x165258 - 0x165310

void entry_165258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165258) {
        switch (ctx->pc) {
            case 0x16526c: ctx->pc = 0; goto label_16526c;
            case 0x165288: ctx->pc = 0; goto label_165288;
            case 0x1652a4: ctx->pc = 0; goto label_1652a4;
            case 0x1652d0: ctx->pc = 0; goto label_1652d0;
            case 0x1652f4: ctx->pc = 0; goto label_1652f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165258: 0x8fa50158
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 344)));
    // 0x16525c: 0x8ca30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x165260: 0x10600002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_16526c;
    }
    // 0x165268: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_16526c:
    // 0x16526c: 0x1aa00021
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        goto label_1652f4;
    }
    // 0x165274: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x165278: 0x240700ff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 255));
    // 0x16527c: 0x8fa50128
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 296)));
    // 0x165280: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x165284: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
label_165288:
    // 0x165288: 0x90a20002
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 2)));
    // 0x16528c: 0x14470005
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 280)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 7)) {
        goto label_1652a4;
    }
    // 0x165294: 0x8fa20030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x165298: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x16529c: 0x1000000c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1652d0;
    }
label_1652a4:
    // 0x1652a4: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1652a8: 0x8fa30030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1652ac: 0x491021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x1652b0: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1652b4: 0xe4600000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x1652b8: 0x90a20002
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 5), 2)));
    // 0x1652bc: 0x8fa30030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1652c0: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x1652c4: 0x491021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x1652c8: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1652cc: 0xe4600004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 4), *(uint32_t*)&val); }
label_1652d0:
    // 0x1652d0: 0x8fa20030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1652d4: 0x24c60001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1652d8: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1652dc: 0xd5202a
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 21)));
    // 0x1652e0: 0xe4420008
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    // 0x1652e4: 0x8fa30030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1652e8: 0x2463000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 12));
    // 0x1652ec: 0x1480ffe6
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_165288;
    }
label_1652f4:
    // 0x1652f4: 0x8fc40038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 30), 56)));
    // 0x1652f8: 0x10800006
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165314; return;
    }
    // 0x165300: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x165304: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x165308: 0x40f809
    SET_GPR_U32(ctx, 31, 0x165310);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_165310
// Address: 0x165310 - 0x16533c

void entry_165310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165310) {
        switch (ctx->pc) {
            case 0x165314: ctx->pc = 0; goto label_165314;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165310: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_165314:
    // 0x165314: 0x56e0000d
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 0)));
        ctx->pc = 0x16534C; return;
    }
    // 0x16531c: 0x8faa0048
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x165320: 0x8d440024
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 10), 36)));
    // 0x165324: 0x10800006
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165340; return;
    }
    // 0x16532c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x165330: 0x8c620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x165334: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16533c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16533c
// Address: 0x16533c - 0x165370

void entry_16533c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16533c) {
        switch (ctx->pc) {
            case 0x165340: ctx->pc = 0; goto label_165340;
            case 0x16534c: ctx->pc = 0; goto label_16534c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16533c: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_165340:
    // 0x165340: 0x52e00014
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 19), 32)));
        ctx->pc = 0x165394; return;
    }
    // 0x165348: 0x8ee20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 0)));
label_16534c:
    // 0x16534c: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x165350: 0x1040000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_165390(rdram, ctx, runtime); return;
    }
    // 0x165358: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x16535c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x165360: 0x24070016
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 22));
    // 0x165364: 0x27a80034
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 52));
    // 0x165368: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x165370);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 56));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_165370
// Address: 0x165370 - 0x165380

void entry_165370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165370: 0x8fa50034
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x165374: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x165378: 0xc05a582
    SET_GPR_U32(ctx, 31, 0x165380);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 56)));
    ReferenceUVAnimation__FP2QWiP3SAI(rdram, ctx, runtime); return;
}


// Function: entry_165380
// Address: 0x165380 - 0x165390

void entry_165380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165380: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x165384: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x165388: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x165390);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 10176));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_165390
// Address: 0x165390 - 0x1653dc

void entry_165390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165390) {
        switch (ctx->pc) {
            case 0x165394: ctx->pc = 0; goto label_165394;
            case 0x1653c0: ctx->pc = 0; goto label_1653c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165390: 0x8e690020
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 19), 32)));
label_165394:
    // 0x165394: 0x1120003e
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    if (GPR_U32(ctx, 9) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165490; return;
    }
    // 0x16539c: 0x8fc30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 84)));
    // 0x1653a0: 0x1755821
    SET_GPR_U32(ctx, 11, ADD32(GPR_U32(ctx, 11), GPR_U32(ctx, 21)));
    // 0x1653a4: 0xafab0058
    WRITE32(ADD32(GPR_U32(ctx, 29), 88), GPR_U32(ctx, 11));
    // 0x1653a8: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1653ac: 0x18400033
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x16547C; return;
    }
    // 0x1653b4: 0x25320024
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 9), 36));
    // 0x1653b8: 0x25310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 9), 4));
    // 0x1653bc: 0x25300014
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 9), 20));
label_1653c0:
    // 0x1653c0: 0x8fa7004c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x1653c4: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1653c8: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1653cc: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1653d0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1653d4: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x1653dc);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_1653dc
// Address: 0x1653dc - 0x165404

void entry_1653dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1653dc: 0x8fc20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 84)));
    // 0x1653e0: 0x8c430018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x1653e4: 0x1060000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165420; return;
    }
    // 0x1653ec: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1653f0: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1653f4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1653f8: 0x24080016
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 22));
    // 0x1653fc: 0xc07b9c6
    SET_GPR_U32(ctx, 31, 0x165404);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifUnpackRefs__4VIFS3UPKiPviPPPv(rdram, ctx, runtime); return;
}


// Function: entry_165404
// Address: 0x165404 - 0x165414

void entry_165404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165404: 0x3c020000
    SET_GPR_U32(ctx, 2, ((uint32_t)0 << 16));
    // 0x165408: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x16540c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x165414);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 14976));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_165414
// Address: 0x165414 - 0x16541c

void entry_165414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165414: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x16541c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_16541c
// Address: 0x16541c - 0x165444

void entry_16541c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16541c) {
        switch (ctx->pc) {
            case 0x165420: ctx->pc = 0; goto label_165420;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16541c: 0x8fc20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 84)));
label_165420:
    // 0x165420: 0x8c430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    // 0x165424: 0x1060000d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_16545c(rdram, ctx, runtime); return;
    }
    // 0x16542c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x165430: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x165434: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x165438: 0x24080016
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 22));
    // 0x16543c: 0xc07b9c6
    SET_GPR_U32(ctx, 31, 0x165444);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AddVifUnpackRefs__4VIFS3UPKiPviPPPv(rdram, ctx, runtime); return;
}


// Function: entry_165444
// Address: 0x165444 - 0x165454

void entry_165444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165444: 0x3c030000
    SET_GPR_U32(ctx, 3, ((uint32_t)0 << 16));
    // 0x165448: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x16544c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x165454);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 3), 15008));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_165454
// Address: 0x165454 - 0x16545c

void entry_165454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165454: 0xc07b920
    SET_GPR_U32(ctx, 31, 0x16545c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    AddVifFlushe__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_16545c
// Address: 0x16545c - 0x1654a4

void entry_16545c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16545c) {
        switch (ctx->pc) {
            case 0x16547c: ctx->pc = 0; goto label_16547c;
            case 0x165490: ctx->pc = 0; goto label_165490;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16545c: 0x8fc30054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 30), 84)));
    // 0x165460: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x165464: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x165468: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x16546c: 0x8c620010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x165470: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x165474: 0x1440ffd2
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1653C0; return;
    }
label_16547c:
    // 0x16547c: 0x8e62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x165480: 0x8fa4004c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x165484: 0xa4440006
    WRITE16(ADD32(GPR_U32(ctx, 2), 6), (uint16_t)GPR_U32(ctx, 4));
    // 0x165488: 0x8fa50058
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 88)));
    // 0x16548c: 0xafa5004c
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 5));
label_165490:
    // 0x165490: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x165494: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x165498: 0x24a51ab0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 6832));
    // 0x16549c: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x1654a4);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_1654a4
// Address: 0x1654a4 - 0x1654e8

void entry_1654a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1654a4) {
        switch (ctx->pc) {
            case 0x1654b8: ctx->pc = 0; goto label_1654b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1654a4: 0x8fa60048
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x1654a8: 0x8cc20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x1654ac: 0x18400022
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x165538; return;
    }
    // 0x1654b4: 0x0
    // NOP
label_1654b8:
    // 0x1654b8: 0x8fa70048
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x1654bc: 0x1110c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 3));
    // 0x1654c0: 0x27a8003c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 60));
    // 0x1654c4: 0x27a90040
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1654c8: 0x8cf0001c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 7), 28)));
    // 0x1654cc: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1654d0: 0x8fa7004c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x1654d4: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1654d8: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x1654dc: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1654e0: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x1654e8);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_1654e8
// Address: 0x1654e8 - 0x165504

void entry_1654e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1654e8: 0x8fa60040
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1654ec: 0x2e0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1654f0: 0x8fa40048
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x1654f4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1654f8: 0x8fa7003c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 60)));
    // 0x1654fc: 0xc05a53e
    SET_GPR_U32(ctx, 31, 0x165504);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI(rdram, ctx, runtime); return;
}


// Function: entry_165504
// Address: 0x165504 - 0x16554c

void entry_165504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165504) {
        switch (ctx->pc) {
            case 0x165538: ctx->pc = 0; goto label_165538;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165504: 0x8e62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 28)));
    // 0x165508: 0x121840
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 1));
    // 0x16550c: 0x8fa9004c
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x165510: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x165514: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x165518: 0xa4490008
    WRITE16(ADD32(GPR_U32(ctx, 2), 8), (uint16_t)GPR_U32(ctx, 9));
    // 0x16551c: 0x8faa0048
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x165520: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x165524: 0x8d420018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 10), 24)));
    // 0x165528: 0x1234821
    SET_GPR_U32(ctx, 9, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 3)));
    // 0x16552c: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x165530: 0x1440ffe1
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 9));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1654B8; return;
    }
label_165538:
    // 0x165538: 0x8fc20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 84)));
    // 0x16553c: 0x10400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165558; return;
    }
    // 0x165544: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x16554c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_16554c
// Address: 0x16554c - 0x165554

void entry_16554c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16554c: 0xc054b28
    SET_GPR_U32(ctx, 31, 0x165554);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    AddDmaRet__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_165554
// Address: 0x165554 - 0x165588

void entry_165554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165554) {
        switch (ctx->pc) {
            case 0x165558: ctx->pc = 0; goto label_165558;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165554: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
label_165558:
    // 0x165558: 0x7bbe00e0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x16555c: 0x7bb700d0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x165560: 0x7bb600c0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x165564: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x165568: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x16556c: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x165570: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x165574: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x165578: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16557c: 0xc7b40100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[20] = *(float*)&val; }
    // 0x165580: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BuildSubglobLighting__FP4GLOBP7SUBGLOBP8SUBGLOBI
// Address: 0x165588 - 0x1655c4

void entry_1655c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1655c4: 0x8e45001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x1655c8: 0x2407ffff
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1655cc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1655d0: 0x2406001a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 26));
    // 0x1655d4: 0x94a30000
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1655d8: 0x94a20002
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 2)));
    // 0x1655dc: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1655e0: 0xe2182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 2)));
    // 0x1655e4: 0x24500003
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 3));
    // 0x1655e8: 0x43800b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 2));
    // 0x1655ec: 0x108083
    SET_GPR_S32(ctx, 16, SRA32(GPR_S32(ctx, 16), 2));
    // 0x1655f0: 0x26020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 7));
    // 0x1655f4: 0x2605000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 10));
    // 0x1655f8: 0xe2382a
    SET_GPR_U32(ctx, 7, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 2)));
    // 0x1655fc: 0x47280b
    if (GPR_U32(ctx, 7) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 2));
    // 0x165600: 0xc054a4e
    SET_GPR_U32(ctx, 31, 0x165608);
    SET_GPR_S32(ctx, 5, SRA32(GPR_S32(ctx, 5), 2));
    AllocSw__4DMASii(rdram, ctx, runtime); return;
}


// Function: entry_165608
// Address: 0x165608 - 0x165618

void entry_165608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165608: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16560c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x165610: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x165618);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_165618
// Address: 0x165618 - 0x16563c

void entry_165618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165618: 0x8e42001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x16561c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x165620: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x165624: 0x26290008
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 8));
    // 0x165628: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16562c: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x165630: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x165634: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x16563c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_16563c
// Address: 0x16563c - 0x16564c

void entry_16563c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16563c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x165640: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x165644: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x16564c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_16564c
// Address: 0x16564c - 0x16565c

void entry_16564c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16564c: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x165650: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x165654: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x16565c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 16));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_16565c
// Address: 0x16565c - 0x16566c

void entry_16565c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16565c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x165660: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x165664: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x16566c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 4));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_16566c
// Address: 0x16566c - 0x165688

void entry_16566c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16566c: 0x26050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 4));
    // 0x165670: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x165674: 0x517c2
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 5), 31));
    // 0x165678: 0x2406001a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 26));
    // 0x16567c: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x165680: 0xc054a4e
    SET_GPR_U32(ctx, 31, 0x165688);
    SET_GPR_S32(ctx, 5, SRA32(GPR_S32(ctx, 5), 1));
    AllocSw__4DMASii(rdram, ctx, runtime); return;
}


// Function: entry_165688
// Address: 0x165688 - 0x165698

void entry_165688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165688: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16568c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x165690: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x165698);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_165698
// Address: 0x165698 - 0x1656bc

void entry_165698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165698: 0x8e42001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x16569c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1656a0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1656a4: 0x26290014
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 20));
    // 0x1656a8: 0x94470000
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1656ac: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1656b0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1656b4: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x1656bc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 2));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_1656bc
// Address: 0x1656bc - 0x1656cc

void entry_1656bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1656bc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1656c0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1656c4: 0xc07b926
    SET_GPR_U32(ctx, 31, 0x1656cc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddVifStcycl__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_1656cc
// Address: 0x1656cc - 0x1656ec

void entry_1656cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1656cc: 0x8e42001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 28)));
    // 0x1656d0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1656d4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1656d8: 0x2405000e
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1656dc: 0x94470002
    SET_GPR_U32(ctx, 7, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 2)));
    // 0x1656e0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1656e4: 0xc07b972
    SET_GPR_U32(ctx, 31, 0x1656ec);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UnpackHelper__4VIFS3UPKiiPiPPUi(rdram, ctx, runtime); return;
}


// Function: entry_1656ec
// Address: 0x1656ec - 0x1656fc

void entry_1656ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1656ec: 0x3c050000
    SET_GPR_U32(ctx, 5, ((uint32_t)0 << 16));
    // 0x1656f0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1656f4: 0xc07b8fc
    SET_GPR_U32(ctx, 31, 0x1656fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 240));
    AddVifMscal__4VIFSPv(rdram, ctx, runtime); return;
}


// Function: entry_1656fc
// Address: 0x1656fc - 0x16570c

void entry_1656fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1656fc: 0x26260010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 16));
    // 0x165700: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x165704: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x16570c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 12));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_16570c
// Address: 0x16570c - 0x165728

void entry_16570c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16570c) {
        switch (ctx->pc) {
            case 0x165710: ctx->pc = 0; goto label_165710;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16570c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_165710:
    // 0x165710: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x165714: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x165718: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16571c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x165724: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x165728; return;
}


// Function: PostGlobsetLoad__FP7GLOBSETP3ALO
// Address: 0x165728 - 0x16578c

void entry_16578c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16578c) {
        switch (ctx->pc) {
            case 0x165790: ctx->pc = 0; goto label_165790;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16578c: 0x8e260014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_165790:
    // 0x165790: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x165794: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x165798: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16579c: 0xd53021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 21)));
    // 0x1657a0: 0xc0598aa
    SET_GPR_U32(ctx, 31, 0x1657a8);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    PredrawGlob__FP7GLOBSETP4GLOBP5GLOBIP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1657a8
// Address: 0x1657a8 - 0x1657e0

void entry_1657a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1657a8) {
        switch (ctx->pc) {
            case 0x1657bc: ctx->pc = 0; goto label_1657bc;
            case 0x1657d0: ctx->pc = 0; goto label_1657d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1657a8: 0x26b50028
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 40));
    // 0x1657ac: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1657b0: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1657b4: 0x1440ffec
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 112));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x165768; return;
    }
label_1657bc:
    // 0x1657bc: 0x8e30004c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x1657c0: 0x12000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165804; return;
    }
    // 0x1657c8: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1657cc: 0x0
    // NOP
label_1657d0:
    // 0x1657d0: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x1657d4: 0x8e060008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1657d8: 0xc056906
    SET_GPR_U32(ctx, 31, 0x1657e0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1657e0
// Address: 0x1657e0 - 0x1657f4

void entry_1657e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1657e0: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1657f4(rdram, ctx, runtime); return;
    }
    // 0x1657e8: 0x8e060004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1657ec: 0xc07c9e6
    SET_GPR_U32(ctx, 31, 0x1657f4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ApplyWrGlob__FP2WRP3ALOP4GLOB(rdram, ctx, runtime); return;
}


// Function: entry_1657f4
// Address: 0x1657f4 - 0x165828

void entry_1657f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1657f4) {
        switch (ctx->pc) {
            case 0x165804: ctx->pc = 0; goto label_165804;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1657f4: 0x8e100080
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x1657f8: 0x5600fff5
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
        ctx->pc = 0x1657D0; return;
    }
    // 0x165800: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_165804:
    // 0x165804: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x165808: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16580c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x165810: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x165814: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x165818: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16581c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x165824: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x165828; return;
}


// Function: BindGlobset__FP7GLOBSETP3ALO
// Address: 0x165828 - 0x16588c

void entry_16588c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16588c: 0x10400016
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1658E8; return;
    }
    // 0x165894: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x165898: 0x26440140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 320));
    // 0x16589c: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x1658a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 272));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1658a4
// Address: 0x1658a4 - 0x1658b8

void entry_1658a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1658a4: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1658a8: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1658ac: 0x24850110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 272));
    // 0x1658b0: 0xc0622d2
    SET_GPR_U32(ctx, 31, 0x1658b8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 320));
    LoadMatrixFromPosRotInverse__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_1658b8
// Address: 0x1658b8 - 0x1658c8

void entry_1658b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1658b8: 0x27a40080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1658bc: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1658c0: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x1658c8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_1658c8
// Address: 0x1658c8 - 0x165920

void entry_1658c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1658c8) {
        switch (ctx->pc) {
            case 0x1658e8: ctx->pc = 0; goto label_1658e8;
            case 0x1658fc: ctx->pc = 0; goto label_1658fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1658c8: 0x7ba20080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1658cc: 0x7e020010
    WRITE128(ADD32(GPR_U32(ctx, 16), 16), GPR_VEC(ctx, 2));
    // 0x1658d0: 0x7ba30090
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1658d4: 0x7e030020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 3));
    // 0x1658d8: 0x7ba200a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1658dc: 0x7e020030
    WRITE128(ADD32(GPR_U32(ctx, 16), 48), GPR_VEC(ctx, 2));
    // 0x1658e0: 0x7ba300b0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1658e4: 0x7e030040
    WRITE128(ADD32(GPR_U32(ctx, 16), 64), GPR_VEC(ctx, 3));
label_1658e8:
    // 0x1658e8: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x1658ec: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1658f0: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x1658f4: 0x1440ffdc
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 144));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x165868; return;
    }
label_1658fc:
    // 0x1658fc: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x165900: 0x7bb50110
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x165904: 0x7bb40100
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x165908: 0x7bb300f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x16590c: 0x7bb200e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x165910: 0x7bb100d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x165914: 0x7bb000c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x165918: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 304));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneGlobset__FP7GLOBSETP3ALOT0
// Address: 0x165920 - 0x165954

void entry_165954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165954: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x165958: 0x24040090
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 144));
    // 0x16595c: 0xae000050
    WRITE32(ADD32(GPR_U32(ctx, 16), 80), GPR_U32(ctx, 0));
    // 0x165960: 0xc063570
    SET_GPR_U32(ctx, 31, 0x165968);
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_165968
// Address: 0x165968 - 0x16597c

void entry_165968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165968: 0x8e040040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x16596c: 0x8e050044
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    // 0x165970: 0x42080
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    // 0x165974: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x16597c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_16597c
// Address: 0x16597c - 0x165994

void entry_16597c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16597c: 0x8e03000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x165980: 0x24040028
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 40));
    // 0x165984: 0x8e050014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x165988: 0x642018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x16598c: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x165994);
    WRITE32(ADD32(GPR_U32(ctx, 16), 68), GPR_U32(ctx, 2));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_165994
// Address: 0x165994 - 0x1659fc

void entry_165994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165994) {
        switch (ctx->pc) {
            case 0x1659a8: ctx->pc = 0; goto label_1659a8;
            case 0x1659b0: ctx->pc = 0; goto label_1659b0;
            case 0x1659ec: ctx->pc = 0; goto label_1659ec;
            case 0x1659f4: ctx->pc = 0; goto label_1659f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165994: 0x8e120010
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x165998: 0x24060070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 112));
    // 0x16599c: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x1659a0: 0x10000003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1659b0;
    }
label_1659a8:
    // 0x1659a8: 0x24a50070
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 112));
    // 0x1659ac: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_1659b0:
    // 0x1659b0: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1659b4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1659b8: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1659bc: 0x50400011
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 76)));
        ctx->pc = 0x165A04; return;
    }
    // 0x1659c4: 0x8e020010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1659c8: 0x451821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1659cc: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x1659d0: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 84)));
        goto label_1659ec;
    }
    // 0x1659d8: 0x8c420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1659dc: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x1659e0: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
        goto label_1659f4;
    }
    // 0x1659e8: 0x8c620054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 84)));
label_1659ec:
    // 0x1659ec: 0x1040ffee
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1659a8;
    }
label_1659f4:
    // 0x1659f4: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x1659fc);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_1659fc
// Address: 0x1659fc - 0x165a18

void entry_1659fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1659fc) {
        switch (ctx->pc) {
            case 0x165a04: ctx->pc = 0; goto label_165a04;
            case 0x165a10: ctx->pc = 0; goto label_165a10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1659fc: 0xae020010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 2));
    // 0x165a00: 0x8e05004c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 76)));
label_165a04:
    // 0x165a04: 0x10a0001c
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 76));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165A78; return;
    }
    // 0x165a0c: 0x24130070
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 112));
label_165a10:
    // 0x165a10: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x165a18);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 144));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_165a18
// Address: 0x165a18 - 0x165ab0

void entry_165a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165a18) {
        switch (ctx->pc) {
            case 0x165a5c: ctx->pc = 0; goto label_165a5c;
            case 0x165a60: ctx->pc = 0; goto label_165a60;
            case 0x165a78: ctx->pc = 0; goto label_165a78;
            case 0x165a90: ctx->pc = 0; goto label_165a90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165a18: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x165a1c: 0xacb40000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 20));
    // 0x165a20: 0x24a30004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 4));
    // 0x165a24: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x165a28: 0x8e060010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x165a2c: 0x1060000b
    { int64_t result = (int64_t)GPR_S32(ctx, 2) * (int64_t)GPR_S32(ctx, 19); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_165a5c;
    }
    // 0x165a34: 0x8ca30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x165a38: 0x72102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x165a3c: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 4)));
        goto label_165a60;
    }
    // 0x165a44: 0x2441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 4)));
    // 0x165a48: 0x62102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x165a4c: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 18)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_165a5c;
    }
    // 0x165a54: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x165a58: 0xaca20004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 2));
label_165a5c:
    // 0x165a5c: 0x8ca20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 4)));
label_165a60:
    // 0x165a60: 0xac450054
    WRITE32(ADD32(GPR_U32(ctx, 2), 84), GPR_U32(ctx, 5));
    // 0x165a64: 0xae250000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 5));
    // 0x165a68: 0x24b10080
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 5), 128));
    // 0x165a6c: 0x8ca50080
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 128)));
    // 0x165a70: 0x14a0ffe7
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x165A10; return;
    }
label_165a78:
    // 0x165a78: 0xae200000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
    // 0x165a7c: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x165a80: 0x1840000f
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x165AC0; return;
    }
    // 0x165a88: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x165a8c: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_165a90:
    // 0x165a90: 0x8e050010
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x165a94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x165a98: 0x8e060014
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x165a9c: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x165aa0: 0xb12821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 17)));
    // 0x165aa4: 0xd23021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 18)));
    // 0x165aa8: 0xc0596ba
    SET_GPR_U32(ctx, 31, 0x165ab0);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 112));
    CloneGlob__FP7GLOBSETP4GLOBP5GLOBI(rdram, ctx, runtime); return;
}


// Function: entry_165ab0
// Address: 0x165ab0 - 0x165ac8

void entry_165ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165ab0) {
        switch (ctx->pc) {
            case 0x165ac0: ctx->pc = 0; goto label_165ac0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165ab0: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x165ab4: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x165ab8: 0x1440fff5
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 40));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x165A90; return;
    }
label_165ac0:
    // 0x165ac0: 0xc058a04
    SET_GPR_U32(ctx, 31, 0x165ac8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BuildGlobsetSaaArray__FP7GLOBSET(rdram, ctx, runtime); return;
}


// Function: entry_165ac8
// Address: 0x165ac8 - 0x165ae8

void entry_165ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165ac8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x165acc: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x165ad0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x165ad4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x165ad8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x165adc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x165ae0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CloneGlob__FP7GLOBSETP4GLOBP5GLOBI
// Address: 0x165ae8 - 0x165b34

void entry_165b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165b34) {
        switch (ctx->pc) {
            case 0x165b70: ctx->pc = 0; goto label_165b70;
            case 0x165b8c: ctx->pc = 0; goto label_165b8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165b34: 0x8fa30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x165b38: 0xac620004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 2));
    // 0x165b3c: 0x8ee20038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 56)));
    // 0x165b40: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 0));
        goto label_165b70;
    }
    // 0x165b48: 0x8e020050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x165b4c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x165b50: 0xae020050
    WRITE32(ADD32(GPR_U32(ctx, 16), 80), GPR_U32(ctx, 2));
    // 0x165b54: 0x8ee20038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 56)));
    // 0x165b58: 0x10400005
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_165b70;
    }
    // 0x165b60: 0x8c420010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x165b64: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x165b68: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x165b6c: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
label_165b70:
    // 0x165b70: 0x8ee20054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 84)));
    // 0x165b74: 0x8fa40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x165b78: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x165b7c: 0x14800003
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_165b8c;
    }
    // 0x165b84: 0x5040002a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 88)));
        ctx->pc = 0x165C30; return;
    }
label_165b8c:
    // 0x165b8c: 0x8ee30058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 88)));
    // 0x165b90: 0x24040050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 80));
    // 0x165b94: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x165b98: 0x8ee5005c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 23), 92)));
    // 0x165b9c: 0x642018
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 4); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x165ba0: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x165ba8);
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 2), 9936)));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_165ba8
// Address: 0x165ba8 - 0x165bbc

void entry_165ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165ba8: 0x8ee30038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 56)));
    // 0x165bac: 0x1060001f
    WRITE32(ADD32(GPR_U32(ctx, 23), 92), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165C2C; return;
    }
    // 0x165bb4: 0xc06d248
    SET_GPR_U32(ctx, 31, 0x165bbc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    CbFromSaak__F4SAAK(rdram, ctx, runtime); return;
}


// Function: entry_165bbc
// Address: 0x165bbc - 0x165bc8

void entry_165bbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165bbc: 0x8ee50038
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 23), 56)));
    // 0x165bc0: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x165bc8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_165bc8
// Address: 0x165bc8 - 0x165c08

void entry_165bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165bc8) {
        switch (ctx->pc) {
            case 0x165be8: ctx->pc = 0; goto label_165be8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165bc8: 0xaee20038
    WRITE32(ADD32(GPR_U32(ctx, 23), 56), GPR_U32(ctx, 2));
    // 0x165bcc: 0x24510010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 16));
    // 0x165bd0: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x165bd4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x165bd8: 0x12000014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165C2C; return;
    }
    // 0x165be0: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x165be4: 0x0
    // NOP
label_165be8:
    // 0x165be8: 0x10a00009
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165C10; return;
    }
    // 0x165bf0: 0x8ce8000c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x165bf4: 0x220482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x165bf8: 0x8ce60008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x165bfc: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x165c00: 0xc05a53e
    SET_GPR_U32(ctx, 31, 0x165c08);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI(rdram, ctx, runtime); return;
}


// Function: entry_165c08
// Address: 0x165c08 - 0x165c20

void entry_165c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165c08) {
        switch (ctx->pc) {
            case 0x165c10: ctx->pc = 0; goto label_165c10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165c08: 0x10000006
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165C24; return;
    }
label_165c10:
    // 0x165c10: 0x8ce50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x165c14: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x165c18: 0xc05a582
    SET_GPR_U32(ctx, 31, 0x165c20);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    ReferenceUVAnimation__FP2QWiP3SAI(rdram, ctx, runtime); return;
}


// Function: entry_165c20
// Address: 0x165c20 - 0x165cdc

void entry_165c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165c20) {
        switch (ctx->pc) {
            case 0x165c24: ctx->pc = 0; goto label_165c24;
            case 0x165c2c: ctx->pc = 0; goto label_165c2c;
            case 0x165c30: ctx->pc = 0; goto label_165c30;
            case 0x165c40: ctx->pc = 0; goto label_165c40;
            case 0x165c7c: ctx->pc = 0; goto label_165c7c;
            case 0x165c98: ctx->pc = 0; goto label_165c98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165c20: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
label_165c24:
    // 0x165c24: 0x5600fff0
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x165BE8; return;
    }
label_165c2c:
    // 0x165c2c: 0x8ee20058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 88)));
label_165c30:
    // 0x165c30: 0x184000de
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x165FAC; return;
    }
    // 0x165c38: 0x24020050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
    // 0x165c3c: 0x0
    // NOP
label_165c40:
    // 0x165c40: 0x24030030
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 48));
    // 0x165c44: 0xe21018
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x165c48: 0xe31818
    { int64_t result = (int64_t)GPR_S32(ctx, 7) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x165c4c: 0x8fa60000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x165c50: 0x8ee4005c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 23), 92)));
    // 0x165c54: 0x8cc50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x165c58: 0x829021
    SET_GPR_U32(ctx, 18, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x165c5c: 0xa32821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x165c60: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x165c64: 0x14400005
    WRITE32(ADD32(GPR_U32(ctx, 29), 12), GPR_U32(ctx, 5));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_165c7c;
    }
    // 0x165c6c: 0x24e30001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 7), 1));
    // 0x165c70: 0x8fa40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x165c74: 0x108000c4
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165F88; return;
    }
label_165c7c:
    // 0x165c7c: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x165c80: 0x26460044
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 68));
    // 0x165c84: 0xafa70018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 7));
    // 0x165c88: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x165c8c: 0xafa60014
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 6));
    // 0x165c90: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x165c94: 0x0
    // NOP
label_165c98:
    // 0x165c98: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x165c9c: 0xafa3001c
    WRITE32(ADD32(GPR_U32(ctx, 29), 28), GPR_U32(ctx, 3));
    // 0x165ca0: 0x8fa30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x165ca4: 0x628821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x165ca8: 0x8e300000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x165cac: 0x120000b2
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165F78; return;
    }
    // 0x165cb4: 0x26430038
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 56));
    // 0x165cb8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x165cbc: 0x60f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x165cc0: 0x731821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 19)));
    // 0x165cc4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x165cc8: 0x2a100
    SET_GPR_U32(ctx, 20, SLL32(GPR_U32(ctx, 2), 4));
    // 0x165ccc: 0x2142021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 20)));
    // 0x165cd0: 0xafa40010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 4));
    // 0x165cd4: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x165cdc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_165cdc
// Address: 0x165cdc - 0x165dfc

void entry_165cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165cdc) {
        switch (ctx->pc) {
            case 0x165d00: ctx->pc = 0; goto label_165d00;
            case 0x165d48: ctx->pc = 0; goto label_165d48;
            case 0x165d70: ctx->pc = 0; goto label_165d70;
            case 0x165d88: ctx->pc = 0; goto label_165d88;
            case 0x165d8c: ctx->pc = 0; goto label_165d8c;
            case 0x165dd8: ctx->pc = 0; goto label_165dd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165cdc: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x165ce0: 0x1aa0004c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 21) <= 0) {
        ctx->pc = 0x165E14; return;
    }
    // 0x165ce8: 0x3c020028
    SET_GPR_U32(ctx, 2, ((uint32_t)40 << 16));
    // 0x165cec: 0x151900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 21), 4));
    // 0x165cf0: 0x2456dc20
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 2), 4294958112));
    // 0x165cf4: 0x3c0d0026
    SET_GPR_U32(ctx, 13, ((uint32_t)38 << 16));
    // 0x165cf8: 0x766021
    SET_GPR_U32(ctx, 12, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 22)));
    // 0x165cfc: 0x41100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
label_165d00:
    // 0x165d00: 0x563821
    SET_GPR_U32(ctx, 7, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x165d04: 0x8ce30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x165d08: 0x70102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x165d0c: 0x1440003d
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 4), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x165E04; return;
    }
    // 0x165d14: 0x8fa60010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x165d18: 0x66102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x165d1c: 0x10400039
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 13), 9936)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165E04; return;
    }
    // 0x165d24: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x165d28: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x165d2c: 0x2a2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 21), GPR_S32(ctx, 2)));
    // 0x165d30: 0x1040000f
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_165d70;
    }
    // 0x165d38: 0x8d820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 12), 8)));
    // 0x165d3c: 0x5043000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
        goto label_165d70;
    }
    // 0x165d44: 0x8d0226d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 9936)));
label_165d48:
    // 0x165d48: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x165d4c: 0xa2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), GPR_S32(ctx, 2)));
    // 0x165d50: 0x10400007
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 5), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_165d70;
    }
    // 0x165d58: 0x8ce40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x165d5c: 0x561021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x165d60: 0x8c430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x165d64: 0x1464fff8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 9936)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_165d48;
    }
    // 0x165d6c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
label_165d70:
    // 0x165d70: 0x14c00025
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x165E08; return;
    }
    // 0x165d78: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x165d7c: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x165d80: 0x10000002
    SET_GPR_U32(ctx, 9, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_165d8c;
    }
label_165d88:
    // 0x165d88: 0x254a0001
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 1));
label_165d8c:
    // 0x165d8c: 0x8d220018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 24)));
    // 0x165d90: 0x142102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 10), GPR_S32(ctx, 2)));
    // 0x165d94: 0x10400010
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 10), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_165dd8;
    }
    // 0x165d9c: 0x8d24001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 9), 28)));
    // 0x165da0: 0x8d230020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 32)));
    // 0x165da4: 0x823021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x165da8: 0x8ce80004
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x165dac: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x165db0: 0x8cc40004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x165db4: 0x621818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x165db8: 0x104282b
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    // 0x165dbc: 0x31900
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    // 0x165dc0: 0x14a0fff1
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        goto label_165d88;
    }
    // 0x165dc8: 0x102102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 8), GPR_U32(ctx, 2)));
    // 0x165dcc: 0x1040ffef
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_165d8c;
    }
    // 0x165dd4: 0xc0582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
label_165dd8:
    // 0x165dd8: 0x8ce8000c
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x165ddc: 0x120202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x165de0: 0x8ce60008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x165de4: 0x160282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    // 0x165de8: 0x8ce70000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x165dec: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x165df0: 0x7fac0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 12));
    // 0x165df4: 0xc05a53e
    SET_GPR_U32(ctx, 31, 0x165dfc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 13));
    ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI(rdram, ctx, runtime); return;
}


// Function: entry_165dfc
// Address: 0x165dfc - 0x165e30

void entry_165dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165dfc) {
        switch (ctx->pc) {
            case 0x165e04: ctx->pc = 0; goto label_165e04;
            case 0x165e08: ctx->pc = 0; goto label_165e08;
            case 0x165e14: ctx->pc = 0; goto label_165e14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165dfc: 0x7bad0030
    SET_GPR_VEC(ctx, 13, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x165e00: 0x7bac0020
    SET_GPR_VEC(ctx, 12, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_165e04:
    // 0x165e04: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_165e08:
    // 0x165e08: 0x95102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 21)));
    // 0x165e0c: 0x1440ffbc
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x165D00; return;
    }
label_165e14:
    // 0x165e14: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x165e18: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x165e1c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x165e20: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x165e24: 0x538821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x165e28: 0xc05a5ae
    SET_GPR_U32(ctx, 31, 0x165e30);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    RebaseSurs__FiiPvT2(rdram, ctx, runtime); return;
}


// Function: entry_165e30
// Address: 0x165e30 - 0x165e48

void entry_165e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x165e30: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x165e34: 0x10600051
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x165F7C; return;
    }
    // 0x165e3c: 0x8e450020
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x165e40: 0xc06355a
    SET_GPR_U32(ctx, 31, 0x165e48);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 52));
    PvAllocSwCopyImpl__FiPv(rdram, ctx, runtime); return;
}


// Function: entry_165e48
// Address: 0x165e48 - 0x165f98

void entry_165e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165e48) {
        switch (ctx->pc) {
            case 0x165e8c: ctx->pc = 0; goto label_165e8c;
            case 0x165e90: ctx->pc = 0; goto label_165e90;
            case 0x165ea0: ctx->pc = 0; goto label_165ea0;
            case 0x165ee4: ctx->pc = 0; goto label_165ee4;
            case 0x165ee8: ctx->pc = 0; goto label_165ee8;
            case 0x165f28: ctx->pc = 0; goto label_165f28;
            case 0x165f2c: ctx->pc = 0; goto label_165f2c;
            case 0x165f6c: ctx->pc = 0; goto label_165f6c;
            case 0x165f70: ctx->pc = 0; goto label_165f70;
            case 0x165f78: ctx->pc = 0; goto label_165f78;
            case 0x165f7c: ctx->pc = 0; goto label_165f7c;
            case 0x165f88: ctx->pc = 0; goto label_165f88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165e48: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x165e4c: 0x3d31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 19)));
    // 0x165e50: 0xae440020
    WRITE32(ADD32(GPR_U32(ctx, 18), 32), GPR_U32(ctx, 4));
    // 0x165e54: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x165e58: 0x8e270000
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x165e5c: 0x1080000b
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 2), 4));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_165e8c;
    }
    // 0x165e64: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x165e68: 0x70102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x165e6c: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 20)));
        goto label_165e90;
    }
    // 0x165e74: 0x2051021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 5)));
    // 0x165e78: 0x62102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x165e7c: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 7), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_165e8c;
    }
    // 0x165e84: 0x621021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x165e88: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
label_165e8c:
    // 0x165e8c: 0x8fa40014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 20)));
label_165e90:
    // 0x165e90: 0x3d34821
    SET_GPR_U32(ctx, 9, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 19)));
    // 0x165e94: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x165e98: 0x240a0003
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 3));
    // 0x165e9c: 0x934021
    SET_GPR_U32(ctx, 8, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 19)));
label_165ea0:
    // 0x165ea0: 0x8e420020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 32)));
    // 0x165ea4: 0x8d230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x165ea8: 0xe22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x165eac: 0x8d060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x165eb0: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x165eb4: 0x10a0000c
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_165ee8;
    }
    // 0x165ebc: 0x8ca40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x165ec0: 0x90102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 16)));
    // 0x165ec4: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 32)));
        goto label_165ee8;
    }
    // 0x165ecc: 0x2031021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x165ed0: 0x82102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x165ed4: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_165ee4;
    }
    // 0x165edc: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x165ee0: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
label_165ee4:
    // 0x165ee4: 0x8e420020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 32)));
label_165ee8:
    // 0x165ee8: 0x8d230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x165eec: 0xe22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x165ef0: 0x8d060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x165ef4: 0x24a50014
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 20));
    // 0x165ef8: 0x10a0000b
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_165f28;
    }
    // 0x165f00: 0x8ca40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x165f04: 0x90102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 16)));
    // 0x165f08: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 32)));
        goto label_165f2c;
    }
    // 0x165f10: 0x2031021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x165f14: 0x82102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x165f18: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_165f28;
    }
    // 0x165f20: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x165f24: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
label_165f28:
    // 0x165f28: 0x8e420020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 32)));
label_165f2c:
    // 0x165f2c: 0x8d230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x165f30: 0xe22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 2)));
    // 0x165f34: 0x8d060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x165f38: 0x24a50024
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 36));
    // 0x165f3c: 0x10a0000b
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 4));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_165f6c;
    }
    // 0x165f44: 0x8ca40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x165f48: 0x90102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 16)));
    // 0x165f4c: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4294967295));
        goto label_165f70;
    }
    // 0x165f54: 0x2031021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x165f58: 0x82102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x165f5c: 0x10400003
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_165f6c;
    }
    // 0x165f64: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x165f68: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
label_165f6c:
    // 0x165f6c: 0x254affff
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4294967295));
label_165f70:
    // 0x165f70: 0x541ffcb
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    if (GPR_S32(ctx, 10) >= 0) {
        goto label_165ea0;
    }
label_165f78:
    // 0x165f78: 0x8fa3001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 28)));
label_165f7c:
    // 0x165f7c: 0x28620003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    // 0x165f80: 0x1440ff45
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x165C98; return;
    }
label_165f88:
    // 0x165f88: 0x8fa6000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x165f8c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x165f90: 0xc059562
    SET_GPR_U32(ctx, 31, 0x165f98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    BuildSubglobLighting__FP4GLOBP7SUBGLOBP8SUBGLOBI(rdram, ctx, runtime); return;
}


// Function: entry_165f98
// Address: 0x165f98 - 0x165fe0

void entry_165f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x165f98) {
        switch (ctx->pc) {
            case 0x165fac: ctx->pc = 0; goto label_165fac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x165f98: 0x8ee20058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 88)));
    // 0x165f9c: 0x8fa70018
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    // 0x165fa0: 0xe2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 7), GPR_S32(ctx, 2)));
    // 0x165fa4: 0x1440ff26
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x165C40; return;
    }
label_165fac:
    // 0x165fac: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x165fb0: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x165fb4: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x165fb8: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x165fbc: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x165fc0: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x165fc4: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x165fc8: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x165fcc: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x165fd0: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x165fd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x165fdc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x165fe0; return;
}


// Function: UpdateGlobset__FP7GLOBSETP3ALOf
// Address: 0x165fe0 - 0x16602c

void entry_16602c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16602c: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 636)));
        ctx->pc = 0x166050; return;
    }
    // 0x166034: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x166038: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x16603c: 0x10400003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_16604c(rdram, ctx, runtime); return;
    }
    // 0x166044: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16604c);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16604c
// Address: 0x16604c - 0x166078

void entry_16604c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16604c) {
        switch (ctx->pc) {
            case 0x166050: ctx->pc = 0; goto label_166050;
            case 0x166060: ctx->pc = 0; goto label_166060;
            case 0x166070: ctx->pc = 0; goto label_166070;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16604c: 0x8e42027c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 636)));
label_166050:
    // 0x166050: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x166054: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x166058: 0x5440ffef
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 640)));
        ctx->pc = 0x166018; return;
    }
label_166060:
    // 0x166060: 0x8e70004c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 76)));
    // 0x166064: 0x12000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x166084; return;
    }
    // 0x16606c: 0x0
    // NOP
label_166070:
    // 0x166070: 0xc07cd02
    SET_GPR_U32(ctx, 31, 0x166078);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    UpdateWrMatrixes__FP2WR(rdram, ctx, runtime); return;
}


// Function: entry_166078
// Address: 0x166078 - 0x1660a0

void entry_166078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x166078) {
        switch (ctx->pc) {
            case 0x166084: ctx->pc = 0; goto label_166084;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x166078: 0x8e100080
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 128)));
    // 0x16607c: 0x1600fffc
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x166070; return;
    }
label_166084:
    // 0x166084: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x166088: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16608c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x166090: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x166094: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x166098: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateAloConstraints__FP3ALO
// Address: 0x1660a0 - 0x1660d8

void entry_1660d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1660d8) {
        switch (ctx->pc) {
            case 0x1660dc: ctx->pc = 0; goto label_1660dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1660d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1660dc:
    // 0x1660dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1660e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1660e8; return;
}


// Function: UpdateAloInfluences__FP3ALOP2RO
// Address: 0x1660e8 - 0x166124

void entry_166124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x166124: 0x12000006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x166140; return;
    }
    // 0x16612c: 0x26040030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 48));
    // 0x166130: 0xc0622d2
    SET_GPR_U32(ctx, 31, 0x166138);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    LoadMatrixFromPosRotInverse__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_166138
// Address: 0x166138 - 0x16619c

void entry_166138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x166138) {
        switch (ctx->pc) {
            case 0x166140: ctx->pc = 0; goto label_166140;
            case 0x166164: ctx->pc = 0; goto label_166164;
            case 0x166178: ctx->pc = 0; goto label_166178;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x166138: 0x1000000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_166164;
    }
label_166140:
    // 0x166140: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x166144: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x166148: 0x7ba40020
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16614c: 0x7ba50030
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x166150: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x166154: 0x7fa30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 3));
    // 0x166158: 0x7fa40060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 4));
    // 0x16615c: 0x7fa50070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 5));
    // 0x166160: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_166164:
    // 0x166164: 0x18400047
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x166284; return;
    }
    // 0x16616c: 0x27b20080
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 128));
    // 0x166170: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x166174: 0x0
    // NOP
label_166178:
    // 0x166178: 0x8e620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4)));
    // 0x16617c: 0x548021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x166180: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x166184: 0x5080003b
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
        ctx->pc = 0x166274; return;
    }
    // 0x16618c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x166190: 0x8c4300c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 192)));
    // 0x166194: 0x60f809
    SET_GPR_U32(ctx, 31, 0x16619c);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_16619c
// Address: 0x16619c - 0x166208

void entry_16619c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16619c) {
        switch (ctx->pc) {
            case 0x1661f4: ctx->pc = 0; goto label_1661f4;
            case 0x1661f8: ctx->pc = 0; goto label_1661f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16619c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1661a0: 0x8c470224
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 2), 548)));
    // 0x1661a4: 0x50e00014
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1661f8;
    }
    // 0x1661ac: 0x8ce200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 176)));
    // 0x1661b0: 0x30420080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 128));
    // 0x1661b4: 0x50400010
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_1661f8;
    }
    // 0x1661bc: 0x8ce200a4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 164)));
    // 0x1661c0: 0x1040000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1661f4;
    }
    // 0x1661c8: 0x78e30060
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 7), 96)));
    // 0x1661cc: 0x27a40100
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 256));
    // 0x1661d0: 0x27a60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 128));
    // 0x1661d4: 0x7fa30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 3));
    // 0x1661d8: 0x78e20070
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 7), 112)));
    // 0x1661dc: 0x7fa20090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 2));
    // 0x1661e0: 0x78e30080
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 7), 128)));
    // 0x1661e4: 0x7fa300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 3));
    // 0x1661e8: 0x78e20090
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 7), 144)));
    // 0x1661ec: 0x10000009
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x166214; return;
    }
label_1661f4:
    // 0x1661f4: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1661f8:
    // 0x1661f8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1661fc: 0x24850110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 272));
    // 0x166200: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x166208);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 320));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_166208
// Address: 0x166208 - 0x16621c

void entry_166208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x166208) {
        switch (ctx->pc) {
            case 0x166214: ctx->pc = 0; goto label_166214;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x166208: 0x27a40100
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 256));
    // 0x16620c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x166210: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_166214:
    // 0x166214: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x16621c);
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_16621c
// Address: 0x16621c - 0x166250

void entry_16621c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16621c: 0x7ba50100
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x166220: 0x27a60100
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 256));
    // 0x166224: 0x7ba20110
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x166228: 0x7ba30120
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x16622c: 0x7ba40130
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x166230: 0x7fa500c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 5));
    // 0x166234: 0x7fa200d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 2));
    // 0x166238: 0x7fa300e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 3));
    // 0x16623c: 0x7fa400f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 4));
    // 0x166240: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x166244: 0x27a500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 192));
    // 0x166248: 0xc06219a
    SET_GPR_U32(ctx, 31, 0x166250);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 16));
    fn___ml__FRC7MATRIX4T0(rdram, ctx, runtime); return;
}


// Function: entry_166250
// Address: 0x166250 - 0x1662a8

void entry_166250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x166250) {
        switch (ctx->pc) {
            case 0x166274: ctx->pc = 0; goto label_166274;
            case 0x166284: ctx->pc = 0; goto label_166284;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x166250: 0x7ba20100
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x166254: 0x7e020050
    WRITE128(ADD32(GPR_U32(ctx, 16), 80), GPR_VEC(ctx, 2));
    // 0x166258: 0x7ba30110
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x16625c: 0x7e030060
    WRITE128(ADD32(GPR_U32(ctx, 16), 96), GPR_VEC(ctx, 3));
    // 0x166260: 0x7ba20120
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x166264: 0x7e020070
    WRITE128(ADD32(GPR_U32(ctx, 16), 112), GPR_VEC(ctx, 2));
    // 0x166268: 0x7ba30130
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x16626c: 0x7e030080
    WRITE128(ADD32(GPR_U32(ctx, 16), 128), GPR_VEC(ctx, 3));
    // 0x166270: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_166274:
    // 0x166274: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x166278: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x16627c: 0x1440ffbe
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 144));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x166178; return;
    }
label_166284:
    // 0x166284: 0x7bbf0190
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x166288: 0x7bb40180
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x16628c: 0x7bb30170
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x166290: 0x7bb20160
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x166294: 0x7bb10150
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x166298: 0x7bb00140
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x16629c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 416));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1662a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1662a8; return;
}


// Function: PredrawGlob__FP7GLOBSETP4GLOBP5GLOBIP3ALO
// Address: 0x1662a8 - 0x1662e8

void entry_1662e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1662e8) {
        switch (ctx->pc) {
            case 0x166320: ctx->pc = 0; goto label_166320;
            case 0x166338: ctx->pc = 0; goto label_166338;
            case 0x166350: ctx->pc = 0; goto label_166350;
            case 0x166368: ctx->pc = 0; goto label_166368;
            case 0x166380: ctx->pc = 0; goto label_166380;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1662e8: 0x8e830028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 40)));
    // 0x1662ec: 0x146000cf
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16662C; return;
    }
    // 0x1662f4: 0x12c000ce
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x166630; return;
    }
    // 0x1662fc: 0x8e020040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x166300: 0x144000cc
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x166634; return;
    }
    // 0x166308: 0x8e840058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x16630c: 0x1880000a
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_166338;
    }
    // 0x166314: 0x8e82005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 92)));
    // 0x166318: 0x24430024
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 36));
    // 0x16631c: 0x0
    // NOP
label_166320:
    // 0x166320: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x166324: 0x144000c0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x166628; return;
    }
    // 0x16632c: 0x244102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 4)));
    // 0x166330: 0x1440fffb
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 80));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_166320;
    }
label_166338:
    // 0x166338: 0x8e840060
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 96)));
    // 0x16633c: 0x1880000a
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_166368;
    }
    // 0x166344: 0x8e820064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 100)));
    // 0x166348: 0x24430004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4));
    // 0x16634c: 0x0
    // NOP
label_166350:
    // 0x166350: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x166354: 0x144000b4
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x166628; return;
    }
    // 0x16635c: 0x204102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 4)));
    // 0x166360: 0x1440fffb
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_166350;
    }
label_166368:
    // 0x166368: 0x26c20020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 22), 32));
    // 0x16636c: 0x26c30018
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 24));
    // 0x166370: 0xafa00040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 0));
    // 0x166374: 0xafa20044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 2));
    // 0x166378: 0xafa30048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 3));
    // 0x16637c: 0x0
    // NOP
label_166380:
    // 0x166380: 0xc063582
    SET_GPR_U32(ctx, 31, 0x166388);
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 532));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_166388
// Address: 0x166388 - 0x166394

void entry_166388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x166388: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16638c: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x166394);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4096));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_166394
// Address: 0x166394 - 0x1663e4

void entry_166394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x166394) {
        switch (ctx->pc) {
            case 0x1663b8: ctx->pc = 0; goto label_1663b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x166394: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x166398: 0x8fa40040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16639c: 0x24020028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 40));
    // 0x1663a0: 0x8e830058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x1663a4: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1663a8: 0x1860004e
    if (GPR_U32(ctx, 4) == 0) SET_GPR_U32(ctx, 21, GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x1664E4; return;
    }
    // 0x1663b0: 0xf02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1663b4: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1663b8:
    // 0x1663b8: 0x8e82005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 92)));
    // 0x1663bc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1663c0: 0x8ec30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 4)));
    // 0x1663c4: 0x2405023c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 572));
    // 0x1663c8: 0xb5a823
    SET_GPR_U32(ctx, 21, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 21)));
    // 0x1663cc: 0x578021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x1663d0: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1663d4: 0x18800009
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 30)));
    if (GPR_S32(ctx, 4) <= 0) {
        entry_1663fc(rdram, ctx, runtime); return;
    }
    // 0x1663dc: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x1663e4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1663e4
// Address: 0x1663e4 - 0x1663f4

void entry_1663e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1663e4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1663e8: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1663ec: 0xc07b8ee
    SET_GPR_U32(ctx, 31, 0x1663f4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifBaseOffset__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_1663f4
// Address: 0x1663f4 - 0x1663fc

void entry_1663f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1663f4: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x1663fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1663fc
// Address: 0x1663fc - 0x16644c

void entry_1663fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1663fc) {
        switch (ctx->pc) {
            case 0x166428: ctx->pc = 0; goto label_166428;
            case 0x166440: ctx->pc = 0; goto label_166440;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1663fc: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x166400: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x166404: 0x90430000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x166408: 0x10670025
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 7)) {
        ctx->pc = 0x1664A0; return;
    }
    // 0x166410: 0x10400005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 11));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_166428;
    }
    // 0x166418: 0x50600009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 56)));
        goto label_166440;
    }
    // 0x166420: 0x1000002b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1664D0; return;
    }
label_166428:
    // 0x166428: 0x10400028
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1664cc(rdram, ctx, runtime); return;
    }
    // 0x166430: 0x54400027
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
        ctx->pc = 0x1664D0; return;
    }
    // 0x166438: 0x1000001a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 84)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1664A4; return;
    }
label_166440:
    // 0x166440: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x166444: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x16644c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_16644c
// Address: 0x16644c - 0x166464

void entry_16644c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16644c: 0x8e820054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 84)));
    // 0x166450: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 76)));
        ctx->pc = 0x16646C; return;
    }
    // 0x166458: 0x8e05004c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x16645c: 0xc054b06
    SET_GPR_U32(ctx, 31, 0x166464);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaCall__4DMASP2QW(rdram, ctx, runtime); return;
}


// Function: entry_166464
// Address: 0x166464 - 0x166478

void entry_166464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x166464) {
        switch (ctx->pc) {
            case 0x16646c: ctx->pc = 0; goto label_16646c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x166464: 0x10000005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16647C; return;
    }
label_16646c:
    // 0x16646c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x166470: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x166478);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_166478
// Address: 0x166478 - 0x166488

void entry_166478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x166478) {
        switch (ctx->pc) {
            case 0x16647c: ctx->pc = 0; goto label_16647c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x166478: 0x8e250000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_16647c:
    // 0x16647c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x166480: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x166488);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_166488
// Address: 0x166488 - 0x166498

void entry_166488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x166488: 0x8e260010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x16648c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x166490: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x166498);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_166498
// Address: 0x166498 - 0x1664b8

void entry_166498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x166498) {
        switch (ctx->pc) {
            case 0x1664a0: ctx->pc = 0; goto label_1664a0;
            case 0x1664a4: ctx->pc = 0; goto label_1664a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x166498: 0x1000000d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1664D0; return;
    }
label_1664a0:
    // 0x1664a0: 0x8e820054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 84)));
label_1664a4:
    // 0x1664a4: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 68)));
        ctx->pc = 0x1664C0; return;
    }
    // 0x1664ac: 0x8e050044
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    // 0x1664b0: 0xc054b06
    SET_GPR_U32(ctx, 31, 0x1664b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaCall__4DMASP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1664b8
// Address: 0x1664b8 - 0x1664cc

void entry_1664b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1664b8) {
        switch (ctx->pc) {
            case 0x1664c0: ctx->pc = 0; goto label_1664c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1664b8: 0x10000005
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1664D0; return;
    }
label_1664c0:
    // 0x1664c0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1664c4: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x1664cc);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1664cc
// Address: 0x1664cc - 0x166520

void entry_1664cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1664cc) {
        switch (ctx->pc) {
            case 0x1664d0: ctx->pc = 0; goto label_1664d0;
            case 0x1664e4: ctx->pc = 0; goto label_1664e4;
            case 0x166508: ctx->pc = 0; goto label_166508;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1664cc: 0x8e820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
label_1664d0:
    // 0x1664d0: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x1664d4: 0x27de0030
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 30), 48));
    // 0x1664d8: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x1664dc: 0x1440ffb6
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 80));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1663B8; return;
    }
label_1664e4:
    // 0x1664e4: 0x8e820060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 96)));
    // 0x1664e8: 0x18400033
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x1665B8; return;
    }
    // 0x1664f0: 0x3c170026
    SET_GPR_U32(ctx, 23, ((uint32_t)38 << 16));
    // 0x1664f4: 0x341e8000
    SET_GPR_U32(ctx, 30, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1664f8: 0x1ef478
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 30) << 17);
    // 0x1664fc: 0x26f223e0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 23), 9184));
    // 0x166500: 0x8e830064
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 100)));
    // 0x166504: 0x0
    // NOP
label_166508:
    // 0x166508: 0x101140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 16), 5));
    // 0x16650c: 0x2405023c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 572));
    // 0x166510: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x166514: 0x628821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x166518: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x166520);
    SET_GPR_U32(ctx, 21, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 21)));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_166520
// Address: 0x166520 - 0x16653c

void entry_166520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x166520: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x166524: 0x18400005
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_S32(ctx, 2) <= 0) {
        entry_16653c(rdram, ctx, runtime); return;
    }
    // 0x16652c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x166530: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x166534: 0xc07b8ee
    SET_GPR_U32(ctx, 31, 0x16653c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifBaseOffset__4VIFSii(rdram, ctx, runtime); return;
}


// Function: entry_16653c
// Address: 0x16653c - 0x166590

void entry_16653c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16653c: 0x92470001
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 1)));
    // 0x166540: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x166544: 0x92430002
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 2)));
    // 0x166548: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16654c: 0x92e223e0
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 23), 9184)));
    // 0x166550: 0x73a38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 8);
    // 0x166554: 0x92460003
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 18), 3)));
    // 0x166558: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x16655c: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x166560: 0x2408001a
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 26));
    // 0x166564: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x166568: 0x63638
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 24);
    // 0x16656c: 0x461025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x166570: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x166574: 0x5e1025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 30)));
    // 0x166578: 0xffa70038
    WRITE64(ADD32(GPR_U32(ctx, 29), 56), GPR_U64(ctx, 7));
    // 0x16657c: 0xffa20030
    WRITE64(ADD32(GPR_U32(ctx, 29), 48), GPR_U64(ctx, 2));
    // 0x166580: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x166584: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x166588: 0xc07b99a
    SET_GPR_U32(ctx, 31, 0x166590);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    AddVifUnpack__4VIFS3UPKiPvi(rdram, ctx, runtime); return;
}


// Function: entry_166590
// Address: 0x166590 - 0x166598

void entry_166590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x166590: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x166598);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_166598
// Address: 0x166598 - 0x1665a8

void entry_166598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x166598: 0x8e26001c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x16659c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1665a0: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x1665a8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1665a8
// Address: 0x1665a8 - 0x1665c0

void entry_1665a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1665a8) {
        switch (ctx->pc) {
            case 0x1665b8: ctx->pc = 0; goto label_1665b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1665a8: 0x8e820060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 96)));
    // 0x1665ac: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x1665b0: 0x5440ffd5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 100)));
        ctx->pc = 0x166508; return;
    }
label_1665b8:
    // 0x1665b8: 0xc054b28
    SET_GPR_U32(ctx, 31, 0x1665c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaRet__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_1665c0
// Address: 0x1665c0 - 0x1665d8

void entry_1665c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1665c0: 0x8fa50048
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x1665c4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1665c8: 0x8fa70044
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x1665cc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1665d0: 0xc054a94
    SET_GPR_U32(ctx, 31, 0x1665d8);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 25));
    DetachCopySw__4DMASPiPP2QWT2i(rdram, ctx, runtime); return;
}


// Function: entry_1665d8
// Address: 0x1665d8 - 0x1665e0

void entry_1665d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1665d8: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x1665e0);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1665e0
// Address: 0x1665e0 - 0x166658

void entry_1665e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1665e0) {
        switch (ctx->pc) {
            case 0x166600: ctx->pc = 0; goto label_166600;
            case 0x166628: ctx->pc = 0; goto label_166628;
            case 0x16662c: ctx->pc = 0; goto label_16662c;
            case 0x166630: ctx->pc = 0; goto label_166630;
            case 0x166634: ctx->pc = 0; goto label_166634;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1665e0: 0x2a620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 2));
    // 0x1665e4: 0x10400006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_166600;
    }
    // 0x1665ec: 0x8ec20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 24)));
    // 0x1665f0: 0x8ec30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 32)));
    // 0x1665f4: 0xaec2001c
    WRITE32(ADD32(GPR_U32(ctx, 22), 28), GPR_U32(ctx, 2));
    // 0x1665f8: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 22), 36), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_166628;
    }
label_166600:
    // 0x166600: 0x8fa30044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 68)));
    // 0x166604: 0x8fa40048
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 72)));
    // 0x166608: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x16660c: 0xafa20040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 2));
    // 0x166610: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x166614: 0x24840004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4));
    // 0x166618: 0xafa30044
    WRITE32(ADD32(GPR_U32(ctx, 29), 68), GPR_U32(ctx, 3));
    // 0x16661c: 0x28420002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    // 0x166620: 0x1440ff57
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x166380; return;
    }
label_166628:
    // 0x166628: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_16662c:
    // 0x16662c: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
label_166630:
    // 0x166630: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
label_166634:
    // 0x166634: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x166638: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x16663c: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x166640: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x166644: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x166648: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16664c: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x166650: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RotateVu1Buffer__Fv
// Address: 0x166658 - 0x166684

void entry_166684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x166684: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x166688: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: DrawGlob__FP3RPL
// Address: 0x166690 - 0x166704

void entry_166704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x166704) {
        switch (ctx->pc) {
            case 0x16676c: ctx->pc = 0; goto label_16676c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x166704: 0x6a820047
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 71); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x166708: 0x6e820040
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 64); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16670c: 0x6a83004f
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 79); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x166710: 0x6e830048
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 72); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x166714: 0xb3a20087
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 135); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x166718: 0xb7a20080
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 128); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16671c: 0xb3a3008f
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 143); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x166720: 0xb7a30088
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 136); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x166724: 0xafa00300
    WRITE32(ADD32(GPR_U32(ctx, 29), 768), GPR_U32(ctx, 0));
    // 0x166728: 0x8e820018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 24)));
    // 0x16672c: 0x1040006c
    WRITE32(ADD32(GPR_U32(ctx, 29), 772), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1668E0; return;
    }
    // 0x166734: 0x8e82006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 108)));
    // 0x166738: 0x1040000c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16676c;
    }
    // 0x166740: 0x8c45027c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 636)));
    // 0x166744: 0x7ac20060
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 22), 96)));
    // 0x166748: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x16674c: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x166750: 0xafa60300
    WRITE32(ADD32(GPR_U32(ctx, 29), 768), GPR_U32(ctx, 6));
    // 0x166754: 0xafa500b0
    WRITE32(ADD32(GPR_U32(ctx, 29), 176), GPR_U32(ctx, 5));
    // 0x166758: 0x7fa200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 2));
    // 0x16675c: 0xafa30094
    WRITE32(ADD32(GPR_U32(ctx, 29), 148), GPR_U32(ctx, 3));
    // 0x166760: 0xafa4009c
    WRITE32(ADD32(GPR_U32(ctx, 29), 156), GPR_U32(ctx, 4));
    // 0x166764: 0x10000062
    WRITE32(ADD32(GPR_U32(ctx, 29), 772), GPR_U32(ctx, 6));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1668F0; return;
    }
label_16676c:
    // 0x16676c: 0x8e820028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 40)));
    // 0x166770: 0x10400010
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1667B4; return;
    }
    // 0x166778: 0xc68c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 16)); ctx->f[12] = *(float*)&val; }
    // 0x16677c: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x166780: 0x26c50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 22), 96));
    // 0x166784: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x166788: 0x24070080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 128));
    // 0x16678c: 0x27a80300
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 768));
    // 0x166790: 0x27a90304
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 772));
    // 0x166794: 0xc061454
    SET_GPR_U32(ctx, 31, 0x16679c);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 176));
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_16679c
// Address: 0x16679c - 0x1667e4

void entry_16679c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16679c) {
        switch (ctx->pc) {
            case 0x1667b4: ctx->pc = 0; goto label_1667b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16679c: 0x7ac30060
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 22), 96)));
    // 0x1667a0: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1667a4: 0xafa2009c
    WRITE32(ADD32(GPR_U32(ctx, 29), 156), GPR_U32(ctx, 2));
    // 0x1667a8: 0x7fa300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 3));
    // 0x1667ac: 0x10000050
    WRITE32(ADD32(GPR_U32(ctx, 29), 148), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1668F0; return;
    }
label_1667b4:
    // 0x1667b4: 0x16e0000f
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 23) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1667F4; return;
    }
    // 0x1667bc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1667c0: 0xc68c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 16)); ctx->f[12] = *(float*)&val; }
    // 0x1667c4: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x1667c8: 0x26c50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 22), 96));
    // 0x1667cc: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1667d0: 0x24070080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 128));
    // 0x1667d4: 0x27a80300
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 768));
    // 0x1667d8: 0x27a90304
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 772));
    // 0x1667dc: 0xc061454
    SET_GPR_U32(ctx, 31, 0x1667e4);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 176));
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_1667e4
// Address: 0x1667e4 - 0x16683c

void entry_1667e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1667e4) {
        switch (ctx->pc) {
            case 0x1667f4: ctx->pc = 0; goto label_1667f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1667e4: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1667e8: 0xafa2009c
    WRITE32(ADD32(GPR_U32(ctx, 29), 156), GPR_U32(ctx, 2));
    // 0x1667ec: 0x10000040
    WRITE32(ADD32(GPR_U32(ctx, 29), 148), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1668F0; return;
    }
label_1667f4:
    // 0x1667f4: 0x8ee30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 8)));
    // 0x1667f8: 0x8c444260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 16992)));
    // 0x1667fc: 0x64182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x166800: 0x1460001e
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16687C; return;
    }
    // 0x166808: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16680c: 0x8c434264
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 16996)));
    // 0x166810: 0x1060000b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x166840; return;
    }
    // 0x166818: 0xc68c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 16)); ctx->f[12] = *(float*)&val; }
    // 0x16681c: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x166820: 0x26c50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 22), 96));
    // 0x166824: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x166828: 0x24070080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 128));
    // 0x16682c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x166830: 0x27a90304
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 772));
    // 0x166834: 0xc061454
    SET_GPR_U32(ctx, 31, 0x16683c);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 176));
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_16683c
// Address: 0x16683c - 0x1668a0

void entry_16683c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16683c) {
        switch (ctx->pc) {
            case 0x166840: ctx->pc = 0; goto label_166840;
            case 0x16686c: ctx->pc = 0; goto label_16686c;
            case 0x16687c: ctx->pc = 0; goto label_16687c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16683c: 0xafa2009c
    WRITE32(ADD32(GPR_U32(ctx, 29), 156), GPR_U32(ctx, 2));
label_166840:
    // 0x166840: 0x8fa20304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 772)));
    // 0x166844: 0x10400009
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16686c;
    }
    // 0x16684c: 0x8fa2009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 156)));
    // 0x166850: 0xafa30094
    WRITE32(ADD32(GPR_U32(ctx, 29), 148), GPR_U32(ctx, 3));
    // 0x166854: 0x8ee3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 12)));
    // 0x166858: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x16685c: 0x10400024
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1668F0; return;
    }
    // 0x166864: 0x10000022
    WRITE32(ADD32(GPR_U32(ctx, 29), 156), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1668F0; return;
    }
label_16686c:
    // 0x16686c: 0xafa00094
    WRITE32(ADD32(GPR_U32(ctx, 29), 148), GPR_U32(ctx, 0));
    // 0x166870: 0x8ee2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 12)));
    // 0x166874: 0x1000001e
    WRITE32(ADD32(GPR_U32(ctx, 29), 156), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1668F0; return;
    }
label_16687c:
    // 0x16687c: 0xc68c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 16)); ctx->f[12] = *(float*)&val; }
    // 0x166880: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x166884: 0x26c50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 22), 96));
    // 0x166888: 0x24060007
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 7));
    // 0x16688c: 0x24070080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 128));
    // 0x166890: 0x27a80300
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 768));
    // 0x166894: 0x27a90304
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 772));
    // 0x166898: 0xc061454
    SET_GPR_U32(ctx, 31, 0x1668a0);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 176));
    TwpsFindSwLights__FP2SWP6VECTORfiiPiT5PP5LIGHT(rdram, ctx, runtime); return;
}


// Function: entry_1668a0
// Address: 0x1668a0 - 0x166948

void entry_1668a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1668a0) {
        switch (ctx->pc) {
            case 0x1668c0: ctx->pc = 0; goto label_1668c0;
            case 0x1668d4: ctx->pc = 0; goto label_1668d4;
            case 0x1668e0: ctx->pc = 0; goto label_1668e0;
            case 0x1668f0: ctx->pc = 0; goto label_1668f0;
            case 0x166914: ctx->pc = 0; goto label_166914;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1668a0: 0x8fa30300
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 768)));
    // 0x1668a4: 0x14600006
    WRITE32(ADD32(GPR_U32(ctx, 29), 156), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1668c0;
    }
    // 0x1668ac: 0x8fa20304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 772)));
    // 0x1668b0: 0x18400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_1668c0;
    }
    // 0x1668b8: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 29), 148), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1668d4;
    }
label_1668c0:
    // 0x1668c0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1668c4: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1668c8: 0x8c4422cc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 8908)));
    // 0x1668cc: 0xafa30094
    WRITE32(ADD32(GPR_U32(ctx, 29), 148), GPR_U32(ctx, 3));
    // 0x1668d0: 0xaee40008
    WRITE32(ADD32(GPR_U32(ctx, 23), 8), GPR_U32(ctx, 4));
label_1668d4:
    // 0x1668d4: 0x8fa2009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 156)));
    // 0x1668d8: 0x10000005
    WRITE32(ADD32(GPR_U32(ctx, 23), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1668f0;
    }
label_1668e0:
    // 0x1668e0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1668e4: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1668e8: 0xafa20094
    WRITE32(ADD32(GPR_U32(ctx, 29), 148), GPR_U32(ctx, 2));
    // 0x1668ec: 0xafa3009c
    WRITE32(ADD32(GPR_U32(ctx, 29), 156), GPR_U32(ctx, 3));
label_1668f0:
    // 0x1668f0: 0x12e00008
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_166914;
    }
    // 0x1668f8: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1668fc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x166900: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x166904: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_166914;
    }
    // 0x16690c: 0x8e020410
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1040)));
    // 0x166910: 0x2f02b
    SET_GPR_U32(ctx, 30, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_166914:
    // 0x166914: 0x17c0000c
    WRITE32(ADD32(GPR_U32(ctx, 29), 776), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        entry_166948(rdram, ctx, runtime); return;
    }
    // 0x16691c: 0x8e82002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 44)));
    // 0x166920: 0x30420003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 3));
    // 0x166924: 0x10400008
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_166948(rdram, ctx, runtime); return;
    }
    // 0x16692c: 0xc68c0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 16)); ctx->f[12] = *(float*)&val; }
    // 0x166930: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x166934: 0x26c50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 22), 96));
    // 0x166938: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x16693c: 0x27a70308
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 776));
    // 0x166940: 0xc06c9e4
    SET_GPR_U32(ctx, 31, 0x166948);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 688));
    FindSwShadows__FP2SWP6VECTORfiPiPP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_166948
// Address: 0x166948 - 0x167784

void entry_166948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x166948) {
        switch (ctx->pc) {
            case 0x166978: ctx->pc = 0; goto label_166978;
            case 0x166984: ctx->pc = 0; goto label_166984;
            case 0x1669c0: ctx->pc = 0; goto label_1669c0;
            case 0x1669f0: ctx->pc = 0; goto label_1669f0;
            case 0x166a14: ctx->pc = 0; goto label_166a14;
            case 0x166a20: ctx->pc = 0; goto label_166a20;
            case 0x166a24: ctx->pc = 0; goto label_166a24;
            case 0x166ac0: ctx->pc = 0; goto label_166ac0;
            case 0x166b10: ctx->pc = 0; goto label_166b10;
            case 0x166b34: ctx->pc = 0; goto label_166b34;
            case 0x166ba0: ctx->pc = 0; goto label_166ba0;
            case 0x166ba4: ctx->pc = 0; goto label_166ba4;
            case 0x166bb0: ctx->pc = 0; goto label_166bb0;
            case 0x166bd4: ctx->pc = 0; goto label_166bd4;
            case 0x166bd8: ctx->pc = 0; goto label_166bd8;
            case 0x166c88: ctx->pc = 0; goto label_166c88;
            case 0x166cc4: ctx->pc = 0; goto label_166cc4;
            case 0x166cf8: ctx->pc = 0; goto label_166cf8;
            case 0x166d40: ctx->pc = 0; goto label_166d40;
            case 0x166d90: ctx->pc = 0; goto label_166d90;
            case 0x166d94: ctx->pc = 0; goto label_166d94;
            case 0x166df0: ctx->pc = 0; goto label_166df0;
            case 0x166e0c: ctx->pc = 0; goto label_166e0c;
            case 0x166e18: ctx->pc = 0; goto label_166e18;
            case 0x166e4c: ctx->pc = 0; goto label_166e4c;
            case 0x166e58: ctx->pc = 0; goto label_166e58;
            case 0x166e70: ctx->pc = 0; goto label_166e70;
            case 0x166e90: ctx->pc = 0; goto label_166e90;
            case 0x166f64: ctx->pc = 0; goto label_166f64;
            case 0x166f94: ctx->pc = 0; goto label_166f94;
            case 0x167060: ctx->pc = 0; goto label_167060;
            case 0x1670a0: ctx->pc = 0; goto label_1670a0;
            case 0x167140: ctx->pc = 0; goto label_167140;
            case 0x167168: ctx->pc = 0; goto label_167168;
            case 0x167200: ctx->pc = 0; goto label_167200;
            case 0x167240: ctx->pc = 0; goto label_167240;
            case 0x1672e0: ctx->pc = 0; goto label_1672e0;
            case 0x167360: ctx->pc = 0; goto label_167360;
            case 0x1673a0: ctx->pc = 0; goto label_1673a0;
            case 0x1674d0: ctx->pc = 0; goto label_1674d0;
            case 0x167510: ctx->pc = 0; goto label_167510;
            case 0x167580: ctx->pc = 0; goto label_167580;
            case 0x1675b4: ctx->pc = 0; goto label_1675b4;
            case 0x1675e4: ctx->pc = 0; goto label_1675e4;
            case 0x167628: ctx->pc = 0; goto label_167628;
            case 0x16768c: ctx->pc = 0; goto label_16768c;
            case 0x1676e4: ctx->pc = 0; goto label_1676e4;
            case 0x16770c: ctx->pc = 0; goto label_16770c;
            case 0x16773c: ctx->pc = 0; goto label_16773c;
            case 0x167764: ctx->pc = 0; goto label_167764;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x166948: 0xc6c00050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 80)); ctx->f[0] = *(float*)&val; }
    // 0x16694c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x166950: 0xafa20098
    WRITE32(ADD32(GPR_U32(ctx, 29), 152), GPR_U32(ctx, 2));
    // 0x166954: 0xe7a00090
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 144), *(uint32_t*)&val); }
    // 0x166958: 0x8e82002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 44)));
    // 0x16695c: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x166960: 0x10400005
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_166978;
    }
    // 0x166968: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16696c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x166970: 0x10000004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 172), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_166984;
    }
label_166978:
    // 0x166978: 0x8c435710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x16697c: 0xc460234c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 9036)); ctx->f[0] = *(float*)&val; }
    // 0x166980: 0xe7a000ac
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 172), *(uint32_t*)&val); }
label_166984:
    // 0x166984: 0x12e00086
    WRITE32(ADD32(GPR_U32(ctx, 29), 780), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_166ba0;
    }
    // 0x16698c: 0x8ee20018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 23), 24)));
    // 0x166990: 0x10400083
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 148)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_166ba0;
    }
    // 0x166998: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x16699c: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1669a0: 0x50400080
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
        goto label_166ba4;
    }
    // 0x1669a8: 0x57c00005
    if (GPR_U32(ctx, 30) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 56)));
        goto label_1669c0;
    }
    // 0x1669b0: 0x8fa20308
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 776)));
    // 0x1669b4: 0x5440007b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
        goto label_166ba4;
    }
    // 0x1669bc: 0x8ea20038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 56)));
label_1669c0:
    // 0x1669c0: 0x30420003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 3));
    // 0x1669c4: 0x54400077
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
        goto label_166ba4;
    }
    // 0x1669cc: 0x13c00015
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        goto label_166a24;
    }
    // 0x1669d4: 0x8e840058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x1669d8: 0x18800011
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 4) <= 0) {
        goto label_166a20;
    }
    // 0x1669e0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1669e4: 0x8ee30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 4)));
    // 0x1669e8: 0x24451858
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x1669ec: 0x0
    // NOP
label_1669f0:
    // 0x1669f0: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x1669f4: 0x10400007
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_166a14;
    }
    // 0x1669fc: 0xc4610018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[1] = *(float*)&val; }
    // 0x166a00: 0xc4a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 4)); ctx->f[0] = *(float*)&val; }
    // 0x166a04: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x166a08: 0x0
    // NOP
    // 0x166a0c: 0x45030065
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
        goto label_166ba4;
    }
label_166a14:
    // 0x166a14: 0x164102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 11), GPR_S32(ctx, 4)));
    // 0x166a18: 0x1440fff5
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 48));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1669f0;
    }
label_166a20:
    // 0x166a20: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
label_166a24:
    // 0x166a24: 0x3c090026
    SET_GPR_U32(ctx, 9, ((uint32_t)38 << 16));
    // 0x166a28: 0x8c852474
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 9332)));
    // 0x166a2c: 0x252b22a8
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x166a30: 0x2402023c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 572));
    // 0x166a34: 0x8d6c000c
    SET_GPR_U32(ctx, 12, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x166a38: 0x451023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x166a3c: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x166a40: 0xac822474
    WRITE32(ADD32(GPR_U32(ctx, 4), 9332), GPR_U32(ctx, 2));
    // 0x166a44: 0x3c080300
    SET_GPR_U32(ctx, 8, ((uint32_t)768 << 16));
    // 0x166a48: 0xfd830000
    WRITE64(ADD32(GPR_U32(ctx, 12), 0), GPR_U64(ctx, 3));
    // 0x166a4c: 0x3c0a0200
    SET_GPR_U32(ctx, 10, ((uint32_t)512 << 16));
    // 0x166a50: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x166a54: 0x3c066c0b
    SET_GPR_U32(ctx, 6, ((uint32_t)27659 << 16));
    // 0x166a58: 0x8d67000c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x166a5c: 0x34c6c000
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 49152));
    // 0x166a60: 0x8c822474
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 9332)));
    // 0x166a64: 0x38a50028
    SET_GPR_U32(ctx, 5, XOR32(GPR_U32(ctx, 5), 40));
    // 0x166a68: 0x24e30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 7), 16));
    // 0x166a6c: 0x5282b
    SET_GPR_U32(ctx, 5, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 5)));
    // 0x166a70: 0xad63000c
    WRITE32(ADD32(GPR_U32(ctx, 11), 12), GPR_U32(ctx, 3));
    // 0x166a74: 0x481025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x166a78: 0xace20010
    WRITE32(ADD32(GPR_U32(ctx, 7), 16), GPR_U32(ctx, 2));
    // 0x166a7c: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x166a80: 0x8d63000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x166a84: 0x24620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4));
    // 0x166a88: 0xad62000c
    WRITE32(ADD32(GPR_U32(ctx, 11), 12), GPR_U32(ctx, 2));
    // 0x166a8c: 0xac6a0004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 10));
    // 0x166a90: 0x8d64000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x166a94: 0x24820004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4));
    // 0x166a98: 0xad62000c
    WRITE32(ADD32(GPR_U32(ctx, 11), 12), GPR_U32(ctx, 2));
    // 0x166a9c: 0xac860004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 6));
    // 0x166aa0: 0x8d62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x166aa4: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x166aa8: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x166aac: 0xad62000c
    WRITE32(ADD32(GPR_U32(ctx, 11), 12), GPR_U32(ctx, 2));
    // 0x166ab0: 0x56880
    SET_GPR_U32(ctx, 13, SLL32(GPR_U32(ctx, 5), 2));
    // 0x166ab4: 0x26e60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 23), 32));
    // 0x166ab8: 0x240a0028
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 40));
    // 0x166abc: 0x0
    // NOP
label_166ac0:
    // 0x166ac0: 0x8d020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x166ac4: 0x254afffc
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4294967292));
    // 0x166ac8: 0x8d030004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 8), 4)));
    // 0x166acc: 0x8d040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 8), 8)));
    // 0x166ad0: 0x8d05000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 8), 12)));
    // 0x166ad4: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
    // 0x166ad8: 0x25080010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 16));
    // 0x166adc: 0xace30004
    WRITE32(ADD32(GPR_U32(ctx, 7), 4), GPR_U32(ctx, 3));
    // 0x166ae0: 0xace40008
    WRITE32(ADD32(GPR_U32(ctx, 7), 8), GPR_U32(ctx, 4));
    // 0x166ae4: 0xace5000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 5));
    // 0x166ae8: 0x541fff5
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    if (GPR_S32(ctx, 10) >= 0) {
        goto label_166ac0;
    }
    // 0x166af0: 0x8d62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x166af4: 0x252522a8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x166af8: 0x244200b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 176));
    // 0x166afc: 0xad62000c
    WRITE32(ADD32(GPR_U32(ctx, 11), 12), GPR_U32(ctx, 2));
    // 0x166b00: 0x8ca4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x166b04: 0x3082000f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 15));
    // 0x166b08: 0x5040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 12), 0)));
        goto label_166b34;
    }
label_166b10:
    // 0x166b10: 0xac800000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 0));
    // 0x166b14: 0x8ca2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x166b18: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x166b1c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x166b20: 0x3083000f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), 15));
    // 0x166b24: 0x1460fffa
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_166b10;
    }
    // 0x166b2c: 0x252522a8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x166b30: 0x8d840000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 12), 0)));
label_166b34:
    // 0x166b34: 0x8ca2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x166b38: 0xcd3021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 13)));
    // 0x166b3c: 0x3c075000
    SET_GPR_U32(ctx, 7, ((uint32_t)20480 << 16));
    // 0x166b40: 0x4c1023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 12)));
    // 0x166b44: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x166b48: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x166b4c: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x166b50: 0xad840000
    WRITE32(ADD32(GPR_U32(ctx, 12), 0), GPR_U32(ctx, 4));
    // 0x166b54: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x166b58: 0x8ca4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x166b5c: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x166b60: 0x671825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x166b64: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x166b68: 0x8ca2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x166b6c: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x166b70: 0xaca2000c
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 2));
    // 0x166b74: 0x8e830060
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 96)));
    // 0x166b78: 0x8e820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x166b7c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x166b80: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x166b84: 0x14400459
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 944)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x167CEC; return;
    }
    // 0x166b8c: 0x8e632474
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 9332)));
    // 0x166b90: 0x2402023c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 572));
    // 0x166b94: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x166b98: 0x10000454
    WRITE32(ADD32(GPR_U32(ctx, 19), 9332), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x167CEC; return;
    }
label_166ba0:
    // 0x166ba0: 0x8e820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
label_166ba4:
    // 0x166ba4: 0x1840031c
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x167818; return;
    }
    // 0x166bac: 0x24020050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
label_166bb0:
    // 0x166bb0: 0x8e83005c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 92)));
    // 0x166bb4: 0x1621018
    { int64_t result = (int64_t)GPR_S32(ctx, 11) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x166bb8: 0x12e00006
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        goto label_166bd4;
    }
    // 0x166bc0: 0x24020030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    // 0x166bc4: 0x8ee30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 23), 4)));
    // 0x166bc8: 0x1621018
    { int64_t result = (int64_t)GPR_S32(ctx, 11) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x166bcc: 0x10000002
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_166bd8;
    }
label_166bd4:
    // 0x166bd4: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_166bd8:
    // 0x166bd8: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x166bdc: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x166be0: 0x8ca32474
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 9332)));
    // 0x166be4: 0x24ca22a8
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 6), 8872));
    // 0x166be8: 0x2402023c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 572));
    // 0x166bec: 0x8d4f000c
    SET_GPR_U32(ctx, 15, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x166bf0: 0x431023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x166bf4: 0x3c041000
    SET_GPR_U32(ctx, 4, ((uint32_t)4096 << 16));
    // 0x166bf8: 0xaca22474
    WRITE32(ADD32(GPR_U32(ctx, 5), 9332), GPR_U32(ctx, 2));
    // 0x166bfc: 0x256b0001
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 11), 1));
    // 0x166c00: 0xfde40000
    WRITE64(ADD32(GPR_U32(ctx, 15), 0), GPR_U64(ctx, 4));
    // 0x166c04: 0x3c070300
    SET_GPR_U32(ctx, 7, ((uint32_t)768 << 16));
    // 0x166c08: 0xafab0310
    WRITE32(ADD32(GPR_U32(ctx, 29), 784), GPR_U32(ctx, 11));
    // 0x166c0c: 0x3c080200
    SET_GPR_U32(ctx, 8, ((uint32_t)512 << 16));
    // 0x166c10: 0x8fa3030c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 780)));
    // 0x166c14: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x166c18: 0x8d44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x166c1c: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x166c20: 0x8ca22474
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 9332)));
    // 0x166c24: 0xafa3030c
    WRITE32(ADD32(GPR_U32(ctx, 29), 780), GPR_U32(ctx, 3));
    // 0x166c28: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x166c2c: 0x24830010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 16));
    // 0x166c30: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x166c34: 0xad43000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 3));
    // 0x166c38: 0xac820010
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 2));
    // 0x166c3c: 0x8d43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x166c40: 0x24620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4));
    // 0x166c44: 0xad42000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 2));
    // 0x166c48: 0xac680004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 8));
    // 0x166c4c: 0x8d44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x166c50: 0x24820004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4));
    // 0x166c54: 0xad42000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 2));
    // 0x166c58: 0x8fa2030c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 780)));
    // 0x166c5c: 0x14450019
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 5)) {
        goto label_166cc4;
    }
    // 0x166c64: 0x3c036c0b
    SET_GPR_U32(ctx, 3, ((uint32_t)27659 << 16));
    // 0x166c68: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x166c6c: 0x3463c000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 49152));
    // 0x166c70: 0xac830004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 3));
    // 0x166c74: 0x8d42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x166c78: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x166c7c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x166c80: 0xad42000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 2));
    // 0x166c84: 0x24080028
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 40));
label_166c88:
    // 0x166c88: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x166c8c: 0x2508fffc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967292));
    // 0x166c90: 0x8ce30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x166c94: 0x8ce40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x166c98: 0x8ce5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x166c9c: 0xacc20000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    // 0x166ca0: 0x24e70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    // 0x166ca4: 0xacc30004
    WRITE32(ADD32(GPR_U32(ctx, 6), 4), GPR_U32(ctx, 3));
    // 0x166ca8: 0xacc40008
    WRITE32(ADD32(GPR_U32(ctx, 6), 8), GPR_U32(ctx, 4));
    // 0x166cac: 0xacc5000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 5));
    // 0x166cb0: 0x501fff5
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    if (GPR_S32(ctx, 8) >= 0) {
        goto label_166c88;
    }
    // 0x166cb8: 0x8d42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x166cbc: 0x244200b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 176));
    // 0x166cc0: 0xad42000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 2));
label_166cc4:
    // 0x166cc4: 0x8e030024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x166cc8: 0x58600032
    if (GPR_S32(ctx, 3) <= 0) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 21), 64)));
        goto label_166d94;
    }
    // 0x166cd0: 0x8e02001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x166cd4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x166cd8: 0x1860002d
    SET_GPR_U32(ctx, 10, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 4)));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_166d90;
    }
    // 0x166ce0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x166ce4: 0x3c0d6c04
    SET_GPR_U32(ctx, 13, ((uint32_t)27652 << 16));
    // 0x166ce8: 0x244b22a8
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 2), 8872));
    // 0x166cec: 0x260e0028
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 16), 40));
    // 0x166cf0: 0x24120090
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 144));
    // 0x166cf4: 0x35adc000
    SET_GPR_U32(ctx, 13, OR32(GPR_U32(ctx, 13), 49152));
label_166cf8:
    // 0x166cf8: 0x81880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 8), 2));
    // 0x166cfc: 0x8d65000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x166d00: 0x1c31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 3)));
    // 0x166d04: 0x8ea60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x166d08: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x166d0c: 0x14d1025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 10), GPR_U32(ctx, 13)));
    // 0x166d10: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x166d14: 0x922018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x166d18: 0x8d62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x166d1c: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x166d20: 0x862021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x166d24: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x166d28: 0x24860050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 80));
    // 0x166d2c: 0xad62000c
    WRITE32(ADD32(GPR_U32(ctx, 11), 12), GPR_U32(ctx, 2));
    // 0x166d30: 0x254c0004
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 10), 4));
    // 0x166d34: 0x250a0001
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 8), 1));
    // 0x166d38: 0x2408000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 12));
    // 0x166d3c: 0x0
    // NOP
label_166d40:
    // 0x166d40: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x166d44: 0x2508fffc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967292));
    // 0x166d48: 0x8cc30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x166d4c: 0x8cc40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x166d50: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x166d54: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
    // 0x166d58: 0x24c60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    // 0x166d5c: 0xace30004
    WRITE32(ADD32(GPR_U32(ctx, 7), 4), GPR_U32(ctx, 3));
    // 0x166d60: 0xace40008
    WRITE32(ADD32(GPR_U32(ctx, 7), 8), GPR_U32(ctx, 4));
    // 0x166d64: 0xace5000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 5));
    // 0x166d68: 0x501fff5
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    if (GPR_S32(ctx, 8) >= 0) {
        goto label_166d40;
    }
    // 0x166d70: 0x8d63000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x166d74: 0x140402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x166d78: 0x24630040
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 64));
    // 0x166d7c: 0xad63000c
    WRITE32(ADD32(GPR_U32(ctx, 11), 12), GPR_U32(ctx, 3));
    // 0x166d80: 0x8e020024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 36)));
    // 0x166d84: 0x102102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 2)));
    // 0x166d88: 0x1440ffdb
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 12) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_166cf8;
    }
label_166d90:
    // 0x166d90: 0x8ea70040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 21), 64)));
label_166d94:
    // 0x166d94: 0x18e00030
    SET_GPR_U32(ctx, 2, ((uint32_t)24576 << 16));
    if (GPR_S32(ctx, 7) <= 0) {
        goto label_166e58;
    }
    // 0x166d9c: 0x8e04001c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x166da0: 0x252c22a8
    SET_GPR_S32(ctx, 12, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x166da4: 0x71c00
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 7), 16));
    // 0x166da8: 0x94850006
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 4), 6)));
    // 0x166dac: 0x3442c000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 49152));
    // 0x166db0: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x166db4: 0x8d84000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 12), 12)));
    // 0x166db8: 0x8ea60044
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 21), 68)));
    // 0x166dbc: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x166dc0: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    // 0x166dc4: 0x76880
    SET_GPR_U32(ctx, 13, SLL32(GPR_U32(ctx, 7), 2));
    // 0x166dc8: 0xd1883
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 13), 2));
    // 0x166dcc: 0xc0502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x166dd0: 0x8d82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 12), 12)));
    // 0x166dd4: 0x30660003
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 3), 3));
    // 0x166dd8: 0x665823
    SET_GPR_U32(ctx, 11, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x166ddc: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x166de0: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x166de4: 0x10c00009
    WRITE32(ADD32(GPR_U32(ctx, 12), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_166e0c;
    }
    // 0x166dec: 0xc0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
label_166df0:
    // 0x166df0: 0x8d420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 10), 0)));
    // 0x166df4: 0x2508ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967295));
    // 0x166df8: 0x254a0004
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 4));
    // 0x166dfc: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
    // 0x166e00: 0x0
    // NOP
    // 0x166e04: 0x1500fffa
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    if (GPR_U32(ctx, 8) != GPR_U32(ctx, 0)) {
        goto label_166df0;
    }
label_166e0c:
    // 0x166e0c: 0x1960000f
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 11) <= 0) {
        goto label_166e4c;
    }
    // 0x166e14: 0x0
    // NOP
label_166e18:
    // 0x166e18: 0x8d440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 10), 0)));
    // 0x166e1c: 0x25080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4));
    // 0x166e20: 0x8d450004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 10), 4)));
    // 0x166e24: 0x10b302a
    SET_GPR_U32(ctx, 6, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 11)));
    // 0x166e28: 0x8d420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 10), 8)));
    // 0x166e2c: 0x8d43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x166e30: 0xace40000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 4));
    // 0x166e34: 0x254a0010
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 10), 16));
    // 0x166e38: 0xace50004
    WRITE32(ADD32(GPR_U32(ctx, 7), 4), GPR_U32(ctx, 5));
    // 0x166e3c: 0xace20008
    WRITE32(ADD32(GPR_U32(ctx, 7), 8), GPR_U32(ctx, 2));
    // 0x166e40: 0xace3000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 3));
    // 0x166e44: 0x14c0fff4
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_166e18;
    }
label_166e4c:
    // 0x166e4c: 0x8d82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 12), 12)));
    // 0x166e50: 0x4d1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 13)));
    // 0x166e54: 0xad82000c
    WRITE32(ADD32(GPR_U32(ctx, 12), 12), GPR_U32(ctx, 2));
label_166e58:
    // 0x166e58: 0x252522a8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x166e5c: 0x8ca4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x166e60: 0x3082000f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 15));
    // 0x166e64: 0x1040000a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 9), 8872));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_166e90;
    }
    // 0x166e6c: 0x0
    // NOP
label_166e70:
    // 0x166e70: 0xac800000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 0));
    // 0x166e74: 0x8ca2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x166e78: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x166e7c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x166e80: 0x3083000f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), 15));
    // 0x166e84: 0x1460fffa
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_166e70;
    }
    // 0x166e8c: 0x252322a8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 9), 8872));
label_166e90:
    // 0x166e90: 0x8de40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 15), 0)));
    // 0x166e94: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x166e98: 0x4f1023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 15)));
    // 0x166e9c: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x166ea0: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x166ea4: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x166ea8: 0xade40000
    WRITE32(ADD32(GPR_U32(ctx, 15), 0), GPR_U32(ctx, 4));
    // 0x166eac: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x166eb0: 0x90440000
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x166eb4: 0x2c83000b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 11));
    // 0x166eb8: 0x10600252
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x167804; return;
    }
    // 0x166ec0: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x166ec4: 0x2442a750
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294944592));
    // 0x166ec8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x166ecc: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x166ed0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x166ed8: 0x8e040038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x166edc: 0x252622a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x166ee0: 0x8e030044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    // 0x166ee4: 0x3c024000
    SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
    // 0x166ee8: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x166eec: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x166ef0: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x166ef4: 0x832025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x166ef8: 0xfca40000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 4));
    // 0x166efc: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x166f00: 0x8fa40094
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 148)));
    // 0x166f04: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x166f08: 0x2c830005
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 5));
    // 0x166f0c: 0x1060020b
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_16773c;
    }
    // 0x166f14: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x166f18: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x166f1c: 0x2442a780
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294944640));
    // 0x166f20: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x166f24: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x166f28: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x166f30: 0x8e820054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 84)));
    // 0x166f34: 0x1040000b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 9), 8872));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_166f64;
    }
    // 0x166f3c: 0x8e03004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x166f40: 0x8c85000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x166f44: 0x3c025000
    SET_GPR_U32(ctx, 2, ((uint32_t)20480 << 16));
    // 0x166f48: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x166f4c: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x166f50: 0xfca30000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 3));
    // 0x166f54: 0x8c82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x166f58: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x166f5c: 0x1000000d
    WRITE32(ADD32(GPR_U32(ctx, 4), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_166f94;
    }
label_166f64:
    // 0x166f64: 0x8e040040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x166f68: 0x252622a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x166f6c: 0x8e03004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x166f70: 0x3c024000
    SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
    // 0x166f74: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x166f78: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x166f7c: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x166f80: 0x832025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x166f84: 0xfca40000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 4));
    // 0x166f88: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x166f8c: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x166f90: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
label_166f94:
    // 0x166f94: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x166f98: 0x252522a8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x166f9c: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x166fa0: 0x3c074000
    SET_GPR_U32(ctx, 7, ((uint32_t)16384 << 16));
    // 0x166fa4: 0x8ca4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x166fa8: 0x671825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x166fac: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x166fb0: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x166fb4: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x166fb8: 0x8ca6000c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x166fbc: 0x24c20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 16));
    // 0x166fc0: 0xaca2000c
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 2));
    // 0x166fc4: 0x8e23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x166fc8: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x166fcc: 0x671825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x166fd0: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x166fd4: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x166fd8: 0xfcc30010
    WRITE64(ADD32(GPR_U32(ctx, 6), 16), GPR_U64(ctx, 3));
    // 0x166fdc: 0x8ca2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x166fe0: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x166fe4: 0x100001d5
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16773c;
    }
    // 0x166fec: 0x8e23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x166ff0: 0x252622a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x166ff4: 0x8e220010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x166ff8: 0x3c054000
    SET_GPR_U32(ctx, 5, ((uint32_t)16384 << 16));
    // 0x166ffc: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167000: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x167004: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x167008: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16700c: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x167010: 0x3c0c0000
    SET_GPR_U32(ctx, 12, ((uint32_t)0 << 16));
    // 0x167014: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x167018: 0x3c0d0000
    SET_GPR_U32(ctx, 13, ((uint32_t)0 << 16));
    // 0x16701c: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167020: 0x24820010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 16));
    // 0x167024: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    // 0x167028: 0x8e03003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x16702c: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x167030: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x167034: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x167038: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x16703c: 0xfc830010
    WRITE64(ADD32(GPR_U32(ctx, 4), 16), GPR_U64(ctx, 3));
    // 0x167040: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167044: 0x8fa30304
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 772)));
    // 0x167048: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x16704c: 0x18600014
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_1670a0;
    }
    // 0x167054: 0x3c074000
    SET_GPR_U32(ctx, 7, ((uint32_t)16384 << 16));
    // 0x167058: 0x27a500b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    // 0x16705c: 0x0
    // NOP
label_167060:
    // 0x167060: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x167064: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x167068: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x16706c: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x167070: 0x8c620418
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1048)));
    // 0x167074: 0x24630420
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1056));
    // 0x167078: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x16707c: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x167080: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x167084: 0xfc820000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
    // 0x167088: 0x8cc3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x16708c: 0x8fa20304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 772)));
    // 0x167090: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x167094: 0x102102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 2)));
    // 0x167098: 0x1440fff1
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_167060;
    }
label_1670a0:
    // 0x1670a0: 0x252722a8
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x1670a4: 0x3c051000
    SET_GPR_U32(ctx, 5, ((uint32_t)4096 << 16));
    // 0x1670a8: 0x34a50001
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1));
    // 0x1670ac: 0x8ce4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x1670b0: 0x25831210
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 12), 4624));
    // 0x1670b4: 0x3c021400
    SET_GPR_U32(ctx, 2, ((uint32_t)5120 << 16));
    // 0x1670b8: 0x318c2
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 3));
    // 0x1670bc: 0xfc850000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 5));
    // 0x1670c0: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1670c4: 0x3c061000
    SET_GPR_U32(ctx, 6, ((uint32_t)4096 << 16));
    // 0x1670c8: 0x8ce4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x1670cc: 0x24820010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 16));
    // 0x1670d0: 0xace2000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
    // 0x1670d4: 0xac830010
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 3));
    // 0x1670d8: 0x8ce5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x1670dc: 0x24a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1670e0: 0xace2000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
    // 0x1670e4: 0xaca60004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 6));
    // 0x1670e8: 0x8ce3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x1670ec: 0x24620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1670f0: 0xace2000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
    // 0x1670f4: 0xac600004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 0));
    // 0x1670f8: 0x8ce4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x1670fc: 0x24820004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4));
    // 0x167100: 0xace2000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
    // 0x167104: 0xac800004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 0));
    // 0x167108: 0x8ce5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x16710c: 0x24a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4));
    // 0x167110: 0xace2000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
    // 0x167114: 0x8e830054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 84)));
    // 0x167118: 0x10600009
    SET_GPR_U32(ctx, 3, ((uint32_t)20480 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_167140;
    }
    // 0x167120: 0x8e02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x167124: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x167128: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16712c: 0xfca20004
    WRITE64(ADD32(GPR_U32(ctx, 5), 4), GPR_U64(ctx, 2));
    // 0x167130: 0x8ce3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x167134: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x167138: 0x1000000b
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_167168;
    }
label_167140:
    // 0x167140: 0x8e030040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x167144: 0x3c044000
    SET_GPR_U32(ctx, 4, ((uint32_t)16384 << 16));
    // 0x167148: 0x8e02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x16714c: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x167150: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x167154: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x167158: 0xfca30004
    WRITE64(ADD32(GPR_U32(ctx, 5), 4), GPR_U64(ctx, 3));
    // 0x16715c: 0x8ce2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x167160: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x167164: 0xace2000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
label_167168:
    // 0x167168: 0x252622a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x16716c: 0x3c051000
    SET_GPR_U32(ctx, 5, ((uint32_t)4096 << 16));
    // 0x167170: 0x34a50001
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1));
    // 0x167174: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167178: 0x25a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 13), 16));
    // 0x16717c: 0x3c021400
    SET_GPR_U32(ctx, 2, ((uint32_t)5120 << 16));
    // 0x167180: 0x318c2
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 3));
    // 0x167184: 0xfc850000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 5));
    // 0x167188: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x16718c: 0x3c071000
    SET_GPR_U32(ctx, 7, ((uint32_t)4096 << 16));
    // 0x167190: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167194: 0x24820010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 16));
    // 0x167198: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    // 0x16719c: 0xac830010
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 3));
    // 0x1671a0: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1671a4: 0x24a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1671a8: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    // 0x1671ac: 0x1000011e
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 7));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_167628;
    }
    // 0x1671b4: 0x8e04003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x1671b8: 0x252622a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x1671bc: 0x8e030048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x1671c0: 0x3c024000
    SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
    // 0x1671c4: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1671c8: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1671cc: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1671d0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1671d4: 0x832025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1671d8: 0x3c0c0000
    SET_GPR_U32(ctx, 12, ((uint32_t)0 << 16));
    // 0x1671dc: 0xfca40000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 4));
    // 0x1671e0: 0x3c0d0000
    SET_GPR_U32(ctx, 13, ((uint32_t)0 << 16));
    // 0x1671e4: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1671e8: 0x8fa30304
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 772)));
    // 0x1671ec: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1671f0: 0x18600013
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_167240;
    }
    // 0x1671f8: 0x3c074000
    SET_GPR_U32(ctx, 7, ((uint32_t)16384 << 16));
    // 0x1671fc: 0x27a500b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
label_167200:
    // 0x167200: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x167204: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x167208: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x16720c: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x167210: 0x8c620418
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1048)));
    // 0x167214: 0x24630420
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1056));
    // 0x167218: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x16721c: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x167220: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x167224: 0xfc820000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
    // 0x167228: 0x8cc3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x16722c: 0x8fa20304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 772)));
    // 0x167230: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x167234: 0x102102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 2)));
    // 0x167238: 0x1440fff1
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_167200;
    }
label_167240:
    // 0x167240: 0x252722a8
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x167244: 0x3c051000
    SET_GPR_U32(ctx, 5, ((uint32_t)4096 << 16));
    // 0x167248: 0x34a50001
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1));
    // 0x16724c: 0x8ce4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x167250: 0x25831210
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 12), 4624));
    // 0x167254: 0x3c021400
    SET_GPR_U32(ctx, 2, ((uint32_t)5120 << 16));
    // 0x167258: 0x318c2
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 3));
    // 0x16725c: 0xfc850000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 5));
    // 0x167260: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x167264: 0x3c061000
    SET_GPR_U32(ctx, 6, ((uint32_t)4096 << 16));
    // 0x167268: 0x8ce4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x16726c: 0x24820010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 16));
    // 0x167270: 0xace2000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
    // 0x167274: 0xac830010
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 3));
    // 0x167278: 0x8ce5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x16727c: 0x24a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4));
    // 0x167280: 0xace2000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
    // 0x167284: 0xaca60004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 6));
    // 0x167288: 0x8ce3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x16728c: 0x24620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4));
    // 0x167290: 0xace2000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
    // 0x167294: 0xac600004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 0));
    // 0x167298: 0x8ce4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x16729c: 0x24820004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4));
    // 0x1672a0: 0xace2000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
    // 0x1672a4: 0xac800004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 0));
    // 0x1672a8: 0x8ce5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x1672ac: 0x24a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1672b0: 0xace2000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
    // 0x1672b4: 0x8e830054
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 84)));
    // 0x1672b8: 0x10600009
    SET_GPR_U32(ctx, 3, ((uint32_t)20480 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1672e0;
    }
    // 0x1672c0: 0x8e02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x1672c4: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1672c8: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1672cc: 0xfca20004
    WRITE64(ADD32(GPR_U32(ctx, 5), 4), GPR_U64(ctx, 2));
    // 0x1672d0: 0x8ce3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x1672d4: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x1672d8: 0x100000c2
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1675e4;
    }
label_1672e0:
    // 0x1672e0: 0x8e030040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1672e4: 0x3c044000
    SET_GPR_U32(ctx, 4, ((uint32_t)16384 << 16));
    // 0x1672e8: 0x8e02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x1672ec: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1672f0: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1672f4: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1672f8: 0xfca30004
    WRITE64(ADD32(GPR_U32(ctx, 5), 4), GPR_U64(ctx, 3));
    // 0x1672fc: 0x8ce2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x167300: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x167304: 0x100000b7
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1675e4;
    }
    // 0x16730c: 0x8e04003c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x167310: 0x252622a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x167314: 0x8e030048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x167318: 0x3c024000
    SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
    // 0x16731c: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x167320: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167324: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x167328: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16732c: 0x832025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x167330: 0x3c0c0000
    SET_GPR_U32(ctx, 12, ((uint32_t)0 << 16));
    // 0x167334: 0xfca40000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 4));
    // 0x167338: 0x3c0d0000
    SET_GPR_U32(ctx, 13, ((uint32_t)0 << 16));
    // 0x16733c: 0x3c0b0026
    SET_GPR_U32(ctx, 11, ((uint32_t)38 << 16));
    // 0x167340: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167344: 0x8fa30300
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 768)));
    // 0x167348: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x16734c: 0x18600014
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_1673a0;
    }
    // 0x167354: 0x3c074000
    SET_GPR_U32(ctx, 7, ((uint32_t)16384 << 16));
    // 0x167358: 0x27a500b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    // 0x16735c: 0x0
    // NOP
label_167360:
    // 0x167360: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x167364: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x167368: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x16736c: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x167370: 0x8c620418
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1048)));
    // 0x167374: 0x24630420
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1056));
    // 0x167378: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x16737c: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x167380: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x167384: 0xfc820000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
    // 0x167388: 0x8cc3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x16738c: 0x8fa20300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 768)));
    // 0x167390: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x167394: 0x102102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 2)));
    // 0x167398: 0x1440fff1
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_167360;
    }
label_1673a0:
    // 0x1673a0: 0x252a22a8
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x1673a4: 0x3c051000
    SET_GPR_U32(ctx, 5, ((uint32_t)4096 << 16));
    // 0x1673a8: 0x34a50001
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1));
    // 0x1673ac: 0x8d43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x1673b0: 0x25841210
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 12), 4624));
    // 0x1673b4: 0x3c021400
    SET_GPR_U32(ctx, 2, ((uint32_t)5120 << 16));
    // 0x1673b8: 0x420c2
    SET_GPR_U32(ctx, 4, SRL32(GPR_U32(ctx, 4), 3));
    // 0x1673bc: 0xfc650000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 5));
    // 0x1673c0: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1673c4: 0x3c069000
    SET_GPR_U32(ctx, 6, ((uint32_t)36864 << 16));
    // 0x1673c8: 0x3c071100
    SET_GPR_U32(ctx, 7, ((uint32_t)4352 << 16));
    // 0x1673cc: 0x8d45000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x1673d0: 0x34e7c000
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 49152));
    // 0x1673d4: 0x24a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 16));
    // 0x1673d8: 0xad42000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 2));
    // 0x1673dc: 0xaca40010
    WRITE32(ADD32(GPR_U32(ctx, 5), 16), GPR_U32(ctx, 4));
    // 0x1673e0: 0x8d43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x1673e4: 0x24620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1673e8: 0xad42000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 2));
    // 0x1673ec: 0xac660004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 6));
    // 0x1673f0: 0x8d44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x1673f4: 0x24820004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4));
    // 0x1673f8: 0xad42000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 2));
    // 0x1673fc: 0xac800004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 0));
    // 0x167400: 0x8d43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x167404: 0x24620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4));
    // 0x167408: 0xad42000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 2));
    // 0x16740c: 0xac600004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 0));
    // 0x167410: 0x8d42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x167414: 0x8e642474
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9332)));
    // 0x167418: 0x8d6322d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 11), 8912)));
    // 0x16741c: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x167420: 0xad42000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 2));
    // 0x167424: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x167428: 0x8e05001c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x16742c: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x167430: 0xad6322d0
    WRITE32(ADD32(GPR_U32(ctx, 11), 8912), GPR_U32(ctx, 3));
    // 0x167434: 0x94a20000
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x167438: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x16743c: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x167440: 0x471021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x167444: 0xacc20000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    // 0x167448: 0x8e03001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x16744c: 0x94620002
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 2)));
    // 0x167450: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x167454: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x167458: 0x471021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x16745c: 0xacc20004
    WRITE32(ADD32(GPR_U32(ctx, 6), 4), GPR_U32(ctx, 2));
    // 0x167460: 0x8e03001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 28)));
    // 0x167464: 0x9462000e
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 14)));
    // 0x167468: 0xacd1000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 17));
    // 0x16746c: 0x822021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x167470: 0x42100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 4));
    // 0x167474: 0x872021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 7)));
    // 0x167478: 0xacc40008
    WRITE32(ADD32(GPR_U32(ctx, 6), 8), GPR_U32(ctx, 4));
    // 0x16747c: 0x8fa20304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 772)));
    // 0x167480: 0x102102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 2)));
    // 0x167484: 0x1040003e
    SET_GPR_U32(ctx, 4, ((uint32_t)16384 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_167580;
    }
    // 0x16748c: 0x8e03003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x167490: 0x8e020048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 72)));
    // 0x167494: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x167498: 0x8d45000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x16749c: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x1674a0: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x1674a4: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1674a8: 0xfca30000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 3));
    // 0x1674ac: 0x8d42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x1674b0: 0x8fa30304
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 772)));
    // 0x1674b4: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1674b8: 0x18600015
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_167510;
    }
    // 0x1674c0: 0x140302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x1674c4: 0x3c074000
    SET_GPR_U32(ctx, 7, ((uint32_t)16384 << 16));
    // 0x1674c8: 0x27a500b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 176));
    // 0x1674cc: 0x0
    // NOP
label_1674d0:
    // 0x1674d0: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1674d4: 0x25080001
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 1));
    // 0x1674d8: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1674dc: 0x24a50004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    // 0x1674e0: 0x8c620418
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1048)));
    // 0x1674e4: 0x24630420
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1056));
    // 0x1674e8: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1674ec: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1674f0: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1674f4: 0xfc820000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 2));
    // 0x1674f8: 0x8cc3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1674fc: 0x8fa20304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 772)));
    // 0x167500: 0x24630010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 16));
    // 0x167504: 0x102102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 2)));
    // 0x167508: 0x1440fff1
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1674d0;
    }
label_167510:
    // 0x167510: 0x252622a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x167514: 0x3c051000
    SET_GPR_U32(ctx, 5, ((uint32_t)4096 << 16));
    // 0x167518: 0x34a50001
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1));
    // 0x16751c: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167520: 0x25831210
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 12), 4624));
    // 0x167524: 0x3c021400
    SET_GPR_U32(ctx, 2, ((uint32_t)5120 << 16));
    // 0x167528: 0x318c2
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 3));
    // 0x16752c: 0xfc850000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 5));
    // 0x167530: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x167534: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167538: 0x24820010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 16));
    // 0x16753c: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    // 0x167540: 0xac830010
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 3));
    // 0x167544: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167548: 0x24a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4));
    // 0x16754c: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    // 0x167550: 0xaca00004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 0));
    // 0x167554: 0x8cc3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167558: 0x24620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4));
    // 0x16755c: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    // 0x167560: 0xac600004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 0));
    // 0x167564: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167568: 0x24820004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4));
    // 0x16756c: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    // 0x167570: 0xac800004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 0));
    // 0x167574: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167578: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x16757c: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
label_167580:
    // 0x167580: 0x8e820054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 84)));
    // 0x167584: 0x1040000b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 9), 8872));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1675b4;
    }
    // 0x16758c: 0x8e03004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x167590: 0x8c85000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x167594: 0x3c025000
    SET_GPR_U32(ctx, 2, ((uint32_t)20480 << 16));
    // 0x167598: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x16759c: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1675a0: 0xfca30000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 3));
    // 0x1675a4: 0x8c82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x1675a8: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1675ac: 0x1000000d
    WRITE32(ADD32(GPR_U32(ctx, 4), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1675e4;
    }
label_1675b4:
    // 0x1675b4: 0x8e040040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x1675b8: 0x252622a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x1675bc: 0x8e03004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x1675c0: 0x3c024000
    SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
    // 0x1675c4: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1675c8: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1675cc: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1675d0: 0x832025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1675d4: 0xfca40000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 4));
    // 0x1675d8: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1675dc: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1675e0: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
label_1675e4:
    // 0x1675e4: 0x252622a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x1675e8: 0x3c051000
    SET_GPR_U32(ctx, 5, ((uint32_t)4096 << 16));
    // 0x1675ec: 0x34a50001
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 1));
    // 0x1675f0: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1675f4: 0x25a30010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 13), 16));
    // 0x1675f8: 0x3c021500
    SET_GPR_U32(ctx, 2, ((uint32_t)5376 << 16));
    // 0x1675fc: 0x318c2
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 3));
    // 0x167600: 0xfc850000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 5));
    // 0x167604: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x167608: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x16760c: 0x24820010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 16));
    // 0x167610: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    // 0x167614: 0xac830010
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 3));
    // 0x167618: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x16761c: 0x24a20004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4));
    // 0x167620: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    // 0x167624: 0xaca00004
    WRITE32(ADD32(GPR_U32(ctx, 5), 4), GPR_U32(ctx, 0));
label_167628:
    // 0x167628: 0x8cc3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x16762c: 0x24620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4));
    // 0x167630: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    // 0x167634: 0xac600004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 0));
    // 0x167638: 0x8cc4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x16763c: 0x24820004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4));
    // 0x167640: 0xacc2000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    // 0x167644: 0xac800004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 0));
    // 0x167648: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x16764c: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x167650: 0x1000003a
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16773c;
    }
    // 0x167658: 0x8e820054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 84)));
    // 0x16765c: 0x1040000b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 9), 8872));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16768c;
    }
    // 0x167664: 0x8e030044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    // 0x167668: 0x8c85000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x16766c: 0x3c025000
    SET_GPR_U32(ctx, 2, ((uint32_t)20480 << 16));
    // 0x167670: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x167674: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x167678: 0xfca30000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 3));
    // 0x16767c: 0x8c82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x167680: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x167684: 0x1000002d
    WRITE32(ADD32(GPR_U32(ctx, 4), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16773c;
    }
label_16768c:
    // 0x16768c: 0x8e040038
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x167690: 0x252622a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x167694: 0x8e030044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    // 0x167698: 0x3c024000
    SET_GPR_U32(ctx, 2, ((uint32_t)16384 << 16));
    // 0x16769c: 0x822025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x1676a0: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1676a4: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1676a8: 0x832025
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1676ac: 0xfca40000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 4));
    // 0x1676b0: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x1676b4: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x1676b8: 0x10000020
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16773c;
    }
    // 0x1676c0: 0x8e820054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 84)));
    // 0x1676c4: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 68)));
        goto label_1676e4;
    }
    // 0x1676cc: 0x1000000f
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 68)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16770c;
    }
    // 0x1676d4: 0x8e820054
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 84)));
    // 0x1676d8: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 68)));
        goto label_16770c;
    }
    // 0x1676e0: 0x8e030044
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 68)));
label_1676e4:
    // 0x1676e4: 0x252422a8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x1676e8: 0x8c85000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x1676ec: 0x3c025000
    SET_GPR_U32(ctx, 2, ((uint32_t)20480 << 16));
    // 0x1676f0: 0x3183c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 0));
    // 0x1676f4: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1676f8: 0xfca30000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 3));
    // 0x1676fc: 0x8c82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 12)));
    // 0x167700: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x167704: 0x1000003f
    WRITE32(ADD32(GPR_U32(ctx, 4), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x167804; return;
    }
label_16770c:
    // 0x16770c: 0x252622a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 9), 8872));
    // 0x167710: 0x8e030038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x167714: 0x3c044000
    SET_GPR_U32(ctx, 4, ((uint32_t)16384 << 16));
    // 0x167718: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x16771c: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167720: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x167724: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x167728: 0xfca30000
    WRITE64(ADD32(GPR_U32(ctx, 5), 0), GPR_U64(ctx, 3));
    // 0x16772c: 0x8cc2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167730: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x167734: 0x10000033
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x167804; return;
    }
label_16773c:
    // 0x16773c: 0x13c00009
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        goto label_167764;
    }
    // 0x167744: 0xc6210018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 24)); ctx->f[1] = *(float*)&val; }
    // 0x167748: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x16774c: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x167750: 0x0
    // NOP
    // 0x167754: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 29), 776), GPR_U32(ctx, 0));
        goto label_167764;
    }
    // 0x16775c: 0x8e22001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 28)));
    // 0x167760: 0xafa20308
    WRITE32(ADD32(GPR_U32(ctx, 29), 776), GPR_U32(ctx, 2));
label_167764:
    // 0x167764: 0x8fa20308
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 776)));
    // 0x167768: 0x1040000a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x167794; return;
    }
    // 0x167770: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x167774: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x167778: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16777c: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x167784);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 752));
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_167784
// Address: 0x167784 - 0x1677c4

void entry_167784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x167784) {
        switch (ctx->pc) {
            case 0x167794: ctx->pc = 0; goto label_167794;
            case 0x1677a8: ctx->pc = 0; goto label_1677a8;
            case 0x1677b8: ctx->pc = 0; goto label_1677b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x167784: 0xc6010010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16)); ctx->f[1] = *(float*)&val; }
    // 0x167788: 0xc6800050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 80)); ctx->f[0] = *(float*)&val; }
    // 0x16778c: 0x46000d02
    ctx->f[20] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x167790: 0x8fa20308
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 776)));
label_167794:
    // 0x167794: 0x1840001b
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x167804; return;
    }
    // 0x16779c: 0x26320020
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 32));
    // 0x1677a0: 0x27b102b0
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 688));
    // 0x1677a4: 0x0
    // NOP
label_1677a8:
    // 0x1677a8: 0x53c00003
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        goto label_1677b8;
    }
    // 0x1677b0: 0x10000006
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1677CC; return;
    }
label_1677b8:
    // 0x1677b8: 0x8e85002c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 44)));
    // 0x1677bc: 0xc06c824
    SET_GPR_U32(ctx, 31, 0x1677c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FShadowValid__FP6SHADOWi(rdram, ctx, runtime); return;
}


// Function: entry_1677c4
// Address: 0x1677c4 - 0x1677dc

void entry_1677c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1677c4) {
        switch (ctx->pc) {
            case 0x1677cc: ctx->pc = 0; goto label_1677cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1677c4: 0x1040000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 776)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1677F0; return;
    }
label_1677cc:
    // 0x1677cc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1677d0: 0x27a502f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 752));
    // 0x1677d4: 0xc06c9be
    SET_GPR_U32(ctx, 31, 0x1677dc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    FShadowIntersectsSphere__FP6SHADOWP6VECTORf(rdram, ctx, runtime); return;
}


// Function: entry_1677dc
// Address: 0x1677dc - 0x1677ec

void entry_1677dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1677dc: 0x10400004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 776)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1677F0; return;
    }
    // 0x1677e4: 0xc06c990
    SET_GPR_U32(ctx, 31, 0x1677ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DrawShadow__FP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_1677ec
// Address: 0x1677ec - 0x167d20

void entry_1677ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1677ec) {
        switch (ctx->pc) {
            case 0x1677f0: ctx->pc = 0; goto label_1677f0;
            case 0x167804: ctx->pc = 0; goto label_167804;
            case 0x167818: ctx->pc = 0; goto label_167818;
            case 0x167834: ctx->pc = 0; goto label_167834;
            case 0x167870: ctx->pc = 0; goto label_167870;
            case 0x1678c8: ctx->pc = 0; goto label_1678c8;
            case 0x167904: ctx->pc = 0; goto label_167904;
            case 0x167908: ctx->pc = 0; goto label_167908;
            case 0x167940: ctx->pc = 0; goto label_167940;
            case 0x16797c: ctx->pc = 0; goto label_16797c;
            case 0x167a20: ctx->pc = 0; goto label_167a20;
            case 0x167a5c: ctx->pc = 0; goto label_167a5c;
            case 0x167a90: ctx->pc = 0; goto label_167a90;
            case 0x167ad8: ctx->pc = 0; goto label_167ad8;
            case 0x167b28: ctx->pc = 0; goto label_167b28;
            case 0x167b2c: ctx->pc = 0; goto label_167b2c;
            case 0x167b88: ctx->pc = 0; goto label_167b88;
            case 0x167ba4: ctx->pc = 0; goto label_167ba4;
            case 0x167bb0: ctx->pc = 0; goto label_167bb0;
            case 0x167be4: ctx->pc = 0; goto label_167be4;
            case 0x167bf0: ctx->pc = 0; goto label_167bf0;
            case 0x167c20: ctx->pc = 0; goto label_167c20;
            case 0x167c70: ctx->pc = 0; goto label_167c70;
            case 0x167c90: ctx->pc = 0; goto label_167c90;
            case 0x167cec: ctx->pc = 0; goto label_167cec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1677ec: 0x8fa20308
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 776)));
label_1677f0:
    // 0x1677f0: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x1677f4: 0x26310004
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    // 0x1677f8: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x1677fc: 0x1440ffea
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1677A8; return;
    }
label_167804:
    // 0x167804: 0x8e820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 88)));
    // 0x167808: 0x8fab0310
    SET_GPR_U32(ctx, 11, READ32(ADD32(GPR_U32(ctx, 29), 784)));
    // 0x16780c: 0x162102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 11), GPR_S32(ctx, 2)));
    // 0x167810: 0x1440fce7
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 80));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x166BB0; return;
    }
label_167818:
    // 0x167818: 0x52a00006
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 84)); ctx->f[1] = *(float*)&val; }
        goto label_167834;
    }
    // 0x167820: 0x8ea20038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 56)));
    // 0x167824: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x167828: 0x14400130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 944)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_167cec;
    }
    // 0x167830: 0xc6c10054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 84)); ctx->f[1] = *(float*)&val; }
label_167834:
    // 0x167834: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x167838: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16783c: 0x0
    // NOP
    // 0x167840: 0x4501012a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 944)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_167cec;
    }
    // 0x167848: 0x8e820060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 96)));
    // 0x16784c: 0x18400127
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_167cec;
    }
    // 0x167854: 0x3c130026
    SET_GPR_U32(ctx, 19, ((uint32_t)38 << 16));
    // 0x167858: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x16785c: 0x247e23e0
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 3), 9184));
    // 0x167860: 0x267222a8
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 8872));
    // 0x167864: 0x24190001
    SET_GPR_S32(ctx, 25, ADD32(GPR_U32(ctx, 0), 1));
    // 0x167868: 0x3c180026
    SET_GPR_U32(ctx, 24, ((uint32_t)38 << 16));
    // 0x16786c: 0x8e830064
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 100)));
label_167870:
    // 0x167870: 0x61140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 5));
    // 0x167874: 0x12a00023
    SET_GPR_U32(ctx, 13, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_167904;
    }
    // 0x16787c: 0x8ea20038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 56)));
    // 0x167880: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x167884: 0x50400020
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 30), 3)));
        goto label_167908;
    }
    // 0x16788c: 0x92a2003f
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 21), 63)));
    // 0x167890: 0xc6c10054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 84)); ctx->f[1] = *(float*)&val; }
    // 0x167894: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x167898: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x16789c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1678a0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x1678a4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1678a8: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x1678ac: 0x2c430041
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 2), 65));
    // 0x1678b0: 0x14600005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_1678c8;
    }
    // 0x1678b8: 0x21600
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 24));
    // 0x1678bc: 0x4400002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 128));
    if (GPR_S32(ctx, 2) < 0) {
        goto label_1678c8;
    }
    // 0x1678c4: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
label_1678c8:
    // 0x1678c8: 0xffb902f8
    WRITE64(ADD32(GPR_U32(ctx, 29), 760), GPR_U64(ctx, 25));
    // 0x1678cc: 0x30a500ff
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 255));
    // 0x1678d0: 0x52e38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 24);
    // 0x1678d4: 0x92a3003d
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 21), 61)));
    // 0x1678d8: 0x92a2003c
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 21), 60)));
    // 0x1678dc: 0x92a4003e
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 21), 62)));
    // 0x1678e0: 0x31a38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 8);
    // 0x1678e4: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1678e8: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x1678ec: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1678f0: 0x31c78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 17);
    // 0x1678f4: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x1678f8: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1678fc: 0x1000001f
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16797c;
    }
label_167904:
    // 0x167904: 0x93c20003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 30), 3)));
label_167908:
    // 0x167908: 0xc6c10054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 84)); ctx->f[1] = *(float*)&val; }
    // 0x16790c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x167910: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x167914: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x167918: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x16791c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x167920: 0x304200ff
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 255));
    // 0x167924: 0x2c430041
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 2), 65));
    // 0x167928: 0x14600005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_167940;
    }
    // 0x167930: 0x21600
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 24));
    // 0x167934: 0x4400002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 128));
    if (GPR_S32(ctx, 2) < 0) {
        goto label_167940;
    }
    // 0x16793c: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
label_167940:
    // 0x167940: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x167944: 0x93c40001
    SET_GPR_U32(ctx, 4, (uint8_t)READ8(ADD32(GPR_U32(ctx, 30), 1)));
    // 0x167948: 0x906223e0
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 9184)));
    // 0x16794c: 0x30a500ff
    SET_GPR_U32(ctx, 5, AND32(GPR_U32(ctx, 5), 255));
    // 0x167950: 0x93c30002
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 30), 2)));
    // 0x167954: 0x42238
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 8);
    // 0x167958: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x16795c: 0x52e38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 24);
    // 0x167960: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x167964: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x167968: 0x42478
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 17);
    // 0x16796c: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x167970: 0xffb902f8
    WRITE64(ADD32(GPR_U32(ctx, 29), 760), GPR_U64(ctx, 25));
    // 0x167974: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x167978: 0x441025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
label_16797c:
    // 0x16797c: 0xffa202f0
    WRITE64(ADD32(GPR_U32(ctx, 29), 752), GPR_U64(ctx, 2));
    // 0x167980: 0x8f042474
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 24), 9332)));
    // 0x167984: 0x266922a8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 19), 8872));
    // 0x167988: 0x2402023c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 572));
    // 0x16798c: 0x8d30000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 9), 12)));
    // 0x167990: 0x441023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x167994: 0x3c031000
    SET_GPR_U32(ctx, 3, ((uint32_t)4096 << 16));
    // 0x167998: 0xaf022474
    WRITE32(ADD32(GPR_U32(ctx, 24), 9332), GPR_U32(ctx, 2));
    // 0x16799c: 0x3c050300
    SET_GPR_U32(ctx, 5, ((uint32_t)768 << 16));
    // 0x1679a0: 0xfe030000
    WRITE64(ADD32(GPR_U32(ctx, 16), 0), GPR_U64(ctx, 3));
    // 0x1679a4: 0x24d70001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 6), 1));
    // 0x1679a8: 0x8fa2030c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 780)));
    // 0x1679ac: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x1679b0: 0xafa2030c
    WRITE32(ADD32(GPR_U32(ctx, 29), 780), GPR_U32(ctx, 2));
    // 0x1679b4: 0x8f022474
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 24), 9332)));
    // 0x1679b8: 0x8d24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 9), 12)));
    // 0x1679bc: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x1679c0: 0x24830010
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 16));
    // 0x1679c4: 0xad23000c
    WRITE32(ADD32(GPR_U32(ctx, 9), 12), GPR_U32(ctx, 3));
    // 0x1679c8: 0xac820010
    WRITE32(ADD32(GPR_U32(ctx, 4), 16), GPR_U32(ctx, 2));
    // 0x1679cc: 0x3c040200
    SET_GPR_U32(ctx, 4, ((uint32_t)512 << 16));
    // 0x1679d0: 0x8d23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 12)));
    // 0x1679d4: 0x24620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4));
    // 0x1679d8: 0xad22000c
    WRITE32(ADD32(GPR_U32(ctx, 9), 12), GPR_U32(ctx, 2));
    // 0x1679dc: 0xac640004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 4));
    // 0x1679e0: 0x8d24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 9), 12)));
    // 0x1679e4: 0x24820004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 4));
    // 0x1679e8: 0xad22000c
    WRITE32(ADD32(GPR_U32(ctx, 9), 12), GPR_U32(ctx, 2));
    // 0x1679ec: 0x8fa5030c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 780)));
    // 0x1679f0: 0x14b9001a
    SET_GPR_S32(ctx, 15, ADD32(GPR_U32(ctx, 29), 752));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 25)) {
        goto label_167a5c;
    }
    // 0x1679f8: 0x3c036c0b
    SET_GPR_U32(ctx, 3, ((uint32_t)27659 << 16));
    // 0x1679fc: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x167a00: 0x3463c000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 49152));
    // 0x167a04: 0xac830004
    WRITE32(ADD32(GPR_U32(ctx, 4), 4), GPR_U32(ctx, 3));
    // 0x167a08: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x167a0c: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x167a10: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x167a14: 0xae42000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 2));
    // 0x167a18: 0x24080028
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 40));
    // 0x167a1c: 0x0
    // NOP
label_167a20:
    // 0x167a20: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x167a24: 0x2508fffc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967292));
    // 0x167a28: 0x8ce30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x167a2c: 0x8ce40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x167a30: 0x8ce5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x167a34: 0xacc20000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    // 0x167a38: 0x24e70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    // 0x167a3c: 0xacc30004
    WRITE32(ADD32(GPR_U32(ctx, 6), 4), GPR_U32(ctx, 3));
    // 0x167a40: 0xacc40008
    WRITE32(ADD32(GPR_U32(ctx, 6), 8), GPR_U32(ctx, 4));
    // 0x167a44: 0xacc5000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 5));
    // 0x167a48: 0x501fff5
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    if (GPR_S32(ctx, 8) >= 0) {
        goto label_167a20;
    }
    // 0x167a50: 0x8d22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 12)));
    // 0x167a54: 0x244200b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 176));
    // 0x167a58: 0xad22000c
    WRITE32(ADD32(GPR_U32(ctx, 9), 12), GPR_U32(ctx, 2));
label_167a5c:
    // 0x167a5c: 0x8da30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 13), 4)));
    // 0x167a60: 0x58600032
    if (GPR_S32(ctx, 3) <= 0) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 21), 64)));
        goto label_167b2c;
    }
    // 0x167a68: 0x8da20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 13), 0)));
    // 0x167a6c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x167a70: 0x1860002d
    SET_GPR_U32(ctx, 9, (uint16_t)READ16(ADD32(GPR_U32(ctx, 2), 8)));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_167b28;
    }
    // 0x167a78: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x167a7c: 0x3c0c6c04
    SET_GPR_U32(ctx, 12, ((uint32_t)27652 << 16));
    // 0x167a80: 0x244a22a8
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 2), 8872));
    // 0x167a84: 0x25ae0008
    SET_GPR_S32(ctx, 14, ADD32(GPR_U32(ctx, 13), 8));
    // 0x167a88: 0x24110090
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 144));
    // 0x167a8c: 0x358cc000
    SET_GPR_U32(ctx, 12, OR32(GPR_U32(ctx, 12), 49152));
label_167a90:
    // 0x167a90: 0x81880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 8), 2));
    // 0x167a94: 0x8d45000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x167a98: 0x1c31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 14), GPR_U32(ctx, 3)));
    // 0x167a9c: 0x8ea60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x167aa0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x167aa4: 0x12c1025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 9), GPR_U32(ctx, 12)));
    // 0x167aa8: 0xaca20000
    WRITE32(ADD32(GPR_U32(ctx, 5), 0), GPR_U32(ctx, 2));
    // 0x167aac: 0x912018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x167ab0: 0x8d42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x167ab4: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x167ab8: 0x862021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 6)));
    // 0x167abc: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x167ac0: 0x24860050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 80));
    // 0x167ac4: 0xad42000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 2));
    // 0x167ac8: 0x252b0004
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 9), 4));
    // 0x167acc: 0x25090001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 8), 1));
    // 0x167ad0: 0x2408000c
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 12));
    // 0x167ad4: 0x0
    // NOP
label_167ad8:
    // 0x167ad8: 0x8cc20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x167adc: 0x2508fffc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967292));
    // 0x167ae0: 0x8cc30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x167ae4: 0x8cc40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x167ae8: 0x8cc5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 12)));
    // 0x167aec: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
    // 0x167af0: 0x24c60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    // 0x167af4: 0xace30004
    WRITE32(ADD32(GPR_U32(ctx, 7), 4), GPR_U32(ctx, 3));
    // 0x167af8: 0xace40008
    WRITE32(ADD32(GPR_U32(ctx, 7), 8), GPR_U32(ctx, 4));
    // 0x167afc: 0xace5000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 5));
    // 0x167b00: 0x501fff5
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    if (GPR_S32(ctx, 8) >= 0) {
        goto label_167ad8;
    }
    // 0x167b08: 0x8d43000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 10), 12)));
    // 0x167b0c: 0x120402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x167b10: 0x24630040
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 64));
    // 0x167b14: 0xad43000c
    WRITE32(ADD32(GPR_U32(ctx, 10), 12), GPR_U32(ctx, 3));
    // 0x167b18: 0x8da20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 13), 4)));
    // 0x167b1c: 0x102102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 2)));
    // 0x167b20: 0x1440ffdb
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 11) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_167a90;
    }
label_167b28:
    // 0x167b28: 0x8ea70040
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 21), 64)));
label_167b2c:
    // 0x167b2c: 0x18e00030
    SET_GPR_U32(ctx, 2, ((uint32_t)24576 << 16));
    if (GPR_S32(ctx, 7) <= 0) {
        goto label_167bf0;
    }
    // 0x167b34: 0x8da40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 13), 0)));
    // 0x167b38: 0x266b22a8
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 19), 8872));
    // 0x167b3c: 0x71c00
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 7), 16));
    // 0x167b40: 0x9485000a
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 4), 10)));
    // 0x167b44: 0x3442c000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 49152));
    // 0x167b48: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x167b4c: 0x8d64000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x167b50: 0x8ea60044
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 21), 68)));
    // 0x167b54: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x167b58: 0xac830000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 3));
    // 0x167b5c: 0x76080
    SET_GPR_U32(ctx, 12, SLL32(GPR_U32(ctx, 7), 2));
    // 0x167b60: 0xc1883
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 12), 2));
    // 0x167b64: 0xc0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x167b68: 0x8d62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x167b6c: 0x30660003
    SET_GPR_U32(ctx, 6, AND32(GPR_U32(ctx, 3), 3));
    // 0x167b70: 0x665023
    SET_GPR_U32(ctx, 10, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    // 0x167b74: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x167b78: 0x40382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x167b7c: 0x10c00009
    WRITE32(ADD32(GPR_U32(ctx, 11), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_167ba4;
    }
    // 0x167b84: 0xc0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
label_167b88:
    // 0x167b88: 0x8d220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x167b8c: 0x2508ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967295));
    // 0x167b90: 0x25290004
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4));
    // 0x167b94: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
    // 0x167b98: 0x0
    // NOP
    // 0x167b9c: 0x1500fffa
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    if (GPR_U32(ctx, 8) != GPR_U32(ctx, 0)) {
        goto label_167b88;
    }
label_167ba4:
    // 0x167ba4: 0x1940000f
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 10) <= 0) {
        goto label_167be4;
    }
    // 0x167bac: 0x0
    // NOP
label_167bb0:
    // 0x167bb0: 0x8d240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x167bb4: 0x25080004
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4));
    // 0x167bb8: 0x8d250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 9), 4)));
    // 0x167bbc: 0x10a302a
    SET_GPR_U32(ctx, 6, SLT32(GPR_S32(ctx, 8), GPR_S32(ctx, 10)));
    // 0x167bc0: 0x8d220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 8)));
    // 0x167bc4: 0x8d23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 12)));
    // 0x167bc8: 0xace40000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 4));
    // 0x167bcc: 0x25290010
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 16));
    // 0x167bd0: 0xace50004
    WRITE32(ADD32(GPR_U32(ctx, 7), 4), GPR_U32(ctx, 5));
    // 0x167bd4: 0xace20008
    WRITE32(ADD32(GPR_U32(ctx, 7), 8), GPR_U32(ctx, 2));
    // 0x167bd8: 0xace3000c
    WRITE32(ADD32(GPR_U32(ctx, 7), 12), GPR_U32(ctx, 3));
    // 0x167bdc: 0x14c0fff4
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_167bb0;
    }
label_167be4:
    // 0x167be4: 0x8d62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 11), 12)));
    // 0x167be8: 0x4c1021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 12)));
    // 0x167bec: 0xad62000c
    WRITE32(ADD32(GPR_U32(ctx, 11), 12), GPR_U32(ctx, 2));
label_167bf0:
    // 0x167bf0: 0x266922a8
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 19), 8872));
    // 0x167bf4: 0x3c026c01
    SET_GPR_U32(ctx, 2, ((uint32_t)27649 << 16));
    // 0x167bf8: 0x8d24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 9), 12)));
    // 0x167bfc: 0x3442c01a
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 49178));
    // 0x167c00: 0x1e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 15) + GPR_U64(ctx, 0));
    // 0x167c04: 0xac820000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 2));
    // 0x167c08: 0x8d23000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 9), 12)));
    // 0x167c0c: 0x24630004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4));
    // 0x167c10: 0x60302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x167c14: 0xad23000c
    WRITE32(ADD32(GPR_U32(ctx, 9), 12), GPR_U32(ctx, 3));
    // 0x167c18: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x167c1c: 0x0
    // NOP
label_167c20:
    // 0x167c20: 0x8ce20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x167c24: 0x2508fffc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 4294967292));
    // 0x167c28: 0x8ce30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 7), 4)));
    // 0x167c2c: 0x8ce40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x167c30: 0x8ce5000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 12)));
    // 0x167c34: 0xacc20000
    WRITE32(ADD32(GPR_U32(ctx, 6), 0), GPR_U32(ctx, 2));
    // 0x167c38: 0x24e70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 16));
    // 0x167c3c: 0xacc30004
    WRITE32(ADD32(GPR_U32(ctx, 6), 4), GPR_U32(ctx, 3));
    // 0x167c40: 0xacc40008
    WRITE32(ADD32(GPR_U32(ctx, 6), 8), GPR_U32(ctx, 4));
    // 0x167c44: 0xacc5000c
    WRITE32(ADD32(GPR_U32(ctx, 6), 12), GPR_U32(ctx, 5));
    // 0x167c48: 0x501fff5
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    if (GPR_S32(ctx, 8) >= 0) {
        goto label_167c20;
    }
    // 0x167c50: 0x8d22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 9), 12)));
    // 0x167c54: 0x266522a8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 8872));
    // 0x167c58: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x167c5c: 0xad22000c
    WRITE32(ADD32(GPR_U32(ctx, 9), 12), GPR_U32(ctx, 2));
    // 0x167c60: 0x8ca4000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x167c64: 0x3082000f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 15));
    // 0x167c68: 0x50400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
        goto label_167c90;
    }
label_167c70:
    // 0x167c70: 0xac800000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 0));
    // 0x167c74: 0x8ca2000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 12)));
    // 0x167c78: 0x24420004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4));
    // 0x167c7c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x167c80: 0x3083000f
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 4), 15));
    // 0x167c84: 0x1460fffa
    WRITE32(ADD32(GPR_U32(ctx, 5), 12), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_167c70;
    }
    // 0x167c8c: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
label_167c90:
    // 0x167c90: 0x3c054000
    SET_GPR_U32(ctx, 5, ((uint32_t)16384 << 16));
    // 0x167c94: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x167c98: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x167c9c: 0x501023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x167ca0: 0x21103
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 4));
    // 0x167ca4: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x167ca8: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x167cac: 0xae030000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 3));
    // 0x167cb0: 0x8da2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 13), 28)));
    // 0x167cb4: 0x8da30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 13), 24)));
    // 0x167cb8: 0x2103c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << (32 + 0));
    // 0x167cbc: 0x8e44000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x167cc0: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x167cc4: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x167cc8: 0xfc830000
    WRITE64(ADD32(GPR_U32(ctx, 4), 0), GPR_U64(ctx, 3));
    // 0x167ccc: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x167cd0: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x167cd4: 0xae42000c
    WRITE32(ADD32(GPR_U32(ctx, 18), 12), GPR_U32(ctx, 2));
    // 0x167cd8: 0x8e830060
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 96)));
    // 0x167cdc: 0xc3182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 6), GPR_S32(ctx, 3)));
    // 0x167ce0: 0x5460fee3
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 100)));
        goto label_167870;
    }
    // 0x167ce8: 0x7bbf03b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 944)));
label_167cec:
    // 0x167cec: 0x7bbe03a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 928)));
    // 0x167cf0: 0x7bb70390
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 912)));
    // 0x167cf4: 0x7bb60380
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 896)));
    // 0x167cf8: 0x7bb50370
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 880)));
    // 0x167cfc: 0x7bb40360
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 864)));
    // 0x167d00: 0x7bb30350
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 848)));
    // 0x167d04: 0x7bb20340
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 832)));
    // 0x167d08: 0x7bb10330
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 816)));
    // 0x167d0c: 0x7bb00320
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 800)));
    // 0x167d10: 0xc7b403c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 960)); ctx->f[20] = *(float*)&val; }
    // 0x167d14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 976));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x167d1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x167d20; return;
}


// Function: glob__static_initialization_and_destruction_0
// Address: 0x167d20 - 0x167d48

void FUN_00167d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x167d48: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x167d4c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x167d50: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x167d54: 0xc059f48
    SET_GPR_U32(ctx, 31, 0x167d5c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    glob__static_initialization_and_destruction_0(rdram, ctx, runtime); return;
}


// Function: entry_167d5c
// Address: 0x167d5c - 0x167d68

void entry_167d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x167d5c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x167d60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitGomer__FP5GOMER
// Address: 0x167d68 - 0x167d7c

void entry_167d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x167d7c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x167d80: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x167d84: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x167d88: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x167d8c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x167d90: 0x3c0144bb
    SET_GPR_U32(ctx, 1, ((uint32_t)17595 << 16));
    // 0x167d94: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x167d98: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x167d9c: 0x3c013f49
    SET_GPR_U32(ctx, 1, ((uint32_t)16201 << 16));
    // 0x167da0: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x167da4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x167da8: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x167dac: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x167db0: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x167db4: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x167db8: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x167dbc: 0x3c013f86
    SET_GPR_U32(ctx, 1, ((uint32_t)16262 << 16));
    // 0x167dc0: 0x34210a92
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 2706));
    // 0x167dc4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x167dc8: 0xe6010c20
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 3104), *(uint32_t*)&val); }
    // 0x167dcc: 0xe600074c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1868), *(uint32_t*)&val); }
    // 0x167dd0: 0xe6020c24
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 3108), *(uint32_t*)&val); }
    // 0x167dd4: 0xe6030c28
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 3112), *(uint32_t*)&val); }
    // 0x167dd8: 0xe6040c2c
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 3116), *(uint32_t*)&val); }
    // 0x167ddc: 0xe6050c10
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 3088), *(uint32_t*)&val); }
    // 0x167de0: 0xae020c18
    WRITE32(ADD32(GPR_U32(ctx, 16), 3096), GPR_U32(ctx, 2));
    // 0x167de4: 0xe606073c
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 16), 1852), *(uint32_t*)&val); }
    // 0x167de8: 0xae020c30
    WRITE32(ADD32(GPR_U32(ctx, 16), 3120), GPR_U32(ctx, 2));
    // 0x167dec: 0xe6060c14
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 16), 3092), *(uint32_t*)&val); }
    // 0x167df0: 0xae000738
    WRITE32(ADD32(GPR_U32(ctx, 16), 1848), GPR_U32(ctx, 0));
    // 0x167df4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x167df8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x167dfc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x167e04: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x167e08; return;
}


// Function: PostGomerLoad__FP5GOMER
// Address: 0x167e08 - 0x167e20

void entry_167e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x167e20: 0x2411ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x167e24: 0x8e050c18
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 3096)));
    // 0x167e28: 0x50b10006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 3120)));
        ctx->pc = 0x167E44; return;
    }
    // 0x167e30: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x167e34: 0xc056912
    SET_GPR_U32(ctx, 31, 0x167e3c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_167e3c
// Address: 0x167e3c - 0x167e58

void entry_167e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x167e3c) {
        switch (ctx->pc) {
            case 0x167e44: ctx->pc = 0; goto label_167e44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x167e3c: 0xae020c1c
    WRITE32(ADD32(GPR_U32(ctx, 16), 3100), GPR_U32(ctx, 2));
    // 0x167e40: 0x8e050c30
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 3120)));
label_167e44:
    // 0x167e44: 0x50b10006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 17)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1872)));
        ctx->pc = 0x167E60; return;
    }
    // 0x167e4c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x167e50: 0xc056912
    SET_GPR_U32(ctx, 31, 0x167e58);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_167e58
// Address: 0x167e58 - 0x167e70

void entry_167e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x167e58) {
        switch (ctx->pc) {
            case 0x167e60: ctx->pc = 0; goto label_167e60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x167e58: 0xae020c34
    WRITE32(ADD32(GPR_U32(ctx, 16), 3124), GPR_U32(ctx, 2));
    // 0x167e5c: 0x8e020750
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1872)));
label_167e60:
    // 0x167e60: 0x1040001f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x167EE0; return;
    }
    // 0x167e68: 0xc063582
    SET_GPR_U32(ctx, 31, 0x167e70);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_167e70
// Address: 0x167e70 - 0x167e84

void entry_167e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x167e70: 0x8e040750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1872)));
    // 0x167e74: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x167e78: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x167e7c: 0xc04b46c
    SET_GPR_U32(ctx, 31, 0x167e84);
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 29), 4));
    GetAsegWaypoints__FP4ASEGP3ALOPiPPP8WAYPOINT(rdram, ctx, runtime); return;
}


// Function: entry_167e84
// Address: 0x167e84 - 0x167eb0

void entry_167e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x167e84) {
        switch (ctx->pc) {
            case 0x167e90: ctx->pc = 0; goto label_167e90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x167e84: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x167e88: 0x18400012
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x167ED4; return;
    }
label_167e90:
    // 0x167e90: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x167e94: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x167e98: 0x8c700000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x167e9c: 0x8e020328
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 808)));
    // 0x167ea0: 0x14400008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x167EC4; return;
    }
    // 0x167ea8: 0xc07be8c
    SET_GPR_U32(ctx, 31, 0x167eb0);
    PwpsgNew__Fv(rdram, ctx, runtime); return;
}


// Function: entry_167eb0
// Address: 0x167eb0 - 0x167ec0

void entry_167eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x167eb0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x167eb4: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x167eb8: 0xc07be98
    SET_GPR_U32(ctx, 31, 0x167ec0);
    WRITE32(ADD32(GPR_U32(ctx, 16), 808), GPR_U32(ctx, 2));
    AddWpsgWaypoint__FP4WPSGP8WAYPOINT(rdram, ctx, runtime); return;
}


// Function: entry_167ec0
// Address: 0x167ec0 - 0x167edc

void entry_167ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x167ec0) {
        switch (ctx->pc) {
            case 0x167ec4: ctx->pc = 0; goto label_167ec4;
            case 0x167ed4: ctx->pc = 0; goto label_167ed4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x167ec0: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_167ec4:
    // 0x167ec4: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x167ec8: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x167ecc: 0x1440fff0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x167E90; return;
    }
label_167ed4:
    // 0x167ed4: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x167edc);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_167edc
// Address: 0x167edc - 0x167ef0

void entry_167edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x167edc) {
        switch (ctx->pc) {
            case 0x167ee0: ctx->pc = 0; goto label_167ee0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x167edc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_167ee0:
    // 0x167ee0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x167ee4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x167ee8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RenderGomerSelf__FP5GOMERP2CMP2RO
// Address: 0x167ef0 - 0x167f00

void entry_167f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x167f00: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x167f04: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x167f0c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x167f10; return;
}


// Function: FDetectGomer__FP5GOMER
// Address: 0x167f10 - 0x167f30

void entry_167f30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x167f30: 0x14400079
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x168118; return;
    }
    // 0x167f38: 0x8e030724
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1828)));
    // 0x167f3c: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x167f40: 0x10620074
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x168114; return;
    }
    // 0x167f48: 0x10620073
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x168118; return;
    }
    // 0x167f50: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x167f54: 0x8c620198
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 408)));
    // 0x167f58: 0x40f809
    SET_GPR_U32(ctx, 31, 0x167f60);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_167f60
// Address: 0x167f60 - 0x167f80

void entry_167f60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x167f60: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x167f64: 0x8e020c40
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 3136)));
    // 0x167f68: 0x1440002e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x168024; return;
    }
    // 0x167f70: 0x1220002c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x168024; return;
    }
    // 0x167f78: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x167f80);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_167f80
// Address: 0x167f80 - 0x167f98

void entry_167f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x167f80: 0x50400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3100)));
        ctx->pc = 0x167FA8; return;
    }
    // 0x167f88: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x167f8c: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x167f90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x167f98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_167f98
// Address: 0x167f98 - 0x167fb8

void entry_167f98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x167f98) {
        switch (ctx->pc) {
            case 0x167fa8: ctx->pc = 0; goto label_167fa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x167f98: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x167f9c: 0x10430021
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x168024; return;
    }
    // 0x167fa4: 0x8e040c1c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3100)));
label_167fa8:
    // 0x167fa8: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 328)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x167FC0; return;
    }
    // 0x167fb0: 0xc05045c
    SET_GPR_U32(ctx, 31, 0x167fb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    FCheckVolPoint__FP3VOLP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_167fb8
// Address: 0x167fb8 - 0x168050

void entry_167fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x167fb8) {
        switch (ctx->pc) {
            case 0x167fc0: ctx->pc = 0; goto label_167fc0;
            case 0x167fe8: ctx->pc = 0; goto label_167fe8;
            case 0x168024: ctx->pc = 0; goto label_168024;
            case 0x168034: ctx->pc = 0; goto label_168034;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x167fb8: 0x1000001a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_168024;
    }
label_167fc0:
    // 0x167fc0: 0xc6010198
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 408)); ctx->f[1] = *(float*)&val; }
    // 0x167fc4: 0xc6020c14
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3092)); ctx->f[2] = *(float*)&val; }
    // 0x167fc8: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x167fcc: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x167fd0: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x167fd4: 0x0
    // NOP
    // 0x167fd8: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
        goto label_167fe8;
    }
    // 0x167fe0: 0x10000010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_168024;
    }
label_167fe8:
    // 0x167fe8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x167fec: 0xda020190
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 400)));
    // 0x167ff0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x167ff4: 0xc6010c10
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3088)); ctx->f[1] = *(float*)&val; }
    // 0x167ff8: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x167ffc: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x168000: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x168004: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x168008: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16800c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x168010: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x168014: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x168018: 0x0
    // NOP
    // 0x16801c: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_168024;
    }
label_168024:
    // 0x168024: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 3128)));
        goto label_168034;
    }
    // 0x16802c: 0x10000039
    WRITE32(ADD32(GPR_U32(ctx, 16), 3128), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x168114; return;
    }
label_168034:
    // 0x168034: 0x14400038
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x168118; return;
    }
    // 0x16803c: 0x8e040c34
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 3124)));
    // 0x168040: 0x50800006
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
        ctx->pc = 0x16805C; return;
    }
    // 0x168048: 0xc05045c
    SET_GPR_U32(ctx, 31, 0x168050);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 320));
    FCheckVolPoint__FP3VOLP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_168050
// Address: 0x168050 - 0x1680e0

void entry_168050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x168050) {
        switch (ctx->pc) {
            case 0x16805c: ctx->pc = 0; goto label_16805c;
            case 0x1680b0: ctx->pc = 0; goto label_1680b0;
            case 0x1680d8: ctx->pc = 0; goto label_1680d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x168050: 0x14400028
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1680F4; return;
    }
    // 0x168058: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
label_16805c:
    // 0x16805c: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x168060: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x168064: 0xc6040c24
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3108)); ctx->f[4] = *(float*)&val; }
    // 0x168068: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16806c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x168070: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x168074: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x168078: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16807c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x168080: 0x44821000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 2);
    // 0x168084: 0x46041034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x168088: 0x0
    // NOP
    // 0x16808c: 0x45000022
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x168118; return;
    }
    // 0x168094: 0xc6000c20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3104)); ctx->f[0] = *(float*)&val; }
    // 0x168098: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16809c: 0x0
    // NOP
    // 0x1680a0: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[4] = FPU_SUB_S(ctx->f[4], ctx->f[0]);
        goto label_1680b0;
    }
    // 0x1680a8: 0x1000000b
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3116)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1680d8;
    }
label_1680b0:
    // 0x1680b0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1680b4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1680b8: 0x46001001
    ctx->f[0] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x1680bc: 0xc6030c2c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3116)); ctx->f[3] = *(float*)&val; }
    // 0x1680c0: 0xc6020c28
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 3112)); ctx->f[2] = *(float*)&val; }
    // 0x1680c4: 0x46040003
    if (ctx->f[4] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[4];
    // 0x1680c8: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x1680cc: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1680d0: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1680d4: 0x46010500
    ctx->f[20] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
label_1680d8:
    // 0x1680d8: 0xc071e98
    SET_GPR_U32(ctx, 31, 0x1680e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DradEnemyStepguard__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1680e0
// Address: 0x1680e0 - 0x1680fc

void entry_1680e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1680e0) {
        switch (ctx->pc) {
            case 0x1680f4: ctx->pc = 0; goto label_1680f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1680e0: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1680e4: 0x46140036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1680e8: 0x0
    // NOP
    // 0x1680ec: 0x4500000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x168118; return;
    }
label_1680f4:
    // 0x1680f4: 0xc072cf4
    SET_GPR_U32(ctx, 31, 0x1680fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FCheckStepguardEnemyHidden__FP9STEPGUARD(rdram, ctx, runtime); return;
}


// Function: entry_1680fc
// Address: 0x1680fc - 0x168130

void entry_1680fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1680fc) {
        switch (ctx->pc) {
            case 0x168114: ctx->pc = 0; goto label_168114;
            case 0x168118: ctx->pc = 0; goto label_168118;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1680fc: 0x14400006
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_168118;
    }
    // 0x168104: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x168108: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16810c: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 16), 3128), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_168118;
    }
label_168114:
    // 0x168114: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_168118:
    // 0x168118: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16811c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x168120: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x168124: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x168128: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BlendDisplayOnBufferMismatch__Fv
// Address: 0x168130 - 0x1682c0

void entry_1682e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1682e4) {
        switch (ctx->pc) {
            case 0x168310: ctx->pc = 0; goto label_168310;
            case 0x168324: ctx->pc = 0; goto label_168324;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1682e4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1682e8: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1682ec: 0x8c4426cc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9932)));
    // 0x1682f0: 0x10830015
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x168348; return;
    }
    // 0x1682f8: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_168310;
    }
    // 0x168300: 0x10820008
    SET_GPR_U32(ctx, 2, ((uint32_t)44 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_168324;
    }
    // 0x168308: 0x10000024
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_16839c(rdram, ctx, runtime); return;
    }
label_168310:
    // 0x168310: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x168314: 0x10820014
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x168368; return;
    }
    // 0x16831c: 0x1000001f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_16839c(rdram, ctx, runtime); return;
    }
label_168324:
    // 0x168324: 0x8c43e470
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294960240)));
    // 0x168328: 0x1460001c
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        entry_16839c(rdram, ctx, runtime); return;
    }
    // 0x168330: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x168334: 0x8c432480
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9344)));
    // 0x168338: 0xc05a04c
    SET_GPR_U32(ctx, 31, 0x168340);
    WRITE32(ADD32(GPR_U32(ctx, 4), 9348), GPR_U32(ctx, 3));
    BlendDisplayOnBufferMismatch__Fv(rdram, ctx, runtime); return;
}


// Function: entry_168340
// Address: 0x168340 - 0x168360

void entry_168340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x168340) {
        switch (ctx->pc) {
            case 0x168348: ctx->pc = 0; goto label_168348;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x168340: 0x10000016
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_16839c(rdram, ctx, runtime); return;
    }
label_168348:
    // 0x168348: 0x3c02002c
    SET_GPR_U32(ctx, 2, ((uint32_t)44 << 16));
    // 0x16834c: 0x8c43e470
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4294960240)));
    // 0x168350: 0x14600012
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        entry_16839c(rdram, ctx, runtime); return;
    }
    // 0x168358: 0xc05a04c
    SET_GPR_U32(ctx, 31, 0x168360);
    BlendDisplayOnBufferMismatch__Fv(rdram, ctx, runtime); return;
}


// Function: entry_168360
// Address: 0x168360 - 0x16839c

void entry_168360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x168360) {
        switch (ctx->pc) {
            case 0x168368: ctx->pc = 0; goto label_168368;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x168360: 0x1000000e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_16839c(rdram, ctx, runtime); return;
    }
label_168368:
    // 0x168368: 0x24080028
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 40));
    // 0x16836c: 0x8ce226c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 9920)));
    // 0x168370: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x168374: 0x24a52490
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 9360));
    // 0x168378: 0x3c06002c
    SET_GPR_U32(ctx, 6, ((uint32_t)44 << 16));
    // 0x16837c: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x168380: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x168384: 0x30440001
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 2), 1));
    // 0x168388: 0xacc3e474
    WRITE32(ADD32(GPR_U32(ctx, 6), 4294960244), GPR_U32(ctx, 3));
    // 0x16838c: 0x882018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 8); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x168390: 0xace226c0
    WRITE32(ADD32(GPR_U32(ctx, 7), 9920), GPR_U32(ctx, 2));
    // 0x168394: 0xc0806ee
    SET_GPR_U32(ctx, 31, 0x16839c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 5)));
    sceGsPutDispEnv(rdram, ctx, runtime); return;
}


// Function: entry_16839c
// Address: 0x16839c - 0x1683b8

void entry_16839c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16839c: 0xf
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x1683a0: 0x42000038
    ctx->cop0_status |= 0x1; // Enable interrupts
    // 0x1683a4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1683a8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1683ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1683b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1683b8; return;
}


// Function: SyncVBlank__Fv
// Address: 0x1683b8 - 0x1683d8

void entry_1683d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1683d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1683dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1683e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1683e8; return;
}


// Function: SwapGsBuffers__Fv
// Address: 0x1683e8 - 0x168404

void entry_168404(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x168404) {
        switch (ctx->pc) {
            case 0x168438: ctx->pc = 0; goto label_168438;
            case 0x168450: ctx->pc = 0; goto label_168450;
            case 0x168470: ctx->pc = 0; goto label_168470;
            case 0x168478: ctx->pc = 0; goto label_168478;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x168404: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x168408: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x16840c: 0x8c4426c4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9924)));
    // 0x168410: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x168414: 0x8ce52484
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 7), 9348)));
    // 0x168418: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16841c: 0xae00e470
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294960240), GPR_U32(ctx, 0));
    // 0x168420: 0x18a00005
    WRITE32(ADD32(GPR_U32(ctx, 3), 9928), GPR_U32(ctx, 4));
    if (GPR_S32(ctx, 5) <= 0) {
        goto label_168438;
    }
    // 0x168428: 0x24a2ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x16842c: 0xacc026c4
    WRITE32(ADD32(GPR_U32(ctx, 6), 9924), GPR_U32(ctx, 0));
    // 0x168430: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 7), 9348), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_168450;
    }
label_168438:
    // 0x168438: 0x3c021200
    SET_GPR_U32(ctx, 2, ((uint32_t)4608 << 16));
    // 0x16843c: 0x8c421000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4096)));
    // 0x168440: 0x21342
    SET_GPR_U32(ctx, 2, SRL32(GPR_U32(ctx, 2), 13));
    // 0x168444: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x168448: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x16844c: 0xacc226c4
    WRITE32(ADD32(GPR_U32(ctx, 6), 9924), GPR_U32(ctx, 2));
label_168450:
    // 0x168450: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x168454: 0x8c6226c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9920)));
    // 0x168458: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x16845c: 0x10400004
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_168470;
    }
    // 0x168464: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x168468: 0x10000003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 9456));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_168478;
    }
label_168470:
    // 0x168470: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x168474: 0x244425e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 9696));
label_168478:
    // 0x168478: 0x84c726c4
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 6), 9924)));
    // 0x16847c: 0x24050800
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2048));
    // 0x168480: 0xc080826
    SET_GPR_U32(ctx, 31, 0x168488);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2048));
    sceGsSetHalfOffset(rdram, ctx, runtime); return;
}


// Function: entry_168488
// Address: 0x168488 - 0x168490

void entry_168488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168488: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x168490);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_168490
// Address: 0x168490 - 0x1684a8

void entry_168490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168490: 0x8e0526c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 9920)));
    // 0x168494: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x168498: 0x24842490
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9360));
    // 0x16849c: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x1684a0: 0xc0807fe
    SET_GPR_U32(ctx, 31, 0x1684a8);
    WRITE32(ADD32(GPR_U32(ctx, 16), 9920), GPR_U32(ctx, 5));
    sceGsSwapDBuff(rdram, ctx, runtime); return;
}


// Function: entry_1684a8
// Address: 0x1684a8 - 0x1684c8

void entry_1684a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1684a8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1684ac: 0x8c6226cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 9932)));
    // 0x1684b0: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1684b4: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1684b8: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1684CC; return;
    }
    // 0x1684c0: 0xc05a04c
    SET_GPR_U32(ctx, 31, 0x1684c8);
    BlendDisplayOnBufferMismatch__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1684c8
// Address: 0x1684c8 - 0x1684d4

void entry_1684c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1684c8) {
        switch (ctx->pc) {
            case 0x1684cc: ctx->pc = 0; goto label_1684cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1684c8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1684cc:
    // 0x1684cc: 0xc080662
    SET_GPR_U32(ctx, 31, 0x1684d4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceGsSyncPath(rdram, ctx, runtime); return;
}


// Function: entry_1684d4
// Address: 0x1684d4 - 0x1684e8

void entry_1684d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1684d4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1684d8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1684dc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1684e4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1684e8; return;
}


// Function: RestoreGsBuffers__Fv
// Address: 0x1684e8 - 0x168574

void entry_168574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168574: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x16857c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_16857c
// Address: 0x16857c - 0x1685a4

void entry_16857c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16857c) {
        switch (ctx->pc) {
            case 0x168594: ctx->pc = 0; goto label_168594;
            case 0x16859c: ctx->pc = 0; goto label_16859c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16857c: 0x8e0226c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9920)));
    // 0x168580: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x168584: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_168594;
    }
    // 0x16858c: 0x10000003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 9680));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16859c;
    }
label_168594:
    // 0x168594: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x168598: 0x244424e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 9440));
label_16859c:
    // 0x16859c: 0xc08071e
    SET_GPR_U32(ctx, 31, 0x1685a4);
    sceGsPutDrawEnv(rdram, ctx, runtime); return;
}


// Function: entry_1685a4
// Address: 0x1685a4 - 0x1685b8

void entry_1685a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1685a4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1685a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1685ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1685b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1685b8; return;
}


// Function: GS_Interrupt__Fi
// Address: 0x1685b8 - 0x1685d4

void entry_1685d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1685d4: 0xc05a0ee
    SET_GPR_U32(ctx, 31, 0x1685dc);
    SyncVBlank__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1685dc
// Address: 0x1685dc - 0x1685f4

void entry_1685dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1685dc: 0xae00e470
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294960240), GPR_U32(ctx, 0));
    // 0x1685e0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1685e4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1685e8: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1685ec: 0xc080686
    SET_GPR_U32(ctx, 31, 0x1685f4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    sceGsResetGraph(rdram, ctx, runtime); return;
}


// Function: entry_1685f4
// Address: 0x1685f4 - 0x168664

void entry_1685f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1685f4) {
        switch (ctx->pc) {
            case 0x16864c: ctx->pc = 0; goto label_16864c;
            case 0x168654: ctx->pc = 0; goto label_168654;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1685f4: 0x3c031200
    SET_GPR_U32(ctx, 3, ((uint32_t)4608 << 16));
    // 0x1685f8: 0x8c631000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 4096)));
    // 0x1685fc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x168600: 0x8c4426c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 9920)));
    // 0x168604: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x168608: 0x31b42
    SET_GPR_U32(ctx, 3, SRL32(GPR_U32(ctx, 3), 13));
    // 0x16860c: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x168610: 0x30630001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 1));
    // 0x168614: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x168618: 0x2c680001
    SET_GPR_U32(ctx, 8, SLTU32(GPR_U32(ctx, 3), 1));
    // 0x16861c: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x168620: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x168624: 0xe0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x168628: 0xac4026cc
    WRITE32(ADD32(GPR_U32(ctx, 2), 9932), GPR_U32(ctx, 0));
    // 0x16862c: 0x30840001
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 4), 1));
    // 0x168630: 0xaca02484
    WRITE32(ADD32(GPR_U32(ctx, 5), 9348), GPR_U32(ctx, 0));
    // 0x168634: 0xacc326c8
    WRITE32(ADD32(GPR_U32(ctx, 6), 9928), GPR_U32(ctx, 3));
    // 0x168638: 0x10800004
    WRITE32(ADD32(GPR_U32(ctx, 7), 9924), GPR_U32(ctx, 8));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_16864c;
    }
    // 0x168640: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x168644: 0x10000003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 9456));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_168654;
    }
label_16864c:
    // 0x16864c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x168650: 0x244425e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 9696));
label_168654:
    // 0x168654: 0x852726c4
    SET_GPR_S32(ctx, 7, (int16_t)READ16(ADD32(GPR_U32(ctx, 9), 9924)));
    // 0x168658: 0x24050800
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2048));
    // 0x16865c: 0xc080826
    SET_GPR_U32(ctx, 31, 0x168664);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2048));
    sceGsSetHalfOffset(rdram, ctx, runtime); return;
}


// Function: entry_168664
// Address: 0x168664 - 0x16866c

void entry_168664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168664: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x16866c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_16866c
// Address: 0x16866c - 0x168684

void entry_16866c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16866c: 0x8e0526c0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 9920)));
    // 0x168670: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x168674: 0x24842490
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9360));
    // 0x168678: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x16867c: 0xc0807fe
    SET_GPR_U32(ctx, 31, 0x168684);
    WRITE32(ADD32(GPR_U32(ctx, 16), 9920), GPR_U32(ctx, 5));
    sceGsSwapDBuff(rdram, ctx, runtime); return;
}


// Function: entry_168684
// Address: 0x168684 - 0x168698

void entry_168684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168684: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x168688: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16868c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x168694: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x168698; return;
}


// Function: ResetGs__Fv
// Address: 0x168698 - 0x1686d0

void entry_1686d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1686d0: 0xf
    // SYNC instruction - memory barrier
// In recompiled code, we don't need explicit memory barriers
    // 0x1686d4: 0x42000038
    ctx->cop0_status |= 0x1; // Enable interrupts
    // 0x1686d8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1686dc: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1686e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SendDmaSyncGsFinish__FP10sceDmaChanP2QW
// Address: 0x1686e8 - 0x16872c

void entry_16872c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16872c: 0x2404fdff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294966783));
    // 0x168730: 0xc080816
    SET_GPR_U32(ctx, 31, 0x168738);
    SET_GPR_U32(ctx, 4, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    sceGsPutIMR(rdram, ctx, runtime); return;
}


// Function: entry_168738
// Address: 0x168738 - 0x168740

void entry_168738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168738: 0xc07db08
    SET_GPR_U32(ctx, 31, 0x168740);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FlushCache(rdram, ctx, runtime); return;
}


// Function: entry_168740
// Address: 0x168740 - 0x16874c

void entry_168740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168740: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x168744: 0xc080aa0
    SET_GPR_U32(ctx, 31, 0x16874c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    sceDmaSend(rdram, ctx, runtime); return;
}


// Function: entry_16874c
// Address: 0x16874c - 0x168758

void entry_16874c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16874c: 0x3c02002c
    SET_GPR_U32(ctx, 2, ((uint32_t)44 << 16));
    // 0x168750: 0xc07dad8
    SET_GPR_U32(ctx, 31, 0x168758);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294960228)));
    WaitSema(rdram, ctx, runtime); return;
}


// Function: entry_168758
// Address: 0x168758 - 0x168770

void entry_168758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168758: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16875c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x168760: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x168764: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16876c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x168770; return;
}


// Function: BuildClearGifs__FP2QWG4RGBAi
// Address: 0x168770 - 0x1687b0

void entry_1687b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1687b0: 0x24136e00
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 28160));
    // 0x1687b4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1687b8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1687bc: 0x2405002c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 44));
    // 0x1687c0: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x1687c8);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 27648));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1687c8
// Address: 0x1687c8 - 0x1687ec

void entry_1687c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1687c8: 0x82020003
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 3)));
    // 0x1687cc: 0x24030006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1687d0: 0x24050046
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 70));
    // 0x1687d4: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x1687d8: 0x28420000
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 0));
    // 0x1687dc: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1687e0: 0x62280b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 3));
    // 0x1687e4: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x1687ec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_1687ec
// Address: 0x1687ec - 0x168824

void entry_1687ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1687ec: 0x92070001
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 1)));
    // 0x1687f0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1687f4: 0x92030000
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1687f8: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1687fc: 0x92020002
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 2)));
    // 0x168800: 0x73a38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 8);
    // 0x168804: 0x92060003
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 3)));
    // 0x168808: 0x671825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x16880c: 0x21438
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 16);
    // 0x168810: 0x24100260
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 608));
    // 0x168814: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x168818: 0x63638
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 24);
    // 0x16881c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x168824);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 6)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_168824
// Address: 0x168824 - 0x168844

void entry_168824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168824: 0x3c020003
    SET_GPR_U32(ctx, 2, ((uint32_t)3 << 16));
    // 0x168828: 0x34422000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8192));
    // 0x16882c: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x168830: 0x34c62001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 8193));
    // 0x168834: 0x52300a
    if (GPR_U32(ctx, 18) == 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 2));
    // 0x168838: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16883c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x168844);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_168844
// Address: 0x168844 - 0x168854

void entry_168844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x168844) {
        switch (ctx->pc) {
            case 0x168848: ctx->pc = 0; goto label_168848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x168844: 0x2353025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 21)));
label_168848:
    // 0x168848: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16884c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x168854);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_168854
// Address: 0x168854 - 0x16886c

void entry_168854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168854: 0x26310200
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 512));
    // 0x168858: 0x2743025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 19), GPR_U32(ctx, 20)));
    // 0x16885c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x168860: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x168864: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x16886c);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 512));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_16886c
// Address: 0x16886c - 0x168888

void entry_16886c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16886c: 0x2610ffe0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967264));
    // 0x168870: 0x601fff5
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 21)));
    if (GPR_S32(ctx, 16) >= 0) {
        ctx->pc = 0x168848; return;
    }
    // 0x168878: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16887c: 0x24050047
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 71));
    // 0x168880: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x168888);
    SET_GPR_U32(ctx, 6, ((uint32_t)7 << 16));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_168888
// Address: 0x168888 - 0x168890

void entry_168888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168888: 0xc058480
    SET_GPR_U32(ctx, 31, 0x168890);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_168890
// Address: 0x168890 - 0x1688b8

void entry_168890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168890: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x168894: 0x7bb50080
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x168898: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x16889c: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1688a0: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1688a4: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1688a8: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1688ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1688b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1688b8; return;
}


// Function: StartupGs__Fv
// Address: 0x1688b8 - 0x1688dc

void entry_1688dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1688dc: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1688e0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1688e4: 0x26102490
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 9360));
    // 0x1688e8: 0x24060280
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 640));
    // 0x1688ec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1688f0: 0x240700e0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 224));
    // 0x1688f4: 0x24080003
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1688f8: 0x24090030
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 48));
    // 0x1688fc: 0xc080758
    SET_GPR_U32(ctx, 31, 0x168904);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceGsSetDefDBuff(rdram, ctx, runtime); return;
}


// Function: entry_168904
// Address: 0x168904 - 0x168978

void entry_168904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x168904) {
        switch (ctx->pc) {
            case 0x168918: ctx->pc = 0; goto label_168918;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x168904: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x168908: 0x2405fffe
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x16890c: 0x24040080
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 128));
    // 0x168910: 0x26030050
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 80));
    // 0x168914: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_168918:
    // 0x168918: 0x451024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x16891c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x168920: 0xa2040001
    WRITE8(ADD32(GPR_U32(ctx, 16), 1), (uint8_t)GPR_U32(ctx, 4));
    // 0x168924: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x168928: 0x34420020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32));
    // 0x16892c: 0xae020000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 2));
    // 0x168930: 0x26100028
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 40));
    // 0x168934: 0x203102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    // 0x168938: 0x5440fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_168918;
    }
    // 0x168940: 0x24020080
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 128));
    // 0x168944: 0xa3a00000
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 0));
    // 0x168948: 0xa3a20003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 2));
    // 0x16894c: 0x3c04002c
    SET_GPR_U32(ctx, 4, ((uint32_t)44 << 16));
    // 0x168950: 0xa3a00001
    WRITE8(ADD32(GPR_U32(ctx, 29), 1), (uint8_t)GPR_U32(ctx, 0));
    // 0x168954: 0x2484dc20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294958112));
    // 0x168958: 0xa3a00002
    WRITE8(ADD32(GPR_U32(ctx, 29), 2), (uint8_t)GPR_U32(ctx, 0));
    // 0x16895c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x168960: 0x8ba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x168964: 0x9ba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x168968: 0xaba20013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16896c: 0xbba20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x168970: 0xc05a1dc
    SET_GPR_U32(ctx, 31, 0x168978);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    BuildClearGifs__FP2QWG4RGBAi(rdram, ctx, runtime); return;
}


// Function: entry_168978
// Address: 0x168978 - 0x16899c

void entry_168978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168978: 0x3c04002c
    SET_GPR_U32(ctx, 4, ((uint32_t)44 << 16));
    // 0x16897c: 0x8ba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x168980: 0x9ba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x168984: 0xaba20013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x168988: 0xbba20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16898c: 0x2484e1a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959520));
    // 0x168990: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x168994: 0xc05a1dc
    SET_GPR_U32(ctx, 31, 0x16899c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    BuildClearGifs__FP2QWG4RGBAi(rdram, ctx, runtime); return;
}


// Function: entry_16899c
// Address: 0x16899c - 0x1689c0

void entry_16899c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16899c: 0x3c04002c
    SET_GPR_U32(ctx, 4, ((uint32_t)44 << 16));
    // 0x1689a0: 0x8ba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x1689a4: 0x9ba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x1689a8: 0xaba20013
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 19); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1689ac: 0xbba20010
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 16); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1689b0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1689b4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1689b8: 0xc05a1dc
    SET_GPR_U32(ctx, 31, 0x1689c0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294958816));
    BuildClearGifs__FP2QWG4RGBAi(rdram, ctx, runtime); return;
}


// Function: entry_1689c0
// Address: 0x1689c0 - 0x1689cc

void entry_1689c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1689c0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1689c4: 0xc07889a
    SET_GPR_U32(ctx, 31, 0x1689cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SemaCreate__Fii(rdram, ctx, runtime); return;
}


// Function: entry_1689cc
// Address: 0x1689cc - 0x1689e0

void entry_1689cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1689cc: 0x3c03002c
    SET_GPR_U32(ctx, 3, ((uint32_t)44 << 16));
    // 0x1689d0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1689d4: 0xac62e460
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294960224), GPR_U32(ctx, 2));
    // 0x1689d8: 0xc07889a
    SET_GPR_U32(ctx, 31, 0x1689e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SemaCreate__Fii(rdram, ctx, runtime); return;
}


// Function: entry_1689e0
// Address: 0x1689e0 - 0x1689fc

void entry_1689e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1689e0: 0x3c03002c
    SET_GPR_U32(ctx, 3, ((uint32_t)44 << 16));
    // 0x1689e4: 0x3c050017
    SET_GPR_U32(ctx, 5, ((uint32_t)23 << 16));
    // 0x1689e8: 0xac62e464
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294960228), GPR_U32(ctx, 2));
    // 0x1689ec: 0x24a582c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294935232));
    // 0x1689f0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1689f4: 0xc07da54
    SET_GPR_U32(ctx, 31, 0x1689fc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    AddIntcHandler(rdram, ctx, runtime); return;
}


// Function: entry_1689fc
// Address: 0x1689fc - 0x168a04

void entry_1689fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1689fc: 0xc07db6a
    SET_GPR_U32(ctx, 31, 0x168a04);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    EnableIntc(rdram, ctx, runtime); return;
}


// Function: entry_168a04
// Address: 0x168a04 - 0x168a18

void entry_168a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168a04: 0x3c050017
    SET_GPR_U32(ctx, 5, ((uint32_t)23 << 16));
    // 0x168a08: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x168a0c: 0x24a58698
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294936216));
    // 0x168a10: 0xc07da54
    SET_GPR_U32(ctx, 31, 0x168a18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddIntcHandler(rdram, ctx, runtime); return;
}


// Function: entry_168a18
// Address: 0x168a18 - 0x168a20

void entry_168a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168a18: 0xc07db6a
    SET_GPR_U32(ctx, 31, 0x168a20);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EnableIntc(rdram, ctx, runtime); return;
}


// Function: entry_168a20
// Address: 0x168a20 - 0x168a28

void entry_168a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168a20: 0xc05a340
    SET_GPR_U32(ctx, 31, 0x168a28);
    ResetGsMemory__Fv(rdram, ctx, runtime); return;
}


// Function: entry_168a28
// Address: 0x168a28 - 0x168a30

void entry_168a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168a28: 0xc05a16e
    SET_GPR_U32(ctx, 31, 0x168a30);
    GS_Interrupt__Fi(rdram, ctx, runtime); return;
}


// Function: entry_168a30
// Address: 0x168a30 - 0x168a48

void entry_168a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168a30: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x168a34: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x168a38: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x168a3c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x168a44: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x168a48; return;
}


// Function: BlastAqwGifsBothFrames__FP2QW
// Address: 0x168a48 - 0x168a84

void entry_168a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x168a84) {
        switch (ctx->pc) {
            case 0x168a90: ctx->pc = 0; goto label_168a90;
            case 0x168aa4: ctx->pc = 0; goto label_168aa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x168a84: 0x3c130026
    SET_GPR_U32(ctx, 19, ((uint32_t)38 << 16));
    // 0x168a88: 0x8ea226c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 9920)));
    // 0x168a8c: 0x0
    // NOP
label_168a90:
    // 0x168a90: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x168a94: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x168a98: 0x14400002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 9440));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_168aa4;
    }
    // 0x168aa0: 0x266425d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 19), 9680));
label_168aa4:
    // 0x168aa4: 0xc08071e
    SET_GPR_U32(ctx, 31, 0x168aac);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    sceGsPutDrawEnv(rdram, ctx, runtime); return;
}


// Function: entry_168aac
// Address: 0x168aac - 0x168ab8

void entry_168aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168aac: 0x8e241f1c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 7964)));
    // 0x168ab0: 0xc080aa0
    SET_GPR_U32(ctx, 31, 0x168ab8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    sceDmaSend(rdram, ctx, runtime); return;
}


// Function: entry_168ab8
// Address: 0x168ab8 - 0x168ad4

void entry_168ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168ab8: 0x2a020002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 2));
    // 0x168abc: 0x1440fff4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 9920)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x168A90; return;
    }
    // 0x168ac4: 0x8e241f1c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 7964)));
    // 0x168ac8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x168acc: 0xc080b0e
    SET_GPR_U32(ctx, 31, 0x168ad4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    sceDmaSync(rdram, ctx, runtime); return;
}


// Function: entry_168ad4
// Address: 0x168ad4 - 0x168af8

void entry_168ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168ad4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x168ad8: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x168adc: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x168ae0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x168ae4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x168ae8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x168aec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x168af0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClearFrameBuffers__Fv
// Address: 0x168af8 - 0x168b0c

void entry_168b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168b0c: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    // 0x168b10: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x168b14: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x168b18: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x168b20);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_168b20
// Address: 0x168b20 - 0x168b34

void entry_168b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168b20: 0x3c06002c
    SET_GPR_U32(ctx, 6, ((uint32_t)44 << 16));
    // 0x168b24: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x168b28: 0x24c6e1a0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294959520));
    // 0x168b2c: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x168b34);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 44));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_168b34
// Address: 0x168b34 - 0x168b3c

void entry_168b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168b34: 0xc054b4c
    SET_GPR_U32(ctx, 31, 0x168b3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaEnd__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_168b3c
// Address: 0x168b3c - 0x168b4c

void entry_168b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168b3c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x168b40: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x168b44: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x168b4c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_168b4c
// Address: 0x168b4c - 0x168b54

void entry_168b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168b4c: 0xc05a292
    SET_GPR_U32(ctx, 31, 0x168b54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BlastAqwGifsBothFrames__FP2QW(rdram, ctx, runtime); return;
}


// Function: entry_168b54
// Address: 0x168b54 - 0x168b68

void entry_168b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168b54: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x168b58: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x168b5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x168b64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x168b68; return;
}


// Function: FadeFramesToBlack__Ff
// Address: 0x168b68 - 0x168ba4

void entry_168ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168ba4: 0x3c01426f
    SET_GPR_U32(ctx, 1, ((uint32_t)17007 << 16));
    // 0x168ba8: 0x3421ffff
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 65535));
    // 0x168bac: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x168bb0: 0x4600a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x168bb4: 0x4600a024
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[20]);
    // 0x168bb8: 0x44130000
    SET_GPR_U32(ctx, 19, *(uint32_t*)&ctx->f[0]);
    // 0x168bbc: 0xc05a0ee
    SET_GPR_U32(ctx, 31, 0x168bc4);
    SyncVBlank__Fv(rdram, ctx, runtime); return;
}


// Function: entry_168bc4
// Address: 0x168bc4 - 0x168c2c

void entry_168bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x168bc4) {
        switch (ctx->pc) {
            case 0x168bf8: ctx->pc = 0; goto label_168bf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x168bc4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x168bc8: 0x1a600040
    WRITE32(ADD32(GPR_U32(ctx, 2), 9932), GPR_U32(ctx, 0));
    if (GPR_S32(ctx, 19) <= 0) {
        ctx->pc = 0x168CCC; return;
    }
    // 0x168bd0: 0x4493a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 19);
    // 0x168bd4: 0x4680ad60
    ctx->f[21] = FPU_CVT_S_W(*(int32_t*)&ctx->f[21]);
    // 0x168bd8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x168bdc: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x168be0: 0x3c01437f
    SET_GPR_U32(ctx, 1, ((uint32_t)17279 << 16));
    // 0x168be4: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x168be8: 0x27b20030
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 48));
    // 0x168bec: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x168bf0: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x168bf4: 0x0
    // NOP
label_168bf8:
    // 0x168bf8: 0x44910000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 17);
    // 0x168bfc: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x168c00: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x168c04: 0x24050040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    // 0x168c08: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x168c0c: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x168c10: 0x46150003
    if (ctx->f[21] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[21];
    // 0x168c14: 0x46160042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x168c18: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x168c1c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x168c20: 0x44100800
    SET_GPR_U32(ctx, 16, *(uint32_t*)&ctx->f[1]);
    // 0x168c24: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x168c2c);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_168c2c
// Address: 0x168c2c - 0x168c34

void entry_168c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168c2c: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x168c34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_168c34
// Address: 0x168c34 - 0x168c68

void entry_168c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168c34: 0x3c014420
    SET_GPR_U32(ctx, 1, ((uint32_t)17440 << 16));
    // 0x168c38: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x168c3c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x168c40: 0x3c0143f6
    SET_GPR_U32(ctx, 1, ((uint32_t)17398 << 16));
    // 0x168c44: 0x34216667
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26215));
    // 0x168c48: 0x44817800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 1);
    // 0x168c4c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x168c50: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x168c54: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x168c58: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x168c5c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x168c60: 0xc067768
    SET_GPR_U32(ctx, 31, 0x168c68);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FillScreenRect__FiiiiffffP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_168c68
// Address: 0x168c68 - 0x168c7c

void entry_168c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168c68: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x168c6c: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x168c70: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x168c74: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x168c7c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_168c7c
// Address: 0x168c7c - 0x168c8c

void entry_168c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168c7c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x168c80: 0x24050061
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 97));
    // 0x168c84: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x168c8c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_168c8c
// Address: 0x168c8c - 0x168c94

void entry_168c8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168c8c: 0xc058480
    SET_GPR_U32(ctx, 31, 0x168c94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_168c94
// Address: 0x168c94 - 0x168c9c

void entry_168c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168c94: 0xc054b4c
    SET_GPR_U32(ctx, 31, 0x168c9c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaEnd__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_168c9c
// Address: 0x168c9c - 0x168cac

void entry_168c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168c9c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x168ca0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x168ca4: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x168cac);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_168cac
// Address: 0x168cac - 0x168cb8

void entry_168cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168cac: 0x8e841f1c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 7964)));
    // 0x168cb0: 0xc05a1ba
    SET_GPR_U32(ctx, 31, 0x168cb8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SendDmaSyncGsFinish__FP10sceDmaChanP2QW(rdram, ctx, runtime); return;
}


// Function: entry_168cb8
// Address: 0x168cb8 - 0x168cc0

void entry_168cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168cb8: 0xc05a0fa
    SET_GPR_U32(ctx, 31, 0x168cc0);
    SwapGsBuffers__Fv(rdram, ctx, runtime); return;
}


// Function: entry_168cc0
// Address: 0x168cc0 - 0x168d00

void entry_168cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x168cc0) {
        switch (ctx->pc) {
            case 0x168ccc: ctx->pc = 0; goto label_168ccc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x168cc0: 0x233102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 19)));
    // 0x168cc4: 0x1440ffcc
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x168BF8; return;
    }
label_168ccc:
    // 0x168ccc: 0x7bbf0480
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1152)));
    // 0x168cd0: 0x7bb40470
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 1136)));
    // 0x168cd4: 0x7bb30460
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1120)));
    // 0x168cd8: 0x7bb20450
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1104)));
    // 0x168cdc: 0x7bb10440
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    // 0x168ce0: 0x7bb00430
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x168ce4: 0xc7b704a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1192)); ctx->f[23] = *(float*)&val; }
    // 0x168ce8: 0xc7b604a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1184)); ctx->f[22] = *(float*)&val; }
    // 0x168cec: 0xc7b50498
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1176)); ctx->f[21] = *(float*)&val; }
    // 0x168cf0: 0xc7b40490
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1168)); ctx->f[20] = *(float*)&val; }
    // 0x168cf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1200));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x168cfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x168d00; return;
}


// Function: ResetGsMemory__Fv
// Address: 0x168d00 - 0x168d1c

void entry_168d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168d1c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x168d20: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x168d24: 0xac4026d0
    WRITE32(ADD32(GPR_U32(ctx, 2), 9936), GPR_U32(ctx, 0));
    // 0x168d28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: NLog2__FUi
// Address: 0x168d30 - 0x168d68

void entry_168dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168dec: 0x118c3c
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 17) << (32 + 16));
    // 0x168df0: 0x10803c
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << (32 + 0));
    // 0x168df4: 0x2118025
    SET_GPR_U32(ctx, 16, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x168df8: 0x12963c
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 18) << (32 + 24));
    // 0x168dfc: 0x2123025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 18)));
    // 0x168e00: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x168e04: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x168e0c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 80));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_168e0c
// Address: 0x168e0c - 0x168e1c

void entry_168e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168e0c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x168e10: 0x24050051
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 81));
    // 0x168e14: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x168e1c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_168e1c
// Address: 0x168e1c - 0x168e30

void entry_168e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168e1c: 0x14a03c
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 20) << (32 + 0));
    // 0x168e20: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x168e24: 0x2b43025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 21), GPR_U32(ctx, 20)));
    // 0x168e28: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x168e30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 82));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_168e30
// Address: 0x168e30 - 0x168e40

void entry_168e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168e30: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x168e34: 0x24050053
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 83));
    // 0x168e38: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x168e40);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_168e40
// Address: 0x168e40 - 0x168e4c

void entry_168e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168e40: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x168e44: 0xc058656
    SET_GPR_U32(ctx, 31, 0x168e4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    AddImage__4GIFSi(rdram, ctx, runtime); return;
}


// Function: entry_168e4c
// Address: 0x168e4c - 0x168e78

void entry_168e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168e4c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x168e50: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x168e54: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x168e58: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x168e5c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x168e60: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x168e64: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x168e68: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x168e6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x168e74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x168e78; return;
}


// Function: BuildClutTex2__FP4CLUTi
// Address: 0x168e78 - 0x168f48

void entry_168fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x168fa4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x168fa8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BuildBmpTex0__FP3BMPi
// Address: 0x168fb0 - 0x169018

void entry_169018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169018: 0xde030018
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x16901c: 0x3042000f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 15));
    // 0x169020: 0x3c04c3ff
    SET_GPR_U32(ctx, 4, ((uint32_t)50175 << 16));
    // 0x169024: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x169028: 0x216b8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 26);
    // 0x16902c: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x169030: 0x96040002
    SET_GPR_U32(ctx, 4, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 2)));
    // 0x169034: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x169038: 0xc05a34c
    SET_GPR_U32(ctx, 31, 0x169040);
    WRITE64(ADD32(GPR_U32(ctx, 16), 24), GPR_U64(ctx, 3));
    NLog2__FUi(rdram, ctx, runtime); return;
}


// Function: entry_169040
// Address: 0x169040 - 0x169088

void entry_169040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169040: 0xde030018
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x169044: 0x2404fffc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967292));
    // 0x169048: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x16904c: 0x34843fff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 16383));
    // 0x169050: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x169054: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x169058: 0x3042000f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 15));
    // 0x16905c: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x169060: 0x52cf8
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 19);
    // 0x169064: 0x217b8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 30);
    // 0x169068: 0x641824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x16906c: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x169070: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x169074: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x169078: 0xfe030018
    WRITE64(ADD32(GPR_U32(ctx, 16), 24), GPR_U64(ctx, 3));
    // 0x16907c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x169080: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: BuildBmpGifs__FP3BMPiP4GIFS
// Address: 0x169088 - 0x1690b4

void entry_1690b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1690b4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1690b8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FBuildUploadBitmapGifs__FiP3GSBP4GIFS
// Address: 0x1690c0 - 0x16914c

void entry_16914c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16914c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x169150: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x169154: 0xc05a39e
    SET_GPR_U32(ctx, 31, 0x16915c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    BuildClutTex2__FP4CLUTi(rdram, ctx, runtime); return;
}


// Function: entry_16915c
// Address: 0x16915c - 0x169170

void entry_16915c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16915c: 0x12400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_169180(rdram, ctx, runtime); return;
    }
    // 0x169164: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x169168: 0xc05a3d2
    SET_GPR_U32(ctx, 31, 0x169170);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    BuildClutGifs__FP4CLUTiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_169170
// Address: 0x169170 - 0x169180

void entry_169170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169170: 0x8e060008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x169174: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x169178: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x169180);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_169180
// Address: 0x169180 - 0x1691b4

void entry_169180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x169180) {
        switch (ctx->pc) {
            case 0x169184: ctx->pc = 0; goto label_169184;
            case 0x169198: ctx->pc = 0; goto label_169198;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x169180: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
label_169184:
    // 0x169184: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x169188: 0x8c624508
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 17672)));
    // 0x16918c: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x169190: 0x1440ffe5
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 24));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x169128; return;
    }
label_169198:
    // 0x169198: 0x8e820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x16919c: 0x3042007f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 127));
    // 0x1691a0: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1691b4(rdram, ctx, runtime); return;
    }
    // 0x1691a8: 0x24050080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 128));
    // 0x1691ac: 0xc05a362
    SET_GPR_U32(ctx, 31, 0x1691b4);
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    IgsAllocGsb__FP3GSBi(rdram, ctx, runtime); return;
}


// Function: entry_1691b4
// Address: 0x1691b4 - 0x169210

void entry_1691b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1691b4) {
        switch (ctx->pc) {
            case 0x1691d0: ctx->pc = 0; goto label_1691d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1691b4: 0x8fc24500
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 17664)));
    // 0x1691b8: 0x1840002a
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x169264; return;
    }
    // 0x1691c0: 0x3c170027
    SET_GPR_U32(ctx, 23, ((uint32_t)39 << 16));
    // 0x1691c4: 0x24160020
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 32));
    // 0x1691c8: 0x8ee44504
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 23), 17668)));
    // 0x1691cc: 0x0
    // NOP
label_1691d0:
    // 0x1691d0: 0x131940
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 5));
    // 0x1691d4: 0x838021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x1691d8: 0x8e020004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x1691dc: 0x551024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x1691e0: 0x1455001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 17664)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        ctx->pc = 0x169254; return;
    }
    // 0x1691e8: 0x92020008
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1691ec: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 10)));
        ctx->pc = 0x169214; return;
    }
    // 0x1691f4: 0x8e820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x1691f8: 0x3042001f
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 31));
    // 0x1691fc: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 10)));
        ctx->pc = 0x169214; return;
    }
    // 0x169204: 0x2c22823
    SET_GPR_U32(ctx, 5, SUB32(GPR_U32(ctx, 22), GPR_U32(ctx, 2)));
    // 0x169208: 0xc05a362
    SET_GPR_U32(ctx, 31, 0x169210);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    IgsAllocGsb__FP3GSBi(rdram, ctx, runtime); return;
}


// Function: entry_169210
// Address: 0x169210 - 0x16921c

void entry_169210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x169210) {
        switch (ctx->pc) {
            case 0x169214: ctx->pc = 0; goto label_169214;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x169210: 0x9605000a
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 10)));
label_169214:
    // 0x169214: 0xc05a362
    SET_GPR_U32(ctx, 31, 0x16921c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    IgsAllocGsb__FP3GSBi(rdram, ctx, runtime); return;
}


// Function: entry_16921c
// Address: 0x16921c - 0x16922c

void entry_16921c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16921c: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x169220: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x169224: 0xc05a3ec
    SET_GPR_U32(ctx, 31, 0x16922c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    BuildBmpTex0__FP3BMPi(rdram, ctx, runtime); return;
}


// Function: entry_16922c
// Address: 0x16922c - 0x169240

void entry_16922c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16922c: 0x12400008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_169250(rdram, ctx, runtime); return;
    }
    // 0x169234: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x169238: 0xc05a422
    SET_GPR_U32(ctx, 31, 0x169240);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    BuildBmpGifs__FP3BMPiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_169240
// Address: 0x169240 - 0x169250

void entry_169240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169240: 0x8e060010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x169244: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x169248: 0xc054ae0
    SET_GPR_U32(ctx, 31, 0x169250);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    AddDmaRefs__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_169250
// Address: 0x169250 - 0x1692b0

void entry_169250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x169250) {
        switch (ctx->pc) {
            case 0x169254: ctx->pc = 0; goto label_169254;
            case 0x169264: ctx->pc = 0; goto label_169264;
            case 0x16927c: ctx->pc = 0; goto label_16927c;
            case 0x169280: ctx->pc = 0; goto label_169280;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x169250: 0x8fc24500
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 30), 17664)));
label_169254:
    // 0x169254: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x169258: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x16925c: 0x1440ffdc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 23), 17668)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1691D0; return;
    }
label_169264:
    // 0x169264: 0x12400005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        goto label_16927c;
    }
    // 0x16926c: 0x8e42000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x169270: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x169274: 0x10000002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_169280;
    }
label_16927c:
    // 0x16927c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_169280:
    // 0x169280: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x169284: 0x7bbe0090
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x169288: 0x7bb70080
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x16928c: 0x7bb60070
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x169290: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x169294: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x169298: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16929c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1692a0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1692a4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1692a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UploadBitmaps__FiP3GSB
// Address: 0x1692b0 - 0x1692d4

void entry_1692d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1692d4: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1692dc);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1692dc
// Address: 0x1692dc - 0x169308

void entry_1692dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1692dc: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1692e0: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1692e4: 0x8c434514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 17684)));
    // 0x1692e8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1692ec: 0x8ca24510
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 17680)));
    // 0x1692f0: 0x32840
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 3), 1));
    // 0x1692f4: 0xa32821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x1692f8: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x1692fc: 0x528c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 3));
    // 0x169300: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x169308);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 4));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_169308
// Address: 0x169308 - 0x169310

void entry_169308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169308: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x169310);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_169310
// Address: 0x169310 - 0x169320

void entry_169310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169310: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x169314: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x169318: 0xc05a430
    SET_GPR_U32(ctx, 31, 0x169320);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FBuildUploadBitmapGifs__FiP3GSBP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_169320
// Address: 0x169320 - 0x169338

void entry_169320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169320: 0x10400019
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_169388(rdram, ctx, runtime); return;
    }
    // 0x169328: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x16932c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x169330: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x169338);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_169338
// Address: 0x169338 - 0x169348

void entry_169338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169338: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16933c: 0x2405003f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    // 0x169340: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x169348);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_169348
// Address: 0x169348 - 0x169358

void entry_169348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169348: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16934c: 0x24050061
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 97));
    // 0x169350: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x169358);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_169358
// Address: 0x169358 - 0x169360

void entry_169358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169358: 0xc058480
    SET_GPR_U32(ctx, 31, 0x169360);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_169360
// Address: 0x169360 - 0x169368

void entry_169360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169360: 0xc054b4c
    SET_GPR_U32(ctx, 31, 0x169368);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaEnd__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_169368
// Address: 0x169368 - 0x169378

void entry_169368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169368: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16936c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x169370: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x169378);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_169378
// Address: 0x169378 - 0x169388

void entry_169378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169378: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16937c: 0x8fa50030
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x169380: 0xc05a1ba
    SET_GPR_U32(ctx, 31, 0x169388);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 7964)));
    SendDmaSyncGsFinish__FP10sceDmaChanP2QW(rdram, ctx, runtime); return;
}


// Function: entry_169388
// Address: 0x169388 - 0x169390

void entry_169388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169388: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x169390);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_169390
// Address: 0x169390 - 0x1693a8

void entry_169390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169390: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x169394: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x169398: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16939c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1693a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1693a8; return;
}


// Function: PqwGifsBitmapUpload__Fi
// Address: 0x1693a8 - 0x1693c4

void entry_1693c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1693c4: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1693c8: 0x24061e00
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 7680));
    // 0x1693cc: 0xafa00040
    WRITE32(ADD32(GPR_U32(ctx, 29), 64), GPR_U32(ctx, 0));
    // 0x1693d0: 0x24051400
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5120));
    // 0x1693d4: 0xc05a35a
    SET_GPR_U32(ctx, 31, 0x1693dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitGsb__FP3GSBii(rdram, ctx, runtime); return;
}


// Function: entry_1693dc
// Address: 0x1693dc - 0x1693e4

void entry_1693dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1693dc: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1693e4);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1693e4
// Address: 0x1693e4 - 0x169410

void entry_1693e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1693e4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1693e8: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1693ec: 0x8c434514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 17684)));
    // 0x1693f0: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1693f4: 0x8ca24510
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 17680)));
    // 0x1693f8: 0x32840
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 3), 1));
    // 0x1693fc: 0xa32821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x169400: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x169404: 0x528c0
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 3));
    // 0x169408: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x169410);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 4));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_169410
// Address: 0x169410 - 0x169418

void entry_169410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169410: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x169418);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_169418
// Address: 0x169418 - 0x169428

void entry_169418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169418: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16941c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x169420: 0xc05a430
    SET_GPR_U32(ctx, 31, 0x169428);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FBuildUploadBitmapGifs__FiP3GSBP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_169428
// Address: 0x169428 - 0x169440

void entry_169428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169428: 0x10400015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_169480(rdram, ctx, runtime); return;
    }
    // 0x169430: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x169434: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x169438: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x169440);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_169440
// Address: 0x169440 - 0x169450

void entry_169440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169440: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x169444: 0x2405003f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    // 0x169448: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x169450);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_169450
// Address: 0x169450 - 0x169458

void entry_169450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169450: 0xc058480
    SET_GPR_U32(ctx, 31, 0x169458);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_169458
// Address: 0x169458 - 0x169460

void entry_169458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169458: 0xc054b4c
    SET_GPR_U32(ctx, 31, 0x169460);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AddDmaEnd__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_169460
// Address: 0x169460 - 0x169478

void entry_169460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169460: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x169464: 0x24080007
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 7));
    // 0x169468: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16946c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x169470: 0xc054a94
    SET_GPR_U32(ctx, 31, 0x169478);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 64));
    DetachCopySw__4DMASPiPP2QWT2i(rdram, ctx, runtime); return;
}


// Function: entry_169478
// Address: 0x169478 - 0x169480

void entry_169478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169478: 0xc06cd44
    SET_GPR_U32(ctx, 31, 0x169480);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FillShaders__Fi(rdram, ctx, runtime); return;
}


// Function: entry_169480
// Address: 0x169480 - 0x169488

void entry_169480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169480: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x169488);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_169488
// Address: 0x169488 - 0x1694a0

void entry_169488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169488: 0x8fa20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16948c: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x169490: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x169494: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x169498: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PropagateSur__FP3SUR
// Address: 0x1694a0 - 0x1694c0

void entry_1694c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1694c0) {
        switch (ctx->pc) {
            case 0x1694ec: ctx->pc = 0; goto label_1694ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1694c0: 0x8e05000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x1694c4: 0x10a00009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_1694ec;
    }
    // 0x1694cc: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x1694d0: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1694d4: 0x8c440010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1694d8: 0x34638000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 32768));
    // 0x1694dc: 0x651825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x1694e0: 0x34848000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 32768));
    // 0x1694e4: 0xac440010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 4));
    // 0x1694e8: 0xac430000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 3));
label_1694ec:
    // 0x1694ec: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1694f0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI
// Address: 0x1694f8 - 0x1695bc

void entry_1695bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1695bc: 0x1260000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1695EC; return;
    }
    // 0x1695c4: 0xc063570
    SET_GPR_U32(ctx, 31, 0x1695cc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_1695cc
// Address: 0x1695cc - 0x169608

void entry_1695cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1695cc) {
        switch (ctx->pc) {
            case 0x1695ec: ctx->pc = 0; goto label_1695ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1695cc: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1695d0: 0x10600006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1695ec;
    }
    // 0x1695d8: 0xac720000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 18));
    // 0x1695dc: 0xac700004
    WRITE32(ADD32(GPR_U32(ctx, 3), 4), GPR_U32(ctx, 16));
    // 0x1695e0: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1695e4: 0xac620008
    WRITE32(ADD32(GPR_U32(ctx, 3), 8), GPR_U32(ctx, 2));
    // 0x1695e8: 0xae230014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 3));
label_1695ec:
    // 0x1695ec: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1695f0: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1695f4: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1695f8: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1695fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x169604: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x169608; return;
}


// Function: ReferenceUVAnimation__FP2QWiP3SAI
// Address: 0x169608 - 0x169674

void entry_169674(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169674: 0x8e4226d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9936)));
    // 0x169678: 0x28424000
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 16384));
    // 0x16967c: 0x10400009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1696A4; return;
    }
    // 0x169684: 0xc063570
    SET_GPR_U32(ctx, 31, 0x16968c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 12));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16968c
// Address: 0x16968c - 0x1696b8

void entry_16968c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16968c) {
        switch (ctx->pc) {
            case 0x1696a4: ctx->pc = 0; goto label_1696a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16968c: 0xac500004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 16));
    // 0x169690: 0xac400000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 0));
    // 0x169694: 0x8e230014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x169698: 0xac430008
    WRITE32(ADD32(GPR_U32(ctx, 2), 8), GPR_U32(ctx, 3));
    // 0x16969c: 0xae220014
    WRITE32(ADD32(GPR_U32(ctx, 17), 20), GPR_U32(ctx, 2));
    // 0x1696a0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_1696a4:
    // 0x1696a4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1696a8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1696ac: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1696b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RebaseSurs__FiiPvT2
// Address: 0x1696b8 - 0x169718

void entry_169754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x169754) {
        switch (ctx->pc) {
            case 0x169764: ctx->pc = 0; goto label_169764;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x169754: 0x8e4226d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9936)));
    // 0x169758: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x16975c: 0x1440fffa
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x169748; return;
    }
label_169764:
    // 0x169764: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x169768: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16976c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x169770: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x169774: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16977c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x169780; return;
}


// Function: PqwVifsBitmapUpload__Fi
// Address: 0x169780 - 0x1697c4

void entry_1697c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1697c4: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1697c8: 0xc05846e
    SET_GPR_U32(ctx, 31, 0x1697d0);
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    fn___4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1697d0
// Address: 0x1697d0 - 0x1697e4

void entry_1697d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1697d0: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x1697d4: 0xafa00118
    WRITE32(ADD32(GPR_U32(ctx, 29), 280), GPR_U32(ctx, 0));
    // 0x1697d8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1697dc: 0xc07b8c6
    SET_GPR_U32(ctx, 31, 0x1697e4);
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_1697e4
// Address: 0x1697e4 - 0x1697ec

void entry_1697e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1697e4: 0xc063582
    SET_GPR_U32(ctx, 31, 0x1697ec);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1697ec
// Address: 0x1697ec - 0x16981c

void entry_1697ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1697ec: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1697f0: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x1697f4: 0x8c464514
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 17684)));
    // 0x1697f8: 0x2407000a
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1697fc: 0x8c624510
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 17680)));
    // 0x169800: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x169804: 0x62840
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 6), 1));
    // 0x169808: 0xa62821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 6)));
    // 0x16980c: 0xa22821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x169810: 0xa72818
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x169814: 0xc054a60
    SET_GPR_U32(ctx, 31, 0x16981c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4));
    AllocStack__4DMASi(rdram, ctx, runtime); return;
}


// Function: entry_16981c
// Address: 0x16981c - 0x169824

void entry_16981c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16981c: 0xc054ace
    SET_GPR_U32(ctx, 31, 0x169824);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_169824
// Address: 0x169824 - 0x16982c

void entry_169824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169824: 0xc07b914
    SET_GPR_U32(ctx, 31, 0x16982c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    AddVifFlush__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_16982c
// Address: 0x16982c - 0x16986c

void entry_16982c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16982c) {
        switch (ctx->pc) {
            case 0x169848: ctx->pc = 0; goto label_169848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16982c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x169830: 0x8c624508
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 17672)));
    // 0x169834: 0x1840003b
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x169924; return;
    }
    // 0x16983c: 0x2e0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x169840: 0x3c0b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x169844: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_169848:
    // 0x169848: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x16984c: 0x8c43450c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 17676)));
    // 0x169850: 0x748821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 20)));
    // 0x169854: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x169858: 0x551024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x16985c: 0x1455002b
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        ctx->pc = 0x16990C; return;
    }
    // 0x169864: 0xc054a38
    SET_GPR_U32(ctx, 31, 0x16986c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    Reset__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_16986c
// Address: 0x16986c - 0x16987c

void entry_16986c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16986c: 0x27a60070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 112));
    // 0x169870: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x169874: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x16987c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_16987c
// Address: 0x16987c - 0x169888

void entry_16987c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16987c: 0x96250006
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 6)));
    // 0x169880: 0xc05a362
    SET_GPR_U32(ctx, 31, 0x169888);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    IgsAllocGsb__FP3GSBi(rdram, ctx, runtime); return;
}


// Function: entry_169888
// Address: 0x169888 - 0x169898

void entry_169888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169888: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16988c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x169890: 0xc05a39e
    SET_GPR_U32(ctx, 31, 0x169898);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BuildClutTex2__FP4CLUTi(rdram, ctx, runtime); return;
}


// Function: entry_169898
// Address: 0x169898 - 0x1698a8

void entry_169898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169898: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16989c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1698a0: 0xc05a3d2
    SET_GPR_U32(ctx, 31, 0x1698a8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    BuildClutGifs__FP4CLUTiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1698a8
// Address: 0x1698a8 - 0x1698cc

void entry_1698a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1698a8: 0x8fa3001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x1698ac: 0x34078000
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1698b0: 0x27a50110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 272));
    // 0x1698b4: 0x27a60114
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 276));
    // 0x1698b8: 0xdc62fff0
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 4294967280)));
    // 0x1698bc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1698c0: 0x471025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1698c4: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x1698cc);
    WRITE64(ADD32(GPR_U32(ctx, 3), 4294967280), GPR_U64(ctx, 2));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1698cc
// Address: 0x1698cc - 0x1698e0

void entry_1698cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1698cc: 0x8fa50110
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1698d0: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1698d4: 0x8fa60114
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 276)));
    // 0x1698d8: 0xc07b9f4
    SET_GPR_U32(ctx, 31, 0x1698e0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifDirect__4VIFSiP2QWi(rdram, ctx, runtime); return;
}


// Function: entry_1698e0
// Address: 0x1698e0 - 0x1698f4

void entry_1698e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1698e0: 0x8e25000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x1698e4: 0x2c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x1698e8: 0x8e260008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x1698ec: 0xc07ba14
    SET_GPR_U32(ctx, 31, 0x1698f4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifDirectRefs__4VIFSiP2QWi(rdram, ctx, runtime); return;
}


// Function: entry_1698f4
// Address: 0x1698f4 - 0x169964

void entry_1698f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1698f4) {
        switch (ctx->pc) {
            case 0x169908: ctx->pc = 0; goto label_169908;
            case 0x16990c: ctx->pc = 0; goto label_16990c;
            case 0x169924: ctx->pc = 0; goto label_169924;
            case 0x169940: ctx->pc = 0; goto label_169940;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1698f4: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x1698f8: 0x3c034000
    SET_GPR_U32(ctx, 3, ((uint32_t)16384 << 16));
    // 0x1698fc: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x169900: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 3));
        goto label_169908;
    }
label_169908:
    // 0x169908: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
label_16990c:
    // 0x16990c: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x169910: 0x8c624508
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 17672)));
    // 0x169914: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x169918: 0x1440ffcb
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 24));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x169848; return;
    }
    // 0x169920: 0x3c070027
    SET_GPR_U32(ctx, 7, ((uint32_t)39 << 16));
label_169924:
    // 0x169924: 0x8ce24500
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 17664)));
    // 0x169928: 0x1840003a
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x169A14; return;
    }
    // 0x169930: 0x2e0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x169934: 0x34168000
    SET_GPR_U32(ctx, 22, OR32(GPR_U32(ctx, 0), 32768));
    // 0x169938: 0x3c0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x16993c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_169940:
    // 0x169940: 0x131940
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 5));
    // 0x169944: 0x8c444504
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 17668)));
    // 0x169948: 0x838821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x16994c: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x169950: 0x551024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x169954: 0x1455002a
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        ctx->pc = 0x169A00; return;
    }
    // 0x16995c: 0xc054a38
    SET_GPR_U32(ctx, 31, 0x169964);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    Reset__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_169964
// Address: 0x169964 - 0x169974

void entry_169964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169964: 0x27a60070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 112));
    // 0x169968: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16996c: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x169974);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_169974
// Address: 0x169974 - 0x169980

void entry_169974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169974: 0x9625000a
    SET_GPR_U32(ctx, 5, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 10)));
    // 0x169978: 0xc05a362
    SET_GPR_U32(ctx, 31, 0x169980);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    IgsAllocGsb__FP3GSBi(rdram, ctx, runtime); return;
}


// Function: entry_169980
// Address: 0x169980 - 0x169990

void entry_169980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169980: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x169984: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x169988: 0xc05a3ec
    SET_GPR_U32(ctx, 31, 0x169990);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    BuildBmpTex0__FP3BMPi(rdram, ctx, runtime); return;
}


// Function: entry_169990
// Address: 0x169990 - 0x1699a0

void entry_169990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169990: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x169994: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x169998: 0xc05a422
    SET_GPR_U32(ctx, 31, 0x1699a0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    BuildBmpGifs__FP3BMPiP4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_1699a0
// Address: 0x1699a0 - 0x1699c0

void entry_1699a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1699a0: 0x8fa3001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x1699a4: 0x27a50110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 272));
    // 0x1699a8: 0x27a60114
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 276));
    // 0x1699ac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1699b0: 0xdc62fff0
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 4294967280)));
    // 0x1699b4: 0x561025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 22)));
    // 0x1699b8: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x1699c0);
    WRITE64(ADD32(GPR_U32(ctx, 3), 4294967280), GPR_U64(ctx, 2));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_1699c0
// Address: 0x1699c0 - 0x1699d4

void entry_1699c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1699c0: 0x8fa50110
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1699c4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1699c8: 0x8fa60114
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 276)));
    // 0x1699cc: 0xc07b9f4
    SET_GPR_U32(ctx, 31, 0x1699d4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifDirect__4VIFSiP2QWi(rdram, ctx, runtime); return;
}


// Function: entry_1699d4
// Address: 0x1699d4 - 0x1699e8

void entry_1699d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1699d4: 0x8e250014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x1699d8: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1699dc: 0x8e260010
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x1699e0: 0xc07ba14
    SET_GPR_U32(ctx, 31, 0x1699e8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    AddVifDirectRefs__4VIFSiP2QWi(rdram, ctx, runtime); return;
}


// Function: entry_1699e8
// Address: 0x1699e8 - 0x169a30

void entry_1699e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1699e8) {
        switch (ctx->pc) {
            case 0x1699fc: ctx->pc = 0; goto label_1699fc;
            case 0x169a00: ctx->pc = 0; goto label_169a00;
            case 0x169a14: ctx->pc = 0; goto label_169a14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1699e8: 0x8e220004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x1699ec: 0x3c034000
    SET_GPR_U32(ctx, 3, ((uint32_t)16384 << 16));
    // 0x1699f0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1699f4: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 3));
        goto label_1699fc;
    }
label_1699fc:
    // 0x1699fc: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
label_169a00:
    // 0x169a00: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x169a04: 0x8c624500
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 17664)));
    // 0x169a08: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x169a0c: 0x1440ffcc
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x169940; return;
    }
label_169a14:
    // 0x169a14: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x169a18: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x169a1c: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
    // 0x169a20: 0x1040002d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_169ad8(rdram, ctx, runtime); return;
    }
    // 0x169a28: 0xc054a38
    SET_GPR_U32(ctx, 31, 0x169a30);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    Reset__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_169a30
// Address: 0x169a30 - 0x169a40

void entry_169a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169a30: 0x27a60070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 112));
    // 0x169a34: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x169a38: 0xc054a72
    SET_GPR_U32(ctx, 31, 0x169a40);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    AllocStatic__4DMASiP2QW(rdram, ctx, runtime); return;
}


// Function: entry_169a40
// Address: 0x169a40 - 0x169a54

void entry_169a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169a40: 0x2407000e
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 14));
    // 0x169a44: 0x2e0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x169a48: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x169a4c: 0xc0584f0
    SET_GPR_U32(ctx, 31, 0x169a54);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    AddPrimPack__4GIFSiiUl(rdram, ctx, runtime); return;
}


// Function: entry_169a54
// Address: 0x169a54 - 0x169a64

void entry_169a54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169a54: 0x2405003f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 63));
    // 0x169a58: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x169a5c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x169a64);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_169a64
// Address: 0x169a64 - 0x169a6c

void entry_169a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169a64: 0xc058480
    SET_GPR_U32(ctx, 31, 0x169a6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    AddPrimEnd__4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_169a6c
// Address: 0x169a6c - 0x169a7c

void entry_169a6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169a6c: 0x27a50110
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 272));
    // 0x169a70: 0x27a60114
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 276));
    // 0x169a74: 0xc054a78
    SET_GPR_U32(ctx, 31, 0x169a7c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    Detach__4DMASPiPP2QW(rdram, ctx, runtime); return;
}


// Function: entry_169a7c
// Address: 0x169a7c - 0x169a90

void entry_169a7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169a7c: 0x8fa50110
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x169a80: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x169a84: 0x8fa60114
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 276)));
    // 0x169a88: 0xc07b9f4
    SET_GPR_U32(ctx, 31, 0x169a90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    AddVifDirect__4VIFSiP2QWi(rdram, ctx, runtime); return;
}


// Function: entry_169a90
// Address: 0x169a90 - 0x169a98

void entry_169a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169a90: 0xc07b914
    SET_GPR_U32(ctx, 31, 0x169a98);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    AddVifFlush__4VIFS(rdram, ctx, runtime); return;
}


// Function: entry_169a98
// Address: 0x169a98 - 0x169aa0

void entry_169a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169a98: 0xc054b5c
    SET_GPR_U32(ctx, 31, 0x169aa0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    EndDmaCnt__4DMAS(rdram, ctx, runtime); return;
}


// Function: entry_169aa0
// Address: 0x169aa0 - 0x169ad0

void entry_169aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169aa0: 0x8fa3004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x169aa4: 0x3c026000
    SET_GPR_U32(ctx, 2, ((uint32_t)24576 << 16));
    // 0x169aa8: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x169aac: 0x24080007
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 7));
    // 0x169ab0: 0xfc620000
    WRITE64(ADD32(GPR_U32(ctx, 3), 0), GPR_U64(ctx, 2));
    // 0x169ab4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x169ab8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x169abc: 0x27a70118
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 280));
    // 0x169ac0: 0x8fa2004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 76)));
    // 0x169ac4: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x169ac8: 0xc054a94
    SET_GPR_U32(ctx, 31, 0x169ad0);
    WRITE32(ADD32(GPR_U32(ctx, 29), 76), GPR_U32(ctx, 2));
    DetachCopySw__4DMASPiPP2QWT2i(rdram, ctx, runtime); return;
}


// Function: entry_169ad0
// Address: 0x169ad0 - 0x169ad8

void entry_169ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169ad0: 0xc06cd44
    SET_GPR_U32(ctx, 31, 0x169ad8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    FillShaders__Fi(rdram, ctx, runtime); return;
}


// Function: entry_169ad8
// Address: 0x169ad8 - 0x169ae0

void entry_169ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169ad8: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x169ae0);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_169ae0
// Address: 0x169ae0 - 0x169b18

void entry_169ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169ae0: 0x8fa20118
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 280)));
    // 0x169ae4: 0x7bbf01b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x169ae8: 0x7bbe01a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x169aec: 0x7bb70190
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x169af0: 0x7bb60180
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x169af4: 0x7bb50170
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x169af8: 0x7bb40160
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x169afc: 0x7bb30150
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x169b00: 0x7bb20140
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x169b04: 0x7bb10130
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x169b08: 0x7bb00120
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x169b0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 448));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x169b14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x169b18; return;
}


// Function: DrawOnBitmap__FP3BMPP4GIFS
// Address: 0x169b18 - 0x169b98

void entry_169b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169b98: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x169b9c: 0x2646003f
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 63));
    // 0x169ba0: 0x52102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 18)));
    // 0x169ba4: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x169ba8: 0x242300b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 6, GPR_U32(ctx, 18));
    // 0x169bac: 0x2405004d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 77));
    // 0x169bb0: 0x63183
    SET_GPR_S32(ctx, 6, SRA32(GPR_S32(ctx, 6), 6));
    // 0x169bb4: 0x63438
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 6) << 16);
    // 0x169bb8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x169bc0);
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 17), GPR_U32(ctx, 6)));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_169bc0
// Address: 0x169bc0 - 0x169be0

void entry_169bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169bc0: 0x3c063000
    SET_GPR_U32(ctx, 6, ((uint32_t)12288 << 16));
    // 0x169bc4: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x169bc8: 0x21478
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 17);
    // 0x169bcc: 0xd13025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 17)));
    // 0x169bd0: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x169bd4: 0xc23025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x169bd8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x169be0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 79));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_169be0
// Address: 0x169be0 - 0x169bf0

void entry_169be0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169be0: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x169be4: 0x24050019
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 25));
    // 0x169be8: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x169bf0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_169bf0
// Address: 0x169bf0 - 0x169c10

void entry_169bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169bf0: 0x2610ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
    // 0x169bf4: 0x2673ffff
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4294967295));
    // 0x169bf8: 0x108438
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 16) << 16);
    // 0x169bfc: 0x139c3c
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) << (32 + 16));
    // 0x169c00: 0x2133025
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 16), GPR_U32(ctx, 19)));
    // 0x169c04: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x169c08: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x169c10);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 65));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_169c10
// Address: 0x169c10 - 0x169c24

void entry_169c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169c10: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x169c14: 0x3c060003
    SET_GPR_U32(ctx, 6, ((uint32_t)3 << 16));
    // 0x169c18: 0x34c61001
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 4097));
    // 0x169c1c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x169c24);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 72));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_169c24
// Address: 0x169c24 - 0x169c34

void entry_169c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169c24: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x169c28: 0x24050043
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 67));
    // 0x169c2c: 0xc0585c2
    SET_GPR_U32(ctx, 31, 0x169c34);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 68));
    PackAD__4GIFSll(rdram, ctx, runtime); return;
}


// Function: entry_169c34
// Address: 0x169c34 - 0x169c58

void entry_169c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169c34: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x169c38: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x169c3c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x169c40: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x169c44: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x169c48: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x169c4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x169c54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x169c58; return;
}


// Function: StartupHide__Fv
// Address: 0x169c58 - 0x169c70

void entry_169c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169c70: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x169c74: 0x24050050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 80));
    // 0x169c78: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x169c80);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9976));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_169c80
// Address: 0x169c80 - 0x169c90

void entry_169c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169c80: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x169c84: 0x24050558
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1368));
    // 0x169c88: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x169c90);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9992));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_169c90
// Address: 0x169c90 - 0x169ca0

void entry_169c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169c90: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x169c94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x169c9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x169ca0; return;
}


// Function: ResetHideList__Fv
// Address: 0x169ca0 - 0x169cb4

void entry_169cb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169cb4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x169cb8: 0xc054910
    SET_GPR_U32(ctx, 31, 0x169cc0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9976));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_169cc0
// Address: 0x169cc0 - 0x169ccc

void entry_169cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169cc0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x169cc4: 0xc054910
    SET_GPR_U32(ctx, 31, 0x169ccc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9992));
    ClearDl__FP2DL(rdram, ctx, runtime); return;
}


// Function: entry_169ccc
// Address: 0x169ccc - 0x169cd8

void entry_169ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169ccc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x169cd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitHshape__FP6HSHAPE
// Address: 0x169cd8 - 0x169cec

void entry_169cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169cec: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x169cf0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x169cf4: 0xc440a794
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944660)); ctx->f[0] = *(float*)&val; }
    // 0x169cf8: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x169cfc: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x169d00: 0xae030044
    WRITE32(ADD32(GPR_U32(ctx, 16), 68), GPR_U32(ctx, 3));
    // 0x169d04: 0xe6000058
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 88), *(uint32_t*)&val); }
    // 0x169d08: 0xae04004c
    WRITE32(ADD32(GPR_U32(ctx, 16), 76), GPR_U32(ctx, 4));
    // 0x169d0c: 0xae020050
    WRITE32(ADD32(GPR_U32(ctx, 16), 80), GPR_U32(ctx, 2));
    // 0x169d10: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x169d14: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x169d18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnHshapeAdd__FP6HSHAPE
// Address: 0x169d20 - 0x169d34

void entry_169d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169d34: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x169d38: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x169d3c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x169d44);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9960));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_169d44
// Address: 0x169d44 - 0x169d58

void entry_169d44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169d44: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x169d48: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x169d4c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x169d54: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x169d58; return;
}


// Function: OnHshapeRemove__FP6HSHAPE
// Address: 0x169d58 - 0x169d6c

void entry_169d6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169d6c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x169d70: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x169d74: 0xc054980
    SET_GPR_U32(ctx, 31, 0x169d7c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9960));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_169d7c
// Address: 0x169d7c - 0x169d90

void entry_169d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169d7c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x169d80: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x169d84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x169d8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x169d90; return;
}


// Function: BindHshape__FP6HSHAPE
// Address: 0x169d90 - 0x169dbc

void entry_169dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x169dbc) {
        switch (ctx->pc) {
            case 0x169dc8: ctx->pc = 0; goto label_169dc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x169dbc: 0xae020048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 2));
    // 0x169dc0: 0xac400398
    WRITE32(ADD32(GPR_U32(ctx, 2), 920), GPR_U32(ctx, 0));
    // 0x169dc4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_169dc8:
    // 0x169dc8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x169dcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x169dd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x169dd8; return;
}


// Function: CloneHshape__FP6HSHAPET0
// Address: 0x169dd8 - 0x169e00

void entry_169e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169e00: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x169e04: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x169e08: 0xb202003f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 63); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x169e0c: 0xb6020038
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 56); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x169e10: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x169e14: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x169e18: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetHshapeHidePos__FP6HSHAPEfP6VECTORPf
// Address: 0x169e20 - 0x169e64

void entry_169e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169e64: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x169e68: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x169e6c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x169e70: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x169e78);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_169e78
// Address: 0x169e78 - 0x169e8c

void entry_169e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169e78: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x169e7c: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x169e80: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x169e84: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x169e8c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_169e8c
// Address: 0x169e8c - 0x169f78

void entry_169e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x169e8c) {
        switch (ctx->pc) {
            case 0x169ea8: ctx->pc = 0; goto label_169ea8;
            case 0x169eb8: ctx->pc = 0; goto label_169eb8;
            case 0x169ec8: ctx->pc = 0; goto label_169ec8;
            case 0x169ecc: ctx->pc = 0; goto label_169ecc;
            case 0x169f4c: ctx->pc = 0; goto label_169f4c;
            case 0x169f58: ctx->pc = 0; goto label_169f58;
            case 0x169f64: ctx->pc = 0; goto label_169f64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x169e8c: 0x8e230040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x169e90: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_169ea8;
    }
    // 0x169e98: 0x10620007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_169eb8;
    }
    // 0x169ea0: 0x10000009
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_169ec8;
    }
label_169ea8:
    // 0x169ea8: 0x3c0141a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16800 << 16));
    // 0x169eac: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x169eb0: 0x10000006
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_169ecc;
    }
label_169eb8:
    // 0x169eb8: 0x3c01428c
    SET_GPR_U32(ctx, 1, ((uint32_t)17036 << 16));
    // 0x169ebc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x169ec0: 0x10000002
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_169ecc;
    }
label_169ec8:
    // 0x169ec8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
label_169ecc:
    // 0x169ecc: 0x12600025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_169f64;
    }
    // 0x169ed4: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x169ed8: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x169edc: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x169ee0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x169ee4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x169ee8: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x169eec: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x169ef0: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x169ef4: 0x4bc208ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x169ef8: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x169efc: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x169f00: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x169f04: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x169f08: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x169f0c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x169f10: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x169f14: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x169f18: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x169f1c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x169f20: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x169f24: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x169f28: 0x78630000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x169f2c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x169f30: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x169f34: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x169f38: 0x0
    // NOP
    // 0x169f3c: 0x45000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[4]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_169f4c;
    }
    // 0x169f44: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_169f58;
    }
label_169f4c:
    // 0x169f4c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x169f50: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x169f54: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_169f58:
    // 0x169f58: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x169f5c: 0x4be40848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x169f60: 0xfa610000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_169f64:
    // 0x169f64: 0x1240000f
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[13] = *(float*)&val; }
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x169FA4; return;
    }
    // 0x169f6c: 0xc7ac0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[12] = *(float*)&val; }
    // 0x169f70: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x169f78);
    ctx->f[12] = FPU_NEG_S(ctx->f[12]);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_169f78
// Address: 0x169f78 - 0x169fa0

void entry_169f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169f78: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x169f7c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x169f80: 0x8e220040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 64)));
    // 0x169f84: 0x14430008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x169FA8; return;
    }
    // 0x169f8c: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x169f90: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x169f94: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x169f98: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x169fa0);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_169fa0
// Address: 0x169fa0 - 0x169fc0

void entry_169fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x169fa0) {
        switch (ctx->pc) {
            case 0x169fa4: ctx->pc = 0; goto label_169fa4;
            case 0x169fa8: ctx->pc = 0; goto label_169fa8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x169fa0: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_169fa4:
    // 0x169fa4: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_169fa8:
    // 0x169fa8: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x169fac: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x169fb0: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x169fb4: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x169fb8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetHshapeClosestHidePos__FP6HSHAPEPfP6VECTORT1
// Address: 0x169fc0 - 0x169ff8

void entry_169ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x169ff8: 0x8e500034
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x169ffc: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16a000: 0x8e450018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x16a004: 0x24460140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 320));
    // 0x16a008: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16a00c: 0xafa30020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 3));
    // 0x16a010: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x16a018);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_16a018
// Address: 0x16a018 - 0x16a034

void entry_16a018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a018: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16a01c: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x16a020: 0x8e450018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x16a024: 0x24c68d20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937888));
    // 0x16a028: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a02c: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x16a034);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_16a034
// Address: 0x16a034 - 0x16a060

void entry_16a034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a034: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x16a038: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x16a03c: 0x10400008
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_16a060(rdram, ctx, runtime); return;
    }
    // 0x16a044: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a048: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16a04c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a050: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a054: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a058: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16a060);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16a060
// Address: 0x16a060 - 0x16a088

void entry_16a060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a060: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16a064: 0x14400015
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16A0BC; return;
    }
    // 0x16a06c: 0x8e440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 52)));
    // 0x16a070: 0x3c0141f0
    SET_GPR_U32(ctx, 1, ((uint32_t)16880 << 16));
    // 0x16a074: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x16a078: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x16a07c: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x16a080: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16a088);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16a088
// Address: 0x16a088 - 0x16a0cc

void entry_16a088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16a088) {
        switch (ctx->pc) {
            case 0x16a0a4: ctx->pc = 0; goto label_16a0a4;
            case 0x16a0b4: ctx->pc = 0; goto label_16a0b4;
            case 0x16a0bc: ctx->pc = 0; goto label_16a0bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16a088: 0xc7a10030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[1] = *(float*)&val; }
    // 0x16a08c: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16a090: 0x0
    // NOP
    // 0x16a094: 0x45000003
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16a0a4;
    }
    // 0x16a09c: 0x10000005
    ctx->f[1] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16a0b4;
    }
label_16a0a4:
    // 0x16a0a4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16a0a8: 0x0
    // NOP
    // 0x16a0ac: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[0]);
        goto label_16a0b4;
    }
label_16a0b4:
    // 0x16a0b4: 0xe7a10030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    // 0x16a0b8: 0xc7ac0030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[12] = *(float*)&val; }
label_16a0bc:
    // 0x16a0bc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16a0c0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16a0c4: 0xc05a788
    SET_GPR_U32(ctx, 31, 0x16a0cc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    GetHshapeHidePos__FP6HSHAPEfP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_16a0cc
// Address: 0x16a0cc - 0x16a100

void entry_16a0cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a0cc: 0xc7a00030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[0] = *(float*)&val; }
    // 0x16a0d0: 0x7bbf00a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x16a0d4: 0xe6a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 21), 0), *(uint32_t*)&val); }
    // 0x16a0d8: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x16a0dc: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x16a0e0: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x16a0e4: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16a0e8: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16a0ec: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16a0f0: 0xc7b400b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[20] = *(float*)&val; }
    // 0x16a0f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 192));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16a0fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16a100; return;
}


// Function: InitHpnt__FP4HPNT
// Address: 0x16a100 - 0x16a114

void entry_16a114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a114: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x16a118: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16a11c: 0xc440a798
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944664)); ctx->f[0] = *(float*)&val; }
    // 0x16a120: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16a124: 0xae030060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 3));
    // 0x16a128: 0xe6000070
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 112), *(uint32_t*)&val); }
    // 0x16a12c: 0xae040068
    WRITE32(ADD32(GPR_U32(ctx, 16), 104), GPR_U32(ctx, 4));
    // 0x16a130: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a134: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a138: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnHpntAdd__FP4HPNT
// Address: 0x16a140 - 0x16a154

void entry_16a154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a154: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16a158: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a15c: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x16a164);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9976));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_16a164
// Address: 0x16a164 - 0x16a178

void entry_16a164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a164: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a168: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a16c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16a174: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16a178; return;
}


// Function: OnHpntRemove__FP4HPNT
// Address: 0x16a178 - 0x16a18c

void entry_16a18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a18c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16a190: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a194: 0xc054980
    SET_GPR_U32(ctx, 31, 0x16a19c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9976));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_16a19c
// Address: 0x16a19c - 0x16a1b0

void entry_16a19c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a19c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a1a0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a1a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16a1ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16a1b0; return;
}


// Function: BindHpnt__FP4HPNT
// Address: 0x16a1b0 - 0x16a1dc

void entry_16a1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16a1dc) {
        switch (ctx->pc) {
            case 0x16a1e8: ctx->pc = 0; goto label_16a1e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16a1dc: 0xae020064
    WRITE32(ADD32(GPR_U32(ctx, 16), 100), GPR_U32(ctx, 2));
    // 0x16a1e0: 0xac400398
    WRITE32(ADD32(GPR_U32(ctx, 2), 920), GPR_U32(ctx, 0));
    // 0x16a1e4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_16a1e8:
    // 0x16a1e8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a1ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16a1f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16a1f8; return;
}


// Function: CloneHpnt__FP4HPNTT0
// Address: 0x16a1f8 - 0x16a220

void entry_16a220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a220: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16a224: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16a228: 0xb2020057
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 87); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16a22c: 0xb6020050
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 80); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16a230: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16a234: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a238: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetHpntClosestHidePos__FP4HPNTP6VECTORPf
// Address: 0x16a240 - 0x16a2b8

void entry_16a2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a2b8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16a2bc: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x16a2c4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_16a2c4
// Address: 0x16a2c4 - 0x16a300

void entry_16a2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16a2c4) {
        switch (ctx->pc) {
            case 0x16a2d4: ctx->pc = 0; goto label_16a2d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16a2c4: 0xda010000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x16a2c8: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a2cc: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16a2d0: 0xfa010000
    WRITE128(ADD32(GPR_U32(ctx, 16), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_16a2d4:
    // 0x16a2d4: 0x1240000b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16A304; return;
    }
    // 0x16a2dc: 0xe6540000
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x16a2e0: 0x8e220058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 88)));
    // 0x16a2e4: 0x14430008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x16A308; return;
    }
    // 0x16a2ec: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x16a2f0: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x16a2f4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x16a2f8: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x16a300);
    ctx->f[12] = FPU_ADD_S(ctx->f[20], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_16a300
// Address: 0x16a300 - 0x16a320

void entry_16a300(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16a300) {
        switch (ctx->pc) {
            case 0x16a304: ctx->pc = 0; goto label_16a304;
            case 0x16a308: ctx->pc = 0; goto label_16a308;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16a300: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
label_16a304:
    // 0x16a304: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_16a308:
    // 0x16a308: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16a30c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16a310: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a314: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x16a318: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0016a320
// Address: 0x16a320 - 0x16a348

void FUN_0016a320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a320: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x16a324: 0x7fb30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 19));
    // 0x16a328: 0x7fb20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 18));
    // 0x16a32c: 0xc0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x16a330: 0x7fb00020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 16));
    // 0x16a334: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x16a338: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x16a33c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16a340: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x16a348);
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 17));
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16a348
// Address: 0x16a348 - 0x16a358

void entry_16a348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a348: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16a34c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a350: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x16a358);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_16a358
// Address: 0x16a358 - 0x16a374

void entry_16a358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a358: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x16a35c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a360: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16a364: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16a368: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x16a36c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x16a374);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_16a374
// Address: 0x16a374 - 0x16a38c

void entry_16a374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a374: 0xc60c005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 92)); ctx->f[12] = *(float*)&val; }
    // 0x16a378: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a37c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16a380: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16a384: 0xc05a890
    SET_GPR_U32(ctx, 31, 0x16a38c);
    ctx->f[12] = FPU_MUL_S(ctx->f[0], ctx->f[12]);
    GetHpntClosestHidePos__FP4HPNTP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_16a38c
// Address: 0x16a38c - 0x16a3a8

void entry_16a38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a38c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16a390: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16a394: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16a398: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16a39c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16a3a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitHbsk__FP4HBSK
// Address: 0x16a3a8 - 0x16a3c8

void entry_16a3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a3c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a3cc: 0xc04a7ec
    SET_GPR_U32(ctx, 31, 0x16a3d4);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetAloRotationSpring__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_16a3d4
// Address: 0x16a3d4 - 0x16a3e0

void entry_16a3d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a3d4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a3d8: 0xc04a820
    SET_GPR_U32(ctx, 31, 0x16a3e0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetAloRotationDamping__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_16a3e0
// Address: 0x16a3e0 - 0x16a3ec

void entry_16a3e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a3e0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x16a3e4: 0xc04a854
    SET_GPR_U32(ctx, 31, 0x16a3ec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetAloPositionSmooth__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_16a3ec
// Address: 0x16a3ec - 0x16a3fc

void entry_16a3ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a3ec: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x16a3f0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x16a3f4: 0xc04a89c
    SET_GPR_U32(ctx, 31, 0x16a3fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetAloRotationSmooth__FP3ALOf(rdram, ctx, runtime); return;
}


// Function: entry_16a3fc
// Address: 0x16a3fc - 0x16a420

void entry_16a3fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a3fc: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x16a400: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16a404: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a408: 0xe6000568
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1384), *(uint32_t*)&val); }
    // 0x16a40c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a410: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x16a414: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16a41c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16a420; return;
}


// Function: LoadHbskFromBrx__FP4HBSKP18CBinaryInputStream
// Address: 0x16a420 - 0x16a434

void entry_16a434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a434: 0x8e020224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 548)));
    // 0x16a438: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 548)));
        ctx->pc = 0x16A450; return;
    }
    // 0x16a440: 0xc063570
    SET_GPR_U32(ctx, 31, 0x16a448);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 192));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16a448
// Address: 0x16a448 - 0x16a490

void entry_16a448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16a448) {
        switch (ctx->pc) {
            case 0x16a450: ctx->pc = 0; goto label_16a450;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16a448: 0xae020224
    WRITE32(ADD32(GPR_U32(ctx, 16), 548), GPR_U32(ctx, 2));
    // 0x16a44c: 0x8e030224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 548)));
label_16a450:
    // 0x16a450: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x16a454: 0x24a583d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294935504));
    // 0x16a458: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a45c: 0x8c6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 176)));
    // 0x16a460: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x16a464: 0xac6200b0
    WRITE32(ADD32(GPR_U32(ctx, 3), 176), GPR_U32(ctx, 2));
    // 0x16a468: 0x8e040224
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 548)));
    // 0x16a46c: 0x78a20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x16a470: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a474: 0x7c820000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 2));
    // 0x16a478: 0x78a30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x16a47c: 0x7c830010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 3));
    // 0x16a480: 0x78a20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 5), 32)));
    // 0x16a484: 0x7c820020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 2));
    // 0x16a488: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnHbskAdd__FP4HBSK
// Address: 0x16a490 - 0x16a4a4

void entry_16a4a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a4a4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16a4a8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a4ac: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x16a4b4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9992));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_16a4b4
// Address: 0x16a4b4 - 0x16a4c8

void entry_16a4b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a4b4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a4b8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a4bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16a4c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16a4c8; return;
}


// Function: OnHbskRemove__FP4HBSK
// Address: 0x16a4c8 - 0x16a4dc

void entry_16a4dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a4dc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16a4e0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a4e4: 0xc054980
    SET_GPR_U32(ctx, 31, 0x16a4ec);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 9992));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_16a4ec
// Address: 0x16a4ec - 0x16a500

void entry_16a4ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a4ec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a4f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a4f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16a4fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16a500; return;
}


// Function: CloneHbsk__FP4HBSKT0
// Address: 0x16a500 - 0x16a528

void entry_16a528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a528: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16a52c: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16a530: 0xb202055f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1375); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16a534: 0xb6020558
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 1368); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16a538: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16a53c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a540: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FIgnoreHbskIntersection__FP4HBSKP2SO
// Address: 0x16a548 - 0x16a570

void entry_16a570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a570: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a574: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16a57c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16a580; return;
}


// Function: PresetHbskAccel__FP4HBSKf
// Address: 0x16a580 - 0x16a59c

void entry_16a59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a59c: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x16a5a0: 0x1440000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16A5DC; return;
    }
    // 0x16a5a8: 0x260400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 208));
    // 0x16a5ac: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a5b0: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x16a5b8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_16a5b8
// Address: 0x16a5b8 - 0x16a5d8

void entry_16a5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a5b8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a5bc: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x16a5c0: 0x8c860214
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 532)));
    // 0x16a5c4: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x16a5c8: 0x8c880218
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 4), 536)));
    // 0x16a5cc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x16a5d0: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x16a5d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_16a5d8
// Address: 0x16a5d8 - 0x16a5f0

void entry_16a5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16a5d8) {
        switch (ctx->pc) {
            case 0x16a5dc: ctx->pc = 0; goto label_16a5dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16a5d8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_16a5dc:
    // 0x16a5dc: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16a5e0: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x16a5e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16a5ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16a5f0; return;
}


// Function: SetHbskHbsks__FP4HBSK5HBSKS
// Address: 0x16a5f0 - 0x16a634

void entry_16a634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a634: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16a638: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a63c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a640: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a644: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x16a64c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_16a64c
// Address: 0x16a64c - 0x16a660

void entry_16a64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a64c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16a650: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16a654: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a658: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x16a660);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_16a660
// Address: 0x16a660 - 0x16a680

void entry_16a660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a660: 0x56700032
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 16)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 1360), GPR_U32(ctx, 19));
        ctx->pc = 0x16A72C; return;
    }
    // 0x16a668: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x16a66c: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x16a670: 0x8e252e10
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x16a674: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x16a678: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16a680);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16a680
// Address: 0x16a680 - 0x16a69c

void entry_16a680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a680: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x16a684: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x16a688: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x16a68c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16a690: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x16a694: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16a69c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16a69c
// Address: 0x16a69c - 0x16a6b0

void entry_16a69c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a69c: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x16a6a0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a6a4: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x16a6a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16a6b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16a6b0
// Address: 0x16a6b0 - 0x16a6c8

void entry_16a6b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a6b0: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16a6b4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a6b8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16a6bc: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16a6c0: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x16a6c8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_16a6c8
// Address: 0x16a6c8 - 0x16a6dc

void entry_16a6c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a6c8: 0x8e242e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x16a6cc: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16a6d0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a6d4: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x16a6dc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 272));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_16a6dc
// Address: 0x16a6dc - 0x16a6f4

void entry_16a6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a6dc: 0x27b00060
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 96));
    // 0x16a6e0: 0x27b10030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 48));
    // 0x16a6e4: 0x26440110
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 272));
    // 0x16a6e8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a6ec: 0xc0624de
    SET_GPR_U32(ctx, 31, 0x16a6f4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    TiltMatUpright__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_16a6f4
// Address: 0x16a6f4 - 0x16a704

void entry_16a6f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a6f4: 0x27a500a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 160));
    // 0x16a6f8: 0x27a60090
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 144));
    // 0x16a6fc: 0xc06234a
    SET_GPR_U32(ctx, 31, 0x16a704);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DecomposeRotateMatrixRad__FP7MATRIX3PfP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_16a704
// Address: 0x16a704 - 0x16a714

void entry_16a704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a704: 0x8e460224
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x16a708: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16a70c: 0xc062454
    SET_GPR_U32(ctx, 31, 0x16a714);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_16a714
// Address: 0x16a714 - 0x16a728

void entry_16a714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a714: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16a718: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16a71c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16a720: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x16a728);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_16a728
// Address: 0x16a728 - 0x16a758

void entry_16a728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16a728) {
        switch (ctx->pc) {
            case 0x16a72c: ctx->pc = 0; goto label_16a72c;
            case 0x16a738: ctx->pc = 0; goto label_16a738;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16a728: 0xae530550
    WRITE32(ADD32(GPR_U32(ctx, 18), 1360), GPR_U32(ctx, 19));
label_16a72c:
    // 0x16a72c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16a730: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x16a734: 0xe6400554
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1364), *(uint32_t*)&val); }
label_16a738:
    // 0x16a738: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x16a73c: 0x7bb300e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x16a740: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x16a744: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x16a748: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x16a74c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16a754: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16a758; return;
}


// Function: CdartStuckHbsk__FP4HBSK
// Address: 0x16a758 - 0x16a7c4

void entry_16a7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16a7c4) {
        switch (ctx->pc) {
            case 0x16a7dc: ctx->pc = 0; goto label_16a7dc;
            case 0x16a7f8: ctx->pc = 0; goto label_16a7f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16a7c4: 0x10400005
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16a7dc;
    }
    // 0x16a7cc: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x16a7d0: 0x2442fffd
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967293));
    // 0x16a7d4: 0x242102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x16a7d8: 0x62880a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 3));
label_16a7dc:
    // 0x16a7dc: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x16a7e0: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    // 0x16a7e4: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16a7e8: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x16a7ec: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16a7f0: 0x1600fff1
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16A7B8; return;
    }
label_16a7f8:
    // 0x16a7f8: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x16a7fc: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16a800: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16a804: 0xae63b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 3));
    // 0x16a808: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16a80c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16a810: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16a814: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a818: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PdartOldestHbskStuck__FP4HBSK
// Address: 0x16a820 - 0x16a894

void entry_16a894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16a894) {
        switch (ctx->pc) {
            case 0x16a8c8: ctx->pc = 0; goto label_16a8c8;
            case 0x16a8cc: ctx->pc = 0; goto label_16a8cc;
            case 0x16a8e0: ctx->pc = 0; goto label_16a8e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16a894: 0x1040000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16a8c8;
    }
    // 0x16a89c: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x16a8a0: 0x14520009
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        goto label_16a8c8;
    }
    // 0x16a8a8: 0xc6000554
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1364)); ctx->f[0] = *(float*)&val; }
    // 0x16a8ac: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16a8b0: 0x0
    // NOP
    // 0x16a8b4: 0x45000005
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16a8cc;
    }
    // 0x16a8bc: 0x200882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16a8c0: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x16a8c4: 0x8fa20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4)));
label_16a8c8:
    // 0x16a8c8: 0x8fa30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 8)));
label_16a8cc:
    // 0x16a8cc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16a8d0: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x16a8d4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16a8d8: 0x1600ffeb
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16A888; return;
    }
label_16a8e0:
    // 0x16a8e0: 0x8fa3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 12)));
    // 0x16a8e4: 0x220102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16a8e8: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16a8ec: 0xae63b314
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294947604), GPR_U32(ctx, 3));
    // 0x16a8f0: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16a8f4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16a8f8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16a8fc: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16a900: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x16a904: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16a90c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16a910; return;
}


// Function: GetHbskClosestHidePos__FP4HBSKP6VECTORPf
// Address: 0x16a910 - 0x16a934

void entry_16a934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16a934) {
        switch (ctx->pc) {
            case 0x16a9b8: ctx->pc = 0; goto label_16a9b8;
            case 0x16a9c4: ctx->pc = 0; goto label_16a9c4;
            case 0x16a9d0: ctx->pc = 0; goto label_16a9d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16a934: 0xda040140
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x16a938: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x16a93c: 0x4be4086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16a940: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16a944: 0x12200022
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_16a9d0;
    }
    // 0x16a94c: 0xc6000560
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1376)); ctx->f[0] = *(float*)&val; }
    // 0x16a950: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x16a954: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16a958: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x16a95c: 0x3c01428c
    SET_GPR_U32(ctx, 1, ((uint32_t)17036 << 16));
    // 0x16a960: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16a964: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16a968: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16a96c: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16a970: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16a974: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16a978: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16a97c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16a980: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x16a984: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x16a988: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x16a98c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x16a990: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16a994: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x16a998: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16a99c: 0x46031034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16a9a0: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x16a9a4: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x16a9a8: 0x45000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16a9b8;
    }
    // 0x16a9b0: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16a9c4;
    }
label_16a9b8:
    // 0x16a9b8: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x16a9bc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16a9c0: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_16a9c4:
    // 0x16a9c4: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x16a9c8: 0x4be20848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16a9cc: 0xfa210000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_16a9d0:
    // 0x16a9d0: 0x1240000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16AA00; return;
    }
    // 0x16a9d8: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x16a9dc: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x16a9e4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_16a9e4
// Address: 0x16a9e4 - 0x16a9f8

void entry_16a9e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16a9e4: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x16a9e8: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x16a9ec: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x16a9f0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x16a9f8);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_16a9f8
// Address: 0x16a9f8 - 0x16aa18

void entry_16a9f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16a9f8) {
        switch (ctx->pc) {
            case 0x16aa00: ctx->pc = 0; goto label_16aa00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16a9f8: 0xe6400000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 0), *(uint32_t*)&val); }
    // 0x16a9fc: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_16aa00:
    // 0x16aa00: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16aa04: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16aa08: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16aa0c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16aa14: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16aa18; return;
}


// Function: iterates_levels_something
// Address: 0x16aa18 - 0x16aa48

void entry_16aa48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16aa48: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x16aa4c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16aa50: 0x24c62718
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 10008));
    // 0x16aa54: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x16aa5c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_16aa5c
// Address: 0x16aa5c - 0x16aac0

void entry_16aa5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16aa5c) {
        switch (ctx->pc) {
            case 0x16aa90: ctx->pc = 0; goto label_16aa90;
            case 0x16aab8: ctx->pc = 0; goto label_16aab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16aa5c: 0x8e030008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16aa60: 0x2462faeb
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294965995));
    // 0x16aa64: 0x2c420005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 5));
    // 0x16aa68: 0x10400028
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294965996));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16AB0C; return;
    }
    // 0x16aa70: 0x2402044c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x16aa74: 0x62a818
    { int64_t result = (int64_t)GPR_S32(ctx, 3) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x16aa78: 0x3a200
    SET_GPR_U32(ctx, 20, SLL32(GPR_U32(ctx, 3), 8));
    // 0x16aa7c: 0x261202d0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 720));
    // 0x16aa80: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16aa84: 0x24170008
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 8));
    // 0x16aa88: 0x3c160026
    SET_GPR_U32(ctx, 22, ((uint32_t)38 << 16));
    // 0x16aa8c: 0x0
    // NOP
label_16aa90:
    // 0x16aa90: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x16aa94: 0x5040001a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
        entry_16ab00(rdram, ctx, runtime); return;
    }
    // 0x16aa9c: 0x16770006
    SET_GPR_U32(ctx, 17, OR32(GPR_U32(ctx, 20), GPR_U32(ctx, 19)));
    if (GPR_U32(ctx, 19) != GPR_U32(ctx, 23)) {
        goto label_16aab8;
    }
    // 0x16aaa4: 0x8ec223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 22), 9152)));
    // 0x16aaa8: 0x551021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 21)));
    // 0x16aaac: 0x8c430458
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x16aab0: 0x1000000c
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16AAE4; return;
    }
label_16aab8:
    // 0x16aab8: 0xc058076
    SET_GPR_U32(ctx, 31, 0x16aac0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    get_level_completion_by_id(rdram, ctx, runtime); return;
}


// Function: entry_16aac0
// Address: 0x16aac0 - 0x16aacc

void entry_16aac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16aac0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16aac4: 0xc058204
    SET_GPR_U32(ctx, 31, 0x16aacc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    LsFromWid(rdram, ctx, runtime); return;
}


// Function: entry_16aacc
// Address: 0x16aacc - 0x16ab00

void entry_16aacc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16aacc) {
        switch (ctx->pc) {
            case 0x16aae0: ctx->pc = 0; goto label_16aae0;
            case 0x16aae4: ctx->pc = 0; goto label_16aae4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16aacc: 0x32100002
    SET_GPR_U32(ctx, 16, AND32(GPR_U32(ctx, 16), 2));
    // 0x16aad0: 0x12000003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_16aae0;
    }
    // 0x16aad8: 0x10000002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16aae4;
    }
label_16aae0:
    // 0x16aae0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
label_16aae4:
    // 0x16aae4: 0x10400006
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_16ab00(rdram, ctx, runtime); return;
    }
    // 0x16aaec: 0x8e440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x16aaf0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x16aaf4: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x16aaf8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16ab00);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16ab00
// Address: 0x16ab00 - 0x16ab38

void entry_16ab00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ab00) {
        switch (ctx->pc) {
            case 0x16ab0c: ctx->pc = 0; goto label_16ab0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ab00: 0x2a620009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 9));
    // 0x16ab04: 0x1440ffe2
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16AA90; return;
    }
label_16ab0c:
    // 0x16ab0c: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x16ab10: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x16ab14: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16ab18: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16ab1c: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16ab20: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16ab24: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16ab28: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16ab2c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16ab30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: calls_something
// Address: 0x16ab38 - 0x16ab80

void entry_16ab80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ab80) {
        switch (ctx->pc) {
            case 0x16ab84: ctx->pc = 0; goto label_16ab84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ab80: 0xae2202e0
    WRITE32(ADD32(GPR_U32(ctx, 17), 736), GPR_U32(ctx, 2));
label_16ab84:
    // 0x16ab84: 0x8e2402e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 740)));
    // 0x16ab88: 0x10800005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16ABA0; return;
    }
    // 0x16ab90: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16ab94: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x16ab9c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_16ab9c
// Address: 0x16ab9c - 0x16abb8

void entry_16ab9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ab9c) {
        switch (ctx->pc) {
            case 0x16aba0: ctx->pc = 0; goto label_16aba0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ab9c: 0xae2202e8
    WRITE32(ADD32(GPR_U32(ctx, 17), 744), GPR_U32(ctx, 2));
label_16aba0:
    // 0x16aba0: 0x8e2402ec
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 748)));
    // 0x16aba4: 0x10800005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16ABBC; return;
    }
    // 0x16abac: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16abb0: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x16abb8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_16abb8
// Address: 0x16abb8 - 0x16abd4

void entry_16abb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16abb8) {
        switch (ctx->pc) {
            case 0x16abbc: ctx->pc = 0; goto label_16abbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16abb8: 0xae2202f0
    WRITE32(ADD32(GPR_U32(ctx, 17), 752), GPR_U32(ctx, 2));
label_16abbc:
    // 0x16abbc: 0x8e2402f4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 756)));
    // 0x16abc0: 0x10800005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16ABD8; return;
    }
    // 0x16abc8: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16abcc: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x16abd4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_16abd4
// Address: 0x16abd4 - 0x16ac90

void entry_16abd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16abd4) {
        switch (ctx->pc) {
            case 0x16abd8: ctx->pc = 0; goto label_16abd8;
            case 0x16abf0: ctx->pc = 0; goto label_16abf0;
            case 0x16ac48: ctx->pc = 0; goto label_16ac48;
            case 0x16ac60: ctx->pc = 0; goto label_16ac60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16abd4: 0xae2202f8
    WRITE32(ADD32(GPR_U32(ctx, 17), 760), GPR_U32(ctx, 2));
label_16abd8:
    // 0x16abd8: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x16abdc: 0xae2202fc
    WRITE32(ADD32(GPR_U32(ctx, 17), 764), GPR_U32(ctx, 2));
    // 0x16abe0: 0x2635033c
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 17), 828));
    // 0x16abe4: 0x3c1e0027
    SET_GPR_U32(ctx, 30, ((uint32_t)39 << 16));
    // 0x16abe8: 0x3c170027
    SET_GPR_U32(ctx, 23, ((uint32_t)39 << 16));
    // 0x16abec: 0x0
    // NOP
label_16abf0:
    // 0x16abf0: 0x8e2202fc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 764)));
    // 0x16abf4: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16abf8: 0x28420003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 3));
    // 0x16abfc: 0x14400012
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1100));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_16ac48;
    }
    // 0x16ac04: 0x24a4fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294967294));
    // 0x16ac08: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16ac0c: 0x862018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x16ac10: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x16ac14: 0x24630458
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1112));
    // 0x16ac18: 0x642021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x16ac1c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x16ac20: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x16ac24: 0x14400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_16ac48;
    }
    // 0x16ac2c: 0x24a4ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x16ac30: 0x861018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 6); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x16ac34: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16ac38: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16ac3c: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x16ac40: 0x5040ffeb
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 764), GPR_U32(ctx, 4));
        goto label_16abf0;
    }
label_16ac48:
    // 0x16ac48: 0x18a00017
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 5) <= 0) {
        ctx->pc = 0x16ACA8; return;
    }
    // 0x16ac50: 0x3c140026
    SET_GPR_U32(ctx, 20, ((uint32_t)38 << 16));
    // 0x16ac54: 0x2412044c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x16ac58: 0x26300310
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 784));
    // 0x16ac5c: 0x0
    // NOP
label_16ac60:
    // 0x16ac60: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x16ac64: 0x1080000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 9152)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_16ac90(rdram, ctx, runtime); return;
    }
    // 0x16ac6c: 0x521021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 18)));
    // 0x16ac70: 0x8c430458
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x16ac74: 0x30630001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 1));
    // 0x16ac78: 0x50600006
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 764)));
        ctx->pc = 0x16AC94; return;
    }
    // 0x16ac80: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x16ac84: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x16ac88: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16ac90);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16ac90
// Address: 0x16ac90 - 0x16ad20

void entry_16ac90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ac90) {
        switch (ctx->pc) {
            case 0x16ac94: ctx->pc = 0; goto label_16ac94;
            case 0x16aca8: ctx->pc = 0; goto label_16aca8;
            case 0x16acc0: ctx->pc = 0; goto label_16acc0;
            case 0x16ad00: ctx->pc = 0; goto label_16ad00;
            case 0x16ad18: ctx->pc = 0; goto label_16ad18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ac90: 0x8e2202fc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 764)));
label_16ac94:
    // 0x16ac94: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x16ac98: 0x2652044c
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1100));
    // 0x16ac9c: 0x53102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 19)));
    // 0x16aca0: 0x1040ffef
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16AC60; return;
    }
label_16aca8:
    // 0x16aca8: 0x2a0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x16acac: 0xae200308
    WRITE32(ADD32(GPR_U32(ctx, 17), 776), GPR_U32(ctx, 0));
    // 0x16acb0: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16acb4: 0x24160001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16acb8: 0x24150002
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16acbc: 0x24140003
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 3));
label_16acc0:
    // 0x16acc0: 0x8e720000
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x16acc4: 0x52400022
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
        ctx->pc = 0x16AD50; return;
    }
    // 0x16accc: 0x8e420304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 772)));
    // 0x16acd0: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16acd4: 0x5460001e
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
        ctx->pc = 0x16AD50; return;
    }
    // 0x16acdc: 0x1216000e
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 22)) {
        goto label_16ad18;
    }
    // 0x16ace4: 0x2a020002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 2));
    // 0x16ace8: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16ad00;
    }
    // 0x16acf0: 0x52000015
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        ctx->pc = 0x16AD48; return;
    }
    // 0x16acf8: 0x10000013
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16AD48; return;
    }
label_16ad00:
    // 0x16ad00: 0x12150009
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 21)) {
        ctx->pc = 0x16AD28; return;
    }
    // 0x16ad08: 0x1214000b
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 20)) {
        ctx->pc = 0x16AD38; return;
    }
    // 0x16ad10: 0x1000000d
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16AD48; return;
    }
label_16ad18:
    // 0x16ad18: 0xc0580a8
    SET_GPR_U32(ctx, 31, 0x16ad20);
    get_game_completion__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16ad20
// Address: 0x16ad20 - 0x16ad30

void entry_16ad20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ad20) {
        switch (ctx->pc) {
            case 0x16ad28: ctx->pc = 0; goto label_16ad28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ad20: 0x10000008
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16AD44; return;
    }
label_16ad28:
    // 0x16ad28: 0xc0580a8
    SET_GPR_U32(ctx, 31, 0x16ad30);
    get_game_completion__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16ad30
// Address: 0x16ad30 - 0x16ad40

void entry_16ad30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ad30) {
        switch (ctx->pc) {
            case 0x16ad38: ctx->pc = 0; goto label_16ad38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ad30: 0x10000004
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 2), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16AD44; return;
    }
label_16ad38:
    // 0x16ad38: 0xc0580a8
    SET_GPR_U32(ctx, 31, 0x16ad40);
    get_game_completion__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16ad40
// Address: 0x16ad40 - 0x16adfc

void entry_16ad40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ad40) {
        switch (ctx->pc) {
            case 0x16ad44: ctx->pc = 0; goto label_16ad44;
            case 0x16ad48: ctx->pc = 0; goto label_16ad48;
            case 0x16ad50: ctx->pc = 0; goto label_16ad50;
            case 0x16ad5c: ctx->pc = 0; goto label_16ad5c;
            case 0x16ad70: ctx->pc = 0; goto label_16ad70;
            case 0x16ad78: ctx->pc = 0; goto label_16ad78;
            case 0x16adac: ctx->pc = 0; goto label_16adac;
            case 0x16ade0: ctx->pc = 0; goto label_16ade0;
            case 0x16adf0: ctx->pc = 0; goto label_16adf0;
            case 0x16adf4: ctx->pc = 0; goto label_16adf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ad40: 0x218c3
    SET_GPR_S32(ctx, 3, SRA32(GPR_S32(ctx, 2), 3));
label_16ad44:
    // 0x16ad44: 0x30630001
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 1));
label_16ad48:
    // 0x16ad48: 0x14600009
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_16ad70;
    }
label_16ad50:
    // 0x16ad50: 0x2a020004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 4));
    // 0x16ad54: 0x1440ffda
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16ACC0; return;
    }
label_16ad5c:
    // 0x16ad5c: 0x8e220308
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 776)));
    // 0x16ad60: 0x10400005
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16ad78;
    }
    // 0x16ad68: 0x10000022
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16adf4;
    }
label_16ad70:
    // 0x16ad70: 0x1000fffa
    WRITE32(ADD32(GPR_U32(ctx, 17), 776), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16ad5c;
    }
label_16ad78:
    // 0x16ad78: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16ad7c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16ad80: 0x8c4523cc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 9164)));
    // 0x16ad84: 0x10a30009
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 3)) {
        goto label_16adac;
    }
    // 0x16ad8c: 0x2403044c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x16ad90: 0x8cc423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 9152)));
    // 0x16ad94: 0xa31818
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 3); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x16ad98: 0x832021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x16ad9c: 0x8c820458
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1112)));
    // 0x16ada0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x16ada4: 0x14400013
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_16adf4;
    }
label_16adac:
    // 0x16adac: 0x8e2502fc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 764)));
    // 0x16adb0: 0x2407044c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1100));
    // 0x16adb4: 0x8cc223c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 9152)));
    // 0x16adb8: 0x24a6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 5), 4294967295));
    // 0x16adbc: 0xc71818
    { int64_t result = (int64_t)GPR_S32(ctx, 6) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x16adc0: 0x24440458
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 1112));
    // 0x16adc4: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x16adc8: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16adcc: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x16add0: 0x14400003
    { int64_t result = (int64_t)GPR_S32(ctx, 5) * (int64_t)GPR_S32(ctx, 7); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_16ade0;
    }
    // 0x16add8: 0x10000005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967294));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16adf0;
    }
label_16ade0:
    // 0x16ade0: 0x441821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x16ade4: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16ade8: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x16adec: 0xc2280a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 6));
label_16adf0:
    // 0x16adf0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_16adf4:
    // 0x16adf4: 0xc05acc0
    SET_GPR_U32(ctx, 31, 0x16adfc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    something(rdram, ctx, runtime); return;
}


// Function: entry_16adfc
// Address: 0x16adfc - 0x16ae74

void entry_16adfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16adfc) {
        switch (ctx->pc) {
            case 0x16ae18: ctx->pc = 0; goto label_16ae18;
            case 0x16ae50: ctx->pc = 0; goto label_16ae50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16adfc: 0x8e2202f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 752)));
    // 0x16ae00: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 764)));
        goto label_16ae18;
    }
    // 0x16ae08: 0x8e2202f8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 760)));
    // 0x16ae0c: 0x10400023
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 23488));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16AE9C; return;
    }
    // 0x16ae14: 0x8e2502fc
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 764)));
label_16ae18:
    // 0x16ae18: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x16ae1c: 0x54a2000c
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 768), GPR_U32(ctx, 5));
        goto label_16ae50;
    }
    // 0x16ae24: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x16ae28: 0x8c6323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    // 0x16ae2c: 0x8c621588
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 5512)));
    // 0x16ae30: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x16ae34: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 768), GPR_U32(ctx, 0));
        goto label_16ae50;
    }
    // 0x16ae3c: 0x8c6219d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6612)));
    // 0x16ae40: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x16ae44: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 768), GPR_U32(ctx, 5));
        goto label_16ae50;
    }
    // 0x16ae4c: 0xae200300
    WRITE32(ADD32(GPR_U32(ctx, 17), 768), GPR_U32(ctx, 0));
label_16ae50:
    // 0x16ae50: 0x8e2402f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 752)));
    // 0x16ae54: 0x10800007
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_16ae74(rdram, ctx, runtime); return;
    }
    // 0x16ae5c: 0x8e220300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 768)));
    // 0x16ae60: 0x24632860
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 10336));
    // 0x16ae64: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x16ae68: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16ae6c: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x16ae74);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_16ae74
// Address: 0x16ae74 - 0x16ae98

void entry_16ae74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ae74: 0x8e2402f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 760)));
    // 0x16ae78: 0x10800007
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_16ae98(rdram, ctx, runtime); return;
    }
    // 0x16ae80: 0x8e220300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 768)));
    // 0x16ae84: 0x24632860
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 10336));
    // 0x16ae88: 0x210c0
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 3));
    // 0x16ae8c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16ae90: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x16ae98);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_16ae98
// Address: 0x16ae98 - 0x16aea4

void entry_16ae98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ae98) {
        switch (ctx->pc) {
            case 0x16ae9c: ctx->pc = 0; goto label_16ae9c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ae98: 0x27c45bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 30), 23488));
label_16ae9c:
    // 0x16ae9c: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x16aea4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 23), 4294965904));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_16aea4
// Address: 0x16aea4 - 0x16aed8

void entry_16aea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16aea4: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x16aea8: 0x7bbe0080
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x16aeac: 0x7bb70070
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x16aeb0: 0x7bb60060
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16aeb4: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16aeb8: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16aebc: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16aec0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16aec4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16aec8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16aecc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16aed4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16aed8; return;
}


// Function: Post_something_load
// Address: 0x16aed8 - 0x16aeec

void entry_16aeec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16aeec: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x16aef0: 0x2404fcff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294966527));
    // 0x16aef4: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x16aef8: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x16aefc: 0x42438
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 16);
    // 0x16af00: 0x3484ffff
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 4), 65535));
    // 0x16af04: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x16af08: 0x52e78
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 25);
    // 0x16af0c: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x16af10: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x16af14: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x16af18: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x16af1c: 0x24635bc0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 23488));
    // 0x16af20: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    // 0x16af24: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16af28: 0xacd0fcf0
    WRITE32(ADD32(GPR_U32(ctx, 6), 4294966512), GPR_U32(ctx, 16));
    // 0x16af2c: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x16af30: 0xc07a5be
    SET_GPR_U32(ctx, 31, 0x16af38);
    WRITE32(ADD32(GPR_U32(ctx, 3), 48), GPR_U32(ctx, 5));
    SetUiUis__FP2UI3UIS(rdram, ctx, runtime); return;
}


// Function: entry_16af38
// Address: 0x16af38 - 0x16af4c

void entry_16af38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16af38: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x16af3c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16af40: 0x24050012
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 18));
    // 0x16af44: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x16af4c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 10120));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_16af4c
// Address: 0x16af4c - 0x16af70

void entry_16af4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16af4c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16af50: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x16af54: 0x3c050017
    SET_GPR_U32(ctx, 5, ((uint32_t)23 << 16));
    // 0x16af58: 0xae0202d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 720), GPR_U32(ctx, 2));
    // 0x16af5c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16af60: 0x24a5ab38
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294945592));
    // 0x16af64: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16af68: 0xc076f32
    SET_GPR_U32(ctx, 31, 0x16af70);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PostSwCallback__FP2SWPFPv5MSGIDPv_vPv5MSGIDT2(rdram, ctx, runtime); return;
}


// Function: entry_16af70
// Address: 0x16af70 - 0x16af80

void entry_16af70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16af70: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16af74: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16af78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: hideout_set_focus
// Address: 0x16af80 - 0x16b00c

void entry_16b00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b00c) {
        switch (ctx->pc) {
            case 0x16b014: ctx->pc = 0; goto label_16b014;
            case 0x16b030: ctx->pc = 0; goto label_16b030;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b00c: 0x10000017
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 4294963512));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B06C; return;
    }
label_16b014:
    // 0x16b014: 0x8cc20300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 768)));
    // 0x16b018: 0x14a2000b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x16B048; return;
    }
    // 0x16b020: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x16b024: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x16b028: 0x8c66f138
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 3), 4294963512)));
    // 0x16b02c: 0x24a5a7b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294944688));
label_16b030:
    // 0x16b030: 0x2464f138
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 4294963512));
    // 0x16b034: 0x8cc20020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 32)));
    // 0x16b038: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16b040);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16b040
// Address: 0x16b040 - 0x16b068

void entry_16b040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b040) {
        switch (ctx->pc) {
            case 0x16b048: ctx->pc = 0; goto label_16b048;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b040: 0x1000000a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 4294963512));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B06C; return;
    }
label_16b048:
    // 0x16b048: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x16b04c: 0x8c46f138
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 4294963512)));
    // 0x16b050: 0x24a5a7a0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294944672));
    // 0x16b054: 0x2444f138
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294963512));
    // 0x16b058: 0x8cc30020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 32)));
    // 0x16b05c: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16b060: 0x60f809
    SET_GPR_U32(ctx, 31, 0x16b068);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_16b068
// Address: 0x16b068 - 0x16b078

void entry_16b068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b068) {
        switch (ctx->pc) {
            case 0x16b06c: ctx->pc = 0; goto label_16b06c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b068: 0x2650f138
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 4294963512));
label_16b06c:
    // 0x16b06c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x16b070: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x16b078);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_16b078
// Address: 0x16b078 - 0x16b08c

void entry_16b078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b078: 0x8e43f138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4294963512)));
    // 0x16b07c: 0xae000464
    WRITE32(ADD32(GPR_U32(ctx, 16), 1124), GPR_U32(ctx, 0));
    // 0x16b080: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x16b084: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16b08c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16b08c
// Address: 0x16b08c - 0x16b0b0

void entry_16b08c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b08c: 0x1220000e
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B0C8; return;
    }
    // 0x16b094: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x16b098: 0x8e03fa90
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294965904)));
    // 0x16b09c: 0x2611fa90
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 4294965904));
    // 0x16b0a0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16b0a4: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x16b0a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16b0b0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294944696));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16b0b0
// Address: 0x16b0b0 - 0x16b0c0

void entry_16b0b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b0b0: 0x8e03fa90
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 4294965904)));
    // 0x16b0b4: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x16b0b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16b0c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16b0c0
// Address: 0x16b0c0 - 0x16b0dc

void entry_16b0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b0c0) {
        switch (ctx->pc) {
            case 0x16b0c8: ctx->pc = 0; goto label_16b0c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b0c0: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B0E0; return;
    }
label_16b0c8:
    // 0x16b0c8: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x16b0cc: 0x8c83fa90
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294965904)));
    // 0x16b0d0: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x16b0d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16b0dc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294965904));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16b0dc
// Address: 0x16b0dc - 0x16b0f8

void entry_16b0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b0dc) {
        switch (ctx->pc) {
            case 0x16b0e0: ctx->pc = 0; goto label_16b0e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b0dc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_16b0e0:
    // 0x16b0e0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16b0e4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16b0e8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16b0ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16b0f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16b0f8; return;
}


// Function: FTakeStepguardDamage
// Address: 0x16b0f8 - 0x16b118

void entry_16b118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b118) {
        switch (ctx->pc) {
            case 0x16b14c: ctx->pc = 0; goto label_16b14c;
            case 0x16b168: ctx->pc = 0; goto label_16b168;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b118: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x16b11c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x16b120: 0x8e2302fc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 764)));
    // 0x16b124: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x16b128: 0x38620005
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), 5));
    // 0x16b12c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16b130: 0x0
    // NOP
    // 0x16b134: 0x45000005
    SET_GPR_U32(ctx, 4, SLTU32(GPR_U32(ctx, 2), 1));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16b14c;
    }
    // 0x16b13c: 0x5e00000a
    if (GPR_S32(ctx, 16) > 0) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294967295));
        goto label_16b168;
    }
    // 0x16b144: 0x10000008
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16b168;
    }
label_16b14c:
    // 0x16b14c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16b150: 0x0
    // NOP
    // 0x16b154: 0x45000004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 3)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16b168;
    }
    // 0x16b15c: 0x54400002
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
        goto label_16b168;
    }
    // 0x16b164: 0x4800b
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 0));
label_16b168:
    // 0x16b168: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16b16c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16b170: 0xc05acc0
    SET_GPR_U32(ctx, 31, 0x16b178);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    something(rdram, ctx, runtime); return;
}


// Function: entry_16b178
// Address: 0x16b178 - 0x16b190

void entry_16b178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b178: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16b17c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16b180: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16b184: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16b18c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16b190; return;
}


// Function: start_world_for_first_timeQMARK
// Address: 0x16b190 - 0x16b1f0

void entry_16b1f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b1f0: 0x8e0202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x16b1f4: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x16b1f8: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x16b1fc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16b200: 0x10800012
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B24C; return;
    }
    // 0x16b208: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x16b20c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16b210: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16b214: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x16b218: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16b21c: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x16b224);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_16b224
// Address: 0x16b224 - 0x16b244

void entry_16b224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b224: 0x8e0202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x16b228: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x16b22c: 0x2221021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x16b230: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16b234: 0x50800006
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 720)));
        ctx->pc = 0x16B250; return;
    }
    // 0x16b23c: 0xc04b26a
    SET_GPR_U32(ctx, 31, 0x16b244);
    FWipingAseg__FP4ASEG(rdram, ctx, runtime); return;
}


// Function: entry_16b244
// Address: 0x16b244 - 0x16b258

void entry_16b244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b244) {
        switch (ctx->pc) {
            case 0x16b24c: ctx->pc = 0; goto label_16b24c;
            case 0x16b250: ctx->pc = 0; goto label_16b250;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b244: 0x14400012
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B290; return;
    }
label_16b24c:
    // 0x16b24c: 0x8e0402d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 720)));
label_16b250:
    // 0x16b250: 0xc058060
    SET_GPR_U32(ctx, 31, 0x16b258);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 8));
    call_search_level_by_id(rdram, ctx, runtime); return;
}


// Function: entry_16b258
// Address: 0x16b258 - 0x16b284

void entry_16b258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b258) {
        switch (ctx->pc) {
            case 0x16b274: ctx->pc = 0; goto label_16b274;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b258: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16b25c: 0x10800005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_16b274;
    }
    // 0x16b264: 0x8c820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 4)));
    // 0x16b268: 0x8c83001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 28)));
    // 0x16b26c: 0x431026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16b270: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
label_16b274:
    // 0x16b274: 0x10400005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B28C; return;
    }
    // 0x16b27c: 0xc07c10a
    SET_GPR_U32(ctx, 31, 0x16b284);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    WipeToWorldWarp(rdram, ctx, runtime); return;
}


// Function: entry_16b284
// Address: 0x16b284 - 0x16b2a0

void entry_16b284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b284) {
        switch (ctx->pc) {
            case 0x16b28c: ctx->pc = 0; goto label_16b28c;
            case 0x16b290: ctx->pc = 0; goto label_16b290;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b284: 0x10000002
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16b290;
    }
label_16b28c:
    // 0x16b28c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_16b290:
    // 0x16b290: 0x1240000e
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_16b2cc(rdram, ctx, runtime); return;
    }
    // 0x16b298: 0xc07a55c
    SET_GPR_U32(ctx, 31, 0x16b2a0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PopUiActiveBlot__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_16b2a0
// Address: 0x16b2a0 - 0x16b2cc

void entry_16b2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b2a0) {
        switch (ctx->pc) {
            case 0x16b2a8: ctx->pc = 0; goto label_16b2a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b2a0: 0x1000000a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_16b2cc(rdram, ctx, runtime); return;
    }
label_16b2a8:
    // 0x16b2a8: 0x8e0402f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 760)));
    // 0x16b2ac: 0x10800007
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_16b2cc(rdram, ctx, runtime); return;
    }
    // 0x16b2b4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16b2b8: 0x518c0
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 3));
    // 0x16b2bc: 0x24422860
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 10336));
    // 0x16b2c0: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16b2c4: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x16b2cc);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_16b2cc
// Address: 0x16b2cc - 0x16b2e0

void entry_16b2cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b2cc: 0x12600004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        entry_16b2e0(rdram, ctx, runtime); return;
    }
    // 0x16b2d4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16b2d8: 0xc05acc0
    SET_GPR_U32(ctx, 31, 0x16b2e0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 720)));
    something(rdram, ctx, runtime); return;
}


// Function: entry_16b2e0
// Address: 0x16b2e0 - 0x16b300

void entry_16b2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b2e0: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16b2e4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16b2e8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16b2ec: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16b2f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16b2f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16b2fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16b300; return;
}


// Function: something
// Address: 0x16b300 - 0x16b3e4

void entry_16b3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b3e4: 0xc06fa60
    SET_GPR_U32(ctx, 31, 0x16b3ec);
    FVagPlaying__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16b3ec
// Address: 0x16b3ec - 0x16b42c

void entry_16b3ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b3ec) {
        switch (ctx->pc) {
            case 0x16b3f4: ctx->pc = 0; goto label_16b3f4;
            case 0x16b3f8: ctx->pc = 0; goto label_16b3f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b3ec: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x16b3f0: 0xac62fcf4
    WRITE32(ADD32(GPR_U32(ctx, 3), 4294966516), GPR_U32(ctx, 2));
label_16b3f4:
    // 0x16b3f4: 0x8e6502e0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 736)));
label_16b3f8:
    // 0x16b3f8: 0x10a0001a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_16b464(rdram, ctx, runtime); return;
    }
    // 0x16b400: 0x8e6302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 720)));
    // 0x16b404: 0x1462000f
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 18), 3));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x16B444; return;
    }
    // 0x16b40c: 0x12400015
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_16b464(rdram, ctx, runtime); return;
    }
    // 0x16b414: 0x1288c0
    SET_GPR_U32(ctx, 17, SLL32(GPR_U32(ctx, 18), 3));
    // 0x16b418: 0x26102860
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 10336));
    // 0x16b41c: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x16b420: 0x2111021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 17)));
    // 0x16b424: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x16b42c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_16b42c
// Address: 0x16b42c - 0x16b43c

void entry_16b42c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b42c: 0x2308821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 16)));
    // 0x16b430: 0x8e6402e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 736)));
    // 0x16b434: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x16b43c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_16b43c
// Address: 0x16b43c - 0x16b464

void entry_16b43c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b43c) {
        switch (ctx->pc) {
            case 0x16b444: ctx->pc = 0; goto label_16b444;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b43c: 0x1000000a
    WRITE32(ADD32(GPR_U32(ctx, 19), 720), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B468; return;
    }
label_16b444:
    // 0x16b444: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16b448: 0x141880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 20), 2));
    // 0x16b44c: 0x24422860
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 10336));
    // 0x16b450: 0x641821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x16b454: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x16b458: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x16b45c: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x16b464);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_16b464
// Address: 0x16b464 - 0x16b4a0

void entry_16b464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b464) {
        switch (ctx->pc) {
            case 0x16b468: ctx->pc = 0; goto label_16b468;
            case 0x16b47c: ctx->pc = 0; goto label_16b47c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b464: 0xae7202d0
    WRITE32(ADD32(GPR_U32(ctx, 19), 720), GPR_U32(ctx, 18));
label_16b468:
    // 0x16b468: 0x26a21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 6232));
    // 0x16b46c: 0xae7402d4
    WRITE32(ADD32(GPR_U32(ctx, 19), 724), GPR_U32(ctx, 20));
    // 0x16b470: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x16b474: 0xe66002d8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 728), *(uint32_t*)&val); }
    // 0x16b478: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_16b47c:
    // 0x16b47c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16b480: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16b484: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16b488: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16b48c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16b490: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16b494: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16b49c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16b4a0; return;
}


// Function: FUN_0016b4a0
// Address: 0x16b4a0 - 0x16b4b4

void FUN_0016b4a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b4a0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x16b4a4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x16b4a8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x16b4ac: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x16b4b4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_16b4b4
// Address: 0x16b4b4 - 0x16b4bc

void entry_16b4b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b4b4: 0xc057062
    SET_GPR_U32(ctx, 31, 0x16b4bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c188(rdram, ctx, runtime); return;
}


// Function: entry_16b4bc
// Address: 0x16b4bc - 0x16b4d4

void entry_16b4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b4bc: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B4DC; return;
    }
    // 0x16b4c4: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16b4c8: 0x24422988
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 10632));
    // 0x16b4cc: 0xc057070
    SET_GPR_U32(ctx, 31, 0x16b4d4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 528), GPR_U32(ctx, 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_16b4d4
// Address: 0x16b4d4 - 0x16b4e8

void entry_16b4d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b4d4) {
        switch (ctx->pc) {
            case 0x16b4dc: ctx->pc = 0; goto label_16b4dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b4d4: 0x8e030210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 528)));
    // 0x16b4d8: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_16b4dc:
    // 0x16b4dc: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x16b4e0: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x16b4e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_16b4e8
// Address: 0x16b4e8 - 0x16b520

void entry_16b4e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b4e8: 0x3c02df7f
    SET_GPR_U32(ctx, 2, ((uint32_t)57215 << 16));
    // 0x16b4ec: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x16b4f0: 0x34427f7f
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32639));
    // 0x16b4f4: 0xae000260
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 0));
    // 0x16b4f8: 0xae020208
    WRITE32(ADD32(GPR_U32(ctx, 16), 520), GPR_U32(ctx, 2));
    // 0x16b4fc: 0xae000264
    WRITE32(ADD32(GPR_U32(ctx, 16), 612), GPR_U32(ctx, 0));
    // 0x16b500: 0xc4602970
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 10608)); ctx->f[0] = *(float*)&val; }
    // 0x16b504: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16b508: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x16b50c: 0xe6000268
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 616), *(uint32_t*)&val); }
    // 0x16b510: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16b514: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16b51c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16b520; return;
}


// Function: FUN_0016b520
// Address: 0x16b520 - 0x16b544

void FUN_0016b520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b520: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x16b524: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x16b528: 0x8c82025c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 604)));
    // 0x16b52c: 0x10400009
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_16b554(rdram, ctx, runtime); return;
    }
    // 0x16b534: 0x240504fd
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1277));
    // 0x16b538: 0x8c445710
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 22288)));
    // 0x16b53c: 0xc056912
    SET_GPR_U32(ctx, 31, 0x16b544);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_16b544
// Address: 0x16b544 - 0x16b554

void entry_16b544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b544: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B558; return;
    }
    // 0x16b54c: 0xc07d3b4
    SET_GPR_U32(ctx, 31, 0x16b554);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    EnableCamera__FP6CAMERA(rdram, ctx, runtime); return;
}


// Function: entry_16b554
// Address: 0x16b554 - 0x16b560

void entry_16b554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b554) {
        switch (ctx->pc) {
            case 0x16b558: ctx->pc = 0; goto label_16b558;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b554: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_16b558:
    // 0x16b558: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0016b560
// Address: 0x16b560 - 0x16b570

void FUN_0016b560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b560: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x16b564: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x16b568: 0xc06a8a6
    SET_GPR_U32(ctx, 31, 0x16b570);
    UpdateBlot__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_16b570
// Address: 0x16b570 - 0x16b580

void entry_16b570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b570: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16b574: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16b57c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16b580; return;
}


// Function: FUN_0016b580
// Address: 0x16b580 - 0x16b5c4

void FUN_0016b580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b580: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x16b584: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x16b588: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x16b58c: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x16b590: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16b594: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x16b598: 0x8e020260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x16b59c: 0x1040007c
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_16b790(rdram, ctx, runtime); return;
    }
    // 0x16b5a4: 0x8c4202e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 736)));
    // 0x16b5a8: 0x1040007a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B794; return;
    }
    // 0x16b5b0: 0x8e020264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 612)));
    // 0x16b5b4: 0x1040000b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B5E4; return;
    }
    // 0x16b5bc: 0xc06fa04
    SET_GPR_U32(ctx, 31, 0x16b5c4);
    FPauseForVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16b5c4
// Address: 0x16b5c4 - 0x16b5d4

void entry_16b5c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b5c4: 0x10400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_16b5d4(rdram, ctx, runtime); return;
    }
    // 0x16b5cc: 0xc04738c
    SET_GPR_U32(ctx, 31, 0x16b5d4);
    snd_FlushSoundCommands(rdram, ctx, runtime); return;
}


// Function: entry_16b5d4
// Address: 0x16b5d4 - 0x16b5dc

void entry_16b5d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b5d4: 0xc06fa60
    SET_GPR_U32(ctx, 31, 0x16b5dc);
    FVagPlaying__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16b5dc
// Address: 0x16b5dc - 0x16b624

void entry_16b5dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b5dc) {
        switch (ctx->pc) {
            case 0x16b5e4: ctx->pc = 0; goto label_16b5e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b5dc: 0xae020264
    WRITE32(ADD32(GPR_U32(ctx, 16), 612), GPR_U32(ctx, 2));
    // 0x16b5e0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
label_16b5e4:
    // 0x16b5e4: 0x8c432420
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9248)));
    // 0x16b5e8: 0x1460006a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B794; return;
    }
    // 0x16b5f0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x16b5f4: 0x8c43051c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1308)));
    // 0x16b5f8: 0x54600067
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        ctx->pc = 0x16B798; return;
    }
    // 0x16b600: 0x8e100260
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x16b604: 0x8e030308
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 776)));
    // 0x16b608: 0x10600009
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 736)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B630; return;
    }
    // 0x16b610: 0x8e02033c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 828)));
    // 0x16b614: 0x14620003
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        entry_16b624(rdram, ctx, runtime); return;
    }
    // 0x16b61c: 0xc0631fe
    SET_GPR_U32(ctx, 31, 0x16b624);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c7f8__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_16b624
// Address: 0x16b624 - 0x16b62c

void entry_16b624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b624: 0xc05462e
    SET_GPR_U32(ctx, 31, 0x16b62c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 776)));
    TriggerDialog__FP6DIALOG(rdram, ctx, runtime); return;
}


// Function: entry_16b62c
// Address: 0x16b62c - 0x16b638

void entry_16b62c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b62c) {
        switch (ctx->pc) {
            case 0x16b630: ctx->pc = 0; goto label_16b630;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b62c: 0xae000308
    WRITE32(ADD32(GPR_U32(ctx, 16), 776), GPR_U32(ctx, 0));
label_16b630:
    // 0x16b630: 0xc05abe0
    SET_GPR_U32(ctx, 31, 0x16b638);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    hideout_set_focus(rdram, ctx, runtime); return;
}


// Function: entry_16b638
// Address: 0x16b638 - 0x16b6ac

void entry_16b638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b638) {
        switch (ctx->pc) {
            case 0x16b680: ctx->pc = 0; goto label_16b680;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b638: 0x8e0202d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 724)));
    // 0x16b63c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16b640: 0x5443002a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 48)));
        ctx->pc = 0x16B6EC; return;
    }
    // 0x16b648: 0x8e230028
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 40)));
    // 0x16b64c: 0x8e220030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 48)));
    // 0x16b650: 0x1062000b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_16b680;
    }
    // 0x16b658: 0xc60202d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 728)); ctx->f[2] = *(float*)&val; }
    // 0x16b65c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x16b660: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x16b664: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x16b668: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16b66c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x16b670: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16b674: 0x0
    // NOP
    // 0x16b678: 0x4502001c
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 48)));
        ctx->pc = 0x16B6EC; return;
    }
label_16b680:
    // 0x16b680: 0x8e0402d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 720)));
    // 0x16b684: 0x1480000b
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B6B4; return;
    }
    // 0x16b68c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x16b690: 0x2445fd00
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 4294966528));
    // 0x16b694: 0x8ca30250
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 592)));
    // 0x16b698: 0x1460003e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B794; return;
    }
    // 0x16b6a0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x16b6a4: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x16b6ac);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_16b6ac
// Address: 0x16b6ac - 0x16b6e4

void entry_16b6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b6ac) {
        switch (ctx->pc) {
            case 0x16b6b4: ctx->pc = 0; goto label_16b6b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b6ac: 0x10000039
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B794; return;
    }
label_16b6b4:
    // 0x16b6b4: 0x2446f808
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 4294965256));
    // 0x16b6b8: 0x8cc30250
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 592)));
    // 0x16b6bc: 0x14600035
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B794; return;
    }
    // 0x16b6c4: 0x41080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 4), 2));
    // 0x16b6c8: 0xc0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x16b6cc: 0xc21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x16b6d0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x16b6d4: 0x8c430264
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 612)));
    // 0x16b6d8: 0x24845bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    // 0x16b6dc: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x16b6e4);
    WRITE32(ADD32(GPR_U32(ctx, 6), 608), GPR_U32(ctx, 3));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_16b6e4
// Address: 0x16b6e4 - 0x16b748

void entry_16b6e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b6e4) {
        switch (ctx->pc) {
            case 0x16b6ec: ctx->pc = 0; goto label_16b6ec;
            case 0x16b740: ctx->pc = 0; goto label_16b740;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b6e4: 0x1000002b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B794; return;
    }
label_16b6ec:
    // 0x16b6ec: 0x8e220028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 40)));
    // 0x16b6f0: 0x14430028
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x16B794; return;
    }
    // 0x16b6f8: 0x964200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 18), 170)));
    // 0x16b6fc: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16b700: 0x30420800
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2048));
    // 0x16b704: 0x5440000e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
        goto label_16b740;
    }
    // 0x16b70c: 0x8e430014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x16b710: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16b714: 0x14620013
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 320));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x16B764; return;
    }
    // 0x16b71c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16b720: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x16b724: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16b728: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x16b72c: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16b730: 0x0
    // NOP
    // 0x16b734: 0x4500000b
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 4), 320));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x16B764; return;
    }
    // 0x16b73c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_16b740:
    // 0x16b740: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x16b748);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2048));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_16b748
// Address: 0x16b748 - 0x16b75c

void entry_16b748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b748: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x16b74c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16b750: 0x2484ff68
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294967144));
    // 0x16b754: 0xc06534c
    SET_GPR_U32(ctx, 31, 0x16b75c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 23));
    FUN_00194d30(rdram, ctx, runtime); return;
}


// Function: entry_16b75c
// Address: 0x16b75c - 0x16b774

void entry_16b75c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b75c) {
        switch (ctx->pc) {
            case 0x16b764: ctx->pc = 0; goto label_16b764;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b75c: 0x1000000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B794; return;
    }
label_16b764:
    // 0x16b764: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B784; return;
    }
    // 0x16b76c: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x16b774);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 320));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_16b774
// Address: 0x16b774 - 0x16b77c

void entry_16b774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b774: 0xc05ac64
    SET_GPR_U32(ctx, 31, 0x16b77c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    start_world_for_first_timeQMARK(rdram, ctx, runtime); return;
}


// Function: entry_16b77c
// Address: 0x16b77c - 0x16b790

void entry_16b77c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b77c) {
        switch (ctx->pc) {
            case 0x16b784: ctx->pc = 0; goto label_16b784;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b77c: 0x10000005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B794; return;
    }
label_16b784:
    // 0x16b784: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16b788: 0xc05ac3e
    SET_GPR_U32(ctx, 31, 0x16b790);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FTakeStepguardDamage(rdram, ctx, runtime); return;
}


// Function: entry_16b790
// Address: 0x16b790 - 0x16b7a8

void entry_16b790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b790) {
        switch (ctx->pc) {
            case 0x16b794: ctx->pc = 0; goto label_16b794;
            case 0x16b798: ctx->pc = 0; goto label_16b798;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b790: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_16b794:
    // 0x16b794: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_16b798:
    // 0x16b798: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16b79c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16b7a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0016b7a8
// Address: 0x16b7a8 - 0x16b7e8

void FUN_0016b7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b7a8: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x16b7ac: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x16b7b0: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x16b7b4: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x16b7b8: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x16b7bc: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16b7c0: 0x11182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 17)));
    // 0x16b7c4: 0x8e02025c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 604)));
    // 0x16b7c8: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x16b7cc: 0x14620020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x16B850; return;
    }
    // 0x16b7d4: 0x1220000b
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B804; return;
    }
    // 0x16b7dc: 0x8e040260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 608)));
    // 0x16b7e0: 0xc05acc0
    SET_GPR_U32(ctx, 31, 0x16b7e8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 720)));
    something(rdram, ctx, runtime); return;
}


// Function: entry_16b7e8
// Address: 0x16b7e8 - 0x16b7f0

void entry_16b7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b7e8: 0xc05b83c
    SET_GPR_U32(ctx, 31, 0x16b7f0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    AddGrfusr__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16b7f0
// Address: 0x16b7f0 - 0x16b7fc

void entry_16b7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b7f0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16b7f4: 0xc05bb22
    SET_GPR_U32(ctx, 31, 0x16b7fc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    StartJoySelection__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_16b7fc
// Address: 0x16b7fc - 0x16b818

void entry_16b7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b7fc) {
        switch (ctx->pc) {
            case 0x16b804: ctx->pc = 0; goto label_16b804;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b7fc: 0x10000013
    WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B84C; return;
    }
label_16b804:
    // 0x16b804: 0x8e020264
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 612)));
    // 0x16b808: 0x10400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B81C; return;
    }
    // 0x16b810: 0xc06fa66
    SET_GPR_U32(ctx, 31, 0x16b818);
    StopVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16b818
// Address: 0x16b818 - 0x16b824

void entry_16b818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b818) {
        switch (ctx->pc) {
            case 0x16b81c: ctx->pc = 0; goto label_16b81c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b818: 0xae000264
    WRITE32(ADD32(GPR_U32(ctx, 16), 612), GPR_U32(ctx, 0));
label_16b81c:
    // 0x16b81c: 0xc05b846
    SET_GPR_U32(ctx, 31, 0x16b824);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    RemoveGrfusr__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16b824
// Address: 0x16b824 - 0x16b834

void entry_16b824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b824: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x16b828: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x16b82c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16b834);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16b834
// Address: 0x16b834 - 0x16b848

void entry_16b834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b834: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x16b838: 0x8c83f138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294963512)));
    // 0x16b83c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x16b840: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16b848);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294963512));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16b848
// Address: 0x16b848 - 0x16b860

void entry_16b848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b848) {
        switch (ctx->pc) {
            case 0x16b84c: ctx->pc = 0; goto label_16b84c;
            case 0x16b850: ctx->pc = 0; goto label_16b850;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b848: 0xae11025c
    WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 17));
label_16b84c:
    // 0x16b84c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_16b850:
    // 0x16b850: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16b854: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16b858: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0016b860
// Address: 0x16b860 - 0x16b8e4

void FUN_0016b860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b860: 0x27bdfec0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966976));
    // 0x16b864: 0x7fb10100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 17));
    // 0x16b868: 0x7fbf0120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 31));
    // 0x16b86c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16b870: 0x7fb20110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 18));
    // 0x16b874: 0x7fb000f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 16));
    // 0x16b878: 0xe7b50138
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 312), *(uint32_t*)&val); }
    // 0x16b87c: 0xe7b40130
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 304), *(uint32_t*)&val); }
    // 0x16b880: 0x8e220260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 608)));
    // 0x16b884: 0x10400067
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16BA24; return;
    }
    // 0x16b88c: 0x82220008
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x16b890: 0x10400064
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16BA24; return;
    }
    // 0x16b898: 0x8a22020b
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 523); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x16b89c: 0x9a220208
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 520); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x16b8a0: 0xaba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16b8a4: 0xbba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16b8a8: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16b8ac: 0x93a20003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 3)));
    // 0x16b8b0: 0xc621023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 572)); ctx->f[1] = *(float*)&val; }
    // 0x16b8b4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x16b8b8: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x16b8bc: 0xc62c021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 540)); ctx->f[12] = *(float*)&val; }
    // 0x16b8c0: 0xc62d0220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 544)); ctx->f[13] = *(float*)&val; }
    // 0x16b8c4: 0xc6340234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 564)); ctx->f[20] = *(float*)&val; }
    // 0x16b8c8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x16b8cc: 0xc6350238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 568)); ctx->f[21] = *(float*)&val; }
    // 0x16b8d0: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x16b8d4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x16b8d8: 0xa3a20003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 2));
    // 0x16b8dc: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x16b8e4);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_16b8e4
// Address: 0x16b8e4 - 0x16b8f4

void entry_16b8e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b8e4: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16b8e8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x16b8ec: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x16b8f4);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_16b8f4
// Address: 0x16b8f4 - 0x16b904

void entry_16b8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b8f4: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16b8f8: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x16b8fc: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x16b904);
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_16b904
// Address: 0x16b904 - 0x16b910

void entry_16b904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b904: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16b908: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x16b910);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_16b910
// Address: 0x16b910 - 0x16b91c

void entry_16b910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b910: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16b914: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x16b91c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_16b91c
// Address: 0x16b91c - 0x16b980

void entry_16b91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b91c: 0x8e230210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x16b920: 0x1060001d
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16B998; return;
    }
    // 0x16b928: 0x8862001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 27); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x16b92c: 0x98620018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x16b930: 0xaba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16b934: 0xbba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16b938: 0x9062001b
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 27)));
    // 0x16b93c: 0xc621023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 572)); ctx->f[1] = *(float*)&val; }
    // 0x16b940: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x16b944: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x16b948: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x16b94c: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x16b950: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x16b954: 0xa062001b
    WRITE8(ADD32(GPR_U32(ctx, 3), 27), (uint8_t)GPR_U32(ctx, 2));
    // 0x16b958: 0x8e250210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x16b95c: 0x8ca80000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x16b960: 0x11000007
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 8832));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_16b980(rdram, ctx, runtime); return;
    }
    // 0x16b968: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x16b96c: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16b970: 0x84440048
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x16b974: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x16b978: 0x60f809
    SET_GPR_U32(ctx, 31, 0x16b980);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_16b980
// Address: 0x16b980 - 0x16b9ac

void entry_16b980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16b980) {
        switch (ctx->pc) {
            case 0x16b998: ctx->pc = 0; goto label_16b998;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16b980: 0x8e220210
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x16b984: 0x8ba30033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x16b988: 0x9ba30030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x16b98c: 0xa843001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 27); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16b990: 0xb8430018
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 24); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16b994: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_16b998:
    // 0x16b998: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x16b99c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16b9a0: 0xc44c1868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[12] = *(float*)&val; }
    // 0x16b9a4: 0xc081500
    SET_GPR_U32(ctx, 31, 0x16b9ac);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    sinf(rdram, ctx, runtime); return;
}


// Function: entry_16b9ac
// Address: 0x16b9ac - 0x16b9f0

void entry_16b9ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b9ac: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x16b9b0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x16b9b4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16b9b8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16b9bc: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x16b9c0: 0x3c013f66
    SET_GPR_U32(ctx, 1, ((uint32_t)16230 << 16));
    // 0x16b9c4: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x16b9c8: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x16b9cc: 0xc62c020c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 524)); ctx->f[12] = *(float*)&val; }
    // 0x16b9d0: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x16b9d4: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x16b9d8: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x16b9dc: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x16b9e0: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x16b9e4: 0x46016302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[1]);
    // 0x16b9e8: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x16b9f0);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_16b9f0
// Address: 0x16b9f0 - 0x16ba04

void entry_16b9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16b9f0: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x16b9f4: 0x8e260004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x16b9f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16b9fc: 0xc0576ca
    SET_GPR_U32(ctx, 31, 0x16ba04);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 8));
    fn___9CRichTextPcP5CFont(rdram, ctx, runtime); return;
}


// Function: entry_16ba04
// Address: 0x16ba04 - 0x16ba18

void entry_16ba04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ba04: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16ba08: 0x26472280
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 8832));
    // 0x16ba0c: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16ba10: 0xc0578c6
    SET_GPR_U32(ctx, 31, 0x16ba18);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    Draw__9CRichTextP8CTextBoxT1P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_16ba18
// Address: 0x16ba18 - 0x16ba20

void entry_16ba18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ba18: 0xc057240
    SET_GPR_U32(ctx, 31, 0x16ba20);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_16ba20
// Address: 0x16ba20 - 0x16ba40

void entry_16ba20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ba20) {
        switch (ctx->pc) {
            case 0x16ba24: ctx->pc = 0; goto label_16ba24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ba20: 0x7bbf0120
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 288)));
label_16ba24:
    // 0x16ba24: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x16ba28: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x16ba2c: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x16ba30: 0xc7b50138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[21] = *(float*)&val; }
    // 0x16ba34: 0xc7b40130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[20] = *(float*)&val; }
    // 0x16ba38: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0016ba40
// Address: 0x16ba40 - 0x16ba60

void FUN_0016ba40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ba40: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x16ba44: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x16ba48: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16ba4c: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x16ba50: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x16ba54: 0xe7b50038
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 56), *(uint32_t*)&val); }
    // 0x16ba58: 0xc06a89a
    SET_GPR_U32(ctx, 31, 0x16ba60);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 48), *(uint32_t*)&val); }
    PostBlotLoad__FP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_16ba60
// Address: 0x16ba60 - 0x16ba68

void entry_16ba60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ba60: 0xc057062
    SET_GPR_U32(ctx, 31, 0x16ba68);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0015c188(rdram, ctx, runtime); return;
}


// Function: entry_16ba68
// Address: 0x16ba68 - 0x16ba80

void entry_16ba68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ba68: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16BA88; return;
    }
    // 0x16ba70: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16ba74: 0x244229a8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 10664));
    // 0x16ba78: 0xc057070
    SET_GPR_U32(ctx, 31, 0x16ba80);
    WRITE32(ADD32(GPR_U32(ctx, 17), 528), GPR_U32(ctx, 2));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_16ba80
// Address: 0x16ba80 - 0x16babc

void entry_16ba80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ba80) {
        switch (ctx->pc) {
            case 0x16ba88: ctx->pc = 0; goto label_16ba88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ba80: 0x8e230210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 528)));
    // 0x16ba84: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
label_16ba88:
    // 0x16ba88: 0x8e250004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x16ba8c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16ba90: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x16ba94: 0x8ca3004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 76)));
    // 0x16ba98: 0x46006346
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    // 0x16ba9c: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x16baa0: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x16baa4: 0x84640008
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x16baa8: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x16baac: 0x3c0142b4
    SET_GPR_U32(ctx, 1, ((uint32_t)17076 << 16));
    // 0x16bab0: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x16bab4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16babc);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16babc
// Address: 0x16babc - 0x16bae8

void entry_16babc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16babc: 0x3c03df7f
    SET_GPR_U32(ctx, 3, ((uint32_t)57215 << 16));
    // 0x16bac0: 0xae220004
    WRITE32(ADD32(GPR_U32(ctx, 17), 4), GPR_U32(ctx, 2));
    // 0x16bac4: 0x34637f7f
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 32639));
    // 0x16bac8: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x16bacc: 0xae230208
    WRITE32(ADD32(GPR_U32(ctx, 17), 520), GPR_U32(ctx, 3));
    // 0x16bad0: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x16bad4: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x16bad8: 0xc4410048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[1] = *(float*)&val; }
    // 0x16badc: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x16bae0: 0xc057070
    SET_GPR_U32(ctx, 31, 0x16bae8);
    ctx->f[20] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_16bae8
// Address: 0x16bae8 - 0x16bb04

void entry_16bae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bae8: 0x3c013fa6
    SET_GPR_U32(ctx, 1, ((uint32_t)16294 << 16));
    // 0x16baec: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x16baf0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x16baf4: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16baf8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16bafc: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x16bb04);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_16bb04
// Address: 0x16bb04 - 0x16bb1c

void entry_16bb04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bb04: 0x8e02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 76)));
    // 0x16bb08: 0x2405005f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 95));
    // 0x16bb0c: 0x84440018
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x16bb10: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x16bb14: 0x60f809
    SET_GPR_U32(ctx, 31, 0x16bb1c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_16bb1c
// Address: 0x16bb1c - 0x16bb4c

void entry_16bb1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bb1c: 0xc6010008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[1] = *(float*)&val; }
    // 0x16bb20: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x16bb24: 0xc6030048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[3] = *(float*)&val; }
    // 0x16bb28: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x16bb2c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x16bb30: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16bb34: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x16bb38: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x16bb3c: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x16bb40: 0x46150540
    ctx->f[21] = FPU_ADD_S(ctx->f[0], ctx->f[21]);
    // 0x16bb44: 0xc057240
    SET_GPR_U32(ctx, 31, 0x16bb4c);
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[1]);
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_16bb4c
// Address: 0x16bb4c - 0x16bb5c

void entry_16bb4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bb4c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16bb50: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x16bb54: 0xc06aac8
    SET_GPR_U32(ctx, 31, 0x16bb5c);
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    ResizeBlot__FP4BLOTff(rdram, ctx, runtime); return;
}


// Function: entry_16bb5c
// Address: 0x16bb5c - 0x16bb78

void entry_16bb5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bb5c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16bb60: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16bb64: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16bb68: 0xc7b50038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 56)); ctx->f[21] = *(float*)&val; }
    // 0x16bb6c: 0xc7b40030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[20] = *(float*)&val; }
    // 0x16bb70: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CFont__PushScaling
// Address: 0x16bb78 - 0x16bba8

void FUN_0016bba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16bba8) {
        switch (ctx->pc) {
            case 0x16bc00: ctx->pc = 0; goto label_16bc00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16bba8: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x16bbac: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x16bbb0: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x16bbb4: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x16bbb8: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x16bbbc: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x16bbc0: 0x960200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
    // 0x16bbc4: 0x304209b0
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2480));
    // 0x16bbc8: 0x1440000d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_16bc00;
    }
    // 0x16bbd0: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x16bbd4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16bbd8: 0x54620011
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
        ctx->pc = 0x16BC20; return;
    }
    // 0x16bbe0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16bbe4: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x16bbe8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16bbec: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x16bbf0: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16bbf4: 0x0
    // NOP
    // 0x16bbf8: 0x45020009
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
        ctx->pc = 0x16BC20; return;
    }
label_16bc00:
    // 0x16bc00: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16bc04: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x16bc0c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2480));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_16bc0c
// Address: 0x16bc0c - 0x16bc18

void entry_16bc0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bc0c: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x16bc10: 0xc07a55c
    SET_GPR_U32(ctx, 31, 0x16bc18);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PopUiActiveBlot__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_16bc18
// Address: 0x16bc18 - 0x16bc34

void entry_16bc18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16bc18) {
        switch (ctx->pc) {
            case 0x16bc20: ctx->pc = 0; goto label_16bc20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16bc18: 0x10000067
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16BDB8; return;
    }
label_16bc20:
    // 0x16bc20: 0x30420040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64));
    // 0x16bc24: 0x1040001c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16BC98; return;
    }
    // 0x16bc2c: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x16bc34);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_16bc34
// Address: 0x16bc34 - 0x16bc3c

void entry_16bc34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bc34: 0xc05aede
    SET_GPR_U32(ctx, 31, 0x16bc3c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    CFont__PushScaling(rdram, ctx, runtime); return;
}


// Function: entry_16bc3c
// Address: 0x16bc3c - 0x16bc4c

void entry_16bc3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bc3c: 0x10400005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 123));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16BC54; return;
    }
    // 0x16bc44: 0xc063930
    SET_GPR_U32(ctx, 31, 0x16bc4c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    FUN_0018e4c0(rdram, ctx, runtime); return;
}


// Function: entry_16bc4c
// Address: 0x16bc4c - 0x16bc90

void entry_16bc4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16bc4c) {
        switch (ctx->pc) {
            case 0x16bc54: ctx->pc = 0; goto label_16bc54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16bc4c: 0x1000005a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16BDB8; return;
    }
label_16bc54:
    // 0x16bc54: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x16bc58: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x16bc5c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x16bc60: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x16bc64: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16bc68: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x16bc6c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x16bc70: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16bc74: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16bc78: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x16bc7c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16bc80: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x16bc84: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16bc88: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x16bc90);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_16bc90
// Address: 0x16bc90 - 0x16bca0

void entry_16bc90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16bc90) {
        switch (ctx->pc) {
            case 0x16bc98: ctx->pc = 0; goto label_16bc98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16bc90: 0x10000049
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16BDB8; return;
    }
label_16bc98:
    // 0x16bc98: 0xc05bb26
    SET_GPR_U32(ctx, 31, 0x16bca0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DxSelectionJoy__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_16bca0
// Address: 0x16bca0 - 0x16bcac

void entry_16bca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bca0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16bca4: 0xc05bbb4
    SET_GPR_U32(ctx, 31, 0x16bcac);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    DySelectionJoy__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_16bcac
// Address: 0x16bcac - 0x16bdb4

void entry_16bcac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16bcac) {
        switch (ctx->pc) {
            case 0x16bcbc: ctx->pc = 0; goto label_16bcbc;
            case 0x16bd28: ctx->pc = 0; goto label_16bd28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16bcac: 0x16200003
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        goto label_16bcbc;
    }
    // 0x16bcb4: 0x11000040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16BDB8; return;
    }
label_16bcbc:
    // 0x16bcbc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16bcc0: 0xc6000034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[0] = *(float*)&val; }
    // 0x16bcc4: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x16bcc8: 0xc602003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 60)); ctx->f[2] = *(float*)&val; }
    // 0x16bccc: 0xc4410010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[1] = *(float*)&val; }
    // 0x16bcd0: 0x240affff
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16bcd4: 0x140282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 10) + GPR_U64(ctx, 0));
    // 0x16bcd8: 0x151302a
    SET_GPR_U32(ctx, 6, SLT32(GPR_S32(ctx, 10), GPR_S32(ctx, 17)));
    // 0x16bcdc: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x16bce0: 0xe6010030
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
    // 0x16bce4: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x16bce8: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x16bcec: 0xe6000038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
    // 0x16bcf0: 0x8e440260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 608)));
    // 0x16bcf4: 0x24820003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 3));
    // 0x16bcf8: 0x144182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 10), GPR_S32(ctx, 4)));
    // 0x16bcfc: 0x83100b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 4));
    // 0x16bd00: 0x23883
    SET_GPR_S32(ctx, 7, SRA32(GPR_S32(ctx, 2), 2));
    // 0x16bd04: 0xe0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x16bd08: 0x91080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 9), 2));
    // 0x16bd0c: 0x823823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x16bd10: 0x107280b
    if (GPR_U32(ctx, 7) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 8));
    // 0x16bd14: 0x1a200004
    if (GPR_U32(ctx, 6) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 5));
    if (GPR_S32(ctx, 17) <= 0) {
        goto label_16bd28;
    }
    // 0x16bd1c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16bd20: 0x38e20003
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 7), 3));
    // 0x16bd24: 0x62400a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 8, GPR_U32(ctx, 3));
label_16bd28:
    // 0x16bd28: 0x25040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 8), 4));
    // 0x16bd2c: 0x26250004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 4));
    // 0x16bd30: 0x1242021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 9), GPR_U32(ctx, 4)));
    // 0x16bd34: 0xe52821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 7), GPR_U32(ctx, 5)));
    // 0x16bd38: 0x144102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 10), GPR_S32(ctx, 4)));
    // 0x16bd3c: 0x24830003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 3));
    // 0x16bd40: 0x82180b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 3, GPR_U32(ctx, 4));
    // 0x16bd44: 0x145302a
    SET_GPR_U32(ctx, 6, SLT32(GPR_S32(ctx, 10), GPR_S32(ctx, 5)));
    // 0x16bd48: 0x24a20003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 3));
    // 0x16bd4c: 0x34883
    SET_GPR_S32(ctx, 9, SRA32(GPR_S32(ctx, 3), 2));
    // 0x16bd50: 0xa6100b
    if (GPR_U32(ctx, 6) != 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 5));
    // 0x16bd54: 0x91880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 9), 2));
    // 0x16bd58: 0x23883
    SET_GPR_S32(ctx, 7, SRA32(GPR_S32(ctx, 2), 2));
    // 0x16bd5c: 0x834823
    SET_GPR_U32(ctx, 9, SUB32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x16bd60: 0x71080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 7), 2));
    // 0x16bd64: 0x91880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 9), 2));
    // 0x16bd68: 0xa23823
    SET_GPR_U32(ctx, 7, SUB32(GPR_U32(ctx, 5), GPR_U32(ctx, 2)));
    // 0x16bd6c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x16bd70: 0x671821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 7)));
    // 0x16bd74: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x16bd78: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x16bd7c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x16bd80: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x16bd84: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x16bd88: 0x24040079
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 121));
    // 0x16bd8c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16bd90: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x16bd94: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16bd98: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16bd9c: 0xae430260
    WRITE32(ADD32(GPR_U32(ctx, 18), 608), GPR_U32(ctx, 3));
    // 0x16bda0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16bda4: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x16bda8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16bdac: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x16bdb4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_16bdb4
// Address: 0x16bdb4 - 0x16bdd0

void entry_16bdb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16bdb4) {
        switch (ctx->pc) {
            case 0x16bdb8: ctx->pc = 0; goto label_16bdb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16bdb4: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_16bdb8:
    // 0x16bdb8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16bdbc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16bdc0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16bdc4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16bdcc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16bdd0; return;
}


// Function: FUN_0016bdd0
// Address: 0x16bdd0 - 0x16be10

void FUN_0016bdd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bdd0: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x16bdd4: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x16bdd8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x16bddc: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x16bde0: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x16bde4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16bde8: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x16bdec: 0x12182b
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 18)));
    // 0x16bdf0: 0x8e02025c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 604)));
    // 0x16bdf4: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x16bdf8: 0x14620023
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x16BE88; return;
    }
    // 0x16be00: 0x12400019
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16BE68; return;
    }
    // 0x16be08: 0xc05b83c
    SET_GPR_U32(ctx, 31, 0x16be10);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 15));
    AddGrfusr__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16be10
// Address: 0x16be10 - 0x16be1c

void entry_16be10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16be10: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16be14: 0xc05bb22
    SET_GPR_U32(ctx, 31, 0x16be1c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    StartJoySelection__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_16be1c
// Address: 0x16be1c - 0x16be2c

void entry_16be1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16be1c: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x16be20: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x16be24: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16be2c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16be2c
// Address: 0x16be2c - 0x16be34

void entry_16be2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16be2c: 0xc05aede
    SET_GPR_U32(ctx, 31, 0x16be34);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 15));
    CFont__PushScaling(rdram, ctx, runtime); return;
}


// Function: entry_16be34
// Address: 0x16be34 - 0x16be70

void entry_16be34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16be34) {
        switch (ctx->pc) {
            case 0x16be48: ctx->pc = 0; goto label_16be48;
            case 0x16be50: ctx->pc = 0; goto label_16be50;
            case 0x16be60: ctx->pc = 0; goto label_16be60;
            case 0x16be68: ctx->pc = 0; goto label_16be68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16be34: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x16be38: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16be3c: 0x10000004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 9152)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16be50;
    }
    // 0x16be44: 0x0
    // NOP
label_16be48:
    // 0x16be48: 0x1a200005
    SET_GPR_S32(ctx, 4, SRA32(GPR_S32(ctx, 4), 1));
    if (GPR_S32(ctx, 17) <= 0) {
        goto label_16be60;
    }
label_16be50:
    // 0x16be50: 0x8c6219f4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6644)));
    // 0x16be54: 0x441024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x16be58: 0x5040fffb
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
        goto label_16be48;
    }
label_16be60:
    // 0x16be60: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 608), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_16be80(rdram, ctx, runtime); return;
    }
label_16be68:
    // 0x16be68: 0xc05b846
    SET_GPR_U32(ctx, 31, 0x16be70);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    RemoveGrfusr__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16be70
// Address: 0x16be70 - 0x16be80

void entry_16be70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16be70: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x16be74: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x16be78: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16be80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16be80
// Address: 0x16be80 - 0x16bea0

void entry_16be80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16be80) {
        switch (ctx->pc) {
            case 0x16be88: ctx->pc = 0; goto label_16be88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16be80: 0xae12025c
    WRITE32(ADD32(GPR_U32(ctx, 16), 604), GPR_U32(ctx, 18));
    // 0x16be84: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_16be88:
    // 0x16be88: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16be8c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16be90: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16be94: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16be9c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16bea0; return;
}


// Function: FUN_0016bea0
// Address: 0x16bea0 - 0x16bf44

void FUN_0016bea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bea0: 0x27bdfec0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966976));
    // 0x16bea4: 0x7fb40090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 20));
    // 0x16bea8: 0x7fb00050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 16));
    // 0x16beac: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16beb0: 0x7fbf00e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 31));
    // 0x16beb4: 0x7fbe00d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 30));
    // 0x16beb8: 0x7fb700c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 23));
    // 0x16bebc: 0x7fb600b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 22));
    // 0x16bec0: 0x7fb500a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 21));
    // 0x16bec4: 0x7fb30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 19));
    // 0x16bec8: 0x7fb20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 18));
    // 0x16becc: 0x7fb10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 17));
    // 0x16bed0: 0xe7bd0138
    { float val = ctx->f[29]; WRITE32(ADD32(GPR_U32(ctx, 29), 312), *(uint32_t*)&val); }
    // 0x16bed4: 0xe7bc0130
    { float val = ctx->f[28]; WRITE32(ADD32(GPR_U32(ctx, 29), 304), *(uint32_t*)&val); }
    // 0x16bed8: 0xe7bb0128
    { float val = ctx->f[27]; WRITE32(ADD32(GPR_U32(ctx, 29), 296), *(uint32_t*)&val); }
    // 0x16bedc: 0xe7ba0120
    { float val = ctx->f[26]; WRITE32(ADD32(GPR_U32(ctx, 29), 288), *(uint32_t*)&val); }
    // 0x16bee0: 0xe7b90118
    { float val = ctx->f[25]; WRITE32(ADD32(GPR_U32(ctx, 29), 280), *(uint32_t*)&val); }
    // 0x16bee4: 0xe7b80110
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 272), *(uint32_t*)&val); }
    // 0x16bee8: 0xe7b70108
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 264), *(uint32_t*)&val); }
    // 0x16beec: 0xe7b60100
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 256), *(uint32_t*)&val); }
    // 0x16bef0: 0xe7b500f8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 248), *(uint32_t*)&val); }
    // 0x16bef4: 0xe7b400f0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 240), *(uint32_t*)&val); }
    // 0x16bef8: 0x8a82020b
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 523); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x16befc: 0x9a820208
    { uint32_t addr = ADD32(GPR_U32(ctx, 20), 520); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x16bf00: 0xaba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16bf04: 0xbba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16bf08: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16bf0c: 0x93a20003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 3)));
    // 0x16bf10: 0xc681023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 572)); ctx->f[1] = *(float*)&val; }
    // 0x16bf14: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x16bf18: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x16bf1c: 0xc68c021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 540)); ctx->f[12] = *(float*)&val; }
    // 0x16bf20: 0xc68d0220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 544)); ctx->f[13] = *(float*)&val; }
    // 0x16bf24: 0xc6940234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 564)); ctx->f[20] = *(float*)&val; }
    // 0x16bf28: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x16bf2c: 0xc6950238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 568)); ctx->f[21] = *(float*)&val; }
    // 0x16bf30: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x16bf34: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x16bf38: 0xa3a20003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 2));
    // 0x16bf3c: 0xc04dc8a
    SET_GPR_U32(ctx, 31, 0x16bf44);
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    SetPos__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_16bf44
// Address: 0x16bf44 - 0x16bf54

void entry_16bf44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bf44: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16bf48: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x16bf4c: 0xc04dc8e
    SET_GPR_U32(ctx, 31, 0x16bf54);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    SetSize__8CTextBoxff(rdram, ctx, runtime); return;
}


// Function: entry_16bf54
// Address: 0x16bf54 - 0x16bf64

void entry_16bf54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bf54: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x16bf58: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16bf5c: 0xc04dc92
    SET_GPR_U32(ctx, 31, 0x16bf64);
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 16));
    SetTextColor__8CTextBoxP4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_16bf64
// Address: 0x16bf64 - 0x16bf70

void entry_16bf64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bf64: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16bf68: 0xc04dc98
    SET_GPR_U32(ctx, 31, 0x16bf70);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetHorizontalJust__8CTextBox2JH(rdram, ctx, runtime); return;
}


// Function: entry_16bf70
// Address: 0x16bf70 - 0x16bf7c

void entry_16bf70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bf70: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16bf74: 0xc04dc9a
    SET_GPR_U32(ctx, 31, 0x16bf7c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetVerticalJust__8CTextBox2JV(rdram, ctx, runtime); return;
}


// Function: entry_16bf7c
// Address: 0x16bf7c - 0x16bfe4

void entry_16bf7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16bf7c: 0x8e830210
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 528)));
    // 0x16bf80: 0x1060001e
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16BFFC; return;
    }
    // 0x16bf88: 0x8862001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 27); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x16bf8c: 0x98620018
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 24); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x16bf90: 0xaba20033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16bf94: 0xbba20030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16bf98: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16bf9c: 0x24472280
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 8832));
    // 0x16bfa0: 0xc681023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 572)); ctx->f[1] = *(float*)&val; }
    // 0x16bfa4: 0x9062001b
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 27)));
    // 0x16bfa8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x16bfac: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x16bfb0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x16bfb4: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x16bfb8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x16bfbc: 0xa062001b
    WRITE8(ADD32(GPR_U32(ctx, 3), 27), (uint8_t)GPR_U32(ctx, 2));
    // 0x16bfc0: 0x8e850210
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 528)));
    // 0x16bfc4: 0x8ca80000
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x16bfc8: 0x11000006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 8) == GPR_U32(ctx, 0)) {
        entry_16bfe4(rdram, ctx, runtime); return;
    }
    // 0x16bfd0: 0x8d02004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 8), 76)));
    // 0x16bfd4: 0x84440048
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x16bfd8: 0x8c43004c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 76)));
    // 0x16bfdc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x16bfe4);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 8), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_16bfe4
// Address: 0x16bfe4 - 0x16c008

void entry_16bfe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16bfe4) {
        switch (ctx->pc) {
            case 0x16bffc: ctx->pc = 0; goto label_16bffc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16bfe4: 0x8e820210
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 528)));
    // 0x16bfe8: 0x8ba30033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x16bfec: 0x9ba30030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x16bff0: 0xa843001b
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 27); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16bff4: 0xb8430018
    { uint32_t addr = ADD32(GPR_U32(ctx, 2), 24); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16bff8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
label_16bffc:
    // 0x16bffc: 0x8e840260
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 608)));
    // 0x16c000: 0xc05aede
    SET_GPR_U32(ctx, 31, 0x16c008);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 4294944728));
    CFont__PushScaling(rdram, ctx, runtime); return;
}


// Function: entry_16c008
// Address: 0x16c008 - 0x16c018

void entry_16c008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c008: 0x10400005
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16C020; return;
    }
    // 0x16c010: 0xc063920
    SET_GPR_U32(ctx, 31, 0x16c018);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 608)));
    FUN_0018e480(rdram, ctx, runtime); return;
}


// Function: entry_16c018
// Address: 0x16c018 - 0x16c044

void entry_16c018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16c018) {
        switch (ctx->pc) {
            case 0x16c020: ctx->pc = 0; goto label_16c020;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16c018: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16c01c: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
label_16c020:
    // 0x16c020: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16c024: 0x8e840004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x16c028: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16c02c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16c030: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16c034: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x16c038: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x16c03c: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x16c044);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 8832));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_16c044
// Address: 0x16c044 - 0x16c05c

void entry_16c044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c044: 0x3c014190
    SET_GPR_U32(ctx, 1, ((uint32_t)16784 << 16));
    // 0x16c048: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x16c04c: 0x3c014140
    SET_GPR_U32(ctx, 1, ((uint32_t)16704 << 16));
    // 0x16c050: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x16c054: 0xc057070
    SET_GPR_U32(ctx, 31, 0x16c05c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    FUN_0015c1c0(rdram, ctx, runtime); return;
}


// Function: entry_16c05c
// Address: 0x16c05c - 0x16c098

void entry_16c05c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c05c: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x16c060: 0x4481e800
    *(uint32_t*)&ctx->f[29] = GPR_U32(ctx, 1);
    // 0x16c064: 0x3c013fa6
    SET_GPR_U32(ctx, 1, ((uint32_t)16294 << 16));
    // 0x16c068: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x16c06c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x16c070: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16c074: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16c078: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x16c07c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x16c080: 0x4481e000
    *(uint32_t*)&ctx->f[28] = GPR_U32(ctx, 1);
    // 0x16c084: 0x3c013fa6
    SET_GPR_U32(ctx, 1, ((uint32_t)16294 << 16));
    // 0x16c088: 0x34216666
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 26214));
    // 0x16c08c: 0x4481d800
    *(uint32_t*)&ctx->f[27] = GPR_U32(ctx, 1);
    // 0x16c090: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x16c098);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_16c098
// Address: 0x16c098 - 0x16c0b8

void entry_16c098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c098: 0x200f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16c09c: 0x8e22004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x16c0a0: 0x2405005f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 95));
    // 0x16c0a4: 0x4600a646
    ctx->f[25] = FPU_MOV_S(ctx->f[20]);
    // 0x16c0a8: 0x84440018
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x16c0ac: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x16c0b0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x16c0b8);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_16c0b8
// Address: 0x16c0b8 - 0x16c118

void entry_16c0b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c0b8: 0x8e820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x16c0bc: 0xc6240008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[4] = *(float*)&val; }
    // 0x16c0c0: 0x46802120
    ctx->f[4] = FPU_CVT_S_W(*(int32_t*)&ctx->f[4]);
    // 0x16c0c4: 0xc6250048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[5] = *(float*)&val; }
    // 0x16c0c8: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x16c0cc: 0xc4430008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[3] = *(float*)&val; }
    // 0x16c0d0: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x16c0d4: 0xc4460048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[6] = *(float*)&val; }
    // 0x16c0d8: 0xc6810220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 544)); ctx->f[1] = *(float*)&val; }
    // 0x16c0dc: 0x46052102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[5]);
    // 0x16c0e0: 0xc682021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 540)); ctx->f[2] = *(float*)&val; }
    // 0x16c0e4: 0x2405005f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 95));
    // 0x16c0e8: 0x460618c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[6]);
    // 0x16c0ec: 0x8e22004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 76)));
    // 0x16c0f0: 0x46142102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[20]);
    // 0x16c0f4: 0x46151080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[21]);
    // 0x16c0f8: 0x84440018
    SET_GPR_S32(ctx, 4, (int16_t)READ16(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x16c0fc: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x16c100: 0x8c43001c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 28)));
    // 0x16c104: 0x2242021
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 4)));
    // 0x16c108: 0x46001600
    ctx->f[24] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x16c10c: 0x46160840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[22]);
    // 0x16c110: 0x60f809
    SET_GPR_U32(ctx, 31, 0x16c118);
    ctx->f[26] = FPU_ADD_S(ctx->f[1], ctx->f[4]);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_16c118
// Address: 0x16c118 - 0x16c18c

void entry_16c118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16c118) {
        switch (ctx->pc) {
            case 0x16c150: ctx->pc = 0; goto label_16c150;
            case 0x16c170: ctx->pc = 0; goto label_16c170;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16c118: 0x461505c0
    ctx->f[23] = FPU_ADD_S(ctx->f[0], ctx->f[21]);
    // 0x16c11c: 0xc6210048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[1] = *(float*)&val; }
    // 0x16c120: 0xc6200008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[0] = *(float*)&val; }
    // 0x16c124: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x16c128: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16c12c: 0xafa00018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 0));
    // 0x16c130: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16c134: 0xafa0001c
    WRITE32(ADD32(GPR_U32(ctx, 29), 28), GPR_U32(ctx, 0));
    // 0x16c138: 0x24571858
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x16c13c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x16c140: 0xae030018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 3));
    // 0x16c144: 0xae030014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 3));
    // 0x16c148: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16c14c: 0x46160580
    ctx->f[22] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
label_16c150:
    // 0x16c150: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x16c154: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x16c158: 0x3a880
    SET_GPR_U32(ctx, 21, SLL32(GPR_U32(ctx, 3), 2));
    // 0x16c15c: 0x24760001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 3), 1));
    // 0x16c160: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16c164: 0x26b30061
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 21), 97));
    // 0x16c168: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x16c16c: 0x4600d540
    ctx->f[21] = FPU_ADD_S(ctx->f[26], ctx->f[0]);
label_16c170:
    // 0x16c170: 0x44920000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 18);
    // 0x16c174: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x16c178: 0x2b28021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 18)));
    // 0x16c17c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16c180: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x16c184: 0xc05aede
    SET_GPR_U32(ctx, 31, 0x16c18c);
    ctx->f[20] = FPU_ADD_S(ctx->f[24], ctx->f[0]);
    CFont__PushScaling(rdram, ctx, runtime); return;
}


// Function: entry_16c18c
// Address: 0x16c18c - 0x16c1d4

void entry_16c18c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16c18c) {
        switch (ctx->pc) {
            case 0x16c198: ctx->pc = 0; goto label_16c198;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16c18c: 0x10400002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 95));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16c198;
    }
    // 0x16c194: 0x260182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_16c198:
    // 0x16c198: 0xa3a30040
    WRITE8(ADD32(GPR_U32(ctx, 29), 64), (uint8_t)GPR_U32(ctx, 3));
    // 0x16c19c: 0xa3a00041
    WRITE8(ADD32(GPR_U32(ctx, 29), 65), (uint8_t)GPR_U32(ctx, 0));
    // 0x16c1a0: 0x8e820260
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 608)));
    // 0x16c1a4: 0x83a30040
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16c1a8: 0x83a40041
    SET_GPR_S32(ctx, 4, (int8_t)READ8(ADD32(GPR_U32(ctx, 29), 65)));
    // 0x16c1ac: 0xa3a30030
    WRITE8(ADD32(GPR_U32(ctx, 29), 48), (uint8_t)GPR_U32(ctx, 3));
    // 0x16c1b0: 0xa3a40031
    WRITE8(ADD32(GPR_U32(ctx, 29), 49), (uint8_t)GPR_U32(ctx, 4));
    // 0x16c1b4: 0xe7b40010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 16), *(uint32_t*)&val); }
    // 0x16c1b8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16c1bc: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x16c1c0: 0x16020009
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 20), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x16C1E8; return;
    }
    // 0x16c1c8: 0xc6ec0010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 16)); ctx->f[12] = *(float*)&val; }
    // 0x16c1cc: 0xc081500
    SET_GPR_U32(ctx, 31, 0x16c1d4);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[29]);
    sinf(rdram, ctx, runtime); return;
}


// Function: entry_16c1d4
// Address: 0x16c1d4 - 0x16c208

void entry_16c1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16c1d4) {
        switch (ctx->pc) {
            case 0x16c1e8: ctx->pc = 0; goto label_16c1e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16c1d4: 0x46190002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[25]);
    // 0x16c1d8: 0x46190000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[25]);
    // 0x16c1dc: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x16c1e0: 0x461c0002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[28]);
    // 0x16c1e4: 0x46140500
    ctx->f[20] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
label_16c1e8:
    // 0x16c1e8: 0x461ba002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[27]);
    // 0x16c1ec: 0xc68c023c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 572)); ctx->f[12] = *(float*)&val; }
    // 0x16c1f0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16c1f4: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x16c1f8: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x16c1fc: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x16c200: 0xc05722e
    SET_GPR_U32(ctx, 31, 0x16c208);
    ctx->f[13] = FPU_MOV_S(ctx->f[12]);
    PushScaling__5CFontff(rdram, ctx, runtime); return;
}


// Function: entry_16c208
// Address: 0x16c208 - 0x16c224

void entry_16c208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c208: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16c20c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16c210: 0x24482280
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 8832));
    // 0x16c214: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x16c218: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x16c21c: 0xc05718e
    SET_GPR_U32(ctx, 31, 0x16c224);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    DrawPchz__5CFontPcP8CTextBoxT2P4GIFS(rdram, ctx, runtime); return;
}


// Function: entry_16c224
// Address: 0x16c224 - 0x16c22c

void entry_16c224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c224: 0xc057240
    SET_GPR_U32(ctx, 31, 0x16c22c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_16c22c
// Address: 0x16c22c - 0x16c24c

void entry_16c22c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c22c: 0x2a420004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 4));
    // 0x16c230: 0x1440ffcf
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16C170; return;
    }
    // 0x16c238: 0x28620004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    // 0x16c23c: 0x1440ffc4
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16C150; return;
    }
    // 0x16c244: 0xc057240
    SET_GPR_U32(ctx, 31, 0x16c24c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PopScaling__5CFont(rdram, ctx, runtime); return;
}


// Function: entry_16c24c
// Address: 0x16c24c - 0x16c308

void entry_16c24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c24c: 0x8e820004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 4)));
    // 0x16c250: 0x27aa0030
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 48));
    // 0x16c254: 0xc6810220
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 544)); ctx->f[1] = *(float*)&val; }
    // 0x16c258: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16c25c: 0xc4430008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[3] = *(float*)&val; }
    // 0x16c260: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x16c264: 0xc4420048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 72)); ctx->f[2] = *(float*)&val; }
    // 0x16c268: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x16c26c: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x16c270: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16c274: 0xc6800234
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 564)); ctx->f[0] = *(float*)&val; }
    // 0x16c278: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16c27c: 0x460218c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[2]);
    // 0x16c280: 0x3c013ee8
    SET_GPR_U32(ctx, 1, ((uint32_t)16104 << 16));
    // 0x16c284: 0x3421ba2f
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 47663));
    // 0x16c288: 0x44813800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 1);
    // 0x16c28c: 0xc682021c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 540)); ctx->f[2] = *(float*)&val; }
    // 0x16c290: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16c294: 0x3c0144d8
    SET_GPR_U32(ctx, 1, ((uint32_t)17624 << 16));
    // 0x16c298: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x16c29c: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x16c2a0: 0x3c0144f2
    SET_GPR_U32(ctx, 1, ((uint32_t)17650 << 16));
    // 0x16c2a4: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x16c2a8: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x16c2ac: 0x3c014180
    SET_GPR_U32(ctx, 1, ((uint32_t)16768 << 16));
    // 0x16c2b0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x16c2b4: 0x46041080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[4]);
    // 0x16c2b8: 0x244729c0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 2), 10688));
    // 0x16c2bc: 0x88e30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x16c2c0: 0x98e30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 7), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x16c2c4: 0xaba30033
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 51); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16c2c8: 0xbba30030
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 48); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x16c2cc: 0x46060840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[6]);
    // 0x16c2d0: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x16c2d4: 0x46031082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[3]);
    // 0x16c2d8: 0x46070842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[7]);
    // 0x16c2dc: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x16c2e0: 0x46001124
    *(int32_t*)&ctx->f[4] = FPU_CVT_W_S(ctx->f[2]);
    // 0x16c2e4: 0x44042000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[4]);
    // 0x16c2e8: 0x46050840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[5]);
    // 0x16c2ec: 0x460000a4
    *(int32_t*)&ctx->f[2] = FPU_CVT_W_S(ctx->f[0]);
    // 0x16c2f0: 0x44071000
    SET_GPR_U32(ctx, 7, *(uint32_t*)&ctx->f[2]);
    // 0x16c2f4: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x16c2f8: 0x46000824
    *(int32_t*)&ctx->f[0] = FPU_CVT_W_S(ctx->f[1]);
    // 0x16c2fc: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x16c300: 0xc06b8ee
    SET_GPR_U32(ctx, 31, 0x16c308);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    DrawLineScreen__FUiUiUiUiUiUiG4RGBAi(rdram, ctx, runtime); return;
}


// Function: entry_16c308
// Address: 0x16c308 - 0x16c360

void entry_16c308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c308: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x16c30c: 0x7bbe00d0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x16c310: 0x7bb700c0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x16c314: 0x7bb600b0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x16c318: 0x7bb500a0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x16c31c: 0x7bb40090
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x16c320: 0x7bb30080
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x16c324: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x16c328: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16c32c: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16c330: 0xc7bd0138
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 312)); ctx->f[29] = *(float*)&val; }
    // 0x16c334: 0xc7bc0130
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 304)); ctx->f[28] = *(float*)&val; }
    // 0x16c338: 0xc7bb0128
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 296)); ctx->f[27] = *(float*)&val; }
    // 0x16c33c: 0xc7ba0120
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 288)); ctx->f[26] = *(float*)&val; }
    // 0x16c340: 0xc7b90118
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 280)); ctx->f[25] = *(float*)&val; }
    // 0x16c344: 0xc7b80110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 272)); ctx->f[24] = *(float*)&val; }
    // 0x16c348: 0xc7b70108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 264)); ctx->f[23] = *(float*)&val; }
    // 0x16c34c: 0xc7b60100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[22] = *(float*)&val; }
    // 0x16c350: 0xc7b500f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 248)); ctx->f[21] = *(float*)&val; }
    // 0x16c354: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x16c358: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 320));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0016c360
// Address: 0x16c360 - 0x16c3b4

void FUN_0016c360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c360: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x16c364: 0x3402ffff
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 65535));
    // 0x16c368: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x16c36c: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x16c370: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x16c374: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x16c378: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x16c37c: 0xe7b60060
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    // 0x16c380: 0xe7b50058
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 88), *(uint32_t*)&val); }
    // 0x16c384: 0x14a20024
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x16C418; return;
    }
    // 0x16c38c: 0x10800022
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16C418; return;
    }
    // 0x16c394: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16c398: 0x26312988
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 10632));
    // 0x16c39c: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    // 0x16c3a0: 0x3c013e99
    SET_GPR_U32(ctx, 1, ((uint32_t)16025 << 16));
    // 0x16c3a4: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x16c3a8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x16c3ac: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x16c3b4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_16c3b4
// Address: 0x16c3b4 - 0x16c400

void entry_16c3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c3b4: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x16c3b8: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x16c3bc: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16c3c0: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x16c3c4: 0x3c12ff7d
    SET_GPR_U32(ctx, 18, ((uint32_t)65405 << 16));
    // 0x16c3c8: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x16c3cc: 0x2413002d
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 45));
    // 0x16c3d0: 0x261029a8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 10664));
    // 0x16c3d4: 0x36524b00
    SET_GPR_U32(ctx, 18, OR32(GPR_U32(ctx, 18), 19200));
    // 0x16c3d8: 0xae320018
    WRITE32(ADD32(GPR_U32(ctx, 17), 24), GPR_U32(ctx, 18));
    // 0x16c3dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16c3e0: 0xa2330004
    WRITE8(ADD32(GPR_U32(ctx, 17), 4), (uint8_t)GPR_U32(ctx, 19));
    // 0x16c3e4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16c3e8: 0xe6350008
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 17), 8), *(uint32_t*)&val); }
    // 0x16c3ec: 0x2406001c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    // 0x16c3f0: 0xe636000c
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 17), 12), *(uint32_t*)&val); }
    // 0x16c3f4: 0xe6340010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 16), *(uint32_t*)&val); }
    // 0x16c3f8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x16c400);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 20), *(uint32_t*)&val); }
    memset(rdram, ctx, runtime); return;
}


// Function: entry_16c400
// Address: 0x16c400 - 0x16c464

void entry_16c400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16c400) {
        switch (ctx->pc) {
            case 0x16c418: ctx->pc = 0; goto label_16c418;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16c400: 0xae120018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 18));
    // 0x16c404: 0xa2130004
    WRITE8(ADD32(GPR_U32(ctx, 16), 4), (uint8_t)GPR_U32(ctx, 19));
    // 0x16c408: 0xe6150008
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x16c40c: 0xe616000c
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x16c410: 0xe6140014
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 20), *(uint32_t*)&val); }
    // 0x16c414: 0xe6140010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 16), *(uint32_t*)&val); }
label_16c418:
    // 0x16c418: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16c41c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16c420: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16c424: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16c428: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16c42c: 0xc7b60060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[22] = *(float*)&val; }
    // 0x16c430: 0xc7b50058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[21] = *(float*)&val; }
    // 0x16c434: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x16c438: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16c440: 0xe48c0000
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x16c444: 0x0
    // NOP
    // 0x16c448: 0xe48c0008
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 4), 8), *(uint32_t*)&val); }
    // 0x16c44c: 0x0
    // NOP
    // 0x16c450: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x16c454: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16c458: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x16c45c: 0xc05b0d8
    SET_GPR_U32(ctx, 31, 0x16c464);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 65535));
    FUN_0016c360(rdram, ctx, runtime); return;
}


// Function: entry_16c464
// Address: 0x16c464 - 0x16c470

void entry_16c464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c464: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16c468: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitHnd__FP3HND
// Address: 0x16c470 - 0x16c484

void entry_16c484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c484: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x16c488: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16c48c: 0xc440a7dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944732)); ctx->f[0] = *(float*)&val; }
    // 0x16c490: 0x24040008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 8));
    // 0x16c494: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    // 0x16c498: 0xae030088
    WRITE32(ADD32(GPR_U32(ctx, 16), 136), GPR_U32(ctx, 3));
    // 0x16c49c: 0xe60000b4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 180), *(uint32_t*)&val); }
    // 0x16c4a0: 0xae0400a8
    WRITE32(ADD32(GPR_U32(ctx, 16), 168), GPR_U32(ctx, 4));
    // 0x16c4a4: 0xae0200ac
    WRITE32(ADD32(GPR_U32(ctx, 16), 172), GPR_U32(ctx, 2));
    // 0x16c4a8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16c4ac: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16c4b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadHndFromBrx__FP3HNDP18CBinaryInputStream
// Address: 0x16c4b8 - 0x16c4c8

void entry_16c4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c4c8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16c4cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16c4d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16c4d8; return;
}


// Function: junk_0016c4d8
// Address: 0x16c4d8 - 0x16c4e8

void entry_16c4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c4f8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16c4fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16c504: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16c508; return;
}


// Function: RenderLikhSelf__FP4LIKHP2CMP2RO
// Address: 0x16c508 - 0x16c518

void entry_16c518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c518: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16c51c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16c524: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16c528; return;
}


// Function: SolveAloIK__FP3ALO
// Address: 0x16c528 - 0x16c648

void entry_16c648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c648: 0x8e650018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 24)));
    // 0x16c64c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16c650: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16c654: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x16c65c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_16c65c
// Address: 0x16c65c - 0x16c670

void entry_16c65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c65c: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x16c660: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16c664: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x16c668: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16c670);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16c670
// Address: 0x16c670 - 0x16c7a0

void entry_16c670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16c670) {
        switch (ctx->pc) {
            case 0x16c768: ctx->pc = 0; goto label_16c768;
            case 0x16c788: ctx->pc = 0; goto label_16c788;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16c670: 0x8e230224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 548)));
    // 0x16c674: 0x24620030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 48));
    // 0x16c678: 0xd8630030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 48)));
    // 0x16c67c: 0xd8460020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x16c680: 0xd8450010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x16c684: 0xd8640000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16c688: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x16c68c: 0x4bc428bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x16c690: 0x4bc4310a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c694: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16c698: 0xfba40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16c69c: 0xd8610010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x16c6a0: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x16c6a4: 0x4bc128bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16c6a8: 0x4bc1304a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c6ac: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16c6b0: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16c6b4: 0xd8620020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x16c6b8: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x16c6bc: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16c6c0: 0x4bc230ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c6c4: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16c6c8: 0xfba30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16c6cc: 0xfa2400d0
    WRITE128(ADD32(GPR_U32(ctx, 17), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16c6d0: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16c6d4: 0x7e2200e0
    WRITE128(ADD32(GPR_U32(ctx, 17), 224), GPR_VEC(ctx, 2));
    // 0x16c6d8: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16c6dc: 0x7e2300f0
    WRITE128(ADD32(GPR_U32(ctx, 17), 240), GPR_VEC(ctx, 3));
    // 0x16c6e0: 0x8e430224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x16c6e4: 0x10600020
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_16c768;
    }
    // 0x16c6ec: 0x8c6200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 176)));
    // 0x16c6f0: 0x30420003
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 3));
    // 0x16c6f4: 0x1040001c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 48));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16c768;
    }
    // 0x16c6fc: 0xd8630030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 48)));
    // 0x16c700: 0xd8460020
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x16c704: 0xd8450010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x16c708: 0xd8640000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16c70c: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x16c710: 0x4bc428bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x16c714: 0x4bc4310a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c718: 0xfba40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16c71c: 0xfba40030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16c720: 0xd8610010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x16c724: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x16c728: 0x4bc128bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16c72c: 0x4bc1304a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c730: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16c734: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16c738: 0xd8620020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x16c73c: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x16c740: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16c744: 0x4bc230ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c748: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16c74c: 0xfba30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16c750: 0xfa4400d0
    WRITE128(ADD32(GPR_U32(ctx, 18), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16c754: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16c758: 0x7e4200e0
    WRITE128(ADD32(GPR_U32(ctx, 18), 224), GPR_VEC(ctx, 2));
    // 0x16c75c: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16c760: 0x10000009
    WRITE128(ADD32(GPR_U32(ctx, 18), 240), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16c788;
    }
label_16c768:
    // 0x16c768: 0x264500d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 208));
    // 0x16c76c: 0x248483d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294935504));
    // 0x16c770: 0x78820000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x16c774: 0x7e4200d0
    WRITE128(ADD32(GPR_U32(ctx, 18), 208), GPR_VEC(ctx, 2));
    // 0x16c778: 0x78830010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x16c77c: 0x7ca30010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 3));
    // 0x16c780: 0x78820020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 32)));
    // 0x16c784: 0x7ca20020
    WRITE128(ADD32(GPR_U32(ctx, 5), 32), GPR_VEC(ctx, 2));
label_16c788:
    // 0x16c788: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x16c78c: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x16c790: 0x10400004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 4294937904));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16C7A4; return;
    }
    // 0x16c798: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16c7a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16c7a0
// Address: 0x16c7a0 - 0x16c7d0

void entry_16c7a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16c7a0) {
        switch (ctx->pc) {
            case 0x16c7a4: ctx->pc = 0; goto label_16c7a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16c7a0: 0x26c38d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 4294937904));
label_16c7a4:
    // 0x16c7a4: 0x7a020060
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 96)));
    // 0x16c7a8: 0x78640000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16c7ac: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16c7b0: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x16c7b4: 0x27a80010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16c7b8: 0x7fa40010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 4));
    // 0x16c7bc: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x16c7c0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16c7c4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16c7c8: 0xc049f98
    SET_GPR_U32(ctx, 31, 0x16c7d0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2(rdram, ctx, runtime); return;
}


// Function: entry_16c7d0
// Address: 0x16c7d0 - 0x16c7f0

void entry_16c7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c7d0: 0x27aa0170
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 368));
    // 0x16c7d4: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x16c7d8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16c7dc: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16c7e0: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x16c7e4: 0x27a80090
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 144));
    // 0x16c7e8: 0xc049ec8
    SET_GPR_U32(ctx, 31, 0x16c7f0);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 304));
    CalculateAloTransform__FP3ALOT0iP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_16c7f0
// Address: 0x16c7f0 - 0x16c8bc

void entry_16c7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c7f0: 0xda070070
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 112)));
    // 0x16c7f4: 0x27a601d0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 464));
    // 0x16c7f8: 0xdba40090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x16c7fc: 0xc0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x16c800: 0xdba200a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x16c804: 0x27a401a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 416));
    // 0x16c808: 0xdba100b0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x16c80c: 0x27a501b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 432));
    // 0x16c810: 0x4bc721bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x16c814: 0x4bc710bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x16c818: 0x4bc709ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c81c: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16c820: 0x4be33a28
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x16c824: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16c828: 0x4be341ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x16c82c: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16c830: 0x4be218ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16c834: 0x4be2212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x16c838: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16c83c: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16c840: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16c844: 0x4b01284a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c848: 0x4bc630aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x16c84c: 0x4b000243
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16c850: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16c854: 0x4b02488a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c858: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16c85c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16c860: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16c864: 0x4bc4216a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x16c868: 0x4b000283
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16c86c: 0x4b05283d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x16c870: 0x4b05514a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c874: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16c878: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16c87c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16c880: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16c884: 0x4482b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 2);
    // 0x16c888: 0x4a0503bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x16c88c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16c890: 0x4b000160
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16c894: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16c898: 0x48222800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x16c89c: 0x4483b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 3);
    // 0x16c8a0: 0xfba70020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x16c8a4: 0x4482c000
    *(uint32_t*)&ctx->f[24] = GPR_U32(ctx, 2);
    // 0x16c8a8: 0xfba80020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x16c8ac: 0xfba301a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16c8b0: 0xfba601b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 432), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x16c8b4: 0xc07b642
    SET_GPR_U32(ctx, 31, 0x16c8bc);
    WRITE128(ADD32(GPR_U32(ctx, 29), 448), _mm_castps_si128(ctx->vu0_vf[4]));
    RadBetweenVectors__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_16c8bc
// Address: 0x16c8bc - 0x16c91c

void entry_16c8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16c8bc) {
        switch (ctx->pc) {
            case 0x16c8fc: ctx->pc = 0; goto label_16c8fc;
            case 0x16c914: ctx->pc = 0; goto label_16c914;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16c8bc: 0x4618c042
    ctx->f[1] = FPU_MUL_S(ctx->f[24], ctx->f[24]);
    // 0x16c8c0: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x16c8c4: 0x4616b082
    ctx->f[2] = FPU_MUL_S(ctx->f[22], ctx->f[22]);
    // 0x16c8c8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16c8cc: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x16c8d0: 0x4617b8c2
    ctx->f[3] = FPU_MUL_S(ctx->f[23], ctx->f[23]);
    // 0x16c8d4: 0x4616b000
    ctx->f[0] = FPU_ADD_S(ctx->f[22], ctx->f[22]);
    // 0x16c8d8: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x16c8dc: 0x46170002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[23]);
    // 0x16c8e0: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x16c8e4: 0x46000d03
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[20] = ctx->f[1] / ctx->f[0];
    // 0x16c8e8: 0x46142034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16c8ec: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16c8fc;
    }
    // 0x16c8f4: 0x10000007
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16c914;
    }
label_16c8fc:
    // 0x16c8fc: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x16c900: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16c904: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16c908: 0x0
    // NOP
    // 0x16c90c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[20] = FPU_MOV_S(ctx->f[0]);
        goto label_16c914;
    }
label_16c914:
    // 0x16c914: 0xc08155e
    SET_GPR_U32(ctx, 31, 0x16c91c);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    acosf(rdram, ctx, runtime); return;
}


// Function: entry_16c91c
// Address: 0x16c91c - 0x16c92c

void entry_16c91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c91c: 0x46150301
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[21]);
    // 0x16c920: 0x27a501e0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 480));
    // 0x16c924: 0xc062214
    SET_GPR_U32(ctx, 31, 0x16c92c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_16c92c
// Address: 0x16c92c - 0x16c96c

void entry_16c92c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c92c: 0xdba301b0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x16c930: 0x27a40220
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 544));
    // 0x16c934: 0xdba501e0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x16c938: 0x27a501c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 448));
    // 0x16c93c: 0xdba401f0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x16c940: 0x27a60230
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 560));
    // 0x16c944: 0xdba20200
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x16c948: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x16c94c: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16c950: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c954: 0xdba101a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x16c958: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16c95c: 0xfba30210
    WRITE128(ADD32(GPR_U32(ctx, 29), 528), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16c960: 0xfba10220
    WRITE128(ADD32(GPR_U32(ctx, 29), 544), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16c964: 0xc062858
    SET_GPR_U32(ctx, 31, 0x16c96c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 432), _mm_castps_si128(ctx->vu0_vf[3]));
    LoadRotateVectorMatrix__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_16c96c
// Address: 0x16c96c - 0x16c9b4

void entry_16c96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c96c: 0xdba101c0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x16c970: 0x27a40290
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 656));
    // 0x16c974: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16c978: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16c97c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16c980: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c984: 0x8e620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 548)));
    // 0x16c988: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16c98c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16c990: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16c994: 0x27a50260
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 608));
    // 0x16c998: 0xfba10290
    WRITE128(ADD32(GPR_U32(ctx, 29), 656), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16c99c: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x16c9a0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16c9a4: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x16c9a8: 0xfba20290
    WRITE128(ADD32(GPR_U32(ctx, 29), 656), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16c9ac: 0xc062214
    SET_GPR_U32(ctx, 31, 0x16c9b4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 144)); ctx->f[12] = *(float*)&val; }
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_16c9b4
// Address: 0x16c9b4 - 0x16ca94

void entry_16c9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16c9b4: 0xdba30270
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 624)));
    // 0x16c9b8: 0x27b00330
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 816));
    // 0x16c9bc: 0xdba10280
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 640)));
    // 0x16c9c0: 0x27a500c0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 192));
    // 0x16c9c4: 0xdba50260
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 608)));
    // 0x16c9c8: 0x27a60300
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 768));
    // 0x16c9cc: 0xdba90230
    ctx->vu0_vf[9] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x16c9d0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16c9d4: 0xdba80240
    ctx->vu0_vf[8] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x16c9d8: 0x4bc929bc
    ctx->vu0_i = (float)ctx->vi[9];
    // 0x16c9dc: 0x4bc918bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); }
    // 0x16c9e0: 0x4bc90a4a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[9], ctx->vu0_vf[9], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c9e4: 0x4bc829bc
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x16c9e8: 0x4bc818bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x16c9ec: 0x4bc80a0a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16c9f0: 0xdba20250
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 592)));
    // 0x16c9f4: 0x4bc229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x16c9f8: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16c9fc: 0x4bc2094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16ca00: 0xdba401e0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 480)));
    // 0x16ca04: 0xdba201f0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 496)));
    // 0x16ca08: 0xdba10200
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 512)));
    // 0x16ca0c: 0xdba60090
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x16ca10: 0xdba700a0
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x16ca14: 0x4bc621bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x16ca18: 0x4bc610bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x16ca1c: 0x4bc6098a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16ca20: 0x4bc721bc
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x16ca24: 0x4bc710bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x16ca28: 0x4bc709ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16ca2c: 0xdba300b0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x16ca30: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x16ca34: 0x4bc310bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16ca38: 0x4bc3090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16ca3c: 0xfba50320
    WRITE128(ADD32(GPR_U32(ctx, 29), 800), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x16ca40: 0xfba90300
    WRITE128(ADD32(GPR_U32(ctx, 29), 768), _mm_castps_si128(ctx->vu0_vf[9]));
    // 0x16ca44: 0xfba80310
    WRITE128(ADD32(GPR_U32(ctx, 29), 784), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x16ca48: 0xfba50250
    WRITE128(ADD32(GPR_U32(ctx, 29), 592), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x16ca4c: 0xfba60300
    WRITE128(ADD32(GPR_U32(ctx, 29), 768), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x16ca50: 0xfba40320
    WRITE128(ADD32(GPR_U32(ctx, 29), 800), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16ca54: 0xfba502f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 752), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x16ca58: 0xfba502c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 704), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x16ca5c: 0xfba60360
    WRITE128(ADD32(GPR_U32(ctx, 29), 864), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x16ca60: 0xfba60330
    WRITE128(ADD32(GPR_U32(ctx, 29), 816), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x16ca64: 0xfba40380
    WRITE128(ADD32(GPR_U32(ctx, 29), 896), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16ca68: 0xfba40350
    WRITE128(ADD32(GPR_U32(ctx, 29), 848), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16ca6c: 0xfba90230
    WRITE128(ADD32(GPR_U32(ctx, 29), 560), _mm_castps_si128(ctx->vu0_vf[9]));
    // 0x16ca70: 0xfba80240
    WRITE128(ADD32(GPR_U32(ctx, 29), 576), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x16ca74: 0xfba70310
    WRITE128(ADD32(GPR_U32(ctx, 29), 784), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x16ca78: 0xfba902d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 720), _mm_castps_si128(ctx->vu0_vf[9]));
    // 0x16ca7c: 0xfba802e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 736), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x16ca80: 0xfba902a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 672), _mm_castps_si128(ctx->vu0_vf[9]));
    // 0x16ca84: 0xfba802b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 688), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x16ca88: 0xfba70370
    WRITE128(ADD32(GPR_U32(ctx, 29), 880), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x16ca8c: 0xc062148
    SET_GPR_U32(ctx, 31, 0x16ca94);
    WRITE128(ADD32(GPR_U32(ctx, 29), 832), _mm_castps_si128(ctx->vu0_vf[7]));
    MatMulMatTransMat__FRC7MATRIX3T0(rdram, ctx, runtime); return;
}


// Function: entry_16ca94
// Address: 0x16ca94 - 0x16cb1c

void entry_16ca94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ca94: 0x7ba30330
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 816)));
    // 0x16ca98: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16ca9c: 0x27a500f0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 240));
    // 0x16caa0: 0x27a602d0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 720));
    // 0x16caa4: 0x7e4300d0
    WRITE128(ADD32(GPR_U32(ctx, 18), 208), GPR_VEC(ctx, 3));
    // 0x16caa8: 0x7ba20340
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 832)));
    // 0x16caac: 0x7e4200e0
    WRITE128(ADD32(GPR_U32(ctx, 18), 224), GPR_VEC(ctx, 2));
    // 0x16cab0: 0x7ba30350
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 848)));
    // 0x16cab4: 0x7e4300f0
    WRITE128(ADD32(GPR_U32(ctx, 18), 240), GPR_VEC(ctx, 3));
    // 0x16cab8: 0xdba10230
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x16cabc: 0xdba40240
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x16cac0: 0xdba20250
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 592)));
    // 0x16cac4: 0xdba300c0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x16cac8: 0xdba500d0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x16cacc: 0x4bc309bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x16cad0: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16cad4: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cad8: 0x4bc509bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x16cadc: 0x4bc520bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x16cae0: 0x4bc5114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cae4: 0xdba600e0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x16cae8: 0x4bc609bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x16caec: 0x4bc620bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x16caf0: 0x4bc6104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16caf4: 0xfba302d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 720), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16caf8: 0xfba502e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 736), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x16cafc: 0xfba102f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 752), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16cb00: 0xfba30360
    WRITE128(ADD32(GPR_U32(ctx, 29), 864), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16cb04: 0xfba30330
    WRITE128(ADD32(GPR_U32(ctx, 29), 816), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16cb08: 0xfba50370
    WRITE128(ADD32(GPR_U32(ctx, 29), 880), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x16cb0c: 0xfba50340
    WRITE128(ADD32(GPR_U32(ctx, 29), 832), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x16cb10: 0xfba10380
    WRITE128(ADD32(GPR_U32(ctx, 29), 896), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16cb14: 0xc062148
    SET_GPR_U32(ctx, 31, 0x16cb1c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 848), _mm_castps_si128(ctx->vu0_vf[1]));
    MatMulMatTransMat__FRC7MATRIX3T0(rdram, ctx, runtime); return;
}


// Function: entry_16cb1c
// Address: 0x16cb1c - 0x16cb4c

void entry_16cb1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16cb1c: 0x7ba30330
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 816)));
    // 0x16cb20: 0x8e240000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x16cb24: 0x7e2300d0
    WRITE128(ADD32(GPR_U32(ctx, 17), 208), GPR_VEC(ctx, 3));
    // 0x16cb28: 0x7ba20340
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 832)));
    // 0x16cb2c: 0x7e2200e0
    WRITE128(ADD32(GPR_U32(ctx, 17), 224), GPR_VEC(ctx, 2));
    // 0x16cb30: 0x7ba30350
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 848)));
    // 0x16cb34: 0x7e2300f0
    WRITE128(ADD32(GPR_U32(ctx, 17), 240), GPR_VEC(ctx, 3));
    // 0x16cb38: 0x8c820058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 88)));
    // 0x16cb3c: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 1));
        ctx->pc = 0x16CB50; return;
    }
    // 0x16cb44: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16cb4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16cb4c
// Address: 0x16cb4c - 0x16cb84

void entry_16cb4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16cb4c) {
        switch (ctx->pc) {
            case 0x16cb50: ctx->pc = 0; goto label_16cb50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16cb4c: 0x32a20001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 21), 1));
label_16cb50:
    // 0x16cb50: 0x10400092
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16CD9C; return;
    }
    // 0x16cb58: 0x4600a305
    ctx->f[12] = FPU_ABS_S(ctx->f[20]);
    // 0x16cb5c: 0xdba20140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x16cb60: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16cb64: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x16cb68: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16cb6c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x16cb70: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x16cb74: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x16cb78: 0xfba10330
    WRITE128(ADD32(GPR_U32(ctx, 29), 816), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16cb7c: 0xc07ab1a
    SET_GPR_U32(ctx, 31, 0x16cb84);
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    FFloatsNear__Ffff(rdram, ctx, runtime); return;
}


// Function: entry_16cb84
// Address: 0x16cb84 - 0x16ce00

void entry_16cb84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16cb84) {
        switch (ctx->pc) {
            case 0x16cb98: ctx->pc = 0; goto label_16cb98;
            case 0x16cbdc: ctx->pc = 0; goto label_16cbdc;
            case 0x16ccc4: ctx->pc = 0; goto label_16ccc4;
            case 0x16ccd4: ctx->pc = 0; goto label_16ccd4;
            case 0x16cd9c: ctx->pc = 0; goto label_16cd9c;
            case 0x16cdb0: ctx->pc = 0; goto label_16cdb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16cb84: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->f[3] = FPU_MUL_S(ctx->f[23], ctx->f[22]);
        goto label_16cb98;
    }
    // 0x16cb8c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x16cb90: 0x10000012
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16cbdc;
    }
label_16cb98:
    // 0x16cb98: 0xdba20330
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 816)));
    // 0x16cb9c: 0x4614a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[20]);
    // 0x16cba0: 0xdba10290
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 656)));
    // 0x16cba4: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16cba8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16cbac: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16cbb0: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cbb4: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16cbb8: 0x4603c0c3
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[3] = copysignf(INFINITY, ctx->f[24] * 0.0f); } else ctx->f[3] = ctx->f[24] / ctx->f[3];
    // 0x16cbbc: 0x44832000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 3);
    // 0x16cbc0: 0x4601a841
    ctx->f[1] = FPU_SUB_S(ctx->f[21], ctx->f[1]);
    // 0x16cbc4: 0x46010084
    ctx->f[2] = FPU_SQRT_S(ctx->f[0]);
    // 0x16cbc8: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x16cbcc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16cbd0: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x16cbd4: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x16cbd8: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
label_16cbdc:
    // 0x16cbdc: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x16cbe0: 0x48a24000
    ctx->vu0_vf[8] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x16cbe4: 0xdba601d0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 464)));
    // 0x16cbe8: 0xdba50230
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 560)));
    // 0x16cbec: 0x4be83198
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[8]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x16cbf0: 0xdba30240
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 576)));
    // 0x16cbf4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x16cbf8: 0xdba10250
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 592)));
    // 0x16cbfc: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x16cc00: 0xdba401b0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 432)));
    // 0x16cc04: 0x4bc629bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x16cc08: 0x4bc618bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x16cc0c: 0x4bc609ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cc10: 0x4bc429bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x16cc14: 0x4bc418bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x16cc18: 0x4bc4090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cc1c: 0xdba20330
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 816)));
    // 0x16cc20: 0x4bc43afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[4] = READ32(addr); }
    // 0x16cc24: 0x4bc7216e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[7]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cc28: 0x4a25296c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x16cc2c: 0xdba301c0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 448)));
    // 0x16cc30: 0x4be510ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16cc34: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x16cc38: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x16cc3c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16cc40: 0x4bc2106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16cc44: 0x4b000243
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16cc48: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16cc4c: 0x4b01484a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cc50: 0x4bc21afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x16cc54: 0x4bc312ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cc58: 0x4a2b5aec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[11]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[11] = _mm_blendv_ps(ctx->vu0_vf[11], res, _mm_castsi128_ps(mask)); }
    // 0x16cc5c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16cc60: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16cc64: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16cc68: 0x4bcb58ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[11]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[11] = _mm_blendv_ps(ctx->vu0_vf[11], res, _mm_castsi128_ps(mask)); }
    // 0x16cc6c: 0x4b000283
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16cc70: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16cc74: 0x4b0350ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cc78: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16cc7c: 0x4a0303bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16cc80: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16cc84: 0x4b0000e0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16cc88: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x16cc8c: 0xfba80350
    WRITE128(ADD32(GPR_U32(ctx, 29), 848), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x16cc90: 0x48231800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16cc94: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x16cc98: 0xfba60340
    WRITE128(ADD32(GPR_U32(ctx, 29), 832), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x16cc9c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16cca0: 0xfba40350
    WRITE128(ADD32(GPR_U32(ctx, 29), 848), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16cca4: 0xfba703c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 960), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x16cca8: 0xfba50360
    WRITE128(ADD32(GPR_U32(ctx, 29), 864), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x16ccac: 0xfba20370
    WRITE128(ADD32(GPR_U32(ctx, 29), 880), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16ccb0: 0x45000004
    WRITE128(ADD32(GPR_U32(ctx, 29), 896), _mm_castps_si128(ctx->vu0_vf[11]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16ccc4;
    }
    // 0x16ccb8: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16ccbc: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 896), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16ccd4;
    }
label_16ccc4:
    // 0x16ccc4: 0x4a6303bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x16ccc8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16cccc: 0x4be0585c
    ctx->vu0_vf[11] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x16ccd0: 0xfba10380
    WRITE128(ADD32(GPR_U32(ctx, 29), 896), _mm_castps_si128(ctx->vu0_vf[1]));
label_16ccd4:
    // 0x16ccd4: 0x46181003
    if (ctx->f[24] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[0] = ctx->f[2] / ctx->f[24];
    // 0x16ccd8: 0xdba50380
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 896)));
    // 0x16ccdc: 0xdba70290
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 656)));
    // 0x16cce0: 0xdba60190
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x16cce4: 0xdba40340
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 832)));
    // 0x16cce8: 0xdba300c0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x16ccec: 0xdba200d0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x16ccf0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x16ccf4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x16ccf8: 0x8e620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 548)));
    // 0x16ccfc: 0x4be12958
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x16cd00: 0xfba50390
    WRITE128(ADD32(GPR_U32(ctx, 29), 912), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x16cd04: 0x8c420094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 148)));
    // 0x16cd08: 0x48a24800
    ctx->vu0_vf[9] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x16cd0c: 0xfba103e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 992), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16cd10: 0x4be939d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[9]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x16cd14: 0xdba100e0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x16cd18: 0x4be53968
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); }
    // 0x16cd1c: 0x4be41b2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16cd20: 0x4be00353
    // Unhandled VU0 Special1 function: 0x13
    // 0x16cd24: 0x4be412ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16cd28: 0x4be40aaa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16cd2c: 0x4b0c603d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[12] = _mm_blendv_ps(ctx->vu0_vf[12], res, _mm_castsi128_ps(mask)); }
    // 0x16cd30: 0x4b0c6a0a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[12], ctx->vu0_vf[12], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[13] = _mm_blendv_ps(ctx->vu0_vf[13], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cd34: 0x4a8b583c
    ctx->vu0_i = (float)ctx->vi[11];
    // 0x16cd38: 0x4a8b6a0a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[11], ctx->vu0_vf[11], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[13] = _mm_blendv_ps(ctx->vu0_vf[13], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cd3c: 0x4a4a503c
    ctx->vu0_i = (float)ctx->vi[10];
    // 0x16cd40: 0x4a4a6a09
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[10], ctx->vu0_vf[10], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[13] = _mm_blendv_ps(ctx->vu0_vf[13], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cd44: 0x4be629ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x16cd48: 0xfba903e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 992), _mm_castps_si128(ctx->vu0_vf[9]));
    // 0x16cd4c: 0xfba603d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 976), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x16cd50: 0xfba703b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 944), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x16cd54: 0xfba503a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 928), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x16cd58: 0xfa480160
    WRITE128(ADD32(GPR_U32(ctx, 18), 352), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x16cd5c: 0xdba403d0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 976)));
    // 0x16cd60: 0xdba300f0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x16cd64: 0xdba20100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x16cd68: 0xdba10110
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x16cd6c: 0x4be41a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16cd70: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x16cd74: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16cd78: 0x4be409aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16cd7c: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x16cd80: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cd84: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x16cd88: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cd8c: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x16cd90: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16cd94: 0x10000006
    WRITE128(ADD32(GPR_U32(ctx, 17), 352), _mm_castps_si128(ctx->vu0_vf[5]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16cdb0;
    }
label_16cd9c:
    // 0x16cd9c: 0x26c28d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 22), 4294937904));
    // 0x16cda0: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16cda4: 0x7e430160
    WRITE128(ADD32(GPR_U32(ctx, 18), 352), GPR_VEC(ctx, 3));
    // 0x16cda8: 0x78440000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16cdac: 0x7e240160
    WRITE128(ADD32(GPR_U32(ctx, 17), 352), GPR_VEC(ctx, 4));
label_16cdb0:
    // 0x16cdb0: 0x8e420224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 548)));
    // 0x16cdb4: 0x7bbf0460
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1120)));
    // 0x16cdb8: 0xac400064
    WRITE32(ADD32(GPR_U32(ctx, 2), 100), GPR_U32(ctx, 0));
    // 0x16cdbc: 0x7bb60450
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 1104)));
    // 0x16cdc0: 0x8e230224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 548)));
    // 0x16cdc4: 0x7bb50440
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    // 0x16cdc8: 0x7bb40430
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x16cdcc: 0x7bb30420
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x16cdd0: 0x7bb20410
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1040)));
    // 0x16cdd4: 0x7bb10400
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1024)));
    // 0x16cdd8: 0x7bb003f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1008)));
    // 0x16cddc: 0xc7b80490
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1168)); ctx->f[24] = *(float*)&val; }
    // 0x16cde0: 0xc7b70488
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1160)); ctx->f[23] = *(float*)&val; }
    // 0x16cde4: 0xc7b60480
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1152)); ctx->f[22] = *(float*)&val; }
    // 0x16cde8: 0xc7b50478
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1144)); ctx->f[21] = *(float*)&val; }
    // 0x16cdec: 0xc7b40470
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1136)); ctx->f[20] = *(float*)&val; }
    // 0x16cdf0: 0xac600064
    WRITE32(ADD32(GPR_U32(ctx, 3), 100), GPR_U32(ctx, 0));
    // 0x16cdf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1184));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16cdfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16ce00; return;
}


// Function: InitJlo__FP3JLO
// Address: 0x16ce00 - 0x16ce14

void entry_16ce14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ce14: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x16ce18: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x16ce1c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16ce20: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16ce24: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x16ce28: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16ce2c: 0x2604055c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1372));
    // 0x16ce30: 0xae020598
    WRITE32(ADD32(GPR_U32(ctx, 16), 1432), GPR_U32(ctx, 2));
    // 0x16ce34: 0x240507b0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1968));
    // 0x16ce38: 0xe60105c4
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1476), *(uint32_t*)&val); }
    // 0x16ce3c: 0xe60005c8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1480), *(uint32_t*)&val); }
    // 0x16ce40: 0xc05490e
    SET_GPR_U32(ctx, 31, 0x16ce48);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1400), GPR_U32(ctx, 2));
    InitDl__FP2DLi(rdram, ctx, runtime); return;
}


// Function: entry_16ce48
// Address: 0x16ce48 - 0x16ce80

void entry_16ce48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ce48: 0x3c0141c8
    SET_GPR_U32(ctx, 1, ((uint32_t)16840 << 16));
    // 0x16ce4c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16ce50: 0x260205b0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 1456));
    // 0x16ce54: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x16ce58: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16ce5c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x16ce60: 0xe60105b0
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1456), *(uint32_t*)&val); }
    // 0x16ce64: 0xe4400008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 8), *(uint32_t*)&val); }
    // 0x16ce68: 0xac400004
    WRITE32(ADD32(GPR_U32(ctx, 2), 4), GPR_U32(ctx, 0));
    // 0x16ce6c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16ce70: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16ce74: 0xac6029c8
    WRITE32(ADD32(GPR_U32(ctx, 3), 10696), GPR_U32(ctx, 0));
    // 0x16ce78: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadJloFromBrx__FP3JLOP18CBinaryInputStream
// Address: 0x16ce80 - 0x16ceb8

void entry_16ceb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ceb8: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x16cebc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16cec0: 0x24c629d0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 10704));
    // 0x16cec4: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x16cecc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_16cecc
// Address: 0x16cecc - 0x16cf00

void entry_16cecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16cecc) {
        switch (ctx->pc) {
            case 0x16ced8: ctx->pc = 0; goto label_16ced8;
            case 0x16cee0: ctx->pc = 0; goto label_16cee0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16cecc: 0x10000004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16cee0;
    }
    // 0x16ced4: 0x0
    // NOP
label_16ced8:
    // 0x16ced8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x16cedc: 0x8e240550
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
label_16cee0:
    // 0x16cee0: 0x8c82003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 60)));
    // 0x16cee4: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x16cee8: 0x10400018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16CF4C; return;
    }
    // 0x16cef0: 0x8c820040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 64)));
    // 0x16cef4: 0x538021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x16cef8: 0xc06d908
    SET_GPR_U32(ctx, 31, 0x16cf00);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    OidFromSmIsms__FP2SMi(rdram, ctx, runtime); return;
}


// Function: entry_16cf00
// Address: 0x16cf00 - 0x16cf14

void entry_16cf00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16cf00: 0x5455fff5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 21)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 20));
        ctx->pc = 0x16CED8; return;
    }
    // 0x16cf08: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16cf0c: 0xc06d908
    SET_GPR_U32(ctx, 31, 0x16cf14);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    OidFromSmIsms__FP2SMi(rdram, ctx, runtime); return;
}


// Function: entry_16cf14
// Address: 0x16cf14 - 0x16cf70

void entry_16cf14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16cf14) {
        switch (ctx->pc) {
            case 0x16cf48: ctx->pc = 0; goto label_16cf48;
            case 0x16cf4c: ctx->pc = 0; goto label_16cf4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16cf14: 0x1454fff0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        ctx->pc = 0x16CED8; return;
    }
    // 0x16cf1c: 0x8e230550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1360)));
    // 0x16cf20: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x16cf24: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x16cf28: 0x10400007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16cf48;
    }
    // 0x16cf30: 0x8c640040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x16cf34: 0x2421018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x16cf38: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x16cf3c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16cf40: 0xc4600034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 52)); ctx->f[0] = *(float*)&val; }
    // 0x16cf44: 0xe62005a4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1444), *(uint32_t*)&val); }
label_16cf48:
    // 0x16cf48: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_16cf4c:
    // 0x16cf4c: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16cf50: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16cf54: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16cf58: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16cf5c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16cf60: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16cf64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16cf6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16cf70; return;
}


// Function: PostJloLoad__FP3JLO
// Address: 0x16cf70 - 0x16cf84

void entry_16cf84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16cf84: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x16cf88: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16cf8c: 0x24c62a10
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 10768));
    // 0x16cf90: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x16cf98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_16cf98
// Address: 0x16cf98 - 0x16cfac

void entry_16cf98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16cf98: 0x8e040550
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x16cf9c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16cfa0: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16cfa4: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x16cfac);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_16cfac
// Address: 0x16cfac - 0x16cfc4

void entry_16cfac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16cfac: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x16cfb0: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16cfb4: 0x2406008c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 140));
    // 0x16cfb8: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16cfbc: 0xc056a0e
    SET_GPR_U32(ctx, 31, 0x16cfc4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1364), GPR_U32(ctx, 2));
    PloFindSwObjectByClass__FP2SWi3CIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_16cfc4
// Address: 0x16cfc4 - 0x16cfd4

void entry_16cfc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16cfc4: 0x8e040568
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1384)));
    // 0x16cfc8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16cfcc: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x16cfd4);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1392), GPR_U32(ctx, 2));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_16cfd4
// Address: 0x16cfd4 - 0x16cff8

void entry_16cfd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16cfd4: 0xc7a10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    // 0x16cfd8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16cfdc: 0xc6000148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 328)); ctx->f[0] = *(float*)&val; }
    // 0x16cfe0: 0x8e050578
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1400)));
    // 0x16cfe4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x16cfe8: 0x10a20003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1388), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        entry_16cff8(rdram, ctx, runtime); return;
    }
    // 0x16cff0: 0xc05b410
    SET_GPR_U32(ctx, 31, 0x16cff8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0016d040(rdram, ctx, runtime); return;
}


// Function: entry_16cff8
// Address: 0x16cff8 - 0x16d028

void entry_16cff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16cff8: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x16cffc: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x16d000: 0x31ef8
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 27);
    // 0x16d004: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x16d008: 0x24040073
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 115));
    // 0x16d00c: 0x8cc55710
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 22288)));
    // 0x16d010: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16d014: 0xfe020538
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 2));
    // 0x16d018: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16d01c: 0x24070302
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 770));
    // 0x16d020: 0xc047960
    SET_GPR_U32(ctx, 31, 0x16d028);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_16d028
// Address: 0x16d028 - 0x16d040

void entry_16d028(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d028: 0xae020594
    WRITE32(ADD32(GPR_U32(ctx, 16), 1428), GPR_U32(ctx, 2));
    // 0x16d02c: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16d030: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16d034: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16d03c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16d040; return;
}


// Function: FUN_0016d040
// Address: 0x16d040 - 0x16d068

void FUN_0016d040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d040: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x16d044: 0xa0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x16d048: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x16d04c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x16d050: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x16d054: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16d058: 0xae020578
    WRITE32(ADD32(GPR_U32(ctx, 16), 1400), GPR_U32(ctx, 2));
    // 0x16d05c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16d060: 0xc056912
    SET_GPR_U32(ctx, 31, 0x16d068);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    PloFindSwNearest__FP2SW3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_16d068
// Address: 0x16d068 - 0x16d07c

void entry_16d068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d068: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16d06c: 0x1220000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_16d0a8(rdram, ctx, runtime); return;
    }
    // 0x16d074: 0xc05b4fc
    SET_GPR_U32(ctx, 31, 0x16d07c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SetJloJlovol__FP3JLOP6JLOVOL(rdram, ctx, runtime); return;
}


// Function: entry_16d07c
// Address: 0x16d07c - 0x16d084

void entry_16d07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d07c: 0xc05b5e2
    SET_GPR_U32(ctx, 31, 0x16d084);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    LandJlo__FP3JLO(rdram, ctx, runtime); return;
}


// Function: entry_16d084
// Address: 0x16d084 - 0x16d098

void entry_16d084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d084: 0x8e2207ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1964)));
    // 0x16d088: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D0A0; return;
    }
    // 0x16d090: 0xc05b6b0
    SET_GPR_U32(ctx, 31, 0x16d098);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJloJlos__FP3JLO4JLOS(rdram, ctx, runtime); return;
}


// Function: entry_16d098
// Address: 0x16d098 - 0x16d0a8

void entry_16d098(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d098) {
        switch (ctx->pc) {
            case 0x16d0a0: ctx->pc = 0; goto label_16d0a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d098: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D0AC; return;
    }
label_16d0a0:
    // 0x16d0a0: 0xc05b6b0
    SET_GPR_U32(ctx, 31, 0x16d0a8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    SetJloJlos__FP3JLO4JLOS(rdram, ctx, runtime); return;
}


// Function: entry_16d0a8
// Address: 0x16d0a8 - 0x16d0c0

void entry_16d0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d0a8) {
        switch (ctx->pc) {
            case 0x16d0ac: ctx->pc = 0; goto label_16d0ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d0a8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_16d0ac:
    // 0x16d0ac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16d0b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16d0b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16d0bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16d0c0; return;
}


// Function: PresetJloAccel__FP3JLOf
// Address: 0x16d0c0 - 0x16d0dc

void entry_16d0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d0dc: 0x8e0205d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1496)));
    // 0x16d0e0: 0x1440000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D114; return;
    }
    // 0x16d0e8: 0xc60c05a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1440)); ctx->f[12] = *(float*)&val; }
    // 0x16d0ec: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x16d0f0: 0x24848d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    // 0x16d0f4: 0xc062214
    SET_GPR_U32(ctx, 31, 0x16d0fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_16d0fc
// Address: 0x16d0fc - 0x16d110

void entry_16d0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d0fc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16d100: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x16d104: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16d108: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x16d110);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1456));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_16d110
// Address: 0x16d110 - 0x16d128

void entry_16d110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d110) {
        switch (ctx->pc) {
            case 0x16d114: ctx->pc = 0; goto label_16d114;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d110: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_16d114:
    // 0x16d114: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16d118: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x16d11c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16d124: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16d128; return;
}


// Function: UpdateJlo__FP3JLOf
// Address: 0x16d128 - 0x16d13c

void entry_16d13c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d13c: 0xc05b66a
    SET_GPR_U32(ctx, 31, 0x16d144);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0016d9a8(rdram, ctx, runtime); return;
}


// Function: entry_16d144
// Address: 0x16d144 - 0x16d168

void entry_16d144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d144) {
        switch (ctx->pc) {
            case 0x16d160: ctx->pc = 0; goto label_16d160;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d144: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16d148: 0x8c4329c8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 10696)));
    // 0x16d14c: 0x16030021
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x16D1D4; return;
    }
    // 0x16d154: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_16d168(rdram, ctx, runtime); return;
    }
    // 0x16d15c: 0x0
    // NOP
label_16d160:
    // 0x16d160: 0xc05b6b0
    SET_GPR_U32(ctx, 31, 0x16d168);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetJloJlos__FP3JLO4JLOS(rdram, ctx, runtime); return;
}


// Function: entry_16d168
// Address: 0x16d168 - 0x16d170

void entry_16d168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d168: 0xc05b478
    SET_GPR_U32(ctx, 31, 0x16d170);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    JlosNextJlo__FP3JLO(rdram, ctx, runtime); return;
}


// Function: entry_16d170
// Address: 0x16d170 - 0x16d1a8

void entry_16d170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d170: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16d174: 0x8e020598
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1432)));
    // 0x16d178: 0x14a2fff9
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), 5));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x16D160; return;
    }
    // 0x16d180: 0x10400013
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D1D0; return;
    }
    // 0x16d188: 0x51880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 5), 2));
    // 0x16d18c: 0x2442a7f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294944752));
    // 0x16d190: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x16d194: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16d198: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x16d1a0: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x16d1a8);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16d1a8
// Address: 0x16d1a8 - 0x16d1cc

void entry_16d1a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d1a8: 0x1040000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D1D4; return;
    }
    // 0x16d1b0: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x16d1b4: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x16d1b8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d1bc: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16d1c0: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x16d1c4: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x16d1cc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_16d1cc
// Address: 0x16d1cc - 0x16d1e0

void entry_16d1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d1cc) {
        switch (ctx->pc) {
            case 0x16d1d0: ctx->pc = 0; goto label_16d1d0;
            case 0x16d1d4: ctx->pc = 0; goto label_16d1d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d1cc: 0xe60005a0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1440), *(uint32_t*)&val); }
label_16d1d0:
    // 0x16d1d0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_16d1d4:
    // 0x16d1d4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16d1d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: JlosNextJlo__FP3JLO
// Address: 0x16d1e0 - 0x16d25c

void entry_16d25c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d25c) {
        switch (ctx->pc) {
            case 0x16d2a4: ctx->pc = 0; goto label_16d2a4;
            case 0x16d2ac: ctx->pc = 0; goto label_16d2ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d25c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16d260: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x16d264: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d268: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x16d26c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16d270: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d274: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d278: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d27c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16d280: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16d284: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16d288: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x16d28c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16d290: 0x0
    // NOP
    // 0x16d294: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_16d2ac;
    }
    // 0x16d29c: 0x8e2307ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1964)));
    // 0x16d2a0: 0x24100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4));
label_16d2a4:
    // 0x16d2a4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16d2a8: 0x43800b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 2));
label_16d2ac:
    // 0x16d2ac: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16d2b0: 0xc05b4fc
    SET_GPR_U32(ctx, 31, 0x16d2b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetJloJlovol__FP3JLOP6JLOVOL(rdram, ctx, runtime); return;
}


// Function: entry_16d2b8
// Address: 0x16d2b8 - 0x16d2c0

void entry_16d2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d2b8: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x16d2c0);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16d2c0
// Address: 0x16d2c0 - 0x16d2e8

void entry_16d2c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d2c0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16d2c4: 0x12200043
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D3D4; return;
    }
    // 0x16d2cc: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x16d2d0: 0x16230013
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x16D320; return;
    }
    // 0x16d2d8: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x16d2dc: 0x8c620144
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 324)));
    // 0x16d2e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16d2e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16d2e8
// Address: 0x16d2e8 - 0x16d360

void entry_16d2e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d2e8) {
        switch (ctx->pc) {
            case 0x16d318: ctx->pc = 0; goto label_16d318;
            case 0x16d320: ctx->pc = 0; goto label_16d320;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d2e8: 0x1440000b
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_16d318;
    }
    // 0x16d2f0: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x16d2f4: 0x1602000a
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_16d320;
    }
    // 0x16d2fc: 0x8e420558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1368)));
    // 0x16d300: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16d320;
    }
    // 0x16d308: 0x8c4307ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1964)));
    // 0x16d30c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16d310: 0x10000003
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16d320;
    }
label_16d318:
    // 0x16d318: 0x3a020002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 16), 2));
    // 0x16d31c: 0x62800a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
label_16d320:
    // 0x16d320: 0x1220002c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D3D4; return;
    }
    // 0x16d328: 0x1602002b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x16D3D8; return;
    }
    // 0x16d330: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16d334: 0xc6410574
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1396)); ctx->f[1] = *(float*)&val; }
    // 0x16d338: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x16d33c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16d340: 0x0
    // NOP
    // 0x16d344: 0x45000024
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x16D3D8; return;
    }
    // 0x16d34c: 0x8e440570
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1392)));
    // 0x16d350: 0x10800022
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D3DC; return;
    }
    // 0x16d358: 0xc06a314
    SET_GPR_U32(ctx, 31, 0x16d360);
    FEnsureRwmLoaded__FP3RWM(rdram, ctx, runtime); return;
}


// Function: entry_16d360
// Address: 0x16d360 - 0x16d374

void entry_16d360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d360: 0x1040001d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D3D8; return;
    }
    // 0x16d368: 0x8e420558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1368)));
    // 0x16d36c: 0xc05b788
    SET_GPR_U32(ctx, 31, 0x16d374);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1964)));
    PxfmChooseJloc__FP4JLOC(rdram, ctx, runtime); return;
}


// Function: entry_16d374
// Address: 0x16d374 - 0x16d3f0

void entry_16d374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d374) {
        switch (ctx->pc) {
            case 0x16d3d4: ctx->pc = 0; goto label_16d3d4;
            case 0x16d3d8: ctx->pc = 0; goto label_16d3d8;
            case 0x16d3dc: ctx->pc = 0; goto label_16d3dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d374: 0x50400018
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        goto label_16d3d8;
    }
    // 0x16d37c: 0xae420590
    WRITE32(ADD32(GPR_U32(ctx, 18), 1424), GPR_U32(ctx, 2));
    // 0x16d380: 0x10000014
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16d3d4;
    }
    // 0x16d388: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16d38c: 0xc64105ac
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1452)); ctx->f[1] = *(float*)&val; }
    // 0x16d390: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x16d394: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16d398: 0x0
    // NOP
    // 0x16d39c: 0x4500000d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16d3d4;
    }
    // 0x16d3a4: 0x8e440558
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1368)));
    // 0x16d3a8: 0x24100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4));
    // 0x16d3ac: 0x8c8207ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1964)));
    // 0x16d3b0: 0x10000008
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16d3d4;
    }
    // 0x16d3b8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16d3bc: 0xc64105a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1448)); ctx->f[1] = *(float*)&val; }
    // 0x16d3c0: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x16d3c4: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16d3c8: 0x0
    // NOP
    // 0x16d3cc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
        goto label_16d3d4;
    }
label_16d3d4:
    // 0x16d3d4: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_16d3d8:
    // 0x16d3d8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_16d3dc:
    // 0x16d3dc: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16d3e0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16d3e4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16d3e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetJloJlovol__FP3JLOP6JLOVOL
// Address: 0x16d3f0 - 0x16d44c

void entry_16d44c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d44c: 0x8e0205bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1468)));
    // 0x16d450: 0x1440000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D484; return;
    }
    // 0x16d458: 0xc06fbbe
    SET_GPR_U32(ctx, 31, 0x16d460);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 107));
    PexcSetExcitement__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16d460
// Address: 0x16d460 - 0x16d47c

void entry_16d460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d460) {
        switch (ctx->pc) {
            case 0x16d468: ctx->pc = 0; goto label_16d468;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d460: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 1468), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D480; return;
    }
label_16d468:
    // 0x16d468: 0x8e0405bc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1468)));
    // 0x16d46c: 0x10800005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D484; return;
    }
    // 0x16d474: 0xc06fc36
    SET_GPR_U32(ctx, 31, 0x16d47c);
    UnsetExcitementHyst__FP3EXC(rdram, ctx, runtime); return;
}


// Function: entry_16d47c
// Address: 0x16d47c - 0x16d490

void entry_16d47c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d47c) {
        switch (ctx->pc) {
            case 0x16d480: ctx->pc = 0; goto label_16d480;
            case 0x16d484: ctx->pc = 0; goto label_16d484;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d47c: 0xae0005bc
    WRITE32(ADD32(GPR_U32(ctx, 16), 1468), GPR_U32(ctx, 0));
label_16d480:
    // 0x16d480: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_16d484:
    // 0x16d484: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16d488: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FireJlo__FP3JLO
// Address: 0x16d490 - 0x16d4c4

void entry_16d4c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d4c4: 0x8e720570
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 19), 1392)));
    // 0x16d4c8: 0x8e500048
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 72)));
    // 0x16d4cc: 0x26550060
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 18), 96));
    // 0x16d4d0: 0x120000a2
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 18), 224));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D75C; return;
    }
    // 0x16d4d8: 0x27b40010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16d4dc: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x16d4e0: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x16d4e4: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x16d4e8: 0xc06a530
    SET_GPR_U32(ctx, 31, 0x16d4f0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetRwfiPosMat__FP4RWFIP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_16d4f0
// Address: 0x16d4f0 - 0x16d504

void entry_16d4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d4f0: 0x8e620558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1368)));
    // 0x16d4f4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16d4f8: 0x2405003d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 61));
    // 0x16d4fc: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x16d504);
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 1964)));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_16d504
// Address: 0x16d504 - 0x16d61c

void entry_16d504(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d504) {
        switch (ctx->pc) {
            case 0x16d568: ctx->pc = 0; goto label_16d568;
            case 0x16d578: ctx->pc = 0; goto label_16d578;
            case 0x16d5b4: ctx->pc = 0; goto label_16d5b4;
            case 0x16d5f4: ctx->pc = 0; goto label_16d5f4;
            case 0x16d610: ctx->pc = 0; goto label_16d610;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d504: 0x10400042
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16d610;
    }
    // 0x16d50c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x16d510: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16d514: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x16d518: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16d51c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x16d520: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x16d524: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16d528: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16d52c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16d530: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d534: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16d538: 0xfba30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16d53c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d540: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16d544: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16d548: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16d54c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x16d550: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16d554: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16d568;
    }
    // 0x16d55c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16d560: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16d578;
    }
label_16d568:
    // 0x16d568: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x16d56c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16d570: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x16d574: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
label_16d578:
    // 0x16d578: 0xc6240328
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 808)); ctx->f[4] = *(float*)&val; }
    // 0x16d57c: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16d580: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16d584: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16d588: 0x44821000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 2);
    // 0x16d58c: 0x46002032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16d590: 0x0
    // NOP
    // 0x16d594: 0x45000007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 804)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16d5b4;
    }
    // 0x16d59c: 0xc6200320
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 800)); ctx->f[0] = *(float*)&val; }
    // 0x16d5a0: 0xae0006f4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1780), GPR_U32(ctx, 0));
    // 0x16d5a4: 0x46001003
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[0] = ctx->f[2] / ctx->f[0];
    // 0x16d5a8: 0xe6000690
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1680), *(uint32_t*)&val); }
    // 0x16d5ac: 0x10000011
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1776), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16d5f4;
    }
label_16d5b4:
    // 0x16d5b4: 0x46052002
    ctx->f[0] = FPU_MUL_S(ctx->f[4], ctx->f[5]);
    // 0x16d5b8: 0xc6230320
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 800)); ctx->f[3] = *(float*)&val; }
    // 0x16d5bc: 0x46042040
    ctx->f[1] = FPU_ADD_S(ctx->f[4], ctx->f[4]);
    // 0x16d5c0: 0x46021080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[2]);
    // 0x16d5c4: 0x46002801
    ctx->f[0] = FPU_SUB_S(ctx->f[5], ctx->f[0]);
    // 0x16d5c8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x16d5cc: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x16d5d0: 0x46001083
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[0];
    // 0x16d5d4: 0x46041042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x16d5d8: 0xe6020690
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 1680), *(uint32_t*)&val); }
    // 0x16d5dc: 0xe60106f0
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1776), *(uint32_t*)&val); }
    // 0x16d5e0: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x16d5e4: 0xc6200320
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 800)); ctx->f[0] = *(float*)&val; }
    // 0x16d5e8: 0x46002802
    ctx->f[0] = FPU_MUL_S(ctx->f[5], ctx->f[0]);
    // 0x16d5ec: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x16d5f0: 0xe60106f4
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1780), *(uint32_t*)&val); }
label_16d5f4:
    // 0x16d5f4: 0x8e100690
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1680)));
    // 0x16d5f8: 0x48b01000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    // 0x16d5fc: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16d600: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d604: 0xfba20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16d608: 0x10000042
    WRITE128(ADD32(GPR_U32(ctx, 21), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D714; return;
    }
label_16d610:
    // 0x16d610: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16d614: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x16d61c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 62));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_16d61c
// Address: 0x16d61c - 0x16d684

void entry_16d61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d61c) {
        switch (ctx->pc) {
            case 0x16d66c: ctx->pc = 0; goto label_16d66c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d61c: 0x10400013
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16d66c;
    }
    // 0x16d624: 0x8e230330
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 816)));
    // 0x16d628: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x16d62c: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x16d630: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16d634: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16d638: 0x4be11058
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16d63c: 0xfa4100b0
    WRITE128(ADD32(GPR_U32(ctx, 18), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16d640: 0xc6200334
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 820)); ctx->f[0] = *(float*)&val; }
    // 0x16d644: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x16d648: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x16d64c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x16d650: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x16d654: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16d658: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d65c: 0xfa010700
    WRITE128(ADD32(GPR_U32(ctx, 16), 1792), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16d660: 0xc6200320
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 800)); ctx->f[0] = *(float*)&val; }
    // 0x16d664: 0x1000002b
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1776), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D714; return;
    }
label_16d66c:
    // 0x16d66c: 0xc62c032c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 812)); ctx->f[12] = *(float*)&val; }
    // 0x16d670: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x16d674: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16d678: 0x27a60050
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 80));
    // 0x16d67c: 0xc07b7bc
    SET_GPR_U32(ctx, 31, 0x16d684);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FCalculateMuzzleVelocity__FP6VECTORT0fT0P2SO(rdram, ctx, runtime); return;
}


// Function: entry_16d684
// Address: 0x16d684 - 0x16d73c

void entry_16d684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d684) {
        switch (ctx->pc) {
            case 0x16d714: ctx->pc = 0; goto label_16d714;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d684: 0x10400035
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D75C; return;
    }
    // 0x16d68c: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16d690: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16d694: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d698: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d69c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d6a0: 0x4b8210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16d6a4: 0x4b021081
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16d6a8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d6ac: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16d6b0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16d6b4: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16d6b8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16d6bc: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16d6c0: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16d6c4: 0xc6220320
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 800)); ctx->f[2] = *(float*)&val; }
    // 0x16d6c8: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16d6cc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x16d6d0: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x16d6d4: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x16d6d8: 0x8e620014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x16d6dc: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x16d6e0: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x16d6e4: 0x46000002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[0]);
    // 0x16d6e8: 0x48a31800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x16d6ec: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x16d6f0: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x16d6f4: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16d6f8: 0xd8421ee0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 7904)));
    // 0x16d6fc: 0x4be11058
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16d700: 0xfa010350
    WRITE128(ADD32(GPR_U32(ctx, 16), 848), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16d704: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16d708: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16d70c: 0x4be308d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d710: 0xfa4300b0
    WRITE128(ADD32(GPR_U32(ctx, 18), 176), _mm_castps_si128(ctx->vu0_vf[3]));
label_16d714:
    // 0x16d714: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16d718: 0xc6200320
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 800)); ctx->f[0] = *(float*)&val; }
    // 0x16d71c: 0xc4412a28
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 10792)); ctx->f[1] = *(float*)&val; }
    // 0x16d720: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16d724: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x16d728: 0xe6a00078
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 21), 120), *(uint32_t*)&val); }
    // 0x16d72c: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16d730: 0x7ec20010
    WRITE128(ADD32(GPR_U32(ctx, 22), 16), GPR_VEC(ctx, 2));
    // 0x16d734: 0xc06a324
    SET_GPR_U32(ctx, 31, 0x16d73c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1392)));
    FFireRwm__FP3RWMi(rdram, ctx, runtime); return;
}


// Function: entry_16d73c
// Address: 0x16d73c - 0x16d788

void entry_16d73c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d73c) {
        switch (ctx->pc) {
            case 0x16d75c: ctx->pc = 0; goto label_16d75c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d73c: 0x10400007
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16d75c;
    }
    // 0x16d744: 0x8e640558
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1368)));
    // 0x16d748: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x16d74c: 0x8c8307ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1964)));
    // 0x16d750: 0xc461031c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 796)); ctx->f[1] = *(float*)&val; }
    // 0x16d754: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x16d758: 0xe6600574
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 1396), *(uint32_t*)&val); }
label_16d75c:
    // 0x16d75c: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x16d760: 0x7bb600d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x16d764: 0x7bb500c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x16d768: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x16d76c: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x16d770: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x16d774: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x16d778: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x16d77c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16d784: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16d788; return;
}


// Function: LandJlo__FP3JLO
// Address: 0x16d788 - 0x16d7b0

void entry_16d7b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d7b0: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x16d7b4: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x16d7b8: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x16d7bc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16d7c0: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x16d7c4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16d7cc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16d7cc
// Address: 0x16d7cc - 0x16d7e0

void entry_16d7cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d7cc: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x16d7d0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16d7d4: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x16d7d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16d7e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16d7e0
// Address: 0x16d7e0 - 0x16d7f0

void entry_16d7e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d7e0: 0x8e230558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1368)));
    // 0x16d7e4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16d7e8: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x16d7f0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 1956)));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_16d7f0
// Address: 0x16d7f0 - 0x16d814

void entry_16d7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d7f0: 0xc621056c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1388)); ctx->f[1] = *(float*)&val; }
    // 0x16d7f4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16d7f8: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x16d7fc: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x16d800: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x16d804: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x16d808: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x16d80c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16d814);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16d814
// Address: 0x16d814 - 0x16d828

void entry_16d814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d814: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16d818: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16d81c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16d820: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: JumpJlo__FP3JLO
// Address: 0x16d828 - 0x16d84c

void entry_16d84c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d84c: 0xc601056c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1388)); ctx->f[1] = *(float*)&val; }
    // 0x16d850: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16d854: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x16d858: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16d85c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x16d860: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x16d864: 0x26040140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 320));
    // 0x16d868: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x16d86c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16d870: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16d874: 0xc07b7bc
    SET_GPR_U32(ctx, 31, 0x16d87c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    FCalculateMuzzleVelocity__FP6VECTORT0fT0P2SO(rdram, ctx, runtime); return;
}


// Function: entry_16d87c
// Address: 0x16d87c - 0x16d894

void entry_16d87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d87c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16d880: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16d884: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16d888: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16d88c: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x16d894);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_16d894
// Address: 0x16d894 - 0x16d8a8

void entry_16d894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d894: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x16d898: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16d89c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x16d8a0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16d8a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16d8a8
// Address: 0x16d8a8 - 0x16d928

void entry_16d8a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d8a8: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x16d8ac: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16d8b0: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16d8b4: 0x4be218ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16d8b8: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16d8bc: 0x4b8318aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x16d8c0: 0x4b021081
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16d8c4: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d8c8: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d8cc: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16d8d0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16d8d4: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16d8d8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16d8dc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16d8e0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16d8e4: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16d8e8: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x16d8ec: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x16d8f0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16d8f4: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16d8f8: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16d8fc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x16d900: 0x46001083
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[2] = copysignf(INFINITY, ctx->f[2] * 0.0f); } else ctx->f[2] = ctx->f[2] / ctx->f[0];
    // 0x16d904: 0xc60005a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1444)); ctx->f[0] = *(float*)&val; }
    // 0x16d908: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16d90c: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x16d910: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x16d914: 0xe60105ac
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1452), *(uint32_t*)&val); }
    // 0x16d918: 0xe60005a8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1448), *(uint32_t*)&val); }
    // 0x16d91c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16d920: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0016d928
// Address: 0x16d928 - 0x16d94c

void FUN_0016d928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d928: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x16d92c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x16d930: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x16d934: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16d938: 0x8e0205c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1472)));
    // 0x16d93c: 0x10400016
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D998; return;
    }
    // 0x16d944: 0xc06fa60
    SET_GPR_U32(ctx, 31, 0x16d94c);
    FVagPlaying__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16d94c
// Address: 0x16d94c - 0x16d960

void entry_16d94c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d94c: 0x14400012
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D998; return;
    }
    // 0x16d954: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16d958: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x16d960);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 100));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_16d960
// Address: 0x16d960 - 0x16d978

void entry_16d960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d960: 0x28420014
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 20));
    // 0x16d964: 0x1040000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D998; return;
    }
    // 0x16d96c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16d970: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x16d978);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_16d978
// Address: 0x16d978 - 0x16d98c

void entry_16d978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d978: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x16d97c: 0x21140
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 5));
    // 0x16d980: 0x248482d8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294935256));
    // 0x16d984: 0xc06f9ca
    SET_GPR_U32(ctx, 31, 0x16d98c);
    SET_GPR_U32(ctx, 4, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    PreloadVag1(rdram, ctx, runtime); return;
}


// Function: entry_16d98c
// Address: 0x16d98c - 0x16d9a8

void entry_16d98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d98c) {
        switch (ctx->pc) {
            case 0x16d998: ctx->pc = 0; goto label_16d998;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d98c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16d990: 0xae0205cc
    WRITE32(ADD32(GPR_U32(ctx, 16), 1484), GPR_U32(ctx, 2));
    // 0x16d994: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_16d998:
    // 0x16d998: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16d99c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16d9a4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16d9a8; return;
}


// Function: FUN_0016d9a8
// Address: 0x16d9a8 - 0x16d9cc

void FUN_0016d9a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d9a8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x16d9ac: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x16d9b0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x16d9b4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x16d9b8: 0x8e0205cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1484)));
    // 0x16d9bc: 0x1040000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D9F0; return;
    }
    // 0x16d9c4: 0xc06fa04
    SET_GPR_U32(ctx, 31, 0x16d9cc);
    FPauseForVag__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16d9cc
// Address: 0x16d9cc - 0x16d9ec

void entry_16d9cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16d9cc: 0x14400008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16D9F0; return;
    }
    // 0x16d9d4: 0xae0005cc
    WRITE32(ADD32(GPR_U32(ctx, 16), 1484), GPR_U32(ctx, 0));
    // 0x16d9d8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16d9dc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16d9e0: 0xc48c05c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 1476)); ctx->f[12] = *(float*)&val; }
    // 0x16d9e4: 0xc06fa3e
    SET_GPR_U32(ctx, 31, 0x16d9ec);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 1480)); ctx->f[13] = *(float*)&val; }
    FUN_001be8f8(rdram, ctx, runtime); return;
}


// Function: entry_16d9ec
// Address: 0x16d9ec - 0x16da00

void entry_16d9ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16d9ec) {
        switch (ctx->pc) {
            case 0x16d9f0: ctx->pc = 0; goto label_16d9f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16d9ec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_16d9f0:
    // 0x16d9f0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16d9f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16d9fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16da00; return;
}


// Function: HandleJloMessage__FP3JLO5MSGIDPv
// Address: 0x16da00 - 0x16da24

void entry_16da24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16da24) {
        switch (ctx->pc) {
            case 0x16da58: ctx->pc = 0; goto label_16da58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16da24: 0x24020013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 19));
    // 0x16da28: 0x16020020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x16DAAC; return;
    }
    // 0x16da30: 0x8e460008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x16da34: 0x240202fe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 766));
    // 0x16da38: 0x10c20019
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 6), 767));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x16DAA0; return;
    }
    // 0x16da40: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 765));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16da58;
    }
    // 0x16da48: 0x10c2000c
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x16DA7C; return;
    }
    // 0x16da50: 0x10000017
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DAB0; return;
    }
label_16da58:
    // 0x16da58: 0x240202ff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 767));
    // 0x16da5c: 0x10c2000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 768));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x16DA8C; return;
    }
    // 0x16da64: 0x14c20011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x16DAAC; return;
    }
    // 0x16da6c: 0xc05b60a
    SET_GPR_U32(ctx, 31, 0x16da74);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    JumpJlo__FP3JLO(rdram, ctx, runtime); return;
}


// Function: entry_16da74
// Address: 0x16da74 - 0x16da84

void entry_16da74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16da74) {
        switch (ctx->pc) {
            case 0x16da7c: ctx->pc = 0; goto label_16da7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16da74: 0x1000000d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DAAC; return;
    }
label_16da7c:
    // 0x16da7c: 0xc05b524
    SET_GPR_U32(ctx, 31, 0x16da84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FireJlo__FP3JLO(rdram, ctx, runtime); return;
}


// Function: entry_16da84
// Address: 0x16da84 - 0x16da98

void entry_16da84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16da84) {
        switch (ctx->pc) {
            case 0x16da8c: ctx->pc = 0; goto label_16da8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16da84: 0x10000009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DAAC; return;
    }
label_16da8c:
    // 0x16da8c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16da90: 0xc05b6b0
    SET_GPR_U32(ctx, 31, 0x16da98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJloJlos__FP3JLO4JLOS(rdram, ctx, runtime); return;
}


// Function: entry_16da98
// Address: 0x16da98 - 0x16daa8

void entry_16da98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16da98) {
        switch (ctx->pc) {
            case 0x16daa0: ctx->pc = 0; goto label_16daa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16da98: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DAAC; return;
    }
label_16daa0:
    // 0x16daa0: 0xc05b64a
    SET_GPR_U32(ctx, 31, 0x16daa8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_0016d928(rdram, ctx, runtime); return;
}


// Function: entry_16daa8
// Address: 0x16daa8 - 0x16dac0

void entry_16daa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16daa8) {
        switch (ctx->pc) {
            case 0x16daac: ctx->pc = 0; goto label_16daac;
            case 0x16dab0: ctx->pc = 0; goto label_16dab0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16daa8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_16daac:
    // 0x16daac: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_16dab0:
    // 0x16dab0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16dab4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16dab8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: SetJloJlos__FP3JLO4JLOS
// Address: 0x16dac0 - 0x16daf8

void entry_16daf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16daf8) {
        switch (ctx->pc) {
            case 0x16dafc: ctx->pc = 0; goto label_16dafc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16daf8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_16dafc:
    // 0x16dafc: 0xae110598
    WRITE32(ADD32(GPR_U32(ctx, 16), 1432), GPR_U32(ctx, 17));
    // 0x16db00: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16db04: 0x2e230005
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 17), 5));
    // 0x16db08: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x16db0c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x16db10: 0x1060006d
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1436), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DCC8; return;
    }
    // 0x16db18: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x16db1c: 0x111880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 17), 2));
    // 0x16db20: 0x2442a830
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294944816));
    // 0x16db24: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x16db28: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16db2c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x16db34: 0x8e020558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x16db38: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16db3c: 0x241202ef
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 751));
    // 0x16db40: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x16db48);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1956)));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_16db48
// Address: 0x16db48 - 0x16db64

void entry_16db48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16db48: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x16db4c: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16db50: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16db54: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16db58: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x16db5c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x16db64);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_16db64
// Address: 0x16db64 - 0x16db84

void entry_16db64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16db64: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x16db68: 0xe60005a0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1440), *(uint32_t*)&val); }
    // 0x16db6c: 0xc440a824
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944804)); ctx->f[0] = *(float*)&val; }
    // 0x16db70: 0xe60005a8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1448), *(uint32_t*)&val); }
    // 0x16db74: 0x10000054
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1452), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DCC8; return;
    }
    // 0x16db7c: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x16db84);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16db84
// Address: 0x16db84 - 0x16dbdc

void entry_16db84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16db84: 0x8e030558
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x16db88: 0x8e0205d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1492)));
    // 0x16db8c: 0x1c400015
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 3), 1964)));
    if (GPR_S32(ctx, 2) > 0) {
        ctx->pc = 0x16DBE4; return;
    }
    // 0x16db94: 0x8e030594
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1428)));
    // 0x16db98: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16db9c: 0x8c462e10
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x16dba0: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x16dba4: 0xae030590
    WRITE32(ADD32(GPR_U32(ctx, 16), 1424), GPR_U32(ctx, 3));
    // 0x16dba8: 0x24e783d0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294935504));
    // 0x16dbac: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16dbb0: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16dbb4: 0x78c20140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 6), 320)));
    // 0x16dbb8: 0x7c620040
    WRITE128(ADD32(GPR_U32(ctx, 3), 64), GPR_VEC(ctx, 2));
    // 0x16dbbc: 0x78e20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x16dbc0: 0x8e060594
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1428)));
    // 0x16dbc4: 0x7cc20050
    WRITE128(ADD32(GPR_U32(ctx, 6), 80), GPR_VEC(ctx, 2));
    // 0x16dbc8: 0x78e30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 7), 16)));
    // 0x16dbcc: 0x7cc30060
    WRITE128(ADD32(GPR_U32(ctx, 6), 96), GPR_VEC(ctx, 3));
    // 0x16dbd0: 0x78e20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 7), 32)));
    // 0x16dbd4: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x16dbdc);
    WRITE128(ADD32(GPR_U32(ctx, 6), 112), GPR_VEC(ctx, 2));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_16dbdc
// Address: 0x16dbdc - 0x16dbec

void entry_16dbdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16dbdc) {
        switch (ctx->pc) {
            case 0x16dbe4: ctx->pc = 0; goto label_16dbe4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16dbdc: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 1492), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DBFC; return;
    }
label_16dbe4:
    // 0x16dbe4: 0xc05b788
    SET_GPR_U32(ctx, 31, 0x16dbec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    PxfmChooseJloc__FP4JLOC(rdram, ctx, runtime); return;
}


// Function: entry_16dbec
// Address: 0x16dbec - 0x16dc20

void entry_16dbec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16dbec) {
        switch (ctx->pc) {
            case 0x16dbfc: ctx->pc = 0; goto label_16dbfc;
            case 0x16dc14: ctx->pc = 0; goto label_16dc14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16dbec: 0x8e0305d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1492)));
    // 0x16dbf0: 0xae020590
    WRITE32(ADD32(GPR_U32(ctx, 16), 1424), GPR_U32(ctx, 2));
    // 0x16dbf4: 0x2463ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294967295));
    // 0x16dbf8: 0xae0305d4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1492), GPR_U32(ctx, 3));
label_16dbfc:
    // 0x16dbfc: 0x8e240318
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 792)));
    // 0x16dc00: 0x10800004
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 753));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_16dc14;
    }
    // 0x16dc08: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16dc0c: 0x50820001
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 754));
        goto label_16dc14;
    }
label_16dc14:
    // 0x16dc14: 0x8e040590
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1424)));
    // 0x16dc18: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x16dc20);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_16dc20
// Address: 0x16dc20 - 0x16dc3c

void entry_16dc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16dc20: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x16dc24: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16dc28: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16dc2c: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16dc30: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x16dc34: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x16dc3c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_16dc3c
// Address: 0x16dc3c - 0x16dc9c

void entry_16dc3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16dc3c) {
        switch (ctx->pc) {
            case 0x16dc88: ctx->pc = 0; goto label_16dc88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16dc3c: 0x10000022
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1440), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DCC8; return;
    }
    // 0x16dc44: 0x24a21858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 6232));
    // 0x16dc48: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16dc4c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16dc50: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x16dc54: 0x241202f0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 752));
    // 0x16dc58: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x16dc5c: 0x1000001a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1396), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DCC8; return;
    }
    // 0x16dc64: 0x8e020558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x16dc68: 0x8c4307ac
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1964)));
    // 0x16dc6c: 0x8c630318
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 792)));
    // 0x16dc70: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_16dc88;
    }
    // 0x16dc78: 0x10620010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 756));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x16DCBC; return;
    }
    // 0x16dc80: 0x10000012
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DCCC; return;
    }
label_16dc88:
    // 0x16dc88: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x16dc8c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16dc90: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x16dc94: 0xc07aab8
    SET_GPR_U32(ctx, 31, 0x16dc9c);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 757));
    GRandInRange__Fff(rdram, ctx, runtime); return;
}


// Function: entry_16dc9c
// Address: 0x16dc9c - 0x16dcd4

void entry_16dc9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16dc9c) {
        switch (ctx->pc) {
            case 0x16dcbc: ctx->pc = 0; goto label_16dcbc;
            case 0x16dcc8: ctx->pc = 0; goto label_16dcc8;
            case 0x16dccc: ctx->pc = 0; goto label_16dccc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16dc9c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x16dca0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16dca4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16dca8: 0x0
    // NOP
    // 0x16dcac: 0x45030006
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 756));
        goto label_16dcc8;
    }
    // 0x16dcb4: 0x10000005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16dccc;
    }
label_16dcbc:
    // 0x16dcbc: 0x10000002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 758));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16dcc8;
    }
    // 0x16dcc4: 0x241202f3
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 755));
label_16dcc8:
    // 0x16dcc8: 0x8e040554
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
label_16dccc:
    // 0x16dccc: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x16dcd4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_16dcd4
// Address: 0x16dcd4 - 0x16dcf0

void entry_16dcd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16dcd4: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16dcd8: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16dcdc: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16dce0: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16dce4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16dcec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16dcf0; return;
}


// Function: ActivateJlo__FP3JLO
// Address: 0x16dcf0 - 0x16dd00

void entry_16dd24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16dd24: 0x3c014010
    SET_GPR_U32(ctx, 1, ((uint32_t)16400 << 16));
    // 0x16dd28: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16dd2c: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x16dd30: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x16dd34: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x16dd38: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x16dd3c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x16dd40: 0x3c014080
    SET_GPR_U32(ctx, 1, ((uint32_t)16512 << 16));
    // 0x16dd44: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x16dd48: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x16dd4c: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x16dd50: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x16dd54: 0x44813000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 1);
    // 0x16dd58: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x16dd5c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16dd60: 0xe601031c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 796), *(uint32_t*)&val); }
    // 0x16dd64: 0xe6000334
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 820), *(uint32_t*)&val); }
    // 0x16dd68: 0xe6020320
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 800), *(uint32_t*)&val); }
    // 0x16dd6c: 0xe6030324
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 804), *(uint32_t*)&val); }
    // 0x16dd70: 0xe6040328
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 808), *(uint32_t*)&val); }
    // 0x16dd74: 0xe605032c
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 812), *(uint32_t*)&val); }
    // 0x16dd78: 0xe6060330
    { float val = ctx->f[6]; WRITE32(ADD32(GPR_U32(ctx, 16), 816), *(uint32_t*)&val); }
    // 0x16dd7c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16dd80: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16dd84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16dd8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16dd90; return;
}


// Function: LoadJlocFromBrx__FP4JLOCP18CBinaryInputStream
// Address: 0x16dd90 - 0x16dda4

void entry_16dda4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16dda4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x16dda8: 0x24050201
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 513));
    // 0x16ddac: 0x24060073
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 115));
    // 0x16ddb0: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16ddb4: 0x24080010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 16));
    // 0x16ddb8: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x16ddc0);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 16), 720));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_16ddc0
// Address: 0x16ddc0 - 0x16dde8

void entry_16ddc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ddc0) {
        switch (ctx->pc) {
            case 0x16ddd4: ctx->pc = 0; goto label_16ddd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ddc0: 0x2c430011
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 2), 17));
    // 0x16ddc4: 0x14600003
    WRITE32(ADD32(GPR_U32(ctx, 16), 784), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_16ddd4;
    }
    // 0x16ddcc: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x16ddd0: 0xae020310
    WRITE32(ADD32(GPR_U32(ctx, 16), 784), GPR_U32(ctx, 2));
label_16ddd4:
    // 0x16ddd4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16ddd8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16dddc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16dde4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16dde8; return;
}


// Function: PostJlocLoad__FP4JLOC
// Address: 0x16dde8 - 0x16ddfc

void entry_16ddfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ddfc: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x16de00: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x16de04: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16de0c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16de0c
// Address: 0x16de0c - 0x16de20

void entry_16de0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16de0c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16de10: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16de14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16de1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16de20; return;
}


// Function: PxfmChooseJloc__FP4JLOC
// Address: 0x16de20 - 0x16de74

void entry_16de74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16de74) {
        switch (ctx->pc) {
            case 0x16de84: ctx->pc = 0; goto label_16de84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16de74: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x16de78: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x16de7c: 0x10000022
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 720)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DF08; return;
    }
label_16de84:
    // 0x16de84: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x16de88: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16de8c: 0xc454a844
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294944836)); ctx->f[20] = *(float*)&val; }
    // 0x16de90: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x16de98);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16de98
// Address: 0x16de98 - 0x16deb8

void entry_16de98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16de98) {
        switch (ctx->pc) {
            case 0x16dea8: ctx->pc = 0; goto label_16dea8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16de98: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16de9c: 0x8e420310
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 784)));
    // 0x16dea0: 0x18400018
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 720));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x16DF04; return;
    }
label_16dea8:
    // 0x16dea8: 0x8e300000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x16deac: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16deb0: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x16deb8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_16deb8
// Address: 0x16deb8 - 0x16df30

void entry_16deb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16deb8) {
        switch (ctx->pc) {
            case 0x16def4: ctx->pc = 0; goto label_16def4;
            case 0x16df04: ctx->pc = 0; goto label_16df04;
            case 0x16df08: ctx->pc = 0; goto label_16df08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16deb8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16debc: 0xdaa20140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 21), 320)));
    // 0x16dec0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16dec4: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16dec8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16decc: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16ded0: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16ded4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16ded8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x16dedc: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16dee0: 0x0
    // NOP
    // 0x16dee4: 0x45000003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 784)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16def4;
    }
    // 0x16deec: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x16def0: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_16def4:
    // 0x16def4: 0x26940001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 1));
    // 0x16def8: 0x282102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 20), GPR_S32(ctx, 2)));
    // 0x16defc: 0x1440ffea
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DEA8; return;
    }
label_16df04:
    // 0x16df04: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_16df08:
    // 0x16df08: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x16df0c: 0x7bb50060
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16df10: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16df14: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16df18: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16df1c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16df20: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16df24: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x16df28: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitJlovol__FP6JLOVOL
// Address: 0x16df30 - 0x16df44

void entry_16df44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16df44: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16df48: 0xae0006e8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1768), GPR_U32(ctx, 0));
    // 0x16df4c: 0xae0207a8
    WRITE32(ADD32(GPR_U32(ctx, 16), 1960), GPR_U32(ctx, 2));
    // 0x16df50: 0xae0207a0
    WRITE32(ADD32(GPR_U32(ctx, 16), 1952), GPR_U32(ctx, 2));
    // 0x16df54: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16df58: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16df5c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16df64: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16df68; return;
}


// Function: BindJlovol__FP6JLOVOL
// Address: 0x16df68 - 0x16df7c

void entry_16df7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16df7c: 0x8e0607a0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1952)));
    // 0x16df80: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16df84: 0x10c20006
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x16DFA0; return;
    }
    // 0x16df8c: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x16df90: 0xc056906
    SET_GPR_U32(ctx, 31, 0x16df98);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_16df98
// Address: 0x16df98 - 0x16dfb0

void entry_16df98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16df98) {
        switch (ctx->pc) {
            case 0x16dfa0: ctx->pc = 0; goto label_16dfa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16df98: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 16), 1956), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16DFB4; return;
    }
label_16dfa0:
    // 0x16dfa0: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16dfa4: 0x2406007e
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 126));
    // 0x16dfa8: 0xc056a0e
    SET_GPR_U32(ctx, 31, 0x16dfb0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObjectByClass__FP2SWi3CIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_16dfb0
// Address: 0x16dfb0 - 0x16dfc8

void entry_16dfb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16dfb0) {
        switch (ctx->pc) {
            case 0x16dfb4: ctx->pc = 0; goto label_16dfb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16dfb0: 0xae0207a4
    WRITE32(ADD32(GPR_U32(ctx, 16), 1956), GPR_U32(ctx, 2));
label_16dfb4:
    // 0x16dfb4: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x16dfb8: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16dfbc: 0x8e0607a8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1960)));
    // 0x16dfc0: 0xc056906
    SET_GPR_U32(ctx, 31, 0x16dfc8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_16dfc8
// Address: 0x16dfc8 - 0x16dfe0

void entry_16dfc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16dfc8: 0xae0207ac
    WRITE32(ADD32(GPR_U32(ctx, 16), 1964), GPR_U32(ctx, 2));
    // 0x16dfcc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16dfd0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16dfd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16dfdc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16dfe0; return;
}


// Function: HandleJlovolMessage__FP6JLOVOL5MSGIDPv
// Address: 0x16dfe0 - 0x16dffc

void entry_16dffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16dffc) {
        switch (ctx->pc) {
            case 0x16e020: ctx->pc = 0; goto label_16e020;
            case 0x16e034: ctx->pc = 0; goto label_16e034;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16dffc: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16e000: 0x12020019
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), 13));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x16E068; return;
    }
    // 0x16e008: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16e020;
    }
    // 0x16e010: 0x12020008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_16e034;
    }
    // 0x16e018: 0x10000023
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E0A8; return;
    }
label_16e020:
    // 0x16e020: 0x2402000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    // 0x16e024: 0x12020018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x16E088; return;
    }
    // 0x16e02c: 0x1000001e
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E0A8; return;
    }
label_16e034:
    // 0x16e034: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x16e038: 0x8e0429c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 10696)));
    // 0x16e03c: 0x10800018
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1372));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_16e0a0(rdram, ctx, runtime); return;
    }
    // 0x16e044: 0xc0549b4
    SET_GPR_U32(ctx, 31, 0x16e04c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FFindDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_16e04c
// Address: 0x16e04c - 0x16e060

void entry_16e04c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e04c: 0x10400014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 10696)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_16e0a0(rdram, ctx, runtime); return;
    }
    // 0x16e054: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16e058: 0xc054980
    SET_GPR_U32(ctx, 31, 0x16e060);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1372));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_16e060
// Address: 0x16e060 - 0x16e080

void entry_16e060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e060) {
        switch (ctx->pc) {
            case 0x16e068: ctx->pc = 0; goto label_16e068;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e060: 0x10000010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E0A4; return;
    }
label_16e068:
    // 0x16e068: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16e06c: 0x8c4429c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 10696)));
    // 0x16e070: 0x1080000b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1372));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_16e0a0(rdram, ctx, runtime); return;
    }
    // 0x16e078: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x16e080);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_16e080
// Address: 0x16e080 - 0x16e0a0

void entry_16e080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e080) {
        switch (ctx->pc) {
            case 0x16e088: ctx->pc = 0; goto label_16e088;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e080: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E0A4; return;
    }
label_16e088:
    // 0x16e088: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16e08c: 0x8c4429c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 10696)));
    // 0x16e090: 0x10800003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1372));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_16e0a0(rdram, ctx, runtime); return;
    }
    // 0x16e098: 0xc054980
    SET_GPR_U32(ctx, 31, 0x16e0a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_16e0a0
// Address: 0x16e0a0 - 0x16e0b8

void entry_16e0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e0a0) {
        switch (ctx->pc) {
            case 0x16e0a4: ctx->pc = 0; goto label_16e0a4;
            case 0x16e0a8: ctx->pc = 0; goto label_16e0a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e0a0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_16e0a4:
    // 0x16e0a4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_16e0a8:
    // 0x16e0a8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16e0ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16e0b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16e0b8; return;
}


// Function: StartupJoy__Fv
// Address: 0x16e0b8 - 0x16e0c8

void entry_16e0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e0c8: 0xc08103a
    SET_GPR_U32(ctx, 31, 0x16e0d0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    scePadInit(rdram, ctx, runtime); return;
}


// Function: entry_16e0d0
// Address: 0x16e0d0 - 0x16e0e4

void entry_16e0d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e0d0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16e0d4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16e0d8: 0x24842c70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11376));
    // 0x16e0dc: 0xc05b868
    SET_GPR_U32(ctx, 31, 0x16e0e4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitJoy__FP3JOYii(rdram, ctx, runtime); return;
}


// Function: entry_16e0e4
// Address: 0x16e0e4 - 0x16e0f0

void entry_16e0e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e0e4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16e0e8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddGrfusr__Fi
// Address: 0x16e0f0 - 0x16e10c

void entry_16e10c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e10c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16e110: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RemoveGrfusr__Fi
// Address: 0x16e118 - 0x16e138

void entry_16e138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e138: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16e13c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16e144: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16e148; return;
}


// Function: UpdateGrfjoytFromGrfusr__Fv
// Address: 0x16e148 - 0x16e1a0

void entry_16e1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e1cc: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e1d0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16e1d4: 0xc05b98c
    SET_GPR_U32(ctx, 31, 0x16e1dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetJoyJoys__FP3JOY4JOYS4JOYK(rdram, ctx, runtime); return;
}


// Function: entry_16e1dc
// Address: 0x16e1dc - 0x16e1ec

void entry_16e1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e1dc: 0xae110004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    // 0x16e1e0: 0x24040140
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 320));
    // 0x16e1e4: 0xc06352c
    SET_GPR_U32(ctx, 31, 0x16e1ec);
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 18));
    PvAllocGlobalImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16e1ec
// Address: 0x16e1ec - 0x16e20c

void entry_16e1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e1ec: 0x2403ffc0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967232));
    // 0x16e1f0: 0x2442003f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 63));
    // 0x16e1f4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16e1f8: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16e1fc: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e200: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16e204: 0xc0810b2
    SET_GPR_U32(ctx, 31, 0x16e20c);
    WRITE32(ADD32(GPR_U32(ctx, 16), 12), GPR_U32(ctx, 2));
    scePadPortOpen(rdram, ctx, runtime); return;
}


// Function: entry_16e20c
// Address: 0x16e20c - 0x16e214

void entry_16e20c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e20c: 0xc06352c
    SET_GPR_U32(ctx, 31, 0x16e214);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 32));
    PvAllocGlobalImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16e214
// Address: 0x16e214 - 0x16e238

void entry_16e214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e214: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e218: 0xae0200bc
    WRITE32(ADD32(GPR_U32(ctx, 16), 188), GPR_U32(ctx, 2));
    // 0x16e21c: 0xae0300c0
    WRITE32(ADD32(GPR_U32(ctx, 16), 192), GPR_U32(ctx, 3));
    // 0x16e220: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16e224: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16e228: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16e22c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16e230: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJoy__FP3JOY
// Address: 0x16e238 - 0x16e26c

void entry_16e26c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e26c) {
        switch (ctx->pc) {
            case 0x16e284: ctx->pc = 0; goto label_16e284;
            case 0x16e28c: ctx->pc = 0; goto label_16e28c;
            case 0x16e2c4: ctx->pc = 0; goto label_16e2c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e26c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16e270: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x16e274: 0x10820003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_16e284;
    }
    // 0x16e27c: 0x54820003
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
        goto label_16e28c;
    }
label_16e284:
    // 0x16e284: 0x24110001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e288: 0x8e030014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 20)));
label_16e28c:
    // 0x16e28c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16e290: 0x1062000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_16e2c4;
    }
    // 0x16e298: 0x10a00011
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_16e2e0(rdram, ctx, runtime); return;
    }
    // 0x16e2a0: 0xc602001c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 28)); ctx->f[2] = *(float*)&val; }
    // 0x16e2a4: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x16e2a8: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x16e2ac: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16e2b0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x16e2b4: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16e2b8: 0x0
    // NOP
    // 0x16e2bc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_16e2c4;
    }
label_16e2c4:
    // 0x16e2c4: 0x10a00006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_16e2e0(rdram, ctx, runtime); return;
    }
    // 0x16e2cc: 0x14800004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        entry_16e2e0(rdram, ctx, runtime); return;
    }
    // 0x16e2d4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e2d8: 0xc05b98c
    SET_GPR_U32(ctx, 31, 0x16e2e0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetJoyJoys__FP3JOY4JOYS4JOYK(rdram, ctx, runtime); return;
}


// Function: entry_16e2e0
// Address: 0x16e2e0 - 0x16e370

void entry_16e2e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e2e0) {
        switch (ctx->pc) {
            case 0x16e310: ctx->pc = 0; goto label_16e310;
            case 0x16e324: ctx->pc = 0; goto label_16e324;
            case 0x16e344: ctx->pc = 0; goto label_16e344;
            case 0x16e35c: ctx->pc = 0; goto label_16e35c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e2e0: 0x122000cb
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        entry_16e610(rdram, ctx, runtime); return;
    }
    // 0x16e2e8: 0x8e120014
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x16e2ec: 0x1251008f
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x16E52C; return;
    }
    // 0x16e2f4: 0x2a420003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), 3));
    // 0x16e2f8: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16e310;
    }
    // 0x16e300: 0x12420008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        goto label_16e324;
    }
    // 0x16e308: 0x100000bf
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E608; return;
    }
label_16e310:
    // 0x16e310: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16e314: 0x124200aa
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x16E5C0; return;
    }
    // 0x16e31c: 0x100000ba
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E608; return;
    }
label_16e324:
    // 0x16e324: 0x12720025
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), 2));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x16E3BC; return;
    }
    // 0x16e32c: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16e344;
    }
    // 0x16e334: 0x12600009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_16e35c;
    }
    // 0x16e33c: 0x100000b2
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E608; return;
    }
label_16e344:
    // 0x16e344: 0x12710026
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 17)) {
        ctx->pc = 0x16E3E0; return;
    }
    // 0x16e34c: 0x1262006b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x16E4FC; return;
    }
    // 0x16e354: 0x100000ac
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E608; return;
    }
label_16e35c:
    // 0x16e35c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e360: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e364: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16e368: 0xc0811fe
    SET_GPR_U32(ctx, 31, 0x16e370);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    scePadInfoMode(rdram, ctx, runtime); return;
}


// Function: entry_16e370
// Address: 0x16e370 - 0x16e38c

void entry_16e370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e370: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16e374: 0x122000a2
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E600; return;
    }
    // 0x16e37c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e380: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16e384: 0xc0811fe
    SET_GPR_U32(ctx, 31, 0x16e38c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    scePadInfoMode(rdram, ctx, runtime); return;
}


// Function: entry_16e38c
// Address: 0x16e38c - 0x16e3d4

void entry_16e38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e38c) {
        switch (ctx->pc) {
            case 0x16e3ac: ctx->pc = 0; goto label_16e3ac;
            case 0x16e3bc: ctx->pc = 0; goto label_16e3bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e38c: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16e390: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x16e394: 0x28820001
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 1));
    // 0x16e398: 0x82880a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 17, GPR_U32(ctx, 4));
    // 0x16e39c: 0x12230003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 3)) {
        goto label_16e3ac;
    }
    // 0x16e3a4: 0x56220097
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        ctx->pc = 0x16E604; return;
    }
label_16e3ac:
    // 0x16e3ac: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e3b0: 0x24120003
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16e3b4: 0x10000092
    if (GPR_U32(ctx, 4) != 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E600; return;
    }
label_16e3bc:
    // 0x16e3bc: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e3c0: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e3c4: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16e3c8: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16e3cc: 0xc08124c
    SET_GPR_U32(ctx, 31, 0x16e3d4);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    scePadSetMainMode(rdram, ctx, runtime); return;
}


// Function: entry_16e3d4
// Address: 0x16e3d4 - 0x16e3f4

void entry_16e3d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e3d4) {
        switch (ctx->pc) {
            case 0x16e3e0: ctx->pc = 0; goto label_16e3e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e3d4: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x16e3d8: 0x10000089
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E600; return;
    }
label_16e3e0:
    // 0x16e3e0: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e3e4: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16e3e8: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16e3ec: 0xc0811b4
    SET_GPR_U32(ctx, 31, 0x16e3f4);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    scePadInfoAct(rdram, ctx, runtime); return;
}


// Function: entry_16e3f4
// Address: 0x16e3f4 - 0x16e414

void entry_16e3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e3f4: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16e3f8: 0x56330081
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 19)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
        ctx->pc = 0x16E600; return;
    }
    // 0x16e400: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e404: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16e408: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16e40c: 0xc0811b4
    SET_GPR_U32(ctx, 31, 0x16e414);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    scePadInfoAct(rdram, ctx, runtime); return;
}


// Function: entry_16e414
// Address: 0x16e414 - 0x16e430

void entry_16e414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e414: 0x5452007a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
        ctx->pc = 0x16E600; return;
    }
    // 0x16e41c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e420: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16e424: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16e428: 0xc0811b4
    SET_GPR_U32(ctx, 31, 0x16e430);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 2));
    scePadInfoAct(rdram, ctx, runtime); return;
}


// Function: entry_16e430
// Address: 0x16e430 - 0x16e44c

void entry_16e430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e430: 0x54530073
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 19)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
        ctx->pc = 0x16E600; return;
    }
    // 0x16e438: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e43c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16e440: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16e444: 0xc0811b4
    SET_GPR_U32(ctx, 31, 0x16e44c);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    scePadInfoAct(rdram, ctx, runtime); return;
}


// Function: entry_16e44c
// Address: 0x16e44c - 0x16e468

void entry_16e44c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e44c: 0x5440006c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
        ctx->pc = 0x16E600; return;
    }
    // 0x16e454: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e458: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e45c: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16e460: 0xc0811b4
    SET_GPR_U32(ctx, 31, 0x16e468);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    scePadInfoAct(rdram, ctx, runtime); return;
}


// Function: entry_16e468
// Address: 0x16e468 - 0x16e484

void entry_16e468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e468: 0x54520065
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
        ctx->pc = 0x16E600; return;
    }
    // 0x16e470: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e474: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e478: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16e47c: 0xc0811b4
    SET_GPR_U32(ctx, 31, 0x16e484);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 2));
    scePadInfoAct(rdram, ctx, runtime); return;
}


// Function: entry_16e484
// Address: 0x16e484 - 0x16e4a0

void entry_16e484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e484: 0x5452005e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
        ctx->pc = 0x16E600; return;
    }
    // 0x16e48c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e490: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e494: 0x8e050008
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16e498: 0xc0811b4
    SET_GPR_U32(ctx, 31, 0x16e4a0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    scePadInfoAct(rdram, ctx, runtime); return;
}


// Function: entry_16e4a0
// Address: 0x16e4a0 - 0x16e4b8

void entry_16e4a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e4a0: 0x54520057
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
        ctx->pc = 0x16E600; return;
    }
    // 0x16e4a8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16e4ac: 0x240500ff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 255));
    // 0x16e4b0: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x16e4b8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_16e4b8
// Address: 0x16e4b8 - 0x16e4ec

void entry_16e4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e4b8) {
        switch (ctx->pc) {
            case 0x16e4c0: ctx->pc = 0; goto label_16e4c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e4b8: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16e4bc: 0x3a31021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 3)));
label_16e4c0:
    // 0x16e4c0: 0xa0430000
    WRITE8(ADD32(GPR_U32(ctx, 2), 0), (uint8_t)GPR_U32(ctx, 3));
    // 0x16e4c4: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x16e4c8: 0x71102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 17)));
    // 0x16e4cc: 0x0
    // NOP
    // 0x16e4d0: 0x0
    // NOP
    // 0x16e4d4: 0x1440fffa
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 3)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_16e4c0;
    }
    // 0x16e4dc: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e4e0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16e4e4: 0xc0812aa
    SET_GPR_U32(ctx, 31, 0x16e4ec);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    scePadSetActAlign(rdram, ctx, runtime); return;
}


// Function: entry_16e4ec
// Address: 0x16e4ec - 0x16e508

void entry_16e4ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e4ec) {
        switch (ctx->pc) {
            case 0x16e4fc: ctx->pc = 0; goto label_16e4fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e4ec: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x16e4f0: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16e4f4: 0x10000042
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E600; return;
    }
label_16e4fc:
    // 0x16e4fc: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e500: 0xc08133a
    SET_GPR_U32(ctx, 31, 0x16e508);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    scePadInfoPressMode(rdram, ctx, runtime); return;
}


// Function: entry_16e508
// Address: 0x16e508 - 0x16e520

void entry_16e508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e508) {
        switch (ctx->pc) {
            case 0x16e510: ctx->pc = 0; goto label_16e510;
            case 0x16e518: ctx->pc = 0; goto label_16e518;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e508: 0x50520003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 18)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
        goto label_16e518;
    }
label_16e510:
    // 0x16e510: 0x1000003b
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E600; return;
    }
label_16e518:
    // 0x16e518: 0xc081352
    SET_GPR_U32(ctx, 31, 0x16e520);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    scePadEnterPressMode(rdram, ctx, runtime); return;
}


// Function: entry_16e520
// Address: 0x16e520 - 0x16e538

void entry_16e520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e520) {
        switch (ctx->pc) {
            case 0x16e52c: ctx->pc = 0; goto label_16e52c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e520: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
    // 0x16e524: 0x10000036
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E600; return;
    }
label_16e52c:
    // 0x16e52c: 0x8e040004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 4)));
    // 0x16e530: 0xc08119e
    SET_GPR_U32(ctx, 31, 0x16e538);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    scePadGetState_2(rdram, ctx, runtime); return;
}


// Function: entry_16e538
// Address: 0x16e538 - 0x16e5c8

void entry_16e538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e538) {
        switch (ctx->pc) {
            case 0x16e560: ctx->pc = 0; goto label_16e560;
            case 0x16e570: ctx->pc = 0; goto label_16e570;
            case 0x16e594: ctx->pc = 0; goto label_16e594;
            case 0x16e5a4: ctx->pc = 0; goto label_16e5a4;
            case 0x16e5a8: ctx->pc = 0; goto label_16e5a8;
            case 0x16e5b0: ctx->pc = 0; goto label_16e5b0;
            case 0x16e5b8: ctx->pc = 0; goto label_16e5b8;
            case 0x16e5c0: ctx->pc = 0; goto label_16e5c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e538: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16e53c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e540: 0x10640019
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_16e5a8;
    }
    // 0x16e548: 0x10400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16e560;
    }
    // 0x16e550: 0x10600007
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_16e570;
    }
    // 0x16e558: 0x1000002a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E604; return;
    }
label_16e560:
    // 0x16e560: 0x10720028
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 18)) {
        ctx->pc = 0x16E604; return;
    }
    // 0x16e568: 0x10000026
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E604; return;
    }
label_16e570:
    // 0x16e570: 0x8e030018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x16e574: 0x1072000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 18)) {
        goto label_16e5b0;
    }
    // 0x16e57c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16e594;
    }
    // 0x16e584: 0x10640007
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_16e5a4;
    }
    // 0x16e58c: 0x1000001d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E604; return;
    }
label_16e594:
    // 0x16e594: 0x10620008
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_16e5b8;
    }
    // 0x16e59c: 0x10000019
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E604; return;
    }
label_16e5a4:
    // 0x16e5a4: 0x24130002
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 2));
label_16e5a8:
    // 0x16e5a8: 0x10000015
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E600; return;
    }
label_16e5b0:
    // 0x16e5b0: 0x1000fffd
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16e5a8;
    }
label_16e5b8:
    // 0x16e5b8: 0x1000ffd5
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E510; return;
    }
label_16e5c0:
    // 0x16e5c0: 0xc05ba50
    SET_GPR_U32(ctx, 31, 0x16e5c8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FReadJoy__FP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_16e5c8
// Address: 0x16e5c8 - 0x16e5f4

void entry_16e5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e5c8: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
        ctx->pc = 0x16E5FC; return;
    }
    // 0x16e5d0: 0x8e0200c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 192)));
    // 0x16e5d4: 0x1040000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E604; return;
    }
    // 0x16e5dc: 0x8e020018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x16e5e0: 0x28420003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 3));
    // 0x16e5e4: 0x14400008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16E608; return;
    }
    // 0x16e5ec: 0xc069ee2
    SET_GPR_U32(ctx, 31, 0x16e5f4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 188)));
    UpdateRumble__FP6RUMBLE(rdram, ctx, runtime); return;
}


// Function: entry_16e5f4
// Address: 0x16e5f4 - 0x16e610

void entry_16e5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e5f4) {
        switch (ctx->pc) {
            case 0x16e5fc: ctx->pc = 0; goto label_16e5fc;
            case 0x16e600: ctx->pc = 0; goto label_16e600;
            case 0x16e604: ctx->pc = 0; goto label_16e604;
            case 0x16e608: ctx->pc = 0; goto label_16e608;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e5f4: 0x10000003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16e604;
    }
label_16e5fc:
    // 0x16e5fc: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_16e600:
    // 0x16e600: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_16e604:
    // 0x16e604: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_16e608:
    // 0x16e608: 0xc05b98c
    SET_GPR_U32(ctx, 31, 0x16e610);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetJoyJoys__FP3JOY4JOYS4JOYK(rdram, ctx, runtime); return;
}


// Function: entry_16e610
// Address: 0x16e610 - 0x16e630

void entry_16e610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e610: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16e614: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16e618: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16e61c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16e620: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16e624: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16e62c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16e630; return;
}


// Function: SetJoyJoys__FP3JOY4JOYS4JOYK
// Address: 0x16e630 - 0x16e69c

void entry_16e69c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e69c) {
        switch (ctx->pc) {
            case 0x16e6a0: ctx->pc = 0; goto label_16e6a0;
            case 0x16e6e0: ctx->pc = 0; goto label_16e6e0;
            case 0x16e70c: ctx->pc = 0; goto label_16e70c;
            case 0x16e724: ctx->pc = 0; goto label_16e724;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e69c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
label_16e6a0:
    // 0x16e6a0: 0x1622001a
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 2)) {
        goto label_16e70c;
    }
    // 0x16e6a8: 0xae000020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 0));
    // 0x16e6ac: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16e6b0: 0xae000084
    WRITE32(ADD32(GPR_U32(ctx, 16), 132), GPR_U32(ctx, 0));
    // 0x16e6b4: 0x26060058
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 88));
    // 0x16e6b8: 0xae000050
    WRITE32(ADD32(GPR_U32(ctx, 16), 80), GPR_U32(ctx, 0));
    // 0x16e6bc: 0x2605008c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 140));
    // 0x16e6c0: 0xa60000a8
    WRITE16(ADD32(GPR_U32(ctx, 16), 168), (uint16_t)GPR_U32(ctx, 0));
    // 0x16e6c4: 0x26040054
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 84));
    // 0x16e6c8: 0x3c01bf40
    SET_GPR_U32(ctx, 1, ((uint32_t)48960 << 16));
    // 0x16e6cc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16e6d0: 0x26030088
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 136));
    // 0x16e6d4: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x16e6d8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16e6dc: 0x0
    // NOP
label_16e6e0:
    // 0x16e6e0: 0xe4610000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 3), 0), *(uint32_t*)&val); }
    // 0x16e6e4: 0x24e70001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 1));
    // 0x16e6e8: 0xe4810000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x16e6ec: 0x24630008
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 8));
    // 0x16e6f0: 0xe4a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 5), 0), *(uint32_t*)&val); }
    // 0x16e6f4: 0x24840008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
    // 0x16e6f8: 0xe4c00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 6), 0), *(uint32_t*)&val); }
    // 0x16e6fc: 0x24a50008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 8));
    // 0x16e700: 0x2ce20004
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 7), 4));
    // 0x16e704: 0x1440fff6
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_16e6e0;
    }
label_16e70c:
    // 0x16e70c: 0xae110014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 17));
    // 0x16e710: 0x25021858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 8), 6232));
    // 0x16e714: 0xae120018
    WRITE32(ADD32(GPR_U32(ctx, 16), 24), GPR_U32(ctx, 18));
    // 0x16e718: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x16e71c: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x16e720: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_16e724:
    // 0x16e724: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16e728: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16e72c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16e730: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM
// Address: 0x16e738 - 0x16e940

void entry_16e96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e96c: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16e970: 0x8e240004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4)));
    // 0x16e974: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16e978: 0xc081144
    SET_GPR_U32(ctx, 31, 0x16e980);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    scePadRead(rdram, ctx, runtime); return;
}


// Function: entry_16e980
// Address: 0x16e980 - 0x16e9d4

void entry_16e980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16e980) {
        switch (ctx->pc) {
            case 0x16e9b0: ctx->pc = 0; goto label_16e9b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16e980: 0x18400095
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 18)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x16EBD8; return;
    }
    // 0x16e988: 0x93a30013
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 19)));
    // 0x16e98c: 0x21200
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 8));
    // 0x16e990: 0x963000a8
    SET_GPR_U32(ctx, 16, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 168)));
    // 0x16e994: 0x431027
    SET_GPR_U32(ctx, 2, NOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16e998: 0x8e230010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x16e99c: 0x10600004
    WRITE16(ADD32(GPR_U32(ctx, 17), 168), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_16e9b0;
    }
    // 0x16e9a4: 0x93a20011
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 17)));
    // 0x16e9a8: 0x621026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x16e9ac: 0x2900b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 0));
label_16e9b0:
    // 0x16e9b0: 0x93a20011
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 17)));
    // 0x16e9b4: 0x24040004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    // 0x16e9b8: 0x8e230018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x16e9bc: 0x14640005
    WRITE32(ADD32(GPR_U32(ctx, 17), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        entry_16e9d4(rdram, ctx, runtime); return;
    }
    // 0x16e9c4: 0x262400ae
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 174));
    // 0x16e9c8: 0x27a50018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 24));
    // 0x16e9cc: 0xc063600
    SET_GPR_U32(ctx, 31, 0x16e9d4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 12));
    CopyAb__FPvT0Ui(rdram, ctx, runtime); return;
}


// Function: entry_16e9d4
// Address: 0x16e9d4 - 0x16ea30

void entry_16e9d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16e9d4: 0x962300a8
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 168)));
    // 0x16e9d8: 0x102827
    SET_GPR_U32(ctx, 5, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 16)));
    // 0x16e9dc: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x16e9e0: 0x31027
    SET_GPR_U32(ctx, 2, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x16e9e4: 0x651824
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), GPR_U32(ctx, 5)));
    // 0x16e9e8: 0x2021024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x16e9ec: 0xa62300aa
    WRITE16(ADD32(GPR_U32(ctx, 17), 170), (uint16_t)GPR_U32(ctx, 3));
    // 0x16e9f0: 0x28840002
    SET_GPR_U32(ctx, 4, SLT32(GPR_S32(ctx, 4), 2));
    // 0x16e9f4: 0x1480001d
    WRITE16(ADD32(GPR_U32(ctx, 17), 172), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16EA6C; return;
    }
    // 0x16e9fc: 0x26220050
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 80));
    // 0x16ea00: 0x26230054
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 84));
    // 0x16ea04: 0x93a50016
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 22)));
    // 0x16ea08: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16ea0c: 0x93a60017
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 23)));
    // 0x16ea10: 0x26270040
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 64));
    // 0x16ea14: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x16ea18: 0x26280044
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 68));
    // 0x16ea1c: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x16ea20: 0x26290048
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 72));
    // 0x16ea24: 0x262a004c
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 17), 76));
    // 0x16ea28: 0xc05b9ce
    SET_GPR_U32(ctx, 31, 0x16ea30);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 17), 77));
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime); return;
}


// Function: entry_16ea30
// Address: 0x16ea30 - 0x16ea64

void entry_16ea30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ea30: 0x26220084
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 132));
    // 0x16ea34: 0x26230088
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 136));
    // 0x16ea38: 0x93a50014
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x16ea3c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x16ea40: 0x93a60015
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 21)));
    // 0x16ea44: 0x26270074
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 116));
    // 0x16ea48: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x16ea4c: 0x26280078
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 120));
    // 0x16ea50: 0xafa30008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 3));
    // 0x16ea54: 0x2629007c
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 124));
    // 0x16ea58: 0x262a0080
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 17), 128));
    // 0x16ea5c: 0xc05b9ce
    SET_GPR_U32(ctx, 31, 0x16ea64);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 17), 129));
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime); return;
}


// Function: entry_16ea64
// Address: 0x16ea64 - 0x16eb80

void entry_16ea64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ea64) {
        switch (ctx->pc) {
            case 0x16ea6c: ctx->pc = 0; goto label_16ea6c;
            case 0x16ea8c: ctx->pc = 0; goto label_16ea8c;
            case 0x16eab0: ctx->pc = 0; goto label_16eab0;
            case 0x16eab4: ctx->pc = 0; goto label_16eab4;
            case 0x16eae4: ctx->pc = 0; goto label_16eae4;
            case 0x16eafc: ctx->pc = 0; goto label_16eafc;
            case 0x16eb00: ctx->pc = 0; goto label_16eb00;
            case 0x16eb1c: ctx->pc = 0; goto label_16eb1c;
            case 0x16eb30: ctx->pc = 0; goto label_16eb30;
            case 0x16eb34: ctx->pc = 0; goto label_16eb34;
            case 0x16eb68: ctx->pc = 0; goto label_16eb68;
            case 0x16eb74: ctx->pc = 0; goto label_16eb74;
            case 0x16eb78: ctx->pc = 0; goto label_16eb78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ea64: 0x10000009
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16ea8c;
    }
label_16ea6c:
    // 0x16ea6c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x16ea70: 0xe6200074
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 116), *(uint32_t*)&val); }
    // 0x16ea74: 0xe6200048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 72), *(uint32_t*)&val); }
    // 0x16ea78: 0xe6200044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 68), *(uint32_t*)&val); }
    // 0x16ea7c: 0xe6200040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
    // 0x16ea80: 0xe620007c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 124), *(uint32_t*)&val); }
    // 0x16ea84: 0xe6200078
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 120), *(uint32_t*)&val); }
    // 0x16ea88: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_16ea8c:
    // 0x16ea8c: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x16ea90: 0x50800008
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 168)));
        goto label_16eab4;
    }
    // 0x16ea98: 0x8c8203d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 976)));
    // 0x16ea9c: 0x10400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 1108));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16eab0;
    }
    // 0x16eaa4: 0x8c8303d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 984)));
    // 0x16eaa8: 0x50620033
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        goto label_16eb78;
    }
label_16eab0:
    // 0x16eab0: 0x962300a8
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 168)));
label_16eab4:
    // 0x16eab4: 0x3062f000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 61440));
    // 0x16eab8: 0x1040002e
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 32768));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16eb74;
    }
    // 0x16eac0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x16eac4: 0xe6200040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
    // 0x16eac8: 0xe6200048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 72), *(uint32_t*)&val); }
    // 0x16eacc: 0x10400005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 68), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16eae4;
    }
    // 0x16ead4: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x16ead8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16eadc: 0x10000007
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16eafc;
    }
label_16eae4:
    // 0x16eae4: 0x30622000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 8192));
    // 0x16eae8: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 168)));
        goto label_16eb00;
    }
    // 0x16eaf0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16eaf4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16eaf8: 0xe6200040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
label_16eafc:
    // 0x16eafc: 0x962300a8
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 168)));
label_16eb00:
    // 0x16eb00: 0x30621000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 4096));
    // 0x16eb04: 0x10400005
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 16384));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16eb1c;
    }
    // 0x16eb0c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16eb10: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16eb14: 0x10000006
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 68), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16eb30;
    }
label_16eb1c:
    // 0x16eb1c: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 64)); ctx->f[3] = *(float*)&val; }
        goto label_16eb34;
    }
    // 0x16eb24: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x16eb28: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16eb2c: 0xe6200044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 68), *(uint32_t*)&val); }
label_16eb30:
    // 0x16eb30: 0xc6230040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 64)); ctx->f[3] = *(float*)&val; }
label_16eb34:
    // 0x16eb34: 0xc6220044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 68)); ctx->f[2] = *(float*)&val; }
    // 0x16eb38: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x16eb3c: 0x46021802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[2]);
    // 0x16eb40: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16eb44: 0x45010008
    if ((ctx->fcr31 & 0x800000)) {
        goto label_16eb68;
    }
    // 0x16eb4c: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x16eb50: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x16eb54: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16eb58: 0x46001042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x16eb5c: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x16eb60: 0xe6210044
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 68), *(uint32_t*)&val); }
    // 0x16eb64: 0xe6200040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 64), *(uint32_t*)&val); }
label_16eb68:
    // 0x16eb68: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16eb6c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16eb70: 0xe6200048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 72), *(uint32_t*)&val); }
label_16eb74:
    // 0x16eb74: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_16eb78:
    // 0x16eb78: 0xc05bc8e
    SET_GPR_U32(ctx, 31, 0x16eb80);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn__MatchCodes__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_16eb80
// Address: 0x16eb80 - 0x16ec20

void entry_16eb80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16eb80) {
        switch (ctx->pc) {
            case 0x16ebc8: ctx->pc = 0; goto label_16ebc8;
            case 0x16ebcc: ctx->pc = 0; goto label_16ebcc;
            case 0x16ebd8: ctx->pc = 0; goto label_16ebd8;
            case 0x16ec00: ctx->pc = 0; goto label_16ec00;
            case 0x16ec04: ctx->pc = 0; goto label_16ec04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16eb80: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16eb84: 0x962300a8
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 17), 168)));
    // 0x16eb88: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16eb8c: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x16eb90: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x16eb94: 0x1460000c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 32), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_16ebc8;
    }
    // 0x16eb9c: 0xc6200048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 72)); ctx->f[0] = *(float*)&val; }
    // 0x16eba0: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x16eba4: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16eba8: 0x0
    // NOP
    // 0x16ebac: 0x45000007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 6232));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16ebcc;
    }
    // 0x16ebb4: 0xc620007c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 124)); ctx->f[0] = *(float*)&val; }
    // 0x16ebb8: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ebbc: 0x0
    // NOP
    // 0x16ebc0: 0x45010010
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_16ec04;
    }
label_16ebc8:
    // 0x16ebc8: 0x24821858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 6232));
label_16ebcc:
    // 0x16ebcc: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x16ebd0: 0x1000000b
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 36), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16ec00;
    }
label_16ebd8:
    // 0x16ebd8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16ebdc: 0xc6220020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 32)); ctx->f[2] = *(float*)&val; }
    // 0x16ebe0: 0xc4401868
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    // 0x16ebe4: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x16ebe8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16ebec: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x16ebf0: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ebf4: 0x0
    // NOP
    // 0x16ebf8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_16ec00;
    }
label_16ec00:
    // 0x16ec00: 0x240102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_16ec04:
    // 0x16ec04: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x16ec08: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x16ec0c: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16ec10: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16ec14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16ec1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16ec20; return;
}


// Function: SetJoyBtnHandled__FP3JOYUs
// Address: 0x16ec20 - 0x16ec38

void entry_16ec70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ec70) {
        switch (ctx->pc) {
            case 0x16ec74: ctx->pc = 0; goto label_16ec74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ec70: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_16ec74:
    // 0x16ec74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16ec7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16ec80; return;
}


// Function: junk_0016EC80
// Address: 0x16ec80 - 0x16ec88

void entry_16eccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16eccc) {
        switch (ctx->pc) {
            case 0x16ecd4: ctx->pc = 0; goto label_16ecd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16eccc: 0x1000001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16ED44; return;
    }
label_16ecd4:
    // 0x16ecd4: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16ECEC; return;
    }
    // 0x16ecdc: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x16ece4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8192));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_16ece4
// Address: 0x16ece4 - 0x16eed0

void entry_16ece4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ece4) {
        switch (ctx->pc) {
            case 0x16ecec: ctx->pc = 0; goto label_16ecec;
            case 0x16ed44: ctx->pc = 0; goto label_16ed44;
            case 0x16ed4c: ctx->pc = 0; goto label_16ed4c;
            case 0x16ed6c: ctx->pc = 0; goto label_16ed6c;
            case 0x16edc8: ctx->pc = 0; goto label_16edc8;
            case 0x16ee18: ctx->pc = 0; goto label_16ee18;
            case 0x16ee20: ctx->pc = 0; goto label_16ee20;
            case 0x16ee30: ctx->pc = 0; goto label_16ee30;
            case 0x16eea4: ctx->pc = 0; goto label_16eea4;
            case 0x16eeb0: ctx->pc = 0; goto label_16eeb0;
            case 0x16eeb8: ctx->pc = 0; goto label_16eeb8;
            case 0x16eebc: ctx->pc = 0; goto label_16eebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ece4: 0x10000017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16ed44;
    }
label_16ecec:
    // 0x16ecec: 0xc6010048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[1] = *(float*)&val; }
    // 0x16ecf0: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x16ecf4: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x16ecf8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16ecfc: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ed00: 0x0
    // NOP
    // 0x16ed04: 0x45020011
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
        goto label_16ed4c;
    }
    // 0x16ed0c: 0xc6020040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[2] = *(float*)&val; }
    // 0x16ed10: 0xc6000044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[0] = *(float*)&val; }
    // 0x16ed14: 0x46001045
    ctx->f[1] = FPU_ABS_S(ctx->f[2]);
    // 0x16ed18: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x16ed1c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ed20: 0x0
    // NOP
    // 0x16ed24: 0x45020009
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
        goto label_16ed4c;
    }
    // 0x16ed2c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x16ed30: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ed34: 0x0
    // NOP
    // 0x16ed38: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_16ed44;
    }
    // 0x16ed40: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_16ed44:
    // 0x16ed44: 0xae020028
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 2));
    // 0x16ed48: 0x8e020028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
label_16ed4c:
    // 0x16ed4c: 0x1040005a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16eeb8;
    }
    // 0x16ed54: 0x3c013eaa
    SET_GPR_U32(ctx, 1, ((uint32_t)16042 << 16));
    // 0x16ed58: 0x3421a64c
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 42572));
    // 0x16ed5c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16ed60: 0xe6010034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x16ed64: 0x10000052
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16eeb0;
    }
label_16ed6c:
    // 0x16ed6c: 0x4410016
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_16edc8;
    }
    // 0x16ed74: 0x960200a8
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 168)));
    // 0x16ed78: 0x30428000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32768));
    // 0x16ed7c: 0x54400028
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_16ee20;
    }
    // 0x16ed84: 0xc6010048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[1] = *(float*)&val; }
    // 0x16ed88: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x16ed8c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16ed90: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ed94: 0x45000022
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16ee20;
    }
    // 0x16ed9c: 0xc6020040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[2] = *(float*)&val; }
    // 0x16eda0: 0xc6000044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[0] = *(float*)&val; }
    // 0x16eda4: 0x46001045
    ctx->f[1] = FPU_ABS_S(ctx->f[2]);
    // 0x16eda8: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x16edac: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16edb0: 0x4500001b
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16ee20;
    }
    // 0x16edb8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x16edbc: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16edc0: 0x10000015
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16ee18;
    }
label_16edc8:
    // 0x16edc8: 0x960200a8
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 168)));
    // 0x16edcc: 0x30422000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 8192));
    // 0x16edd0: 0x54400013
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_16ee20;
    }
    // 0x16edd8: 0xc6010048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[1] = *(float*)&val; }
    // 0x16eddc: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x16ede0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16ede4: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ede8: 0x4500000d
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16ee20;
    }
    // 0x16edf0: 0xc6020040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[2] = *(float*)&val; }
    // 0x16edf4: 0xc6000044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[0] = *(float*)&val; }
    // 0x16edf8: 0x46001045
    ctx->f[1] = FPU_ABS_S(ctx->f[2]);
    // 0x16edfc: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x16ee00: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ee04: 0x45000006
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16ee20;
    }
    // 0x16ee0c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x16ee10: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ee14: 0x0
    // NOP
label_16ee18:
    // 0x16ee18: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_16ee20;
    }
label_16ee20:
    // 0x16ee20: 0x14600003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_16ee30;
    }
    // 0x16ee28: 0x10000023
    WRITE32(ADD32(GPR_U32(ctx, 16), 40), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16eeb8;
    }
label_16ee30:
    // 0x16ee30: 0xc6010030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 48)); ctx->f[1] = *(float*)&val; }
    // 0x16ee34: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16ee38: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x16ee3c: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x16ee40: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ee44: 0x0
    // NOP
    // 0x16ee48: 0x4500001c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16eebc;
    }
    // 0x16ee50: 0xc6000034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 52)); ctx->f[0] = *(float*)&val; }
    // 0x16ee54: 0x3c013eaa
    SET_GPR_U32(ctx, 1, ((uint32_t)16042 << 16));
    // 0x16ee58: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x16ee5c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16ee60: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x16ee64: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x16ee68: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x16ee6c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x16ee70: 0x3c013eaa
    SET_GPR_U32(ctx, 1, ((uint32_t)16042 << 16));
    // 0x16ee74: 0x3421a64c
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 42572));
    // 0x16ee78: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x16ee7c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x16ee80: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ee84: 0x0
    // NOP
    // 0x16ee88: 0x45010006
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_16eea4;
    }
    // 0x16ee90: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ee94: 0x0
    // NOP
    // 0x16ee98: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16eea4;
    }
    // 0x16eea0: 0x46001846
    ctx->f[1] = FPU_MOV_S(ctx->f[3]);
label_16eea4:
    // 0x16eea4: 0xe6010034
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 52), *(uint32_t*)&val); }
    // 0x16eea8: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x16eeac: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
label_16eeb0:
    // 0x16eeb0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x16eeb4: 0xe6000030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 48), *(uint32_t*)&val); }
label_16eeb8:
    // 0x16eeb8: 0x8e020028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 40)));
label_16eebc:
    // 0x16eebc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16eec0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16eec4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16eecc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16eed0; return;
}


// Function: DySelectionJoy__FP3JOY
// Address: 0x16eed0 - 0x16ef04

void entry_16ef04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ef04) {
        switch (ctx->pc) {
            case 0x16ef0c: ctx->pc = 0; goto label_16ef0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ef04: 0x1000001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16EF7C; return;
    }
label_16ef0c:
    // 0x16ef0c: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x16EF24; return;
    }
    // 0x16ef14: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x16ef1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 16384));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_16ef1c
// Address: 0x16ef1c - 0x16f108

void entry_16ef1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ef1c) {
        switch (ctx->pc) {
            case 0x16ef24: ctx->pc = 0; goto label_16ef24;
            case 0x16ef7c: ctx->pc = 0; goto label_16ef7c;
            case 0x16ef84: ctx->pc = 0; goto label_16ef84;
            case 0x16efa4: ctx->pc = 0; goto label_16efa4;
            case 0x16f000: ctx->pc = 0; goto label_16f000;
            case 0x16f050: ctx->pc = 0; goto label_16f050;
            case 0x16f058: ctx->pc = 0; goto label_16f058;
            case 0x16f068: ctx->pc = 0; goto label_16f068;
            case 0x16f0dc: ctx->pc = 0; goto label_16f0dc;
            case 0x16f0e8: ctx->pc = 0; goto label_16f0e8;
            case 0x16f0f0: ctx->pc = 0; goto label_16f0f0;
            case 0x16f0f4: ctx->pc = 0; goto label_16f0f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ef1c: 0x10000017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16ef7c;
    }
label_16ef24:
    // 0x16ef24: 0xc6010048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[1] = *(float*)&val; }
    // 0x16ef28: 0x3c013f4c
    SET_GPR_U32(ctx, 1, ((uint32_t)16204 << 16));
    // 0x16ef2c: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x16ef30: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16ef34: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ef38: 0x0
    // NOP
    // 0x16ef3c: 0x45020011
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 44)));
        goto label_16ef84;
    }
    // 0x16ef44: 0xc6020044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[2] = *(float*)&val; }
    // 0x16ef48: 0xc6000040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[0] = *(float*)&val; }
    // 0x16ef4c: 0x46001045
    ctx->f[1] = FPU_ABS_S(ctx->f[2]);
    // 0x16ef50: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x16ef54: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ef58: 0x0
    // NOP
    // 0x16ef5c: 0x45020009
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 44)));
        goto label_16ef84;
    }
    // 0x16ef64: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x16ef68: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16ef6c: 0x0
    // NOP
    // 0x16ef70: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_16ef7c;
    }
    // 0x16ef78: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_16ef7c:
    // 0x16ef7c: 0xae02002c
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 2));
    // 0x16ef80: 0x8e02002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 44)));
label_16ef84:
    // 0x16ef84: 0x1040005a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16f0f0;
    }
    // 0x16ef8c: 0x3c013eaa
    SET_GPR_U32(ctx, 1, ((uint32_t)16042 << 16));
    // 0x16ef90: 0x3421a64c
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 42572));
    // 0x16ef94: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16ef98: 0xe601003c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 60), *(uint32_t*)&val); }
    // 0x16ef9c: 0x10000052
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6248)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16f0e8;
    }
label_16efa4:
    // 0x16efa4: 0x4410016
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) >= 0) {
        goto label_16f000;
    }
    // 0x16efac: 0x960200a8
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 168)));
    // 0x16efb0: 0x30421000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4096));
    // 0x16efb4: 0x54400028
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_16f058;
    }
    // 0x16efbc: 0xc6010048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[1] = *(float*)&val; }
    // 0x16efc0: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x16efc4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16efc8: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16efcc: 0x45000022
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16f058;
    }
    // 0x16efd4: 0xc6020044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[2] = *(float*)&val; }
    // 0x16efd8: 0xc6000040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[0] = *(float*)&val; }
    // 0x16efdc: 0x46001045
    ctx->f[1] = FPU_ABS_S(ctx->f[2]);
    // 0x16efe0: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x16efe4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16efe8: 0x4500001b
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16f058;
    }
    // 0x16eff0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x16eff4: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16eff8: 0x10000015
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16f050;
    }
label_16f000:
    // 0x16f000: 0x960200a8
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 168)));
    // 0x16f004: 0x30424000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16384));
    // 0x16f008: 0x54400013
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_16f058;
    }
    // 0x16f010: 0xc6010048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 72)); ctx->f[1] = *(float*)&val; }
    // 0x16f014: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x16f018: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16f01c: 0x46010036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16f020: 0x4500000d
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16f058;
    }
    // 0x16f028: 0xc6020044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 68)); ctx->f[2] = *(float*)&val; }
    // 0x16f02c: 0xc6000040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 64)); ctx->f[0] = *(float*)&val; }
    // 0x16f030: 0x46001045
    ctx->f[1] = FPU_ABS_S(ctx->f[2]);
    // 0x16f034: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x16f038: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16f03c: 0x45000006
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16f058;
    }
    // 0x16f044: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x16f048: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16f04c: 0x0
    // NOP
label_16f050:
    // 0x16f050: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
        goto label_16f058;
    }
label_16f058:
    // 0x16f058: 0x14600003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_16f068;
    }
    // 0x16f060: 0x10000023
    WRITE32(ADD32(GPR_U32(ctx, 16), 44), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_16f0f0;
    }
label_16f068:
    // 0x16f068: 0xc6010038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 56)); ctx->f[1] = *(float*)&val; }
    // 0x16f06c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16f070: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x16f074: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
    // 0x16f078: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16f07c: 0x0
    // NOP
    // 0x16f080: 0x4500001c
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16f0f4;
    }
    // 0x16f088: 0xc600003c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 60)); ctx->f[0] = *(float*)&val; }
    // 0x16f08c: 0x3c013eaa
    SET_GPR_U32(ctx, 1, ((uint32_t)16042 << 16));
    // 0x16f090: 0x3421aaab
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 43691));
    // 0x16f094: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16f098: 0x46000000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[0]);
    // 0x16f09c: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x16f0a0: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x16f0a4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x16f0a8: 0x3c013eaa
    SET_GPR_U32(ctx, 1, ((uint32_t)16042 << 16));
    // 0x16f0ac: 0x3421a64c
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 42572));
    // 0x16f0b0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x16f0b4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x16f0b8: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16f0bc: 0x0
    // NOP
    // 0x16f0c0: 0x45010006
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_16f0dc;
    }
    // 0x16f0c8: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x16f0cc: 0x0
    // NOP
    // 0x16f0d0: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_16f0dc;
    }
    // 0x16f0d8: 0x46001846
    ctx->f[1] = FPU_MOV_S(ctx->f[3]);
label_16f0dc:
    // 0x16f0dc: 0xe601003c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 60), *(uint32_t*)&val); }
    // 0x16f0e0: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x16f0e4: 0xc4400010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16)); ctx->f[0] = *(float*)&val; }
label_16f0e8:
    // 0x16f0e8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x16f0ec: 0xe6000038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 56), *(uint32_t*)&val); }
label_16f0f0:
    // 0x16f0f0: 0x8e02002c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 44)));
label_16f0f4:
    // 0x16f0f4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16f0f8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16f0fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16f104: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16f108; return;
}


// Function: UBtnpJoy__FP3JOY4BTNP
// Address: 0x16f108 - 0x16f188

void entry_16f3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f3d8: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x16f3dc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16f3e4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16f3e4
// Address: 0x16f3e4 - 0x16f3ec

void entry_16f3e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f3e4: 0xc05bc7e
    SET_GPR_U32(ctx, 31, 0x16f3ec);
    fn__ResetCodes__Fv(rdram, ctx, runtime); return;
}


// Function: entry_16f3ec
// Address: 0x16f3ec - 0x16f408

void entry_16f3ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16f3ec) {
        switch (ctx->pc) {
            case 0x16f3f0: ctx->pc = 0; goto label_16f3f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16f3ec: 0xae202e00
    WRITE32(ADD32(GPR_U32(ctx, 17), 11776), GPR_U32(ctx, 0));
label_16f3f0:
    // 0x16f3f0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16f3f4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16f3f8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16f3fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16f404: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16f408; return;
}


// Function: ClearFchts__Fv
// Address: 0x16f408 - 0x16f420

void entry_16f420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f420: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16f424: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16f42c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16f430; return;
}


// Function: AddFcht__Fi
// Address: 0x16f430 - 0x16f460

void entry_16f460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f460: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16f464: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16f46c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16f470; return;
}


// Function: junk_0016F470
// Address: 0x16f470 - 0x16f478

void entry_16f4b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f4b4: 0x30420006
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 6));
    // 0x16f4b8: 0x24030006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    // 0x16f4bc: 0x1443002e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x16F578; return;
    }
    // 0x16f4c4: 0x8e0423c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9152)));
    // 0x16f4c8: 0x24030063
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 99));
    // 0x16f4cc: 0x8c8219e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6632)));
    // 0x16f4d0: 0x1443002a
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x16F57C; return;
    }
    // 0x16f4d8: 0x8c8219e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 6624)));
    // 0x16f4dc: 0x14400028
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x16F580; return;
    }
    // 0x16f4e4: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x16f4e8: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x16f4ec: 0x24a583b8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294935480));
    // 0x16f4f0: 0xc07884e
    SET_GPR_U32(ctx, 31, 0x16f4f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    strcpy(rdram, ctx, runtime); return;
}


// Function: entry_16f4f8
// Address: 0x16f4f8 - 0x16f540

void entry_16f4f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16f4f8) {
        switch (ctx->pc) {
            case 0x16f510: ctx->pc = 0; goto label_16f510;
            case 0x16f52c: ctx->pc = 0; goto label_16f52c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16f4f8: 0x3c110027
    SET_GPR_U32(ctx, 17, ((uint32_t)39 << 16));
    // 0x16f4fc: 0x83a20040
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16f500: 0x1040000a
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_16f52c;
    }
    // 0x16f508: 0x92020000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x16f50c: 0x0
    // NOP
label_16f510:
    // 0x16f510: 0x38420023
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 35));
    // 0x16f514: 0xa2020000
    WRITE8(ADD32(GPR_U32(ctx, 16), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x16f518: 0x26100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    // 0x16f51c: 0x82020000
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x16f520: 0x0
    // NOP
    // 0x16f524: 0x5440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_16f510;
    }
label_16f52c:
    // 0x16f52c: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x16f530: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16f534: 0x24a5a848
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294944840));
    // 0x16f538: 0xc0787f4
    SET_GPR_U32(ctx, 31, 0x16f540);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4294962288));
    sprintf(rdram, ctx, runtime); return;
}


// Function: entry_16f540
// Address: 0x16f540 - 0x16f554

void entry_16f540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f540: 0x8e23ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294962288)));
    // 0x16f544: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16f548: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x16f54c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16f554);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16f554
// Address: 0x16f554 - 0x16f564

void entry_16f554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f554: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x16f558: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x16f55c: 0xc06aa2e
    SET_GPR_U32(ctx, 31, 0x16f564);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetBlotDtVisible__FP4BLOTf(rdram, ctx, runtime); return;
}


// Function: entry_16f564
// Address: 0x16f564 - 0x16f574

void entry_16f564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f564: 0x8e23ec70
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 4294962288)));
    // 0x16f568: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x16f56c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16f574);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16f574
// Address: 0x16f574 - 0x16f588

void entry_16f574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16f574) {
        switch (ctx->pc) {
            case 0x16f578: ctx->pc = 0; goto label_16f578;
            case 0x16f57c: ctx->pc = 0; goto label_16f57c;
            case 0x16f580: ctx->pc = 0; goto label_16f580;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16f574: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_16f578:
    // 0x16f578: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_16f57c:
    // 0x16f57c: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_16f580:
    // 0x16f580: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: StartupCodes__Fv
// Address: 0x16f588 - 0x16f59c

void entry_16f59c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f59c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16f5a0: 0xc05bc62
    SET_GPR_U32(ctx, 31, 0x16f5a8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 10936));
    AddCode__FP4CODE(rdram, ctx, runtime); return;
}


// Function: entry_16f5a8
// Address: 0x16f5a8 - 0x16f5b4

void entry_16f5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f5a8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16f5ac: 0xc05bc62
    SET_GPR_U32(ctx, 31, 0x16f5b4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 10992));
    AddCode__FP4CODE(rdram, ctx, runtime); return;
}


// Function: entry_16f5b4
// Address: 0x16f5b4 - 0x16f5c0

void entry_16f5b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f5b4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16f5b8: 0xc05bc62
    SET_GPR_U32(ctx, 31, 0x16f5c0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11048));
    AddCode__FP4CODE(rdram, ctx, runtime); return;
}


// Function: entry_16f5c0
// Address: 0x16f5c0 - 0x16f5cc

void entry_16f5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f5c0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16f5c4: 0xc05bc62
    SET_GPR_U32(ctx, 31, 0x16f5cc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11104));
    AddCode__FP4CODE(rdram, ctx, runtime); return;
}


// Function: entry_16f5cc
// Address: 0x16f5cc - 0x16f5d8

void entry_16f5cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f5cc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16f5d0: 0xc05bc62
    SET_GPR_U32(ctx, 31, 0x16f5d8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11160));
    AddCode__FP4CODE(rdram, ctx, runtime); return;
}


// Function: entry_16f5d8
// Address: 0x16f5d8 - 0x16f5e4

void entry_16f5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f5d8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16f5dc: 0xc05bc62
    SET_GPR_U32(ctx, 31, 0x16f5e4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11216));
    AddCode__FP4CODE(rdram, ctx, runtime); return;
}


// Function: entry_16f5e4
// Address: 0x16f5e4 - 0x16f5f0

void entry_16f5e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f5e4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16f5e8: 0xc05bc62
    SET_GPR_U32(ctx, 31, 0x16f5f0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11272));
    AddCode__FP4CODE(rdram, ctx, runtime); return;
}


// Function: entry_16f5f0
// Address: 0x16f5f0 - 0x16f5fc

void entry_16f5f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f5f0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16f5f4: 0xc05bc62
    SET_GPR_U32(ctx, 31, 0x16f5fc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 11336));
    AddCode__FP4CODE(rdram, ctx, runtime); return;
}


// Function: entry_16f5fc
// Address: 0x16f5fc - 0x16f608

void entry_16f5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f5fc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16f600: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: InitJt__FP2JT
// Address: 0x16f608 - 0x16f61c

void entry_16f61c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f61c: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16f620: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16f624: 0xae052220
    WRITE32(ADD32(GPR_U32(ctx, 16), 8736), GPR_U32(ctx, 5));
    // 0x16f628: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x16f62c: 0xae05223c
    WRITE32(ADD32(GPR_U32(ctx, 16), 8764), GPR_U32(ctx, 5));
    // 0x16f630: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x16f634: 0xae052228
    WRITE32(ADD32(GPR_U32(ctx, 16), 8744), GPR_U32(ctx, 5));
    // 0x16f638: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x16f63c: 0xae05224c
    WRITE32(ADD32(GPR_U32(ctx, 16), 8780), GPR_U32(ctx, 5));
    // 0x16f640: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x16f644: 0x244b36a0
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 2), 13984));
    // 0x16f648: 0x69680007
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x16f64c: 0x6d680000
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 8, (GPR_U64(ctx, 8) & ~mask) | (aligned_data & mask)); }
    // 0x16f650: 0x6969000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x16f654: 0x6d690008
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x16f658: 0xb2082447
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9287); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f65c: 0xb6082440
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9280); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 8) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f660: 0xb209244f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9295); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f664: 0xb6092448
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9288); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f668: 0x246b36b0
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 3), 14000));
    // 0x16f66c: 0x69620007
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16f670: 0x6d620000
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16f674: 0x6969000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x16f678: 0x6d690008
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 9, (GPR_U64(ctx, 9) & ~mask) | (aligned_data & mask)); }
    // 0x16f67c: 0xb2022457
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9303); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f680: 0xb6022450
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9296); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f684: 0xb209245f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9311); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f688: 0xb6092458
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9304); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 9) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f68c: 0x2408fcff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294966527));
    // 0x16f690: 0x84438
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 8) << 16);
    // 0x16f694: 0x3508ffff
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 8), 65535));
    // 0x16f698: 0x84438
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 8) << 16);
    // 0x16f69c: 0x3508ffff
    SET_GPR_U32(ctx, 8, OR32(GPR_U32(ctx, 8), 65535));
    // 0x16f6a0: 0x248b36c0
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 4), 14016));
    // 0x16f6a4: 0x69620007
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16f6a8: 0x6d620000
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16f6ac: 0x6963000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x16f6b0: 0x6d630008
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 3, (GPR_U64(ctx, 3) & ~mask) | (aligned_data & mask)); }
    // 0x16f6b4: 0xb2022467
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9319); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f6b8: 0xb6022460
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9312); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f6bc: 0xb203246f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9327); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f6c0: 0xb6032468
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9320); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 3) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f6c4: 0x34098000
    SET_GPR_U32(ctx, 9, OR32(GPR_U32(ctx, 0), 32768));
    // 0x16f6c8: 0x94e78
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 9) << 25);
    // 0x16f6cc: 0x24cb36d0
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 6), 14032));
    // 0x16f6d0: 0x69620007
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16f6d4: 0x6d620000
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16f6d8: 0x6964000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x16f6dc: 0x6d640008
    { uint32_t addr = ADD32(GPR_U32(ctx, 11), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x16f6e0: 0xb2022477
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9335); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f6e4: 0xb6022470
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9328); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f6e8: 0xb204247f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9343); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f6ec: 0xb6042478
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9336); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f6f0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x16f6f4: 0x24ea36e0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 7), 14048));
    // 0x16f6f8: 0x69420007
    { uint32_t addr = ADD32(GPR_U32(ctx, 10), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16f6fc: 0x6d420000
    { uint32_t addr = ADD32(GPR_U32(ctx, 10), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x16f700: 0x6944000f
    { uint32_t addr = ADD32(GPR_U32(ctx, 10), 15); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x16f704: 0x6d440008
    { uint32_t addr = ADD32(GPR_U32(ctx, 10), 8); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 4, (GPR_U64(ctx, 4) & ~mask) | (aligned_data & mask)); }
    // 0x16f708: 0xb2022487
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9351); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f70c: 0xb6022480
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9344); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f710: 0xb204248f
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9359); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f714: 0xb6042488
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 9352); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 4) & mask); WRITE64(aligned_addr, new_data); }
    // 0x16f718: 0x246336f0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 14064));
    // 0x16f71c: 0x3c014170
    SET_GPR_U32(ctx, 1, ((uint32_t)16752 << 16));
    // 0x16f720: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x16f724: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x16f728: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x16f72c: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16f730: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x16f734: 0x481024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 8)));
    // 0x16f738: 0x3c01c4da
    SET_GPR_U32(ctx, 1, ((uint32_t)50394 << 16));
    // 0x16f73c: 0x3421c000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 49152));
    // 0x16f740: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16f744: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x16f748: 0x44080000
    SET_GPR_U32(ctx, 8, *(uint32_t*)&ctx->f[0]);
    // 0x16f74c: 0x71042488
    SET_GPR_VEC(ctx, 4, PS2_PEXTLW(GPR_VEC(ctx, 8), GPR_VEC(ctx, 4)));
    // 0x16f750: 0x44080800
    SET_GPR_U32(ctx, 8, *(uint32_t*)&ctx->f[1]);
    // 0x16f754: 0x71042389
    SET_GPR_VEC(ctx, 4, _mm_unpacklo_epi64(GPR_VEC(ctx, 8), GPR_VEC(ctx, 4)));
    // 0x16f758: 0x491025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 9)));
    // 0x16f75c: 0xe6022420
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 9248), *(uint32_t*)&val); }
    // 0x16f760: 0x7e040350
    WRITE128(ADD32(GPR_U32(ctx, 16), 848), GPR_VEC(ctx, 4));
    // 0x16f764: 0xfe0202c8
    WRITE64(ADD32(GPR_U32(ctx, 16), 712), GPR_U64(ctx, 2));
    // 0x16f768: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16f76c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16f770: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16f774: 0xc4c2a860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 4294944864)); ctx->f[2] = *(float*)&val; }
    // 0x16f778: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x16f77c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16f780: 0x7e0224e0
    WRITE128(ADD32(GPR_U32(ctx, 16), 9440), GPR_VEC(ctx, 2));
    // 0x16f784: 0xe60026d0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 9936), *(uint32_t*)&val); }
    // 0x16f788: 0xae0721c0
    WRITE32(ADD32(GPR_U32(ctx, 16), 8640), GPR_U32(ctx, 7));
    // 0x16f78c: 0xae052718
    WRITE32(ADD32(GPR_U32(ctx, 16), 10008), GPR_U32(ctx, 5));
    // 0x16f790: 0xe6012724
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 10020), *(uint32_t*)&val); }
    // 0x16f794: 0xe6022758
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 10072), *(uint32_t*)&val); }
    // 0x16f798: 0x7fa40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 4));
    // 0x16f79c: 0xe6012728
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 10024), *(uint32_t*)&val); }
    // 0x16f7a0: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16f7a4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16f7a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: LoadJtFromBrx__FP2JTP18CBinaryInputStream
// Address: 0x16f7b0 - 0x16f7c4

void entry_16f7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f7c4: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x16f7c8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16f7cc: 0x24c62e40
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 11840));
    // 0x16f7d0: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x16f7d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 151));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_16f7d8
// Address: 0x16f7d8 - 0x16f7e4

void entry_16f7d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f7d8: 0x26042428
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 9256));
    // 0x16f7dc: 0xc05651e
    SET_GPR_U32(ctx, 31, 0x16f7e4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InferExpl__FPP4EXPLP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_16f7e4
// Address: 0x16f7e4 - 0x16f810

void entry_16f7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f7e4: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x16f7e8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16f7ec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16f7f0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16f7f4: 0xe60021c8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8648), *(uint32_t*)&val); }
    // 0x16f7f8: 0xe6002284
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8836), *(uint32_t*)&val); }
    // 0x16f7fc: 0xac502e10
    WRITE32(ADD32(GPR_U32(ctx, 2), 11792), GPR_U32(ctx, 16));
    // 0x16f800: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x16f804: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x16f80c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x16f810; return;
}


// Function: PostJtLoad__FP2JT
// Address: 0x16f810 - 0x16f840

void entry_16f840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f840: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x16f844: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16f848: 0x24c63558
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 13656));
    // 0x16f84c: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x16f854);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 27));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_16f854
// Address: 0x16f854 - 0x16f864

void entry_16f854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f854: 0x26650720
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 1824));
    // 0x16f858: 0x26660900
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 2304));
    // 0x16f85c: 0xc074dbc
    SET_GPR_U32(ctx, 31, 0x16f864);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PostStepLoadRun__FP4STEPP5BLRUNPP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16f864
// Address: 0x16f864 - 0x16f86c

void entry_16f864(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f864: 0xc07453c
    SET_GPR_U32(ctx, 31, 0x16f86c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PostJtLoadPipe__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_16f86c
// Address: 0x16f86c - 0x16f87c

void entry_16f86c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f86c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16f870: 0x26650a20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 2592));
    // 0x16f874: 0xc075052
    SET_GPR_U32(ctx, 31, 0x16f87c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 2848));
    PostJtLoadSidestep__FP2JTP4BLSSPP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16f87c
// Address: 0x16f87c - 0x16f88c

void entry_16f87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f87c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16f880: 0x26650b30
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 2864));
    // 0x16f884: 0xc075052
    SET_GPR_U32(ctx, 31, 0x16f88c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 3120));
    PostJtLoadSidestep__FP2JTP4BLSSPP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16f88c
// Address: 0x16f88c - 0x16f89c

void entry_16f88c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f88c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16f890: 0x26650c40
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 3136));
    // 0x16f894: 0xc074dbc
    SET_GPR_U32(ctx, 31, 0x16f89c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 3616));
    PostStepLoadRun__FP4STEPP5BLRUNPP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16f89c
// Address: 0x16f89c - 0x16f8ac

void entry_16f89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f89c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16f8a0: 0x26652360
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 9056));
    // 0x16f8a4: 0xc073104
    SET_GPR_U32(ctx, 31, 0x16f8ac);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 9092));
    PostJtLoadSwing__FP2JTP2BLPP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16f8ac
// Address: 0x16f8ac - 0x16f8bc

void entry_16f8ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f8ac: 0x26661010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 4112));
    // 0x16f8b0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16f8b4: 0xc074dbc
    SET_GPR_U32(ctx, 31, 0x16f8bc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 3632));
    PostStepLoadRun__FP4STEPP5BLRUNPP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16f8bc
// Address: 0x16f8bc - 0x16f8dc

void entry_16f8bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f8bc: 0x8e62110c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 4364)));
    // 0x16f8c0: 0x3c060022
    SET_GPR_U32(ctx, 6, ((uint32_t)34 << 16));
    // 0x16f8c4: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x16f8c8: 0x24c6a9a8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294945192));
    // 0x16f8cc: 0x8e6524f8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 9464)));
    // 0x16f8d0: 0xae730598
    WRITE32(ADD32(GPR_U32(ctx, 19), 1432), GPR_U32(ctx, 19));
    // 0x16f8d4: 0xc04848a
    SET_GPR_U32(ctx, 31, 0x16f8dc);
    WRITE32(ADD32(GPR_U32(ctx, 19), 1520), GPR_U32(ctx, 2));
    PactNew__FP2SWP3ALOP5VTACT(rdram, ctx, runtime); return;
}


// Function: entry_16f8dc
// Address: 0x16f8dc - 0x16f904

void entry_16f8dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f8dc: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16f8e0: 0x24030009
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 9));
    // 0x16f8e4: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16f8e8: 0xa2030011
    WRITE8(ADD32(GPR_U32(ctx, 16), 17), (uint8_t)GPR_U32(ctx, 3));
    // 0x16f8ec: 0xa2030010
    WRITE8(ADD32(GPR_U32(ctx, 16), 16), (uint8_t)GPR_U32(ctx, 3));
    // 0x16f8f0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16f8f4: 0xae020014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 2));
    // 0x16f8f8: 0xae12001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 28), GPR_U32(ctx, 18));
    // 0x16f8fc: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x16f904);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9464)));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_16f904
// Address: 0x16f904 - 0x16f918

void entry_16f904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f904: 0x8e6424f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9464)));
    // 0x16f908: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x16f90c: 0xae7024fc
    WRITE32(ADD32(GPR_U32(ctx, 19), 9468), GPR_U32(ctx, 16));
    // 0x16f910: 0xc04a740
    SET_GPR_U32(ctx, 31, 0x16f918);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 9472));
    CreateAloActadj__FP3ALOiPP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_16f918
// Address: 0x16f918 - 0x16f928

void entry_16f918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f918: 0x8e640618
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1560)));
    // 0x16f91c: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x16f920: 0xc04a740
    SET_GPR_U32(ctx, 31, 0x16f928);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 9476));
    CreateAloActadj__FP3ALOiPP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_16f928
// Address: 0x16f928 - 0x16f938

void entry_16f928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f928: 0x8e64061c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1564)));
    // 0x16f92c: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x16f930: 0xc04a740
    SET_GPR_U32(ctx, 31, 0x16f938);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 9480));
    CreateAloActadj__FP3ALOiPP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_16f938
// Address: 0x16f938 - 0x16f948

void entry_16f938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f938: 0x8e640610
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1552)));
    // 0x16f93c: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x16f940: 0xc04a740
    SET_GPR_U32(ctx, 31, 0x16f948);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 9484));
    CreateAloActadj__FP3ALOiPP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_16f948
// Address: 0x16f948 - 0x16f958

void entry_16f948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f948: 0x8e640614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1556)));
    // 0x16f94c: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x16f950: 0xc04a740
    SET_GPR_U32(ctx, 31, 0x16f958);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 9488));
    CreateAloActadj__FP3ALOiPP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_16f958
// Address: 0x16f958 - 0x16f968

void entry_16f958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f958: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x16f95c: 0x26269588
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 4294940040));
    // 0x16f960: 0xc04848a
    SET_GPR_U32(ctx, 31, 0x16f968);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 9464)));
    PactNew__FP2SWP3ALOP5VTACT(rdram, ctx, runtime); return;
}


// Function: entry_16f968
// Address: 0x16f968 - 0x16f980

void entry_16f968(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f968: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x16f96c: 0xae622518
    WRITE32(ADD32(GPR_U32(ctx, 19), 9496), GPR_U32(ctx, 2));
    // 0x16f970: 0xac430014
    WRITE32(ADD32(GPR_U32(ctx, 2), 20), GPR_U32(ctx, 3));
    // 0x16f974: 0x8e652518
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 9496)));
    // 0x16f978: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x16f980);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9464)));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_16f980
// Address: 0x16f980 - 0x16f990

void entry_16f980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f980: 0x8e6223d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 9168)));
    // 0x16f984: 0x2404015a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 346));
    // 0x16f988: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x16f990);
    WRITE32(ADD32(GPR_U32(ctx, 19), 5408), GPR_U32(ctx, 2));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_16f990
// Address: 0x16f990 - 0x16f9dc

void entry_16f990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f990: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x16f994: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16f998: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x16f99c: 0xae621524
    WRITE32(ADD32(GPR_U32(ctx, 19), 5412), GPR_U32(ctx, 2));
    // 0x16f9a0: 0x24633710
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 14096));
    // 0x16f9a4: 0xe6601530
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 5424), *(uint32_t*)&val); }
    // 0x16f9a8: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x16f9ac: 0x25083720
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 14112));
    // 0x16f9b0: 0x8e6623d4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 19), 9172)));
    // 0x16f9b4: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x16f9b8: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16f9bc: 0x8e6523d0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 9168)));
    // 0x16f9c0: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x16f9c4: 0x7e621560
    WRITE128(ADD32(GPR_U32(ctx, 19), 5472), GPR_VEC(ctx, 2));
    // 0x16f9c8: 0x26671540
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 5440));
    // 0x16f9cc: 0x79020000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 8), 0)));
    // 0x16f9d0: 0xae721538
    WRITE32(ADD32(GPR_U32(ctx, 19), 5432), GPR_U32(ctx, 18));
    // 0x16f9d4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x16f9dc);
    WRITE128(ADD32(GPR_U32(ctx, 19), 5488), GPR_VEC(ctx, 2));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_16f9dc
// Address: 0x16f9dc - 0x16fa48

void entry_16f9dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16f9dc: 0xda621540
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 5440)));
    // 0x16f9e0: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16f9e4: 0x4bc2106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16f9e8: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16f9ec: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16f9f0: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16f9f4: 0xc6602420
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 9248)); ctx->f[0] = *(float*)&val; }
    // 0x16f9f8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16f9fc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x16fa00: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x16fa04: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16fa08: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16fa0c: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16fa10: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x16fa14: 0x26672540
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 9536));
    // 0x16fa18: 0x46000800
    ctx->f[0] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x16fa1c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fa20: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fa24: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fa28: 0x266b2558
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 19), 9560));
    // 0x16fa2c: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x16fa30: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x16fa34: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x16fa38: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16fa3c: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x16fa40: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x16fa48);
    WRITE128(ADD32(GPR_U32(ctx, 19), 5440), _mm_castps_si128(ctx->vu0_vf[2]));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16fa48
// Address: 0x16fa48 - 0x16fa6c

void entry_16fa48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fa48: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16fa4c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16fa50: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16fa54: 0x2667255c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 9564));
    // 0x16fa58: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fa5c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fa60: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fa64: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x16fa6c);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 19), 9588));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16fa6c
// Address: 0x16fa6c - 0x16fa90

void entry_16fa6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fa6c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16fa70: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16fa74: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16fa78: 0x26672578
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 9592));
    // 0x16fa7c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fa80: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fa84: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fa88: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x16fa90);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 19), 9616));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16fa90
// Address: 0x16fa90 - 0x16fab4

void entry_16fa90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fa90: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16fa94: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16fa98: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x16fa9c: 0x26672594
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 19), 9620));
    // 0x16faa0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16faa4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16faa8: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16faac: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x16fab4);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 19), 9644));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16fab4
// Address: 0x16fab4 - 0x16fad0

void entry_16fab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fab4: 0x8e64243c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9276)));
    // 0x16fab8: 0x50800009
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 20)));
        ctx->pc = 0x16FAE0; return;
    }
    // 0x16fac0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x16fac4: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x16fac8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16fad0);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16fad0
// Address: 0x16fad0 - 0x16fadc

void entry_16fad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fad0: 0x8e64243c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9276)));
    // 0x16fad4: 0xc054b92
    SET_GPR_U32(ctx, 31, 0x16fadc);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 644)));
    SetDyshShadow__FP4DYSHP6SHADOW(rdram, ctx, runtime); return;
}


// Function: entry_16fadc
// Address: 0x16fadc - 0x16faf4

void entry_16fadc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16fadc) {
        switch (ctx->pc) {
            case 0x16fae0: ctx->pc = 0; goto label_16fae0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16fadc: 0x8e650014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 20)));
label_16fae0:
    // 0x16fae0: 0x24070316
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 790));
    // 0x16fae4: 0x2408ffff
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16fae8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16faec: 0xc047960
    SET_GPR_U32(ctx, 31, 0x16faf4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 99));
    PloNew__F3CIDP2SWP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_16faf4
// Address: 0x16faf4 - 0x16fb00

void entry_16faf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16faf4: 0xae622678
    WRITE32(ADD32(GPR_U32(ctx, 19), 9848), GPR_U32(ctx, 2));
    // 0x16faf8: 0xc074498
    SET_GPR_U32(ctx, 31, 0x16fb00);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ResetJtDynamicTunnel__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_16fb00
// Address: 0x16fb00 - 0x16fb10

void entry_16fb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fb00: 0x26650910
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 19), 2320));
    // 0x16fb04: 0x26660a10
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 2576));
    // 0x16fb08: 0xc075052
    SET_GPR_U32(ctx, 31, 0x16fb10);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PostJtLoadSidestep__FP2JTP4BLSSPP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16fb10
// Address: 0x16fb10 - 0x16fb18

void entry_16fb10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fb10: 0xc075212
    SET_GPR_U32(ctx, 31, 0x16fb18);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PostJtLoadZap__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_16fb18
// Address: 0x16fb18 - 0x16fb30

void entry_16fb18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fb18: 0x8e630000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x16fb1c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16fb20: 0x8e651390
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 5008)));
    // 0x16fb24: 0x8c6200e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 224)));
    // 0x16fb28: 0x40f809
    SET_GPR_U32(ctx, 31, 0x16fb30);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_16fb30
// Address: 0x16fb30 - 0x16fb40

void entry_16fb30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fb30: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fb34: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x16fb38: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x16fb40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_16fb40
// Address: 0x16fb40 - 0x16fb64

void entry_16fb40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fb40: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x16fb44: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x16fb48: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16fb4c: 0xc6600148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 328)); ctx->f[0] = *(float*)&val; }
    // 0x16fb50: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16fb54: 0xc44c3700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14080)); ctx->f[12] = *(float*)&val; }
    // 0x16fb58: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x16fb5c: 0xc0717aa
    SET_GPR_U32(ctx, 31, 0x16fb64);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 1616), *(uint32_t*)&val); }
    SetStepGravityRatio__FP4STEPf(rdram, ctx, runtime); return;
}


// Function: entry_16fb64
// Address: 0x16fb64 - 0x16fb74

void entry_16fb64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fb64: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x16fb68: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16fb6c: 0xc06e506
    SET_GPR_U32(ctx, 31, 0x16fb74);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14084)); ctx->f[12] = *(float*)&val; }
    SetSoMass__FP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_16fb74
// Address: 0x16fb74 - 0x16fc2c

void entry_16fb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16fb74) {
        switch (ctx->pc) {
            case 0x16fb98: ctx->pc = 0; goto label_16fb98;
            case 0x16fbb8: ctx->pc = 0; goto label_16fbb8;
            case 0x16fbd8: ctx->pc = 0; goto label_16fbd8;
            case 0x16fbf8: ctx->pc = 0; goto label_16fbf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16fb74: 0x8e6425d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9688)));
    // 0x16fb78: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9696)));
        goto label_16fb98;
    }
    // 0x16fb80: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x16fb84: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x16fb88: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x16fb8c: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16fb90: 0xfc820538
    WRITE64(ADD32(GPR_U32(ctx, 4), 1336), GPR_U64(ctx, 2));
    // 0x16fb94: 0x8e6425e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9696)));
label_16fb98:
    // 0x16fb98: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9692)));
        goto label_16fbb8;
    }
    // 0x16fba0: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x16fba4: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x16fba8: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x16fbac: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16fbb0: 0xfc820538
    WRITE64(ADD32(GPR_U32(ctx, 4), 1336), GPR_U64(ctx, 2));
    // 0x16fbb4: 0x8e6425dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9692)));
label_16fbb8:
    // 0x16fbb8: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9700)));
        goto label_16fbd8;
    }
    // 0x16fbc0: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x16fbc4: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x16fbc8: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x16fbcc: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16fbd0: 0xfc820538
    WRITE64(ADD32(GPR_U32(ctx, 4), 1336), GPR_U64(ctx, 2));
    // 0x16fbd4: 0x8e6425e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9700)));
label_16fbd8:
    // 0x16fbd8: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9704)));
        goto label_16fbf8;
    }
    // 0x16fbe0: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x16fbe4: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x16fbe8: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x16fbec: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16fbf0: 0xfc820538
    WRITE64(ADD32(GPR_U32(ctx, 4), 1336), GPR_U64(ctx, 2));
    // 0x16fbf4: 0x8e6425e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9704)));
label_16fbf8:
    // 0x16fbf8: 0x50800017
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 5040)));
        ctx->pc = 0x16FC58; return;
    }
    // 0x16fc00: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x16fc04: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x16fc08: 0x31f38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 28);
    // 0x16fc0c: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16fc10: 0xfc820538
    WRITE64(ADD32(GPR_U32(ctx, 4), 1336), GPR_U64(ctx, 2));
    // 0x16fc14: 0x8e6325e8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 9704)));
    // 0x16fc18: 0x8c620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    // 0x16fc1c: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 548)));
        ctx->pc = 0x16FC3C; return;
    }
    // 0x16fc24: 0xc063570
    SET_GPR_U32(ctx, 31, 0x16fc2c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 192));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_16fc2c
// Address: 0x16fc2c - 0x16fc78

void entry_16fc2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16fc2c) {
        switch (ctx->pc) {
            case 0x16fc3c: ctx->pc = 0; goto label_16fc3c;
            case 0x16fc58: ctx->pc = 0; goto label_16fc58;
            case 0x16fc68: ctx->pc = 0; goto label_16fc68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16fc2c: 0x8e6325e8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 9704)));
    // 0x16fc30: 0xac620224
    WRITE32(ADD32(GPR_U32(ctx, 3), 548), GPR_U32(ctx, 2));
    // 0x16fc34: 0x8e6325e8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 9704)));
    // 0x16fc38: 0x8c640224
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 548)));
label_16fc3c:
    // 0x16fc3c: 0x8c8200b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 176)));
    // 0x16fc40: 0x34420008
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 8));
    // 0x16fc44: 0xac8200b0
    WRITE32(ADD32(GPR_U32(ctx, 4), 176), GPR_U32(ctx, 2));
    // 0x16fc48: 0x8e6325e8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 9704)));
    // 0x16fc4c: 0x8c620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    // 0x16fc50: 0xac400060
    WRITE32(ADD32(GPR_U32(ctx, 2), 96), GPR_U32(ctx, 0));
    // 0x16fc54: 0x8e6213b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 5040)));
label_16fc58:
    // 0x16fc58: 0x14400003
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 20), 4294940040));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_16fc68;
    }
    // 0x16fc60: 0x8e621398
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 5016)));
    // 0x16fc64: 0xae6213b0
    WRITE32(ADD32(GPR_U32(ctx, 19), 5040), GPR_U32(ctx, 2));
label_16fc68:
    // 0x16fc68: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x16fc6c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16fc70: 0xc04848a
    SET_GPR_U32(ctx, 31, 0x16fc78);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    PactNew__FP2SWP3ALOP5VTACT(rdram, ctx, runtime); return;
}


// Function: entry_16fc78
// Address: 0x16fc78 - 0x16fc90

void entry_16fc78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fc78: 0x24110005
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 5));
    // 0x16fc7c: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x16fc80: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16fc84: 0xae622514
    WRITE32(ADD32(GPR_U32(ctx, 19), 9492), GPR_U32(ctx, 2));
    // 0x16fc88: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x16fc90);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 19), 4204));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_16fc90
// Address: 0x16fc90 - 0x16fca0

void entry_16fc90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fc90: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x16fc94: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16fc98: 0xc04848a
    SET_GPR_U32(ctx, 31, 0x16fca0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 1564)));
    PactNew__FP2SWP3ALOP5VTACT(rdram, ctx, runtime); return;
}


// Function: entry_16fca0
// Address: 0x16fca0 - 0x16fcb4

void entry_16fca0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fca0: 0xae62251c
    WRITE32(ADD32(GPR_U32(ctx, 19), 9500), GPR_U32(ctx, 2));
    // 0x16fca4: 0xac510014
    WRITE32(ADD32(GPR_U32(ctx, 2), 20), GPR_U32(ctx, 17));
    // 0x16fca8: 0x8e64061c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 1564)));
    // 0x16fcac: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x16fcb4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 9500)));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_16fcb4
// Address: 0x16fcb4 - 0x16fcc4

void entry_16fcb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fcb4: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x16fcb8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16fcbc: 0xc04848a
    SET_GPR_U32(ctx, 31, 0x16fcc4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 9168)));
    PactNew__FP2SWP3ALOP5VTACT(rdram, ctx, runtime); return;
}


// Function: entry_16fcc4
// Address: 0x16fcc4 - 0x16fcd8

void entry_16fcc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fcc4: 0xae622520
    WRITE32(ADD32(GPR_U32(ctx, 19), 9504), GPR_U32(ctx, 2));
    // 0x16fcc8: 0xac510014
    WRITE32(ADD32(GPR_U32(ctx, 2), 20), GPR_U32(ctx, 17));
    // 0x16fccc: 0x8e6423d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 9168)));
    // 0x16fcd0: 0xc04a678
    SET_GPR_U32(ctx, 31, 0x16fcd8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 9504)));
    InsertAloAct__FP3ALOP3ACT(rdram, ctx, runtime); return;
}


// Function: entry_16fcd8
// Address: 0x16fcd8 - 0x16fd1c

void entry_16fcd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fcd8: 0xde6202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 19), 712)));
    // 0x16fcdc: 0x3c03f3ff
    SET_GPR_U32(ctx, 3, ((uint32_t)62463 << 16));
    // 0x16fce0: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x16fce4: 0x3c06cfff
    SET_GPR_U32(ctx, 6, ((uint32_t)53247 << 16));
    // 0x16fce8: 0x34c6ffff
    SET_GPR_U32(ctx, 6, OR32(GPR_U32(ctx, 6), 65535));
    // 0x16fcec: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x16fcf0: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x16fcf4: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16fcf8: 0x461024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x16fcfc: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16fd00: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x16fd04: 0xfe6202c8
    WRITE64(ADD32(GPR_U32(ctx, 19), 712), GPR_U64(ctx, 2));
    // 0x16fd08: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fd0c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fd10: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x16fd14: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x16fd1c);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 19), 4240));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_16fd1c
// Address: 0x16fd1c - 0x16fd40

void entry_16fd1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16fd1c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x16fd20: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x16fd24: 0x8e641090
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 4240)));
    // 0x16fd28: 0x10800005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 4216), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_16fd40(rdram, ctx, runtime); return;
    }
    // 0x16fd30: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x16fd34: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x16fd38: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x16fd40);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_16fd40
// Address: 0x16fd40 - 0x16fd70

void entry_16fd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16fd40) {
        switch (ctx->pc) {
            case 0x16fd50: ctx->pc = 0; goto label_16fd50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16fd40: 0x8e632490
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 9360)));
    // 0x16fd44: 0x10600002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_16fd50;
    }
    // 0x16fd4c: 0xac6202f0
    WRITE32(ADD32(GPR_U32(ctx, 3), 752), GPR_U32(ctx, 2));
label_16fd50:
    // 0x16fd50: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16fd54: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x16fd58: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x16fd5c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x16fd60: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x16fd64: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16fd68: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PresetJtAccelBase
// Address: 0x16fd70 - 0x16ff58

void entry_16ff58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ff58: 0x26500660
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 1632));
    // 0x16ff5c: 0x460005c6
    ctx->f[23] = FPU_MOV_S(ctx->f[0]);
    // 0x16ff60: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x16ff64: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x16ff68: 0xc062214
    SET_GPR_U32(ctx, 31, 0x16ff70);
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_16ff70
// Address: 0x16ff70 - 0x16ffe4

void entry_16ff70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x16ff70: 0x4480b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 0);
    // 0x16ff74: 0xda4400d0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 208)));
    // 0x16ff78: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x16ff7c: 0xdba30060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x16ff80: 0x27a40090
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 144));
    // 0x16ff84: 0xdba60070
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x16ff88: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x16ff8c: 0xdba50080
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x16ff90: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x16ff94: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x16ff98: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16ff9c: 0xfba400d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16ffa0: 0xfba40100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x16ffa4: 0xda220010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 16)));
    // 0x16ffa8: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x16ffac: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x16ffb0: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16ffb4: 0xfba200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16ffb8: 0xfba20110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16ffbc: 0xda210020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 32)));
    // 0x16ffc0: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x16ffc4: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16ffc8: 0x4bc128ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x16ffcc: 0xfba200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x16ffd0: 0xfba300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16ffd4: 0xfba30120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16ffd8: 0xfba300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x16ffdc: 0xc07b642
    SET_GPR_U32(ctx, 31, 0x16ffe4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[4]));
    RadBetweenVectors__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_16ffe4
// Address: 0x16ffe4 - 0x170030

void entry_16ffe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x16ffe4) {
        switch (ctx->pc) {
            case 0x170018: ctx->pc = 0; goto label_170018;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x16ffe4: 0xda430680
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 1664)));
    // 0x16ffe8: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x16ffec: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x16fff0: 0x4bc3086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16fff4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x16fff8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x16fffc: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x170000: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x170004: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x170008: 0x46160034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[22])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17000c: 0x0
    // NOP
    // 0x170010: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[21] = FPU_NEG_S(ctx->f[21]);
        goto label_170018;
    }
label_170018:
    // 0x170018: 0xfba30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17001c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x170020: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x170024: 0x27a70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    // 0x170028: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x170030);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 352));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_170030
// Address: 0x170030 - 0x170078

void entry_160014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160014 inside entry_15ffe8 (0x15ffe8 - 0x160030)
    ctx->pc = 0x160014;
    entry_15ffe8(rdram, ctx, runtime);
}

void entry_160024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160024 inside entry_15ffe8 (0x15ffe8 - 0x160030)
    ctx->pc = 0x160024;
    entry_15ffe8(rdram, ctx, runtime);
}

void entry_1600b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1600b0 inside search_level_by_load_data (0x1600a0 - 0x160110)
    ctx->pc = 0x1600b0;
    search_level_by_load_data(rdram, ctx, runtime);
}

void entry_1600d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1600d0 inside search_level_by_load_data (0x1600a0 - 0x160110)
    ctx->pc = 0x1600d0;
    search_level_by_load_data(rdram, ctx, runtime);
}

void entry_1600ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1600ec inside search_level_by_load_data (0x1600a0 - 0x160110)
    ctx->pc = 0x1600ec;
    search_level_by_load_data(rdram, ctx, runtime);
}

void entry_1600fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1600fc inside search_level_by_load_data (0x1600a0 - 0x160110)
    ctx->pc = 0x1600fc;
    search_level_by_load_data(rdram, ctx, runtime);
}

void entry_160120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160120 inside search_level_by_id (0x160110 - 0x160148)
    ctx->pc = 0x160120;
    search_level_by_id(rdram, ctx, runtime);
}

void entry_160130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160130 inside search_level_by_id (0x160110 - 0x160148)
    ctx->pc = 0x160130;
    search_level_by_id(rdram, ctx, runtime);
}

void entry_160168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160168 inside entry_160158 (0x160158 - 0x160178)
    ctx->pc = 0x160168;
    entry_160158(rdram, ctx, runtime);
}

void entry_16016c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16016c inside entry_160158 (0x160158 - 0x160178)
    ctx->pc = 0x16016c;
    entry_160158(rdram, ctx, runtime);
}

void entry_1601bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1601bc inside entry_1601b0 (0x1601b0 - 0x1601d0)
    ctx->pc = 0x1601bc;
    entry_1601b0(rdram, ctx, runtime);
}

void entry_1601f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1601f4 inside entry_1601e8 (0x1601e8 - 0x160208)
    ctx->pc = 0x1601f4;
    entry_1601e8(rdram, ctx, runtime);
}

void entry_160228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160228 inside tally_world_completion (0x160208 - 0x1602a0)
    ctx->pc = 0x160228;
    tally_world_completion(rdram, ctx, runtime);
}

void entry_160254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160254 inside tally_world_completion (0x160208 - 0x1602a0)
    ctx->pc = 0x160254;
    tally_world_completion(rdram, ctx, runtime);
}

void entry_160270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160270 inside tally_world_completion (0x160208 - 0x1602a0)
    ctx->pc = 0x160270;
    tally_world_completion(rdram, ctx, runtime);
}

void entry_160288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160288 inside tally_world_completion (0x160208 - 0x1602a0)
    ctx->pc = 0x160288;
    tally_world_completion(rdram, ctx, runtime);
}

void entry_1602c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1602c8 inside get_game_completion__Fv (0x1602a0 - 0x1602d0)
    ctx->pc = 0x1602c8;
    get_game_completion__Fv(rdram, ctx, runtime);
}

void entry_160308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160308 inside entry_1602d0 (0x1602d0 - 0x160340)
    ctx->pc = 0x160308;
    entry_1602d0(rdram, ctx, runtime);
}

void entry_1603dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1603dc inside UnlockIntroCutsceneFromWid__Fi (0x160340 - 0x1603e8)
    ctx->pc = 0x1603dc;
    UnlockIntroCutsceneFromWid__Fi(rdram, ctx, runtime);
}

void entry_1604e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1604e4 inside UnlockEndgameCutscenesFromFgs (0x1604b8 - 0x16051c)
    ctx->pc = 0x1604e4;
    UnlockEndgameCutscenesFromFgs(rdram, ctx, runtime);
}

void entry_1604f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1604f8 inside UnlockEndgameCutscenesFromFgs (0x1604b8 - 0x16051c)
    ctx->pc = 0x1604f8;
    UnlockEndgameCutscenesFromFgs(rdram, ctx, runtime);
}

void entry_160514(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160514 inside UnlockEndgameCutscenesFromFgs (0x1604b8 - 0x16051c)
    ctx->pc = 0x160514;
    UnlockEndgameCutscenesFromFgs(rdram, ctx, runtime);
}

void entry_16053c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16053c inside entry_16051c (0x16051c - 0x160544)
    ctx->pc = 0x16053c;
    entry_16051c(rdram, ctx, runtime);
}

void entry_160564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160564 inside entry_160544 (0x160544 - 0x160578)
    ctx->pc = 0x160564;
    entry_160544(rdram, ctx, runtime);
}

void entry_16056c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16056c inside entry_160544 (0x160544 - 0x160578)
    ctx->pc = 0x16056c;
    entry_160544(rdram, ctx, runtime);
}

void entry_160570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160570 inside entry_160544 (0x160544 - 0x160578)
    ctx->pc = 0x160570;
    entry_160544(rdram, ctx, runtime);
}

void entry_1605a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1605a8 inside PlayEndingFromCompletionFlags (0x160578 - 0x1605c0)
    ctx->pc = 0x1605a8;
    PlayEndingFromCompletionFlags(rdram, ctx, runtime);
}

void entry_1605ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1605ac inside PlayEndingFromCompletionFlags (0x160578 - 0x1605c0)
    ctx->pc = 0x1605ac;
    PlayEndingFromCompletionFlags(rdram, ctx, runtime);
}

void entry_160668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160668 inside FUN_00160650 (0x160650 - 0x160690)
    ctx->pc = 0x160668;
    FUN_00160650(rdram, ctx, runtime);
}

void entry_160684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160684 inside FUN_00160650 (0x160650 - 0x160690)
    ctx->pc = 0x160684;
    FUN_00160650(rdram, ctx, runtime);
}

void entry_160728(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160728 inside entry_1606c0 (0x1606c0 - 0x160730)
    ctx->pc = 0x160728;
    entry_1606c0(rdram, ctx, runtime);
}

void entry_160738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160738 inside entry_160730 (0x160730 - 0x160748)
    ctx->pc = 0x160738;
    entry_160730(rdram, ctx, runtime);
}

void entry_160750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160750 inside entry_160748 (0x160748 - 0x160764)
    ctx->pc = 0x160750;
    entry_160748(rdram, ctx, runtime);
}

void entry_16076c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16076c inside entry_160764 (0x160764 - 0x160774)
    ctx->pc = 0x16076c;
    entry_160764(rdram, ctx, runtime);
}

void entry_160778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160778 inside entry_160774 (0x160774 - 0x1607d0)
    ctx->pc = 0x160778;
    entry_160774(rdram, ctx, runtime);
}

void entry_160848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160848 inside LsFromWid (0x160810 - 0x160850)
    ctx->pc = 0x160848;
    LsFromWid(rdram, ctx, runtime);
}

void entry_16086c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16086c inside entry_160860 (0x160860 - 0x160880)
    ctx->pc = 0x16086c;
    entry_160860(rdram, ctx, runtime);
}

void entry_160990(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160990 inside entry_16097c (0x16097c - 0x160998)
    ctx->pc = 0x160990;
    entry_16097c(rdram, ctx, runtime);
}

void entry_1609e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1609e4 inside entry_160998 (0x160998 - 0x160a30)
    ctx->pc = 0x1609e4;
    entry_160998(rdram, ctx, runtime);
}

void entry_1609fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1609fc inside entry_160998 (0x160998 - 0x160a30)
    ctx->pc = 0x1609fc;
    entry_160998(rdram, ctx, runtime);
}

void entry_160a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160a18 inside entry_160998 (0x160998 - 0x160a30)
    ctx->pc = 0x160a18;
    entry_160998(rdram, ctx, runtime);
}

void entry_160a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160a20 inside entry_160998 (0x160998 - 0x160a30)
    ctx->pc = 0x160a20;
    entry_160998(rdram, ctx, runtime);
}

void entry_160a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160a24 inside entry_160998 (0x160998 - 0x160a30)
    ctx->pc = 0x160a24;
    entry_160998(rdram, ctx, runtime);
}

void entry_160a38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160a38 inside entry_160a30 (0x160a30 - 0x160a68)
    ctx->pc = 0x160a38;
    entry_160a30(rdram, ctx, runtime);
}

void entry_160ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160ad0 inside entry_160a90 (0x160a90 - 0x160ad8)
    ctx->pc = 0x160ad0;
    entry_160a90(rdram, ctx, runtime);
}

void entry_160af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160af4 inside entry_160ad8 (0x160ad8 - 0x160b10)
    ctx->pc = 0x160af4;
    entry_160ad8(rdram, ctx, runtime);
}

void entry_160afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160afc inside entry_160ad8 (0x160ad8 - 0x160b10)
    ctx->pc = 0x160afc;
    entry_160ad8(rdram, ctx, runtime);
}

void entry_160b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160b14 inside entry_160b10 (0x160b10 - 0x160b28)
    ctx->pc = 0x160b14;
    entry_160b10(rdram, ctx, runtime);
}

void entry_160b18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160b18 inside entry_160b10 (0x160b10 - 0x160b28)
    ctx->pc = 0x160b18;
    entry_160b10(rdram, ctx, runtime);
}

void entry_160b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160b50 inside CalculatePercentCompletion__FP2GS (0x160b28 - 0x160c48)
    ctx->pc = 0x160b50;
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime);
}

void entry_160b98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160b98 inside CalculatePercentCompletion__FP2GS (0x160b28 - 0x160c48)
    ctx->pc = 0x160b98;
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime);
}

void entry_160bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160bb0 inside CalculatePercentCompletion__FP2GS (0x160b28 - 0x160c48)
    ctx->pc = 0x160bb0;
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime);
}

void entry_160bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160bc0 inside CalculatePercentCompletion__FP2GS (0x160b28 - 0x160c48)
    ctx->pc = 0x160bc0;
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime);
}

void entry_160bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160bd8 inside CalculatePercentCompletion__FP2GS (0x160b28 - 0x160c48)
    ctx->pc = 0x160bd8;
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime);
}

void entry_160c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160c10 inside CalculatePercentCompletion__FP2GS (0x160b28 - 0x160c48)
    ctx->pc = 0x160c10;
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime);
}

void entry_160c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160c34 inside CalculatePercentCompletion__FP2GS (0x160b28 - 0x160c48)
    ctx->pc = 0x160c34;
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime);
}

void entry_160c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160c3c inside CalculatePercentCompletion__FP2GS (0x160b28 - 0x160c48)
    ctx->pc = 0x160c3c;
    CalculatePercentCompletion__FP2GS(rdram, ctx, runtime);
}

void entry_160c80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160c80 inside FCharmAvailable__Fv (0x160c58 - 0x160c90)
    ctx->pc = 0x160c80;
    FCharmAvailable__Fv(rdram, ctx, runtime);
}

void entry_160c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160c84 inside FCharmAvailable__Fv (0x160c58 - 0x160c90)
    ctx->pc = 0x160c84;
    FCharmAvailable__Fv(rdram, ctx, runtime);
}

void entry_160cbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160cbc inside PfLookupDialog__FP2LS3OID (0x160ca0 - 0x160cc8)
    ctx->pc = 0x160cbc;
    PfLookupDialog__FP2LS3OID(rdram, ctx, runtime);
}

void entry_160d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160d88 inside GetBlueprintInfo__FPiT0 (0x160d30 - 0x160d98)
    ctx->pc = 0x160d88;
    GetBlueprintInfo__FPiT0(rdram, ctx, runtime);
}

void entry_160d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160d90 inside GetBlueprintInfo__FPiT0 (0x160d30 - 0x160d98)
    ctx->pc = 0x160d90;
    GetBlueprintInfo__FPiT0(rdram, ctx, runtime);
}

void entry_160e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160e30 inside entry_160e28 (0x160e28 - 0x160e44)
    ctx->pc = 0x160e30;
    entry_160e28(rdram, ctx, runtime);
}

void entry_160e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160e4c inside entry_160e44 (0x160e44 - 0x160e5c)
    ctx->pc = 0x160e4c;
    entry_160e44(rdram, ctx, runtime);
}

void entry_160e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160e60 inside entry_160e5c (0x160e5c - 0x160e70)
    ctx->pc = 0x160e60;
    entry_160e5c(rdram, ctx, runtime);
}

void entry_160f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160f48 inside entry_160f20 (0x160f20 - 0x160f68)
    ctx->pc = 0x160f48;
    entry_160f20(rdram, ctx, runtime);
}

void entry_160f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160f78 inside entry_160f68 (0x160f68 - 0x160fa4)
    ctx->pc = 0x160f78;
    entry_160f68(rdram, ctx, runtime);
}

void entry_160f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x160f88 inside entry_160f68 (0x160f68 - 0x160fa4)
    ctx->pc = 0x160f88;
    entry_160f68(rdram, ctx, runtime);
}

void entry_161008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161008 inside entry_160ff8 (0x160ff8 - 0x161028)
    ctx->pc = 0x161008;
    entry_160ff8(rdram, ctx, runtime);
}

void entry_1610b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1610b4 inside entry_1610ac (0x1610ac - 0x161190)
    ctx->pc = 0x1610b4;
    entry_1610ac(rdram, ctx, runtime);
}

void entry_1610e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1610e0 inside entry_1610ac (0x1610ac - 0x161190)
    ctx->pc = 0x1610e0;
    entry_1610ac(rdram, ctx, runtime);
}

void entry_161100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161100 inside entry_1610ac (0x1610ac - 0x161190)
    ctx->pc = 0x161100;
    entry_1610ac(rdram, ctx, runtime);
}

void entry_161114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161114 inside entry_1610ac (0x1610ac - 0x161190)
    ctx->pc = 0x161114;
    entry_1610ac(rdram, ctx, runtime);
}

void entry_161130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161130 inside entry_1610ac (0x1610ac - 0x161190)
    ctx->pc = 0x161130;
    entry_1610ac(rdram, ctx, runtime);
}

void entry_16114c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16114c inside entry_1610ac (0x1610ac - 0x161190)
    ctx->pc = 0x16114c;
    entry_1610ac(rdram, ctx, runtime);
}

void entry_161154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161154 inside entry_1610ac (0x1610ac - 0x161190)
    ctx->pc = 0x161154;
    entry_1610ac(rdram, ctx, runtime);
}

void entry_161170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161170 inside entry_1610ac (0x1610ac - 0x161190)
    ctx->pc = 0x161170;
    entry_1610ac(rdram, ctx, runtime);
}

void entry_161178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161178 inside entry_1610ac (0x1610ac - 0x161190)
    ctx->pc = 0x161178;
    entry_1610ac(rdram, ctx, runtime);
}

void entry_161188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161188 inside entry_1610ac (0x1610ac - 0x161190)
    ctx->pc = 0x161188;
    entry_1610ac(rdram, ctx, runtime);
}

void entry_161194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161194 inside entry_161190 (0x161190 - 0x1611b8)
    ctx->pc = 0x161194;
    entry_161190(rdram, ctx, runtime);
}

void entry_161238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161238 inside entry_161230 (0x161230 - 0x16124c)
    ctx->pc = 0x161238;
    entry_161230(rdram, ctx, runtime);
}

void entry_161268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161268 inside entry_161264 (0x161264 - 0x161278)
    ctx->pc = 0x161268;
    entry_161264(rdram, ctx, runtime);
}

void entry_161298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161298 inside EndPrim__4GIFSi (0x161278 - 0x1612e8)
    ctx->pc = 0x161298;
    EndPrim__4GIFSi(rdram, ctx, runtime);
}

void entry_1612b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1612b8 inside EndPrim__4GIFSi (0x161278 - 0x1612e8)
    ctx->pc = 0x1612b8;
    EndPrim__4GIFSi(rdram, ctx, runtime);
}

void entry_1612cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1612cc inside EndPrim__4GIFSi (0x161278 - 0x1612e8)
    ctx->pc = 0x1612cc;
    EndPrim__4GIFSi(rdram, ctx, runtime);
}

void entry_1612d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1612d0 inside EndPrim__4GIFSi (0x161278 - 0x1612e8)
    ctx->pc = 0x1612d0;
    EndPrim__4GIFSi(rdram, ctx, runtime);
}

void entry_1612dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1612dc inside EndPrim__4GIFSi (0x161278 - 0x1612e8)
    ctx->pc = 0x1612dc;
    EndPrim__4GIFSi(rdram, ctx, runtime);
}

void entry_161384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161384 inside entry_161348 (0x161348 - 0x1613c0)
    ctx->pc = 0x161384;
    entry_161348(rdram, ctx, runtime);
}

void entry_1619e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1619e0 inside __4GLBS (0x1619c0 - 0x161a0c)
    ctx->pc = 0x1619e0;
    fn___4GLBS(rdram, ctx, runtime);
}

void entry_161b40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161b40 inside FindLights__4GLBSP6VECTORf (0x161b10 - 0x161b60)
    ctx->pc = 0x161b40;
    FindLights__4GLBSP6VECTORf(rdram, ctx, runtime);
}

void entry_161b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161b6c inside entry_161b60 (0x161b60 - 0x161b80)
    ctx->pc = 0x161b6c;
    entry_161b60(rdram, ctx, runtime);
}

void entry_161d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161d10 inside entry_161cec (0x161cec - 0x161da8)
    ctx->pc = 0x161d10;
    entry_161cec(rdram, ctx, runtime);
}

void entry_161d64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161d64 inside entry_161cec (0x161cec - 0x161da8)
    ctx->pc = 0x161d64;
    entry_161cec(rdram, ctx, runtime);
}

void entry_161d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161d94 inside entry_161cec (0x161cec - 0x161da8)
    ctx->pc = 0x161d94;
    entry_161cec(rdram, ctx, runtime);
}

void entry_161e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161e08 inside entry_161dec (0x161dec - 0x161eb8)
    ctx->pc = 0x161e08;
    entry_161dec(rdram, ctx, runtime);
}

void entry_161e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161e20 inside entry_161dec (0x161dec - 0x161eb8)
    ctx->pc = 0x161e20;
    entry_161dec(rdram, ctx, runtime);
}

void entry_161e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161e34 inside entry_161dec (0x161dec - 0x161eb8)
    ctx->pc = 0x161e34;
    entry_161dec(rdram, ctx, runtime);
}

void entry_161e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161e80 inside entry_161dec (0x161dec - 0x161eb8)
    ctx->pc = 0x161e80;
    entry_161dec(rdram, ctx, runtime);
}

void entry_161e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161e90 inside entry_161dec (0x161dec - 0x161eb8)
    ctx->pc = 0x161e90;
    entry_161dec(rdram, ctx, runtime);
}

void entry_161ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161ecc inside entry_161eb8 (0x161eb8 - 0x161eec)
    ctx->pc = 0x161ecc;
    entry_161eb8(rdram, ctx, runtime);
}

void entry_161f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x161f40 inside entry_161eec (0x161eec - 0x161f50)
    ctx->pc = 0x161f40;
    entry_161eec(rdram, ctx, runtime);
}

void entry_1620a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1620a0 inside entry_162070 (0x162070 - 0x162118)
    ctx->pc = 0x1620a0;
    entry_162070(rdram, ctx, runtime);
}

void entry_1620d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1620d8 inside entry_162070 (0x162070 - 0x162118)
    ctx->pc = 0x1620d8;
    entry_162070(rdram, ctx, runtime);
}

void entry_1620e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1620e0 inside entry_162070 (0x162070 - 0x162118)
    ctx->pc = 0x1620e0;
    entry_162070(rdram, ctx, runtime);
}

void entry_162104(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162104 inside entry_162070 (0x162070 - 0x162118)
    ctx->pc = 0x162104;
    entry_162070(rdram, ctx, runtime);
}

void entry_1621a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1621a0 inside entry_162188 (0x162188 - 0x16223c)
    ctx->pc = 0x1621a0;
    entry_162188(rdram, ctx, runtime);
}

void entry_1621b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1621b8 inside entry_162188 (0x162188 - 0x16223c)
    ctx->pc = 0x1621b8;
    entry_162188(rdram, ctx, runtime);
}

void entry_1621fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1621fc inside entry_162188 (0x162188 - 0x16223c)
    ctx->pc = 0x1621fc;
    entry_162188(rdram, ctx, runtime);
}

void entry_162214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162214 inside entry_162188 (0x162188 - 0x16223c)
    ctx->pc = 0x162214;
    entry_162188(rdram, ctx, runtime);
}

void entry_16225c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16225c inside entry_16223c (0x16223c - 0x1622f4)
    ctx->pc = 0x16225c;
    entry_16223c(rdram, ctx, runtime);
}

void entry_162270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162270 inside entry_16223c (0x16223c - 0x1622f4)
    ctx->pc = 0x162270;
    entry_16223c(rdram, ctx, runtime);
}

void entry_162288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162288 inside entry_16223c (0x16223c - 0x1622f4)
    ctx->pc = 0x162288;
    entry_16223c(rdram, ctx, runtime);
}

void entry_16229c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16229c inside entry_16223c (0x16223c - 0x1622f4)
    ctx->pc = 0x16229c;
    entry_16223c(rdram, ctx, runtime);
}

void entry_1622e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1622e8 inside entry_16223c (0x16223c - 0x1622f4)
    ctx->pc = 0x1622e8;
    entry_16223c(rdram, ctx, runtime);
}

void entry_162308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162308 inside entry_1622f4 (0x1622f4 - 0x162320)
    ctx->pc = 0x162308;
    entry_1622f4(rdram, ctx, runtime);
}

void entry_162330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162330 inside entry_162320 (0x162320 - 0x16233c)
    ctx->pc = 0x162330;
    entry_162320(rdram, ctx, runtime);
}

void entry_1623c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1623c0 inside entry_1623a4 (0x1623a4 - 0x162440)
    ctx->pc = 0x1623c0;
    entry_1623a4(rdram, ctx, runtime);
}

void entry_162400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162400 inside entry_1623a4 (0x1623a4 - 0x162440)
    ctx->pc = 0x162400;
    entry_1623a4(rdram, ctx, runtime);
}

void entry_162418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162418 inside entry_1623a4 (0x1623a4 - 0x162440)
    ctx->pc = 0x162418;
    entry_1623a4(rdram, ctx, runtime);
}

void entry_162454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162454 inside entry_162440 (0x162440 - 0x162478)
    ctx->pc = 0x162454;
    entry_162440(rdram, ctx, runtime);
}

void entry_1624cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1624cc inside entry_162478 (0x162478 - 0x1624dc)
    ctx->pc = 0x1624cc;
    entry_162478(rdram, ctx, runtime);
}

void entry_16254c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16254c inside entry_162544 (0x162544 - 0x162554)
    ctx->pc = 0x16254c;
    entry_162544(rdram, ctx, runtime);
}

void entry_162590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162590 inside entry_16256c (0x16256c - 0x162608)
    ctx->pc = 0x162590;
    entry_16256c(rdram, ctx, runtime);
}

void entry_1625ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1625ac inside entry_16256c (0x16256c - 0x162608)
    ctx->pc = 0x1625ac;
    entry_16256c(rdram, ctx, runtime);
}

void entry_1625b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1625b8 inside entry_16256c (0x16256c - 0x162608)
    ctx->pc = 0x1625b8;
    entry_16256c(rdram, ctx, runtime);
}

void entry_1625ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1625ec inside entry_16256c (0x16256c - 0x162608)
    ctx->pc = 0x1625ec;
    entry_16256c(rdram, ctx, runtime);
}

void entry_162634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162634 inside entry_162608 (0x162608 - 0x16264c)
    ctx->pc = 0x162634;
    entry_162608(rdram, ctx, runtime);
}

void entry_162644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162644 inside entry_162608 (0x162608 - 0x16264c)
    ctx->pc = 0x162644;
    entry_162608(rdram, ctx, runtime);
}

void entry_162654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162654 inside entry_16264c (0x16264c - 0x16265c)
    ctx->pc = 0x162654;
    entry_16264c(rdram, ctx, runtime);
}

void entry_162668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162668 inside entry_162664 (0x162664 - 0x162680)
    ctx->pc = 0x162668;
    entry_162664(rdram, ctx, runtime);
}

void entry_162790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162790 inside AddVtx__4GLBSi (0x1626d8 - 0x1627c8)
    ctx->pc = 0x162790;
    AddVtx__4GLBSi(rdram, ctx, runtime);
}

void entry_1627f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1627f4 inside entry_1627ec (0x1627ec - 0x162810)
    ctx->pc = 0x1627f4;
    entry_1627ec(rdram, ctx, runtime);
}

void entry_162848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162848 inside entry_16282c (0x16282c - 0x162890)
    ctx->pc = 0x162848;
    entry_16282c(rdram, ctx, runtime);
}

void entry_16286c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16286c inside entry_16282c (0x16282c - 0x162890)
    ctx->pc = 0x16286c;
    entry_16282c(rdram, ctx, runtime);
}

void entry_162880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162880 inside entry_16282c (0x16282c - 0x162890)
    ctx->pc = 0x162880;
    entry_16282c(rdram, ctx, runtime);
}

void entry_162930(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162930 inside entry_16291c (0x16291c - 0x162938)
    ctx->pc = 0x162930;
    entry_16291c(rdram, ctx, runtime);
}

void entry_162960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162960 inside entry_162938 (0x162938 - 0x16296c)
    ctx->pc = 0x162960;
    entry_162938(rdram, ctx, runtime);
}

void entry_162a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162a08 inside entry_1629e8 (0x1629e8 - 0x162a38)
    ctx->pc = 0x162a08;
    entry_1629e8(rdram, ctx, runtime);
}

void entry_162aa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162aa8 inside entry_162a50 (0x162a50 - 0x162b3c)
    ctx->pc = 0x162aa8;
    entry_162a50(rdram, ctx, runtime);
}

void entry_162b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162b58 inside entry_162b50 (0x162b50 - 0x162be8)
    ctx->pc = 0x162b58;
    entry_162b50(rdram, ctx, runtime);
}

void entry_162bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162bd8 inside entry_162b50 (0x162b50 - 0x162be8)
    ctx->pc = 0x162bd8;
    entry_162b50(rdram, ctx, runtime);
}

void entry_162bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162bf0 inside entry_162be8 (0x162be8 - 0x162c00)
    ctx->pc = 0x162bf0;
    entry_162be8(rdram, ctx, runtime);
}

void entry_162c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162c08 inside entry_162c00 (0x162c00 - 0x162c18)
    ctx->pc = 0x162c08;
    entry_162c00(rdram, ctx, runtime);
}

void entry_162c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162c3c inside entry_162c18 (0x162c18 - 0x162c5c)
    ctx->pc = 0x162c3c;
    entry_162c18(rdram, ctx, runtime);
}

void entry_162c4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162c4c inside entry_162c18 (0x162c18 - 0x162c5c)
    ctx->pc = 0x162c4c;
    entry_162c18(rdram, ctx, runtime);
}

void entry_162c64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162c64 inside entry_162c5c (0x162c5c - 0x162c74)
    ctx->pc = 0x162c64;
    entry_162c5c(rdram, ctx, runtime);
}

void entry_162c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162c98 inside entry_162c74 (0x162c74 - 0x162ca8)
    ctx->pc = 0x162c98;
    entry_162c74(rdram, ctx, runtime);
}

void entry_162cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162cc8 inside entry_162ca8 (0x162ca8 - 0x162ce8)
    ctx->pc = 0x162cc8;
    entry_162ca8(rdram, ctx, runtime);
}

void entry_162ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162ccc inside entry_162ca8 (0x162ca8 - 0x162ce8)
    ctx->pc = 0x162ccc;
    entry_162ca8(rdram, ctx, runtime);
}

void entry_162d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162d00 inside entry_162ce8 (0x162ce8 - 0x162d10)
    ctx->pc = 0x162d00;
    entry_162ce8(rdram, ctx, runtime);
}

void entry_162d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162d40 inside entry_162d38 (0x162d38 - 0x162d58)
    ctx->pc = 0x162d40;
    entry_162d38(rdram, ctx, runtime);
}

void entry_162d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162d48 inside entry_162d38 (0x162d38 - 0x162d58)
    ctx->pc = 0x162d48;
    entry_162d38(rdram, ctx, runtime);
}

void entry_162e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162e08 inside entry_162de8 (0x162de8 - 0x162e18)
    ctx->pc = 0x162e08;
    entry_162de8(rdram, ctx, runtime);
}

void entry_162e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162e0c inside entry_162de8 (0x162de8 - 0x162e18)
    ctx->pc = 0x162e0c;
    entry_162de8(rdram, ctx, runtime);
}

void entry_162e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162e94 inside entry_162e8c (0x162e8c - 0x162ea0)
    ctx->pc = 0x162e94;
    entry_162e8c(rdram, ctx, runtime);
}

void entry_162f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x162f08 inside entry_162ed4 (0x162ed4 - 0x162f40)
    ctx->pc = 0x162f08;
    entry_162ed4(rdram, ctx, runtime);
}

void entry_163088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163088 inside entry_16307c (0x16307c - 0x163094)
    ctx->pc = 0x163088;
    entry_16307c(rdram, ctx, runtime);
}

void entry_1630a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1630a8 inside entry_163094 (0x163094 - 0x1630bc)
    ctx->pc = 0x1630a8;
    entry_163094(rdram, ctx, runtime);
}

void entry_163168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163168 inside entry_163148 (0x163148 - 0x163174)
    ctx->pc = 0x163168;
    entry_163148(rdram, ctx, runtime);
}

void entry_1631b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1631b8 inside entry_1631a4 (0x1631a4 - 0x1631d4)
    ctx->pc = 0x1631b8;
    entry_1631a4(rdram, ctx, runtime);
}

void entry_1631c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1631c8 inside entry_1631a4 (0x1631a4 - 0x1631d4)
    ctx->pc = 0x1631c8;
    entry_1631a4(rdram, ctx, runtime);
}

void entry_1631f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1631f8 inside entry_1631d4 (0x1631d4 - 0x163200)
    ctx->pc = 0x1631f8;
    entry_1631d4(rdram, ctx, runtime);
}

void entry_163254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163254 inside entry_163250 (0x163250 - 0x1632fc)
    ctx->pc = 0x163254;
    entry_163250(rdram, ctx, runtime);
}

void entry_163278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163278 inside entry_163250 (0x163250 - 0x1632fc)
    ctx->pc = 0x163278;
    entry_163250(rdram, ctx, runtime);
}

void entry_163288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163288 inside entry_163250 (0x163250 - 0x1632fc)
    ctx->pc = 0x163288;
    entry_163250(rdram, ctx, runtime);
}

void entry_163304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163304 inside entry_1632fc (0x1632fc - 0x163380)
    ctx->pc = 0x163304;
    entry_1632fc(rdram, ctx, runtime);
}

void entry_163388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163388 inside entry_163380 (0x163380 - 0x1633e8)
    ctx->pc = 0x163388;
    entry_163380(rdram, ctx, runtime);
}

void entry_16338c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16338c inside entry_163380 (0x163380 - 0x1633e8)
    ctx->pc = 0x16338c;
    entry_163380(rdram, ctx, runtime);
}

void entry_163450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163450 inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x163450;
    entry_16340c(rdram, ctx, runtime);
}

void entry_163454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163454 inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x163454;
    entry_16340c(rdram, ctx, runtime);
}

void entry_16349c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16349c inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x16349c;
    entry_16340c(rdram, ctx, runtime);
}

void entry_1634a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1634a0 inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x1634a0;
    entry_16340c(rdram, ctx, runtime);
}

void entry_1634e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1634e8 inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x1634e8;
    entry_16340c(rdram, ctx, runtime);
}

void entry_163518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163518 inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x163518;
    entry_16340c(rdram, ctx, runtime);
}

void entry_163554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163554 inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x163554;
    entry_16340c(rdram, ctx, runtime);
}

void entry_16355c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16355c inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x16355c;
    entry_16340c(rdram, ctx, runtime);
}

void entry_163560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163560 inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x163560;
    entry_16340c(rdram, ctx, runtime);
}

void entry_163590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163590 inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x163590;
    entry_16340c(rdram, ctx, runtime);
}

void entry_163594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163594 inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x163594;
    entry_16340c(rdram, ctx, runtime);
}

void entry_1635cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1635cc inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x1635cc;
    entry_16340c(rdram, ctx, runtime);
}

void entry_1635d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1635d0 inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x1635d0;
    entry_16340c(rdram, ctx, runtime);
}

void entry_1635f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1635f0 inside entry_16340c (0x16340c - 0x16362c)
    ctx->pc = 0x1635f0;
    entry_16340c(rdram, ctx, runtime);
}

void entry_163648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163648 inside entry_163634 (0x163634 - 0x163654)
    ctx->pc = 0x163648;
    entry_163634(rdram, ctx, runtime);
}

void entry_163688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163688 inside entry_163664 (0x163664 - 0x1636ac)
    ctx->pc = 0x163688;
    entry_163664(rdram, ctx, runtime);
}

void entry_163720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163720 inside entry_163714 (0x163714 - 0x16372c)
    ctx->pc = 0x163720;
    entry_163714(rdram, ctx, runtime);
}

void entry_163740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163740 inside entry_16372c (0x16372c - 0x163764)
    ctx->pc = 0x163740;
    entry_16372c(rdram, ctx, runtime);
}

void entry_1637e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1637e0 inside entry_1637c4 (0x1637c4 - 0x1637ec)
    ctx->pc = 0x1637e0;
    entry_1637c4(rdram, ctx, runtime);
}

void entry_163818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163818 inside entry_163800 (0x163800 - 0x163824)
    ctx->pc = 0x163818;
    entry_163800(rdram, ctx, runtime);
}

void entry_1638e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1638e4 inside entry_1638d0 (0x1638d0 - 0x163904)
    ctx->pc = 0x1638e4;
    entry_1638d0(rdram, ctx, runtime);
}

void entry_1638e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1638e8 inside entry_1638d0 (0x1638d0 - 0x163904)
    ctx->pc = 0x1638e8;
    entry_1638d0(rdram, ctx, runtime);
}

void entry_1638fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1638fc inside entry_1638d0 (0x1638d0 - 0x163904)
    ctx->pc = 0x1638fc;
    entry_1638d0(rdram, ctx, runtime);
}

void entry_16395c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16395c inside EnsureBuffer__FiP4VIFS (0x163938 - 0x16396c)
    ctx->pc = 0x16395c;
    EnsureBuffer__FiP4VIFS(rdram, ctx, runtime);
}

void entry_163974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163974 inside entry_16396c (0x16396c - 0x163984)
    ctx->pc = 0x163974;
    entry_16396c(rdram, ctx, runtime);
}

void entry_163988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163988 inside entry_163984 (0x163984 - 0x163990)
    ctx->pc = 0x163988;
    entry_163984(rdram, ctx, runtime);
}

void entry_1639b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1639b4 inside EnsureBufferCel__FiP4VIFS (0x163990 - 0x1639c4)
    ctx->pc = 0x1639b4;
    EnsureBufferCel__FiP4VIFS(rdram, ctx, runtime);
}

void entry_1639cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1639cc inside entry_1639c4 (0x1639c4 - 0x1639dc)
    ctx->pc = 0x1639cc;
    entry_1639c4(rdram, ctx, runtime);
}

void entry_1639e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1639e0 inside entry_1639dc (0x1639dc - 0x1639e8)
    ctx->pc = 0x1639e0;
    entry_1639dc(rdram, ctx, runtime);
}

void entry_163d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163d50 inside entry_163d10 (0x163d10 - 0x163d68)
    ctx->pc = 0x163d50;
    entry_163d10(rdram, ctx, runtime);
}

void entry_163db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163db8 inside entry_163d88 (0x163d88 - 0x163e30)
    ctx->pc = 0x163db8;
    entry_163d88(rdram, ctx, runtime);
}

void entry_163e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163e24 inside entry_163d88 (0x163d88 - 0x163e30)
    ctx->pc = 0x163e24;
    entry_163d88(rdram, ctx, runtime);
}

void entry_163e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x163e50 inside entry_163e38 (0x163e38 - 0x163e7c)
    ctx->pc = 0x163e50;
    entry_163e38(rdram, ctx, runtime);
}

void entry_164044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164044 inside entry_163f70 (0x163f70 - 0x16405c)
    ctx->pc = 0x164044;
    entry_163f70(rdram, ctx, runtime);
}

void entry_1640c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1640c0 inside entry_1640b4 (0x1640b4 - 0x1640f4)
    ctx->pc = 0x1640c0;
    entry_1640b4(rdram, ctx, runtime);
}

void entry_1640d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1640d0 inside entry_1640b4 (0x1640b4 - 0x1640f4)
    ctx->pc = 0x1640d0;
    entry_1640b4(rdram, ctx, runtime);
}

void entry_1640e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1640e0 inside entry_1640b4 (0x1640b4 - 0x1640f4)
    ctx->pc = 0x1640e0;
    entry_1640b4(rdram, ctx, runtime);
}

void entry_164100(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164100 inside entry_1640f4 (0x1640f4 - 0x16421c)
    ctx->pc = 0x164100;
    entry_1640f4(rdram, ctx, runtime);
}

void entry_164130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164130 inside entry_1640f4 (0x1640f4 - 0x16421c)
    ctx->pc = 0x164130;
    entry_1640f4(rdram, ctx, runtime);
}

void entry_164154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164154 inside entry_1640f4 (0x1640f4 - 0x16421c)
    ctx->pc = 0x164154;
    entry_1640f4(rdram, ctx, runtime);
}

void entry_164180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164180 inside entry_1640f4 (0x1640f4 - 0x16421c)
    ctx->pc = 0x164180;
    entry_1640f4(rdram, ctx, runtime);
}

void entry_164194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164194 inside entry_1640f4 (0x1640f4 - 0x16421c)
    ctx->pc = 0x164194;
    entry_1640f4(rdram, ctx, runtime);
}

void entry_1641d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1641d8 inside entry_1640f4 (0x1640f4 - 0x16421c)
    ctx->pc = 0x1641d8;
    entry_1640f4(rdram, ctx, runtime);
}

void entry_1641e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1641e0 inside entry_1640f4 (0x1640f4 - 0x16421c)
    ctx->pc = 0x1641e0;
    entry_1640f4(rdram, ctx, runtime);
}

void entry_164200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164200 inside entry_1640f4 (0x1640f4 - 0x16421c)
    ctx->pc = 0x164200;
    entry_1640f4(rdram, ctx, runtime);
}

void entry_164220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164220 inside entry_16421c (0x16421c - 0x164248)
    ctx->pc = 0x164220;
    entry_16421c(rdram, ctx, runtime);
}

void entry_164250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164250 inside entry_164248 (0x164248 - 0x164258)
    ctx->pc = 0x164250;
    entry_164248(rdram, ctx, runtime);
}

void entry_1642b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1642b0 inside entry_1642ac (0x1642ac - 0x1642ec)
    ctx->pc = 0x1642b0;
    entry_1642ac(rdram, ctx, runtime);
}

void entry_164368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164368 inside entry_164358 (0x164358 - 0x1643dc)
    ctx->pc = 0x164368;
    entry_164358(rdram, ctx, runtime);
}

void entry_164380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164380 inside entry_164358 (0x164358 - 0x1643dc)
    ctx->pc = 0x164380;
    entry_164358(rdram, ctx, runtime);
}

void entry_1643bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1643bc inside entry_164358 (0x164358 - 0x1643dc)
    ctx->pc = 0x1643bc;
    entry_164358(rdram, ctx, runtime);
}

void entry_1643cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1643cc inside entry_164358 (0x164358 - 0x1643dc)
    ctx->pc = 0x1643cc;
    entry_164358(rdram, ctx, runtime);
}

void entry_164418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164418 inside entry_1643dc (0x1643dc - 0x164428)
    ctx->pc = 0x164418;
    entry_1643dc(rdram, ctx, runtime);
}

void entry_16442c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16442c inside entry_164428 (0x164428 - 0x164440)
    ctx->pc = 0x16442c;
    entry_164428(rdram, ctx, runtime);
}

void entry_164490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164490 inside entry_164460 (0x164460 - 0x164534)
    ctx->pc = 0x164490;
    entry_164460(rdram, ctx, runtime);
}

void entry_164528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164528 inside entry_164460 (0x164460 - 0x164534)
    ctx->pc = 0x164528;
    entry_164460(rdram, ctx, runtime);
}

void entry_164550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164550 inside entry_164534 (0x164534 - 0x16459c)
    ctx->pc = 0x164550;
    entry_164534(rdram, ctx, runtime);
}

void entry_164580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164580 inside entry_164534 (0x164534 - 0x16459c)
    ctx->pc = 0x164580;
    entry_164534(rdram, ctx, runtime);
}

void entry_1645e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1645e0 inside entry_1645dc (0x1645dc - 0x164604)
    ctx->pc = 0x1645e0;
    entry_1645dc(rdram, ctx, runtime);
}

void entry_16463c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16463c inside entry_16461c (0x16461c - 0x16465c)
    ctx->pc = 0x16463c;
    entry_16461c(rdram, ctx, runtime);
}

void entry_164650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164650 inside entry_16461c (0x16461c - 0x16465c)
    ctx->pc = 0x164650;
    entry_16461c(rdram, ctx, runtime);
}

void entry_1646b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1646b8 inside entry_1646a8 (0x1646a8 - 0x1647c0)
    ctx->pc = 0x1646b8;
    entry_1646a8(rdram, ctx, runtime);
}

void entry_1646e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1646e0 inside entry_1646a8 (0x1646a8 - 0x1647c0)
    ctx->pc = 0x1646e0;
    entry_1646a8(rdram, ctx, runtime);
}

void entry_164710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164710 inside entry_1646a8 (0x1646a8 - 0x1647c0)
    ctx->pc = 0x164710;
    entry_1646a8(rdram, ctx, runtime);
}

void entry_164720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164720 inside entry_1646a8 (0x1646a8 - 0x1647c0)
    ctx->pc = 0x164720;
    entry_1646a8(rdram, ctx, runtime);
}

void entry_164730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164730 inside entry_1646a8 (0x1646a8 - 0x1647c0)
    ctx->pc = 0x164730;
    entry_1646a8(rdram, ctx, runtime);
}

void entry_164778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164778 inside entry_1646a8 (0x1646a8 - 0x1647c0)
    ctx->pc = 0x164778;
    entry_1646a8(rdram, ctx, runtime);
}

void entry_16478c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16478c inside entry_1646a8 (0x1646a8 - 0x1647c0)
    ctx->pc = 0x16478c;
    entry_1646a8(rdram, ctx, runtime);
}

void entry_164798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164798 inside entry_1646a8 (0x1646a8 - 0x1647c0)
    ctx->pc = 0x164798;
    entry_1646a8(rdram, ctx, runtime);
}

void entry_164810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164810 inside entry_1647dc (0x1647dc - 0x16481c)
    ctx->pc = 0x164810;
    entry_1647dc(rdram, ctx, runtime);
}

void entry_16483c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16483c inside entry_164838 (0x164838 - 0x164868)
    ctx->pc = 0x16483c;
    entry_164838(rdram, ctx, runtime);
}

void entry_164928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164928 inside entry_164908 (0x164908 - 0x1649c4)
    ctx->pc = 0x164928;
    entry_164908(rdram, ctx, runtime);
}

void entry_164978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164978 inside entry_164908 (0x164908 - 0x1649c4)
    ctx->pc = 0x164978;
    entry_164908(rdram, ctx, runtime);
}

void entry_16497c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16497c inside entry_164908 (0x164908 - 0x1649c4)
    ctx->pc = 0x16497c;
    entry_164908(rdram, ctx, runtime);
}

void entry_1649a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1649a0 inside entry_164908 (0x164908 - 0x1649c4)
    ctx->pc = 0x1649a0;
    entry_164908(rdram, ctx, runtime);
}

void entry_164a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164a08 inside entry_1649f8 (0x1649f8 - 0x164a30)
    ctx->pc = 0x164a08;
    entry_1649f8(rdram, ctx, runtime);
}

void entry_164a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164a1c inside entry_1649f8 (0x1649f8 - 0x164a30)
    ctx->pc = 0x164a1c;
    entry_1649f8(rdram, ctx, runtime);
}

void entry_164a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164a40 inside entry_164a30 (0x164a30 - 0x164af4)
    ctx->pc = 0x164a40;
    entry_164a30(rdram, ctx, runtime);
}

void entry_164a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164a78 inside entry_164a30 (0x164a30 - 0x164af4)
    ctx->pc = 0x164a78;
    entry_164a30(rdram, ctx, runtime);
}

void entry_164ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164ac0 inside entry_164a30 (0x164a30 - 0x164af4)
    ctx->pc = 0x164ac0;
    entry_164a30(rdram, ctx, runtime);
}

void entry_164ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164ac8 inside entry_164a30 (0x164a30 - 0x164af4)
    ctx->pc = 0x164ac8;
    entry_164a30(rdram, ctx, runtime);
}

void entry_164ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164ae8 inside entry_164a30 (0x164a30 - 0x164af4)
    ctx->pc = 0x164ae8;
    entry_164a30(rdram, ctx, runtime);
}

void entry_164bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164bb0 inside entry_164ba0 (0x164ba0 - 0x164c24)
    ctx->pc = 0x164bb0;
    entry_164ba0(rdram, ctx, runtime);
}

void entry_164bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164bc8 inside entry_164ba0 (0x164ba0 - 0x164c24)
    ctx->pc = 0x164bc8;
    entry_164ba0(rdram, ctx, runtime);
}

void entry_164c04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164c04 inside entry_164ba0 (0x164ba0 - 0x164c24)
    ctx->pc = 0x164c04;
    entry_164ba0(rdram, ctx, runtime);
}

void entry_164c14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164c14 inside entry_164ba0 (0x164ba0 - 0x164c24)
    ctx->pc = 0x164c14;
    entry_164ba0(rdram, ctx, runtime);
}

void entry_164c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164c50 inside entry_164c24 (0x164c24 - 0x164c68)
    ctx->pc = 0x164c50;
    entry_164c24(rdram, ctx, runtime);
}

void entry_164cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164cb8 inside entry_164c88 (0x164c88 - 0x164d60)
    ctx->pc = 0x164cb8;
    entry_164c88(rdram, ctx, runtime);
}

void entry_164d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164d50 inside entry_164c88 (0x164c88 - 0x164d60)
    ctx->pc = 0x164d50;
    entry_164c88(rdram, ctx, runtime);
}

void entry_164d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164d80 inside entry_164d68 (0x164d68 - 0x164d90)
    ctx->pc = 0x164d80;
    entry_164d68(rdram, ctx, runtime);
}

void entry_164de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164de0 inside entry_164dd8 (0x164dd8 - 0x164dfc)
    ctx->pc = 0x164de0;
    entry_164dd8(rdram, ctx, runtime);
}

void entry_164e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164e00 inside entry_164dfc (0x164dfc - 0x164e24)
    ctx->pc = 0x164e00;
    entry_164dfc(rdram, ctx, runtime);
}

void entry_164e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164e60 inside entry_164e4c (0x164e4c - 0x164e70)
    ctx->pc = 0x164e60;
    entry_164e4c(rdram, ctx, runtime);
}

void entry_164e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164e74 inside entry_164e70 (0x164e70 - 0x164e94)
    ctx->pc = 0x164e74;
    entry_164e70(rdram, ctx, runtime);
}

void entry_164ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164ec0 inside entry_164e94 (0x164e94 - 0x164f64)
    ctx->pc = 0x164ec0;
    entry_164e94(rdram, ctx, runtime);
}

void entry_164f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164f58 inside entry_164e94 (0x164e94 - 0x164f64)
    ctx->pc = 0x164f58;
    entry_164e94(rdram, ctx, runtime);
}

void entry_164f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164f78 inside entry_164f64 (0x164f64 - 0x164f88)
    ctx->pc = 0x164f78;
    entry_164f64(rdram, ctx, runtime);
}

void entry_164f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164f8c inside entry_164f88 (0x164f88 - 0x164f98)
    ctx->pc = 0x164f8c;
    entry_164f88(rdram, ctx, runtime);
}

void entry_164fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164fc0 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x164fc0;
    entry_164f98(rdram, ctx, runtime);
}

void entry_164ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x164ff0 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x164ff0;
    entry_164f98(rdram, ctx, runtime);
}

void entry_165020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165020 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x165020;
    entry_164f98(rdram, ctx, runtime);
}

void entry_165038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165038 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x165038;
    entry_164f98(rdram, ctx, runtime);
}

void entry_165048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165048 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x165048;
    entry_164f98(rdram, ctx, runtime);
}

void entry_165090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165090 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x165090;
    entry_164f98(rdram, ctx, runtime);
}

void entry_1650b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1650b4 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x1650b4;
    entry_164f98(rdram, ctx, runtime);
}

void entry_1650d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1650d0 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x1650d0;
    entry_164f98(rdram, ctx, runtime);
}

void entry_16510c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16510c inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x16510c;
    entry_164f98(rdram, ctx, runtime);
}

void entry_165120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165120 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x165120;
    entry_164f98(rdram, ctx, runtime);
}

void entry_165140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165140 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x165140;
    entry_164f98(rdram, ctx, runtime);
}

void entry_165158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165158 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x165158;
    entry_164f98(rdram, ctx, runtime);
}

void entry_1651bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1651bc inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x1651bc;
    entry_164f98(rdram, ctx, runtime);
}

void entry_1651d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1651d8 inside entry_164f98 (0x164f98 - 0x165200)
    ctx->pc = 0x1651d8;
    entry_164f98(rdram, ctx, runtime);
}

void entry_16521c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16521c inside entry_165200 (0x165200 - 0x165228)
    ctx->pc = 0x16521c;
    entry_165200(rdram, ctx, runtime);
}

void entry_16526c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16526c inside entry_165258 (0x165258 - 0x165310)
    ctx->pc = 0x16526c;
    entry_165258(rdram, ctx, runtime);
}

void entry_165288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165288 inside entry_165258 (0x165258 - 0x165310)
    ctx->pc = 0x165288;
    entry_165258(rdram, ctx, runtime);
}

void entry_1652a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1652a4 inside entry_165258 (0x165258 - 0x165310)
    ctx->pc = 0x1652a4;
    entry_165258(rdram, ctx, runtime);
}

void entry_1652d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1652d0 inside entry_165258 (0x165258 - 0x165310)
    ctx->pc = 0x1652d0;
    entry_165258(rdram, ctx, runtime);
}

void entry_1652f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1652f4 inside entry_165258 (0x165258 - 0x165310)
    ctx->pc = 0x1652f4;
    entry_165258(rdram, ctx, runtime);
}

void entry_165314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165314 inside entry_165310 (0x165310 - 0x16533c)
    ctx->pc = 0x165314;
    entry_165310(rdram, ctx, runtime);
}

void entry_165340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165340 inside entry_16533c (0x16533c - 0x165370)
    ctx->pc = 0x165340;
    entry_16533c(rdram, ctx, runtime);
}

void entry_16534c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16534c inside entry_16533c (0x16533c - 0x165370)
    ctx->pc = 0x16534c;
    entry_16533c(rdram, ctx, runtime);
}

void entry_165394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165394 inside entry_165390 (0x165390 - 0x1653dc)
    ctx->pc = 0x165394;
    entry_165390(rdram, ctx, runtime);
}

void entry_1653c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1653c0 inside entry_165390 (0x165390 - 0x1653dc)
    ctx->pc = 0x1653c0;
    entry_165390(rdram, ctx, runtime);
}

void entry_165420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165420 inside entry_16541c (0x16541c - 0x165444)
    ctx->pc = 0x165420;
    entry_16541c(rdram, ctx, runtime);
}

void entry_16547c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16547c inside entry_16545c (0x16545c - 0x1654a4)
    ctx->pc = 0x16547c;
    entry_16545c(rdram, ctx, runtime);
}

void entry_165490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165490 inside entry_16545c (0x16545c - 0x1654a4)
    ctx->pc = 0x165490;
    entry_16545c(rdram, ctx, runtime);
}

void entry_1654b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1654b8 inside entry_1654a4 (0x1654a4 - 0x1654e8)
    ctx->pc = 0x1654b8;
    entry_1654a4(rdram, ctx, runtime);
}

void entry_165538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165538 inside entry_165504 (0x165504 - 0x16554c)
    ctx->pc = 0x165538;
    entry_165504(rdram, ctx, runtime);
}

void entry_165558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165558 inside entry_165554 (0x165554 - 0x165588)
    ctx->pc = 0x165558;
    entry_165554(rdram, ctx, runtime);
}

void entry_165710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165710 inside entry_16570c (0x16570c - 0x165728)
    ctx->pc = 0x165710;
    entry_16570c(rdram, ctx, runtime);
}

void entry_165768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165768 inside PostGlobsetLoad__FP7GLOBSETP3ALO (0x165728 - 0x16578c)
    ctx->pc = 0x165768;
    PostGlobsetLoad__FP7GLOBSETP3ALO(rdram, ctx, runtime);
}

void entry_165790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165790 inside entry_16578c (0x16578c - 0x1657a8)
    ctx->pc = 0x165790;
    entry_16578c(rdram, ctx, runtime);
}

void entry_1657bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1657bc inside entry_1657a8 (0x1657a8 - 0x1657e0)
    ctx->pc = 0x1657bc;
    entry_1657a8(rdram, ctx, runtime);
}

void entry_1657d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1657d0 inside entry_1657a8 (0x1657a8 - 0x1657e0)
    ctx->pc = 0x1657d0;
    entry_1657a8(rdram, ctx, runtime);
}

void entry_165804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165804 inside entry_1657f4 (0x1657f4 - 0x165828)
    ctx->pc = 0x165804;
    entry_1657f4(rdram, ctx, runtime);
}

void entry_165868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165868 inside BindGlobset__FP7GLOBSETP3ALO (0x165828 - 0x16588c)
    ctx->pc = 0x165868;
    BindGlobset__FP7GLOBSETP3ALO(rdram, ctx, runtime);
}

void entry_1658e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1658e8 inside entry_1658c8 (0x1658c8 - 0x165920)
    ctx->pc = 0x1658e8;
    entry_1658c8(rdram, ctx, runtime);
}

void entry_1658fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1658fc inside entry_1658c8 (0x1658c8 - 0x165920)
    ctx->pc = 0x1658fc;
    entry_1658c8(rdram, ctx, runtime);
}

void entry_1659a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1659a8 inside entry_165994 (0x165994 - 0x1659fc)
    ctx->pc = 0x1659a8;
    entry_165994(rdram, ctx, runtime);
}

void entry_1659b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1659b0 inside entry_165994 (0x165994 - 0x1659fc)
    ctx->pc = 0x1659b0;
    entry_165994(rdram, ctx, runtime);
}

void entry_1659ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1659ec inside entry_165994 (0x165994 - 0x1659fc)
    ctx->pc = 0x1659ec;
    entry_165994(rdram, ctx, runtime);
}

void entry_1659f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1659f4 inside entry_165994 (0x165994 - 0x1659fc)
    ctx->pc = 0x1659f4;
    entry_165994(rdram, ctx, runtime);
}

void entry_165a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165a04 inside entry_1659fc (0x1659fc - 0x165a18)
    ctx->pc = 0x165a04;
    entry_1659fc(rdram, ctx, runtime);
}

void entry_165a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165a10 inside entry_1659fc (0x1659fc - 0x165a18)
    ctx->pc = 0x165a10;
    entry_1659fc(rdram, ctx, runtime);
}

void entry_165a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165a5c inside entry_165a18 (0x165a18 - 0x165ab0)
    ctx->pc = 0x165a5c;
    entry_165a18(rdram, ctx, runtime);
}

void entry_165a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165a60 inside entry_165a18 (0x165a18 - 0x165ab0)
    ctx->pc = 0x165a60;
    entry_165a18(rdram, ctx, runtime);
}

void entry_165a78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165a78 inside entry_165a18 (0x165a18 - 0x165ab0)
    ctx->pc = 0x165a78;
    entry_165a18(rdram, ctx, runtime);
}

void entry_165a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165a90 inside entry_165a18 (0x165a18 - 0x165ab0)
    ctx->pc = 0x165a90;
    entry_165a18(rdram, ctx, runtime);
}

void entry_165ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165ac0 inside entry_165ab0 (0x165ab0 - 0x165ac8)
    ctx->pc = 0x165ac0;
    entry_165ab0(rdram, ctx, runtime);
}

void entry_165b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165b70 inside entry_165b34 (0x165b34 - 0x165ba8)
    ctx->pc = 0x165b70;
    entry_165b34(rdram, ctx, runtime);
}

void entry_165b8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165b8c inside entry_165b34 (0x165b34 - 0x165ba8)
    ctx->pc = 0x165b8c;
    entry_165b34(rdram, ctx, runtime);
}

void entry_165be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165be8 inside entry_165bc8 (0x165bc8 - 0x165c08)
    ctx->pc = 0x165be8;
    entry_165bc8(rdram, ctx, runtime);
}

void entry_165c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165c10 inside entry_165c08 (0x165c08 - 0x165c20)
    ctx->pc = 0x165c10;
    entry_165c08(rdram, ctx, runtime);
}

void entry_165c24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165c24 inside entry_165c20 (0x165c20 - 0x165cdc)
    ctx->pc = 0x165c24;
    entry_165c20(rdram, ctx, runtime);
}

void entry_165c2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165c2c inside entry_165c20 (0x165c20 - 0x165cdc)
    ctx->pc = 0x165c2c;
    entry_165c20(rdram, ctx, runtime);
}

void entry_165c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165c30 inside entry_165c20 (0x165c20 - 0x165cdc)
    ctx->pc = 0x165c30;
    entry_165c20(rdram, ctx, runtime);
}

void entry_165c40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165c40 inside entry_165c20 (0x165c20 - 0x165cdc)
    ctx->pc = 0x165c40;
    entry_165c20(rdram, ctx, runtime);
}

void entry_165c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165c7c inside entry_165c20 (0x165c20 - 0x165cdc)
    ctx->pc = 0x165c7c;
    entry_165c20(rdram, ctx, runtime);
}

void entry_165c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165c98 inside entry_165c20 (0x165c20 - 0x165cdc)
    ctx->pc = 0x165c98;
    entry_165c20(rdram, ctx, runtime);
}

void entry_165d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165d00 inside entry_165cdc (0x165cdc - 0x165dfc)
    ctx->pc = 0x165d00;
    entry_165cdc(rdram, ctx, runtime);
}

void entry_165d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165d48 inside entry_165cdc (0x165cdc - 0x165dfc)
    ctx->pc = 0x165d48;
    entry_165cdc(rdram, ctx, runtime);
}

void entry_165d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165d70 inside entry_165cdc (0x165cdc - 0x165dfc)
    ctx->pc = 0x165d70;
    entry_165cdc(rdram, ctx, runtime);
}

void entry_165d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165d88 inside entry_165cdc (0x165cdc - 0x165dfc)
    ctx->pc = 0x165d88;
    entry_165cdc(rdram, ctx, runtime);
}

void entry_165d8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165d8c inside entry_165cdc (0x165cdc - 0x165dfc)
    ctx->pc = 0x165d8c;
    entry_165cdc(rdram, ctx, runtime);
}

void entry_165dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165dd8 inside entry_165cdc (0x165cdc - 0x165dfc)
    ctx->pc = 0x165dd8;
    entry_165cdc(rdram, ctx, runtime);
}

void entry_165e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165e04 inside entry_165dfc (0x165dfc - 0x165e30)
    ctx->pc = 0x165e04;
    entry_165dfc(rdram, ctx, runtime);
}

void entry_165e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165e08 inside entry_165dfc (0x165dfc - 0x165e30)
    ctx->pc = 0x165e08;
    entry_165dfc(rdram, ctx, runtime);
}

void entry_165e14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165e14 inside entry_165dfc (0x165dfc - 0x165e30)
    ctx->pc = 0x165e14;
    entry_165dfc(rdram, ctx, runtime);
}

void entry_165e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165e8c inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165e8c;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165e90 inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165e90;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165ea0 inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165ea0;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165ee4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165ee4 inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165ee4;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165ee8 inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165ee8;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165f28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165f28 inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165f28;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165f2c inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165f2c;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165f6c inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165f6c;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165f70 inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165f70;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165f78 inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165f78;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165f7c inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165f7c;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165f88 inside entry_165e48 (0x165e48 - 0x165f98)
    ctx->pc = 0x165f88;
    entry_165e48(rdram, ctx, runtime);
}

void entry_165fac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x165fac inside entry_165f98 (0x165f98 - 0x165fe0)
    ctx->pc = 0x165fac;
    entry_165f98(rdram, ctx, runtime);
}

void entry_166018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166018 inside UpdateGlobset__FP7GLOBSETP3ALOf (0x165fe0 - 0x16602c)
    ctx->pc = 0x166018;
    UpdateGlobset__FP7GLOBSETP3ALOf(rdram, ctx, runtime);
}

void entry_166050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166050 inside entry_16604c (0x16604c - 0x166078)
    ctx->pc = 0x166050;
    entry_16604c(rdram, ctx, runtime);
}

void entry_166060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166060 inside entry_16604c (0x16604c - 0x166078)
    ctx->pc = 0x166060;
    entry_16604c(rdram, ctx, runtime);
}

void entry_166070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166070 inside entry_16604c (0x16604c - 0x166078)
    ctx->pc = 0x166070;
    entry_16604c(rdram, ctx, runtime);
}

void entry_166084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166084 inside entry_166078 (0x166078 - 0x1660a0)
    ctx->pc = 0x166084;
    entry_166078(rdram, ctx, runtime);
}

void entry_1660dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1660dc inside entry_1660d8 (0x1660d8 - 0x1660e8)
    ctx->pc = 0x1660dc;
    entry_1660d8(rdram, ctx, runtime);
}

void entry_166140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166140 inside entry_166138 (0x166138 - 0x16619c)
    ctx->pc = 0x166140;
    entry_166138(rdram, ctx, runtime);
}

void entry_166164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166164 inside entry_166138 (0x166138 - 0x16619c)
    ctx->pc = 0x166164;
    entry_166138(rdram, ctx, runtime);
}

void entry_166178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166178 inside entry_166138 (0x166138 - 0x16619c)
    ctx->pc = 0x166178;
    entry_166138(rdram, ctx, runtime);
}

void entry_1661f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1661f4 inside entry_16619c (0x16619c - 0x166208)
    ctx->pc = 0x1661f4;
    entry_16619c(rdram, ctx, runtime);
}

void entry_1661f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1661f8 inside entry_16619c (0x16619c - 0x166208)
    ctx->pc = 0x1661f8;
    entry_16619c(rdram, ctx, runtime);
}

void entry_166214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166214 inside entry_166208 (0x166208 - 0x16621c)
    ctx->pc = 0x166214;
    entry_166208(rdram, ctx, runtime);
}

void entry_166274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166274 inside entry_166250 (0x166250 - 0x1662a8)
    ctx->pc = 0x166274;
    entry_166250(rdram, ctx, runtime);
}

void entry_166284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166284 inside entry_166250 (0x166250 - 0x1662a8)
    ctx->pc = 0x166284;
    entry_166250(rdram, ctx, runtime);
}

void entry_166320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166320 inside entry_1662e8 (0x1662e8 - 0x166388)
    ctx->pc = 0x166320;
    entry_1662e8(rdram, ctx, runtime);
}

void entry_166338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166338 inside entry_1662e8 (0x1662e8 - 0x166388)
    ctx->pc = 0x166338;
    entry_1662e8(rdram, ctx, runtime);
}

void entry_166350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166350 inside entry_1662e8 (0x1662e8 - 0x166388)
    ctx->pc = 0x166350;
    entry_1662e8(rdram, ctx, runtime);
}

void entry_166368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166368 inside entry_1662e8 (0x1662e8 - 0x166388)
    ctx->pc = 0x166368;
    entry_1662e8(rdram, ctx, runtime);
}

void entry_166380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166380 inside entry_1662e8 (0x1662e8 - 0x166388)
    ctx->pc = 0x166380;
    entry_1662e8(rdram, ctx, runtime);
}

void entry_1663b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1663b8 inside entry_166394 (0x166394 - 0x1663e4)
    ctx->pc = 0x1663b8;
    entry_166394(rdram, ctx, runtime);
}

void entry_166428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166428 inside entry_1663fc (0x1663fc - 0x16644c)
    ctx->pc = 0x166428;
    entry_1663fc(rdram, ctx, runtime);
}

void entry_166440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166440 inside entry_1663fc (0x1663fc - 0x16644c)
    ctx->pc = 0x166440;
    entry_1663fc(rdram, ctx, runtime);
}

void entry_16646c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16646c inside entry_166464 (0x166464 - 0x166478)
    ctx->pc = 0x16646c;
    entry_166464(rdram, ctx, runtime);
}

void entry_16647c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16647c inside entry_166478 (0x166478 - 0x166488)
    ctx->pc = 0x16647c;
    entry_166478(rdram, ctx, runtime);
}

void entry_1664a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1664a0 inside entry_166498 (0x166498 - 0x1664b8)
    ctx->pc = 0x1664a0;
    entry_166498(rdram, ctx, runtime);
}

void entry_1664a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1664a4 inside entry_166498 (0x166498 - 0x1664b8)
    ctx->pc = 0x1664a4;
    entry_166498(rdram, ctx, runtime);
}

void entry_1664c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1664c0 inside entry_1664b8 (0x1664b8 - 0x1664cc)
    ctx->pc = 0x1664c0;
    entry_1664b8(rdram, ctx, runtime);
}

void entry_1664d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1664d0 inside entry_1664cc (0x1664cc - 0x166520)
    ctx->pc = 0x1664d0;
    entry_1664cc(rdram, ctx, runtime);
}

void entry_1664e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1664e4 inside entry_1664cc (0x1664cc - 0x166520)
    ctx->pc = 0x1664e4;
    entry_1664cc(rdram, ctx, runtime);
}

void entry_166508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166508 inside entry_1664cc (0x1664cc - 0x166520)
    ctx->pc = 0x166508;
    entry_1664cc(rdram, ctx, runtime);
}

void entry_1665b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1665b8 inside entry_1665a8 (0x1665a8 - 0x1665c0)
    ctx->pc = 0x1665b8;
    entry_1665a8(rdram, ctx, runtime);
}

void entry_166600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166600 inside entry_1665e0 (0x1665e0 - 0x166658)
    ctx->pc = 0x166600;
    entry_1665e0(rdram, ctx, runtime);
}

void entry_166628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166628 inside entry_1665e0 (0x1665e0 - 0x166658)
    ctx->pc = 0x166628;
    entry_1665e0(rdram, ctx, runtime);
}

void entry_16662c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16662c inside entry_1665e0 (0x1665e0 - 0x166658)
    ctx->pc = 0x16662c;
    entry_1665e0(rdram, ctx, runtime);
}

void entry_166630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166630 inside entry_1665e0 (0x1665e0 - 0x166658)
    ctx->pc = 0x166630;
    entry_1665e0(rdram, ctx, runtime);
}

void entry_166634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166634 inside entry_1665e0 (0x1665e0 - 0x166658)
    ctx->pc = 0x166634;
    entry_1665e0(rdram, ctx, runtime);
}

void entry_16676c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16676c inside entry_166704 (0x166704 - 0x16679c)
    ctx->pc = 0x16676c;
    entry_166704(rdram, ctx, runtime);
}

void entry_1667b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1667b4 inside entry_16679c (0x16679c - 0x1667e4)
    ctx->pc = 0x1667b4;
    entry_16679c(rdram, ctx, runtime);
}

void entry_1667f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1667f4 inside entry_1667e4 (0x1667e4 - 0x16683c)
    ctx->pc = 0x1667f4;
    entry_1667e4(rdram, ctx, runtime);
}

void entry_166840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166840 inside entry_16683c (0x16683c - 0x1668a0)
    ctx->pc = 0x166840;
    entry_16683c(rdram, ctx, runtime);
}

void entry_16686c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16686c inside entry_16683c (0x16683c - 0x1668a0)
    ctx->pc = 0x16686c;
    entry_16683c(rdram, ctx, runtime);
}

void entry_16687c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16687c inside entry_16683c (0x16683c - 0x1668a0)
    ctx->pc = 0x16687c;
    entry_16683c(rdram, ctx, runtime);
}

void entry_1668c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1668c0 inside entry_1668a0 (0x1668a0 - 0x166948)
    ctx->pc = 0x1668c0;
    entry_1668a0(rdram, ctx, runtime);
}

void entry_1668d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1668d4 inside entry_1668a0 (0x1668a0 - 0x166948)
    ctx->pc = 0x1668d4;
    entry_1668a0(rdram, ctx, runtime);
}

void entry_1668e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1668e0 inside entry_1668a0 (0x1668a0 - 0x166948)
    ctx->pc = 0x1668e0;
    entry_1668a0(rdram, ctx, runtime);
}

void entry_1668f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1668f0 inside entry_1668a0 (0x1668a0 - 0x166948)
    ctx->pc = 0x1668f0;
    entry_1668a0(rdram, ctx, runtime);
}

void entry_166914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166914 inside entry_1668a0 (0x1668a0 - 0x166948)
    ctx->pc = 0x166914;
    entry_1668a0(rdram, ctx, runtime);
}

void entry_166978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166978 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166978;
    entry_166948(rdram, ctx, runtime);
}

void entry_166984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166984 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166984;
    entry_166948(rdram, ctx, runtime);
}

void entry_1669c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1669c0 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x1669c0;
    entry_166948(rdram, ctx, runtime);
}

void entry_1669f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1669f0 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x1669f0;
    entry_166948(rdram, ctx, runtime);
}

void entry_166a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166a14 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166a14;
    entry_166948(rdram, ctx, runtime);
}

void entry_166a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166a20 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166a20;
    entry_166948(rdram, ctx, runtime);
}

void entry_166a24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166a24 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166a24;
    entry_166948(rdram, ctx, runtime);
}

void entry_166ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166ac0 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166ac0;
    entry_166948(rdram, ctx, runtime);
}

void entry_166b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166b10 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166b10;
    entry_166948(rdram, ctx, runtime);
}

void entry_166b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166b34 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166b34;
    entry_166948(rdram, ctx, runtime);
}

void entry_166ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166ba0 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166ba0;
    entry_166948(rdram, ctx, runtime);
}

void entry_166ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166ba4 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166ba4;
    entry_166948(rdram, ctx, runtime);
}

void entry_166bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166bb0 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166bb0;
    entry_166948(rdram, ctx, runtime);
}

void entry_166bd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166bd4 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166bd4;
    entry_166948(rdram, ctx, runtime);
}

void entry_166bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166bd8 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166bd8;
    entry_166948(rdram, ctx, runtime);
}

void entry_166c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166c88 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166c88;
    entry_166948(rdram, ctx, runtime);
}

void entry_166cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166cc4 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166cc4;
    entry_166948(rdram, ctx, runtime);
}

void entry_166cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166cf8 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166cf8;
    entry_166948(rdram, ctx, runtime);
}

void entry_166d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166d40 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166d40;
    entry_166948(rdram, ctx, runtime);
}

void entry_166d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166d90 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166d90;
    entry_166948(rdram, ctx, runtime);
}

void entry_166d94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166d94 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166d94;
    entry_166948(rdram, ctx, runtime);
}

void entry_166df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166df0 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166df0;
    entry_166948(rdram, ctx, runtime);
}

void entry_166e0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166e0c inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166e0c;
    entry_166948(rdram, ctx, runtime);
}

void entry_166e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166e18 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166e18;
    entry_166948(rdram, ctx, runtime);
}

void entry_166e4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166e4c inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166e4c;
    entry_166948(rdram, ctx, runtime);
}

void entry_166e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166e58 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166e58;
    entry_166948(rdram, ctx, runtime);
}

void entry_166e70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166e70 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166e70;
    entry_166948(rdram, ctx, runtime);
}

void entry_166e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166e90 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166e90;
    entry_166948(rdram, ctx, runtime);
}

void entry_166f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166f64 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166f64;
    entry_166948(rdram, ctx, runtime);
}

void entry_166f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x166f94 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x166f94;
    entry_166948(rdram, ctx, runtime);
}

void entry_167060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167060 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x167060;
    entry_166948(rdram, ctx, runtime);
}

void entry_1670a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1670a0 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x1670a0;
    entry_166948(rdram, ctx, runtime);
}

void entry_167140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167140 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x167140;
    entry_166948(rdram, ctx, runtime);
}

void entry_167168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167168 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x167168;
    entry_166948(rdram, ctx, runtime);
}

void entry_167200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167200 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x167200;
    entry_166948(rdram, ctx, runtime);
}

void entry_167240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167240 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x167240;
    entry_166948(rdram, ctx, runtime);
}

void entry_1672e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1672e0 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x1672e0;
    entry_166948(rdram, ctx, runtime);
}

void entry_167360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167360 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x167360;
    entry_166948(rdram, ctx, runtime);
}

void entry_1673a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1673a0 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x1673a0;
    entry_166948(rdram, ctx, runtime);
}

void entry_1674d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1674d0 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x1674d0;
    entry_166948(rdram, ctx, runtime);
}

void entry_167510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167510 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x167510;
    entry_166948(rdram, ctx, runtime);
}

void entry_167580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167580 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x167580;
    entry_166948(rdram, ctx, runtime);
}

void entry_1675b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1675b4 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x1675b4;
    entry_166948(rdram, ctx, runtime);
}

void entry_1675e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1675e4 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x1675e4;
    entry_166948(rdram, ctx, runtime);
}

void entry_167628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167628 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x167628;
    entry_166948(rdram, ctx, runtime);
}

void entry_16768c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16768c inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x16768c;
    entry_166948(rdram, ctx, runtime);
}

void entry_1676e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1676e4 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x1676e4;
    entry_166948(rdram, ctx, runtime);
}

void entry_16770c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16770c inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x16770c;
    entry_166948(rdram, ctx, runtime);
}

void entry_16773c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16773c inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x16773c;
    entry_166948(rdram, ctx, runtime);
}

void entry_167764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167764 inside entry_166948 (0x166948 - 0x167784)
    ctx->pc = 0x167764;
    entry_166948(rdram, ctx, runtime);
}

void entry_167794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167794 inside entry_167784 (0x167784 - 0x1677c4)
    ctx->pc = 0x167794;
    entry_167784(rdram, ctx, runtime);
}

void entry_1677a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1677a8 inside entry_167784 (0x167784 - 0x1677c4)
    ctx->pc = 0x1677a8;
    entry_167784(rdram, ctx, runtime);
}

void entry_1677b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1677b8 inside entry_167784 (0x167784 - 0x1677c4)
    ctx->pc = 0x1677b8;
    entry_167784(rdram, ctx, runtime);
}

void entry_1677cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1677cc inside entry_1677c4 (0x1677c4 - 0x1677dc)
    ctx->pc = 0x1677cc;
    entry_1677c4(rdram, ctx, runtime);
}

void entry_1677f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1677f0 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x1677f0;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167804 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167804;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167818 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167818;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167834(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167834 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167834;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167870 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167870;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_1678c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1678c8 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x1678c8;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167904 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167904;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167908 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167908;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167940 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167940;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_16797c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16797c inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x16797c;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167a20 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167a20;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167a5c inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167a5c;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167a90 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167a90;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167ad8 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167ad8;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167b28 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167b28;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167b2c inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167b2c;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167b88 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167b88;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167ba4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167ba4 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167ba4;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167bb0 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167bb0;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167be4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167be4 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167be4;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167bf0 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167bf0;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167c20 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167c20;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167c70 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167c70;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167c90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167c90 inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167c90;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167cec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167cec inside entry_1677ec (0x1677ec - 0x167d20)
    ctx->pc = 0x167cec;
    entry_1677ec(rdram, ctx, runtime);
}

void entry_167d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167d40 inside glob__static_initialization_and_destruction_0 (0x167d20 - 0x167d48)
    ctx->pc = 0x167d40;
    glob__static_initialization_and_destruction_0(rdram, ctx, runtime);
}

void entry_167e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167e44 inside entry_167e3c (0x167e3c - 0x167e58)
    ctx->pc = 0x167e44;
    entry_167e3c(rdram, ctx, runtime);
}

void entry_167e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167e60 inside entry_167e58 (0x167e58 - 0x167e70)
    ctx->pc = 0x167e60;
    entry_167e58(rdram, ctx, runtime);
}

void entry_167e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167e90 inside entry_167e84 (0x167e84 - 0x167eb0)
    ctx->pc = 0x167e90;
    entry_167e84(rdram, ctx, runtime);
}

void entry_167ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167ec4 inside entry_167ec0 (0x167ec0 - 0x167edc)
    ctx->pc = 0x167ec4;
    entry_167ec0(rdram, ctx, runtime);
}

void entry_167ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167ed4 inside entry_167ec0 (0x167ec0 - 0x167edc)
    ctx->pc = 0x167ed4;
    entry_167ec0(rdram, ctx, runtime);
}

void entry_167ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167ee0 inside entry_167edc (0x167edc - 0x167ef0)
    ctx->pc = 0x167ee0;
    entry_167edc(rdram, ctx, runtime);
}

void entry_167fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167fa8 inside entry_167f98 (0x167f98 - 0x167fb8)
    ctx->pc = 0x167fa8;
    entry_167f98(rdram, ctx, runtime);
}

void entry_167fc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167fc0 inside entry_167fb8 (0x167fb8 - 0x168050)
    ctx->pc = 0x167fc0;
    entry_167fb8(rdram, ctx, runtime);
}

void entry_167fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x167fe8 inside entry_167fb8 (0x167fb8 - 0x168050)
    ctx->pc = 0x167fe8;
    entry_167fb8(rdram, ctx, runtime);
}

void entry_168024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168024 inside entry_167fb8 (0x167fb8 - 0x168050)
    ctx->pc = 0x168024;
    entry_167fb8(rdram, ctx, runtime);
}

void entry_168034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168034 inside entry_167fb8 (0x167fb8 - 0x168050)
    ctx->pc = 0x168034;
    entry_167fb8(rdram, ctx, runtime);
}

void entry_16805c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16805c inside entry_168050 (0x168050 - 0x1680e0)
    ctx->pc = 0x16805c;
    entry_168050(rdram, ctx, runtime);
}

void entry_1680b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1680b0 inside entry_168050 (0x168050 - 0x1680e0)
    ctx->pc = 0x1680b0;
    entry_168050(rdram, ctx, runtime);
}

void entry_1680d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1680d8 inside entry_168050 (0x168050 - 0x1680e0)
    ctx->pc = 0x1680d8;
    entry_168050(rdram, ctx, runtime);
}

void entry_1680f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1680f4 inside entry_1680e0 (0x1680e0 - 0x1680fc)
    ctx->pc = 0x1680f4;
    entry_1680e0(rdram, ctx, runtime);
}

void entry_168114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168114 inside entry_1680fc (0x1680fc - 0x168130)
    ctx->pc = 0x168114;
    entry_1680fc(rdram, ctx, runtime);
}

void entry_168118(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168118 inside entry_1680fc (0x1680fc - 0x168130)
    ctx->pc = 0x168118;
    entry_1680fc(rdram, ctx, runtime);
}

void entry_168220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168220 inside BlendDisplayOnBufferMismatch__Fv (0x168130 - 0x1682c0)
    ctx->pc = 0x168220;
    BlendDisplayOnBufferMismatch__Fv(rdram, ctx, runtime);
}

void entry_16825c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16825c inside BlendDisplayOnBufferMismatch__Fv (0x168130 - 0x1682c0)
    ctx->pc = 0x16825c;
    BlendDisplayOnBufferMismatch__Fv(rdram, ctx, runtime);
}

void entry_16829c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16829c inside BlendDisplayOnBufferMismatch__Fv (0x168130 - 0x1682c0)
    ctx->pc = 0x16829c;
    BlendDisplayOnBufferMismatch__Fv(rdram, ctx, runtime);
}

void entry_168310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168310 inside entry_1682e4 (0x1682e4 - 0x168340)
    ctx->pc = 0x168310;
    entry_1682e4(rdram, ctx, runtime);
}

void entry_168324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168324 inside entry_1682e4 (0x1682e4 - 0x168340)
    ctx->pc = 0x168324;
    entry_1682e4(rdram, ctx, runtime);
}

void entry_168348(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168348 inside entry_168340 (0x168340 - 0x168360)
    ctx->pc = 0x168348;
    entry_168340(rdram, ctx, runtime);
}

void entry_168368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168368 inside entry_168360 (0x168360 - 0x16839c)
    ctx->pc = 0x168368;
    entry_168360(rdram, ctx, runtime);
}

void entry_168438(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168438 inside entry_168404 (0x168404 - 0x168488)
    ctx->pc = 0x168438;
    entry_168404(rdram, ctx, runtime);
}

void entry_168450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168450 inside entry_168404 (0x168404 - 0x168488)
    ctx->pc = 0x168450;
    entry_168404(rdram, ctx, runtime);
}

void entry_168470(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168470 inside entry_168404 (0x168404 - 0x168488)
    ctx->pc = 0x168470;
    entry_168404(rdram, ctx, runtime);
}

void entry_168478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168478 inside entry_168404 (0x168404 - 0x168488)
    ctx->pc = 0x168478;
    entry_168404(rdram, ctx, runtime);
}

void entry_1684cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1684cc inside entry_1684c8 (0x1684c8 - 0x1684d4)
    ctx->pc = 0x1684cc;
    entry_1684c8(rdram, ctx, runtime);
}

void entry_16850c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16850c inside RestoreGsBuffers__Fv (0x1684e8 - 0x168574)
    ctx->pc = 0x16850c;
    RestoreGsBuffers__Fv(rdram, ctx, runtime);
}

void entry_16855c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16855c inside RestoreGsBuffers__Fv (0x1684e8 - 0x168574)
    ctx->pc = 0x16855c;
    RestoreGsBuffers__Fv(rdram, ctx, runtime);
}

void entry_168564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168564 inside RestoreGsBuffers__Fv (0x1684e8 - 0x168574)
    ctx->pc = 0x168564;
    RestoreGsBuffers__Fv(rdram, ctx, runtime);
}

void entry_168594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168594 inside entry_16857c (0x16857c - 0x1685a4)
    ctx->pc = 0x168594;
    entry_16857c(rdram, ctx, runtime);
}

void entry_16859c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16859c inside entry_16857c (0x16857c - 0x1685a4)
    ctx->pc = 0x16859c;
    entry_16857c(rdram, ctx, runtime);
}

void entry_16864c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16864c inside entry_1685f4 (0x1685f4 - 0x168664)
    ctx->pc = 0x16864c;
    entry_1685f4(rdram, ctx, runtime);
}

void entry_168654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168654 inside entry_1685f4 (0x1685f4 - 0x168664)
    ctx->pc = 0x168654;
    entry_1685f4(rdram, ctx, runtime);
}

void entry_168848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168848 inside entry_168844 (0x168844 - 0x168854)
    ctx->pc = 0x168848;
    entry_168844(rdram, ctx, runtime);
}

void entry_168918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168918 inside entry_168904 (0x168904 - 0x168978)
    ctx->pc = 0x168918;
    entry_168904(rdram, ctx, runtime);
}

void entry_168a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168a90 inside entry_168a84 (0x168a84 - 0x168aac)
    ctx->pc = 0x168a90;
    entry_168a84(rdram, ctx, runtime);
}

void entry_168aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168aa4 inside entry_168a84 (0x168a84 - 0x168aac)
    ctx->pc = 0x168aa4;
    entry_168a84(rdram, ctx, runtime);
}

void entry_168bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168bf8 inside entry_168bc4 (0x168bc4 - 0x168c2c)
    ctx->pc = 0x168bf8;
    entry_168bc4(rdram, ctx, runtime);
}

void entry_168ccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168ccc inside entry_168cc0 (0x168cc0 - 0x168d00)
    ctx->pc = 0x168ccc;
    entry_168cc0(rdram, ctx, runtime);
}

void entry_168d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168d48 inside NLog2__FUi (0x168d30 - 0x168d68)
    ctx->pc = 0x168d48;
    NLog2__FUi(rdram, ctx, runtime);
}

void entry_168d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168d60 inside NLog2__FUi (0x168d30 - 0x168d68)
    ctx->pc = 0x168d60;
    NLog2__FUi(rdram, ctx, runtime);
}

void entry_168f94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x168f94 inside BuildClutGifs__FP4CLUTiP4GIFS (0x168f48 - 0x168fa4)
    ctx->pc = 0x168f94;
    BuildClutGifs__FP4CLUTiP4GIFS(rdram, ctx, runtime);
}

void entry_169108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169108 inside FBuildUploadBitmapGifs__FiP3GSBP4GIFS (0x1690c0 - 0x16914c)
    ctx->pc = 0x169108;
    FBuildUploadBitmapGifs__FiP3GSBP4GIFS(rdram, ctx, runtime);
}

void entry_169128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169128 inside FBuildUploadBitmapGifs__FiP3GSBP4GIFS (0x1690c0 - 0x16914c)
    ctx->pc = 0x169128;
    FBuildUploadBitmapGifs__FiP3GSBP4GIFS(rdram, ctx, runtime);
}

void entry_169184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169184 inside entry_169180 (0x169180 - 0x1691b4)
    ctx->pc = 0x169184;
    entry_169180(rdram, ctx, runtime);
}

void entry_169198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169198 inside entry_169180 (0x169180 - 0x1691b4)
    ctx->pc = 0x169198;
    entry_169180(rdram, ctx, runtime);
}

void entry_1691d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1691d0 inside entry_1691b4 (0x1691b4 - 0x169210)
    ctx->pc = 0x1691d0;
    entry_1691b4(rdram, ctx, runtime);
}

void entry_169214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169214 inside entry_169210 (0x169210 - 0x16921c)
    ctx->pc = 0x169214;
    entry_169210(rdram, ctx, runtime);
}

void entry_169254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169254 inside entry_169250 (0x169250 - 0x1692b0)
    ctx->pc = 0x169254;
    entry_169250(rdram, ctx, runtime);
}

void entry_169264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169264 inside entry_169250 (0x169250 - 0x1692b0)
    ctx->pc = 0x169264;
    entry_169250(rdram, ctx, runtime);
}

void entry_16927c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16927c inside entry_169250 (0x169250 - 0x1692b0)
    ctx->pc = 0x16927c;
    entry_169250(rdram, ctx, runtime);
}

void entry_169280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169280 inside entry_169250 (0x169250 - 0x1692b0)
    ctx->pc = 0x169280;
    entry_169250(rdram, ctx, runtime);
}

void entry_1694ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1694ec inside entry_1694c0 (0x1694c0 - 0x1694f8)
    ctx->pc = 0x1694ec;
    entry_1694c0(rdram, ctx, runtime);
}

void entry_169528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169528 inside ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI (0x1694f8 - 0x1695bc)
    ctx->pc = 0x169528;
    ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI(rdram, ctx, runtime);
}

void entry_16955c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16955c inside ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI (0x1694f8 - 0x1695bc)
    ctx->pc = 0x16955c;
    ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI(rdram, ctx, runtime);
}

void entry_169568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169568 inside ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI (0x1694f8 - 0x1695bc)
    ctx->pc = 0x169568;
    ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI(rdram, ctx, runtime);
}

void entry_16956c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16956c inside ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI (0x1694f8 - 0x1695bc)
    ctx->pc = 0x16956c;
    ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI(rdram, ctx, runtime);
}

void entry_169570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169570 inside ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI (0x1694f8 - 0x1695bc)
    ctx->pc = 0x169570;
    ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI(rdram, ctx, runtime);
}

void entry_169584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169584 inside ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI (0x1694f8 - 0x1695bc)
    ctx->pc = 0x169584;
    ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI(rdram, ctx, runtime);
}

void entry_169594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169594 inside ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI (0x1694f8 - 0x1695bc)
    ctx->pc = 0x169594;
    ReferenceShaderAqwRegs__FP3SHDP4SHDPP2QWiiP3SAI(rdram, ctx, runtime);
}

void entry_1695ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1695ec inside entry_1695cc (0x1695cc - 0x169608)
    ctx->pc = 0x1695ec;
    entry_1695cc(rdram, ctx, runtime);
}

void entry_169640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169640 inside ReferenceUVAnimation__FP2QWiP3SAI (0x169608 - 0x169674)
    ctx->pc = 0x169640;
    ReferenceUVAnimation__FP2QWiP3SAI(rdram, ctx, runtime);
}

void entry_169658(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169658 inside ReferenceUVAnimation__FP2QWiP3SAI (0x169608 - 0x169674)
    ctx->pc = 0x169658;
    ReferenceUVAnimation__FP2QWiP3SAI(rdram, ctx, runtime);
}

void entry_1696a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1696a4 inside entry_16968c (0x16968c - 0x1696b8)
    ctx->pc = 0x1696a4;
    entry_16968c(rdram, ctx, runtime);
}

void entry_1696e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1696e0 inside RebaseSurs__FiiPvT2 (0x1696b8 - 0x169718)
    ctx->pc = 0x1696e0;
    RebaseSurs__FiiPvT2(rdram, ctx, runtime);
}

void entry_169704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169704 inside RebaseSurs__FiiPvT2 (0x1696b8 - 0x169718)
    ctx->pc = 0x169704;
    RebaseSurs__FiiPvT2(rdram, ctx, runtime);
}

void entry_169708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169708 inside RebaseSurs__FiiPvT2 (0x1696b8 - 0x169718)
    ctx->pc = 0x169708;
    RebaseSurs__FiiPvT2(rdram, ctx, runtime);
}

void entry_169710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169710 inside RebaseSurs__FiiPvT2 (0x1696b8 - 0x169718)
    ctx->pc = 0x169710;
    RebaseSurs__FiiPvT2(rdram, ctx, runtime);
}

void entry_169748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169748 inside PropagateSurs__Fv (0x169718 - 0x169754)
    ctx->pc = 0x169748;
    PropagateSurs__Fv(rdram, ctx, runtime);
}

void entry_169764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169764 inside entry_169754 (0x169754 - 0x169780)
    ctx->pc = 0x169764;
    entry_169754(rdram, ctx, runtime);
}

void entry_169848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169848 inside entry_16982c (0x16982c - 0x16986c)
    ctx->pc = 0x169848;
    entry_16982c(rdram, ctx, runtime);
}

void entry_169908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169908 inside entry_1698f4 (0x1698f4 - 0x169964)
    ctx->pc = 0x169908;
    entry_1698f4(rdram, ctx, runtime);
}

void entry_16990c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16990c inside entry_1698f4 (0x1698f4 - 0x169964)
    ctx->pc = 0x16990c;
    entry_1698f4(rdram, ctx, runtime);
}

void entry_169924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169924 inside entry_1698f4 (0x1698f4 - 0x169964)
    ctx->pc = 0x169924;
    entry_1698f4(rdram, ctx, runtime);
}

void entry_169940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169940 inside entry_1698f4 (0x1698f4 - 0x169964)
    ctx->pc = 0x169940;
    entry_1698f4(rdram, ctx, runtime);
}

void entry_1699fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1699fc inside entry_1699e8 (0x1699e8 - 0x169a30)
    ctx->pc = 0x1699fc;
    entry_1699e8(rdram, ctx, runtime);
}

void entry_169a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169a00 inside entry_1699e8 (0x1699e8 - 0x169a30)
    ctx->pc = 0x169a00;
    entry_1699e8(rdram, ctx, runtime);
}

void entry_169a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169a14 inside entry_1699e8 (0x1699e8 - 0x169a30)
    ctx->pc = 0x169a14;
    entry_1699e8(rdram, ctx, runtime);
}

void entry_169dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169dc8 inside entry_169dbc (0x169dbc - 0x169dd8)
    ctx->pc = 0x169dc8;
    entry_169dbc(rdram, ctx, runtime);
}

void entry_169ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169ea8 inside entry_169e8c (0x169e8c - 0x169f78)
    ctx->pc = 0x169ea8;
    entry_169e8c(rdram, ctx, runtime);
}

void entry_169eb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169eb8 inside entry_169e8c (0x169e8c - 0x169f78)
    ctx->pc = 0x169eb8;
    entry_169e8c(rdram, ctx, runtime);
}

void entry_169ec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169ec8 inside entry_169e8c (0x169e8c - 0x169f78)
    ctx->pc = 0x169ec8;
    entry_169e8c(rdram, ctx, runtime);
}

void entry_169ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169ecc inside entry_169e8c (0x169e8c - 0x169f78)
    ctx->pc = 0x169ecc;
    entry_169e8c(rdram, ctx, runtime);
}

void entry_169f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169f4c inside entry_169e8c (0x169e8c - 0x169f78)
    ctx->pc = 0x169f4c;
    entry_169e8c(rdram, ctx, runtime);
}

void entry_169f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169f58 inside entry_169e8c (0x169e8c - 0x169f78)
    ctx->pc = 0x169f58;
    entry_169e8c(rdram, ctx, runtime);
}

void entry_169f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169f64 inside entry_169e8c (0x169e8c - 0x169f78)
    ctx->pc = 0x169f64;
    entry_169e8c(rdram, ctx, runtime);
}

void entry_169fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169fa4 inside entry_169fa0 (0x169fa0 - 0x169fc0)
    ctx->pc = 0x169fa4;
    entry_169fa0(rdram, ctx, runtime);
}

void entry_169fa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x169fa8 inside entry_169fa0 (0x169fa0 - 0x169fc0)
    ctx->pc = 0x169fa8;
    entry_169fa0(rdram, ctx, runtime);
}

void entry_16a0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a0a4 inside entry_16a088 (0x16a088 - 0x16a0cc)
    ctx->pc = 0x16a0a4;
    entry_16a088(rdram, ctx, runtime);
}

void entry_16a0b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a0b4 inside entry_16a088 (0x16a088 - 0x16a0cc)
    ctx->pc = 0x16a0b4;
    entry_16a088(rdram, ctx, runtime);
}

void entry_16a0bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a0bc inside entry_16a088 (0x16a088 - 0x16a0cc)
    ctx->pc = 0x16a0bc;
    entry_16a088(rdram, ctx, runtime);
}

void entry_16a1e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a1e8 inside entry_16a1dc (0x16a1dc - 0x16a1f8)
    ctx->pc = 0x16a1e8;
    entry_16a1dc(rdram, ctx, runtime);
}

void entry_16a28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a28c inside GetHpntClosestHidePos__FP4HPNTP6VECTORPf (0x16a240 - 0x16a2b8)
    ctx->pc = 0x16a28c;
    GetHpntClosestHidePos__FP4HPNTP6VECTORPf(rdram, ctx, runtime);
}

void entry_16a29c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a29c inside GetHpntClosestHidePos__FP4HPNTP6VECTORPf (0x16a240 - 0x16a2b8)
    ctx->pc = 0x16a29c;
    GetHpntClosestHidePos__FP4HPNTP6VECTORPf(rdram, ctx, runtime);
}

void entry_16a2a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a2a8 inside GetHpntClosestHidePos__FP4HPNTP6VECTORPf (0x16a240 - 0x16a2b8)
    ctx->pc = 0x16a2a8;
    GetHpntClosestHidePos__FP4HPNTP6VECTORPf(rdram, ctx, runtime);
}

void entry_16a2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a2d4 inside entry_16a2c4 (0x16a2c4 - 0x16a300)
    ctx->pc = 0x16a2d4;
    entry_16a2c4(rdram, ctx, runtime);
}

void entry_16a304(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a304 inside entry_16a300 (0x16a300 - 0x16a320)
    ctx->pc = 0x16a304;
    entry_16a300(rdram, ctx, runtime);
}

void entry_16a308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a308 inside entry_16a300 (0x16a300 - 0x16a320)
    ctx->pc = 0x16a308;
    entry_16a300(rdram, ctx, runtime);
}

void entry_16a450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a450 inside entry_16a448 (0x16a448 - 0x16a490)
    ctx->pc = 0x16a450;
    entry_16a448(rdram, ctx, runtime);
}

void entry_16a568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a568 inside FIgnoreHbskIntersection__FP4HBSKP2SO (0x16a548 - 0x16a570)
    ctx->pc = 0x16a568;
    FIgnoreHbskIntersection__FP4HBSKP2SO(rdram, ctx, runtime);
}

void entry_16a5dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a5dc inside entry_16a5d8 (0x16a5d8 - 0x16a5f0)
    ctx->pc = 0x16a5dc;
    entry_16a5d8(rdram, ctx, runtime);
}

void entry_16a72c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a72c inside entry_16a728 (0x16a728 - 0x16a758)
    ctx->pc = 0x16a72c;
    entry_16a728(rdram, ctx, runtime);
}

void entry_16a738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a738 inside entry_16a728 (0x16a728 - 0x16a758)
    ctx->pc = 0x16a738;
    entry_16a728(rdram, ctx, runtime);
}

void entry_16a7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a7b8 inside CdartStuckHbsk__FP4HBSK (0x16a758 - 0x16a7c4)
    ctx->pc = 0x16a7b8;
    CdartStuckHbsk__FP4HBSK(rdram, ctx, runtime);
}

void entry_16a7dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a7dc inside entry_16a7c4 (0x16a7c4 - 0x16a820)
    ctx->pc = 0x16a7dc;
    entry_16a7c4(rdram, ctx, runtime);
}

void entry_16a7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a7f8 inside entry_16a7c4 (0x16a7c4 - 0x16a820)
    ctx->pc = 0x16a7f8;
    entry_16a7c4(rdram, ctx, runtime);
}

void entry_16a888(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a888 inside PdartOldestHbskStuck__FP4HBSK (0x16a820 - 0x16a894)
    ctx->pc = 0x16a888;
    PdartOldestHbskStuck__FP4HBSK(rdram, ctx, runtime);
}

void entry_16a8c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a8c8 inside entry_16a894 (0x16a894 - 0x16a910)
    ctx->pc = 0x16a8c8;
    entry_16a894(rdram, ctx, runtime);
}

void entry_16a8cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a8cc inside entry_16a894 (0x16a894 - 0x16a910)
    ctx->pc = 0x16a8cc;
    entry_16a894(rdram, ctx, runtime);
}

void entry_16a8e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a8e0 inside entry_16a894 (0x16a894 - 0x16a910)
    ctx->pc = 0x16a8e0;
    entry_16a894(rdram, ctx, runtime);
}

void entry_16a9b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a9b8 inside entry_16a934 (0x16a934 - 0x16a9e4)
    ctx->pc = 0x16a9b8;
    entry_16a934(rdram, ctx, runtime);
}

void entry_16a9c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a9c4 inside entry_16a934 (0x16a934 - 0x16a9e4)
    ctx->pc = 0x16a9c4;
    entry_16a934(rdram, ctx, runtime);
}

void entry_16a9d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16a9d0 inside entry_16a934 (0x16a934 - 0x16a9e4)
    ctx->pc = 0x16a9d0;
    entry_16a934(rdram, ctx, runtime);
}

void entry_16aa00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16aa00 inside entry_16a9f8 (0x16a9f8 - 0x16aa18)
    ctx->pc = 0x16aa00;
    entry_16a9f8(rdram, ctx, runtime);
}

void entry_16aa90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16aa90 inside entry_16aa5c (0x16aa5c - 0x16aac0)
    ctx->pc = 0x16aa90;
    entry_16aa5c(rdram, ctx, runtime);
}

void entry_16aab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16aab8 inside entry_16aa5c (0x16aa5c - 0x16aac0)
    ctx->pc = 0x16aab8;
    entry_16aa5c(rdram, ctx, runtime);
}

void entry_16aae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16aae0 inside entry_16aacc (0x16aacc - 0x16ab00)
    ctx->pc = 0x16aae0;
    entry_16aacc(rdram, ctx, runtime);
}

void entry_16aae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16aae4 inside entry_16aacc (0x16aacc - 0x16ab00)
    ctx->pc = 0x16aae4;
    entry_16aacc(rdram, ctx, runtime);
}

void entry_16ab0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ab0c inside entry_16ab00 (0x16ab00 - 0x16ab38)
    ctx->pc = 0x16ab0c;
    entry_16ab00(rdram, ctx, runtime);
}

void entry_16ab84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ab84 inside entry_16ab80 (0x16ab80 - 0x16ab9c)
    ctx->pc = 0x16ab84;
    entry_16ab80(rdram, ctx, runtime);
}

void entry_16aba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16aba0 inside entry_16ab9c (0x16ab9c - 0x16abb8)
    ctx->pc = 0x16aba0;
    entry_16ab9c(rdram, ctx, runtime);
}

void entry_16abbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16abbc inside entry_16abb8 (0x16abb8 - 0x16abd4)
    ctx->pc = 0x16abbc;
    entry_16abb8(rdram, ctx, runtime);
}

void entry_16abd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16abd8 inside entry_16abd4 (0x16abd4 - 0x16ac90)
    ctx->pc = 0x16abd8;
    entry_16abd4(rdram, ctx, runtime);
}

void entry_16abf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16abf0 inside entry_16abd4 (0x16abd4 - 0x16ac90)
    ctx->pc = 0x16abf0;
    entry_16abd4(rdram, ctx, runtime);
}

void entry_16ac48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ac48 inside entry_16abd4 (0x16abd4 - 0x16ac90)
    ctx->pc = 0x16ac48;
    entry_16abd4(rdram, ctx, runtime);
}

void entry_16ac60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ac60 inside entry_16abd4 (0x16abd4 - 0x16ac90)
    ctx->pc = 0x16ac60;
    entry_16abd4(rdram, ctx, runtime);
}

void entry_16ac94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ac94 inside entry_16ac90 (0x16ac90 - 0x16ad20)
    ctx->pc = 0x16ac94;
    entry_16ac90(rdram, ctx, runtime);
}

void entry_16aca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16aca8 inside entry_16ac90 (0x16ac90 - 0x16ad20)
    ctx->pc = 0x16aca8;
    entry_16ac90(rdram, ctx, runtime);
}

void entry_16acc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16acc0 inside entry_16ac90 (0x16ac90 - 0x16ad20)
    ctx->pc = 0x16acc0;
    entry_16ac90(rdram, ctx, runtime);
}

void entry_16ad00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ad00 inside entry_16ac90 (0x16ac90 - 0x16ad20)
    ctx->pc = 0x16ad00;
    entry_16ac90(rdram, ctx, runtime);
}

void entry_16ad18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ad18 inside entry_16ac90 (0x16ac90 - 0x16ad20)
    ctx->pc = 0x16ad18;
    entry_16ac90(rdram, ctx, runtime);
}

void entry_16ad28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ad28 inside entry_16ad20 (0x16ad20 - 0x16ad30)
    ctx->pc = 0x16ad28;
    entry_16ad20(rdram, ctx, runtime);
}

void entry_16ad38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ad38 inside entry_16ad30 (0x16ad30 - 0x16ad40)
    ctx->pc = 0x16ad38;
    entry_16ad30(rdram, ctx, runtime);
}

void entry_16ad44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ad44 inside entry_16ad40 (0x16ad40 - 0x16adfc)
    ctx->pc = 0x16ad44;
    entry_16ad40(rdram, ctx, runtime);
}

void entry_16ad48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ad48 inside entry_16ad40 (0x16ad40 - 0x16adfc)
    ctx->pc = 0x16ad48;
    entry_16ad40(rdram, ctx, runtime);
}

void entry_16ad50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ad50 inside entry_16ad40 (0x16ad40 - 0x16adfc)
    ctx->pc = 0x16ad50;
    entry_16ad40(rdram, ctx, runtime);
}

void entry_16ad5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ad5c inside entry_16ad40 (0x16ad40 - 0x16adfc)
    ctx->pc = 0x16ad5c;
    entry_16ad40(rdram, ctx, runtime);
}

void entry_16ad70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ad70 inside entry_16ad40 (0x16ad40 - 0x16adfc)
    ctx->pc = 0x16ad70;
    entry_16ad40(rdram, ctx, runtime);
}

void entry_16ad78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ad78 inside entry_16ad40 (0x16ad40 - 0x16adfc)
    ctx->pc = 0x16ad78;
    entry_16ad40(rdram, ctx, runtime);
}

void entry_16adac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16adac inside entry_16ad40 (0x16ad40 - 0x16adfc)
    ctx->pc = 0x16adac;
    entry_16ad40(rdram, ctx, runtime);
}

void entry_16ade0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ade0 inside entry_16ad40 (0x16ad40 - 0x16adfc)
    ctx->pc = 0x16ade0;
    entry_16ad40(rdram, ctx, runtime);
}

void entry_16adf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16adf0 inside entry_16ad40 (0x16ad40 - 0x16adfc)
    ctx->pc = 0x16adf0;
    entry_16ad40(rdram, ctx, runtime);
}

void entry_16adf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16adf4 inside entry_16ad40 (0x16ad40 - 0x16adfc)
    ctx->pc = 0x16adf4;
    entry_16ad40(rdram, ctx, runtime);
}

void entry_16ae18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ae18 inside entry_16adfc (0x16adfc - 0x16ae74)
    ctx->pc = 0x16ae18;
    entry_16adfc(rdram, ctx, runtime);
}

void entry_16ae50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ae50 inside entry_16adfc (0x16adfc - 0x16ae74)
    ctx->pc = 0x16ae50;
    entry_16adfc(rdram, ctx, runtime);
}

void entry_16ae9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ae9c inside entry_16ae98 (0x16ae98 - 0x16aea4)
    ctx->pc = 0x16ae9c;
    entry_16ae98(rdram, ctx, runtime);
}

void entry_16afc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16afc0 inside hideout_set_focus (0x16af80 - 0x16b00c)
    ctx->pc = 0x16afc0;
    hideout_set_focus(rdram, ctx, runtime);
}

void entry_16afe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16afe0 inside hideout_set_focus (0x16af80 - 0x16b00c)
    ctx->pc = 0x16afe0;
    hideout_set_focus(rdram, ctx, runtime);
}

void entry_16b014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b014 inside entry_16b00c (0x16b00c - 0x16b040)
    ctx->pc = 0x16b014;
    entry_16b00c(rdram, ctx, runtime);
}

void entry_16b030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b030 inside entry_16b00c (0x16b00c - 0x16b040)
    ctx->pc = 0x16b030;
    entry_16b00c(rdram, ctx, runtime);
}

void entry_16b048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b048 inside entry_16b040 (0x16b040 - 0x16b068)
    ctx->pc = 0x16b048;
    entry_16b040(rdram, ctx, runtime);
}

void entry_16b06c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b06c inside entry_16b068 (0x16b068 - 0x16b078)
    ctx->pc = 0x16b06c;
    entry_16b068(rdram, ctx, runtime);
}

void entry_16b0c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b0c8 inside entry_16b0c0 (0x16b0c0 - 0x16b0dc)
    ctx->pc = 0x16b0c8;
    entry_16b0c0(rdram, ctx, runtime);
}

void entry_16b0e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b0e0 inside entry_16b0dc (0x16b0dc - 0x16b0f8)
    ctx->pc = 0x16b0e0;
    entry_16b0dc(rdram, ctx, runtime);
}

void entry_16b14c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b14c inside entry_16b118 (0x16b118 - 0x16b178)
    ctx->pc = 0x16b14c;
    entry_16b118(rdram, ctx, runtime);
}

void entry_16b168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b168 inside entry_16b118 (0x16b118 - 0x16b178)
    ctx->pc = 0x16b168;
    entry_16b118(rdram, ctx, runtime);
}

void entry_16b24c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b24c inside entry_16b244 (0x16b244 - 0x16b258)
    ctx->pc = 0x16b24c;
    entry_16b244(rdram, ctx, runtime);
}

void entry_16b250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b250 inside entry_16b244 (0x16b244 - 0x16b258)
    ctx->pc = 0x16b250;
    entry_16b244(rdram, ctx, runtime);
}

void entry_16b274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b274 inside entry_16b258 (0x16b258 - 0x16b284)
    ctx->pc = 0x16b274;
    entry_16b258(rdram, ctx, runtime);
}

void entry_16b28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b28c inside entry_16b284 (0x16b284 - 0x16b2a0)
    ctx->pc = 0x16b28c;
    entry_16b284(rdram, ctx, runtime);
}

void entry_16b290(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b290 inside entry_16b284 (0x16b284 - 0x16b2a0)
    ctx->pc = 0x16b290;
    entry_16b284(rdram, ctx, runtime);
}

void entry_16b2a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b2a8 inside entry_16b2a0 (0x16b2a0 - 0x16b2cc)
    ctx->pc = 0x16b2a8;
    entry_16b2a0(rdram, ctx, runtime);
}

void entry_16b340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b340 inside something (0x16b300 - 0x16b3e4)
    ctx->pc = 0x16b340;
    something(rdram, ctx, runtime);
}

void entry_16b394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b394 inside something (0x16b300 - 0x16b3e4)
    ctx->pc = 0x16b394;
    something(rdram, ctx, runtime);
}

void entry_16b3d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b3d4 inside something (0x16b300 - 0x16b3e4)
    ctx->pc = 0x16b3d4;
    something(rdram, ctx, runtime);
}

void entry_16b3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b3f4 inside entry_16b3ec (0x16b3ec - 0x16b42c)
    ctx->pc = 0x16b3f4;
    entry_16b3ec(rdram, ctx, runtime);
}

void entry_16b3f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b3f8 inside entry_16b3ec (0x16b3ec - 0x16b42c)
    ctx->pc = 0x16b3f8;
    entry_16b3ec(rdram, ctx, runtime);
}

void entry_16b444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b444 inside entry_16b43c (0x16b43c - 0x16b464)
    ctx->pc = 0x16b444;
    entry_16b43c(rdram, ctx, runtime);
}

void entry_16b468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b468 inside entry_16b464 (0x16b464 - 0x16b4a0)
    ctx->pc = 0x16b468;
    entry_16b464(rdram, ctx, runtime);
}

void entry_16b47c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b47c inside entry_16b464 (0x16b464 - 0x16b4a0)
    ctx->pc = 0x16b47c;
    entry_16b464(rdram, ctx, runtime);
}

void entry_16b4dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b4dc inside entry_16b4d4 (0x16b4d4 - 0x16b4e8)
    ctx->pc = 0x16b4dc;
    entry_16b4d4(rdram, ctx, runtime);
}

void entry_16b558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b558 inside entry_16b554 (0x16b554 - 0x16b560)
    ctx->pc = 0x16b558;
    entry_16b554(rdram, ctx, runtime);
}

void entry_16b5e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b5e4 inside entry_16b5dc (0x16b5dc - 0x16b624)
    ctx->pc = 0x16b5e4;
    entry_16b5dc(rdram, ctx, runtime);
}

void entry_16b630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b630 inside entry_16b62c (0x16b62c - 0x16b638)
    ctx->pc = 0x16b630;
    entry_16b62c(rdram, ctx, runtime);
}

void entry_16b680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b680 inside entry_16b638 (0x16b638 - 0x16b6ac)
    ctx->pc = 0x16b680;
    entry_16b638(rdram, ctx, runtime);
}

void entry_16b6b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b6b4 inside entry_16b6ac (0x16b6ac - 0x16b6e4)
    ctx->pc = 0x16b6b4;
    entry_16b6ac(rdram, ctx, runtime);
}

void entry_16b6ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b6ec inside entry_16b6e4 (0x16b6e4 - 0x16b748)
    ctx->pc = 0x16b6ec;
    entry_16b6e4(rdram, ctx, runtime);
}

void entry_16b740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b740 inside entry_16b6e4 (0x16b6e4 - 0x16b748)
    ctx->pc = 0x16b740;
    entry_16b6e4(rdram, ctx, runtime);
}

void entry_16b764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b764 inside entry_16b75c (0x16b75c - 0x16b774)
    ctx->pc = 0x16b764;
    entry_16b75c(rdram, ctx, runtime);
}

void entry_16b784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b784 inside entry_16b77c (0x16b77c - 0x16b790)
    ctx->pc = 0x16b784;
    entry_16b77c(rdram, ctx, runtime);
}

void entry_16b794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b794 inside entry_16b790 (0x16b790 - 0x16b7a8)
    ctx->pc = 0x16b794;
    entry_16b790(rdram, ctx, runtime);
}

void entry_16b798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b798 inside entry_16b790 (0x16b790 - 0x16b7a8)
    ctx->pc = 0x16b798;
    entry_16b790(rdram, ctx, runtime);
}

void entry_16b804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b804 inside entry_16b7fc (0x16b7fc - 0x16b818)
    ctx->pc = 0x16b804;
    entry_16b7fc(rdram, ctx, runtime);
}

void entry_16b81c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b81c inside entry_16b818 (0x16b818 - 0x16b824)
    ctx->pc = 0x16b81c;
    entry_16b818(rdram, ctx, runtime);
}

void entry_16b84c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b84c inside entry_16b848 (0x16b848 - 0x16b860)
    ctx->pc = 0x16b84c;
    entry_16b848(rdram, ctx, runtime);
}

void entry_16b850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b850 inside entry_16b848 (0x16b848 - 0x16b860)
    ctx->pc = 0x16b850;
    entry_16b848(rdram, ctx, runtime);
}

void entry_16b998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16b998 inside entry_16b980 (0x16b980 - 0x16b9ac)
    ctx->pc = 0x16b998;
    entry_16b980(rdram, ctx, runtime);
}

void entry_16ba24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ba24 inside entry_16ba20 (0x16ba20 - 0x16ba40)
    ctx->pc = 0x16ba24;
    entry_16ba20(rdram, ctx, runtime);
}

void entry_16ba88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ba88 inside entry_16ba80 (0x16ba80 - 0x16babc)
    ctx->pc = 0x16ba88;
    entry_16ba80(rdram, ctx, runtime);
}

void entry_16bb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16bb8c inside CFont__PushScaling (0x16bb78 - 0x16bba8)
    ctx->pc = 0x16bb8c;
    CFont__PushScaling(rdram, ctx, runtime);
}

void entry_16bb90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16bb90 inside CFont__PushScaling (0x16bb78 - 0x16bba8)
    ctx->pc = 0x16bb90;
    CFont__PushScaling(rdram, ctx, runtime);
}

void entry_16bc00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16bc00 inside FUN_0016bba8 (0x16bba8 - 0x16bc0c)
    ctx->pc = 0x16bc00;
    FUN_0016bba8(rdram, ctx, runtime);
}

void entry_16bc20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16bc20 inside entry_16bc18 (0x16bc18 - 0x16bc34)
    ctx->pc = 0x16bc20;
    entry_16bc18(rdram, ctx, runtime);
}

void entry_16bc54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16bc54 inside entry_16bc4c (0x16bc4c - 0x16bc90)
    ctx->pc = 0x16bc54;
    entry_16bc4c(rdram, ctx, runtime);
}

void entry_16bc98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16bc98 inside entry_16bc90 (0x16bc90 - 0x16bca0)
    ctx->pc = 0x16bc98;
    entry_16bc90(rdram, ctx, runtime);
}

void entry_16bcbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16bcbc inside entry_16bcac (0x16bcac - 0x16bdb4)
    ctx->pc = 0x16bcbc;
    entry_16bcac(rdram, ctx, runtime);
}

void entry_16bd28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16bd28 inside entry_16bcac (0x16bcac - 0x16bdb4)
    ctx->pc = 0x16bd28;
    entry_16bcac(rdram, ctx, runtime);
}

void entry_16bdb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16bdb8 inside entry_16bdb4 (0x16bdb4 - 0x16bdd0)
    ctx->pc = 0x16bdb8;
    entry_16bdb4(rdram, ctx, runtime);
}

void entry_16be48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16be48 inside entry_16be34 (0x16be34 - 0x16be70)
    ctx->pc = 0x16be48;
    entry_16be34(rdram, ctx, runtime);
}

void entry_16be50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16be50 inside entry_16be34 (0x16be34 - 0x16be70)
    ctx->pc = 0x16be50;
    entry_16be34(rdram, ctx, runtime);
}

void entry_16be60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16be60 inside entry_16be34 (0x16be34 - 0x16be70)
    ctx->pc = 0x16be60;
    entry_16be34(rdram, ctx, runtime);
}

void entry_16be68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16be68 inside entry_16be34 (0x16be34 - 0x16be70)
    ctx->pc = 0x16be68;
    entry_16be34(rdram, ctx, runtime);
}

void entry_16be88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16be88 inside entry_16be80 (0x16be80 - 0x16bea0)
    ctx->pc = 0x16be88;
    entry_16be80(rdram, ctx, runtime);
}

void entry_16bffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16bffc inside entry_16bfe4 (0x16bfe4 - 0x16c008)
    ctx->pc = 0x16bffc;
    entry_16bfe4(rdram, ctx, runtime);
}

void entry_16c020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16c020 inside entry_16c018 (0x16c018 - 0x16c044)
    ctx->pc = 0x16c020;
    entry_16c018(rdram, ctx, runtime);
}

void entry_16c150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16c150 inside entry_16c118 (0x16c118 - 0x16c18c)
    ctx->pc = 0x16c150;
    entry_16c118(rdram, ctx, runtime);
}

void entry_16c170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16c170 inside entry_16c118 (0x16c118 - 0x16c18c)
    ctx->pc = 0x16c170;
    entry_16c118(rdram, ctx, runtime);
}

void entry_16c198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16c198 inside entry_16c18c (0x16c18c - 0x16c1d4)
    ctx->pc = 0x16c198;
    entry_16c18c(rdram, ctx, runtime);
}

void entry_16c1e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16c1e8 inside entry_16c1d4 (0x16c1d4 - 0x16c208)
    ctx->pc = 0x16c1e8;
    entry_16c1d4(rdram, ctx, runtime);
}

void entry_16c418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16c418 inside entry_16c400 (0x16c400 - 0x16c464)
    ctx->pc = 0x16c418;
    entry_16c400(rdram, ctx, runtime);
}

void entry_16c768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16c768 inside entry_16c670 (0x16c670 - 0x16c7a0)
    ctx->pc = 0x16c768;
    entry_16c670(rdram, ctx, runtime);
}

void entry_16c788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16c788 inside entry_16c670 (0x16c670 - 0x16c7a0)
    ctx->pc = 0x16c788;
    entry_16c670(rdram, ctx, runtime);
}

void entry_16c7a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16c7a4 inside entry_16c7a0 (0x16c7a0 - 0x16c7d0)
    ctx->pc = 0x16c7a4;
    entry_16c7a0(rdram, ctx, runtime);
}

void entry_16c8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16c8fc inside entry_16c8bc (0x16c8bc - 0x16c91c)
    ctx->pc = 0x16c8fc;
    entry_16c8bc(rdram, ctx, runtime);
}

void entry_16c914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16c914 inside entry_16c8bc (0x16c8bc - 0x16c91c)
    ctx->pc = 0x16c914;
    entry_16c8bc(rdram, ctx, runtime);
}

void entry_16cb50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16cb50 inside entry_16cb4c (0x16cb4c - 0x16cb84)
    ctx->pc = 0x16cb50;
    entry_16cb4c(rdram, ctx, runtime);
}

void entry_16cb98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16cb98 inside entry_16cb84 (0x16cb84 - 0x16ce00)
    ctx->pc = 0x16cb98;
    entry_16cb84(rdram, ctx, runtime);
}

void entry_16cbdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16cbdc inside entry_16cb84 (0x16cb84 - 0x16ce00)
    ctx->pc = 0x16cbdc;
    entry_16cb84(rdram, ctx, runtime);
}

void entry_16ccc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ccc4 inside entry_16cb84 (0x16cb84 - 0x16ce00)
    ctx->pc = 0x16ccc4;
    entry_16cb84(rdram, ctx, runtime);
}

void entry_16ccd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ccd4 inside entry_16cb84 (0x16cb84 - 0x16ce00)
    ctx->pc = 0x16ccd4;
    entry_16cb84(rdram, ctx, runtime);
}

void entry_16cd9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16cd9c inside entry_16cb84 (0x16cb84 - 0x16ce00)
    ctx->pc = 0x16cd9c;
    entry_16cb84(rdram, ctx, runtime);
}

void entry_16cdb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16cdb0 inside entry_16cb84 (0x16cb84 - 0x16ce00)
    ctx->pc = 0x16cdb0;
    entry_16cb84(rdram, ctx, runtime);
}

void entry_16ced8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ced8 inside entry_16cecc (0x16cecc - 0x16cf00)
    ctx->pc = 0x16ced8;
    entry_16cecc(rdram, ctx, runtime);
}

void entry_16cee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16cee0 inside entry_16cecc (0x16cecc - 0x16cf00)
    ctx->pc = 0x16cee0;
    entry_16cecc(rdram, ctx, runtime);
}

void entry_16cf48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16cf48 inside entry_16cf14 (0x16cf14 - 0x16cf70)
    ctx->pc = 0x16cf48;
    entry_16cf14(rdram, ctx, runtime);
}

void entry_16cf4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16cf4c inside entry_16cf14 (0x16cf14 - 0x16cf70)
    ctx->pc = 0x16cf4c;
    entry_16cf14(rdram, ctx, runtime);
}

void entry_16d0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d0a0 inside entry_16d098 (0x16d098 - 0x16d0a8)
    ctx->pc = 0x16d0a0;
    entry_16d098(rdram, ctx, runtime);
}

void entry_16d0ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d0ac inside entry_16d0a8 (0x16d0a8 - 0x16d0c0)
    ctx->pc = 0x16d0ac;
    entry_16d0a8(rdram, ctx, runtime);
}

void entry_16d114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d114 inside entry_16d110 (0x16d110 - 0x16d128)
    ctx->pc = 0x16d114;
    entry_16d110(rdram, ctx, runtime);
}

void entry_16d160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d160 inside entry_16d144 (0x16d144 - 0x16d168)
    ctx->pc = 0x16d160;
    entry_16d144(rdram, ctx, runtime);
}

void entry_16d1d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d1d0 inside entry_16d1cc (0x16d1cc - 0x16d1e0)
    ctx->pc = 0x16d1d0;
    entry_16d1cc(rdram, ctx, runtime);
}

void entry_16d1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d1d4 inside entry_16d1cc (0x16d1cc - 0x16d1e0)
    ctx->pc = 0x16d1d4;
    entry_16d1cc(rdram, ctx, runtime);
}

void entry_16d254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d254 inside JlosNextJlo__FP3JLO (0x16d1e0 - 0x16d25c)
    ctx->pc = 0x16d254;
    JlosNextJlo__FP3JLO(rdram, ctx, runtime);
}

void entry_16d2a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d2a4 inside entry_16d25c (0x16d25c - 0x16d2b8)
    ctx->pc = 0x16d2a4;
    entry_16d25c(rdram, ctx, runtime);
}

void entry_16d2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d2ac inside entry_16d25c (0x16d25c - 0x16d2b8)
    ctx->pc = 0x16d2ac;
    entry_16d25c(rdram, ctx, runtime);
}

void entry_16d318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d318 inside entry_16d2e8 (0x16d2e8 - 0x16d360)
    ctx->pc = 0x16d318;
    entry_16d2e8(rdram, ctx, runtime);
}

void entry_16d320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d320 inside entry_16d2e8 (0x16d2e8 - 0x16d360)
    ctx->pc = 0x16d320;
    entry_16d2e8(rdram, ctx, runtime);
}

void entry_16d3d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d3d4 inside entry_16d374 (0x16d374 - 0x16d3f0)
    ctx->pc = 0x16d3d4;
    entry_16d374(rdram, ctx, runtime);
}

void entry_16d3d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d3d8 inside entry_16d374 (0x16d374 - 0x16d3f0)
    ctx->pc = 0x16d3d8;
    entry_16d374(rdram, ctx, runtime);
}

void entry_16d3dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d3dc inside entry_16d374 (0x16d374 - 0x16d3f0)
    ctx->pc = 0x16d3dc;
    entry_16d374(rdram, ctx, runtime);
}

void entry_16d418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d418 inside SetJloJlovol__FP3JLOP6JLOVOL (0x16d3f0 - 0x16d44c)
    ctx->pc = 0x16d418;
    SetJloJlovol__FP3JLOP6JLOVOL(rdram, ctx, runtime);
}

void entry_16d42c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d42c inside SetJloJlovol__FP3JLOP6JLOVOL (0x16d3f0 - 0x16d44c)
    ctx->pc = 0x16d42c;
    SetJloJlovol__FP3JLOP6JLOVOL(rdram, ctx, runtime);
}

void entry_16d468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d468 inside entry_16d460 (0x16d460 - 0x16d47c)
    ctx->pc = 0x16d468;
    entry_16d460(rdram, ctx, runtime);
}

void entry_16d480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d480 inside entry_16d47c (0x16d47c - 0x16d490)
    ctx->pc = 0x16d480;
    entry_16d47c(rdram, ctx, runtime);
}

void entry_16d484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d484 inside entry_16d47c (0x16d47c - 0x16d490)
    ctx->pc = 0x16d484;
    entry_16d47c(rdram, ctx, runtime);
}

void entry_16d568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d568 inside entry_16d504 (0x16d504 - 0x16d61c)
    ctx->pc = 0x16d568;
    entry_16d504(rdram, ctx, runtime);
}

void entry_16d578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d578 inside entry_16d504 (0x16d504 - 0x16d61c)
    ctx->pc = 0x16d578;
    entry_16d504(rdram, ctx, runtime);
}

void entry_16d5b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d5b4 inside entry_16d504 (0x16d504 - 0x16d61c)
    ctx->pc = 0x16d5b4;
    entry_16d504(rdram, ctx, runtime);
}

void entry_16d5f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d5f4 inside entry_16d504 (0x16d504 - 0x16d61c)
    ctx->pc = 0x16d5f4;
    entry_16d504(rdram, ctx, runtime);
}

void entry_16d610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d610 inside entry_16d504 (0x16d504 - 0x16d61c)
    ctx->pc = 0x16d610;
    entry_16d504(rdram, ctx, runtime);
}

void entry_16d66c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d66c inside entry_16d61c (0x16d61c - 0x16d684)
    ctx->pc = 0x16d66c;
    entry_16d61c(rdram, ctx, runtime);
}

void entry_16d714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d714 inside entry_16d684 (0x16d684 - 0x16d73c)
    ctx->pc = 0x16d714;
    entry_16d684(rdram, ctx, runtime);
}

void entry_16d75c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d75c inside entry_16d73c (0x16d73c - 0x16d788)
    ctx->pc = 0x16d75c;
    entry_16d73c(rdram, ctx, runtime);
}

void entry_16d998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d998 inside entry_16d98c (0x16d98c - 0x16d9a8)
    ctx->pc = 0x16d998;
    entry_16d98c(rdram, ctx, runtime);
}

void entry_16d9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16d9f0 inside entry_16d9ec (0x16d9ec - 0x16da00)
    ctx->pc = 0x16d9f0;
    entry_16d9ec(rdram, ctx, runtime);
}

void entry_16da58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16da58 inside entry_16da24 (0x16da24 - 0x16da74)
    ctx->pc = 0x16da58;
    entry_16da24(rdram, ctx, runtime);
}

void entry_16da7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16da7c inside entry_16da74 (0x16da74 - 0x16da84)
    ctx->pc = 0x16da7c;
    entry_16da74(rdram, ctx, runtime);
}

void entry_16da8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16da8c inside entry_16da84 (0x16da84 - 0x16da98)
    ctx->pc = 0x16da8c;
    entry_16da84(rdram, ctx, runtime);
}

void entry_16daa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16daa0 inside entry_16da98 (0x16da98 - 0x16daa8)
    ctx->pc = 0x16daa0;
    entry_16da98(rdram, ctx, runtime);
}

void entry_16daac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16daac inside entry_16daa8 (0x16daa8 - 0x16dac0)
    ctx->pc = 0x16daac;
    entry_16daa8(rdram, ctx, runtime);
}

void entry_16dab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dab0 inside entry_16daa8 (0x16daa8 - 0x16dac0)
    ctx->pc = 0x16dab0;
    entry_16daa8(rdram, ctx, runtime);
}

void entry_16dafc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dafc inside entry_16daf8 (0x16daf8 - 0x16db48)
    ctx->pc = 0x16dafc;
    entry_16daf8(rdram, ctx, runtime);
}

void entry_16dbe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dbe4 inside entry_16dbdc (0x16dbdc - 0x16dbec)
    ctx->pc = 0x16dbe4;
    entry_16dbdc(rdram, ctx, runtime);
}

void entry_16dbfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dbfc inside entry_16dbec (0x16dbec - 0x16dc20)
    ctx->pc = 0x16dbfc;
    entry_16dbec(rdram, ctx, runtime);
}

void entry_16dc14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dc14 inside entry_16dbec (0x16dbec - 0x16dc20)
    ctx->pc = 0x16dc14;
    entry_16dbec(rdram, ctx, runtime);
}

void entry_16dc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dc88 inside entry_16dc3c (0x16dc3c - 0x16dc9c)
    ctx->pc = 0x16dc88;
    entry_16dc3c(rdram, ctx, runtime);
}

void entry_16dcbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dcbc inside entry_16dc9c (0x16dc9c - 0x16dcd4)
    ctx->pc = 0x16dcbc;
    entry_16dc9c(rdram, ctx, runtime);
}

void entry_16dcc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dcc8 inside entry_16dc9c (0x16dc9c - 0x16dcd4)
    ctx->pc = 0x16dcc8;
    entry_16dc9c(rdram, ctx, runtime);
}

void entry_16dccc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dccc inside entry_16dc9c (0x16dc9c - 0x16dcd4)
    ctx->pc = 0x16dccc;
    entry_16dc9c(rdram, ctx, runtime);
}

void entry_16ddd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ddd4 inside entry_16ddc0 (0x16ddc0 - 0x16dde8)
    ctx->pc = 0x16ddd4;
    entry_16ddc0(rdram, ctx, runtime);
}

void entry_16de84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16de84 inside entry_16de74 (0x16de74 - 0x16de98)
    ctx->pc = 0x16de84;
    entry_16de74(rdram, ctx, runtime);
}

void entry_16dea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dea8 inside entry_16de98 (0x16de98 - 0x16deb8)
    ctx->pc = 0x16dea8;
    entry_16de98(rdram, ctx, runtime);
}

void entry_16def4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16def4 inside entry_16deb8 (0x16deb8 - 0x16df30)
    ctx->pc = 0x16def4;
    entry_16deb8(rdram, ctx, runtime);
}

void entry_16df04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16df04 inside entry_16deb8 (0x16deb8 - 0x16df30)
    ctx->pc = 0x16df04;
    entry_16deb8(rdram, ctx, runtime);
}

void entry_16df08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16df08 inside entry_16deb8 (0x16deb8 - 0x16df30)
    ctx->pc = 0x16df08;
    entry_16deb8(rdram, ctx, runtime);
}

void entry_16dfa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dfa0 inside entry_16df98 (0x16df98 - 0x16dfb0)
    ctx->pc = 0x16dfa0;
    entry_16df98(rdram, ctx, runtime);
}

void entry_16dfb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16dfb4 inside entry_16dfb0 (0x16dfb0 - 0x16dfc8)
    ctx->pc = 0x16dfb4;
    entry_16dfb0(rdram, ctx, runtime);
}

void entry_16e020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e020 inside entry_16dffc (0x16dffc - 0x16e04c)
    ctx->pc = 0x16e020;
    entry_16dffc(rdram, ctx, runtime);
}

void entry_16e034(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e034 inside entry_16dffc (0x16dffc - 0x16e04c)
    ctx->pc = 0x16e034;
    entry_16dffc(rdram, ctx, runtime);
}

void entry_16e068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e068 inside entry_16e060 (0x16e060 - 0x16e080)
    ctx->pc = 0x16e068;
    entry_16e060(rdram, ctx, runtime);
}

void entry_16e088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e088 inside entry_16e080 (0x16e080 - 0x16e0a0)
    ctx->pc = 0x16e088;
    entry_16e080(rdram, ctx, runtime);
}

void entry_16e0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e0a4 inside entry_16e0a0 (0x16e0a0 - 0x16e0b8)
    ctx->pc = 0x16e0a4;
    entry_16e0a0(rdram, ctx, runtime);
}

void entry_16e0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e0a8 inside entry_16e0a0 (0x16e0a0 - 0x16e0b8)
    ctx->pc = 0x16e0a8;
    entry_16e0a0(rdram, ctx, runtime);
}

void entry_16e168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e168 inside UpdateGrfjoytFromGrfusr__Fv (0x16e148 - 0x16e1a0)
    ctx->pc = 0x16e168;
    UpdateGrfjoytFromGrfusr__Fv(rdram, ctx, runtime);
}

void entry_16e180(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e180 inside UpdateGrfjoytFromGrfusr__Fv (0x16e148 - 0x16e1a0)
    ctx->pc = 0x16e180;
    UpdateGrfjoytFromGrfusr__Fv(rdram, ctx, runtime);
}

void entry_16e194(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e194 inside UpdateGrfjoytFromGrfusr__Fv (0x16e148 - 0x16e1a0)
    ctx->pc = 0x16e194;
    UpdateGrfjoytFromGrfusr__Fv(rdram, ctx, runtime);
}

void entry_16e284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e284 inside entry_16e26c (0x16e26c - 0x16e2e0)
    ctx->pc = 0x16e284;
    entry_16e26c(rdram, ctx, runtime);
}

void entry_16e28c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e28c inside entry_16e26c (0x16e26c - 0x16e2e0)
    ctx->pc = 0x16e28c;
    entry_16e26c(rdram, ctx, runtime);
}

void entry_16e2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e2c4 inside entry_16e26c (0x16e26c - 0x16e2e0)
    ctx->pc = 0x16e2c4;
    entry_16e26c(rdram, ctx, runtime);
}

void entry_16e310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e310 inside entry_16e2e0 (0x16e2e0 - 0x16e370)
    ctx->pc = 0x16e310;
    entry_16e2e0(rdram, ctx, runtime);
}

void entry_16e324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e324 inside entry_16e2e0 (0x16e2e0 - 0x16e370)
    ctx->pc = 0x16e324;
    entry_16e2e0(rdram, ctx, runtime);
}

void entry_16e344(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e344 inside entry_16e2e0 (0x16e2e0 - 0x16e370)
    ctx->pc = 0x16e344;
    entry_16e2e0(rdram, ctx, runtime);
}

void entry_16e35c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e35c inside entry_16e2e0 (0x16e2e0 - 0x16e370)
    ctx->pc = 0x16e35c;
    entry_16e2e0(rdram, ctx, runtime);
}

void entry_16e3ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e3ac inside entry_16e38c (0x16e38c - 0x16e3d4)
    ctx->pc = 0x16e3ac;
    entry_16e38c(rdram, ctx, runtime);
}

void entry_16e3bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e3bc inside entry_16e38c (0x16e38c - 0x16e3d4)
    ctx->pc = 0x16e3bc;
    entry_16e38c(rdram, ctx, runtime);
}

void entry_16e3e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e3e0 inside entry_16e3d4 (0x16e3d4 - 0x16e3f4)
    ctx->pc = 0x16e3e0;
    entry_16e3d4(rdram, ctx, runtime);
}

void entry_16e4c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e4c0 inside entry_16e4b8 (0x16e4b8 - 0x16e4ec)
    ctx->pc = 0x16e4c0;
    entry_16e4b8(rdram, ctx, runtime);
}

void entry_16e4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e4fc inside entry_16e4ec (0x16e4ec - 0x16e508)
    ctx->pc = 0x16e4fc;
    entry_16e4ec(rdram, ctx, runtime);
}

void entry_16e510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e510 inside entry_16e508 (0x16e508 - 0x16e520)
    ctx->pc = 0x16e510;
    entry_16e508(rdram, ctx, runtime);
}

void entry_16e518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e518 inside entry_16e508 (0x16e508 - 0x16e520)
    ctx->pc = 0x16e518;
    entry_16e508(rdram, ctx, runtime);
}

void entry_16e52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e52c inside entry_16e520 (0x16e520 - 0x16e538)
    ctx->pc = 0x16e52c;
    entry_16e520(rdram, ctx, runtime);
}

void entry_16e560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e560 inside entry_16e538 (0x16e538 - 0x16e5c8)
    ctx->pc = 0x16e560;
    entry_16e538(rdram, ctx, runtime);
}

void entry_16e570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e570 inside entry_16e538 (0x16e538 - 0x16e5c8)
    ctx->pc = 0x16e570;
    entry_16e538(rdram, ctx, runtime);
}

void entry_16e594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e594 inside entry_16e538 (0x16e538 - 0x16e5c8)
    ctx->pc = 0x16e594;
    entry_16e538(rdram, ctx, runtime);
}

void entry_16e5a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e5a4 inside entry_16e538 (0x16e538 - 0x16e5c8)
    ctx->pc = 0x16e5a4;
    entry_16e538(rdram, ctx, runtime);
}

void entry_16e5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e5a8 inside entry_16e538 (0x16e538 - 0x16e5c8)
    ctx->pc = 0x16e5a8;
    entry_16e538(rdram, ctx, runtime);
}

void entry_16e5b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e5b0 inside entry_16e538 (0x16e538 - 0x16e5c8)
    ctx->pc = 0x16e5b0;
    entry_16e538(rdram, ctx, runtime);
}

void entry_16e5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e5b8 inside entry_16e538 (0x16e538 - 0x16e5c8)
    ctx->pc = 0x16e5b8;
    entry_16e538(rdram, ctx, runtime);
}

void entry_16e5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e5c0 inside entry_16e538 (0x16e538 - 0x16e5c8)
    ctx->pc = 0x16e5c0;
    entry_16e538(rdram, ctx, runtime);
}

void entry_16e5fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e5fc inside entry_16e5f4 (0x16e5f4 - 0x16e610)
    ctx->pc = 0x16e5fc;
    entry_16e5f4(rdram, ctx, runtime);
}

void entry_16e600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e600 inside entry_16e5f4 (0x16e5f4 - 0x16e610)
    ctx->pc = 0x16e600;
    entry_16e5f4(rdram, ctx, runtime);
}

void entry_16e604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e604 inside entry_16e5f4 (0x16e5f4 - 0x16e610)
    ctx->pc = 0x16e604;
    entry_16e5f4(rdram, ctx, runtime);
}

void entry_16e608(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e608 inside entry_16e5f4 (0x16e5f4 - 0x16e610)
    ctx->pc = 0x16e608;
    entry_16e5f4(rdram, ctx, runtime);
}

void entry_16e664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e664 inside SetJoyJoys__FP3JOY4JOYS4JOYK (0x16e630 - 0x16e69c)
    ctx->pc = 0x16e664;
    SetJoyJoys__FP3JOY4JOYS4JOYK(rdram, ctx, runtime);
}

void entry_16e678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e678 inside SetJoyJoys__FP3JOY4JOYS4JOYK (0x16e630 - 0x16e69c)
    ctx->pc = 0x16e678;
    SetJoyJoys__FP3JOY4JOYS4JOYK(rdram, ctx, runtime);
}

void entry_16e6a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e6a0 inside entry_16e69c (0x16e69c - 0x16e738)
    ctx->pc = 0x16e6a0;
    entry_16e69c(rdram, ctx, runtime);
}

void entry_16e6e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e6e0 inside entry_16e69c (0x16e69c - 0x16e738)
    ctx->pc = 0x16e6e0;
    entry_16e69c(rdram, ctx, runtime);
}

void entry_16e70c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e70c inside entry_16e69c (0x16e69c - 0x16e738)
    ctx->pc = 0x16e70c;
    entry_16e69c(rdram, ctx, runtime);
}

void entry_16e724(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e724 inside entry_16e69c (0x16e69c - 0x16e738)
    ctx->pc = 0x16e724;
    entry_16e69c(rdram, ctx, runtime);
}

void entry_16e7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e7a8 inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e7a8;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e7ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e7ac inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e7ac;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e7b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e7b4 inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e7b4;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e7fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e7fc inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e7fc;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e804 inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e804;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e828 inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e828;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e860 inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e860;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e868 inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e868;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e878 inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e878;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e87c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e87c inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e87c;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e890 inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e890;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e8e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e8e8 inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e8e8;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e928 inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e928;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e934 inside GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM (0x16e738 - 0x16e940)
    ctx->pc = 0x16e934;
    GetJoyXYDeflection__FP3JOYUcUcPfN23PUcT6PiP2LM(rdram, ctx, runtime);
}

void entry_16e9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16e9b0 inside entry_16e980 (0x16e980 - 0x16e9d4)
    ctx->pc = 0x16e9b0;
    entry_16e980(rdram, ctx, runtime);
}

void entry_16ea6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ea6c inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16ea6c;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16ea8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ea8c inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16ea8c;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16eab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eab0 inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16eab0;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16eab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eab4 inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16eab4;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16eae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eae4 inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16eae4;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16eafc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eafc inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16eafc;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16eb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eb00 inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16eb00;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16eb1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eb1c inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16eb1c;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16eb30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eb30 inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16eb30;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16eb34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eb34 inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16eb34;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16eb68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eb68 inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16eb68;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16eb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eb74 inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16eb74;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16eb78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eb78 inside entry_16ea64 (0x16ea64 - 0x16eb80)
    ctx->pc = 0x16eb78;
    entry_16ea64(rdram, ctx, runtime);
}

void entry_16ebc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ebc8 inside entry_16eb80 (0x16eb80 - 0x16ec20)
    ctx->pc = 0x16ebc8;
    entry_16eb80(rdram, ctx, runtime);
}

void entry_16ebcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ebcc inside entry_16eb80 (0x16eb80 - 0x16ec20)
    ctx->pc = 0x16ebcc;
    entry_16eb80(rdram, ctx, runtime);
}

void entry_16ebd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ebd8 inside entry_16eb80 (0x16eb80 - 0x16ec20)
    ctx->pc = 0x16ebd8;
    entry_16eb80(rdram, ctx, runtime);
}

void entry_16ec00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ec00 inside entry_16eb80 (0x16eb80 - 0x16ec20)
    ctx->pc = 0x16ec00;
    entry_16eb80(rdram, ctx, runtime);
}

void entry_16ec04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ec04 inside entry_16eb80 (0x16eb80 - 0x16ec20)
    ctx->pc = 0x16ec04;
    entry_16eb80(rdram, ctx, runtime);
}

void entry_16ec74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ec74 inside entry_16ec70 (0x16ec70 - 0x16ec80)
    ctx->pc = 0x16ec74;
    entry_16ec70(rdram, ctx, runtime);
}

void entry_16ecd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ecd4 inside entry_16eccc (0x16eccc - 0x16ece4)
    ctx->pc = 0x16ecd4;
    entry_16eccc(rdram, ctx, runtime);
}

void entry_16ecec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ecec inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16ecec;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16ed44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ed44 inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16ed44;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16ed4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ed4c inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16ed4c;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16ed6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ed6c inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16ed6c;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16edc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16edc8 inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16edc8;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16ee18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ee18 inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16ee18;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16ee20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ee20 inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16ee20;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16ee30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ee30 inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16ee30;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16eea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eea4 inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16eea4;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16eeb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eeb0 inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16eeb0;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16eeb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eeb8 inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16eeb8;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16eebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16eebc inside entry_16ece4 (0x16ece4 - 0x16eed0)
    ctx->pc = 0x16eebc;
    entry_16ece4(rdram, ctx, runtime);
}

void entry_16ef0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ef0c inside entry_16ef04 (0x16ef04 - 0x16ef1c)
    ctx->pc = 0x16ef0c;
    entry_16ef04(rdram, ctx, runtime);
}

void entry_16ef24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ef24 inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16ef24;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16ef7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ef7c inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16ef7c;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16ef84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ef84 inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16ef84;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16efa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16efa4 inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16efa4;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16f000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f000 inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16f000;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16f050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f050 inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16f050;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16f058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f058 inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16f058;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16f068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f068 inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16f068;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16f0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f0dc inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16f0dc;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16f0e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f0e8 inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16f0e8;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16f0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f0f0 inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16f0f0;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16f0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f0f4 inside entry_16ef1c (0x16ef1c - 0x16f108)
    ctx->pc = 0x16f0f4;
    entry_16ef1c(rdram, ctx, runtime);
}

void entry_16f16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f16c inside UBtnpJoy__FP3JOY4BTNP (0x16f108 - 0x16f188)
    ctx->pc = 0x16f16c;
    UBtnpJoy__FP3JOY4BTNP(rdram, ctx, runtime);
}

void entry_16f17c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f17c inside UBtnpJoy__FP3JOY4BTNP (0x16f108 - 0x16f188)
    ctx->pc = 0x16f17c;
    UBtnpJoy__FP3JOY4BTNP(rdram, ctx, runtime);
}

void entry_16f1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f1a0 inside AddCode__FP4CODE (0x16f188 - 0x16f1f0)
    ctx->pc = 0x16f1a0;
    AddCode__FP4CODE(rdram, ctx, runtime);
}

void entry_16f1b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f1b4 inside AddCode__FP4CODE (0x16f188 - 0x16f1f0)
    ctx->pc = 0x16f1b4;
    AddCode__FP4CODE(rdram, ctx, runtime);
}

void entry_16f1e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f1e4 inside AddCode__FP4CODE (0x16f188 - 0x16f1f0)
    ctx->pc = 0x16f1e4;
    AddCode__FP4CODE(rdram, ctx, runtime);
}

void entry_16f210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f210 inside _ResetCodes__Fv (0x16f1f8 - 0x16f238)
    ctx->pc = 0x16f210;
    fn__ResetCodes__Fv(rdram, ctx, runtime);
}

void entry_16f22c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f22c inside _ResetCodes__Fv (0x16f1f8 - 0x16f238)
    ctx->pc = 0x16f22c;
    fn__ResetCodes__Fv(rdram, ctx, runtime);
}

void entry_16f278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f278 inside _MatchCodes__FP3JOYUs (0x16f238 - 0x16f2e0)
    ctx->pc = 0x16f278;
    fn__MatchCodes__FP3JOYUs(rdram, ctx, runtime);
}

void entry_16f2a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f2a8 inside _MatchCodes__FP3JOYUs (0x16f238 - 0x16f2e0)
    ctx->pc = 0x16f2a8;
    fn__MatchCodes__FP3JOYUs(rdram, ctx, runtime);
}

void entry_16f2d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f2d4 inside _MatchCodes__FP3JOYUs (0x16f238 - 0x16f2e0)
    ctx->pc = 0x16f2d4;
    fn__MatchCodes__FP3JOYUs(rdram, ctx, runtime);
}

void entry_16f338(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f338 inside UpdateCodes__Fv (0x16f2e0 - 0x16f3d8)
    ctx->pc = 0x16f338;
    UpdateCodes__Fv(rdram, ctx, runtime);
}

void entry_16f358(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f358 inside UpdateCodes__Fv (0x16f2e0 - 0x16f3d8)
    ctx->pc = 0x16f358;
    UpdateCodes__Fv(rdram, ctx, runtime);
}

void entry_16f384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f384 inside UpdateCodes__Fv (0x16f2e0 - 0x16f3d8)
    ctx->pc = 0x16f384;
    UpdateCodes__Fv(rdram, ctx, runtime);
}

void entry_16f388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f388 inside UpdateCodes__Fv (0x16f2e0 - 0x16f3d8)
    ctx->pc = 0x16f388;
    UpdateCodes__Fv(rdram, ctx, runtime);
}

void entry_16f394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f394 inside UpdateCodes__Fv (0x16f2e0 - 0x16f3d8)
    ctx->pc = 0x16f394;
    UpdateCodes__Fv(rdram, ctx, runtime);
}

void entry_16f3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f3f0 inside entry_16f3ec (0x16f3ec - 0x16f408)
    ctx->pc = 0x16f3f0;
    entry_16f3ec(rdram, ctx, runtime);
}

void entry_16f510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f510 inside entry_16f4f8 (0x16f4f8 - 0x16f540)
    ctx->pc = 0x16f510;
    entry_16f4f8(rdram, ctx, runtime);
}

void entry_16f52c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f52c inside entry_16f4f8 (0x16f4f8 - 0x16f540)
    ctx->pc = 0x16f52c;
    entry_16f4f8(rdram, ctx, runtime);
}

void entry_16f578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f578 inside entry_16f574 (0x16f574 - 0x16f588)
    ctx->pc = 0x16f578;
    entry_16f574(rdram, ctx, runtime);
}

void entry_16f57c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f57c inside entry_16f574 (0x16f574 - 0x16f588)
    ctx->pc = 0x16f57c;
    entry_16f574(rdram, ctx, runtime);
}

void entry_16f580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16f580 inside entry_16f574 (0x16f574 - 0x16f588)
    ctx->pc = 0x16f580;
    entry_16f574(rdram, ctx, runtime);
}

void entry_16fae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16fae0 inside entry_16fadc (0x16fadc - 0x16faf4)
    ctx->pc = 0x16fae0;
    entry_16fadc(rdram, ctx, runtime);
}

void entry_16fb98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16fb98 inside entry_16fb74 (0x16fb74 - 0x16fc2c)
    ctx->pc = 0x16fb98;
    entry_16fb74(rdram, ctx, runtime);
}

void entry_16fbb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16fbb8 inside entry_16fb74 (0x16fb74 - 0x16fc2c)
    ctx->pc = 0x16fbb8;
    entry_16fb74(rdram, ctx, runtime);
}

void entry_16fbd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16fbd8 inside entry_16fb74 (0x16fb74 - 0x16fc2c)
    ctx->pc = 0x16fbd8;
    entry_16fb74(rdram, ctx, runtime);
}

void entry_16fbf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16fbf8 inside entry_16fb74 (0x16fb74 - 0x16fc2c)
    ctx->pc = 0x16fbf8;
    entry_16fb74(rdram, ctx, runtime);
}

void entry_16fc3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16fc3c inside entry_16fc2c (0x16fc2c - 0x16fc78)
    ctx->pc = 0x16fc3c;
    entry_16fc2c(rdram, ctx, runtime);
}

void entry_16fc58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16fc58 inside entry_16fc2c (0x16fc2c - 0x16fc78)
    ctx->pc = 0x16fc58;
    entry_16fc2c(rdram, ctx, runtime);
}

void entry_16fc68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16fc68 inside entry_16fc2c (0x16fc2c - 0x16fc78)
    ctx->pc = 0x16fc68;
    entry_16fc2c(rdram, ctx, runtime);
}

void entry_16fd50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16fd50 inside entry_16fd40 (0x16fd40 - 0x16fd70)
    ctx->pc = 0x16fd50;
    entry_16fd40(rdram, ctx, runtime);
}

void entry_16fe14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16fe14 inside PresetJtAccelBase (0x16fd70 - 0x16ff58)
    ctx->pc = 0x16fe14;
    PresetJtAccelBase(rdram, ctx, runtime);
}

void entry_16fe28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16fe28 inside PresetJtAccelBase (0x16fd70 - 0x16ff58)
    ctx->pc = 0x16fe28;
    PresetJtAccelBase(rdram, ctx, runtime);
}

void entry_16feec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16feec inside PresetJtAccelBase (0x16fd70 - 0x16ff58)
    ctx->pc = 0x16feec;
    PresetJtAccelBase(rdram, ctx, runtime);
}

void entry_16ff00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ff00 inside PresetJtAccelBase (0x16fd70 - 0x16ff58)
    ctx->pc = 0x16ff00;
    PresetJtAccelBase(rdram, ctx, runtime);
}

void entry_16ff20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ff20 inside PresetJtAccelBase (0x16fd70 - 0x16ff58)
    ctx->pc = 0x16ff20;
    PresetJtAccelBase(rdram, ctx, runtime);
}

void entry_16ff44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x16ff44 inside PresetJtAccelBase (0x16fd70 - 0x16ff58)
    ctx->pc = 0x16ff44;
    PresetJtAccelBase(rdram, ctx, runtime);
}

