// Auto-generated split file - DO NOT EDIT DIRECTLY
// Edit the original ps2_recompiled_functions.cpp and re-run split_recompiled.py

#include "ps2_recompiled_functions.h"
#include "ps2_runtime_macros.h"
#include "ps2_runtime.h"
#include "ps2_recompiled_stubs.h"
#include "ps2_stubs.h"

void entry_170030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170030: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x170034: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x170038: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17003c: 0x26101858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 6232));
    // 0x170040: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x170044: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x170048: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17004c: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x170050: 0xc60f0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[15] = *(float*)&val; }
    // 0x170054: 0x48261000
    SET_GPR_VEC(ctx, 6, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x170058: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x17005c: 0x4486a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 6);
    // 0x170060: 0x27a50130
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 304));
    // 0x170064: 0x46000346
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    // 0x170068: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x17006c: 0x24843730
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 14128));
    // 0x170070: 0xc07a988
    SET_GPR_U32(ctx, 31, 0x170078);
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    GSmoothA__FffffP4SMPAPf(rdram, ctx, runtime); return;
}


// Function: entry_170078
// Address: 0x170078 - 0x170094

void entry_170078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170078: 0xc60f0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[15] = *(float*)&val; }
    // 0x17007c: 0x27a50134
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 308));
    // 0x170080: 0x27a400c0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 192));
    // 0x170084: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x170088: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x17008c: 0xc07a988
    SET_GPR_U32(ctx, 31, 0x170094);
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    GSmoothA__FffffP4SMPAPf(rdram, ctx, runtime); return;
}


// Function: entry_170094
// Address: 0x170094 - 0x170110

void entry_170094(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170094: 0xc6020008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[2] = *(float*)&val; }
    // 0x170098: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17009c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1700a0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1700a4: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1700a8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1700ac: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x1700b0: 0x8fa20130
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1700b4: 0x46020843
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[2];
    // 0x1700b8: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1700bc: 0x8fa30134
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 308)));
    // 0x1700c0: 0xfba300d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1700c4: 0x48a33000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x1700c8: 0xfba600d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x1700cc: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1700d0: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1700d4: 0x4be311bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1700d8: 0x4be608c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1700dc: 0x44050000
    SET_GPR_U32(ctx, 5, *(uint32_t*)&ctx->f[0]);
    // 0x1700e0: 0x44060800
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[1]);
    // 0x1700e4: 0x48a52000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 5));
    // 0x1700e8: 0xda410160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x1700ec: 0x48a62800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 6));
    // 0x1700f0: 0x4be419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1700f4: 0x4be50848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1700f8: 0xfba400d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1700fc: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x170100: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x170104: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x170108: 0xc06e6b2
    SET_GPR_U32(ctx, 31, 0x170110);
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[5]));
    AddSoAngularAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_170110
// Address: 0x170110 - 0x170154

void entry_170110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170110) {
        switch (ctx->pc) {
            case 0x170120: ctx->pc = 0; goto label_170120;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170110: 0x8e420690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1680)));
    // 0x170114: 0x14400002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 18), 1696));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_170120;
    }
    // 0x17011c: 0x8e4306d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 1748)));
label_170120:
    // 0x170120: 0xd8630000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x170124: 0x27b000e0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 224));
    // 0x170128: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x17012c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x170130: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x170134: 0xda410180
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 384)));
    // 0x170138: 0x4bc20afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x17013c: 0x4bc1106e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x170140: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170144: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x170148: 0xfba100e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17014c: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x170154);
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[2]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_170154
// Address: 0x170154 - 0x170188

void entry_170154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170154: 0xda420160
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 352)));
    // 0x170158: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17015c: 0xdba100d0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x170160: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x170164: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x170168: 0x4bc2086e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17016c: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170170: 0x4bc112fe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[1] = READ32(addr); }
    // 0x170174: 0x4bc208ae
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x170178: 0x4a2210ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17017c: 0xfba100f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x170180: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x170188);
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_170188
// Address: 0x170188 - 0x1701b0

void entry_170188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170188: 0x7bbf0170
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x17018c: 0x7bb20160
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x170190: 0x7bb10150
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x170194: 0x7bb00140
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x170198: 0xc7b70198
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 408)); ctx->f[23] = *(float*)&val; }
    // 0x17019c: 0xc7b60190
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 400)); ctx->f[22] = *(float*)&val; }
    // 0x1701a0: 0xc7b50188
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 392)); ctx->f[21] = *(float*)&val; }
    // 0x1701a4: 0xc7b40180
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 384)); ctx->f[20] = *(float*)&val; }
    // 0x1701a8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 416));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PresetJtAccel__FP2JTf
// Address: 0x1701b0 - 0x1701d4

void entry_1701d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1701d4: 0x8e422220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    // 0x1701d8: 0x2444fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x1701dc: 0x2c83000c
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 12));
    // 0x1701e0: 0x10600081
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1703E8; return;
    }
    // 0x1701e8: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x1701ec: 0x2442a870
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294944880));
    // 0x1701f0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1701f4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1701f8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x170200: 0xc05f492
    SET_GPR_U32(ctx, 31, 0x170208);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PresetJtAccelJump__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_170208
// Address: 0x170208 - 0x170218

void entry_170208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170208: 0x1000007a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1703F4; return;
    }
    // 0x170210: 0xc0733e6
    SET_GPR_U32(ctx, 31, 0x170218);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PresetJtAccelHang__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_170218
// Address: 0x170218 - 0x170228

void entry_170218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170218: 0x10000076
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1703F4; return;
    }
    // 0x170220: 0xc0746a0
    SET_GPR_U32(ctx, 31, 0x170228);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PresetJtAccelPipe__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_170228
// Address: 0x170228 - 0x170238

void entry_170228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170228: 0x10000072
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1703F4; return;
    }
    // 0x170230: 0xc07523a
    SET_GPR_U32(ctx, 31, 0x170238);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PresetJtAccelZap__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_170238
// Address: 0x170238 - 0x170248

void entry_170238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170238: 0x1000006e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1703F4; return;
    }
    // 0x170240: 0xc0744bc
    SET_GPR_U32(ctx, 31, 0x170248);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PresetJtAccelHide__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_170248
// Address: 0x170248 - 0x17028c

void entry_170248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170248: 0x1000006a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1703F4; return;
    }
    // 0x170250: 0x8e432228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    // 0x170254: 0x28620036
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 54));
    // 0x170258: 0x14400066
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1703F4; return;
    }
    // 0x170260: 0x28620038
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 56));
    // 0x170264: 0x14400012
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1702B0; return;
    }
    // 0x17026c: 0x24020038
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 56));
    // 0x170270: 0x54620061
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
        ctx->pc = 0x1703F8; return;
    }
    // 0x170278: 0xc64c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x17027c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x170280: 0x24848d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    // 0x170284: 0xc062214
    SET_GPR_U32(ctx, 31, 0x17028c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17028c
// Address: 0x17028c - 0x1702a8

void entry_17028c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17028c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x170290: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x170294: 0xc44c1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[12] = *(float*)&val; }
    // 0x170298: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17029c: 0x24c63780
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 14208));
    // 0x1702a0: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x1702a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_1702a8
// Address: 0x1702a8 - 0x1702e4

void entry_1702a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1702a8) {
        switch (ctx->pc) {
            case 0x1702b0: ctx->pc = 0; goto label_1702b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1702a8: 0x10000052
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1703F4; return;
    }
label_1702b0:
    // 0x1702b0: 0xc64d0634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1588)); ctx->f[13] = *(float*)&val; }
    // 0x1702b4: 0xc4402e28
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11816)); ctx->f[0] = *(float*)&val; }
    // 0x1702b8: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1702bc: 0xc64203cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 972)); ctx->f[2] = *(float*)&val; }
    // 0x1702c0: 0x46006b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[0]);
    // 0x1702c4: 0xc6410638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1592)); ctx->f[1] = *(float*)&val; }
    // 0x1702c8: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x1702cc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x1702d0: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1702d4: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x1702d8: 0x46026b43
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[13] = copysignf(INFINITY, ctx->f[13] * 0.0f); } else ctx->f[13] = ctx->f[13] / ctx->f[2];
    // 0x1702dc: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1702e4);
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[12]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1702e4
// Address: 0x1702e4 - 0x1702f8

void entry_1702e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1702e4: 0xc64c0634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1588)); ctx->f[12] = *(float*)&val; }
    // 0x1702e8: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1702ec: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1702f0: 0xc04633c
    SET_GPR_U32(ctx, 31, 0x1702f8);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 14224));
    fn___8VU_FLOATf(rdram, ctx, runtime); return;
}


// Function: entry_1702f8
// Address: 0x1702f8 - 0x170308

void entry_1702f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1702f8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1702fc: 0x27a40040
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 64));
    // 0x170300: 0xc046344
    SET_GPR_U32(ctx, 31, 0x170308);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    fn___9VU_VECTORRC6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_170308
// Address: 0x170308 - 0x170314

void entry_170308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170308: 0x7ba50040
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17030c: 0xc04634c
    SET_GPR_U32(ctx, 31, 0x170314);
    SET_GPR_VEC(ctx, 4, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 17)));
    fn___ml__FG8VU_FLOATG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_170314
// Address: 0x170314 - 0x170320

void entry_170314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170314: 0x70022ca9
    SET_GPR_VEC(ctx, 5, PS2_POR(GPR_VEC(ctx, 0), GPR_VEC(ctx, 2)));
    // 0x170318: 0xc046348
    SET_GPR_U32(ctx, 31, 0x170320);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    fn___as__6VECTORG9VU_VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_170320
// Address: 0x170320 - 0x17033c

void entry_170320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170320: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x170324: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x170328: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17032c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x170330: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x170334: 0xc06e46a
    SET_GPR_U32(ctx, 31, 0x17033c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    AccelSoTowardMatSpring__FP2SOP7MATRIX3P3CLQP6VECTORT2f(rdram, ctx, runtime); return;
}


// Function: entry_17033c
// Address: 0x17033c - 0x170398

void entry_17033c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17033c: 0x1000002d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1703F4; return;
    }
    // 0x170344: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x170348: 0xc6422224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8740)); ctx->f[2] = *(float*)&val; }
    // 0x17034c: 0x24501858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x170350: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x170354: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x170358: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17035c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x170360: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x170364: 0x0
    // NOP
    // 0x170368: 0x4500001b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1703D8; return;
    }
    // 0x170370: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x170374: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x170378: 0xda410350
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 848)));
    // 0x17037c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x170380: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x170384: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x170388: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17038c: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x170390: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x170398);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_170398
// Address: 0x170398 - 0x1703bc

void entry_170398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170398: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x17039c: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x1703a0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1703a4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1703a8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1703ac: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1703b0: 0x24e78d30
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937904));
    // 0x1703b4: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x1703bc);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 14240));
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_1703bc
// Address: 0x1703bc - 0x1703d0

void entry_1703bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1703bc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1703c0: 0xc60c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8)); ctx->f[12] = *(float*)&val; }
    // 0x1703c4: 0x24850660
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 1632));
    // 0x1703c8: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x1703d0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1760));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_1703d0
// Address: 0x1703d0 - 0x1703e0

void entry_1703d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1703d0) {
        switch (ctx->pc) {
            case 0x1703d8: ctx->pc = 0; goto label_1703d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1703d0: 0x10000008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1703F4; return;
    }
label_1703d8:
    // 0x1703d8: 0xc05bf5c
    SET_GPR_U32(ctx, 31, 0x1703e0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PresetJtAccelBase(rdram, ctx, runtime); return;
}


// Function: entry_1703e0
// Address: 0x1703e0 - 0x1703f0

void entry_1703e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1703e0) {
        switch (ctx->pc) {
            case 0x1703e8: ctx->pc = 0; goto label_1703e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1703e0: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1703F4; return;
    }
label_1703e8:
    // 0x1703e8: 0xc05bf5c
    SET_GPR_U32(ctx, 31, 0x1703f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PresetJtAccelBase(rdram, ctx, runtime); return;
}


// Function: entry_1703f0
// Address: 0x1703f0 - 0x170410

void entry_1703f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1703f0) {
        switch (ctx->pc) {
            case 0x1703f4: ctx->pc = 0; goto label_1703f4;
            case 0x1703f8: ctx->pc = 0; goto label_1703f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1703f0: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_1703f4:
    // 0x1703f4: 0x7bb20070
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_1703f8:
    // 0x1703f8: 0x7bb10060
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1703fc: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x170400: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x170404: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17040c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x170410; return;
}


// Function: AdjustJtNewXp__FP2JTP2XPi
// Address: 0x170410 - 0x170464

void entry_170464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170464) {
        switch (ctx->pc) {
            case 0x17049c: ctx->pc = 0; goto label_17049c;
            case 0x1704a4: ctx->pc = 0; goto label_1704a4;
            case 0x1704cc: ctx->pc = 0; goto label_1704cc;
            case 0x1704d4: ctx->pc = 0; goto label_1704d4;
            case 0x1704e0: ctx->pc = 0; goto label_1704e0;
            case 0x1704ec: ctx->pc = 0; goto label_1704ec;
            case 0x1704f8: ctx->pc = 0; goto label_1704f8;
            case 0x1704fc: ctx->pc = 0; goto label_1704fc;
            case 0x170500: ctx->pc = 0; goto label_170500;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170464: 0x1040000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1704a4;
    }
    // 0x17046c: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x170470: 0x1462000a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_17049c;
    }
    // 0x170478: 0x8e23239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x17047c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x170480: 0x14620006
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_17049c;
    }
    // 0x170488: 0x8e2223bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9148)));
    // 0x17048c: 0x8c430040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x170490: 0x5460001a
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 148), GPR_U32(ctx, 0));
        goto label_1704fc;
    }
    // 0x170498: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_17049c:
    // 0x17049c: 0x1000000d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14264)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1704d4;
    }
label_1704a4:
    // 0x1704a4: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x1704a8: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1704ac: 0x54620013
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 148), GPR_U32(ctx, 0));
        goto label_1704fc;
    }
    // 0x1704b4: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x1704b8: 0x24020028
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 40));
    // 0x1704bc: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 49));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1704cc;
    }
    // 0x1704c4: 0x14620006
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1704e0;
    }
label_1704cc:
    // 0x1704cc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1704d0: 0xc44037b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14256)); ctx->f[0] = *(float*)&val; }
label_1704d4:
    // 0x1704d4: 0xae000098
    WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 0));
    // 0x1704d8: 0x10000009
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 148), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_170500;
    }
label_1704e0:
    // 0x1704e0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1704e4: 0xc44037b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14256)); ctx->f[0] = *(float*)&val; }
    // 0x1704e8: 0xc46137b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 14260)); ctx->f[1] = *(float*)&val; }
label_1704ec:
    // 0x1704ec: 0xe6000094
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 148), *(uint32_t*)&val); }
    // 0x1704f0: 0x10000003
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 152), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_170500;
    }
label_1704f8:
    // 0x1704f8: 0xae000094
    WRITE32(ADD32(GPR_U32(ctx, 16), 148), GPR_U32(ctx, 0));
label_1704fc:
    // 0x1704fc: 0xae000098
    WRITE32(ADD32(GPR_U32(ctx, 16), 152), GPR_U32(ctx, 0));
label_170500:
    // 0x170500: 0xc6210700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1792)); ctx->f[1] = *(float*)&val; }
    // 0x170504: 0xc6000094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 148)); ctx->f[0] = *(float*)&val; }
    // 0x170508: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17050c: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x170510: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x170514: 0xe6000094
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 148), *(uint32_t*)&val); }
    // 0x170518: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17051c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x170524: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x170528; return;
}


// Function: AdjustJtDz__FP2JTiP2DZif
// Address: 0x170528 - 0x1705b8

void entry_1705b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1705b8) {
        switch (ctx->pc) {
            case 0x1705bc: ctx->pc = 0; goto label_1705bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1705b8: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_1705bc:
    // 0x1705bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1705c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1705c8; return;
}


// Function: HandleJtGrfjtsc
// Address: 0x1705c8 - 0x170618

void entry_170618(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170618: 0x8e022254
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8788)));
    // 0x17061c: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x170620: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8788)));
        ctx->pc = 0x170638; return;
    }
    // 0x170628: 0x8e052260
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8800)));
    // 0x17062c: 0xc071878
    SET_GPR_U32(ctx, 31, 0x170634);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_170634
// Address: 0x170634 - 0x17064c

void entry_170634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170634) {
        switch (ctx->pc) {
            case 0x170638: ctx->pc = 0; goto label_170638;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170634: 0x8e022254
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8788)));
label_170638:
    // 0x170638: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x17063c: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x170650; return;
    }
    // 0x170644: 0xc075326
    SET_GPR_U32(ctx, 31, 0x17064c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001d4c98(rdram, ctx, runtime); return;
}


// Function: entry_17064c
// Address: 0x17064c - 0x170660

void entry_17064c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17064c) {
        switch (ctx->pc) {
            case 0x170650: ctx->pc = 0; goto label_170650;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17064c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_170650:
    // 0x170650: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x170654: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17065c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x170660; return;
}


// Function: UpdateJtInternalXps__FP2JT
// Address: 0x170660 - 0x17067c

void entry_17067c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17067c) {
        switch (ctx->pc) {
            case 0x1706a8: ctx->pc = 0; goto label_1706a8;
            case 0x1706bc: ctx->pc = 0; goto label_1706bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17067c: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x170680: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x170684: 0x1062000d
    WRITE32(ADD32(GPR_U32(ctx, 16), 1204), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1706bc;
    }
    // 0x17068c: 0x28620008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 8));
    // 0x170690: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1706a8;
    }
    // 0x170698: 0x1062000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1706CC; return;
    }
    // 0x1706a0: 0x10000038
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x170784; return;
    }
label_1706a8:
    // 0x1706a8: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1706ac: 0x1062000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1706DC; return;
    }
    // 0x1706b4: 0x10000033
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x170784; return;
    }
label_1706bc:
    // 0x1706bc: 0xc074946
    SET_GPR_U32(ctx, 31, 0x1706c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateJtInternalXpsPipe__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1706c4
// Address: 0x1706c4 - 0x1706d4

void entry_1706c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1706c4) {
        switch (ctx->pc) {
            case 0x1706cc: ctx->pc = 0; goto label_1706cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1706c4: 0x1000002e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x170780; return;
    }
label_1706cc:
    // 0x1706cc: 0xc0743c8
    SET_GPR_U32(ctx, 31, 0x1706d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateJtInternalXpsHide__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1706d4
// Address: 0x1706d4 - 0x1706f0

void entry_1706d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1706d4) {
        switch (ctx->pc) {
            case 0x1706dc: ctx->pc = 0; goto label_1706dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1706d4: 0x1000002a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x170780; return;
    }
label_1706dc:
    // 0x1706dc: 0x8e0424a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9376)));
    // 0x1706e0: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1706e4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1706e8: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1706f0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 9392));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1706f0
// Address: 0x1706f0 - 0x170738

void entry_1706f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1706f0: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1706f4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1706f8: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x1706fc: 0xda0324d0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 9424)));
    // 0x170700: 0x24c68d20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937888));
    // 0x170704: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x170708: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x17070c: 0xda0124c0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 9408)));
    // 0x170710: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x170714: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x170718: 0x4be40858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17071c: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x170720: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x170724: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x170728: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17072c: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x170730: 0xc07b5e0
    SET_GPR_U32(ctx, 31, 0x170738);
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    GetNormalVectors__FP6VECTORN30(rdram, ctx, runtime); return;
}


// Function: entry_170738
// Address: 0x170738 - 0x17077c

void entry_170738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170738: 0xda0324e0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 9440)));
    // 0x17073c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x170740: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x170744: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x170748: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17074c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x170750: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x170754: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x170758: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17075c: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x170760: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x170764: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x170768: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17076c: 0x24890140
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 4), 320));
    // 0x170770: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x170774: 0xc07361c
    SET_GPR_U32(ctx, 31, 0x17077c);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 9376)));
    AddJtHookXps__FP2JTiP2LOP6VECTORN23(rdram, ctx, runtime); return;
}


// Function: entry_17077c
// Address: 0x17077c - 0x170790

void entry_17077c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17077c) {
        switch (ctx->pc) {
            case 0x170780: ctx->pc = 0; goto label_170780;
            case 0x170784: ctx->pc = 0; goto label_170784;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17077c: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_170780:
    // 0x170780: 0x7bb00050
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_170784:
    // 0x170784: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17078c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x170790; return;
}


// Function: FCheckJtXpBase__FP2JTP2XPi
// Address: 0x170790 - 0x1707b0

void entry_1707b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1707b0) {
        switch (ctx->pc) {
            case 0x1707b8: ctx->pc = 0; goto label_1707b8;
            case 0x17080c: ctx->pc = 0; goto label_17080c;
            case 0x170810: ctx->pc = 0; goto label_170810;
            case 0x170814: ctx->pc = 0; goto label_170814;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1707b0: 0x10000018
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_170814;
    }
label_1707b8:
    // 0x1707b8: 0x61880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 6), 2));
    // 0x1707bc: 0x24424ad0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 19152));
    // 0x1707c0: 0xc4a10088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 136)); ctx->f[1] = *(float*)&val; }
    // 0x1707c4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1707c8: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x1707cc: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x1707d0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1707d4: 0xc4600000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[0] = *(float*)&val; }
    // 0x1707d8: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1707dc: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1707e0: 0x0
    // NOP
    // 0x1707e4: 0x4501000a
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_170810;
    }
    // 0x1707ec: 0x8ca5009c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 156)));
    // 0x1707f0: 0x28a20007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 7));
    // 0x1707f4: 0x10400005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17080c;
    }
    // 0x1707fc: 0x14400004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_170810;
    }
    // 0x170804: 0x10000002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 6), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_170810;
    }
label_17080c:
    // 0x17080c: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_170810:
    // 0x170810: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_170814:
    // 0x170814: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17081c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x170820; return;
}


// Function: AdjustJtXpVelocity__FP2JTP2XPi
// Address: 0x170820 - 0x1708f0

void entry_1708f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1708f0: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17090C; return;
    }
    // 0x1708f8: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1708fc: 0xc071534
    SET_GPR_U32(ctx, 31, 0x170904);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    AdjustStepXpVelocityBase__FP4STEPP2XPi(rdram, ctx, runtime); return;
}


// Function: entry_170904
// Address: 0x170904 - 0x170960

void entry_170904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170904) {
        switch (ctx->pc) {
            case 0x17090c: ctx->pc = 0; goto label_17090c;
            case 0x170940: ctx->pc = 0; goto label_170940;
            case 0x170944: ctx->pc = 0; goto label_170944;
            case 0x170948: ctx->pc = 0; goto label_170948;
            case 0x17094c: ctx->pc = 0; goto label_17094c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170904: 0x1000000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_170944;
    }
label_17090c:
    // 0x17090c: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x170910: 0x1450000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 16)) {
        goto label_170944;
    }
    // 0x170918: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x17091c: 0xda420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x170920: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x170924: 0xda030160
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 352)));
    // 0x170928: 0xda410030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 48)));
    // 0x17092c: 0x4bc21afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[2] = READ32(addr); }
    // 0x170930: 0x4bc310ee
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x170934: 0x4a2318ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x170938: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17093c: 0xfa410030
    WRITE128(ADD32(GPR_U32(ctx, 18), 48), _mm_castps_si128(ctx->vu0_vf[1]));
label_170940:
    // 0x170940: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_170944:
    // 0x170944: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_170948:
    // 0x170948: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_17094c:
    // 0x17094c: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x170950: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x170954: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17095c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x170960; return;
}


// Function: HandleJtMessage__FP2JT5MSGIDPv
// Address: 0x170960 - 0x1709ac

void entry_1709ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1709ac) {
        switch (ctx->pc) {
            case 0x170a04: ctx->pc = 0; goto label_170a04;
            case 0x170a10: ctx->pc = 0; goto label_170a10;
            case 0x170a5c: ctx->pc = 0; goto label_170a5c;
            case 0x170a84: ctx->pc = 0; goto label_170a84;
            case 0x170abc: ctx->pc = 0; goto label_170abc;
            case 0x170ad0: ctx->pc = 0; goto label_170ad0;
            case 0x170b5c: ctx->pc = 0; goto label_170b5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1709ac: 0x2603fffe
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 16), 4294967294));
    // 0x1709b0: 0x2c620012
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 18));
    // 0x1709b4: 0x104001e1
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x1709bc: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1709c0: 0x2442a8a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294944928));
    // 0x1709c4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1709c8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1709cc: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1709d4: 0x8e222244
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8772)));
    // 0x1709d8: 0x5642000d
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
        goto label_170a10;
    }
    // 0x1709e0: 0x8e222254
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8788)));
    // 0x1709e4: 0x2404000a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 10));
    // 0x1709e8: 0x8e23223c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8764)));
    // 0x1709ec: 0x34420002
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 2));
    // 0x1709f0: 0x14640004
    WRITE32(ADD32(GPR_U32(ctx, 17), 8788), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_170a04;
    }
    // 0x1709f8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1709fc: 0x100001cf
    WRITE32(ADD32(GPR_U32(ctx, 17), 8800), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
label_170a04:
    // 0x170a04: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x170a08: 0x100001cc
    WRITE32(ADD32(GPR_U32(ctx, 17), 8800), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
label_170a10:
    // 0x170a10: 0x164201cb
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x171140; return;
    }
    // 0x170a18: 0x8e222220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x170a1c: 0x2444fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x170a20: 0x2c83000f
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 15));
    // 0x170a24: 0x106001c6
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171140; return;
    }
    // 0x170a2c: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x170a30: 0x2442a8f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945008));
    // 0x170a34: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x170a38: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x170a3c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x170a44: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x170a48: 0x2402001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 27));
    // 0x170a4c: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 23));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_170a5c;
    }
    // 0x170a54: 0x146201ba
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x171140; return;
    }
label_170a5c:
    // 0x170a5c: 0x8e222254
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8788)));
    // 0x170a60: 0x24030007
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 7));
    // 0x170a64: 0x10000015
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 24));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_170abc;
    }
    // 0x170a6c: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x170a70: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x170a74: 0x10620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_170a84;
    }
    // 0x170a7c: 0x146201b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x171140; return;
    }
label_170a84:
    // 0x170a84: 0x8e222254
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8788)));
    // 0x170a88: 0x24030002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    // 0x170a8c: 0xae23225c
    WRITE32(ADD32(GPR_U32(ctx, 17), 8796), GPR_U32(ctx, 3));
    // 0x170a90: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x170a94: 0xae232258
    WRITE32(ADD32(GPR_U32(ctx, 17), 8792), GPR_U32(ctx, 3));
    // 0x170a98: 0x100001a8
    WRITE32(ADD32(GPR_U32(ctx, 17), 8788), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x170aa0: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x170aa4: 0x24020021
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    // 0x170aa8: 0x14620009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 35));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_170ad0;
    }
    // 0x170ab0: 0x8e222254
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8788)));
    // 0x170ab4: 0x2403000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 12));
    // 0x170ab8: 0x24040022
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 34));
label_170abc:
    // 0x170abc: 0xae232258
    WRITE32(ADD32(GPR_U32(ctx, 17), 8792), GPR_U32(ctx, 3));
    // 0x170ac0: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x170ac4: 0xae24225c
    WRITE32(ADD32(GPR_U32(ctx, 17), 8796), GPR_U32(ctx, 4));
    // 0x170ac8: 0x1000019c
    WRITE32(ADD32(GPR_U32(ctx, 17), 8788), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
label_170ad0:
    // 0x170ad0: 0x1462019b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x171140; return;
    }
    // 0x170ad8: 0x8e232254
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8788)));
    // 0x170adc: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x170ae0: 0xae22225c
    WRITE32(ADD32(GPR_U32(ctx, 17), 8796), GPR_U32(ctx, 2));
    // 0x170ae4: 0x34630001
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 1));
    // 0x170ae8: 0xae202258
    WRITE32(ADD32(GPR_U32(ctx, 17), 8792), GPR_U32(ctx, 0));
    // 0x170aec: 0x10000193
    WRITE32(ADD32(GPR_U32(ctx, 17), 8788), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x170af4: 0x8e222230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
    // 0x170af8: 0x16420191
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x171140; return;
    }
    // 0x170b00: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x170b04: 0x28620007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 7));
    // 0x170b08: 0x1040018d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171140; return;
    }
    // 0x170b10: 0x1440018c
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x171144; return;
    }
    // 0x170b18: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x170b1c: 0x10000189
    WRITE32(ADD32(GPR_U32(ctx, 17), 2580), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171144; return;
    }
    // 0x170b24: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x170b28: 0x8e252230
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
    // 0x170b2c: 0x5205000b
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 5)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
        goto label_170b5c;
    }
    // 0x170b34: 0x8e222244
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8772)));
    // 0x170b38: 0x52020008
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
        goto label_170b5c;
    }
    // 0x170b40: 0x8e222234
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8756)));
    // 0x170b44: 0x1040017e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171140; return;
    }
    // 0x170b4c: 0x8c420024
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 36)));
    // 0x170b50: 0x1602017c
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x171144; return;
    }
    // 0x170b58: 0x8e420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8)));
label_170b5c:
    // 0x170b5c: 0x2444fec8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294966984));
    // 0x170b60: 0x2c830028
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 40));
    // 0x170b64: 0x10600175
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x170b6c: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x170b70: 0x2442a930
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945072));
    // 0x170b74: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x170b78: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x170b7c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x170b84: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x170b88: 0x8c42009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 156)));
    // 0x170b8c: 0x1040016b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x170b94: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x170b98: 0xc60c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20)); ctx->f[12] = *(float*)&val; }
    // 0x170b9c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x170ba0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x170ba4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x170ba8: 0xc60d0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 24)); ctx->f[13] = *(float*)&val; }
    // 0x170bac: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x170bb0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x170bb8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_170bb8
// Address: 0x170bb8 - 0x170bf4

void entry_170bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170bb8: 0x26230660
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 1632));
    // 0x170bbc: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x170bc0: 0xd8640020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x170bc4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x170bc8: 0xd8630010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x170bcc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x170bd0: 0xda210660
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1632)));
    // 0x170bd4: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x170bd8: 0x4bc209bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x170bdc: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x170be0: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x170be4: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x170be8: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x170bec: 0x40f809
    SET_GPR_U32(ctx, 31, 0x170bf4);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_170bf4
// Address: 0x170bf4 - 0x170c98

void entry_170bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170bf4) {
        switch (ctx->pc) {
            case 0x170c48: ctx->pc = 0; goto label_170c48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170bf4: 0x8e232230
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
    // 0x170bf8: 0x16030151
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x171140; return;
    }
    // 0x170c00: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x170c04: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x170c08: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x170c0c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x170c10: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x170c14: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170c18: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x170c1c: 0x10000148
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171140; return;
    }
    // 0x170c24: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x170c28: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x170c2c: 0x14620006
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_170c48;
    }
    // 0x170c34: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x170c38: 0xc44037d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14292)); ctx->f[0] = *(float*)&val; }
    // 0x170c3c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x170c40: 0x1000013e
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 9260), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
label_170c48:
    // 0x170c48: 0xc44037d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14288)); ctx->f[0] = *(float*)&val; }
    // 0x170c4c: 0x46800020
    ctx->f[0] = FPU_CVT_S_W(*(int32_t*)&ctx->f[0]);
    // 0x170c50: 0x1000013a
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 9260), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x170c58: 0x10000138
    WRITE32(ADD32(GPR_U32(ctx, 17), 9260), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x170c60: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x170c64: 0x10000135
    WRITE32(ADD32(GPR_U32(ctx, 17), 1364), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x170c6c: 0xda210560
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1376)));
    // 0x170c70: 0xda220100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x170c74: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170c78: 0xae200554
    WRITE32(ADD32(GPR_U32(ctx, 17), 1364), GPR_U32(ctx, 0));
    // 0x170c7c: 0xfa212530
    WRITE128(ADD32(GPR_U32(ctx, 17), 9520), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x170c80: 0x1000012e
    WRITE32(ADD32(GPR_U32(ctx, 17), 9528), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x170c88: 0x8ca40008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x170c8c: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x170c90: 0xc04b330
    SET_GPR_U32(ctx, 31, 0x170c98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 320));
    TFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_170c98
// Address: 0x170c98 - 0x170d08

void entry_170c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170c98) {
        switch (ctx->pc) {
            case 0x170cf0: ctx->pc = 0; goto label_170cf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170c98: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x170c9c: 0xc6410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[1] = *(float*)&val; }
    // 0x170ca0: 0x8c4623c4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 9156)));
    // 0x170ca4: 0xae2005d0
    WRITE32(ADD32(GPR_U32(ctx, 17), 1488), GPR_U32(ctx, 0));
    // 0x170ca8: 0x8e2426d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
    // 0x170cac: 0x8cc50438
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 1080)));
    // 0x170cb0: 0x8c830300
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 768)));
    // 0x170cb4: 0x65102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 5)));
    // 0x170cb8: 0x60a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x170cbc: 0xa2a00a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 5));
    // 0x170cc0: 0x1a80011e
    ctx->f[20] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    if (GPR_S32(ctx, 20) <= 0) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x170cc8: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x170ccc: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x170cd0: 0x263505ac
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 17), 1452));
    // 0x170cd4: 0x3c013a11
    SET_GPR_U32(ctx, 1, ((uint32_t)14865 << 16));
    // 0x170cd8: 0x3421a2b4
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 41652));
    // 0x170cdc: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x170ce0: 0x3c170026
    SET_GPR_U32(ctx, 23, ((uint32_t)38 << 16));
    // 0x170ce4: 0x3c160027
    SET_GPR_U32(ctx, 22, ((uint32_t)39 << 16));
    // 0x170ce8: 0x8e2226d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
    // 0x170cec: 0x0
    // NOP
label_170cf0:
    // 0x170cf0: 0x131880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 19), 2));
    // 0x170cf4: 0x2404001a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 26));
    // 0x170cf8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x170cfc: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x170d00: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x170d08);
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 772)));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_170d08
// Address: 0x170d08 - 0x170d48

void entry_170d08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170d08: 0x8e2305d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1488)));
    // 0x170d0c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x170d10: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x170d14: 0x2a21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x170d18: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x170d1c: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x170d20: 0x12000024
    WRITE32(ADD32(GPR_U32(ctx, 17), 1488), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x170DB4; return;
    }
    // 0x170d28: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x170d2c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x170d30: 0x8e25059c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1436)));
    // 0x170d34: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x170d38: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x170d3c: 0xc6ec37cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 14284)); ctx->f[12] = *(float*)&val; }
    // 0x170d40: 0x40f809
    SET_GPR_U32(ctx, 31, 0x170d48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_170d48
// Address: 0x170d48 - 0x170d54

void entry_170d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170d48: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x170d4c: 0xc067e3a
    SET_GPR_U32(ctx, 31, 0x170d54);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SubscribeRipObject__FP3RIPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_170d54
// Address: 0x170d54 - 0x170e1c

void entry_170d54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170d54) {
        switch (ctx->pc) {
            case 0x170db4: ctx->pc = 0; goto label_170db4;
            case 0x170de8: ctx->pc = 0; goto label_170de8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170d54: 0x8e4302d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 728)));
    // 0x170d58: 0x8e22059c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1436)));
    // 0x170d5c: 0xd8610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x170d60: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x170d64: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170d68: 0xae030020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 3));
    // 0x170d6c: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170d70: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x170d74: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170d78: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x170d7c: 0x8ec35710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 22288)));
    // 0x170d80: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170d84: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x170d88: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x170d8c: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x170d90: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x170d94: 0x4600a828
    ctx->f[0] = std::max(ctx->f[21], ctx->f[0]);
    // 0x170d98: 0x46160002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[22]);
    // 0x170d9c: 0x4600a029
    ctx->f[0] = std::min(ctx->f[20], ctx->f[0]);
    // 0x170da0: 0xe600001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x170da4: 0x78621ee0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 7904)));
    // 0x170da8: 0x7e0200c0
    WRITE128(ADD32(GPR_U32(ctx, 16), 192), GPR_VEC(ctx, 2));
    // 0x170dac: 0x8e23059c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1436)));
    // 0x170db0: 0xae030134
    WRITE32(ADD32(GPR_U32(ctx, 16), 308), GPR_U32(ctx, 3));
label_170db4:
    // 0x170db4: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
    // 0x170db8: 0x274102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 20)));
    // 0x170dbc: 0x5440ffcc
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
        ctx->pc = 0x170CF0; return;
    }
    // 0x170dc4: 0x100000de
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171140; return;
    }
    // 0x170dcc: 0x8e2526d4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
    // 0x170dd0: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x170dd4: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x170dd8: 0x8ca20300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 768)));
    // 0x170ddc: 0x1840001e
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x170E58; return;
    }
    // 0x170de4: 0x0
    // NOP
label_170de8:
    // 0x170de8: 0x8e0223c4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9156)));
    // 0x170dec: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x170df0: 0xa31821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 5), GPR_U32(ctx, 3)));
    // 0x170df4: 0x8c440438
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 1080)));
    // 0x170df8: 0x244102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 4)));
    // 0x170dfc: 0x1040000d
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 772)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x170E34; return;
    }
    // 0x170e04: 0x8ca20300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 768)));
    // 0x170e08: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x170e0c: 0x14400005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 724)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x170E24; return;
    }
    // 0x170e14: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x170e1c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 559));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_170e1c
// Address: 0x170e1c - 0x170e2c

void entry_170e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170e1c) {
        switch (ctx->pc) {
            case 0x170e24: ctx->pc = 0; goto label_170e24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170e1c: 0x10000009
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x170E44; return;
    }
label_170e24:
    // 0x170e24: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x170e2c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 560));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_170e2c
// Address: 0x170e2c - 0x170e40

void entry_170e2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170e2c) {
        switch (ctx->pc) {
            case 0x170e34: ctx->pc = 0; goto label_170e34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170e2c: 0x10000005
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x170E44; return;
    }
label_170e34:
    // 0x170e34: 0x8c6402d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 724)));
    // 0x170e38: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x170e40);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 561));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_170e40
// Address: 0x170e40 - 0x170e78

void entry_170e40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170e40) {
        switch (ctx->pc) {
            case 0x170e44: ctx->pc = 0; goto label_170e44;
            case 0x170e58: ctx->pc = 0; goto label_170e58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170e40: 0x8e2526d4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
label_170e44:
    // 0x170e44: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x170e48: 0x8ca20300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 768)));
    // 0x170e4c: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x170e50: 0x1440ffe5
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x170DE8; return;
    }
label_170e58:
    // 0x170e58: 0x8e0223c4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9156)));
    // 0x170e5c: 0x8cc40300
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 768)));
    // 0x170e60: 0x8c430438
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1080)));
    // 0x170e64: 0x64182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x170e68: 0x1460000a
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 728)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x170E94; return;
    }
    // 0x170e70: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x170e78);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 559));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_170e78
// Address: 0x170e78 - 0x170e9c

void entry_170e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170e78) {
        switch (ctx->pc) {
            case 0x170e94: ctx->pc = 0; goto label_170e94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170e78: 0x8e0523c4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 9156)));
    // 0x170e7c: 0x8e2426d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
    // 0x170e80: 0x8ca20448
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 1096)));
    // 0x170e84: 0x8c8302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 720)));
    // 0x170e88: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x170e8c: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 5), 1096), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_170e9c(rdram, ctx, runtime); return;
    }
label_170e94:
    // 0x170e94: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x170e9c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 560));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_170e9c
// Address: 0x170e9c - 0x170eac

void entry_170e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170e9c: 0x8e222230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
    // 0x170ea0: 0x2405013f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 319));
    // 0x170ea4: 0xc04b2fa
    SET_GPR_U32(ctx, 31, 0x170eac);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    PeaFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_170eac
// Address: 0x170eac - 0x170f38

void entry_170eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170eac) {
        switch (ctx->pc) {
            case 0x170f20: ctx->pc = 0; goto label_170f20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170eac: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x170eb0: 0x106000a2
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x170eb8: 0x8e222230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
    // 0x170ebc: 0xc4610000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    // 0x170ec0: 0xc4400014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[0] = *(float*)&val; }
    // 0x170ec4: 0x8e0623c4
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 9156)));
    // 0x170ec8: 0xae2005d0
    WRITE32(ADD32(GPR_U32(ctx, 17), 1488), GPR_U32(ctx, 0));
    // 0x170ecc: 0x8e2426d4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
    // 0x170ed0: 0x8cc50438
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 1080)));
    // 0x170ed4: 0x8c830300
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 768)));
    // 0x170ed8: 0x65102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 5)));
    // 0x170edc: 0x60a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x170ee0: 0xa2a00a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 5));
    // 0x170ee4: 0x1a800095
    ctx->f[20] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    if (GPR_S32(ctx, 20) <= 0) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x170eec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x170ef0: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x170ef4: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x170ef8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x170efc: 0x4481b800
    *(uint32_t*)&ctx->f[23] = GPR_U32(ctx, 1);
    // 0x170f00: 0x245e1858
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x170f04: 0x3c013ada
    SET_GPR_U32(ctx, 1, ((uint32_t)15066 << 16));
    // 0x170f08: 0x3421740e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 29710));
    // 0x170f0c: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x170f10: 0x263505ac
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 17), 1452));
    // 0x170f14: 0x3c170026
    SET_GPR_U32(ctx, 23, ((uint32_t)38 << 16));
    // 0x170f18: 0x3c160027
    SET_GPR_U32(ctx, 22, ((uint32_t)39 << 16));
    // 0x170f1c: 0x8e2226d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
label_170f20:
    // 0x170f20: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x170f24: 0x2404001a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 26));
    // 0x170f28: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x170f2c: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x170f30: 0xc067a9e
    SET_GPR_U32(ctx, 31, 0x170f38);
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 2), 772)));
    PripNewRipg__F4RIPTP4RIPG(rdram, ctx, runtime); return;
}


// Function: entry_170f38
// Address: 0x170f38 - 0x170f7c

void entry_170f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170f38: 0x8e2305d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1488)));
    // 0x170f3c: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x170f40: 0x31080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    // 0x170f44: 0x2a21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 21), GPR_U32(ctx, 2)));
    // 0x170f48: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x170f4c: 0xac500000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 16));
    // 0x170f50: 0x12000029
    WRITE32(ADD32(GPR_U32(ctx, 17), 1488), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x170FF8; return;
    }
    // 0x170f58: 0xc6ec37cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 14284)); ctx->f[12] = *(float*)&val; }
    // 0x170f5c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x170f60: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x170f64: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x170f68: 0x460cbb03
    if (ctx->f[12] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[23] * 0.0f); } else ctx->f[12] = ctx->f[23] / ctx->f[12];
    // 0x170f6c: 0x8e6502d8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 728)));
    // 0x170f70: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x170f74: 0x40f809
    SET_GPR_U32(ctx, 31, 0x170f7c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 320));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_170f7c
// Address: 0x170f7c - 0x170f88

void entry_170f7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x170f7c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x170f80: 0xc067e3a
    SET_GPR_U32(ctx, 31, 0x170f88);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    SubscribeRipObject__FP3RIPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_170f88
// Address: 0x170f88 - 0x171120

void entry_170f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x170f88) {
        switch (ctx->pc) {
            case 0x170ff8: ctx->pc = 0; goto label_170ff8;
            case 0x171060: ctx->pc = 0; goto label_171060;
            case 0x1710d0: ctx->pc = 0; goto label_1710d0;
            case 0x1710e4: ctx->pc = 0; goto label_1710e4;
            case 0x1710ec: ctx->pc = 0; goto label_1710ec;
            case 0x1710f4: ctx->pc = 0; goto label_1710f4;
            case 0x171110: ctx->pc = 0; goto label_171110;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x170f88: 0x8e6202d8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 728)));
    // 0x170f8c: 0x8e23059c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1436)));
    // 0x170f90: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x170f94: 0xd8620140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x170f98: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170f9c: 0xae030020
    WRITE32(ADD32(GPR_U32(ctx, 16), 32), GPR_U32(ctx, 3));
    // 0x170fa0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170fa4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x170fa8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170fac: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x170fb0: 0x8ec35710
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 22), 22288)));
    // 0x170fb4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x170fb8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x170fbc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x170fc0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x170fc4: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x170fc8: 0x4601a868
    ctx->f[1] = std::max(ctx->f[21], ctx->f[1]);
    // 0x170fcc: 0x46160842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[22]);
    // 0x170fd0: 0x4601a069
    ctx->f[1] = std::min(ctx->f[20], ctx->f[1]);
    // 0x170fd4: 0xe601001c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 28), *(uint32_t*)&val); }
    // 0x170fd8: 0x4601a041
    ctx->f[1] = FPU_SUB_S(ctx->f[20], ctx->f[1]);
    // 0x170fdc: 0x78621ee0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 7904)));
    // 0x170fe0: 0x7e0200c0
    WRITE128(ADD32(GPR_U32(ctx, 16), 192), GPR_VEC(ctx, 2));
    // 0x170fe4: 0x8e6302d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 728)));
    // 0x170fe8: 0xae030134
    WRITE32(ADD32(GPR_U32(ctx, 16), 308), GPR_U32(ctx, 3));
    // 0x170fec: 0xc7c00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 4)); ctx->f[0] = *(float*)&val; }
    // 0x170ff0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x170ff4: 0xe6000018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 24), *(uint32_t*)&val); }
label_170ff8:
    // 0x170ff8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x170ffc: 0x254102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 20)));
    // 0x171000: 0x5440ffc7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
        ctx->pc = 0x170F20; return;
    }
    // 0x171008: 0x1000004d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171140; return;
    }
    // 0x171010: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x171014: 0x10000049
    WRITE32(ADD32(GPR_U32(ctx, 17), 10040), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x17101c: 0x10000047
    WRITE32(ADD32(GPR_U32(ctx, 17), 10040), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x171024: 0x8e222254
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8788)));
    // 0x171028: 0x34420010
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 16));
    // 0x17102c: 0x10000043
    WRITE32(ADD32(GPR_U32(ctx, 17), 8788), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x171034: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x171038: 0x10000040
    WRITE32(ADD32(GPR_U32(ctx, 17), 8776), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17113c(rdram, ctx, runtime); return;
    }
    // 0x171040: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x171044: 0x1451003e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        ctx->pc = 0x171140; return;
    }
    // 0x17104c: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x171050: 0x262426dc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 9948));
    // 0x171054: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171058: 0xae222438
    WRITE32(ADD32(GPR_U32(ctx, 17), 9272), GPR_U32(ctx, 2));
    // 0x17105c: 0x0
    // NOP
label_171060:
    // 0x171060: 0xac800000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 0));
    // 0x171064: 0x24a50001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 1));
    // 0x171068: 0x2ca20008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 5), 8));
    // 0x17106c: 0x0
    // NOP
    // 0x171070: 0x0
    // NOP
    // 0x171074: 0x1440fffa
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 8));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_171060;
    }
    // 0x17107c: 0x10000030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171140; return;
    }
    // 0x171084: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x171088: 0x1451002d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 17)) {
        ctx->pc = 0x171140; return;
    }
    // 0x171090: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x171094: 0x8e222438
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9272)));
    // 0x171098: 0x50620029
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 9272), GPR_U32(ctx, 0));
        ctx->pc = 0x171140; return;
    }
    // 0x1710a0: 0x10000028
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171144; return;
    }
    // 0x1710a8: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x1710ac: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1710b0: 0x10620010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 7));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1710f4;
    }
    // 0x1710b8: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1710d0;
    }
    // 0x1710c0: 0x10620008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1710e4;
    }
    // 0x1710c8: 0x1000001e
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171144; return;
    }
label_1710d0:
    // 0x1710d0: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1710d4: 0x10620005
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1710ec;
    }
    // 0x1710dc: 0x10000019
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171144; return;
    }
label_1710e4:
    // 0x1710e4: 0x1000000a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8708)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_171110;
    }
label_1710ec:
    // 0x1710ec: 0x10000008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_171110;
    }
label_1710f4:
    // 0x1710f4: 0x8e23239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x1710f8: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1710fc: 0x1062000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x171128; return;
    }
    // 0x171104: 0x1462000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x171140; return;
    }
    // 0x17110c: 0x8e2223b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9144)));
label_171110:
    // 0x171110: 0x1452000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x171140; return;
    }
    // 0x171118: 0xc05c7f8
    SET_GPR_U32(ctx, 31, 0x171120);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UnhookJt__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_171120
// Address: 0x171120 - 0x17113c

void entry_171120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171120) {
        switch (ctx->pc) {
            case 0x171128: ctx->pc = 0; goto label_171128;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171120: 0x10000007
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171140; return;
    }
label_171128:
    // 0x171128: 0x8e2223bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9148)));
    // 0x17112c: 0x14520004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 18)) {
        ctx->pc = 0x171140; return;
    }
    // 0x171134: 0xc05c7f8
    SET_GPR_U32(ctx, 31, 0x17113c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UnhookJt__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_17113c
// Address: 0x17113c - 0x171180

void entry_17113c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17113c) {
        switch (ctx->pc) {
            case 0x171140: ctx->pc = 0; goto label_171140;
            case 0x171144: ctx->pc = 0; goto label_171144;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17113c: 0x7bbf00b0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_171140:
    // 0x171140: 0x7bbe00a0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 160)));
label_171144:
    // 0x171144: 0x7bb70090
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x171148: 0x7bb60080
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x17114c: 0x7bb50070
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x171150: 0x7bb40060
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x171154: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x171158: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17115c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x171160: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x171164: 0xc7b700d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[23] = *(float*)&val; }
    // 0x171168: 0xc7b600d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[22] = *(float*)&val; }
    // 0x17116c: 0xc7b500c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 200)); ctx->f[21] = *(float*)&val; }
    // 0x171170: 0xc7b400c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 192)); ctx->f[20] = *(float*)&val; }
    // 0x171174: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17117c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x171180; return;
}


// Function: FTurnJtToTarget__FP2JT
// Address: 0x171180 - 0x1711a4

void entry_1711a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1711a4) {
        switch (ctx->pc) {
            case 0x1711c0: ctx->pc = 0; goto label_1711c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1711a4: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x1711a8: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1711ac: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1711b0: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1711b4: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1711b8: 0x10000017
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171218; return;
    }
label_1711c0:
    // 0x1711c0: 0x50400019
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x171228; return;
    }
    // 0x1711c8: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1711cc: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1711d0: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x1711d4: 0x10400004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1711e8(rdram, ctx, runtime); return;
    }
    // 0x1711dc: 0xc60c220c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8716)); ctx->f[12] = *(float*)&val; }
    // 0x1711e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1711e8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1711e8
// Address: 0x1711e8 - 0x171200

void entry_1711e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1711e8: 0x8e022208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8712)));
    // 0x1711ec: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1711f0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1711f4: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1711f8: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x171200);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_171200
// Address: 0x171200 - 0x171220

void entry_171200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171200) {
        switch (ctx->pc) {
            case 0x171218: ctx->pc = 0; goto label_171218;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171200: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x171204: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x171208: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17120c: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x171210: 0xc7ac0024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[12] = *(float*)&val; }
    // 0x171214: 0xc7ad0020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[13] = *(float*)&val; }
label_171218:
    // 0x171218: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x171220);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_171220
// Address: 0x171220 - 0x171238

void entry_171220(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171220) {
        switch (ctx->pc) {
            case 0x171228: ctx->pc = 0; goto label_171228;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171220: 0xe6000638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    // 0x171224: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_171228:
    // 0x171228: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17122c: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x171230: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtBalance__FP2JT
// Address: 0x171238 - 0x1712fc

void entry_1712fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1712fc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x171300: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x171304: 0xc44c3850
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14416)); ctx->f[12] = *(float*)&val; }
    // 0x171308: 0x24848d10
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937872));
    // 0x17130c: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x171310: 0xc062214
    SET_GPR_U32(ctx, 31, 0x171318);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_171318
// Address: 0x171318 - 0x17136c

void entry_171318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171318) {
        switch (ctx->pc) {
            case 0x171360: ctx->pc = 0; goto label_171360;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171318: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17131c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x171320: 0x24423840
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 14400));
    // 0x171324: 0x24633800
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 14336));
    // 0x171328: 0xd8440000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17132c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x171330: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x171334: 0x24843810
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 14352));
    // 0x171338: 0x4be410ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17133c: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x171340: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x171344: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x171348: 0x4bc229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x17134c: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x171350: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x171354: 0x8e422518
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9496)));
    // 0x171358: 0x4be22128
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x17135c: 0xf8440020
    WRITE128(ADD32(GPR_U32(ctx, 2), 32), _mm_castps_si128(ctx->vu0_vf[4]));
label_171360:
    // 0x171360: 0x8e452518
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9496)));
    // 0x171364: 0xc062288
    SET_GPR_U32(ctx, 31, 0x17136c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 64));
    LoadRotateMatrixEuler__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17136c
// Address: 0x17136c - 0x1713a8

void entry_17136c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17136c) {
        switch (ctx->pc) {
            case 0x171374: ctx->pc = 0; goto label_171374;
            case 0x171378: ctx->pc = 0; goto label_171378;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17136c: 0x10000002
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9496)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_171378;
    }
label_171374:
    // 0x171374: 0x8e442518
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9496)));
label_171378:
    // 0x171378: 0x80820010
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x17137c: 0x1050000b
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x1713AC; return;
    }
    // 0x171384: 0xa0900011
    WRITE8(ADD32(GPR_U32(ctx, 4), 17), (uint8_t)GPR_U32(ctx, 16));
    // 0x171388: 0x8e422518
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9496)));
    // 0x17138c: 0x80430011
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 17)));
    // 0x171390: 0xa0830010
    WRITE8(ADD32(GPR_U32(ctx, 4), 16), (uint8_t)GPR_U32(ctx, 3));
    // 0x171394: 0x8e4424f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9464)));
    // 0x171398: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17139c: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x1713a0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1713a8);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1713a8
// Address: 0x1713a8 - 0x171448

void entry_1713a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1713a8) {
        switch (ctx->pc) {
            case 0x1713ac: ctx->pc = 0; goto label_1713ac;
            case 0x1713f8: ctx->pc = 0; goto label_1713f8;
            case 0x171410: ctx->pc = 0; goto label_171410;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1713a8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
label_1713ac:
    // 0x1713ac: 0x8e442500
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9472)));
    // 0x1713b0: 0x40a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1713b4: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1713b8: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1713bc: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1713c0: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1713c4: 0x1080017e
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1719C0; return;
    }
    // 0x1713cc: 0x80830010
    SET_GPR_S32(ctx, 3, (int8_t)READ8(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x1713d0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1713d4: 0x5062017b
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
        ctx->pc = 0x1719C4; return;
    }
    // 0x1713dc: 0x8e432220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    // 0x1713e0: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1713f8;
    }
    // 0x1713e8: 0x50620009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
        goto label_171410;
    }
    // 0x1713f0: 0x100000c8
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171714; return;
    }
label_1713f8:
    // 0x1713f8: 0x8e420690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1680)));
    // 0x1713fc: 0x104000c5
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171714; return;
    }
    // 0x171404: 0x8e5306c0
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 18), 1728)));
    // 0x171408: 0x100000c2
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 18), 1696));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171714; return;
    }
label_171410:
    // 0x171410: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x171414: 0x146200bf
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x171714; return;
    }
    // 0x17141c: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x171420: 0x1062000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x171450; return;
    }
    // 0x171428: 0x146200ba
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x171714; return;
    }
    // 0x171430: 0x8e4323b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9144)));
    // 0x171434: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x171438: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17143c: 0x60202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x171440: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x171448);
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_171448
// Address: 0x171448 - 0x171480

void entry_171448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171448) {
        switch (ctx->pc) {
            case 0x171450: ctx->pc = 0; goto label_171450;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171448: 0x100000b2
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171714; return;
    }
label_171450:
    // 0x171450: 0x8e4323bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9148)));
    // 0x171454: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x171458: 0x8c710034
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x17145c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x171460: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x171464: 0x10400006
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_171480(rdram, ctx, runtime); return;
    }
    // 0x17146c: 0xc64c23c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9152)); ctx->f[12] = *(float*)&val; }
    // 0x171470: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x171474: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x171478: 0x40f809
    SET_GPR_U32(ctx, 31, 0x171480);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_171480
// Address: 0x171480 - 0x171494

void entry_171480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171480: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x171484: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171488: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17148c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x171494);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_171494
// Address: 0x171494 - 0x171524

void entry_171494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171494: 0x8e4223bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9148)));
    // 0x171498: 0x8c430040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x17149c: 0x1060009d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171714; return;
    }
    // 0x1714a4: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1714a8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1714ac: 0x4bc2106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1714b0: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1714b4: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1714b8: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1714bc: 0xda430150
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1714c0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1714c4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1714c8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1714cc: 0xc64123c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9156)); ctx->f[1] = *(float*)&val; }
    // 0x1714d0: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1714d4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1714d8: 0x4be0105c
    ctx->vu0_vf[2] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1714dc: 0xc44037d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14296)); ctx->f[0] = *(float*)&val; }
    // 0x1714e0: 0x4bc118ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1714e4: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1714e8: 0x4b03183d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1714ec: 0x4b0310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1714f0: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1714f4: 0x48301800
    SET_GPR_VEC(ctx, 16, _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1714f8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1714fc: 0x48b01000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    // 0x171500: 0x44901000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 16);
    // 0x171504: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x171508: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17150c: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x171510: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x171514: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x171518: 0x8c430020
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x17151c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x171524);
    ctx->f[20] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_171524
// Address: 0x171524 - 0x171538

void entry_171524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171524: 0x8e220008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8)));
    // 0x171528: 0x10400005
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171540; return;
    }
    // 0x171530: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x171538);
    ctx->f[13] = FPU_MOV_S(ctx->f[0]);
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_171538
// Address: 0x171538 - 0x17158c

void entry_171538(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171538) {
        switch (ctx->pc) {
            case 0x171540: ctx->pc = 0; goto label_171540;
            case 0x17155c: ctx->pc = 0; goto label_17155c;
            case 0x17156c: ctx->pc = 0; goto label_17156c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171538: 0x1000000c
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17156c;
    }
label_171540:
    // 0x171540: 0x8e220014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x171544: 0xc4410000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[1] = *(float*)&val; }
    // 0x171548: 0x4601a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17154c: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17155c;
    }
    // 0x171554: 0x10000005
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17156c;
    }
label_17155c:
    // 0x17155c: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x171560: 0x0
    // NOP
    // 0x171564: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[20] = FPU_MOV_S(ctx->f[0]);
        goto label_17156c;
    }
label_17156c:
    // 0x17156c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x171570: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x171574: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17158c(rdram, ctx, runtime); return;
    }
    // 0x17157c: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x171580: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171584: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17158c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17158c
// Address: 0x17158c - 0x1715a0

void entry_17158c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17158c: 0x27a60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    // 0x171590: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x171594: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171598: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1715a0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1715a0
// Address: 0x1715a0 - 0x171648

void entry_1715a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1715a0: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1715a4: 0x48b01000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 16));
    // 0x1715a8: 0x4bc5286a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[5]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x1715ac: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1715b0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1715b4: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1715b8: 0x8e421090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4240)));
    // 0x1715bc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1715c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1715c4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1715c8: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1715cc: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1715d0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1715d4: 0x4be0285c
    ctx->vu0_vf[5] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1715d8: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1715dc: 0x4be20898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1715e0: 0x4be310ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1715e4: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1715e8: 0x1040004c
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17171C; return;
    }
    // 0x1715f0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1715f4: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1715f8: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x1715fc: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x171600: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x171604: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171608: 0x4bc50afe
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[30], ctx->vu0_vf[30], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; ctx->vi[5] = READ32(addr); }
    // 0x17160c: 0x4bc1286e
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128 res = PS2_VSUB(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x171610: 0x4a21086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[17], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(0, 0, 0, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x171614: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x171618: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17161c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x171620: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x171624: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x171628: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17162c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x171630: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x171634: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x171638: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17163c: 0x4be0089c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x171640: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x171648);
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_171648
// Address: 0x171648 - 0x1716c8

void entry_171648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171648) {
        switch (ctx->pc) {
            case 0x171688: ctx->pc = 0; goto label_171688;
            case 0x171694: ctx->pc = 0; goto label_171694;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171648: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17164c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x171650: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x171654: 0xc44137dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14300)); ctx->f[1] = *(float*)&val; }
    // 0x171658: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17165c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x171660: 0x46010003
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[1];
    // 0x171664: 0x460e0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[14])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x171668: 0x0
    // NOP
    // 0x17166c: 0x45010006
    ctx->f[1] = FPU_MOV_S(ctx->f[14]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_171688;
    }
    // 0x171674: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x171678: 0x0
    // NOP
    // 0x17167c: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_171688;
    }
    // 0x171684: 0x46001046
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
label_171688:
    // 0x171688: 0x8e4223c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9160)));
    // 0x17168c: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->f[1] = FPU_NEG_S(ctx->f[1]);
        goto label_171694;
    }
label_171694:
    // 0x171694: 0x46000805
    ctx->f[0] = FPU_ABS_S(ctx->f[1]);
    // 0x171698: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x17169c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1716a0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1716a4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1716a8: 0xc44f1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[15] = *(float*)&val; }
    // 0x1716ac: 0x24843858
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 14424));
    // 0x1716b0: 0x46007381
    ctx->f[14] = FPU_SUB_S(ctx->f[14], ctx->f[0]);
    // 0x1716b4: 0xc64c1094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4244)); ctx->f[12] = *(float*)&val; }
    // 0x1716b8: 0xc64d1098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4248)); ctx->f[13] = *(float*)&val; }
    // 0x1716bc: 0x26451098
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 18), 4248));
    // 0x1716c0: 0xc07a988
    SET_GPR_U32(ctx, 31, 0x1716c8);
    ctx->f[14] = FPU_MUL_S(ctx->f[1], ctx->f[14]);
    GSmoothA__FffffP4SMPAPf(rdram, ctx, runtime); return;
}


// Function: entry_1716c8
// Address: 0x1716c8 - 0x17170c

void entry_1716c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1716c8: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1716cc: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x1716d0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1716d4: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1716d8: 0x46000047
    ctx->f[1] = FPU_NEG_S(ctx->f[0]);
    // 0x1716dc: 0x46020128
    ctx->f[4] = std::max(ctx->f[0], ctx->f[2]);
    // 0x1716e0: 0x8e441090
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 4240)));
    // 0x1716e4: 0x460418c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[4]);
    // 0x1716e8: 0xe6401094
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 4244), *(uint32_t*)&val); }
    // 0x1716ec: 0x46020868
    ctx->f[1] = std::max(ctx->f[1], ctx->f[2]);
    // 0x1716f0: 0xe644106c
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 18), 4204), *(uint32_t*)&val); }
    // 0x1716f4: 0xe6411084
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 4228), *(uint32_t*)&val); }
    // 0x1716f8: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1716fc: 0x460118c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[1]);
    // 0x171700: 0x2647106c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 4204));
    // 0x171704: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x17170c);
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 18), 4216), *(uint32_t*)&val); }
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_17170c
// Address: 0x17170c - 0x171740

void entry_17170c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17170c) {
        switch (ctx->pc) {
            case 0x171714: ctx->pc = 0; goto label_171714;
            case 0x17171c: ctx->pc = 0; goto label_17171c;
            case 0x171720: ctx->pc = 0; goto label_171720;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17170c: 0x10000004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_171720;
    }
label_171714:
    // 0x171714: 0x126000ab
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1719C4; return;
    }
label_17171c:
    // 0x17171c: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
label_171720:
    // 0x171720: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171724: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171728: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17172c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x171730: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171734: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x171738: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x171740);
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_171740
// Address: 0x171740 - 0x171758

void entry_171740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171740: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x171744: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x171748: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17174c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x171750: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x171758);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_171758
// Address: 0x171758 - 0x171780

void entry_171758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171758: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17175c: 0xc62c37d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 14296)); ctx->f[12] = *(float*)&val; }
    // 0x171760: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x171764: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x171768: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17176c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171770: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171774: 0x27a80040
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 64));
    // 0x171778: 0xc049676
    SET_GPR_U32(ctx, 31, 0x171780);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_171780
// Address: 0x171780 - 0x1719e8

void entry_171780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171780) {
        switch (ctx->pc) {
            case 0x171844: ctx->pc = 0; goto label_171844;
            case 0x171854: ctx->pc = 0; goto label_171854;
            case 0x1718e8: ctx->pc = 0; goto label_1718e8;
            case 0x1718f4: ctx->pc = 0; goto label_1718f4;
            case 0x17195c: ctx->pc = 0; goto label_17195c;
            case 0x171960: ctx->pc = 0; goto label_171960;
            case 0x1719a4: ctx->pc = 0; goto label_1719a4;
            case 0x1719c0: ctx->pc = 0; goto label_1719c0;
            case 0x1719c4: ctx->pc = 0; goto label_1719c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171780: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x171784: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x171788: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17178c: 0x8e3137d8
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 14296)));
    // 0x171790: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x171794: 0x48b12000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 17));
    // 0x171798: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17179c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1717a0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1717a4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1717a8: 0x4a6403bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x1717ac: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1717b0: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1717b4: 0xfba40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x1717b8: 0x4b8108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1717bc: 0x4b021081
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1717c0: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1717c4: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1717c8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1717cc: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1717d0: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1717d4: 0x44823800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 2);
    // 0x1717d8: 0x46070034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[7])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1717dc: 0x0
    // NOP
    // 0x1717e0: 0x45000041
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1718e8;
    }
    // 0x1717e8: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x1717ec: 0xc44337dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14300)); ctx->f[3] = *(float*)&val; }
    // 0x1717f0: 0x24a337f0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 5), 14320));
    // 0x1717f4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1717f8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1717fc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x171800: 0x460338c3
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[3] = copysignf(INFINITY, ctx->f[7] * 0.0f); } else ctx->f[3] = ctx->f[7] / ctx->f[3];
    // 0x171804: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x171808: 0xc4620004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[2] = *(float*)&val; }
    // 0x17180c: 0x24825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x171810: 0xc4a437f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 14320)); ctx->f[4] = *(float*)&val; }
    // 0x171814: 0xc4855c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x171818: 0x46030029
    ctx->f[0] = std::min(ctx->f[0], ctx->f[3]);
    // 0x17181c: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x171820: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x171824: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x171828: 0x46002100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x17182c: 0x46052034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x171830: 0x0
    // NOP
    // 0x171834: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[6] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_171844;
    }
    // 0x17183c: 0x10000005
    ctx->f[4] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_171854;
    }
label_171844:
    // 0x171844: 0x46043034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x171848: 0x0
    // NOP
    // 0x17184c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[4] = FPU_MOV_S(ctx->f[6]);
        goto label_171854;
    }
label_171854:
    // 0x171854: 0x26420660
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 18), 1632));
    // 0x171858: 0xda410660
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 1632)));
    // 0x17185c: 0xd8430020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x171860: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x171864: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x171868: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x17186c: 0xdba40050
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x171870: 0x4be40a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x171874: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x171878: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17187c: 0x4be419aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x171880: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x171884: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x171888: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x17188c: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x171890: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x171894: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x171898: 0xc46337e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 14304)); ctx->f[3] = *(float*)&val; }
    // 0x17189c: 0xfba50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x1718a0: 0xc48237e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 14308)); ctx->f[2] = *(float*)&val; }
    // 0x1718a4: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x1718a8: 0x46041082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x1718ac: 0xc7a00054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[0] = *(float*)&val; }
    // 0x1718b0: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x1718b4: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x1718b8: 0x46040842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x1718bc: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x1718c0: 0x46070843
    if (ctx->f[7] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[7];
    // 0x1718c4: 0x46070003
    if (ctx->f[7] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[7];
    // 0x1718c8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x1718cc: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x1718d0: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1718d4: 0x44031000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[2]);
    // 0x1718d8: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x1718dc: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x1718e0: 0x10000004
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1718f4;
    }
label_1718e8:
    // 0x1718e8: 0x26a38d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 21), 4294937904));
    // 0x1718ec: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1718f0: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
label_1718f4:
    // 0x1718f4: 0x7ba20060
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1718f8: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x1718fc: 0x8e432500
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9472)));
    // 0x171900: 0x24a43870
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 14448));
    // 0x171904: 0x7c620020
    WRITE128(ADD32(GPR_U32(ctx, 3), 32), GPR_VEC(ctx, 2));
    // 0x171908: 0x8e42250c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9484)));
    // 0x17190c: 0xc4820008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 8)); ctx->f[2] = *(float*)&val; }
    // 0x171910: 0xc4430028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 40)); ctx->f[3] = *(float*)&val; }
    // 0x171914: 0xc4840004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[4] = *(float*)&val; }
    // 0x171918: 0x46021802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[2]);
    // 0x17191c: 0x8e422510
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9488)));
    // 0x171920: 0xc4a53870
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 14448)); ctx->f[5] = *(float*)&val; }
    // 0x171924: 0xc4410028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 40)); ctx->f[1] = *(float*)&val; }
    // 0x171928: 0x46002000
    ctx->f[0] = FPU_ADD_S(ctx->f[4], ctx->f[0]);
    // 0x17192c: 0xc7a60068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[6] = *(float*)&val; }
    // 0x171930: 0x46020882
    ctx->f[2] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x171934: 0x460018c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x171938: 0x46022100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[2]);
    // 0x17193c: 0x46032800
    ctx->f[0] = FPU_ADD_S(ctx->f[5], ctx->f[3]);
    // 0x171940: 0x46040842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x171944: 0x46003034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x171948: 0x0
    // NOP
    // 0x17194c: 0x45000003
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17195c;
    }
    // 0x171954: 0x10000002
    ctx->f[5] = std::min(ctx->f[5], ctx->f[6]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_171960;
    }
label_17195c:
    // 0x17195c: 0x46002969
    ctx->f[5] = std::min(ctx->f[5], ctx->f[0]);
label_171960:
    // 0x171960: 0x8e422500
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9472)));
    // 0x171964: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x171968: 0xe4450028
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 2), 40), *(uint32_t*)&val); }
    // 0x17196c: 0x8e43223c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8764)));
    // 0x171970: 0x1464000c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 21), 4294937904));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        goto label_1719a4;
    }
    // 0x171978: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17197c: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x171980: 0x8c4237e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 14312)));
    // 0x171984: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x171988: 0x8e432504
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9476)));
    // 0x17198c: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x171990: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x171994: 0xf8610020
    WRITE128(ADD32(GPR_U32(ctx, 3), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x171998: 0x8e422508
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9480)));
    // 0x17199c: 0x10000008
    WRITE128(ADD32(GPR_U32(ctx, 2), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1719c0;
    }
label_1719a4:
    // 0x1719a4: 0x8e442504
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9476)));
    // 0x1719a8: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1719ac: 0x8e452508
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9480)));
    // 0x1719b0: 0x7c820020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 2));
    // 0x1719b4: 0x8e432504
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9476)));
    // 0x1719b8: 0x78620020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1719bc: 0x7ca20020
    WRITE128(ADD32(GPR_U32(ctx, 5), 32), GPR_VEC(ctx, 2));
label_1719c0:
    // 0x1719c0: 0x7bbf00e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 224)));
label_1719c4:
    // 0x1719c4: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1719c8: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1719cc: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1719d0: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1719d4: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x1719d8: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1719dc: 0xc7b400f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 240)); ctx->f[20] = *(float*)&val; }
    // 0x1719e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG
// Address: 0x1719e8 - 0x171a88

void entry_171a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171a88) {
        switch (ctx->pc) {
            case 0x171a90: ctx->pc = 0; goto label_171a90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171a88: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[21] = *(float*)&val; }
        goto label_171a90;
    }
label_171a90:
    // 0x171a90: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x171a94: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x171a98: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x171a9c: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x171aa0: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x171aa4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x171aa8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x171aac: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x171ab0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171ab4: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171ab8: 0xc04b35e
    SET_GPR_U32(ctx, 31, 0x171ac0);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime); return;
}


// Function: entry_171ac0
// Address: 0x171ac0 - 0x171afc

void entry_171ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171ac0: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x171ac4: 0x27a80010
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 16));
    // 0x171ac8: 0x8e620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 548)));
    // 0x171acc: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x171ad0: 0x46160001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[22]);
    // 0x171ad4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x171ad8: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x171adc: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x171ae0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171ae4: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171ae8: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x171aec: 0x582d
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171af0: 0x8c450080
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 128)));
    // 0x171af4: 0xc04b35e
    SET_GPR_U32(ctx, 31, 0x171afc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime); return;
}


// Function: entry_171afc
// Address: 0x171afc - 0x171b28

void entry_171afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171afc: 0x8e040008
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x171b00: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x171b04: 0x27a90030
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 48));
    // 0x171b08: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x171b0c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x171b10: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x171b14: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x171b18: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x171b1c: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171b20: 0xc04b35e
    SET_GPR_U32(ctx, 31, 0x171b28);
    SET_GPR_U64(ctx, 11, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAsegEffect__FP4ASEGffP3ALOT3iP6VECTORP7MATRIX3T6T6(rdram, ctx, runtime); return;
}


// Function: entry_171b28
// Address: 0x171b28 - 0x171c30

void entry_171b28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171b28: 0x8e620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 548)));
    // 0x171b2c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x171b30: 0xdba50030
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x171b34: 0x3c090025
    SET_GPR_U32(ctx, 9, ((uint32_t)37 << 16));
    // 0x171b38: 0xd8410060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 96)));
    // 0x171b3c: 0x25298d20
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 9), 4294937888));
    // 0x171b40: 0xdba40040
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x171b44: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x171b48: 0xdba30050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x171b4c: 0x26440020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 32));
    // 0x171b50: 0x4bc129bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x171b54: 0x4bc120bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x171b58: 0x4bc1184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x171b5c: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x171b60: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x171b64: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x171b68: 0x4be220ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x171b6c: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x171b70: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x171b74: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x171b78: 0x8c633880
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 14464)));
    // 0x171b7c: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x171b80: 0xfa410020
    WRITE128(ADD32(GPR_U32(ctx, 18), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x171b84: 0x48a33000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x171b88: 0x8c423884
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 14468)));
    // 0x171b8c: 0x27a60070
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 112));
    // 0x171b90: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x171b94: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x171b98: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x171b9c: 0x8e630224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 548)));
    // 0x171ba0: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x171ba4: 0x27a80080
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 128));
    // 0x171ba8: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x171bac: 0xd8610070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x171bb0: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x171bb4: 0x4b000143
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x171bb8: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x171bbc: 0x4b01284a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x171bc0: 0xd8420100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 256)));
    // 0x171bc4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x171bc8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x171bcc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x171bd0: 0x4bc210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x171bd4: 0x4b0001c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x171bd8: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x171bdc: 0x4b02388a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x171be0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x171be4: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x171be8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x171bec: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x171bf0: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x171bf4: 0xfba600f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x171bf8: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x171bfc: 0x44826000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 2);
    // 0x171c00: 0xfba300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x171c04: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x171c08: 0x46016300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[1]);
    // 0x171c0c: 0xe64c0008
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 18), 8), *(uint32_t*)&val); }
    // 0x171c10: 0xd9210000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x171c14: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x171c18: 0x4be308c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x171c1c: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x171c20: 0x4be60908
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x171c24: 0xfba30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x171c28: 0xc0507d2
    SET_GPR_U32(ctx, 31, 0x171c30);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    ClsgClipEdgeToSphere__FP6VECTORfT0T0iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_171c30
// Address: 0x171c30 - 0x171c80

void entry_171c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171c30) {
        switch (ctx->pc) {
            case 0x171c50: ctx->pc = 0; goto label_171c50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171c30: 0x7ba50000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x171c34: 0x2102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 0), GPR_S32(ctx, 2)));
    // 0x171c38: 0x7ba40080
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x171c3c: 0x7ba30090
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x171c40: 0xae420004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 2));
    // 0x171c44: 0x7e430040
    WRITE128(ADD32(GPR_U32(ctx, 18), 64), GPR_VEC(ctx, 3));
    // 0x171c48: 0x7e450010
    WRITE128(ADD32(GPR_U32(ctx, 18), 16), GPR_VEC(ctx, 5));
    // 0x171c4c: 0x7e440030
    WRITE128(ADD32(GPR_U32(ctx, 18), 48), GPR_VEC(ctx, 4));
label_171c50:
    // 0x171c50: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x171c54: 0x7bb40140
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x171c58: 0x7bb30130
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x171c5c: 0x7bb20120
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x171c60: 0x7bb10110
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x171c64: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x171c68: 0xc7b60170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[22] = *(float*)&val; }
    // 0x171c6c: 0xc7b50168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 360)); ctx->f[21] = *(float*)&val; }
    // 0x171c70: 0xc7b40160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[20] = *(float*)&val; }
    // 0x171c74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x171c7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x171c80; return;
}


// Function: FMatchJtXmg__FP2JTP3XMGP6ACTADJ
// Address: 0x171c80 - 0x171cb8

void entry_171cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171cb8: 0x27b10070
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 112));
    // 0x171cbc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x171cc0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171cc4: 0x26660030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 48));
    // 0x171cc8: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x171cd0);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_171cd0
// Address: 0x171cd0 - 0x171ce8

void entry_171cd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171cd0: 0x27b00080
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 128));
    // 0x171cd4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x171cd8: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x171cdc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171ce0: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x171ce8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 64));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_171ce8
// Address: 0x171ce8 - 0x171d0c

void entry_171ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171ce8: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x171cec: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x171cf0: 0x8e450050
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 80)));
    // 0x171cf4: 0x27aa00a0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 160));
    // 0x171cf8: 0x27ab00a4
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 164));
    // 0x171cfc: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x171d00: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171d04: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x171d0c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_171d0c
// Address: 0x171d0c - 0x171d28

void entry_171d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171d0c: 0x8fa700a0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x171d10: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x171d14: 0x8fa800a4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 164)));
    // 0x171d18: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x171d1c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171d20: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x171d28);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_171d28
// Address: 0x171d28 - 0x171d30

void entry_171d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171d28: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x171d30);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_171d30
// Address: 0x171d30 - 0x171d60

void entry_171d30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171d30: 0x12000011
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171D78; return;
    }
    // 0x171d38: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x171d3c: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x171d40: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x171d44: 0xd8420000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x171d48: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171d4c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x171d50: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x171d54: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x171d58: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x171d60);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 144));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_171d60
// Address: 0x171d60 - 0x171dd8

void entry_171d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171d60) {
        switch (ctx->pc) {
            case 0x171d78: ctx->pc = 0; goto label_171d78;
            case 0x171db0: ctx->pc = 0; goto label_171db0;
            case 0x171db4: ctx->pc = 0; goto label_171db4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171d60: 0xda620010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x171d64: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x171d68: 0xdba10090
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x171d6c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x171d70: 0x10000010
    WRITE128(ADD32(GPR_U32(ctx, 20), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_171db4;
    }
label_171d78:
    // 0x171d78: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x171d7c: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x171d80: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x171d84: 0x7e830020
    WRITE128(ADD32(GPR_U32(ctx, 20), 32), GPR_VEC(ctx, 3));
    // 0x171d88: 0x8e420690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1680)));
    // 0x171d8c: 0x10400009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_171db4;
    }
    // 0x171d94: 0xc6610048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 72)); ctx->f[1] = *(float*)&val; }
    // 0x171d98: 0x3c01c2aa
    SET_GPR_U32(ctx, 1, ((uint32_t)49834 << 16));
    // 0x171d9c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x171da0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x171da4: 0x0
    // NOP
    // 0x171da8: 0x45010002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_171db4;
    }
label_171db0:
    // 0x171db0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_171db4:
    // 0x171db4: 0x7bbf0100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x171db8: 0x7bb400f0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x171dbc: 0x7bb300e0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x171dc0: 0x7bb200d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x171dc4: 0x7bb100c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x171dc8: 0x7bb000b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x171dcc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x171dd4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x171dd8; return;
}


// Function: UpdateJtStand__FP2JT
// Address: 0x171dd8 - 0x171df8

void entry_171df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171df8: 0x54400017
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9484)));
        ctx->pc = 0x171E58; return;
    }
    // 0x171e00: 0x8e220690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
    // 0x171e04: 0x10400013
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171E54; return;
    }
    // 0x171e0c: 0x8e2406c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1728)));
    // 0x171e10: 0x262606a0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 1696));
    // 0x171e14: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171e18: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x171e1c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x171e20: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x171e28);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_171e28
// Address: 0x171e28 - 0x171e38

void entry_171e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171e28: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x171e2c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x171e30: 0xc07a920
    SET_GPR_U32(ctx, 31, 0x171e38);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[12] = *(float*)&val; }
    GLimitAbs__Fff(rdram, ctx, runtime); return;
}


// Function: entry_171e38
// Address: 0x171e38 - 0x171e84

void entry_171e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171e38) {
        switch (ctx->pc) {
            case 0x171e54: ctx->pc = 0; goto label_171e54;
            case 0x171e58: ctx->pc = 0; goto label_171e58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171e38: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x171e3c: 0xc6220638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1592)); ctx->f[2] = *(float*)&val; }
    // 0x171e40: 0xc4411860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[1] = *(float*)&val; }
    // 0x171e44: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x171e48: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x171e4c: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x171e50: 0xe6220638
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
label_171e54:
    // 0x171e54: 0x8e27250c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9484)));
label_171e58:
    // 0x171e58: 0x10e0002b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 4496));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171F08; return;
    }
    // 0x171e60: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x171e64: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x171e68: 0x8e250628
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1576)));
    // 0x171e6c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x171e70: 0x8e260620
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1568)));
    // 0x171e74: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x171e78: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x171e7c: 0xc05c67a
    SET_GPR_U32(ctx, 31, 0x171e84);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 4752));
    RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG(rdram, ctx, runtime); return;
}


// Function: entry_171e84
// Address: 0x171e84 - 0x171ea0

void entry_171e84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171e84: 0x8e25062c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1580)));
    // 0x171e88: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x171e8c: 0x8e260624
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1572)));
    // 0x171e90: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x171e94: 0x8e272510
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9488)));
    // 0x171e98: 0xc05c67a
    SET_GPR_U32(ctx, 31, 0x171ea0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG(rdram, ctx, runtime); return;
}


// Function: entry_171ea0
// Address: 0x171ea0 - 0x171eb0

void entry_171ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171ea0: 0x8e26250c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 9484)));
    // 0x171ea4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x171ea8: 0xc05c720
    SET_GPR_U32(ctx, 31, 0x171eb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FMatchJtXmg__FP2JTP3XMGP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_171eb0
// Address: 0x171eb0 - 0x171ec4

void entry_171eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171eb0: 0x10400006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171ECC; return;
    }
    // 0x171eb8: 0x8e262510
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 9488)));
    // 0x171ebc: 0xc05c720
    SET_GPR_U32(ctx, 31, 0x171ec4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FMatchJtXmg__FP2JTP3XMGP6ACTADJ(rdram, ctx, runtime); return;
}


// Function: entry_171ec4
// Address: 0x171ec4 - 0x171eec

void entry_171ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171ec4) {
        switch (ctx->pc) {
            case 0x171ecc: ctx->pc = 0; goto label_171ecc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171ec4: 0x14400011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x171F0C; return;
    }
label_171ecc:
    // 0x171ecc: 0x8e22118c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 4492)));
    // 0x171ed0: 0x1440000e
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x171F0C; return;
    }
    // 0x171ed8: 0x8e241188
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 4488)));
    // 0x171edc: 0x1080000c
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x171F10; return;
    }
    // 0x171ee4: 0xc06d8f0
    SET_GPR_U32(ctx, 31, 0x171eec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 328));
    IsmsFindSmOptional__FP2SM3OID(rdram, ctx, runtime); return;
}


// Function: entry_171eec
// Address: 0x171eec - 0x171f00

void entry_171eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171eec: 0x4400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_S32(ctx, 2) < 0) {
        ctx->pc = 0x171F04; return;
    }
    // 0x171ef4: 0x8e242234
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8756)));
    // 0x171ef8: 0xc06d98a
    SET_GPR_U32(ctx, 31, 0x171f00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 328));
    SeekSma__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_171f00
// Address: 0x171f00 - 0x171f28

void entry_171f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171f00) {
        switch (ctx->pc) {
            case 0x171f04: ctx->pc = 0; goto label_171f04;
            case 0x171f08: ctx->pc = 0; goto label_171f08;
            case 0x171f0c: ctx->pc = 0; goto label_171f0c;
            case 0x171f10: ctx->pc = 0; goto label_171f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171f00: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_171f04:
    // 0x171f04: 0xae22118c
    WRITE32(ADD32(GPR_U32(ctx, 17), 4492), GPR_U32(ctx, 2));
label_171f08:
    // 0x171f08: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_171f0c:
    // 0x171f0c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_171f10:
    // 0x171f10: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x171f14: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x171f18: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x171f1c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x171f24: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x171f28; return;
}


// Function: ThrowJt__FP2JTP6VECTORff
// Address: 0x171f28 - 0x171f74

void entry_171f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171f74: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x171f78: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x171f7c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x171f80: 0x40f809
    SET_GPR_U32(ctx, 31, 0x171f88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_171f88
// Address: 0x171f88 - 0x171fa4

void entry_171f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x171f88: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x171f8c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x171f90: 0x1062000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x171FC4; return;
    }
    // 0x171f98: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x171f9c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x171fa4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_171fa4
// Address: 0x171fa4 - 0x171fe0

void entry_171fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x171fa4) {
        switch (ctx->pc) {
            case 0x171fc4: ctx->pc = 0; goto label_171fc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x171fa4: 0xc620226c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8812)); ctx->f[0] = *(float*)&val; }
    // 0x171fa8: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x171fac: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x171fb0: 0x4601a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x171fb4: 0x0
    // NOP
    // 0x171fb8: 0x45000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 8812), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_171fc4;
    }
    // 0x171fc0: 0xae202498
    WRITE32(ADD32(GPR_U32(ctx, 17), 9368), GPR_U32(ctx, 0));
label_171fc4:
    // 0x171fc4: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x171fc8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x171fcc: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x171fd0: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x171fd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x171fdc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x171fe0; return;
}


// Function: UnhookJt__FP2JT
// Address: 0x171fe0 - 0x172038

void entry_172038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172038) {
        switch (ctx->pc) {
            case 0x172040: ctx->pc = 0; goto label_172040;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172038: 0x1000000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17206C; return;
    }
label_172040:
    // 0x172040: 0x8ca3239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 9116)));
    // 0x172044: 0x28620006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 6));
    // 0x172048: 0x10400007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_172068(rdram, ctx, runtime); return;
    }
    // 0x172050: 0x14400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17206C; return;
    }
    // 0x172058: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x17205c: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x172060: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x172068);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_172068
// Address: 0x172068 - 0x172078

void entry_172068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172068) {
        switch (ctx->pc) {
            case 0x17206c: ctx->pc = 0; goto label_17206c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172068: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_17206c:
    // 0x17206c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x172074: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x172078; return;
}


// Function: CalculateJtToolSpin__FP2JTfP7MATRIX3
// Address: 0x172078 - 0x1720e4

void entry_1720e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1720e4: 0x260200d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 208));
    // 0x1720e8: 0xda0400d0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x1720ec: 0xd8420020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x1720f0: 0xd8410010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x1720f4: 0xdba30010
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1720f8: 0xdba50020
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1720fc: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x172100: 0x4bc308bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x172104: 0x4bc310ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x172108: 0x4bc521bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x17210c: 0x4bc508bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x172110: 0x4bc5114a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x172114: 0xdba60030
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x172118: 0x8e02061c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1564)));
    // 0x17211c: 0x4bc621bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x172120: 0x4bc608bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x172124: 0x4bc6110a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x172128: 0xfba300a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17212c: 0xfba30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x172130: 0x244300d0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 208));
    // 0x172134: 0xfba50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x172138: 0xfba40090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17213c: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x172140: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x172144: 0xd84600d0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 208)));
    // 0x172148: 0x4bc619bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x17214c: 0x4bc628bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x172150: 0x4bc6218a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x172154: 0xfba500b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x172158: 0xfba400c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17215c: 0xfba60040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x172160: 0xd8620010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x172164: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x172168: 0x4bc228bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17216c: 0x4bc2208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x172170: 0xfba600a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x172174: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x172178: 0xfba200b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17217c: 0xd8610020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x172180: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x172184: 0x4bc128bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x172188: 0x4bc120ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17218c: 0xfa260000
    WRITE128(ADD32(GPR_U32(ctx, 17), 0), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x172190: 0xfa230020
    WRITE128(ADD32(GPR_U32(ctx, 17), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x172194: 0xfa220010
    WRITE128(ADD32(GPR_U32(ctx, 17), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x172198: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x17219c: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1721a0: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1721a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 256));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1721ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1721b0; return;
}


// Function: RenderJtAll__FP2JTP2CMP2RO
// Address: 0x1721b0 - 0x172218

void entry_172218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172218) {
        switch (ctx->pc) {
            case 0x172258: ctx->pc = 0; goto label_172258;
            case 0x172264: ctx->pc = 0; goto label_172264;
            case 0x17229c: ctx->pc = 0; goto label_17229c;
            case 0x1722a0: ctx->pc = 0; goto label_1722a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172218: 0x10400020
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17229c;
    }
    // 0x172220: 0xc6212224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8740)); ctx->f[1] = *(float*)&val; }
    // 0x172224: 0x24431858
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x172228: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x17222c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x172230: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x172234: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x172238: 0x46001036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17223c: 0x0
    // NOP
    // 0x172240: 0x45000005
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_172258;
    }
    // 0x172248: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17224c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x172250: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_172264;
    }
label_172258:
    // 0x172258: 0x46001041
    ctx->f[1] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x17225c: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x172260: 0x460100c3
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[3] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[3] = ctx->f[0] / ctx->f[1];
label_172264:
    // 0x172264: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x172268: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17226c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x172270: 0xc4403894
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14484)); ctx->f[0] = *(float*)&val; }
    // 0x172274: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x172278: 0x46030841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x17227c: 0xc6222724
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 10020)); ctx->f[2] = *(float*)&val; }
    // 0x172280: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x172284: 0xc46d3898
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 14488)); ctx->f[13] = *(float*)&val; }
    // 0x172288: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x17228c: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x172290: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x172294: 0x1000000f
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 10020), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1722D4; return;
    }
label_17229c:
    // 0x17229c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
label_1722a0:
    // 0x1722a0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1722a4: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1722a8: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x1722ac: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1722b0: 0xc44e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1722b4: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x1722b8: 0xc62c2724
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 10020)); ctx->f[12] = *(float*)&val; }
    // 0x1722bc: 0x26043888
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 14472));
    // 0x1722c0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1722c4: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1722cc);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1722cc
// Address: 0x1722cc - 0x1722ec

void entry_1722cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1722cc) {
        switch (ctx->pc) {
            case 0x1722d4: ctx->pc = 0; goto label_1722d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1722cc: 0xe6202724
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 10020), *(uint32_t*)&val); }
    // 0x1722d0: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
label_1722d4:
    // 0x1722d4: 0x26621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 6232));
    // 0x1722d8: 0xc62c2728
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 10024)); ctx->f[12] = *(float*)&val; }
    // 0x1722dc: 0xc44e0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[14] = *(float*)&val; }
    // 0x1722e0: 0x26043888
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 14472));
    // 0x1722e4: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1722ec);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1722ec
// Address: 0x1722ec - 0x17232c

void entry_1722ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1722ec) {
        switch (ctx->pc) {
            case 0x17231c: ctx->pc = 0; goto label_17231c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1722ec: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x1722f0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1722f4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1722f8: 0xc6202724
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 10020)); ctx->f[0] = *(float*)&val; }
    // 0x1722fc: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x172300: 0x0
    // NOP
    // 0x172304: 0x45010005
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 10024), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17231c;
    }
    // 0x17230c: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x172310: 0x0
    // NOP
    // 0x172314: 0x4502000d
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9268)); ctx->f[1] = *(float*)&val; }
        ctx->pc = 0x17234C; return;
    }
label_17231c:
    // 0x17231c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x172320: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x172324: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x17232c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_17232c
// Address: 0x17232c - 0x172388

void entry_17232c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17232c) {
        switch (ctx->pc) {
            case 0x17234c: ctx->pc = 0; goto label_17234c;
            case 0x17237c: ctx->pc = 0; goto label_17237c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17232c: 0xc6212724
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 10020)); ctx->f[1] = *(float*)&val; }
    // 0x172330: 0x3a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x172334: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x172338: 0xc6222728
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 10024)); ctx->f[2] = *(float*)&val; }
    // 0x17233c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x172340: 0xe7a20044
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 29), 68), *(uint32_t*)&val); }
    // 0x172344: 0xe7a00040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 64), *(uint32_t*)&val); }
    // 0x172348: 0xc6212434
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9268)); ctx->f[1] = *(float*)&val; }
label_17234c:
    // 0x17234c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x172350: 0x3c0143fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17402 << 16));
    // 0x172354: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x172358: 0x460c0832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17235c: 0x0
    // NOP
    // 0x172360: 0x45000006
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 680), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17237c;
    }
    // 0x172368: 0xc6202430
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9264)); ctx->f[0] = *(float*)&val; }
    // 0x17236c: 0x460c0032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x172370: 0x0
    // NOP
    // 0x172374: 0x45030036
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x172450; return;
    }
label_17237c:
    // 0x17237c: 0x27a50090
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 144));
    // 0x172380: 0xc05c81e
    SET_GPR_U32(ctx, 31, 0x172388);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CalculateJtToolSpin__FP2JTfP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_172388
// Address: 0x172388 - 0x172434

void entry_172388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172388: 0x8e2323d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9168)));
    // 0x17238c: 0x26681858
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 19), 6232));
    // 0x172390: 0xdba40090
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x172394: 0x26241520
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 5408));
    // 0x172398: 0xd8620100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 256)));
    // 0x17239c: 0x246900d0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 3), 208));
    // 0x1723a0: 0xdba600a0
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1723a4: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1723a8: 0xdba500b0
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1723ac: 0x27a60060
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 96));
    // 0x1723b0: 0x8e22061c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1564)));
    // 0x1723b4: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1723b8: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x1723bc: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1723c0: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1723c4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1723c8: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1723cc: 0xc50d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 8)); ctx->f[13] = *(float*)&val; }
    // 0x1723d0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1723d4: 0xc62c2430
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9264)); ctx->f[12] = *(float*)&val; }
    // 0x1723d8: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1723dc: 0xd86300d0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 208)));
    // 0x1723e0: 0x4bc321bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x1723e4: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1723e8: 0x4bc328ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1723ec: 0xfba300c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1723f0: 0xfba300f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1723f4: 0xd9220010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 9), 16)));
    // 0x1723f8: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1723fc: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x172400: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x172404: 0xfba200d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x172408: 0xfba20100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17240c: 0xd9210020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 9), 32)));
    // 0x172410: 0x4bc121bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x172414: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x172418: 0x4bc1290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17241c: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x172420: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x172424: 0xfba40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x172428: 0xfba40110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17242c: 0xc070a7e
    SET_GPR_U32(ctx, 31, 0x172434);
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    UpdateSqtrm__FP5SQTRMP6VECTORP7MATRIX3ff(rdram, ctx, runtime); return;
}


// Function: entry_172434
// Address: 0x172434 - 0x172494

void entry_172434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172434) {
        switch (ctx->pc) {
            case 0x172450: ctx->pc = 0; goto label_172450;
            case 0x172478: ctx->pc = 0; goto label_172478;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172434: 0x8e24061c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1564)));
    // 0x172438: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x17243c: 0x31c78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 17);
    // 0x172440: 0xdc8202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    // 0x172444: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x172448: 0x10000012
    WRITE64(ADD32(GPR_U32(ctx, 4), 712), GPR_U64(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_172494(rdram, ctx, runtime); return;
    }
label_172450:
    // 0x172450: 0x28620003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    // 0x172454: 0x14400008
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_172478;
    }
    // 0x17245c: 0x28620005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    // 0x172460: 0x14400005
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_172478;
    }
    // 0x172468: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x17246c: 0x14620002
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_172478;
    }
    // 0x172474: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
label_172478:
    // 0x172478: 0x26621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 6232));
    // 0x17247c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x172480: 0xc44d0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[13] = *(float*)&val; }
    // 0x172484: 0x26241520
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 5408));
    // 0x172488: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17248c: 0xc070a7e
    SET_GPR_U32(ctx, 31, 0x172494);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UpdateSqtrm__FP5SQTRMP6VECTORP7MATRIX3ff(rdram, ctx, runtime); return;
}


// Function: entry_172494
// Address: 0x172494 - 0x1724e4

void entry_172494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172494) {
        switch (ctx->pc) {
            case 0x1724b4: ctx->pc = 0; goto label_1724b4;
            case 0x1724d8: ctx->pc = 0; goto label_1724d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172494: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x172498: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x17249c: 0x14620005
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_1724b4;
    }
    // 0x1724a4: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x1724a8: 0x24020022
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
    // 0x1724ac: 0x10620016
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x172508; return;
    }
label_1724b4:
    // 0x1724b4: 0x8c42fa68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4294965864)));
    // 0x1724b8: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1724d8;
    }
    // 0x1724c0: 0x8c4202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 720)));
    // 0x1724c4: 0x2442fffe
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x1724c8: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1724cc: 0x1440000f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17250C; return;
    }
    // 0x1724d4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_1724d8:
    // 0x1724d8: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1724dc: 0xc049724
    SET_GPR_U32(ctx, 31, 0x1724e4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RenderAloAll__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_1724e4
// Address: 0x1724e4 - 0x172530

void entry_1724e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1724e4) {
        switch (ctx->pc) {
            case 0x172508: ctx->pc = 0; goto label_172508;
            case 0x17250c: ctx->pc = 0; goto label_17250c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1724e4: 0x8e24061c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1564)));
    // 0x1724e8: 0x2403fffe
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x1724ec: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1724f0: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1724f4: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x1724f8: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x1724fc: 0xdc8202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    // 0x172500: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x172504: 0xfc8202c8
    WRITE64(ADD32(GPR_U32(ctx, 4), 712), GPR_U64(ctx, 2));
label_172508:
    // 0x172508: 0x7bbf0170
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 368)));
label_17250c:
    // 0x17250c: 0x7bb40160
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x172510: 0x7bb30150
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x172514: 0x7bb20140
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x172518: 0x7bb10130
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x17251c: 0x7bb00120
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x172520: 0xc7b40180
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 384)); ctx->f[20] = *(float*)&val; }
    // 0x172524: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 400));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17252c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x172530; return;
}


// Function: FUN_00172530
// Address: 0x172530 - 0x172548

void FUN_00172530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172530: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x172534: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x172538: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17253c: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x172540: 0xc07150e
    SET_GPR_U32(ctx, 31, 0x172548);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    UpdateStepXfWorld__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_172548
// Address: 0x172548 - 0x17259c

void entry_172548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172548) {
        switch (ctx->pc) {
            case 0x17256c: ctx->pc = 0; goto label_17256c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172548: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x17254c: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x172550: 0x54620006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
        goto label_17256c;
    }
    // 0x172558: 0x8e03239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9116)));
    // 0x17255c: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x172560: 0x50620018
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 4832), GPR_U32(ctx, 0));
        ctx->pc = 0x1725C4; return;
    }
    // 0x172568: 0x8e050610
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
label_17256c:
    // 0x17256c: 0x50a00015
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 4832), GPR_U32(ctx, 0));
        ctx->pc = 0x1725C4; return;
    }
    // 0x172574: 0x8e020614
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x172578: 0x10400011
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1725C0; return;
    }
    // 0x172580: 0x3c0140c0
    SET_GPR_U32(ctx, 1, ((uint32_t)16576 << 16));
    // 0x172584: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x172588: 0x8e070620
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 16), 1568)));
    // 0x17258c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x172590: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x172594: 0xc071186
    SET_GPR_U32(ctx, 31, 0x17259c);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 16), 4496));
    FUN_001c4618(rdram, ctx, runtime); return;
}


// Function: entry_17259c
// Address: 0x17259c - 0x1725b8

void entry_17259c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17259c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1725a0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1725a4: 0x8c850614
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 1556)));
    // 0x1725a8: 0x24881290
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 4), 4752));
    // 0x1725ac: 0x8c870624
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 4), 1572)));
    // 0x1725b0: 0xc071186
    SET_GPR_U32(ctx, 31, 0x1725b8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    FUN_001c4618(rdram, ctx, runtime); return;
}


// Function: entry_1725b8
// Address: 0x1725b8 - 0x1725e0

void entry_1725b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1725b8) {
        switch (ctx->pc) {
            case 0x1725c0: ctx->pc = 0; goto label_1725c0;
            case 0x1725c4: ctx->pc = 0; goto label_1725c4;
            case 0x1725cc: ctx->pc = 0; goto label_1725cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1725b8: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1725cc;
    }
label_1725c0:
    // 0x1725c0: 0xae0012e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 4832), GPR_U32(ctx, 0));
label_1725c4:
    // 0x1725c4: 0xae0011e0
    WRITE32(ADD32(GPR_U32(ctx, 16), 4576), GPR_U32(ctx, 0));
    // 0x1725c8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1725cc:
    // 0x1725cc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1725d0: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x1725d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1725dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1725e0; return;
}


// Function: FUN_001725e0
// Address: 0x1725e0 - 0x17263c

void FUN_001725e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1725e0) {
        switch (ctx->pc) {
            case 0x172628: ctx->pc = 0; goto label_172628;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1725e0: 0x27bdff10
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967056));
    // 0x1725e4: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1725e8: 0x7fb400c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 20));
    // 0x1725ec: 0x7fb300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 19));
    // 0x1725f0: 0xc0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1725f4: 0x7fb00080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 16));
    // 0x1725f8: 0x7fbf00d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 31));
    // 0x1725fc: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x172600: 0x7fb200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 18));
    // 0x172604: 0x7fb10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 17));
    // 0x172608: 0xe7b400e0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 224), *(uint32_t*)&val); }
    // 0x17260c: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x172610: 0x14620005
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_172628;
    }
    // 0x172618: 0x8e03239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9116)));
    // 0x17261c: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x172620: 0x5062000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9268)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x172654; return;
    }
label_172628:
    // 0x172628: 0x8e050610
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x17262c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x172630: 0x26071190
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 4496));
    // 0x172634: 0xc071212
    SET_GPR_U32(ctx, 31, 0x17263c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    FUN_001c4848(rdram, ctx, runtime); return;
}


// Function: entry_17263c
// Address: 0x17263c - 0x172650

void entry_17263c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17263c: 0x8e050614
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x172640: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x172644: 0x26071290
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 4752));
    // 0x172648: 0xc071212
    SET_GPR_U32(ctx, 31, 0x172650);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    FUN_001c4848(rdram, ctx, runtime); return;
}


// Function: entry_172650
// Address: 0x172650 - 0x1726b8

void entry_172650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172650) {
        switch (ctx->pc) {
            case 0x172654: ctx->pc = 0; goto label_172654;
            case 0x172680: ctx->pc = 0; goto label_172680;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172650: 0xc6002434
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9268)); ctx->f[0] = *(float*)&val; }
label_172654:
    // 0x172654: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x172658: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17265c: 0x0
    // NOP
    // 0x172660: 0x45020007
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1564)));
        goto label_172680;
    }
    // 0x172668: 0xc6002430
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9264)); ctx->f[0] = *(float*)&val; }
    // 0x17266c: 0x46010032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x172670: 0x0
    // NOP
    // 0x172674: 0x45030032
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
        ctx->pc = 0x172740; return;
    }
    // 0x17267c: 0x8e03061c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1564)));
label_172680:
    // 0x172680: 0x2407fffe
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 4294967294));
    // 0x172684: 0x73c38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 16);
    // 0x172688: 0x34e7ffff
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65535));
    // 0x17268c: 0x73c38
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 7) << 16);
    // 0x172690: 0x34e7ffff
    SET_GPR_U32(ctx, 7, OR32(GPR_U32(ctx, 7), 65535));
    // 0x172694: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x172698: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17269c: 0xdc6202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 3), 712)));
    // 0x1726a0: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1726a4: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1726a8: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1726ac: 0x471024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 7)));
    // 0x1726b0: 0xc0496dc
    SET_GPR_U32(ctx, 31, 0x1726b8);
    WRITE64(ADD32(GPR_U32(ctx, 3), 712), GPR_U64(ctx, 2));
    DupAloRo__FP3ALOP2ROT1(rdram, ctx, runtime); return;
}


// Function: entry_1726b8
// Address: 0x1726b8 - 0x1726ec

void entry_1726b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1726b8) {
        switch (ctx->pc) {
            case 0x1726d0: ctx->pc = 0; goto label_1726d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1726b8: 0xc7a00070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[0] = *(float*)&val; }
    // 0x1726bc: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x1726c0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1726c4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1726c8: 0x46000d06
    ctx->f[20] = FPU_MOV_S(ctx->f[1]);
    // 0x1726cc: 0xe7a00070
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
label_1726d0:
    // 0x1726d0: 0x44916000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 17);
    // 0x1726d4: 0x46806320
    ctx->f[12] = FPU_CVT_S_W(*(int32_t*)&ctx->f[12]);
    // 0x1726d8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1726dc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1726e0: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x1726e4: 0xc05c81e
    SET_GPR_U32(ctx, 31, 0x1726ec);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[20]);
    CalculateJtToolSpin__FP2JTfP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_1726ec
// Address: 0x1726ec - 0x172700

void entry_1726ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1726ec: 0x8e04061c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1564)));
    // 0x1726f0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1726f4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1726f8: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x172700);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 320));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_172700
// Address: 0x172700 - 0x172718

void entry_172700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172700: 0x8e04061c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1564)));
    // 0x172704: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x172708: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17270c: 0x8c6200a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 160)));
    // 0x172710: 0x40f809
    SET_GPR_U32(ctx, 31, 0x172718);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_172718
// Address: 0x172718 - 0x172754

void entry_172718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172718) {
        switch (ctx->pc) {
            case 0x172740: ctx->pc = 0; goto label_172740;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172718: 0x2a230004
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 17), 4));
    // 0x17271c: 0x1460ffec
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1726D0; return;
    }
    // 0x172724: 0x8e04061c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1564)));
    // 0x172728: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x17272c: 0x31c78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 17);
    // 0x172730: 0xdc8202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 712)));
    // 0x172734: 0x431025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x172738: 0xfc8202c8
    WRITE64(ADD32(GPR_U32(ctx, 4), 712), GPR_U64(ctx, 2));
    // 0x17273c: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
label_172740:
    // 0x172740: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x172744: 0x14620004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x172758; return;
    }
    // 0x17274c: 0xc073766
    SET_GPR_U32(ctx, 31, 0x172754);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001cdd98(rdram, ctx, runtime); return;
}


// Function: entry_172754
// Address: 0x172754 - 0x172764

void entry_172754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172754) {
        switch (ctx->pc) {
            case 0x172758: ctx->pc = 0; goto label_172758;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172754: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_172758:
    // 0x172758: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17275c: 0xc071272
    SET_GPR_U32(ctx, 31, 0x172764);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    RenderStepSelf__FP4STEPP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_172764
// Address: 0x172764 - 0x172778

void entry_172764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172764: 0x8e0221c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8640)));
    // 0x172768: 0x10400003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 5408));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_172778(rdram, ctx, runtime); return;
    }
    // 0x172770: 0xc070c0a
    SET_GPR_U32(ctx, 31, 0x172778);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RenderSqtrm__FP5SQTRMP2CM(rdram, ctx, runtime); return;
}


// Function: entry_172778
// Address: 0x172778 - 0x172788

void entry_172778(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172778: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17277c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x172780: 0xc0758b8
    SET_GPR_U32(ctx, 31, 0x172788);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    RenderJtSelfZap__FP2JTP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_172788
// Address: 0x172788 - 0x1727b0

void entry_172788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172788: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x17278c: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x172790: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x172794: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x172798: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x17279c: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x1727a0: 0xc7b400e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[20] = *(float*)&val; }
    // 0x1727a4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 240));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1727ac: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1727b0; return;
}


// Function: UpdateJtTool__FP2JT
// Address: 0x1727b0 - 0x172828

void entry_172828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172828) {
        switch (ctx->pc) {
            case 0x172830: ctx->pc = 0; goto label_172830;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172828: 0x10000014
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 9268), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17287C; return;
    }
label_172830:
    // 0x172830: 0x46156032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[12], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x172834: 0x0
    // NOP
    // 0x172838: 0x45010011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x172880; return;
    }
    // 0x172840: 0x3c0140c9
    SET_GPR_U32(ctx, 1, ((uint32_t)16585 << 16));
    // 0x172844: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x172848: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x17284c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x172850: 0xc44e1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[14] = *(float*)&val; }
    // 0x172854: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x172858: 0x248438a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 14496));
    // 0x17285c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x172860: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x172868);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 16), 9264));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_172868
// Address: 0x172868 - 0x172898

void entry_172868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172868) {
        switch (ctx->pc) {
            case 0x17287c: ctx->pc = 0; goto label_17287c;
            case 0x172880: ctx->pc = 0; goto label_172880;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172868: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17286c: 0x0
    // NOP
    // 0x172870: 0x45000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 9268), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17287c;
    }
    // 0x172878: 0xe6152434
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 16), 9268), *(uint32_t*)&val); }
label_17287c:
    // 0x17287c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_172880:
    // 0x172880: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x172884: 0xc7b50028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[21] = *(float*)&val; }
    // 0x172888: 0xc7b40020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[20] = *(float*)&val; }
    // 0x17288c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x172894: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x172898; return;
}


// Function: FUN_00172898
// Address: 0x172898 - 0x1728c8

void FUN_00172898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172898: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x17289c: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x1728a0: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1728a4: 0x7fb50050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 21));
    // 0x1728a8: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x1728ac: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x1728b0: 0x2625151c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 5404));
    // 0x1728b4: 0x7fb40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 20));
    // 0x1728b8: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1728bc: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x1728c0: 0xc06f136
    SET_GPR_U32(ctx, 31, 0x1728c8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    FUN_001bc4d8(rdram, ctx, runtime); return;
}


// Function: entry_1728c8
// Address: 0x1728c8 - 0x17292c

void entry_1728c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1728c8) {
        switch (ctx->pc) {
            case 0x1728e0: ctx->pc = 0; goto label_1728e0;
            case 0x1728f0: ctx->pc = 0; goto label_1728f0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1728c8: 0x8e220480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1152)));
    // 0x1728cc: 0x8c520000
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1728d0: 0x1240003a
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1729BC; return;
    }
    // 0x1728d8: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1728dc: 0x0
    // NOP
label_1728e0:
    // 0x1728e0: 0x12000030
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1729A4; return;
    }
    // 0x1728e8: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1728ec: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_1728f0:
    // 0x1728f0: 0x8e2423b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9136)));
    // 0x1728f4: 0x711826
    SET_GPR_U32(ctx, 3, XOR32(GPR_U32(ctx, 3), GPR_U32(ctx, 17)));
    // 0x1728f8: 0x3302b
    SET_GPR_U32(ctx, 6, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 3)));
    // 0x1728fc: 0x61180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 6), 6));
    // 0x172900: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x172904: 0x8c430004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x172908: 0x1464000f
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 6)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        ctx->pc = 0x172948; return;
    }
    // 0x172910: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x172914: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x172918: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17291c: 0x50800006
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 208)));
        ctx->pc = 0x172938; return;
    }
    // 0x172924: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17292c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 70));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17292c
// Address: 0x17292c - 0x172974

void entry_17292c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17292c) {
        switch (ctx->pc) {
            case 0x172938: ctx->pc = 0; goto label_172938;
            case 0x172948: ctx->pc = 0; goto label_172948;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17292c: 0x5440001a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 208));
        ctx->pc = 0x172998; return;
    }
    // 0x172934: 0x8e0200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 208)));
label_172938:
    // 0x172938: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x17293c: 0xae1500d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 208), GPR_U32(ctx, 21));
    // 0x172940: 0x10000015
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x172998; return;
    }
label_172948:
    // 0x172948: 0x8e242750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 10064)));
    // 0x17294c: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x172950: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x172954: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x172958: 0x5464000f
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 208));
        ctx->pc = 0x172998; return;
    }
    // 0x172960: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x172964: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x172968: 0x8c620168
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 360)));
    // 0x17296c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x172974);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_172974
// Address: 0x172974 - 0x1729c4

void entry_172974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172974) {
        switch (ctx->pc) {
            case 0x172998: ctx->pc = 0; goto label_172998;
            case 0x1729a4: ctx->pc = 0; goto label_1729a4;
            case 0x1729bc: ctx->pc = 0; goto label_1729bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172974: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 208));
        goto label_172998;
    }
    // 0x17297c: 0x8e0200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x172980: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x172984: 0x8e232750
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 10064)));
    // 0x172988: 0x8c620554
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1364)));
    // 0x17298c: 0xae0200d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 208), GPR_U32(ctx, 2));
    // 0x172990: 0x8e232750
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 10064)));
    // 0x172994: 0xac700554
    WRITE32(ADD32(GPR_U32(ctx, 3), 1364), GPR_U32(ctx, 16));
label_172998:
    // 0x172998: 0x8e700000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x17299c: 0x5600ffd4
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1728F0; return;
    }
label_1729a4:
    // 0x1729a4: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x1729a8: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1729ac: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x1729b0: 0x8e520004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x1729b4: 0x5640ffca
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x1728E0; return;
    }
label_1729bc:
    // 0x1729bc: 0xc0715f2
    SET_GPR_U32(ctx, 31, 0x1729c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    AdjustStepXps__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1729c4
// Address: 0x1729c4 - 0x1729fc

void entry_1729c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1729c4: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x1729c8: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1729cc: 0x54620038
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        ctx->pc = 0x172AB0; return;
    }
    // 0x1729d4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1729d8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1729dc: 0xae220690
    WRITE32(ADD32(GPR_U32(ctx, 17), 1680), GPR_U32(ctx, 2));
    // 0x1729e0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1729e4: 0x8e2424a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9376)));
    // 0x1729e8: 0x262624b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 9392));
    // 0x1729ec: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1729f0: 0x262706a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 1696));
    // 0x1729f4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1729fc);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1684), *(uint32_t*)&val); }
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1729fc
// Address: 0x1729fc - 0x172ab8

void entry_1729fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1729fc) {
        switch (ctx->pc) {
            case 0x172a28: ctx->pc = 0; goto label_172a28;
            case 0x172a40: ctx->pc = 0; goto label_172a40;
            case 0x172a84: ctx->pc = 0; goto label_172a84;
            case 0x172a88: ctx->pc = 0; goto label_172a88;
            case 0x172a94: ctx->pc = 0; goto label_172a94;
            case 0x172ab0: ctx->pc = 0; goto label_172ab0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1729fc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x172a00: 0x8e2424a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9376)));
    // 0x172a04: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x172a08: 0x8e250480
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1152)));
    // 0x172a0c: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x172a10: 0xae2406c0
    WRITE32(ADD32(GPR_U32(ctx, 17), 1728), GPR_U32(ctx, 4));
    // 0x172a14: 0x7e2306b0
    WRITE128(ADD32(GPR_U32(ctx, 17), 1712), GPR_VEC(ctx, 3));
    // 0x172a18: 0x8cb20000
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x172a1c: 0x52400024
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
        goto label_172ab0;
    }
    // 0x172a24: 0x8e500000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_172a28:
    // 0x172a28: 0x1200001a
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_172a94;
    }
    // 0x172a30: 0x2407000b
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 11));
    // 0x172a34: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x172a38: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x172a3c: 0x0
    // NOP
label_172a40:
    // 0x172a40: 0x8e03009c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 156)));
    // 0x172a44: 0x2221026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 17), GPR_U32(ctx, 2)));
    // 0x172a48: 0x1067000e
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 7)) {
        goto label_172a84;
    }
    // 0x172a50: 0xc21023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x172a54: 0x8e2524a0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 9376)));
    // 0x172a58: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x172a5c: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x172a60: 0x8ca40050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 80)));
    // 0x172a64: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x172a68: 0x54640007
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 208));
        goto label_172a88;
    }
    // 0x172a70: 0x8e0200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 208)));
    // 0x172a74: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
    // 0x172a78: 0xae1500d0
    WRITE32(ADD32(GPR_U32(ctx, 16), 208), GPR_U32(ctx, 21));
    // 0x172a7c: 0x10000002
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_172a88;
    }
label_172a84:
    // 0x172a84: 0x261300d0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 208));
label_172a88:
    // 0x172a88: 0x8e700000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    // 0x172a8c: 0x5600ffec
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_172a40;
    }
label_172a94:
    // 0x172a94: 0x8e430008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8)));
    // 0x172a98: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x172a9c: 0xac620000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 2));
    // 0x172aa0: 0x8e520004
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    // 0x172aa4: 0x5640ffe0
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_172a28;
    }
    // 0x172aac: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
label_172ab0:
    // 0x172ab0: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x172ab8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_172ab8
// Address: 0x172ab8 - 0x172ae0

void entry_172ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172ab8: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x172abc: 0x7bb50050
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x172ac0: 0x7bb40040
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x172ac4: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x172ac8: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x172acc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x172ad0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x172ad4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x172adc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x172ae0; return;
}


// Function: UpdateJtPosWorldPrev__FP2JT
// Address: 0x172ae0 - 0x172af4

void entry_172af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172af4: 0xae0021cc
    WRITE32(ADD32(GPR_U32(ctx, 16), 8652), GPR_U32(ctx, 0));
    // 0x172af8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x172afc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x172b00: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00172b08
// Address: 0x172b08 - 0x172b38

void FUN_00172b08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172b08: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x172b0c: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x172b10: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x172b14: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x172b18: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x172b1c: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x172b20: 0x8e0323d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9172)));
    // 0x172b24: 0x78620140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x172b28: 0xae0021cc
    WRITE32(ADD32(GPR_U32(ctx, 16), 8652), GPR_U32(ctx, 0));
    // 0x172b2c: 0x7e0221e0
    WRITE128(ADD32(GPR_U32(ctx, 16), 8672), GPR_VEC(ctx, 2));
    // 0x172b30: 0xc06f022
    SET_GPR_U32(ctx, 31, 0x172b38);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 6240)); ctx->f[12] = *(float*)&val; }
    ProjectSoTransform__FP2SOfi(rdram, ctx, runtime); return;
}


// Function: entry_172b38
// Address: 0x172b38 - 0x172b70

void entry_172b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172b38: 0x8e02223c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8764)));
    // 0x172b3c: 0x5440000e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 8652), GPR_U32(ctx, 0));
        ctx->pc = 0x172B78; return;
    }
    // 0x172b44: 0x7a020140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x172b48: 0x24060003
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    // 0x172b4c: 0x8e0323d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9172)));
    // 0x172b50: 0x7e0221d0
    WRITE128(ADD32(GPR_U32(ctx, 16), 8656), GPR_VEC(ctx, 2));
    // 0x172b54: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x172b58: 0x78620140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x172b5c: 0xae0621cc
    WRITE32(ADD32(GPR_U32(ctx, 16), 8652), GPR_U32(ctx, 6));
    // 0x172b60: 0x7e0221f0
    WRITE128(ADD32(GPR_U32(ctx, 16), 8688), GPR_VEC(ctx, 2));
    // 0x172b64: 0x8ca300d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 216)));
    // 0x172b68: 0x60f809
    SET_GPR_U32(ctx, 31, 0x172b70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_172b70
// Address: 0x172b70 - 0x172b88

void entry_172b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172b70) {
        switch (ctx->pc) {
            case 0x172b78: ctx->pc = 0; goto label_172b78;
            case 0x172b7c: ctx->pc = 0; goto label_172b7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172b70: 0x10000002
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_172b7c;
    }
label_172b78:
    // 0x172b78: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_172b7c:
    // 0x172b7c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x172b80: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtBounds__FP2JT
// Address: 0x172b88 - 0x172ba8

void entry_172ba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172ba8) {
        switch (ctx->pc) {
            case 0x172bb8: ctx->pc = 0; goto label_172bb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172ba8: 0x8e0221cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8652)));
    // 0x172bac: 0x1840000b
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 8656));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x172BDC; return;
    }
    // 0x172bb4: 0x0
    // NOP
label_172bb8:
    // 0x172bb8: 0xc60c2420
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9248)); ctx->f[12] = *(float*)&val; }
    // 0x172bbc: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x172bc0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x172bc4: 0xc06e108
    SET_GPR_U32(ctx, 31, 0x172bcc);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    ExtendSoBounds__FP2SOP6VECTORf(rdram, ctx, runtime); return;
}


// Function: entry_172bcc
// Address: 0x172bcc - 0x172bf8

void entry_172bcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172bcc) {
        switch (ctx->pc) {
            case 0x172bdc: ctx->pc = 0; goto label_172bdc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172bcc: 0x8e0221cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8652)));
    // 0x172bd0: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x172bd4: 0x1440fff8
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x172BB8; return;
    }
label_172bdc:
    // 0x172bdc: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x172be0: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x172be4: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x172be8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x172bec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x172bf4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x172bf8; return;
}


// Function: PsoGetJtEffect__FP2JTPi
// Address: 0x172bf8 - 0x172c20

void entry_172c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172c20) {
        switch (ctx->pc) {
            case 0x172c34: ctx->pc = 0; goto label_172c34;
            case 0x172c38: ctx->pc = 0; goto label_172c38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172c20: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9696)));
        goto label_172c38;
    }
    // 0x172c28: 0xae200000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 0));
    // 0x172c2c: 0x1000002a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9688)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x172CD8; return;
    }
label_172c34:
    // 0x172c34: 0x8e0425e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9696)));
label_172c38:
    // 0x172c38: 0x50800009
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9692)));
        ctx->pc = 0x172C60; return;
    }
    // 0x172c40: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x172c48);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_172c48
// Address: 0x172c48 - 0x172c70

void entry_172c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172c48) {
        switch (ctx->pc) {
            case 0x172c5c: ctx->pc = 0; goto label_172c5c;
            case 0x172c60: ctx->pc = 0; goto label_172c60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172c48: 0x10400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_172c5c;
    }
    // 0x172c50: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x172c54: 0x10000020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9696)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x172CD8; return;
    }
label_172c5c:
    // 0x172c5c: 0x8e0425dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9692)));
label_172c60:
    // 0x172c60: 0x50800009
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9700)));
        ctx->pc = 0x172C88; return;
    }
    // 0x172c68: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x172c70);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_172c70
// Address: 0x172c70 - 0x172c98

void entry_172c70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172c70) {
        switch (ctx->pc) {
            case 0x172c84: ctx->pc = 0; goto label_172c84;
            case 0x172c88: ctx->pc = 0; goto label_172c88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172c70: 0x10400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_172c84;
    }
    // 0x172c78: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x172c7c: 0x10000016
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9692)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x172CD8; return;
    }
label_172c84:
    // 0x172c84: 0x8e0425e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9700)));
label_172c88:
    // 0x172c88: 0x50800009
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9704)));
        ctx->pc = 0x172CB0; return;
    }
    // 0x172c90: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x172c98);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_172c98
// Address: 0x172c98 - 0x172cc0

void entry_172c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172c98) {
        switch (ctx->pc) {
            case 0x172cac: ctx->pc = 0; goto label_172cac;
            case 0x172cb0: ctx->pc = 0; goto label_172cb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172c98: 0x10400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_172cac;
    }
    // 0x172ca0: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x172ca4: 0x1000000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9700)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x172CD8; return;
    }
label_172cac:
    // 0x172cac: 0x8e0425e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9704)));
label_172cb0:
    // 0x172cb0: 0x10800009
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x172CD8; return;
    }
    // 0x172cb8: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x172cc0);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_172cc0
// Address: 0x172cc0 - 0x172cf0

void entry_172cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172cc0) {
        switch (ctx->pc) {
            case 0x172cd4: ctx->pc = 0; goto label_172cd4;
            case 0x172cd8: ctx->pc = 0; goto label_172cd8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172cc0: 0x10400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_172cd4;
    }
    // 0x172cc8: 0xae220000
    WRITE32(ADD32(GPR_U32(ctx, 17), 0), GPR_U32(ctx, 2));
    // 0x172ccc: 0x10000002
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9704)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_172cd8;
    }
label_172cd4:
    // 0x172cd4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_172cd8:
    // 0x172cd8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x172cdc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x172ce0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x172ce4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x172cec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x172cf0; return;
}


// Function: AddJtCustomXps__FP2JTP2SOiP3BSPT3PP2XP
// Address: 0x172cf0 - 0x172db0

void entry_172db0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172db0) {
        switch (ctx->pc) {
            case 0x172db8: ctx->pc = 0; goto label_172db8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172db0: 0x10000010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x172DF4; return;
    }
label_172db8:
    // 0x172db8: 0x8cc703f0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 6), 1008)));
    // 0x172dbc: 0xc48c03cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 972)); ctx->f[12] = *(float*)&val; }
    // 0x172dc0: 0x260a2670
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 16), 9840));
    // 0x172dc4: 0x8cc803f8
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 6), 1016)));
    // 0x172dc8: 0x24850140
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 320));
    // 0x172dcc: 0xc061e70
    SET_GPR_U32(ctx, 31, 0x172dd4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    MarkSoContactsSphereBsp__FP2SOP6VECTORfT0iP3BSPT5PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_172dd4
// Address: 0x172dd4 - 0x172df0

void entry_172dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172dd4) {
        switch (ctx->pc) {
            case 0x172ddc: ctx->pc = 0; goto label_172ddc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172dd4: 0x10000031
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x172E9C; return;
    }
label_172ddc:
    // 0x172ddc: 0x14400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x172DF4; return;
    }
    // 0x172de4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x172de8: 0xc071704
    SET_GPR_U32(ctx, 31, 0x172df0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    AddStepCustomXpsBase__FP4STEPP2SOP3BSPPP2XP(rdram, ctx, runtime); return;
}


// Function: entry_172df0
// Address: 0x172df0 - 0x172e04

void entry_172df0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172df0) {
        switch (ctx->pc) {
            case 0x172df4: ctx->pc = 0; goto label_172df4;
            case 0x172df8: ctx->pc = 0; goto label_172df8;
            case 0x172dfc: ctx->pc = 0; goto label_172dfc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172df0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_172df4:
    // 0x172df4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_172df8:
    // 0x172df8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_172dfc:
    // 0x172dfc: 0xc0711e4
    SET_GPR_U32(ctx, 31, 0x172e04);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 4496));
    FUN_001c4790(rdram, ctx, runtime); return;
}


// Function: entry_172e04
// Address: 0x172e04 - 0x172e18

void entry_172e04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172e04: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x172e08: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x172e0c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x172e10: 0xc0711e4
    SET_GPR_U32(ctx, 31, 0x172e18);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 4752));
    FUN_001c4790(rdram, ctx, runtime); return;
}


// Function: entry_172e18
// Address: 0x172e18 - 0x172e24

void entry_172e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172e18: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x172e1c: 0xc05cafe
    SET_GPR_U32(ctx, 31, 0x172e24);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PsoGetJtEffect__FP2JTPi(rdram, ctx, runtime); return;
}


// Function: entry_172e24
// Address: 0x172e24 - 0x172e88

void entry_172e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172e24) {
        switch (ctx->pc) {
            case 0x172e48: ctx->pc = 0; goto label_172e48;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172e24: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x172e28: 0x10c0001c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x172E9C; return;
    }
    // 0x172e30: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x172e34: 0x5080001a
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
        ctx->pc = 0x172EA0; return;
    }
    // 0x172e3c: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x172e40: 0x52e78
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 25);
    // 0x172e44: 0x8fa20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
label_172e48:
    // 0x172e48: 0x821021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 2)));
    // 0x172e4c: 0x904302b0
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 688)));
    // 0x172e50: 0x5060000f
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 24)));
        ctx->pc = 0x172E90; return;
    }
    // 0x172e58: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x172e5c: 0x451024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x172e60: 0x5440ffd5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x172DB8; return;
    }
    // 0x172e68: 0x1260000b
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x172E98; return;
    }
    // 0x172e70: 0xc0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x172e74: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x172e78: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x172e7c: 0x240402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x172e80: 0xc061aea
    SET_GPR_U32(ctx, 31, 0x172e88);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 16), 9840));
    MarkSoContactsBspBsp__FP2SOT0iP3BSPT3PP2XP(rdram, ctx, runtime); return;
}


// Function: entry_172e88
// Address: 0x172e88 - 0x172eb8

void entry_172e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172e88) {
        switch (ctx->pc) {
            case 0x172e90: ctx->pc = 0; goto label_172e90;
            case 0x172e98: ctx->pc = 0; goto label_172e98;
            case 0x172e9c: ctx->pc = 0; goto label_172e9c;
            case 0x172ea0: ctx->pc = 0; goto label_172ea0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172e88: 0x10000004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_172e9c;
    }
label_172e90:
    // 0x172e90: 0x1480ffed
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x172E48; return;
    }
label_172e98:
    // 0x172e98: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_172e9c:
    // 0x172e9c: 0x7bb40050
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_172ea0:
    // 0x172ea0: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x172ea4: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x172ea8: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x172eac: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x172eb0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: CtTorqueJt__FP2JT
// Address: 0x172eb8 - 0x172ee0

void FUN_00172ee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172ee0: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x172ee4: 0x7fb30070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 19));
    // 0x172ee8: 0x7fb00040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 16));
    // 0x172eec: 0xa0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x172ef0: 0xe7b40090
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 144), *(uint32_t*)&val); }
    // 0x172ef4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x172ef8: 0x7fbf0080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 31));
    // 0x172efc: 0x46006506
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    // 0x172f00: 0x7fb20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 18));
    // 0x172f04: 0x7fb10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 17));
    // 0x172f08: 0x7a020560
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 1376)));
    // 0x172f0c: 0xc0648e0
    SET_GPR_U32(ctx, 31, 0x172f14);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    GetPoCpdefi__FP2POfP6CPDEFI(rdram, ctx, runtime); return;
}


// Function: entry_172f14
// Address: 0x172f14 - 0x172f58

void entry_172f14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172f14: 0x8e020554
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1364)));
    // 0x172f18: 0x144000aa
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1731C4; return;
    }
    // 0x172f20: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x172f24: 0x1462003f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x173024; return;
    }
    // 0x172f2c: 0x8e032208
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8712)));
    // 0x172f30: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x172f34: 0x8c640034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x172f38: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x172f3c: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x172f40: 0x10400005
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_172f58(rdram, ctx, runtime); return;
    }
    // 0x172f48: 0xc60c2410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9232)); ctx->f[12] = *(float*)&val; }
    // 0x172f4c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x172f50: 0x40f809
    SET_GPR_U32(ctx, 31, 0x172f58);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_172f58
// Address: 0x172f58 - 0x172f70

void entry_172f58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172f58: 0x8e022208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8712)));
    // 0x172f5c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x172f60: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x172f64: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x172f68: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x172f70);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_172f70
// Address: 0x172f70 - 0x172f90

void entry_172f70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x172f70: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x172f74: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x172f78: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x172f7c: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x172f80: 0x7e630010
    WRITE128(ADD32(GPR_U32(ctx, 19), 16), GPR_VEC(ctx, 3));
    // 0x172f84: 0x8e022208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8712)));
    // 0x172f88: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x172f90);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_172f90
// Address: 0x172f90 - 0x173038

void entry_172f90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x172f90) {
        switch (ctx->pc) {
            case 0x172fe8: ctx->pc = 0; goto label_172fe8;
            case 0x172ff4: ctx->pc = 0; goto label_172ff4;
            case 0x173024: ctx->pc = 0; goto label_173024;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x172f90: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x172f94: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x172f98: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x172f9c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x172fa0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x172fa4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x172fa8: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x172fac: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x172fb0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x172fb4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x172fb8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x172fbc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x172fc0: 0x24628d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x172fc4: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x172fc8: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x172fcc: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x172fd0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x172fd4: 0x0
    // NOP
    // 0x172fd8: 0x45000003
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_172fe8;
    }
    // 0x172fe0: 0x10000004
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_172ff4;
    }
label_172fe8:
    // 0x172fe8: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x172fec: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x172ff0: 0x4be018dc
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_172ff4:
    // 0x172ff4: 0xc6600018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 24)); ctx->f[0] = *(float*)&val; }
    // 0x172ff8: 0x8e022414
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9236)));
    // 0x172ffc: 0x3c0142fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17146 << 16));
    // 0x173000: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x173004: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x173008: 0x4be21858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17300c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x173010: 0xfa610020
    WRITE128(ADD32(GPR_U32(ctx, 19), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x173014: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x173018: 0xfba20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17301c: 0x10000051
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1616), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173164; return;
    }
label_173024:
    // 0x173024: 0x5462000a
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1680)));
        ctx->pc = 0x173050; return;
    }
    // 0x17302c: 0x8e042204
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 8708)));
    // 0x173030: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x173038);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_173038
// Address: 0x173038 - 0x173110

void entry_173038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173038) {
        switch (ctx->pc) {
            case 0x173050: ctx->pc = 0; goto label_173050;
            case 0x173060: ctx->pc = 0; goto label_173060;
            case 0x173084: ctx->pc = 0; goto label_173084;
            case 0x173088: ctx->pc = 0; goto label_173088;
            case 0x1730bc: ctx->pc = 0; goto label_1730bc;
            case 0x1730d0: ctx->pc = 0; goto label_1730d0;
            case 0x1730f4: ctx->pc = 0; goto label_1730f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173038: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17303c: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x173040: 0xc44138c8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14536)); ctx->f[1] = *(float*)&val; }
    // 0x173044: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x173048: 0x1000000e
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173084;
    }
label_173050:
    // 0x173050: 0x10400003
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_173060;
    }
    // 0x173058: 0x1000000a
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1704)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173084;
    }
label_173060:
    // 0x173060: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x173064: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x173068: 0x8c830224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 548)));
    // 0x17306c: 0x10600006
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_173088;
    }
    // 0x173074: 0xc6000148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 328)); ctx->f[0] = *(float*)&val; }
    // 0x173078: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x17307c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x173080: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
label_173084:
    // 0x173084: 0xe6000650
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1616), *(uint32_t*)&val); }
label_173088:
    // 0x173088: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17308c: 0xc6020108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 264)); ctx->f[2] = *(float*)&val; }
    // 0x173090: 0xc44138c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14532)); ctx->f[1] = *(float*)&val; }
    // 0x173094: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x173098: 0xc6030650
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1616)); ctx->f[3] = *(float*)&val; }
    // 0x17309c: 0x46011040
    ctx->f[1] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x1730a0: 0xc46038c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 14528)); ctx->f[0] = *(float*)&val; }
    // 0x1730a4: 0x46011834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1730a8: 0x0
    // NOP
    // 0x1730ac: 0x45000003
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1730bc;
    }
    // 0x1730b4: 0x10000006
    ctx->f[2] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1730d0;
    }
label_1730bc:
    // 0x1730bc: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1730c0: 0x0
    // NOP
    // 0x1730c4: 0x45000002
    ctx->f[2] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1730d0;
    }
    // 0x1730cc: 0x46000086
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
label_1730d0:
    // 0x1730d0: 0x8ca21990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 6544)));
    // 0x1730d4: 0xe6020650
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 16), 1616), *(uint32_t*)&val); }
    // 0x1730d8: 0x3c0142fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17146 << 16));
    // 0x1730dc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1730e0: 0x8c430224
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 548)));
    // 0x1730e4: 0x10600003
    ctx->f[13] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_1730f4;
    }
    // 0x1730ec: 0x1000001c
    { float val = ctx->f[13]; WRITE32(ADD32(GPR_U32(ctx, 19), 24), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173160; return;
    }
label_1730f4:
    // 0x1730f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1730f8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1730fc: 0xc44e1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[14] = *(float*)&val; }
    // 0x173100: 0x248438f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 14576));
    // 0x173104: 0xc7ac0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[12] = *(float*)&val; }
    // 0x173108: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x173110);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_173110
// Address: 0x173110 - 0x17318c

void entry_173110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173110) {
        switch (ctx->pc) {
            case 0x173148: ctx->pc = 0; goto label_173148;
            case 0x17315c: ctx->pc = 0; goto label_17315c;
            case 0x173160: ctx->pc = 0; goto label_173160;
            case 0x173164: ctx->pc = 0; goto label_173164;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173110: 0x460000c6
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
    // 0x173114: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x173118: 0xe6630018
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 19), 24), *(uint32_t*)&val); }
    // 0x17311c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x173120: 0xc44238bc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14524)); ctx->f[2] = *(float*)&val; }
    // 0x173124: 0xc6000108
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 264)); ctx->f[0] = *(float*)&val; }
    // 0x173128: 0xc46138b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 14520)); ctx->f[1] = *(float*)&val; }
    // 0x17312c: 0x46020080
    ctx->f[2] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x173130: 0x46021834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x173134: 0x0
    // NOP
    // 0x173138: 0x45000003
    ctx->f[1] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_173148;
    }
    // 0x173140: 0x10000006
    ctx->f[0] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17315c;
    }
label_173148:
    // 0x173148: 0x46030834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17314c: 0x0
    // NOP
    // 0x173150: 0x45000002
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17315c;
    }
    // 0x173158: 0x46000806
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
label_17315c:
    // 0x17315c: 0xe6600018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 24), *(uint32_t*)&val); }
label_173160:
    // 0x173160: 0x3c110025
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
label_173164:
    // 0x173164: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x173168: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x17316c: 0x14620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294937904));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x173190; return;
    }
    // 0x173174: 0x8e02239c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9116)));
    // 0x173178: 0x14400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294937904));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x173190; return;
    }
    // 0x173180: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x173184: 0xc05ccee
    SET_GPR_U32(ctx, 31, 0x17318c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    GetJtCpdefiFlatten__FP2JTP6CPDEFI(rdram, ctx, runtime); return;
}


// Function: entry_17318c
// Address: 0x17318c - 0x1731ac

void entry_17318c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17318c) {
        switch (ctx->pc) {
            case 0x173190: ctx->pc = 0; goto label_173190;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17318c: 0x26228d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294937904));
label_173190:
    // 0x173190: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x173194: 0x78450000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x173198: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x17319c: 0x7a042530
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 16), 9520)));
    // 0x1731a0: 0x24c638e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 14560));
    // 0x1731a4: 0xc07aa06
    SET_GPR_U32(ctx, 31, 0x1731ac);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PosSmooth(rdram, ctx, runtime); return;
}


// Function: entry_1731ac
// Address: 0x1731ac - 0x1733b8

void entry_1731ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1731ac) {
        switch (ctx->pc) {
            case 0x1731c4: ctx->pc = 0; goto label_1731c4;
            case 0x1731e8: ctx->pc = 0; goto label_1731e8;
            case 0x1731fc: ctx->pc = 0; goto label_1731fc;
            case 0x173210: ctx->pc = 0; goto label_173210;
            case 0x173240: ctx->pc = 0; goto label_173240;
            case 0x173244: ctx->pc = 0; goto label_173244;
            case 0x17324c: ctx->pc = 0; goto label_17324c;
            case 0x173250: ctx->pc = 0; goto label_173250;
            case 0x173258: ctx->pc = 0; goto label_173258;
            case 0x17327c: ctx->pc = 0; goto label_17327c;
            case 0x17328c: ctx->pc = 0; goto label_17328c;
            case 0x173294: ctx->pc = 0; goto label_173294;
            case 0x173298: ctx->pc = 0; goto label_173298;
            case 0x17329c: ctx->pc = 0; goto label_17329c;
            case 0x1732ac: ctx->pc = 0; goto label_1732ac;
            case 0x1732dc: ctx->pc = 0; goto label_1732dc;
            case 0x1732f4: ctx->pc = 0; goto label_1732f4;
            case 0x173340: ctx->pc = 0; goto label_173340;
            case 0x173350: ctx->pc = 0; goto label_173350;
            case 0x173360: ctx->pc = 0; goto label_173360;
            case 0x17338c: ctx->pc = 0; goto label_17338c;
            case 0x173390: ctx->pc = 0; goto label_173390;
            case 0x173394: ctx->pc = 0; goto label_173394;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1731ac: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1731b0: 0xfa022530
    WRITE128(ADD32(GPR_U32(ctx, 16), 9520), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1731b4: 0xda610010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 16)));
    // 0x1731b8: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1731bc: 0xfa610010
    WRITE128(ADD32(GPR_U32(ctx, 19), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1731c0: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
label_1731c4:
    // 0x1731c4: 0x28620006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 6));
    // 0x1731c8: 0x10400007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1731e8;
    }
    // 0x1731d0: 0x1040001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_173240;
    }
    // 0x1731d8: 0x10620008
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1731fc;
    }
    // 0x1731e0: 0x1000001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173258;
    }
label_1731e8:
    // 0x1731e8: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1731ec: 0x50620008
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9116)));
        goto label_173210;
    }
    // 0x1731f4: 0x10000016
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173250;
    }
label_1731fc:
    // 0x1731fc: 0x8e022498
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9368)));
    // 0x173200: 0x50400013
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
        goto label_173250;
    }
    // 0x173208: 0x1000000e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173244;
    }
label_173210:
    // 0x173210: 0x2c620006
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 6));
    // 0x173214: 0x1040000a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_173240;
    }
    // 0x17321c: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x173220: 0x2442a9d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945232));
    // 0x173224: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x173228: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17322c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x173234: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x173238: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 19), 60), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17324c;
    }
label_173240:
    // 0x173240: 0x8e620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 0)));
label_173244:
    // 0x173244: 0x34420001
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 1));
    // 0x173248: 0xae620000
    WRITE32(ADD32(GPR_U32(ctx, 19), 0), GPR_U32(ctx, 2));
label_17324c:
    // 0x17324c: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
label_173250:
    // 0x173250: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x173254: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
label_173258:
    // 0x173258: 0x5062000c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8744)));
        goto label_17328c;
    }
    // 0x173260: 0x28620007
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 7));
    // 0x173264: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
        goto label_17327c;
    }
    // 0x17326c: 0x5060000b
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_17329c;
    }
    // 0x173274: 0x10000009
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17329c;
    }
label_17327c:
    // 0x17327c: 0x50620005
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8744)));
        goto label_173294;
    }
    // 0x173284: 0x10000005
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17329c;
    }
label_17328c:
    // 0x17328c: 0x10000002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173298;
    }
label_173294:
    // 0x173294: 0x38420018
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 24));
label_173298:
    // 0x173298: 0x2200a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 0));
label_17329c:
    // 0x17329c: 0x10800003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1732ac;
    }
    // 0x1732a4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1732a8: 0xe6002680
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 9856), *(uint32_t*)&val); }
label_1732ac:
    // 0x1732ac: 0xc6002680
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9856)); ctx->f[0] = *(float*)&val; }
    // 0x1732b0: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1732b4: 0xe6600038
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 56), *(uint32_t*)&val); }
    // 0x1732b8: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x1732bc: 0x10620028
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_173360;
    }
    // 0x1732c4: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1732dc;
    }
    // 0x1732cc: 0x50600009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 360)); ctx->f[2] = *(float*)&val; }
        goto label_1732f4;
    }
    // 0x1732d4: 0x1000002f
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173394;
    }
label_1732dc:
    // 0x1732dc: 0x1062002b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17338c;
    }
    // 0x1732e4: 0x5062002a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 19), 52), GPR_U32(ctx, 0));
        goto label_173390;
    }
    // 0x1732ec: 0x10000029
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173394;
    }
label_1732f4:
    // 0x1732f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1732f8: 0x244338d0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 14544));
    // 0x1732fc: 0xc44338d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14544)); ctx->f[3] = *(float*)&val; }
    // 0x173300: 0x46001085
    ctx->f[2] = FPU_ABS_S(ctx->f[2]);
    // 0x173304: 0xc4600008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[0] = *(float*)&val; }
    // 0x173308: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x17330c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x173310: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x173314: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x173318: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x17331c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x173320: 0x46011082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x173324: 0x460218c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x173328: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17332c: 0x0
    // NOP
    // 0x173330: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_173340;
    }
    // 0x173338: 0x10000005
    ctx->f[3] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173350;
    }
label_173340:
    // 0x173340: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x173344: 0x0
    // NOP
    // 0x173348: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[3] = FPU_MOV_S(ctx->f[5]);
        goto label_173350;
    }
label_173350:
    // 0x173350: 0xc6600034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 52)); ctx->f[0] = *(float*)&val; }
    // 0x173354: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x173358: 0x1000000d
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 52), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173390;
    }
label_173360:
    // 0x173360: 0x8e032228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8744)));
    // 0x173364: 0x24020029
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 41));
    // 0x173368: 0x10620008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 41));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17338c;
    }
    // 0x173370: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 16)));
        goto label_173394;
    }
    // 0x173378: 0x28620032
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 50));
    // 0x17337c: 0x10400004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 45));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_173390;
    }
    // 0x173384: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 16)));
        goto label_173394;
    }
label_17338c:
    // 0x17338c: 0xae600034
    WRITE32(ADD32(GPR_U32(ctx, 19), 52), GPR_U32(ctx, 0));
label_173390:
    // 0x173390: 0x7a620010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 19), 16)));
label_173394:
    // 0x173394: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x173398: 0x7e020560
    WRITE128(ADD32(GPR_U32(ctx, 16), 1376), GPR_VEC(ctx, 2));
    // 0x17339c: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x1733a0: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x1733a4: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x1733a8: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1733ac: 0xc7b40090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[20] = *(float*)&val; }
    // 0x1733b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetJtCpdefiFlatten__FP2JTP6CPDEFI
// Address: 0x1733b8 - 0x1733e0

void entry_1733e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1733e0) {
        switch (ctx->pc) {
            case 0x173420: ctx->pc = 0; goto label_173420;
            case 0x173480: ctx->pc = 0; goto label_173480;
            case 0x173488: ctx->pc = 0; goto label_173488;
            case 0x1734cc: ctx->pc = 0; goto label_1734cc;
            case 0x1734d0: ctx->pc = 0; goto label_1734d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1733e0: 0xe6200030
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 48), *(uint32_t*)&val); }
    // 0x1733e4: 0x8e032674
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9844)));
    // 0x1733e8: 0x8e022678
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9848)));
    // 0x1733ec: 0x146200c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1736F0; return;
    }
    // 0x1733f4: 0xae200034
    WRITE32(ADD32(GPR_U32(ctx, 17), 52), GPR_U32(ctx, 0));
    // 0x1733f8: 0x8e032684
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9860)));
    // 0x1733fc: 0x28620003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    // 0x173400: 0x5040006b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9120)));
        ctx->pc = 0x1735B0; return;
    }
    // 0x173408: 0x5c600005
    if (GPR_S32(ctx, 3) > 0) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 9120)));
        goto label_173420;
    }
    // 0x173410: 0x50600060
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 320)));
        ctx->pc = 0x173594; return;
    }
    // 0x173418: 0x10000065
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9120)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1735B0; return;
    }
label_173420:
    // 0x173420: 0x10a0003d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173518; return;
    }
    // 0x173428: 0x14620017
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9888)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_173488;
    }
    // 0x173430: 0x3c0142fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17146 << 16));
    // 0x173434: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x173438: 0x8ca30034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 52)));
    // 0x17343c: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x173440: 0xc60223a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9124)); ctx->f[2] = *(float*)&val; }
    // 0x173444: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x173448: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x17344c: 0x14400020
    ctx->f[12] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1734d0;
    }
    // 0x173454: 0x8c62000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 12)));
    // 0x173458: 0x8c640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x17345c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x173460: 0x8ca30050
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 80)));
    // 0x173464: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x173468: 0x30630002
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 2));
    // 0x17346c: 0x10600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_173480;
    }
    // 0x173474: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x173478: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17347c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
label_173480:
    // 0x173480: 0x10000013
    ctx->f[12] = std::min(ctx->f[1], ctx->f[12]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1734d0;
    }
label_173488:
    // 0x173488: 0x3c0142fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17146 << 16));
    // 0x17348c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x173490: 0x8ca30034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 52)));
    // 0x173494: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x173498: 0xc60223a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9124)); ctx->f[2] = *(float*)&val; }
    // 0x17349c: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1734a0: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1734a4: 0x1440000a
    ctx->f[12] = FPU_SUB_S(ctx->f[2], ctx->f[1]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1734d0;
    }
    // 0x1734ac: 0x8c630014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 20)));
    // 0x1734b0: 0x8ca20050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 80)));
    // 0x1734b4: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1734b8: 0x10400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 0)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1734cc;
    }
    // 0x1734c0: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x1734c4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1734c8: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
label_1734cc:
    // 0x1734cc: 0x460c0b28
    ctx->f[12] = std::max(ctx->f[1], ctx->f[12]);
label_1734d0:
    // 0x1734d0: 0x8e0223a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9120)));
    // 0x1734d4: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x1734d8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1734dc: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1734e0: 0x10400003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1734f0(rdram, ctx, runtime); return;
    }
    // 0x1734e8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1734f0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1734f0
// Address: 0x1734f0 - 0x173508

void entry_1734f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1734f0: 0x8e0223a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9120)));
    // 0x1734f4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1734f8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1734fc: 0x26072690
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 9872));
    // 0x173500: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x173508);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_173508
// Address: 0x173508 - 0x1735e0

void entry_173508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173508) {
        switch (ctx->pc) {
            case 0x173518: ctx->pc = 0; goto label_173518;
            case 0x173554: ctx->pc = 0; goto label_173554;
            case 0x173584: ctx->pc = 0; goto label_173584;
            case 0x173594: ctx->pc = 0; goto label_173594;
            case 0x1735a4: ctx->pc = 0; goto label_1735a4;
            case 0x1735b0: ctx->pc = 0; goto label_1735b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173508: 0x3c0142fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17146 << 16));
    // 0x17350c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x173510: 0x10000024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9880)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1735a4;
    }
label_173518:
    // 0x173518: 0x1462000e
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9888)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_173554;
    }
    // 0x173520: 0x3c0142fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17146 << 16));
    // 0x173524: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x173528: 0xda030120
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x17352c: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x173530: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x173534: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x173538: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x17353c: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x173540: 0x4be118d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x173544: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x173548: 0x4be310a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17354c: 0x1000000d
    WRITE128(ADD32(GPR_U32(ctx, 16), 9872), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173584;
    }
label_173554:
    // 0x173554: 0x3c0142fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17146 << 16));
    // 0x173558: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17355c: 0xda030120
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 288)));
    // 0x173560: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x173564: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x173568: 0x46000842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x17356c: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x173570: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x173574: 0x4be118d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x173578: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17357c: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x173580: 0xfa022690
    WRITE128(ADD32(GPR_U32(ctx, 16), 9872), _mm_castps_si128(ctx->vu0_vf[2]));
label_173584:
    // 0x173584: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x173588: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17358c: 0x10000005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9880)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1735a4;
    }
label_173594:
    // 0x173594: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x173598: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17359c: 0x7e022690
    WRITE128(ADD32(GPR_U32(ctx, 16), 9872), GPR_VEC(ctx, 2));
    // 0x1735a0: 0xc6002698
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9880)); ctx->f[0] = *(float*)&val; }
label_1735a4:
    // 0x1735a4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1735a8: 0xe6002698
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 9880), *(uint32_t*)&val); }
    // 0x1735ac: 0x8e0323a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9120)));
label_1735b0:
    // 0x1735b0: 0x1060004f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1736F0; return;
    }
    // 0x1735b8: 0x8c640034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x1735bc: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x1735c0: 0x1440004c
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1736F4; return;
    }
    // 0x1735c8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1735cc: 0x3c0141f0
    SET_GPR_U32(ctx, 1, ((uint32_t)16880 << 16));
    // 0x1735d0: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1735d4: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x1735d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1735e0);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1735e0
// Address: 0x1735e0 - 0x1736e4

void entry_1735e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1735e0) {
        switch (ctx->pc) {
            case 0x173650: ctx->pc = 0; goto label_173650;
            case 0x173668: ctx->pc = 0; goto label_173668;
            case 0x1736ac: ctx->pc = 0; goto label_1736ac;
            case 0x1736c0: ctx->pc = 0; goto label_1736c0;
            case 0x1736c4: ctx->pc = 0; goto label_1736c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1735e0: 0x46140001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1735e4: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1735e8: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1735ec: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1735f0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1735f4: 0xc60423a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9124)); ctx->f[4] = *(float*)&val; }
    // 0x1735f8: 0x46140041
    ctx->f[1] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x1735fc: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x173600: 0x460208a9
    ctx->f[2] = std::min(ctx->f[1], ctx->f[2]);
    // 0x173604: 0x46141040
    ctx->f[1] = FPU_ADD_S(ctx->f[2], ctx->f[20]);
    // 0x173608: 0x46012034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17360c: 0x0
    // NOP
    // 0x173610: 0x45000015
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_173668;
    }
    // 0x173618: 0x46040801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[4]);
    // 0x17361c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x173620: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x173624: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x173628: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x17362c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x173630: 0x0
    // NOP
    // 0x173634: 0x45010006
    ctx->f[2] = FPU_MOV_S(ctx->f[1]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_173650;
    }
    // 0x17363c: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x173640: 0x0
    // NOP
    // 0x173644: 0x45000002
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_173650;
    }
    // 0x17364c: 0x46001886
    ctx->f[2] = FPU_MOV_S(ctx->f[3]);
label_173650:
    // 0x173650: 0x46001007
    ctx->f[0] = FPU_NEG_S(ctx->f[2]);
    // 0x173654: 0x3c014316
    SET_GPR_U32(ctx, 1, ((uint32_t)17174 << 16));
    // 0x173658: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17365c: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x173660: 0x10000018
    ctx->f[13] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1736c4;
    }
label_173668:
    // 0x173668: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17366c: 0x45000014
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1736c0;
    }
    // 0x173674: 0x46002001
    ctx->f[0] = FPU_SUB_S(ctx->f[4], ctx->f[0]);
    // 0x173678: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17367c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x173680: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x173684: 0x46020003
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[0] = ctx->f[0] / ctx->f[2];
    // 0x173688: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17368c: 0x0
    // NOP
    // 0x173690: 0x45010006
    ctx->f[2] = FPU_MOV_S(ctx->f[1]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1736ac;
    }
    // 0x173698: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17369c: 0x0
    // NOP
    // 0x1736a0: 0x45000002
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1736ac;
    }
    // 0x1736a8: 0x46001886
    ctx->f[2] = FPU_MOV_S(ctx->f[3]);
label_1736ac:
    // 0x1736ac: 0x46021042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[2]);
    // 0x1736b0: 0x3c014316
    SET_GPR_U32(ctx, 1, ((uint32_t)17174 << 16));
    // 0x1736b4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1736b8: 0x10000002
    ctx->f[13] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1736c4;
    }
label_1736c0:
    // 0x1736c0: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
label_1736c4:
    // 0x1736c4: 0x8e032678
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 9848)));
    // 0x1736c8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1736cc: 0xc44e1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[14] = *(float*)&val; }
    // 0x1736d0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x1736d4: 0xc46c0300
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 768)); ctx->f[12] = *(float*)&val; }
    // 0x1736d8: 0x24843900
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 14592));
    // 0x1736dc: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x1736e4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_1736e4
// Address: 0x1736e4 - 0x173708

void entry_1736e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1736e4) {
        switch (ctx->pc) {
            case 0x1736f0: ctx->pc = 0; goto label_1736f0;
            case 0x1736f4: ctx->pc = 0; goto label_1736f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1736e4: 0x8e022678
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9848)));
    // 0x1736e8: 0xe4400300
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 768), *(uint32_t*)&val); }
    // 0x1736ec: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_1736f0:
    // 0x1736f0: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_1736f4:
    // 0x1736f4: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1736f8: 0xc7b40040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[20] = *(float*)&val; }
    // 0x1736fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x173704: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x173708; return;
}


// Function: FUN_00173708
// Address: 0x173708 - 0x17371c

void FUN_00173708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x173708: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x17370c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x173710: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x173714: 0xc0648ba
    SET_GPR_U32(ctx, 31, 0x17371c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    OnPoActive__FP2POiT0(rdram, ctx, runtime); return;
}


// Function: entry_17371c
// Address: 0x17371c - 0x17373c

void entry_17371c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17371c) {
        switch (ctx->pc) {
            case 0x173730: ctx->pc = 0; goto label_173730;
            case 0x173734: ctx->pc = 0; goto label_173734;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17371c: 0x12000004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_173730;
    }
    // 0x173724: 0x8c4323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9152)));
    // 0x173728: 0x10000002
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 6652)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173734;
    }
label_173730:
    // 0x173730: 0x2404ffff
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967295));
label_173734:
    // 0x173734: 0xc074a72
    SET_GPR_U32(ctx, 31, 0x17373c);
    SetFsp__F3FSP(rdram, ctx, runtime); return;
}


// Function: entry_17373c
// Address: 0x17373c - 0x173750

void entry_17373c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17373c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x173740: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x173744: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17374c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x173750; return;
}


// Function: FUN_00173750
// Address: 0x173750 - 0x173774

void FUN_00173750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x173750: 0x27bdfc10
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966288));
    // 0x173754: 0x7fb103c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 960), GPR_VEC(ctx, 17));
    // 0x173758: 0x7fb003b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 944), GPR_VEC(ctx, 16));
    // 0x17375c: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x173760: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x173764: 0x7fb203d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 976), GPR_VEC(ctx, 18));
    // 0x173768: 0x7fbf03e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 992), GPR_VEC(ctx, 31));
    // 0x17376c: 0xc063582
    SET_GPR_U32(ctx, 31, 0x173774);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_173774
// Address: 0x173774 - 0x1737b8

void entry_173774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x173774: 0x8e0306d8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1752)));
    // 0x173778: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17377c: 0xda220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x173780: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x173784: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x173788: 0xe0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x17378c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x173790: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x173794: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x173798: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17379c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1737a0: 0x27aa03a0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 928));
    // 0x1737a4: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1737a8: 0x27ab03a4
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 932));
    // 0x1737ac: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1737b0: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x1737b8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1737b8
// Address: 0x1737b8 - 0x1737e8

void entry_1737b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1737b8) {
        switch (ctx->pc) {
            case 0x1737c8: ctx->pc = 0; goto label_1737c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1737b8: 0x8fa203a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 928)));
    // 0x1737bc: 0x18400028
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x173860; return;
    }
    // 0x1737c4: 0x8fa303a4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 932)));
label_1737c8:
    // 0x1737c8: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x1737cc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1737d0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1737d4: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x1737d8: 0x24070008
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1737dc: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1737e0: 0xc05070a
    SET_GPR_U32(ctx, 31, 0x1737e8);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    ClsgClipEdgeToObject__FP2SOP6VECTORT1iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_1737e8
// Address: 0x1737e8 - 0x173838

void entry_1737e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1737e8) {
        switch (ctx->pc) {
            case 0x173808: ctx->pc = 0; goto label_173808;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1737e8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1737ec: 0x18a00017
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 5) <= 0) {
        ctx->pc = 0x17384C; return;
    }
    // 0x1737f4: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1737f8: 0x200182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1737fc: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x173800: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x173804: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
label_173808:
    // 0x173808: 0xc4600040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 64)); ctx->f[0] = *(float*)&val; }
    // 0x17380c: 0x46020032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x173810: 0x0
    // NOP
    // 0x173814: 0x4501000a
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x173840; return;
    }
    // 0x17381c: 0xc4600028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 40)); ctx->f[0] = *(float*)&val; }
    // 0x173820: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x173824: 0x0
    // NOP
    // 0x173828: 0x45000006
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x173844; return;
    }
    // 0x173830: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x173838);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_173838
// Address: 0x173838 - 0x173868

void entry_173838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173838) {
        switch (ctx->pc) {
            case 0x173840: ctx->pc = 0; goto label_173840;
            case 0x173844: ctx->pc = 0; goto label_173844;
            case 0x17384c: ctx->pc = 0; goto label_17384c;
            case 0x173860: ctx->pc = 0; goto label_173860;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173838: 0x1000000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17386C; return;
    }
label_173840:
    // 0x173840: 0x85102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 5)));
label_173844:
    // 0x173844: 0x1440fff0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 112));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x173808; return;
    }
label_17384c:
    // 0x17384c: 0x8fa203a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 928)));
    // 0x173850: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x173854: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x173858: 0x1440ffdb
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 932)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1737C8; return;
    }
label_173860:
    // 0x173860: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x173868);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_173868
// Address: 0x173868 - 0x173888

void entry_173868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173868) {
        switch (ctx->pc) {
            case 0x17386c: ctx->pc = 0; goto label_17386c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173868: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_17386c:
    // 0x17386c: 0x7bbf03e0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 992)));
    // 0x173870: 0x7bb203d0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 976)));
    // 0x173874: 0x7bb103c0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 960)));
    // 0x173878: 0x7bb003b0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 944)));
    // 0x17387c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1008));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x173884: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x173888; return;
}


// Function: UpdateJtActive__FP2JTP3JOYf
// Address: 0x173888 - 0x1738c0

void entry_1738c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1738c0) {
        switch (ctx->pc) {
            case 0x1738ec: ctx->pc = 0; goto label_1738ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1738c0: 0x1040000d
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1738F8; return;
    }
    // 0x1738c8: 0xc6610048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 72)); ctx->f[1] = *(float*)&val; }
    // 0x1738cc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1738d0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1738d4: 0x45010005
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1738ec;
    }
    // 0x1738dc: 0x966200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 170)));
    // 0x1738e0: 0x304200f0
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 240));
    // 0x1738e4: 0x104003bc
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1747D8; return;
    }
label_1738ec:
    // 0x1738ec: 0xc04a09e
    SET_GPR_U32(ctx, 31, 0x1738f4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    RetractAloDrive__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_1738f4
// Address: 0x1738f4 - 0x173978

void entry_1738f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1738f4) {
        switch (ctx->pc) {
            case 0x1738f8: ctx->pc = 0; goto label_1738f8;
            case 0x173928: ctx->pc = 0; goto label_173928;
            case 0x17394c: ctx->pc = 0; goto label_17394c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1738f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_1738f8:
    // 0x1738f8: 0x8c431d38
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 7480)));
    // 0x1738fc: 0x5c60000a
    if (GPR_S32(ctx, 3) > 0) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        goto label_173928;
    }
    // 0x173904: 0x8e222be0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 11232)));
    // 0x173908: 0x54400007
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        goto label_173928;
    }
    // 0x173910: 0x8e222be4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 11236)));
    // 0x173914: 0x14400004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_173928;
    }
    // 0x17391c: 0x8e222be8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 11240)));
    // 0x173920: 0x10400048
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173A44; return;
    }
label_173928:
    // 0x173928: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x17392c: 0x10620014
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 9));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x173980; return;
    }
    // 0x173934: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17394c;
    }
    // 0x17393c: 0x1062002c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1739F0; return;
    }
    // 0x173944: 0x1000003b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173A34; return;
    }
label_17394c:
    // 0x17394c: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x173950: 0x14620037
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x173A30; return;
    }
    // 0x173958: 0x8e222bd0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 11216)));
    // 0x17395c: 0x14400035
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x173A34; return;
    }
    // 0x173964: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x173968: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x17396c: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x173970: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x173978);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 35));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_173978
// Address: 0x173978 - 0x1739c4

void entry_173978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173978) {
        switch (ctx->pc) {
            case 0x173980: ctx->pc = 0; goto label_173980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173978: 0x1000002d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173A30; return;
    }
label_173980:
    // 0x173980: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x173984: 0xc6222224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8740)); ctx->f[2] = *(float*)&val; }
    // 0x173988: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17398c: 0x3c013e4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15948 << 16));
    // 0x173990: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x173994: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x173998: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17399c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1739a0: 0x0
    // NOP
    // 0x1739a4: 0x45000021
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_173a2c(rdram, ctx, runtime); return;
    }
    // 0x1739ac: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1739b0: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x1739b4: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1739b8: 0xae23224c
    WRITE32(ADD32(GPR_U32(ctx, 17), 8780), GPR_U32(ctx, 3));
    // 0x1739bc: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x1739c4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_1739c4
// Address: 0x1739c4 - 0x1739dc

void entry_1739c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1739c4) {
        switch (ctx->pc) {
            case 0x1739cc: ctx->pc = 0; goto label_1739cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1739c4: 0x1000001a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173A30; return;
    }
label_1739cc:
    // 0x1739cc: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1739d0: 0x24845b04
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23300));
    // 0x1739d4: 0xc07c10a
    SET_GPR_U32(ctx, 31, 0x1739dc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    WipeToWorldWarp(rdram, ctx, runtime); return;
}


// Function: entry_1739dc
// Address: 0x1739dc - 0x1739e8

void entry_1739dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1739dc: 0x26c42c70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 22), 11376));
    // 0x1739e0: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1739e8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2048));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1739e8
// Address: 0x1739e8 - 0x173a2c

void entry_1739e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1739e8) {
        switch (ctx->pc) {
            case 0x1739f0: ctx->pc = 0; goto label_1739f0;
            case 0x173a1c: ctx->pc = 0; goto label_173a1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1739e8: 0x1000004a
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173B14; return;
    }
label_1739f0:
    // 0x1739f0: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x1739f4: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1739f8: 0x10620008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_173a1c;
    }
    // 0x173a00: 0x1440000b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x173A30; return;
    }
    // 0x173a08: 0x28620010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 16));
    // 0x173a0c: 0x10400008
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 10));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173A30; return;
    }
    // 0x173a14: 0x14400007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x173A34; return;
    }
label_173a1c:
    // 0x173a1c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x173a20: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x173a24: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x173a2c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_173a2c
// Address: 0x173a2c - 0x173a3c

void entry_173a2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173a2c) {
        switch (ctx->pc) {
            case 0x173a30: ctx->pc = 0; goto label_173a30;
            case 0x173a34: ctx->pc = 0; goto label_173a34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173a2c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_173a30:
    // 0x173a30: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_173a34:
    // 0x173a34: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x173a3c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 196));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_173a3c
// Address: 0x173a3c - 0x173a64

void entry_173a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173a3c) {
        switch (ctx->pc) {
            case 0x173a44: ctx->pc = 0; goto label_173a44;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173a3c: 0x3a0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x173a40: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
label_173a44:
    // 0x173a44: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x173a48: 0x10620045
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x173B60; return;
    }
    // 0x173a50: 0x8e242740
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 10048)));
    // 0x173a54: 0x5080003e
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x173B50; return;
    }
    // 0x173a5c: 0xc05f36a
    SET_GPR_U32(ctx, 31, 0x173a64);
    FIsJsgActive__FP3JSG(rdram, ctx, runtime); return;
}


// Function: entry_173a64
// Address: 0x173a64 - 0x173ae0

void entry_173a64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173a64) {
        switch (ctx->pc) {
            case 0x173ab8: ctx->pc = 0; goto label_173ab8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173a64: 0x10400034
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173B38; return;
    }
    // 0x173a6c: 0x60b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    // 0x173a70: 0x24632c70
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 11376));
    // 0x173a74: 0x946200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 170)));
    // 0x173a78: 0x30420800
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2048));
    // 0x173a7c: 0x10400024
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 17), 10048)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173B10; return;
    }
    // 0x173a84: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x173a88: 0x8c625f84
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24452)));
    // 0x173a8c: 0x14400021
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x173B14; return;
    }
    // 0x173a94: 0x8e630040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 64)));
    // 0x173a98: 0x460001e
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) < 0) {
        ctx->pc = 0x173B14; return;
    }
    // 0x173aa0: 0x8e620034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 52)));
    // 0x173aa4: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x173aa8: 0x1040001a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 20));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173B14; return;
    }
    // 0x173ab0: 0x24150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    // 0x173ab4: 0x242a018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
label_173ab8:
    // 0x173ab8: 0x8e620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 56)));
    // 0x173abc: 0x541021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 20)));
    // 0x173ac0: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x173ac4: 0x5475000e
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 21)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 52)));
        ctx->pc = 0x173B00; return;
    }
    // 0x173acc: 0x8c460004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x173ad0: 0x24050104
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    // 0x173ad4: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x173ad8: 0xc056906
    SET_GPR_U32(ctx, 31, 0x173ae0);
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 19), 76)));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_173ae0
// Address: 0x173ae0 - 0x173af4

void entry_173ae0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x173ae0: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x173ae4: 0x12000005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173AFC; return;
    }
    // 0x173aec: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x173af4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 116));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_173af4
// Address: 0x173af4 - 0x173b20

void entry_173af4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173af4) {
        switch (ctx->pc) {
            case 0x173afc: ctx->pc = 0; goto label_173afc;
            case 0x173b00: ctx->pc = 0; goto label_173b00;
            case 0x173b10: ctx->pc = 0; goto label_173b10;
            case 0x173b14: ctx->pc = 0; goto label_173b14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173af4: 0x5440ffb5
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 8)));
        ctx->pc = 0x1739CC; return;
    }
label_173afc:
    // 0x173afc: 0x8e620034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 52)));
label_173b00:
    // 0x173b00: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x173b04: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x173b08: 0x1440ffeb
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 20));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x173AB8; return;
    }
label_173b10:
    // 0x173b10: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_173b14:
    // 0x173b14: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x173b18: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x173b20);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 196));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_173b20
// Address: 0x173b20 - 0x173b30

void entry_173b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x173b20: 0x8e242740
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 10048)));
    // 0x173b24: 0x3a0982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x173b28: 0xc05f1c6
    SET_GPR_U32(ctx, 31, 0x173b30);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ReadJsgJoystick__FP3JSGP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_173b30
// Address: 0x173b30 - 0x173b4c

void entry_173b30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173b30) {
        switch (ctx->pc) {
            case 0x173b38: ctx->pc = 0; goto label_173b38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173b30: 0x1000000e
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 212)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173B6C; return;
    }
label_173b38:
    // 0x173b38: 0x8e242740
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 10048)));
    // 0x173b3c: 0x50800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
        ctx->pc = 0x173B50; return;
    }
    // 0x173b44: 0xc05f3a0
    SET_GPR_U32(ctx, 31, 0x173b4c);
    RetractJsg__FP3JSG(rdram, ctx, runtime); return;
}


// Function: entry_173b4c
// Address: 0x173b4c - 0x173b58

void entry_173b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173b4c) {
        switch (ctx->pc) {
            case 0x173b50: ctx->pc = 0; goto label_173b50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173b4c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
label_173b50:
    // 0x173b50: 0xc07127a
    SET_GPR_U32(ctx, 31, 0x173b58);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ReadStepJoystick__FP4STEPP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_173b58
// Address: 0x173b58 - 0x173b68

void entry_173b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173b58) {
        switch (ctx->pc) {
            case 0x173b60: ctx->pc = 0; goto label_173b60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173b58: 0x10000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 212)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173B6C; return;
    }
label_173b60:
    // 0x173b60: 0xc07127a
    SET_GPR_U32(ctx, 31, 0x173b68);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    ReadStepJoystick__FP4STEPP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_173b68
// Address: 0x173b68 - 0x173b84

void entry_173b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173b68) {
        switch (ctx->pc) {
            case 0x173b6c: ctx->pc = 0; goto label_173b6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173b68: 0xc62c00d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 212)); ctx->f[12] = *(float*)&val; }
label_173b6c:
    // 0x173b6c: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x173b70: 0xc62d00d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 208)); ctx->f[13] = *(float*)&val; }
    // 0x173b74: 0xb02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x173b78: 0xafa000f4
    WRITE32(ADD32(GPR_U32(ctx, 29), 244), GPR_U32(ctx, 0));
    // 0x173b7c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x173b84);
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_173b84
// Address: 0x173b84 - 0x173b90

void entry_173b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x173b84: 0xc62c0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[12] = *(float*)&val; }
    // 0x173b88: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x173b90);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_173b90
// Address: 0x173b90 - 0x173c88

void entry_173b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173b90) {
        switch (ctx->pc) {
            case 0x173c0c: ctx->pc = 0; goto label_173c0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173b90: 0x966200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 170)));
    // 0x173b94: 0x30420040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64));
    // 0x173b98: 0x10400060
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173D1C; return;
    }
    // 0x173ba0: 0x8e222220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x173ba4: 0x2444fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x173ba8: 0x2c830007
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 7));
    // 0x173bac: 0x10600039
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173C94; return;
    }
    // 0x173bb4: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x173bb8: 0x2442a9f0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945264));
    // 0x173bbc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x173bc0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x173bc4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x173bcc: 0x8e23239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x173bd0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x173bd4: 0x1062004a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x173D00; return;
    }
    // 0x173bdc: 0x10620048
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x173D00; return;
    }
    // 0x173be4: 0x14620047
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x173D04; return;
    }
    // 0x173bec: 0x10000045
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173D04; return;
    }
    // 0x173bf4: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x173bf8: 0x28620009
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 9));
    // 0x173bfc: 0x10400003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 7));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_173c0c;
    }
    // 0x173c04: 0x1040003f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173D04; return;
    }
label_173c0c:
    // 0x173c0c: 0x8e222498
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9368)));
    // 0x173c10: 0x1040003c
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173D04; return;
    }
    // 0x173c18: 0xc62006cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1740)); ctx->f[0] = *(float*)&val; }
    // 0x173c1c: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x173c20: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x173c24: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x173c28: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x173c2c: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x173c30: 0xd8450000
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x173c34: 0x3c013ba3
    SET_GPR_U32(ctx, 1, ((uint32_t)15267 << 16));
    // 0x173c38: 0x3421d70b
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 55051));
    // 0x173c3c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x173c40: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x173c44: 0x27a500d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 208));
    // 0x173c48: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x173c4c: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x173c50: 0xfba200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x173c54: 0x44031000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[2]);
    // 0x173c58: 0x48a32000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x173c5c: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x173c60: 0xda230150
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x173c64: 0x48a33000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x173c68: 0xda210350
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 848)));
    // 0x173c6c: 0x4be229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x173c70: 0x4be418bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x173c74: 0x4be60888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x173c78: 0xfba400e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x173c7c: 0xfba200d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x173c80: 0xc05cdd4
    SET_GPR_U32(ctx, 31, 0x173c88);
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[6]));
    FUN_00173750(rdram, ctx, runtime); return;
}


// Function: entry_173c88
// Address: 0x173c88 - 0x173cf8

void entry_173c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173c88) {
        switch (ctx->pc) {
            case 0x173c94: ctx->pc = 0; goto label_173c94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173c88: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x173c8c: 0x1000001d
    WRITE32(ADD32(GPR_U32(ctx, 29), 244), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173D04; return;
    }
label_173c94:
    // 0x173c94: 0xc62006cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1740)); ctx->f[0] = *(float*)&val; }
    // 0x173c98: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x173c9c: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x173ca0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x173ca4: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x173ca8: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x173cac: 0xc6220694
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1684)); ctx->f[2] = *(float*)&val; }
    // 0x173cb0: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x173cb4: 0x24638d20
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937888));
    // 0x173cb8: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x173cbc: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x173cc0: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x173cc4: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x173cc8: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x173ccc: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x173cd0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x173cd4: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x173cd8: 0x46040834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x173cdc: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x173ce0: 0xfba200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x173ce4: 0x45010006
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[1]));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x173D00; return;
    }
    // 0x173cec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x173cf0: 0xc05cdd4
    SET_GPR_U32(ctx, 31, 0x173cf8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 208));
    FUN_00173750(rdram, ctx, runtime); return;
}


// Function: entry_173cf8
// Address: 0x173cf8 - 0x173e30

void entry_173cf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173cf8) {
        switch (ctx->pc) {
            case 0x173d00: ctx->pc = 0; goto label_173d00;
            case 0x173d04: ctx->pc = 0; goto label_173d04;
            case 0x173d1c: ctx->pc = 0; goto label_173d1c;
            case 0x173d5c: ctx->pc = 0; goto label_173d5c;
            case 0x173d60: ctx->pc = 0; goto label_173d60;
            case 0x173df4: ctx->pc = 0; goto label_173df4;
            case 0x173e18: ctx->pc = 0; goto label_173e18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173cf8: 0x10400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_173d04;
    }
label_173d00:
    // 0x173d00: 0x24140001
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
label_173d04:
    // 0x173d04: 0x56800016
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        goto label_173d60;
    }
    // 0x173d0c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x173d10: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x173d14: 0x10000011
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 8836), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173d5c;
    }
label_173d1c:
    // 0x173d1c: 0xc6202284
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8836)); ctx->f[0] = *(float*)&val; }
    // 0x173d20: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x173d24: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x173d28: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x173d2c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x173d30: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x173d34: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x173d38: 0x0
    // NOP
    // 0x173d3c: 0x45020008
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        goto label_173d60;
    }
    // 0x173d44: 0xc6200694
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1684)); ctx->f[0] = *(float*)&val; }
    // 0x173d48: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x173d4c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x173d50: 0x0
    // NOP
    // 0x173d54: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 1));
        goto label_173d5c;
    }
label_173d5c:
    // 0x173d5c: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
label_173d60:
    // 0x173d60: 0x2c620011
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 17));
    // 0x173d64: 0x10400034
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173E38; return;
    }
    // 0x173d6c: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x173d70: 0x2442aa10
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945296));
    // 0x173d74: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x173d78: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x173d7c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x173d84: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x173d88: 0xc6220694
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1684)); ctx->f[2] = *(float*)&val; }
    // 0x173d8c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x173d90: 0x3c013dcc
    SET_GPR_U32(ctx, 1, ((uint32_t)15820 << 16));
    // 0x173d94: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x173d98: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x173d9c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x173da0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x173da4: 0x0
    // NOP
    // 0x173da8: 0x45000024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x173E3C; return;
    }
    // 0x173db0: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x173db4: 0x1462000f
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1740)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_173df4;
    }
    // 0x173dbc: 0x8e23239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x173dc0: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x173dc4: 0x1462000b
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_173df4;
    }
    // 0x173dcc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x173dd0: 0x3c014348
    SET_GPR_U32(ctx, 1, ((uint32_t)17224 << 16));
    // 0x173dd4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x173dd8: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x173ddc: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x173de0: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x173de4: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x173de8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x173dec: 0x1000000a
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173e18;
    }
label_173df4:
    // 0x173df4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x173df8: 0x3c014270
    SET_GPR_U32(ctx, 1, ((uint32_t)17008 << 16));
    // 0x173dfc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x173e00: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x173e04: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x173e08: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x173e0c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x173e10: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x173e14: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
label_173e18:
    // 0x173e18: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x173e1c: 0xfba200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x173e20: 0xfba100d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x173e24: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x173e28: 0xc05cdd4
    SET_GPR_U32(ctx, 31, 0x173e30);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 208));
    FUN_00173750(rdram, ctx, runtime); return;
}


// Function: entry_173e30
// Address: 0x173e30 - 0x173e8c

void entry_173e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173e30) {
        switch (ctx->pc) {
            case 0x173e38: ctx->pc = 0; goto label_173e38;
            case 0x173e3c: ctx->pc = 0; goto label_173e3c;
            case 0x173e5c: ctx->pc = 0; goto label_173e5c;
            case 0x173e80: ctx->pc = 0; goto label_173e80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173e30: 0x10000002
    SET_GPR_U32(ctx, 22, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173e3c;
    }
label_173e38:
    // 0x173e38: 0xb02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_173e3c:
    // 0x173e3c: 0xc6210634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[1] = *(float*)&val; }
    // 0x173e40: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x173e44: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x173e48: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x173e4c: 0x0
    // NOP
    // 0x173e50: 0x45010002
    WRITE32(ADD32(GPR_U32(ctx, 29), 240), GPR_U32(ctx, 3));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_173e5c;
    }
    // 0x173e58: 0xafa000f0
    WRITE32(ADD32(GPR_U32(ctx, 29), 240), GPR_U32(ctx, 0));
label_173e5c:
    // 0x173e5c: 0x966300a8
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 168)));
    // 0x173e60: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x173e64: 0x966200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 170)));
    // 0x173e68: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x173e6c: 0x10400004
    SET_GPR_U32(ctx, 30, AND32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_173e80;
    }
    // 0x173e74: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x173e78: 0x8c434f74
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 20340)));
    // 0x173e7c: 0x2c770001
    SET_GPR_U32(ctx, 23, SLTU32(GPR_U32(ctx, 3), 1));
label_173e80:
    // 0x173e80: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x173e84: 0xc074aee
    SET_GPR_U32(ctx, 31, 0x173e8c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    UpdateJtActivePowerUp__FP2JTP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_173e8c
// Address: 0x173e8c - 0x173e9c

void entry_173e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x173e8c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x173e90: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x173e94: 0xc0524e8
    SET_GPR_U32(ctx, 31, 0x173e9c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1108));
    FActiveCplcy(rdram, ctx, runtime); return;
}


// Function: entry_173e9c
// Address: 0x173e9c - 0x173f34

void entry_173e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173e9c) {
        switch (ctx->pc) {
            case 0x173ec0: ctx->pc = 0; goto label_173ec0;
            case 0x173ec8: ctx->pc = 0; goto label_173ec8;
            case 0x173f2c: ctx->pc = 0; goto label_173f2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173e9c: 0x54400059
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174004; return;
    }
    // 0x173ea4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x173ea8: 0x8c622c68
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11368)));
    // 0x173eac: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x173eb0: 0x10400003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_173ec0;
    }
    // 0x173eb8: 0x10000003
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 11376));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_173ec8;
    }
label_173ec0:
    // 0x173ec0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x173ec4: 0x24502d38
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 11576));
label_173ec8:
    // 0x173ec8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x173ecc: 0x244501f8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 2), 504));
    // 0x173ed0: 0x8ca40324
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 804)));
    // 0x173ed4: 0x1080001c
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173F48; return;
    }
    // 0x173edc: 0x8c8302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 724)));
    // 0x173ee0: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x173ee4: 0x54620019
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 11220)));
        ctx->pc = 0x173F4C; return;
    }
    // 0x173eec: 0x8c82032c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 812)));
    // 0x173ef0: 0x54400016
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 11220)));
        ctx->pc = 0x173F4C; return;
    }
    // 0x173ef8: 0x960200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 16), 170)));
    // 0x173efc: 0x3042000c
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 12));
    // 0x173f00: 0x50400012
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 11220)));
        ctx->pc = 0x173F4C; return;
    }
    // 0x173f08: 0x8c820304
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 772)));
    // 0x173f0c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x173f10: 0x1060000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173F48; return;
    }
    // 0x173f18: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x173f1c: 0x14620003
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_173f2c;
    }
    // 0x173f24: 0xae202bd0
    WRITE32(ADD32(GPR_U32(ctx, 17), 11216), GPR_U32(ctx, 0));
    // 0x173f28: 0x24150001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
label_173f2c:
    // 0x173f2c: 0xc0545b0
    SET_GPR_U32(ctx, 31, 0x173f34);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 804)));
    FUN_001516c0(rdram, ctx, runtime); return;
}


// Function: entry_173f34
// Address: 0x173f34 - 0x173f40

void entry_173f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x173f34: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x173f38: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x173f40);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_173f40
// Address: 0x173f40 - 0x173fcc

void entry_173f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173f40) {
        switch (ctx->pc) {
            case 0x173f48: ctx->pc = 0; goto label_173f48;
            case 0x173f4c: ctx->pc = 0; goto label_173f4c;
            case 0x173f68: ctx->pc = 0; goto label_173f68;
            case 0x173f88: ctx->pc = 0; goto label_173f88;
            case 0x173fc4: ctx->pc = 0; goto label_173fc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173f40: 0x10000030
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174004; return;
    }
label_173f48:
    // 0x173f48: 0x8e252bd4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 11220)));
label_173f4c:
    // 0x173f4c: 0x54a00006
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        goto label_173f68;
    }
    // 0x173f54: 0x966200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 170)));
    // 0x173f58: 0x3042000c
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 12));
    // 0x173f5c: 0x50400029
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174004; return;
    }
    // 0x173f64: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
label_173f68:
    // 0x173f68: 0x2402000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    // 0x173f6c: 0x14620006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 6), 504));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_173f88;
    }
    // 0x173f74: 0x8c430324
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 804)));
    // 0x173f78: 0x54600022
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174004; return;
    }
    // 0x173f80: 0x10000017
    WRITE32(ADD32(GPR_U32(ctx, 17), 11216), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173FE0; return;
    }
label_173f88:
    // 0x173f88: 0x8c430324
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 804)));
    // 0x173f8c: 0x5460001d
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174004; return;
    }
    // 0x173f94: 0x966200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 170)));
    // 0x173f98: 0x30420004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4));
    // 0x173f9c: 0x1040000d
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173FD4; return;
    }
    // 0x173fa4: 0x8c44f800
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4294965248)));
    // 0x173fa8: 0x1080000a
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x173FD4; return;
    }
    // 0x173fb0: 0x10a00004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_173fc4;
    }
    // 0x173fb8: 0x8c8302d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 720)));
    // 0x173fbc: 0x14620005
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x173FD4; return;
    }
label_173fc4:
    // 0x173fc4: 0xc0541e4
    SET_GPR_U32(ctx, 31, 0x173fcc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetDialogDialogs__FP6DIALOG7DIALOGS(rdram, ctx, runtime); return;
}


// Function: entry_173fcc
// Address: 0x173fcc - 0x173ff8

void entry_173fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173fcc) {
        switch (ctx->pc) {
            case 0x173fd4: ctx->pc = 0; goto label_173fd4;
            case 0x173fe0: ctx->pc = 0; goto label_173fe0;
            case 0x173fe8: ctx->pc = 0; goto label_173fe8;
            case 0x173fec: ctx->pc = 0; goto label_173fec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173fcc: 0x1000000d
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174004; return;
    }
label_173fd4:
    // 0x173fd4: 0x54a0000b
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174004; return;
    }
    // 0x173fdc: 0xae202bd0
    WRITE32(ADD32(GPR_U32(ctx, 17), 11216), GPR_U32(ctx, 0));
label_173fe0:
    // 0x173fe0: 0x10000007
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174000; return;
    }
label_173fe8:
    // 0x173fe8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_173fec:
    // 0x173fec: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x173ff0: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x173ff8);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_173ff8
// Address: 0x173ff8 - 0x174038

void entry_173ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x173ff8) {
        switch (ctx->pc) {
            case 0x174000: ctx->pc = 0; goto label_174000;
            case 0x174004: ctx->pc = 0; goto label_174004;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x173ff8: 0xa02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x173ffc: 0xafa000f4
    WRITE32(ADD32(GPR_U32(ctx, 29), 244), GPR_U32(ctx, 0));
label_174000:
    // 0x174000: 0x8e322220
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
label_174004:
    // 0x174004: 0x8e302228
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x174008: 0x2e420011
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 18), 17));
    // 0x17400c: 0x1040019c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
    // 0x174014: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x174018: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x17401c: 0x2442aa60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945376));
    // 0x174020: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x174024: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x174028: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x174030: 0xc058316
    SET_GPR_U32(ctx, 31, 0x174038);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_174038
// Address: 0x174038 - 0x174058

void entry_174038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174038: 0x5040000b
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10040)));
        ctx->pc = 0x174068; return;
    }
    // 0x174040: 0x966200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 170)));
    // 0x174044: 0x30420040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64));
    // 0x174048: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174064; return;
    }
    // 0x174050: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x174058);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_174058
// Address: 0x174058 - 0x17409c

void entry_174058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174058) {
        switch (ctx->pc) {
            case 0x174064: ctx->pc = 0; goto label_174064;
            case 0x174068: ctx->pc = 0; goto label_174068;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174058: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17405c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x174060: 0xe6202734
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 10036), *(uint32_t*)&val); }
label_174064:
    // 0x174064: 0x8e222738
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10040)));
label_174068:
    // 0x174068: 0x10400185
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
    // 0x174070: 0xc6222734
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 10036)); ctx->f[2] = *(float*)&val; }
    // 0x174074: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x174078: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17407c: 0xc4413910
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14608)); ctx->f[1] = *(float*)&val; }
    // 0x174080: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x174084: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x174088: 0x0
    // NOP
    // 0x17408c: 0x4502017d
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174684; return;
    }
    // 0x174094: 0xc075326
    SET_GPR_U32(ctx, 31, 0x17409c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001d4c98(rdram, ctx, runtime); return;
}


// Function: entry_17409c
// Address: 0x17409c - 0x1740e8

void entry_17409c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17409c) {
        switch (ctx->pc) {
            case 0x1740c8: ctx->pc = 0; goto label_1740c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17409c: 0x8e322220
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x1740a0: 0x10000177
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
    // 0x1740a8: 0x8e22223c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8764)));
    // 0x1740ac: 0x2442fff8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967288));
    // 0x1740b0: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1740b4: 0x10400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1740c8;
    }
    // 0x1740bc: 0x8e222248
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8776)));
    // 0x1740c0: 0x50400170
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174684; return;
    }
label_1740c8:
    // 0x1740c8: 0x568000f2
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
        ctx->pc = 0x174494; return;
    }
    // 0x1740d0: 0x56c0016a
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
        ctx->pc = 0x17467C; return;
    }
    // 0x1740d8: 0x12e00006
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1740F4; return;
    }
    // 0x1740e0: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1740e8);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1740e8
// Address: 0x1740e8 - 0x174108

void entry_1740e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1740e8) {
        switch (ctx->pc) {
            case 0x1740f4: ctx->pc = 0; goto label_1740f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1740e8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1740ec: 0x544000f6
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 10));
        ctx->pc = 0x1744C8; return;
    }
label_1740f4:
    // 0x1740f4: 0x13c0001b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        entry_174164(rdram, ctx, runtime); return;
    }
    // 0x1740fc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174100: 0xc0737ee
    SET_GPR_U32(ctx, 31, 0x174108);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 9116));
    JtbsChooseJtHide__FP2JTP2LOP4JTHK(rdram, ctx, runtime); return;
}


// Function: entry_174108
// Address: 0x174108 - 0x174164

void entry_174108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174108: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17410c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x174110: 0x5462005b
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
        ctx->pc = 0x174280; return;
    }
    // 0x174118: 0x966200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 170)));
    // 0x17411c: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x174120: 0x10400010
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_174164(rdram, ctx, runtime); return;
    }
    // 0x174128: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x17412c: 0xc44e2e24
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11812)); ctx->f[14] = *(float*)&val; }
    // 0x174130: 0x2404007e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 126));
    // 0x174134: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x174138: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x17413c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x174140: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174144: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x174148: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x17414c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174150: 0x26270140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 320));
    // 0x174154: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x174158: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17415c: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x174164);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_174164
// Address: 0x174164 - 0x1741b4

void entry_174164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174164) {
        switch (ctx->pc) {
            case 0x17419c: ctx->pc = 0; goto label_17419c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174164: 0x56a0005d
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 12));
        ctx->pc = 0x1742DC; return;
    }
    // 0x17416c: 0x8fa300f0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x174170: 0x50600144
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174684; return;
    }
    // 0x174178: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17417c: 0x10000140
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
    // 0x174184: 0x12800005
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_17419c;
    }
    // 0x17418c: 0x24120002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    // 0x174190: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174194: 0x1000013a
    WRITE32(ADD32(GPR_U32(ctx, 17), 8780), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
label_17419c:
    // 0x17419c: 0x56c00137
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
        ctx->pc = 0x17467C; return;
    }
    // 0x1741a4: 0x12e00006
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1741C0; return;
    }
    // 0x1741ac: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1741b4);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1741b4
// Address: 0x1741b4 - 0x1741d4

void entry_1741b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1741b4) {
        switch (ctx->pc) {
            case 0x1741c0: ctx->pc = 0; goto label_1741c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1741b4: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1741b8: 0x544000c3
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 10));
        ctx->pc = 0x1744C8; return;
    }
label_1741c0:
    // 0x1741c0: 0x13c0001b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        entry_174230(rdram, ctx, runtime); return;
    }
    // 0x1741c8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1741cc: 0xc0737ee
    SET_GPR_U32(ctx, 31, 0x1741d4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 9116));
    JtbsChooseJtHide__FP2JTP2LOP4JTHK(rdram, ctx, runtime); return;
}


// Function: entry_1741d4
// Address: 0x1741d4 - 0x174230

void entry_1741d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1741d4: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1741d8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1741dc: 0x54620028
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
        ctx->pc = 0x174280; return;
    }
    // 0x1741e4: 0x966200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 170)));
    // 0x1741e8: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1741ec: 0x10400010
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_174230(rdram, ctx, runtime); return;
    }
    // 0x1741f4: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1741f8: 0xc44e2e24
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11812)); ctx->f[14] = *(float*)&val; }
    // 0x1741fc: 0x2404007e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 126));
    // 0x174200: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x174204: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x174208: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x17420c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174210: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x174214: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x174218: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17421c: 0x26270140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 320));
    // 0x174220: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x174224: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174228: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x174230);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_174230
// Address: 0x174230 - 0x174270

void entry_174230(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174230: 0x56a0002a
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 12));
        ctx->pc = 0x1742DC; return;
    }
    // 0x174238: 0x8fa200f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x17423c: 0x54400111
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174684; return;
    }
    // 0x174244: 0x100000f6
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174620; return;
    }
    // 0x17424c: 0x16800091
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x174494; return;
    }
    // 0x174254: 0x16c0010a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
    // 0x17425c: 0x13c0001d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        entry_1742d4(rdram, ctx, runtime); return;
    }
    // 0x174264: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174268: 0xc0737ee
    SET_GPR_U32(ctx, 31, 0x174270);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 9116));
    JtbsChooseJtHide__FP2JTP2LOP4JTHK(rdram, ctx, runtime); return;
}


// Function: entry_174270
// Address: 0x174270 - 0x1742d4

void entry_174270(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174270) {
        switch (ctx->pc) {
            case 0x174280: ctx->pc = 0; goto label_174280;
            case 0x174288: ctx->pc = 0; goto label_174288;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174270: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x174274: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x174278: 0x10620003
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_174288;
    }
label_174280:
    // 0x174280: 0x100000ff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
label_174288:
    // 0x174288: 0x966200aa
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 170)));
    // 0x17428c: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x174290: 0x10400010
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1742d4(rdram, ctx, runtime); return;
    }
    // 0x174298: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x17429c: 0xc44e2e24
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11812)); ctx->f[14] = *(float*)&val; }
    // 0x1742a0: 0x2404007e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 126));
    // 0x1742a4: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1742a8: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1742ac: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1742b0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1742b4: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1742b8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1742bc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1742c0: 0x26270140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 17), 320));
    // 0x1742c4: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1742c8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1742cc: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1742d4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1742d4
// Address: 0x1742d4 - 0x174378

void entry_1742d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1742d4) {
        switch (ctx->pc) {
            case 0x1742dc: ctx->pc = 0; goto label_1742dc;
            case 0x174354: ctx->pc = 0; goto label_174354;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1742d4: 0x12a000d1
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17461C; return;
    }
label_1742dc:
    // 0x1742dc: 0x100000e8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 33));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
    // 0x1742e4: 0x2602fff6
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 4294967286));
    // 0x1742e8: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1742ec: 0x14400019
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_174354;
    }
    // 0x1742f4: 0x2402000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 13));
    // 0x1742f8: 0x12020016
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 12));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_174354;
    }
    // 0x174300: 0x12020014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 14));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_174354;
    }
    // 0x174308: 0x12020012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 15));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_174354;
    }
    // 0x174310: 0x12020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_174354;
    }
    // 0x174318: 0x1202000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        goto label_174354;
    }
    // 0x174320: 0x5602000c
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
        goto label_174354;
    }
    // 0x174328: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17432c: 0xc622222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x174330: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x174334: 0x3c013d4c
    SET_GPR_U32(ctx, 1, ((uint32_t)15692 << 16));
    // 0x174338: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x17433c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x174340: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x174344: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x174348: 0x0
    // NOP
    // 0x17434c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
        goto label_174354;
    }
label_174354:
    // 0x174354: 0x1080002f
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174414; return;
    }
    // 0x17435c: 0x966300aa
    SET_GPR_U32(ctx, 3, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 170)));
    // 0x174360: 0x30620020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 32));
    // 0x174364: 0x1040000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174398; return;
    }
    // 0x17436c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x174370: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x174378);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 32));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_174378
// Address: 0x174378 - 0x174384

void entry_174378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174378: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17437c: 0xc071878
    SET_GPR_U32(ctx, 31, 0x174384);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_174384
// Address: 0x174384 - 0x174390

void entry_174384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174384: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x174388: 0xc073c56
    SET_GPR_U32(ctx, 31, 0x174390);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001cf158(rdram, ctx, runtime); return;
}


// Function: entry_174390
// Address: 0x174390 - 0x1743c8

void entry_174390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174390) {
        switch (ctx->pc) {
            case 0x174398: ctx->pc = 0; goto label_174398;
            case 0x1743b4: ctx->pc = 0; goto label_1743b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174390: 0x100000bb
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
label_174398:
    // 0x174398: 0x16020006
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 128));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        goto label_1743b4;
    }
    // 0x1743a0: 0xc621226c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8812)); ctx->f[1] = *(float*)&val; }
    // 0x1743a4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1743a8: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1743ac: 0x4501000c
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x1743E0; return;
    }
label_1743b4:
    // 0x1743b4: 0x1040000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1743E0; return;
    }
    // 0x1743bc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1743c0: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1743c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1743c8
// Address: 0x1743c8 - 0x1743d8

void entry_1743c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1743c8: 0x24100007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1743cc: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1743d0: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x1743d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 128));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_1743d8
// Address: 0x1743d8 - 0x1743f8

void entry_1743d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1743d8) {
        switch (ctx->pc) {
            case 0x1743e0: ctx->pc = 0; goto label_1743e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1743d8: 0x100000aa
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174684; return;
    }
label_1743e0:
    // 0x1743e0: 0x1080000c
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174414; return;
    }
    // 0x1743e8: 0x12e0000a
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174414; return;
    }
    // 0x1743f0: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1743f8);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1743f8
// Address: 0x1743f8 - 0x17440c

void entry_1743f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1743f8: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x1743fc: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174414; return;
    }
    // 0x174404: 0xc071878
    SET_GPR_U32(ctx, 31, 0x17440c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_17440c
// Address: 0x17440c - 0x174424

void entry_17440c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17440c) {
        switch (ctx->pc) {
            case 0x174414: ctx->pc = 0; goto label_174414;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17440c: 0x1000009c
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
label_174414:
    // 0x174414: 0x1280000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174448; return;
    }
    // 0x17441c: 0xc058344
    SET_GPR_U32(ctx, 31, 0x174424);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_174424
// Address: 0x174424 - 0x1744b8

void entry_174424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174424) {
        switch (ctx->pc) {
            case 0x174448: ctx->pc = 0; goto label_174448;
            case 0x174488: ctx->pc = 0; goto label_174488;
            case 0x174494: ctx->pc = 0; goto label_174494;
            case 0x17449c: ctx->pc = 0; goto label_17449c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174424: 0x30421000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4096));
    // 0x174428: 0x54400096
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174684; return;
    }
    // 0x174430: 0x966200a8
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 168)));
    // 0x174434: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x174438: 0x50400091
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 10052), GPR_U32(ctx, 0));
        ctx->pc = 0x174680; return;
    }
    // 0x174440: 0x10000090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174684; return;
    }
label_174448:
    // 0x174448: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x17444c: 0x1000008c
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 16, GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
    // 0x174454: 0x1280008a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
    // 0x17445c: 0x1000002f
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17451C; return;
    }
    // 0x174464: 0x8e23239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x174468: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17446c: 0x14620006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_174488;
    }
    // 0x174474: 0x52800083
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174684; return;
    }
    // 0x17447c: 0x24120002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    // 0x174480: 0x1000007f
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
label_174488:
    // 0x174488: 0x12800004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 4294967292));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_17449c;
    }
    // 0x174490: 0x24120002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
label_174494:
    // 0x174494: 0x1000007a
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
label_17449c:
    // 0x17449c: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x1744a0: 0x54400078
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174684; return;
    }
    // 0x1744a8: 0x12e00009
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1744D0; return;
    }
    // 0x1744b0: 0xc058344
    SET_GPR_U32(ctx, 31, 0x1744b8);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_1744b8
// Address: 0x1744b8 - 0x174508

void entry_1744b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1744b8) {
        switch (ctx->pc) {
            case 0x1744c8: ctx->pc = 0; goto label_1744c8;
            case 0x1744d0: ctx->pc = 0; goto label_1744d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1744b8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x1744bc: 0x10400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1744d0;
    }
    // 0x1744c4: 0x2412000a
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 10));
label_1744c8:
    // 0x1744c8: 0x1000006d
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 31));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
label_1744d0:
    // 0x1744d0: 0x56c0006a
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
        ctx->pc = 0x17467C; return;
    }
    // 0x1744d8: 0x966200a8
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 168)));
    // 0x1744dc: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x1744e0: 0x54400068
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174684; return;
    }
    // 0x1744e8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1744ec: 0x8c622c6c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11372)));
    // 0x1744f0: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x1744f4: 0x54400063
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        ctx->pc = 0x174684; return;
    }
    // 0x1744fc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x174500: 0xc05f9b4
    SET_GPR_U32(ctx, 31, 0x174508);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    JtsResetJt__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_174508
// Address: 0x174508 - 0x174548

void entry_174508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174508) {
        switch (ctx->pc) {
            case 0x17451c: ctx->pc = 0; goto label_17451c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174508: 0x1000005d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
    // 0x174510: 0x1280005b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
    // 0x174518: 0x24120002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
label_17451c:
    // 0x17451c: 0xae22224c
    WRITE32(ADD32(GPR_U32(ctx, 17), 8780), GPR_U32(ctx, 2));
    // 0x174520: 0x10000057
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174680; return;
    }
    // 0x174528: 0x12a00009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 34));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174550; return;
    }
    // 0x174530: 0x14a20019
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x174598; return;
    }
    // 0x174538: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x17453c: 0x24100023
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 35));
    // 0x174540: 0xc07a55c
    SET_GPR_U32(ctx, 31, 0x174548);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PopUiActiveBlot__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_174548
// Address: 0x174548 - 0x1746a4

void entry_174548(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174548) {
        switch (ctx->pc) {
            case 0x174550: ctx->pc = 0; goto label_174550;
            case 0x174590: ctx->pc = 0; goto label_174590;
            case 0x174598: ctx->pc = 0; goto label_174598;
            case 0x1745dc: ctx->pc = 0; goto label_1745dc;
            case 0x17461c: ctx->pc = 0; goto label_17461c;
            case 0x174620: ctx->pc = 0; goto label_174620;
            case 0x174668: ctx->pc = 0; goto label_174668;
            case 0x17467c: ctx->pc = 0; goto label_17467c;
            case 0x174680: ctx->pc = 0; goto label_174680;
            case 0x174684: ctx->pc = 0; goto label_174684;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174548: 0x1000004e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_174684;
    }
label_174550:
    // 0x174550: 0x14a20011
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_174598;
    }
    // 0x174558: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x17455c: 0x244401f8
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 504));
    // 0x174560: 0x8c830260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 608)));
    // 0x174564: 0x1060000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_174590;
    }
    // 0x17456c: 0x1462000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_174598;
    }
    // 0x174574: 0x8c820324
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 804)));
    // 0x174578: 0x50400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
        goto label_174598;
    }
    // 0x174580: 0x8c4302d4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 724)));
    // 0x174584: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x174588: 0x14620003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_174598;
    }
label_174590:
    // 0x174590: 0x1000003b
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 35));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_174680;
    }
label_174598:
    // 0x174598: 0x54a20010
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
        goto label_1745dc;
    }
    // 0x1745a0: 0x8e2225cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9676)));
    // 0x1745a4: 0x5440000d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
        goto label_1745dc;
    }
    // 0x1745ac: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1745b0: 0xc622222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x1745b4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1745b8: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1745bc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1745c0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1745c4: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1745c8: 0x0
    // NOP
    // 0x1745cc: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
        goto label_1745dc;
    }
    // 0x1745d4: 0x1000002a
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 34));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_174680;
    }
label_1745dc:
    // 0x1745dc: 0x24020023
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 35));
    // 0x1745e0: 0x54620028
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        goto label_174684;
    }
    // 0x1745e8: 0x8e2225d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9680)));
    // 0x1745ec: 0x54400025
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        goto label_174684;
    }
    // 0x1745f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1745f8: 0xc622222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x1745fc: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x174600: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x174604: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x174608: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17460c: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x174610: 0x0
    // NOP
    // 0x174614: 0x4502001b
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        goto label_174684;
    }
label_17461c:
    // 0x17461c: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_174620:
    // 0x174620: 0x10000017
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_174680;
    }
    // 0x174628: 0x966200a8
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 19), 168)));
    // 0x17462c: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x174630: 0x5440000d
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[0] = *(float*)&val; }
        goto label_174668;
    }
    // 0x174638: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17463c: 0xc6222224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8740)); ctx->f[2] = *(float*)&val; }
    // 0x174640: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x174644: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x174648: 0xc4412e3c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11836)); ctx->f[1] = *(float*)&val; }
    // 0x17464c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x174650: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x174654: 0x0
    // NOP
    // 0x174658: 0x45020003
    if (!(ctx->fcr31 & 0x800000)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[0] = *(float*)&val; }
        goto label_174668;
    }
    // 0x174660: 0x10000007
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 56));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_174680;
    }
label_174668:
    // 0x174668: 0x10000005
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_174680;
    }
    // 0x174670: 0x52c00004
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
        goto label_174684;
    }
    // 0x174678: 0x24120002
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
label_17467c:
    // 0x17467c: 0x24100002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
label_174680:
    // 0x174680: 0x8e222220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
label_174684:
    // 0x174684: 0x1642fe58
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x173FE8; return;
    }
    // 0x17468c: 0x8e222228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x174690: 0x1602fe56
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x173FEC; return;
    }
    // 0x174698: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17469c: 0xc071a4a
    SET_GPR_U32(ctx, 31, 0x1746a4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    UpdateJtActiveCane__FP2JTP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_1746a4
// Address: 0x1746a4 - 0x1746e4

void entry_1746a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1746a4: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x1746a8: 0x2c620011
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 17));
    // 0x1746ac: 0x10400047
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1747cc(rdram, ctx, runtime); return;
    }
    // 0x1746b4: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1746b8: 0x2442aab0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945456));
    // 0x1746bc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1746c0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1746c4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1746cc: 0x8e260a10
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 2576)));
    // 0x1746d0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1746d4: 0xc62c0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[12] = *(float*)&val; }
    // 0x1746d8: 0x26250910
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 2320));
    // 0x1746dc: 0xc0751a6
    SET_GPR_U32(ctx, 31, 0x1746e4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[13] = *(float*)&val; }
    SetJtSidestepTarget__FP2JTP4BLSSP6ASEGBLff(rdram, ctx, runtime); return;
}


// Function: entry_1746e4
// Address: 0x1746e4 - 0x174704

void entry_1746e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1746e4: 0x10000039
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1747cc(rdram, ctx, runtime); return;
    }
    // 0x1746ec: 0xc62c0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[12] = *(float*)&val; }
    // 0x1746f0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1746f4: 0xc62d0634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1588)); ctx->f[13] = *(float*)&val; }
    // 0x1746f8: 0x26250720
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1824));
    // 0x1746fc: 0xc075028
    SET_GPR_U32(ctx, 31, 0x174704);
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 2304)));
    SetStepRunTarget__FP4STEPffP5BLRUNP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_174704
// Address: 0x174704 - 0x174760

void entry_174704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174704: 0x10000031
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1747cc(rdram, ctx, runtime); return;
    }
    // 0x17470c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x174710: 0x8e272230
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
    // 0x174714: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x174718: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17471c: 0x10e0002b
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 7) == GPR_U32(ctx, 0)) {
        entry_1747cc(rdram, ctx, runtime); return;
    }
    // 0x174724: 0x8ce20008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 8)));
    // 0x174728: 0x8c42009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 156)));
    // 0x17472c: 0x10400027
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1747cc(rdram, ctx, runtime); return;
    }
    // 0x174734: 0x8c440004
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x174738: 0x10800024
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1747cc(rdram, ctx, runtime); return;
    }
    // 0x174740: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x174744: 0xc4ed0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 24)); ctx->f[13] = *(float*)&val; }
    // 0x174748: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17474c: 0x8c430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x174750: 0x27a800d0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 208));
    // 0x174754: 0xc4ec0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 20)); ctx->f[12] = *(float*)&val; }
    // 0x174758: 0x60f809
    SET_GPR_U32(ctx, 31, 0x174760);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_174760
// Address: 0x174760 - 0x174790

void entry_174760(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174760: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x174764: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x174768: 0xdba100d0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x17476c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x174770: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x174774: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x174778: 0xfba200e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17477c: 0x10000013
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1747cc(rdram, ctx, runtime); return;
    }
    // 0x174784: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x174788: 0xc073432
    SET_GPR_U32(ctx, 31, 0x174790);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtActiveHang__FP2JTP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_174790
// Address: 0x174790 - 0x1747a4

void entry_174790(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174790: 0x1000000e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1747cc(rdram, ctx, runtime); return;
    }
    // 0x174798: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17479c: 0xc0746ec
    SET_GPR_U32(ctx, 31, 0x1747a4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtActivePipe__FP2JTP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_1747a4
// Address: 0x1747a4 - 0x1747b8

void entry_1747a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1747a4: 0x10000009
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1747cc(rdram, ctx, runtime); return;
    }
    // 0x1747ac: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1747b0: 0xc05f576
    SET_GPR_U32(ctx, 31, 0x1747b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtActiveJump__FP2JTP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_1747b8
// Address: 0x1747b8 - 0x1747cc

void entry_1747b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1747b8: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1747cc(rdram, ctx, runtime); return;
    }
    // 0x1747c0: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1747c4: 0xc073ff4
    SET_GPR_U32(ctx, 31, 0x1747cc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtActiveHide__FP2JTP3JOY(rdram, ctx, runtime); return;
}


// Function: entry_1747cc
// Address: 0x1747cc - 0x1747d4

void entry_1747cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1747cc: 0xc05de64
    SET_GPR_U32(ctx, 31, 0x1747d4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtEffect__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1747d4
// Address: 0x1747d4 - 0x174808

void entry_1747d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1747d4) {
        switch (ctx->pc) {
            case 0x1747d8: ctx->pc = 0; goto label_1747d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1747d4: 0x7bbf0190
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 400)));
label_1747d8:
    // 0x1747d8: 0x7bbe0180
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x1747dc: 0x7bb70170
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x1747e0: 0x7bb60160
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x1747e4: 0x7bb50150
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x1747e8: 0x7bb40140
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x1747ec: 0x7bb30130
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x1747f0: 0x7bb20120
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1747f4: 0x7bb10110
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1747f8: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1747fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 416));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x174804: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x174808; return;
}


// Function: UpdateJt__FP2JTf
// Address: 0x174808 - 0x174838

void entry_174838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174838: 0xc05c172
    SET_GPR_U32(ctx, 31, 0x174840);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    HandleJtGrfjtsc(rdram, ctx, runtime); return;
}


// Function: entry_174840
// Address: 0x174840 - 0x174848

void entry_174840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174840: 0xc04a08c
    SET_GPR_U32(ctx, 31, 0x174848);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FDrivenAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_174848
// Address: 0x174848 - 0x174858

void entry_174848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174848: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9924)));
        ctx->pc = 0x17485C; return;
    }
    // 0x174850: 0xc05d388
    SET_GPR_U32(ctx, 31, 0x174858);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtDrive__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_174858
// Address: 0x174858 - 0x1748cc

void entry_174858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174858) {
        switch (ctx->pc) {
            case 0x17485c: ctx->pc = 0; goto label_17485c;
            case 0x174890: ctx->pc = 0; goto label_174890;
            case 0x174894: ctx->pc = 0; goto label_174894;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174858: 0x8e2226c4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9924)));
label_17485c:
    // 0x17485c: 0x1040000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_174890;
    }
    // 0x174864: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x174868: 0x1062000a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_174894;
    }
    // 0x174870: 0xc62226cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9932)); ctx->f[2] = *(float*)&val; }
    // 0x174874: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x174878: 0xc62126d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9936)); ctx->f[1] = *(float*)&val; }
    // 0x17487c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x174880: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x174884: 0x0
    // NOP
    // 0x174888: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 9924), GPR_U32(ctx, 0));
        goto label_174890;
    }
label_174890:
    // 0x174890: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
label_174894:
    // 0x174894: 0x2c62000e
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 14));
    // 0x174898: 0x104000a4
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x1748a0: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1748a4: 0x2442ab00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945536));
    // 0x1748a8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1748ac: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1748b0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1748b8: 0x8e260900
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 2304)));
    // 0x1748bc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1748c0: 0x8e272230
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
    // 0x1748c4: 0xc074f80
    SET_GPR_U32(ctx, 31, 0x1748cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 1824));
    AdjustStepRun__FP4STEPP5BLRUNP6ASEGBLP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_1748cc
// Address: 0x1748cc - 0x174900

void entry_1748cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1748cc: 0x8e232230
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
    // 0x1748d0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1748d4: 0xc4404b64
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19300)); ctx->f[0] = *(float*)&val; }
    // 0x1748d8: 0xc4610018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[1] = *(float*)&val; }
    // 0x1748dc: 0xc46c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20)); ctx->f[12] = *(float*)&val; }
    // 0x1748e0: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1748e4: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x1748e8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1748ec: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1748f0: 0xc4410034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1748f4: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x1748f8: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x174900);
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[1];
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_174900
// Address: 0x174900 - 0x174910

void entry_174900(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174900: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x174904: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x174908: 0xc0712a0
    SET_GPR_U32(ctx, 31, 0x174910);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 9280));
    UpdateStepFootfall__FP4STEPfP3SFF(rdram, ctx, runtime); return;
}


// Function: entry_174910
// Address: 0x174910 - 0x174928

void entry_174910(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174910: 0x10000086
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x174918: 0x8e260a10
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 2576)));
    // 0x17491c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x174920: 0xc0750d2
    SET_GPR_U32(ctx, 31, 0x174928);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 2320));
    AdjustJtSidestep__FP2JTP4BLSSP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_174928
// Address: 0x174928 - 0x17495c

void entry_174928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174928: 0x8e232230
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8752)));
    // 0x17492c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x174930: 0xc4404b64
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 19300)); ctx->f[0] = *(float*)&val; }
    // 0x174934: 0xc4610018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[1] = *(float*)&val; }
    // 0x174938: 0xc46c0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20)); ctx->f[12] = *(float*)&val; }
    // 0x17493c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x174940: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x174944: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x174948: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x17494c: 0xc4410034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[1] = *(float*)&val; }
    // 0x174950: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x174954: 0xc07abf8
    SET_GPR_U32(ctx, 31, 0x17495c);
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[12] = copysignf(INFINITY, ctx->f[12] * 0.0f); } else ctx->f[12] = ctx->f[12] / ctx->f[1];
    GModPositive__Fff(rdram, ctx, runtime); return;
}


// Function: entry_17495c
// Address: 0x17495c - 0x17496c

void entry_17495c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17495c: 0x46000306
    ctx->f[12] = FPU_MOV_S(ctx->f[0]);
    // 0x174960: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x174964: 0xc0712a0
    SET_GPR_U32(ctx, 31, 0x17496c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 9296));
    UpdateStepFootfall__FP4STEPfP3SFF(rdram, ctx, runtime); return;
}


// Function: entry_17496c
// Address: 0x17496c - 0x17497c

void entry_17496c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17496c: 0x1000006f
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x174974: 0xc05fc06
    SET_GPR_U32(ctx, 31, 0x17497c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtJump__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_17497c
// Address: 0x17497c - 0x17498c

void entry_17497c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17497c: 0x1000006b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x174984: 0xc05c776
    SET_GPR_U32(ctx, 31, 0x17498c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtStand__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_17498c
// Address: 0x17498c - 0x17499c

void entry_17498c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17498c: 0x10000067
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x174994: 0xc07431e
    SET_GPR_U32(ctx, 31, 0x17499c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtHide__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_17499c
// Address: 0x17499c - 0x1749c8

void entry_17499c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17499c: 0x10000063
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x1749a4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1749a8: 0x7a2424d0
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 17), 9424)));
    // 0x1749ac: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1749b0: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x1749b4: 0x78450000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1749b8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1749bc: 0x24c63918
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 14616));
    // 0x1749c0: 0xc07aa06
    SET_GPR_U32(ctx, 31, 0x1749c8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PosSmooth(rdram, ctx, runtime); return;
}


// Function: entry_1749c8
// Address: 0x1749c8 - 0x1749e0

void entry_1749c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1749c8: 0x8e2424a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9376)));
    // 0x1749cc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1749d0: 0x262624b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 9392));
    // 0x1749d4: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1749d8: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x1749e0);
    WRITE128(ADD32(GPR_U32(ctx, 17), 9424), GPR_VEC(ctx, 2));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1749e0
// Address: 0x1749e0 - 0x1749fc

void entry_1749e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1749e0: 0x8e2524a0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 9376)));
    // 0x1749e4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1749e8: 0x8e2724f0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9456)));
    // 0x1749ec: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1749f0: 0x8e2824f4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 17), 9460)));
    // 0x1749f4: 0xc05f822
    SET_GPR_U32(ctx, 31, 0x1749fc);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 17), 9408));
    FCheckJtEdgeGrab__FP2JTP2SOP6VECTOR3XPKPvT2(rdram, ctx, runtime); return;
}


// Function: entry_1749fc
// Address: 0x1749fc - 0x174a60

void entry_1749fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1749fc) {
        switch (ctx->pc) {
            case 0x174a34: ctx->pc = 0; goto label_174a34;
            case 0x174a48: ctx->pc = 0; goto label_174a48;
            case 0x174a58: ctx->pc = 0; goto label_174a58;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1749fc: 0x1040003e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174AF8; return;
    }
    // 0x174a04: 0xc62c24c4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9412)); ctx->f[12] = *(float*)&val; }
    // 0x174a08: 0xc62d24c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9408)); ctx->f[13] = *(float*)&val; }
    // 0x174a0c: 0x46006307
    ctx->f[12] = FPU_NEG_S(ctx->f[12]);
    // 0x174a10: 0x10000011
    ctx->f[13] = FPU_NEG_S(ctx->f[13]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_174a58;
    }
    // 0x174a18: 0x8e2226d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9940)));
    // 0x174a1c: 0x10400005
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_174a34;
    }
    // 0x174a24: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x174a28: 0x8c622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x174a2c: 0x10000006
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_174a48;
    }
label_174a34:
    // 0x174a34: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x174a38: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x174a3c: 0x8c652e10
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x174a40: 0xd8810040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 64)));
    // 0x174a44: 0xd8a20140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 320)));
label_174a48:
    // 0x174a48: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x174a4c: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x174a50: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x174a54: 0xc7ad0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
label_174a58:
    // 0x174a58: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x174a60);
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_174a60
// Address: 0x174a60 - 0x174a70

void entry_174a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174a60: 0x10000032
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x174a68: 0xc0752a6
    SET_GPR_U32(ctx, 31, 0x174a70);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtZap__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_174a70
// Address: 0x174a70 - 0x174b04

void entry_174a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174a70) {
        switch (ctx->pc) {
            case 0x174af0: ctx->pc = 0; goto label_174af0;
            case 0x174af8: ctx->pc = 0; goto label_174af8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174a70: 0x1000002e
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x174a78: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x174a7c: 0x8c431990
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x174a80: 0xc4600468
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 1128)); ctx->f[0] = *(float*)&val; }
    // 0x174a84: 0x10000029
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x174a8c: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x174a90: 0x24020038
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 56));
    // 0x174a94: 0x1462001d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 54));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x174B0C; return;
    }
    // 0x174a9c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x174aa0: 0xc62100f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 248)); ctx->f[1] = *(float*)&val; }
    // 0x174aa4: 0xc4403924
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14628)); ctx->f[0] = *(float*)&val; }
    // 0x174aa8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x174aac: 0x0
    // NOP
    // 0x174ab0: 0x4500001e
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x174ab8: 0xda210160
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 352)));
    // 0x174abc: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x174ac0: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x174ac4: 0xc4413928
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14632)); ctx->f[1] = *(float*)&val; }
    // 0x174ac8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x174acc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x174ad0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x174ad4: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x174ad8: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x174adc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x174ae0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x174ae4: 0x0
    // NOP
    // 0x174ae8: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_174af0;
    }
label_174af0:
    // 0x174af0: 0x1040000e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
label_174af8:
    // 0x174af8: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x174afc: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x174b04);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_174b04
// Address: 0x174b04 - 0x174b2c

void entry_174b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174b04) {
        switch (ctx->pc) {
            case 0x174b0c: ctx->pc = 0; goto label_174b0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174b04: 0x10000009
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
label_174b0c:
    // 0x174b0c: 0x14620007
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x174b14: 0x8e220690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
    // 0x174b18: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_174b2c(rdram, ctx, runtime); return;
    }
    // 0x174b20: 0x2405000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    // 0x174b24: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x174b2c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 55));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_174b2c
// Address: 0x174b2c - 0x174b34

void entry_174b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174b2c: 0xc071a24
    SET_GPR_U32(ctx, 31, 0x174b34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtCane__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_174b34
// Address: 0x174b34 - 0x174b44

void entry_174b34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174b34: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x174b38: 0x8c430160
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 352)));
    // 0x174b3c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x174b44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_174b44
// Address: 0x174b44 - 0x174b4c

void entry_174b44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174b44: 0xc0735b0
    SET_GPR_U32(ctx, 31, 0x174b4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    CheckJtUnhook__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_174b4c
// Address: 0x174b4c - 0x174b54

void entry_174b4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174b4c: 0xc0759aa
    SET_GPR_U32(ctx, 31, 0x174b54);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtWater__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_174b54
// Address: 0x174b54 - 0x174b5c

void entry_174b54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174b54: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x174b5c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_174b5c
// Address: 0x174b5c - 0x174b7c

void entry_174b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174b5c: 0x8e22223c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8764)));
    // 0x174b60: 0x5440006b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 5404)));
        ctx->pc = 0x174D10; return;
    }
    // 0x174b68: 0x8e242204
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8708)));
    // 0x174b6c: 0x10800026
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174C08; return;
    }
    // 0x174b74: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x174b7c);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_174b7c
// Address: 0x174b7c - 0x174bb8

void entry_174b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174b7c) {
        switch (ctx->pc) {
            case 0x174b88: ctx->pc = 0; goto label_174b88;
            case 0x174b94: ctx->pc = 0; goto label_174b94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174b7c: 0x263221e0
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 8672));
    // 0x174b80: 0x10000004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 8656));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_174b94;
    }
label_174b88:
    // 0x174b88: 0x26520010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 16));
    // 0x174b8c: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    // 0x174b90: 0x26730001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 1));
label_174b94:
    // 0x174b94: 0x8e2221cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8652)));
    // 0x174b98: 0x262102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 19), GPR_S32(ctx, 2)));
    // 0x174b9c: 0x1040005b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174D0C; return;
    }
    // 0x174ba4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x174ba8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x174bac: 0x27a70080
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 128));
    // 0x174bb0: 0xc0618c8
    SET_GPR_U32(ctx, 31, 0x174bb8);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 132));
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime); return;
}


// Function: entry_174bb8
// Address: 0x174bb8 - 0x174be8

void entry_174bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174bb8: 0x8e222200
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8704)));
    // 0x174bbc: 0xc6222420
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9248)); ctx->f[2] = *(float*)&val; }
    // 0x174bc0: 0xc440008c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 140)); ctx->f[0] = *(float*)&val; }
    // 0x174bc4: 0xc7a10084
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 132)); ctx->f[1] = *(float*)&val; }
    // 0x174bc8: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x174bcc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x174bd0: 0x0
    // NOP
    // 0x174bd4: 0x4500ffec
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x174B88; return;
    }
    // 0x174bdc: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x174be0: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x174be8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 51));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_174be8
// Address: 0x174be8 - 0x174c00

void entry_174be8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174be8) {
        switch (ctx->pc) {
            case 0x174bf0: ctx->pc = 0; goto label_174bf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174be8: 0x10000049
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 5404)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174D10; return;
    }
label_174bf0:
    // 0x174bf0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x174bf4: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x174bf8: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x174c00);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 23));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_174c00
// Address: 0x174c00 - 0x174c48

void entry_174c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174c00) {
        switch (ctx->pc) {
            case 0x174c08: ctx->pc = 0; goto label_174c08;
            case 0x174c30: ctx->pc = 0; goto label_174c30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174c00: 0x10000043
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 5404)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174D10; return;
    }
label_174c08:
    // 0x174c08: 0x8e222208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    // 0x174c0c: 0x1040003f
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174D0C; return;
    }
    // 0x174c14: 0x8e2221cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8652)));
    // 0x174c18: 0x18400020
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x174C9C; return;
    }
    // 0x174c20: 0x27b40040
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 64));
    // 0x174c24: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x174c28: 0x263321d0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 17), 8656));
    // 0x174c2c: 0x0
    // NOP
label_174c30:
    // 0x174c30: 0x8e222208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    // 0x174c34: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174c38: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x174c3c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x174c40: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x174c48);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_174c48
// Address: 0x174c48 - 0x174c7c

void entry_174c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174c48: 0x8e222208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    // 0x174c4c: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x174c50: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x174c54: 0x8c620030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 48)));
    // 0x174c58: 0x10400008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_174c7c(rdram, ctx, runtime); return;
    }
    // 0x174c60: 0xc62c220c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8716)); ctx->f[12] = *(float*)&val; }
    // 0x174c64: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174c68: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x174c6c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174c70: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174c74: 0x40f809
    SET_GPR_U32(ctx, 31, 0x174c7c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_174c7c
// Address: 0x174c7c - 0x174cd8

void entry_174c7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174c7c) {
        switch (ctx->pc) {
            case 0x174c9c: ctx->pc = 0; goto label_174c9c;
            case 0x174cb8: ctx->pc = 0; goto label_174cb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174c7c: 0x8e2221cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8652)));
    // 0x174c80: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x174c84: 0x26940010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 16));
    // 0x174c88: 0x26100010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    // 0x174c8c: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x174c90: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x174c94: 0x1440ffe6
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x174C30; return;
    }
label_174c9c:
    // 0x174c9c: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x174ca0: 0x243102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 3)));
    // 0x174ca4: 0x10400019
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 64));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174D0C; return;
    }
    // 0x174cac: 0x27b50050
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 80));
    // 0x174cb0: 0x27b30020
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 32));
    // 0x174cb4: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
label_174cb8:
    // 0x174cb8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x174cbc: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x174cc0: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x174cc4: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x174cc8: 0x3a0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x174ccc: 0x27a90088
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 136));
    // 0x174cd0: 0xc07b702
    SET_GPR_U32(ctx, 31, 0x174cd8);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 112));
    FindClosestPointBetweenLineSegments__FP6VECTORN40PfT0(rdram, ctx, runtime); return;
}


// Function: entry_174cd8
// Address: 0x174cd8 - 0x174d7c

void entry_174cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174cd8) {
        switch (ctx->pc) {
            case 0x174d0c: ctx->pc = 0; goto label_174d0c;
            case 0x174d10: ctx->pc = 0; goto label_174d10;
            case 0x174d28: ctx->pc = 0; goto label_174d28;
            case 0x174d40: ctx->pc = 0; goto label_174d40;
            case 0x174d70: ctx->pc = 0; goto label_174d70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174cd8: 0xc7a10088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[1] = *(float*)&val; }
    // 0x174cdc: 0xc6202420
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9248)); ctx->f[0] = *(float*)&val; }
    // 0x174ce0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x174ce4: 0x0
    // NOP
    // 0x174ce8: 0x4501ffc1
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x174BF0; return;
    }
    // 0x174cf0: 0x8e2221cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8652)));
    // 0x174cf4: 0x26b50010
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 16));
    // 0x174cf8: 0x26940010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 16));
    // 0x174cfc: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x174d00: 0x26730010
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 19), 16));
    // 0x174d04: 0x1440ffec
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x174CB8; return;
    }
label_174d0c:
    // 0x174d0c: 0x8e25151c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 5404)));
label_174d10:
    // 0x174d10: 0x10a00030
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174DD4; return;
    }
    // 0x174d18: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x174d1c: 0x24140004
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 0), 4));
    // 0x174d20: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x174d24: 0x0
    // NOP
label_174d28:
    // 0x174d28: 0x511026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), GPR_U32(ctx, 17)));
    // 0x174d2c: 0x2102b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x174d30: 0x2621023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x174d34: 0x21180
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 6));
    // 0x174d38: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x174d3c: 0x8c500004
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 4)));
label_174d40:
    // 0x174d40: 0x5200001e
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 208)));
        ctx->pc = 0x174DBC; return;
    }
    // 0x174d48: 0x8e0204e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1248)));
    // 0x174d4c: 0x5040fffc
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        goto label_174d40;
    }
    // 0x174d54: 0x52000019
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 208)));
        ctx->pc = 0x174DBC; return;
    }
    // 0x174d5c: 0x10530004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 19)) {
        goto label_174d70;
    }
    // 0x174d64: 0x54540015
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 208)));
        ctx->pc = 0x174DBC; return;
    }
    // 0x174d6c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_174d70:
    // 0x174d70: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174d74: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x174d7c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_174d7c
// Address: 0x174d7c - 0x174d9c

void entry_174d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174d7c) {
        switch (ctx->pc) {
            case 0x174d80: ctx->pc = 0; goto label_174d80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174d7c: 0x0
    // NOP
label_174d80:
    // 0x174d80: 0x12000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174DA4; return;
    }
    // 0x174d88: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x174d8c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x174d90: 0x8c62012c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 300)));
    // 0x174d94: 0x40f809
    SET_GPR_U32(ctx, 31, 0x174d9c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_174d9c
// Address: 0x174d9c - 0x174db8

void entry_174d9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174d9c) {
        switch (ctx->pc) {
            case 0x174da4: ctx->pc = 0; goto label_174da4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174d9c: 0x5040fff8
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
        ctx->pc = 0x174D80; return;
    }
label_174da4:
    // 0x174da4: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x174da8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x174dac: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x174db0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x174db8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_174db8
// Address: 0x174db8 - 0x174dd0

void entry_174db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174db8) {
        switch (ctx->pc) {
            case 0x174dbc: ctx->pc = 0; goto label_174dbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174db8: 0x8e5200d0
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 18), 208)));
label_174dbc:
    // 0x174dbc: 0x5640ffda
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        ctx->pc = 0x174D28; return;
    }
    // 0x174dc4: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x174dc8: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x174dd0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 5404)));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_174dd0
// Address: 0x174dd0 - 0x174ddc

void entry_174dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174dd0) {
        switch (ctx->pc) {
            case 0x174dd4: ctx->pc = 0; goto label_174dd4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174dd0: 0xae20151c
    WRITE32(ADD32(GPR_U32(ctx, 17), 5404), GPR_U32(ctx, 0));
label_174dd4:
    // 0x174dd4: 0xc05c9ec
    SET_GPR_U32(ctx, 31, 0x174ddc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtTool__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_174ddc
// Address: 0x174ddc - 0x174de4

void entry_174ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174ddc: 0xc05c48e
    SET_GPR_U32(ctx, 31, 0x174de4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    UpdateJtBalance__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_174de4
// Address: 0x174de4 - 0x174dec

void entry_174de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174de4: 0xc05e42e
    SET_GPR_U32(ctx, 31, 0x174dec);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001790b8(rdram, ctx, runtime); return;
}


// Function: entry_174dec
// Address: 0x174dec - 0x174df4

void entry_174dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174dec: 0xc05e01a
    SET_GPR_U32(ctx, 31, 0x174df4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_00178068(rdram, ctx, runtime); return;
}


// Function: entry_174df4
// Address: 0x174df4 - 0x174e20

void entry_174df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174df4: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x174df8: 0x7bb500e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x174dfc: 0x7bb400d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x174e00: 0x7bb300c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x174e04: 0x7bb200b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x174e08: 0x7bb100a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x174e0c: 0x7bb00090
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x174e10: 0xc7b40100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[20] = *(float*)&val; }
    // 0x174e14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x174e1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x174e20; return;
}


// Function: UpdateJtDrive__FP2JT
// Address: 0x174e20 - 0x174e64

void entry_174e64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174e64) {
        switch (ctx->pc) {
            case 0x174e6c: ctx->pc = 0; goto label_174e6c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174e64: 0x10000005
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x174E7C; return;
    }
label_174e6c:
    // 0x174e6c: 0x2405000d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    // 0x174e70: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x174e78);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 56));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_174e78
// Address: 0x174e78 - 0x174e88

void entry_174e78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174e78) {
        switch (ctx->pc) {
            case 0x174e7c: ctx->pc = 0; goto label_174e7c;
            case 0x174e80: ctx->pc = 0; goto label_174e80;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174e78: 0x8e112220
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
label_174e7c:
    // 0x174e7c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_174e80:
    // 0x174e80: 0xc071878
    SET_GPR_U32(ctx, 31, 0x174e88);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_174e88
// Address: 0x174e88 - 0x174ee8

void entry_174e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174e88) {
        switch (ctx->pc) {
            case 0x174ebc: ctx->pc = 0; goto label_174ebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174e88: 0x2623fffe
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 4294967294));
    // 0x174e8c: 0x2c62000f
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 15));
    // 0x174e90: 0x1040000a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_174ebc;
    }
    // 0x174e98: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x174e9c: 0x2442ab40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945600));
    // 0x174ea0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x174ea4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x174ea8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x174eb0: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x174eb4: 0x10000020
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_174f38(rdram, ctx, runtime); return;
    }
label_174ebc:
    // 0x174ebc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x174ec0: 0xc60d0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1592)); ctx->f[13] = *(float*)&val; }
    // 0x174ec4: 0xc44c1860
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6240)); ctx->f[12] = *(float*)&val; }
    // 0x174ec8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x174ecc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174ed0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174ed4: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x174ed8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x174edc: 0x27a90014
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 20));
    // 0x174ee0: 0xc04a166
    SET_GPR_U32(ctx, 31, 0x174ee8);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloDrive__FP3ALOP3CLQP2LMffPfN25(rdram, ctx, runtime); return;
}


// Function: entry_174ee8
// Address: 0x174ee8 - 0x174f38

void entry_174ee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x174ee8) {
        switch (ctx->pc) {
            case 0x174f00: ctx->pc = 0; goto label_174f00;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x174ee8: 0xc7a00014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[0] = *(float*)&val; }
    // 0x174eec: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x174ef0: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x174ef4: 0x0
    // NOP
    // 0x174ef8: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 0), 1));
        goto label_174f00;
    }
label_174f00:
    // 0x174f00: 0xc7a10010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[1] = *(float*)&val; }
    // 0x174f04: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x174f08: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x174f0c: 0x44031000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[2]);
    // 0x174f10: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x174f14: 0x44031000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[2]);
    // 0x174f18: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x174f1c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x174f20: 0xe6010638
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1592), *(uint32_t*)&val); }
    // 0x174f24: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x174f28: 0x7e020640
    WRITE128(ADD32(GPR_U32(ctx, 16), 1600), GPR_VEC(ctx, 2));
    // 0x174f2c: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x174f30: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x174f38);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_174f38
// Address: 0x174f38 - 0x174f50

void entry_174f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x174f38: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x174f3c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x174f40: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x174f44: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x174f4c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x174f50; return;
}


// Function: ChooseJtPhys__FP2JT
// Address: 0x174f50 - 0x175068

void entry_175068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175068) {
        switch (ctx->pc) {
            case 0x17506c: ctx->pc = 0; goto label_17506c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175068: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_17506c:
    // 0x17506c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x175074: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x175078; return;
}


// Function: EnableJtActadj__FP2JTi
// Address: 0x175078 - 0x17510c

void entry_17510c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17510c: 0x8e040618
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1560)));
    // 0x175110: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x175114: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x175118: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175120);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175120
// Address: 0x175120 - 0x175134

void entry_175120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175120: 0x8e04061c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1564)));
    // 0x175124: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x175128: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x17512c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175134);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175134
// Address: 0x175134 - 0x175148

void entry_175134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175134: 0x8e040610
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x175138: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17513c: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x175140: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175148);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175148
// Address: 0x175148 - 0x17515c

void entry_175148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175148: 0x8e040614
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1556)));
    // 0x17514c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x175150: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x175154: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17515c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17515c
// Address: 0x17515c - 0x175170

void entry_17515c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17515c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x175160: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x175164: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17516c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x175170; return;
}


// Function: SetJtJts__FP2JT3JTS4JTBS
// Address: 0x175170 - 0x175280

void entry_175280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175280: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x175284: 0x8e43223c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8764)));
    // 0x175288: 0x14600008
    WRITE32(ADD32(GPR_U32(ctx, 18), 8780), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        entry_1752ac(rdram, ctx, runtime); return;
    }
    // 0x175290: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x175294: 0x12a20005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 2)) {
        entry_1752ac(rdram, ctx, runtime); return;
    }
    // 0x17529c: 0x12a20003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 2)) {
        entry_1752ac(rdram, ctx, runtime); return;
    }
    // 0x1752a4: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1752ac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1752ac
// Address: 0x1752ac - 0x175320

void entry_1752ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1752ac) {
        switch (ctx->pc) {
            case 0x175310: ctx->pc = 0; goto label_175310;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1752ac: 0x8e422438
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9272)));
    // 0x1752b0: 0x1440001b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 13));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_175320(rdram, ctx, runtime); return;
    }
    // 0x1752b8: 0x10400015
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_175310;
    }
    // 0x1752c0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1752c4: 0x151880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 21), 2));
    // 0x1752c8: 0x2442abc0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945728));
    // 0x1752cc: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1752d0: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1752d4: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1752dc: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x1752e0: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x1752e4: 0x1040000a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_175310;
    }
    // 0x1752ec: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1752f0: 0x2442ac00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945792));
    // 0x1752f4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1752f8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1752fc: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x175304: 0x10000002
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 10016)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_175310;
    }
    // 0x17530c: 0x8e45271c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 10012)));
label_175310:
    // 0x175310: 0x10a00003
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_175320(rdram, ctx, runtime); return;
    }
    // 0x175318: 0xc0561cc
    SET_GPR_U32(ctx, 31, 0x175320);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    ExplodeExpl__FP4EXPL(rdram, ctx, runtime); return;
}


// Function: entry_175320
// Address: 0x175320 - 0x175328

void entry_175320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175320: 0xc058344
    SET_GPR_U32(ctx, 31, 0x175328);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_175328
// Address: 0x175328 - 0x175370

void entry_175328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175328) {
        switch (ctx->pc) {
            case 0x175360: ctx->pc = 0; goto label_175360;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175328: 0x30421000
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 4096));
    // 0x17532c: 0x5040015c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 10052), GPR_U32(ctx, 0));
        entry_1758a0(rdram, ctx, runtime); return;
    }
    // 0x175334: 0x1000015b
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
    // 0x17533c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x175340: 0x10000157
    WRITE32(ADD32(GPR_U32(ctx, 18), 2580), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1758a0(rdram, ctx, runtime); return;
    }
    // 0x175348: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17534c: 0x56a20004
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
        goto label_175360;
    }
    // 0x175354: 0x8e422204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
    // 0x175358: 0xae422bdc
    WRITE32(ADD32(GPR_U32(ctx, 18), 11228), GPR_U32(ctx, 2));
    // 0x17535c: 0x8e442204
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
label_175360:
    // 0x175360: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175364: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175368: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x175370);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_175370
// Address: 0x175370 - 0x175388

void entry_175370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175370: 0x2410ffff
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x175374: 0x8e442204
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
    // 0x175378: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17537c: 0x8c620070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x175380: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175388);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175388
// Address: 0x175388 - 0x17539c

void entry_175388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175388: 0x8e432204
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
    // 0x17538c: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x175390: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175394: 0xc071878
    SET_GPR_U32(ctx, 31, 0x17539c);
    WRITE32(ADD32(GPR_U32(ctx, 18), 8720), GPR_U32(ctx, 3));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_17539c
// Address: 0x17539c - 0x1753c0

void entry_17539c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17539c: 0x8e42251c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9500)));
    // 0x1753a0: 0xa0500010
    WRITE8(ADD32(GPR_U32(ctx, 2), 16), (uint8_t)GPR_U32(ctx, 16));
    // 0x1753a4: 0x8e43251c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9500)));
    // 0x1753a8: 0xa0700011
    WRITE8(ADD32(GPR_U32(ctx, 3), 17), (uint8_t)GPR_U32(ctx, 16));
    // 0x1753ac: 0x8e44061c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1564)));
    // 0x1753b0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1753b4: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x1753b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1753c0);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1753c0
// Address: 0x1753c0 - 0x1753dc

void entry_1753c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1753c0: 0x8e432520
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9504)));
    // 0x1753c4: 0xa0700011
    WRITE8(ADD32(GPR_U32(ctx, 3), 17), (uint8_t)GPR_U32(ctx, 16));
    // 0x1753c8: 0x8e4423d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9168)));
    // 0x1753cc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1753d0: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x1753d4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1753dc);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1753dc
// Address: 0x1753dc - 0x1753e8

void entry_1753dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1753dc: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1753e0: 0xc07115e
    SET_GPR_U32(ctx, 31, 0x1753e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    LimitStepHands__FP4STEPi(rdram, ctx, runtime); return;
}


// Function: entry_1753e8
// Address: 0x1753e8 - 0x1753fc

void entry_1753e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1753e8: 0x8e4522ac
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 8876)));
    // 0x1753ec: 0x10a00007
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17540C; return;
    }
    // 0x1753f4: 0xc06e954
    SET_GPR_U32(ctx, 31, 0x1753fc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    RemoveSoXa__FP2SOP2XA(rdram, ctx, runtime); return;
}


// Function: entry_1753fc
// Address: 0x1753fc - 0x175408

void entry_1753fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1753fc: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x175400: 0xc076ee4
    SET_GPR_U32(ctx, 31, 0x175408);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 8876)));
    FreeSwXaList__FP2SWP2XA(rdram, ctx, runtime); return;
}


// Function: entry_175408
// Address: 0x175408 - 0x175414

void entry_175408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175408) {
        switch (ctx->pc) {
            case 0x17540c: ctx->pc = 0; goto label_17540c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175408: 0xae4022ac
    WRITE32(ADD32(GPR_U32(ctx, 18), 8876), GPR_U32(ctx, 0));
label_17540c:
    // 0x17540c: 0xc070a7a
    SET_GPR_U32(ctx, 31, 0x175414);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 5408));
    FUN_001c29e8(rdram, ctx, runtime); return;
}


// Function: entry_175414
// Address: 0x175414 - 0x175444

void entry_175414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175414) {
        switch (ctx->pc) {
            case 0x175434: ctx->pc = 0; goto label_175434;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175414: 0x10000123
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
    // 0x17541c: 0x24100002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
    // 0x175420: 0x56b00004
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 16)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
        goto label_175434;
    }
    // 0x175428: 0x8e422208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x17542c: 0xae422bdc
    WRITE32(ADD32(GPR_U32(ctx, 18), 11228), GPR_U32(ctx, 2));
    // 0x175430: 0x8e442208
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
label_175434:
    // 0x175434: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175438: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17543c: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x175444);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_175444
// Address: 0x175444 - 0x175458

void entry_175444(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175444: 0x8e442208
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x175448: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17544c: 0x8c620070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x175450: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175458);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175458
// Address: 0x175458 - 0x175468

void entry_175458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175458: 0x8e452208
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x17545c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175460: 0xc0735f8
    SET_GPR_U32(ctx, 31, 0x175468);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UpdateJtHookOx__FP2JTP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_175468
// Address: 0x175468 - 0x175494

void entry_175468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175468) {
        switch (ctx->pc) {
            case 0x17548c: ctx->pc = 0; goto label_17548c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175468: 0x8e422208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x17546c: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x175470: 0xc640220c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8716)); ctx->f[0] = *(float*)&val; }
    // 0x175474: 0xae422214
    WRITE32(ADD32(GPR_U32(ctx, 18), 8724), GPR_U32(ctx, 2));
    // 0x175478: 0x16b00004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8728), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 16)) {
        goto label_17548c;
    }
    // 0x175480: 0x8e43101c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4124)));
    // 0x175484: 0x2402000b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 11));
    // 0x175488: 0x43280b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 2));
label_17548c:
    // 0x17548c: 0xc071878
    SET_GPR_U32(ctx, 31, 0x175494);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_175494
// Address: 0x175494 - 0x1754b0

void entry_175494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175494: 0xda410560
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 1376)));
    // 0x175498: 0x26441520
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 5408));
    // 0x17549c: 0xda420100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 256)));
    // 0x1754a0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1754a4: 0xfa412530
    WRITE128(ADD32(GPR_U32(ctx, 18), 9520), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1754a8: 0xc070a7a
    SET_GPR_U32(ctx, 31, 0x1754b0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 9528), GPR_U32(ctx, 0));
    FUN_001c29e8(rdram, ctx, runtime); return;
}


// Function: entry_1754b0
// Address: 0x1754b0 - 0x1754c8

void entry_1754b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1754b0: 0x100000fc
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
    // 0x1754b8: 0x8e4524a0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9376)));
    // 0x1754bc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1754c0: 0xc0735f8
    SET_GPR_U32(ctx, 31, 0x1754c8);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UpdateJtHookOx__FP2JTP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_1754c8
// Address: 0x1754c8 - 0x175518

void entry_1754c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1754c8) {
        switch (ctx->pc) {
            case 0x1754f0: ctx->pc = 0; goto label_1754f0;
            case 0x175508: ctx->pc = 0; goto label_175508;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1754c8: 0x100000f5
    WRITE32(ADD32(GPR_U32(ctx, 18), 9376), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1758a0(rdram, ctx, runtime); return;
    }
    // 0x1754d0: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1754d4: 0x8e442490
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9360)));
    // 0x1754d8: 0x10800005
    WRITE32(ADD32(GPR_U32(ctx, 18), 9180), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_1754f0;
    }
    // 0x1754e0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1754e4: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1754e8: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1754ec: 0x7c830300
    WRITE128(ADD32(GPR_U32(ctx, 4), 768), GPR_VEC(ctx, 3));
label_1754f0:
    // 0x1754f0: 0x8e442494
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9364)));
    // 0x1754f4: 0x10800004
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_175508;
    }
    // 0x1754fc: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x175500: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x175504: 0x7c830300
    WRITE128(ADD32(GPR_U32(ctx, 4), 768), GPR_VEC(ctx, 3));
label_175508:
    // 0x175508: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17550c: 0x26441520
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 5408));
    // 0x175510: 0xc070a7a
    SET_GPR_U32(ctx, 31, 0x175518);
    WRITE32(ADD32(GPR_U32(ctx, 18), 1408), GPR_U32(ctx, 2));
    FUN_001c29e8(rdram, ctx, runtime); return;
}


// Function: entry_175518
// Address: 0x175518 - 0x175568

void entry_175518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175518: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17551c: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x175520: 0x100000df
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9932), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_1758a0(rdram, ctx, runtime); return;
    }
    // 0x175528: 0x8e42239c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x17552c: 0x2444fffe
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967294));
    // 0x175530: 0x2c830006
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 6));
    // 0x175534: 0x1060005b
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1756A4; return;
    }
    // 0x17553c: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x175540: 0x2442ac20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945824));
    // 0x175544: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x175548: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17554c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x175554: 0x8e442230
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x175558: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8756)));
        ctx->pc = 0x175570; return;
    }
    // 0x175560: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x175568);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_175568
// Address: 0x175568 - 0x175580

void entry_175568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175568) {
        switch (ctx->pc) {
            case 0x175570: ctx->pc = 0; goto label_175570;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175568: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 18), 8752), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175584; return;
    }
label_175570:
    // 0x175570: 0x10800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175584; return;
    }
    // 0x175578: 0xc06d90e
    SET_GPR_U32(ctx, 31, 0x175580);
    RetractSma__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_175580
// Address: 0x175580 - 0x1755c4

void entry_175580(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175580) {
        switch (ctx->pc) {
            case 0x175584: ctx->pc = 0; goto label_175584;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175580: 0xae402234
    WRITE32(ADD32(GPR_U32(ctx, 18), 8756), GPR_U32(ctx, 0));
label_175584:
    // 0x175584: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x175588: 0x2404004e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 78));
    // 0x17558c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x175590: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x175594: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x175598: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17559c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1755a0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1755a4: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1755a8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1755ac: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1755b0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1755b4: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1755b8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1755bc: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1755c4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1755c4
// Address: 0x1755c4 - 0x1755d0

void entry_1755c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1755c4: 0x8e4423b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9136)));
    // 0x1755c8: 0xc05a97c
    SET_GPR_U32(ctx, 31, 0x1755d0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetHbskHbsks__FP4HBSK5HBSKS(rdram, ctx, runtime); return;
}


// Function: entry_1755d0
// Address: 0x1755d0 - 0x1755ec

void entry_1755d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1755d0: 0x10000036
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1756AC; return;
    }
    // 0x1755d8: 0x8e4423b8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9144)));
    // 0x1755dc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1755e0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1755e4: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1755ec);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1755ec
// Address: 0x1755ec - 0x175600

void entry_1755ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1755ec: 0x8e4423b8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9144)));
    // 0x1755f0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1755f4: 0x8c620070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x1755f8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175600);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175600
// Address: 0x175600 - 0x175610

void entry_175600(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175600) {
        switch (ctx->pc) {
            case 0x175604: ctx->pc = 0; goto label_175604;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175600: 0x8e4523b8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9144)));
label_175604:
    // 0x175604: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175608: 0xc0735f8
    SET_GPR_U32(ctx, 31, 0x175610);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    UpdateJtHookOx__FP2JTP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_175610
// Address: 0x175610 - 0x17562c

void entry_175610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175610: 0x10000025
    WRITE32(ADD32(GPR_U32(ctx, 18), 9136), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1756A8; return;
    }
    // 0x175618: 0x8e4423bc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9148)));
    // 0x17561c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175620: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175624: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x17562c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_17562c
// Address: 0x17562c - 0x175640

void entry_17562c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17562c: 0x8e4423bc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9148)));
    // 0x175630: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x175634: 0x8c620070
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 112)));
    // 0x175638: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175640);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175640
// Address: 0x175640 - 0x175670

void entry_175640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175640: 0x1000fff0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9148)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175604; return;
    }
    // 0x175648: 0x8e42223c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8764)));
    // 0x17564c: 0x14400017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1756AC; return;
    }
    // 0x175654: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x175658: 0x12a20013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1756A8; return;
    }
    // 0x175660: 0x12a20011
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1756A8; return;
    }
    // 0x175668: 0xc071878
    SET_GPR_U32(ctx, 31, 0x175670);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_175670
// Address: 0x175670 - 0x175688

void entry_175670(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175670: 0x1000000e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1756AC; return;
    }
    // 0x175678: 0x8e4223cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9164)));
    // 0x17567c: 0xc44c0114
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 276)); ctx->f[12] = *(float*)&val; }
    // 0x175680: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x175688);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 272)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_175688
// Address: 0x175688 - 0x175698

void entry_175688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175688: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17568c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x175690: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x175698);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_175698
// Address: 0x175698 - 0x175714

void entry_175698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175698) {
        switch (ctx->pc) {
            case 0x1756a4: ctx->pc = 0; goto label_1756a4;
            case 0x1756a8: ctx->pc = 0; goto label_1756a8;
            case 0x1756ac: ctx->pc = 0; goto label_1756ac;
            case 0x1756e8: ctx->pc = 0; goto label_1756e8;
            case 0x1756ec: ctx->pc = 0; goto label_1756ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175698: 0xe6400638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    // 0x17569c: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 18), 9164), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1756a8;
    }
label_1756a4:
    // 0x1756a4: 0xae4023b0
    WRITE32(ADD32(GPR_U32(ctx, 18), 9136), GPR_U32(ctx, 0));
label_1756a8:
    // 0x1756a8: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_1756ac:
    // 0x1756ac: 0x16a2000f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 2)) {
        goto label_1756ec;
    }
    // 0x1756b4: 0x8e4223a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9120)));
    // 0x1756b8: 0x5440000b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 11228), GPR_U32(ctx, 2));
        goto label_1756e8;
    }
    // 0x1756c0: 0x8e4223a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9128)));
    // 0x1756c4: 0x54400008
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 11228), GPR_U32(ctx, 2));
        goto label_1756e8;
    }
    // 0x1756cc: 0x8e4223b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9144)));
    // 0x1756d0: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 11228), GPR_U32(ctx, 2));
        goto label_1756e8;
    }
    // 0x1756d8: 0x8e4223bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9148)));
    // 0x1756dc: 0x50400002
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 11228), GPR_U32(ctx, 0));
        goto label_1756e8;
    }
    // 0x1756e4: 0xae422bdc
    WRITE32(ADD32(GPR_U32(ctx, 18), 11228), GPR_U32(ctx, 2));
label_1756e8:
    // 0x1756e8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_1756ec:
    // 0x1756ec: 0x8e442674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x1756f0: 0xae42239c
    WRITE32(ADD32(GPR_U32(ctx, 18), 9116), GPR_U32(ctx, 2));
    // 0x1756f4: 0xae420a14
    WRITE32(ADD32(GPR_U32(ctx, 18), 2580), GPR_U32(ctx, 2));
    // 0x1756f8: 0xae4023a0
    WRITE32(ADD32(GPR_U32(ctx, 18), 9120), GPR_U32(ctx, 0));
    // 0x1756fc: 0xae4023a8
    WRITE32(ADD32(GPR_U32(ctx, 18), 9128), GPR_U32(ctx, 0));
    // 0x175700: 0xae4023b8
    WRITE32(ADD32(GPR_U32(ctx, 18), 9144), GPR_U32(ctx, 0));
    // 0x175704: 0x10800004
    WRITE32(ADD32(GPR_U32(ctx, 18), 9148), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175718; return;
    }
    // 0x17570c: 0xc078a10
    SET_GPR_U32(ctx, 31, 0x175714);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001e2840__FP2TN3TNS(rdram, ctx, runtime); return;
}


// Function: entry_175714
// Address: 0x175714 - 0x17572c

void entry_175714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175714) {
        switch (ctx->pc) {
            case 0x175718: ctx->pc = 0; goto label_175718;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175714: 0xae402674
    WRITE32(ADD32(GPR_U32(ctx, 18), 9844), GPR_U32(ctx, 0));
label_175718:
    // 0x175718: 0x8e4426a4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9892)));
    // 0x17571c: 0x10800004
    WRITE32(ADD32(GPR_U32(ctx, 18), 9868), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175730; return;
    }
    // 0x175724: 0xc06fc12
    SET_GPR_U32(ctx, 31, 0x17572c);
    UnsetExcitement__FP3EXC(rdram, ctx, runtime); return;
}


// Function: entry_17572c
// Address: 0x17572c - 0x175750

void entry_17572c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17572c) {
        switch (ctx->pc) {
            case 0x175730: ctx->pc = 0; goto label_175730;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17572c: 0xae4026a4
    WRITE32(ADD32(GPR_U32(ctx, 18), 9892), GPR_U32(ctx, 0));
label_175730:
    // 0x175730: 0x1000000f
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 10028)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175770; return;
    }
    // 0x175738: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17573c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175740: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175744: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x175748: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x175750);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_175750
// Address: 0x175750 - 0x17575c

void entry_175750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175750: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175754: 0xc06ecec
    SET_GPR_U32(ctx, 31, 0x17575c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoNoXpsAll__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_17575c
// Address: 0x17575c - 0x175788

void entry_17575c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17575c) {
        switch (ctx->pc) {
            case 0x175770: ctx->pc = 0; goto label_175770;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17575c: 0x10000051
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
    // 0x175764: 0x8e4425e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9696)));
    // 0x175768: 0xae402200
    WRITE32(ADD32(GPR_U32(ctx, 18), 8704), GPR_U32(ctx, 0));
    // 0x17576c: 0xae402204
    WRITE32(ADD32(GPR_U32(ctx, 18), 8708), GPR_U32(ctx, 0));
label_175770:
    // 0x175770: 0x1080004c
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
    // 0x175778: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17577c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x175780: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175788);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175788
// Address: 0x175788 - 0x1757b0

void entry_175788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175788: 0x10000046
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
    // 0x175790: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x175794: 0x2405000f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    // 0x175798: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x17579c: 0x24060006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1757a0: 0x240402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1757a4: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1757a8: 0xc05147c
    SET_GPR_U32(ctx, 31, 0x1757b0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 1120));
    RevokeCmPolicy(rdram, ctx, runtime); return;
}


// Function: entry_1757b0
// Address: 0x1757b0 - 0x1757c8

void entry_1757b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1757b0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1757b4: 0x8c430454
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1108)));
    // 0x1757b8: 0x10600039
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        entry_1758a0(rdram, ctx, runtime); return;
    }
    // 0x1757c0: 0xc07a55c
    SET_GPR_U32(ctx, 31, 0x1757c8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    PopUiActiveBlot__FP2UI(rdram, ctx, runtime); return;
}


// Function: entry_1757c8
// Address: 0x1757c8 - 0x1757e8

void entry_1757c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1757c8: 0x10000036
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
    // 0x1757d0: 0xae4026d4
    WRITE32(ADD32(GPR_U32(ctx, 18), 9940), GPR_U32(ctx, 0));
    // 0x1757d4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1757d8: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1757dc: 0x8c62014c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 332)));
    // 0x1757e0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1757e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1757e8
// Address: 0x1757e8 - 0x175838

void entry_1757e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1757e8) {
        switch (ctx->pc) {
            case 0x175818: ctx->pc = 0; goto label_175818;
            case 0x17582c: ctx->pc = 0; goto label_17582c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1757e8: 0x1000002e
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
    // 0x1757f0: 0x8e43223c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8764)));
    // 0x1757f4: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1757f8: 0x10620011
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 8));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x175840; return;
    }
    // 0x175800: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_175818;
    }
    // 0x175808: 0x10620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17582c;
    }
    // 0x175810: 0x10000024
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
label_175818:
    // 0x175818: 0x2862000a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 10));
    // 0x17581c: 0x10400020
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1758a0(rdram, ctx, runtime); return;
    }
    // 0x175824: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175854; return;
    }
label_17582c:
    // 0x17582c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175830: 0xc071878
    SET_GPR_U32(ctx, 31, 0x175838);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_175838
// Address: 0x175838 - 0x17584c

void entry_175838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175838) {
        switch (ctx->pc) {
            case 0x175840: ctx->pc = 0; goto label_175840;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175838: 0x1000001a
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
label_175840:
    // 0x175840: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175844: 0xc071878
    SET_GPR_U32(ctx, 31, 0x17584c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_17584c
// Address: 0x17584c - 0x17585c

void entry_17584c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17584c) {
        switch (ctx->pc) {
            case 0x175854: ctx->pc = 0; goto label_175854;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17584c: 0x10000015
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
label_175854:
    // 0x175854: 0xc071878
    SET_GPR_U32(ctx, 31, 0x17585c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_17585c
// Address: 0x17585c - 0x1758a0

void entry_17585c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17585c: 0x10000011
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1758A4; return;
    }
    // 0x175864: 0xde420538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
    // 0x175868: 0x2403feff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967039));
    // 0x17586c: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x175870: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x175874: 0x31c38
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 16);
    // 0x175878: 0x3463ffff
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 65535));
    // 0x17587c: 0x8e44273c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 10044)));
    // 0x175880: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x175884: 0x8e4513c4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 5060)));
    // 0x175888: 0xfe420538
    WRITE64(ADD32(GPR_U32(ctx, 18), 1336), GPR_U64(ctx, 2));
    // 0x17588c: 0x10a00004
    WRITE32(ADD32(GPR_U32(ctx, 18), 968), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1758a0(rdram, ctx, runtime); return;
    }
    // 0x175894: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175898: 0xc071358
    SET_GPR_U32(ctx, 31, 0x1758a0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    SetStepPhys__FP4STEPP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1758a0
// Address: 0x1758a0 - 0x175948

void entry_1758a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1758a0) {
        switch (ctx->pc) {
            case 0x1758a4: ctx->pc = 0; goto label_1758a4;
            case 0x175914: ctx->pc = 0; goto label_175914;
            case 0x175934: ctx->pc = 0; goto label_175934;
            case 0x175938: ctx->pc = 0; goto label_175938;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1758a0: 0x2ea20011
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 21), 17));
label_1758a4:
    // 0x1758a4: 0x1040032f
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x1758ac: 0x151880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 21), 2));
    // 0x1758b0: 0x2442ac40
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945856));
    // 0x1758b4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1758b8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1758bc: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1758c4: 0x8e432220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    // 0x1758c8: 0x24040146
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 326));
    // 0x1758cc: 0xafa4007c
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 4));
    // 0x1758d0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1758d4: 0xae40118c
    WRITE32(ADD32(GPR_U32(ctx, 18), 4492), GPR_U32(ctx, 0));
    // 0x1758d8: 0x14620026
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 18), 4488)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x175974; return;
    }
    // 0x1758e0: 0x8e432250
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8784)));
    // 0x1758e4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1758e8: 0x14620013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_175938;
    }
    // 0x1758f0: 0x8e432228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    // 0x1758f4: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x1758f8: 0x3c013f73
    SET_GPR_U32(ctx, 1, ((uint32_t)16243 << 16));
    // 0x1758fc: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x175900: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x175904: 0x14620003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_175914;
    }
    // 0x17590c: 0x3c013fa0
    SET_GPR_U32(ctx, 1, ((uint32_t)16288 << 16));
    // 0x175910: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
label_175914:
    // 0x175914: 0xc6412224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8740)); ctx->f[1] = *(float*)&val; }
    // 0x175918: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17591c: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x175920: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x175924: 0x0
    // NOP
    // 0x175928: 0x45010002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_175934;
    }
    // 0x175930: 0x182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_175934:
    // 0x175934: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_175938:
    // 0x175938: 0x14620008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x17595C; return;
    }
    // 0x175940: 0xc06d8f0
    SET_GPR_U32(ctx, 31, 0x175948);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 330));
    IsmsFindSmOptional__FP2SM3OID(rdram, ctx, runtime); return;
}


// Function: entry_175948
// Address: 0x175948 - 0x175964

void entry_175948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175948) {
        switch (ctx->pc) {
            case 0x175958: ctx->pc = 0; goto label_175958;
            case 0x17595c: ctx->pc = 0; goto label_17595c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175948: 0x10400003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 330));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_175958;
    }
    // 0x175950: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175974; return;
    }
label_175958:
    // 0x175958: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
label_17595c:
    // 0x17595c: 0xc06d8f0
    SET_GPR_U32(ctx, 31, 0x175964);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 329));
    IsmsFindSmOptional__FP2SM3OID(rdram, ctx, runtime); return;
}


// Function: entry_175964
// Address: 0x175964 - 0x175a00

void entry_175964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175964) {
        switch (ctx->pc) {
            case 0x175974: ctx->pc = 0; goto label_175974;
            case 0x1759a8: ctx->pc = 0; goto label_1759a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175964: 0x8fa4007c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 124)));
    // 0x175968: 0x24030149
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 329));
    // 0x17596c: 0x62200b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 4, GPR_U32(ctx, 3));
    // 0x175970: 0xafa4007c
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 4));
label_175974:
    // 0x175974: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x175978: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17597c: 0xafa20078
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 2));
    // 0x175980: 0x100002f8
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x175988: 0x100002f6
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 2304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x175990: 0x100002f4
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 2576)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x175998: 0x8e42224c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8780)));
    // 0x17599c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1759a0: 0x50430001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 8780), GPR_U32(ctx, 0));
        goto label_1759a8;
    }
label_1759a8:
    // 0x1759a8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1759ac: 0xae432250
    WRITE32(ADD32(GPR_U32(ctx, 18), 8784), GPR_U32(ctx, 3));
    // 0x1759b0: 0xc440ab7c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294945660)); ctx->f[0] = *(float*)&val; }
    // 0x1759b4: 0xae402498
    WRITE32(ADD32(GPR_U32(ctx, 18), 9368), GPR_U32(ctx, 0));
    // 0x1759b8: 0x100002ea
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9372), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x1759c0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1759c4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1759c8: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1759cc: 0xae4222a4
    WRITE32(ADD32(GPR_U32(ctx, 18), 8868), GPR_U32(ctx, 2));
    // 0x1759d0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1759d4: 0xe6402388
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9096), *(uint32_t*)&val); }
    // 0x1759d8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1759dc: 0xe640238c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9100), *(uint32_t*)&val); }
    // 0x1759e0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1759e4: 0x8e542384
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 9092)));
    // 0x1759e8: 0x24100002
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1759ec: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1759f0: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x1759f4: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x1759f8: 0xc07115e
    SET_GPR_U32(ctx, 31, 0x175a00);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8864), *(uint32_t*)&val); }
    LimitStepHands__FP4STEPi(rdram, ctx, runtime); return;
}


// Function: entry_175a00
// Address: 0x175a00 - 0x175a28

void entry_175a00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175a00: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x175a04: 0x8e42251c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9500)));
    // 0x175a08: 0xa0500010
    WRITE8(ADD32(GPR_U32(ctx, 2), 16), (uint8_t)GPR_U32(ctx, 16));
    // 0x175a0c: 0x8e43251c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9500)));
    // 0x175a10: 0xa0700011
    WRITE8(ADD32(GPR_U32(ctx, 3), 17), (uint8_t)GPR_U32(ctx, 16));
    // 0x175a14: 0x8e44061c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 1564)));
    // 0x175a18: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x175a1c: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x175a20: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175a28);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175a28
// Address: 0x175a28 - 0x175a44

void entry_175a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175a28: 0x8e432520
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9504)));
    // 0x175a2c: 0xa0700011
    WRITE8(ADD32(GPR_U32(ctx, 3), 17), (uint8_t)GPR_U32(ctx, 16));
    // 0x175a30: 0x8e4423d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9168)));
    // 0x175a34: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x175a38: 0x8c6200bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 188)));
    // 0x175a3c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175a44);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175a44
// Address: 0x175a44 - 0x175a60

void entry_175a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175a44: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x175a48: 0x27b10040
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 64));
    // 0x175a4c: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x175a50: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x175a54: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175a58: 0xc0736dc
    SET_GPR_U32(ctx, 31, 0x175a60);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    UpdateJtIkHang__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_175a60
// Address: 0x175a60 - 0x175a84

void entry_175a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175a60: 0x8e45061c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1564)));
    // 0x175a64: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x175a68: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x175a6c: 0x26462300
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 8960));
    // 0x175a70: 0xd8a10100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 256)));
    // 0x175a74: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x175a78: 0x24a500d0
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 208));
    // 0x175a7c: 0xc062454
    SET_GPR_U32(ctx, 31, 0x175a84);
    WRITE128(ADD32(GPR_U32(ctx, 18), 8944), _mm_castps_si128(ctx->vu0_vf[1]));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_175a84
// Address: 0x175a84 - 0x175a98

void entry_175a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175a84: 0x8e4523d0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9168)));
    // 0x175a88: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x175a8c: 0x26462330
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 9008));
    // 0x175a90: 0xc062454
    SET_GPR_U32(ctx, 31, 0x175a98);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 208));
    CalculateDmat__FP7MATRIX3N20(rdram, ctx, runtime); return;
}


// Function: entry_175a98
// Address: 0x175a98 - 0x175aac

void entry_175a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175a98: 0x8e442204
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
    // 0x175a9c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175aa0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175aa4: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x175aac);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_175aac
// Address: 0x175aac - 0x175ac0

void entry_175aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175aac: 0x8e442204
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
    // 0x175ab0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x175ab4: 0x8c62006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 108)));
    // 0x175ab8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175ac0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175ac0
// Address: 0x175ac0 - 0x175acc

void entry_175ac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175ac0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175ac4: 0xc0736ca
    SET_GPR_U32(ctx, 31, 0x175acc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 112));
    GetJtHangHeading__FP2JTPf(rdram, ctx, runtime); return;
}


// Function: entry_175acc
// Address: 0x175acc - 0x175ae4

void entry_175acc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175acc: 0xc7a00070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[0] = *(float*)&val; }
    // 0x175ad0: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x175ad4: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x175ad8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x175adc: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x175ae4);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_175ae4
// Address: 0x175ae4 - 0x175b38

void entry_175ae4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175ae4) {
        switch (ctx->pc) {
            case 0x175af8: ctx->pc = 0; goto label_175af8;
            case 0x175b1c: ctx->pc = 0; goto label_175b1c;
            case 0x175b2c: ctx->pc = 0; goto label_175b2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175ae4: 0x8e422204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
    // 0x175ae8: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x175aec: 0x10400002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_175af8;
    }
    // 0x175af4: 0x8c4300a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 160)));
label_175af8:
    // 0x175af8: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x175afc: 0x10700016
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x175B58; return;
    }
    // 0x175b04: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_175b1c;
    }
    // 0x175b0c: 0x10600007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_175b2c;
    }
    // 0x175b14: 0x10000016
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175B70; return;
    }
label_175b1c:
    // 0x175b1c: 0x54620014
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
        ctx->pc = 0x175B70; return;
    }
    // 0x175b24: 0x10000010
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175B68; return;
    }
label_175b2c:
    // 0x175b2c: 0xc64c0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1584)); ctx->f[12] = *(float*)&val; }
    // 0x175b30: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x175b38);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_175b38
// Address: 0x175b38 - 0x175b88

void entry_175b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175b38) {
        switch (ctx->pc) {
            case 0x175b58: ctx->pc = 0; goto label_175b58;
            case 0x175b68: ctx->pc = 0; goto label_175b68;
            case 0x175b6c: ctx->pc = 0; goto label_175b6c;
            case 0x175b70: ctx->pc = 0; goto label_175b70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175b38: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x175b3c: 0x3c013fc9
    SET_GPR_U32(ctx, 1, ((uint32_t)16329 << 16));
    // 0x175b40: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x175b44: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x175b48: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x175b4c: 0x0
    // NOP
    // 0x175b50: 0x45020005
    if (!(ctx->fcr31 & 0x800000)) {
        { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
        goto label_175b68;
    }
label_175b58:
    // 0x175b58: 0xc7a00070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[0] = *(float*)&val; }
    // 0x175b5c: 0xae4022a8
    WRITE32(ADD32(GPR_U32(ctx, 18), 8872), GPR_U32(ctx, 0));
    // 0x175b60: 0x10000002
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_175b6c;
    }
label_175b68:
    // 0x175b68: 0xae5022a8
    WRITE32(ADD32(GPR_U32(ctx, 18), 8872), GPR_U32(ctx, 16));
label_175b6c:
    // 0x175b6c: 0x8e422204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
label_175b70:
    // 0x175b70: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x175b74: 0xfba10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x175b78: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175b7c: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x175b80: 0xc071878
    SET_GPR_U32(ctx, 31, 0x175b88);
    SET_GPR_U32(ctx, 23, READ32(ADD32(GPR_U32(ctx, 2), 168)));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_175b88
// Address: 0x175b88 - 0x175c00

void entry_175b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175b88) {
        switch (ctx->pc) {
            case 0x175ba0: ctx->pc = 0; goto label_175ba0;
            case 0x175bd8: ctx->pc = 0; goto label_175bd8;
            case 0x175bf8: ctx->pc = 0; goto label_175bf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175b88: 0x8e422204
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
    // 0x175b8c: 0x8c510018
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x175b90: 0x12200025
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175C28; return;
    }
    // 0x175b98: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x175b9c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_175ba0:
    // 0x175ba0: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x175ba4: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x175ba8: 0x5040001d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 24)));
        ctx->pc = 0x175C20; return;
    }
    // 0x175bb0: 0x8e220450
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1104)));
    // 0x175bb4: 0x50450008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1136)));
        goto label_175bd8;
    }
    // 0x175bbc: 0x8e2201ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 492)));
    // 0x175bc0: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1136)));
        goto label_175bd8;
    }
    // 0x175bc8: 0x80420010
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x175bcc: 0x1044000a
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 4)) {
        goto label_175bf8;
    }
    // 0x175bd4: 0x8e220470
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1136)));
label_175bd8:
    // 0x175bd8: 0x50450011
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 24)));
        ctx->pc = 0x175C20; return;
    }
    // 0x175be0: 0x8e2201f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 496)));
    // 0x175be4: 0x5040000e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 24)));
        ctx->pc = 0x175C20; return;
    }
    // 0x175bec: 0x80420011
    SET_GPR_S32(ctx, 2, (int8_t)READ8(ADD32(GPR_U32(ctx, 2), 17)));
    // 0x175bf0: 0x5444000b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 4)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 24)));
        ctx->pc = 0x175C20; return;
    }
label_175bf8:
    // 0x175bf8: 0xc076ed4
    SET_GPR_U32(ctx, 31, 0x175c00);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    PxaAllocSw__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_175c00
// Address: 0x175c00 - 0x175c18

void entry_175c00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175c00: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x175c04: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x175c08: 0xae120000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 18));
    // 0x175c0c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x175c10: 0xc06e94a
    SET_GPR_U32(ctx, 31, 0x175c18);
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 17));
    AddSoXa__FP2SOP2XA(rdram, ctx, runtime); return;
}


// Function: entry_175c18
// Address: 0x175c18 - 0x175c38

void entry_175c18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175c18) {
        switch (ctx->pc) {
            case 0x175c20: ctx->pc = 0; goto label_175c20;
            case 0x175c28: ctx->pc = 0; goto label_175c28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175c18: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 18), 8876), GPR_U32(ctx, 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_175c28;
    }
label_175c20:
    // 0x175c20: 0x5620ffdf
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x175BA0; return;
    }
label_175c28:
    // 0x175c28: 0x7ba20090
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x175c2c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175c30: 0xc073206
    SET_GPR_U32(ctx, 31, 0x175c38);
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), GPR_VEC(ctx, 2));
    CalculateJtHangAccel__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_175c38
// Address: 0x175c38 - 0x175c54

void entry_175c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175c38: 0x1000024a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x175c40: 0x8e442208
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x175c44: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175c48: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175c4c: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x175c54);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_175c54
// Address: 0x175c54 - 0x175c68

void entry_175c54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175c54: 0x8e442208
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x175c58: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x175c5c: 0x8c62006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 108)));
    // 0x175c60: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175c68);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175c68
// Address: 0x175c68 - 0x175c78

void entry_175c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175c68: 0x8e452208
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x175c6c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175c70: 0xc0735f8
    SET_GPR_U32(ctx, 31, 0x175c78);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    UpdateJtHookOx__FP2JTP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_175c78
// Address: 0x175c78 - 0x175ce4

void entry_175c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175c78) {
        switch (ctx->pc) {
            case 0x175ca4: ctx->pc = 0; goto label_175ca4;
            case 0x175cb0: ctx->pc = 0; goto label_175cb0;
            case 0x175cb8: ctx->pc = 0; goto label_175cb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175c78: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x175c7c: 0x8e432208
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x175c80: 0xae42241c
    WRITE32(ADD32(GPR_U32(ctx, 18), 9244), GPR_U32(ctx, 2));
    // 0x175c84: 0x8c650058
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 88)));
    // 0x175c88: 0x10a00006
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_175ca4;
    }
    // 0x175c90: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x175c94: 0x50a20006
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 8732), GPR_U32(ctx, 5));
        goto label_175cb0;
    }
    // 0x175c9c: 0x10000006
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_175cb8;
    }
label_175ca4:
    // 0x175ca4: 0xae40221c
    WRITE32(ADD32(GPR_U32(ctx, 18), 8732), GPR_U32(ctx, 0));
    // 0x175ca8: 0x10000049
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175DD0; return;
    }
label_175cb0:
    // 0x175cb0: 0x10000047
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x175DD0; return;
    }
label_175cb8:
    // 0x175cb8: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x175cbc: 0x10400013
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_175d0c(rdram, ctx, runtime); return;
    }
    // 0x175cc4: 0x3c130027
    SET_GPR_U32(ctx, 19, ((uint32_t)39 << 16));
    // 0x175cc8: 0xc6402410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9232)); ctx->f[0] = *(float*)&val; }
    // 0x175ccc: 0xc66c4f14
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 20244)); ctx->f[12] = *(float*)&val; }
    // 0x175cd0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x175cd4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x175cd8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175cdc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175ce4);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175ce4
// Address: 0x175ce4 - 0x175d0c

void entry_175ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175ce4: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x175ce8: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x175cec: 0x10400007
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 20244)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_175d0c(rdram, ctx, runtime); return;
    }
    // 0x175cf4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x175cf8: 0xc64c2410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9232)); ctx->f[12] = *(float*)&val; }
    // 0x175cfc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x175d00: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175d04: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175d0c);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175d0c
// Address: 0x175d0c - 0x175d24

void entry_175d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175d0c: 0x8e422208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x175d10: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x175d14: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x175d18: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175d1c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x175d24);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_175d24
// Address: 0x175d24 - 0x175d3c

void entry_175d24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175d24: 0x8e422208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x175d28: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175d2c: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x175d30: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x175d34: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x175d3c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_175d3c
// Address: 0x175d3c - 0x175eac

void entry_175d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175d3c) {
        switch (ctx->pc) {
            case 0x175d98: ctx->pc = 0; goto label_175d98;
            case 0x175da4: ctx->pc = 0; goto label_175da4;
            case 0x175dcc: ctx->pc = 0; goto label_175dcc;
            case 0x175dd0: ctx->pc = 0; goto label_175dd0;
            case 0x175e30: ctx->pc = 0; goto label_175e30;
            case 0x175e6c: ctx->pc = 0; goto label_175e6c;
            case 0x175e74: ctx->pc = 0; goto label_175e74;
            case 0x175e88: ctx->pc = 0; goto label_175e88;
            case 0x175e90: ctx->pc = 0; goto label_175e90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175d3c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x175d40: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x175d44: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x175d48: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x175d4c: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x175d50: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x175d54: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x175d58: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x175d5c: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x175d60: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x175d64: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x175d68: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x175d6c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x175d70: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x175d74: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x175d78: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x175d7c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x175d80: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x175d84: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x175d88: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_175d98;
    }
    // 0x175d90: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_175da4;
    }
label_175d98:
    // 0x175d98: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x175d9c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x175da0: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_175da4:
    // 0x175da4: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x175da8: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x175dac: 0xc4404f08
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20232)); ctx->f[0] = *(float*)&val; }
    // 0x175db0: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x175db4: 0xc7a10028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[1] = *(float*)&val; }
    // 0x175db8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x175dbc: 0x0
    // NOP
    // 0x175dc0: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_175dcc;
    }
    // 0x175dc8: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_175dcc:
    // 0x175dcc: 0xae42221c
    WRITE32(ADD32(GPR_U32(ctx, 18), 8732), GPR_U32(ctx, 2));
label_175dd0:
    // 0x175dd0: 0xc643220c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8716)); ctx->f[3] = *(float*)&val; }
    // 0x175dd4: 0xe6432410
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 18), 9232), *(uint32_t*)&val); }
    // 0x175dd8: 0x8e020008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x175ddc: 0x5440002c
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        goto label_175e90;
    }
    // 0x175de4: 0x8e42221c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
    // 0x175de8: 0x10400011
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_175e30;
    }
    // 0x175df0: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x175df4: 0xc4414f00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20224)); ctx->f[1] = *(float*)&val; }
    // 0x175df8: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x175dfc: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x175e00: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x175e04: 0x46010100
    ctx->f[4] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x175e08: 0xc4624f04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20228)); ctx->f[2] = *(float*)&val; }
    // 0x175e0c: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x175e10: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x175e14: 0xc440fffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[0] = *(float*)&val; }
    // 0x175e18: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x175e1c: 0x0
    // NOP
    // 0x175e20: 0x45010012
    ctx->f[1] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_175e6c;
    }
    // 0x175e28: 0x10000012
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_175e74;
    }
label_175e30:
    // 0x175e30: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x175e34: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x175e38: 0xc4414f04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20228)); ctx->f[1] = *(float*)&val; }
    // 0x175e3c: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x175e40: 0xc4800000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 0)); ctx->f[0] = *(float*)&val; }
    // 0x175e44: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x175e48: 0x46010100
    ctx->f[4] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x175e4c: 0xc4624f00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 20224)); ctx->f[2] = *(float*)&val; }
    // 0x175e50: 0x21080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 2));
    // 0x175e54: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x175e58: 0xc440fffc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294967292)); ctx->f[0] = *(float*)&val; }
    // 0x175e5c: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x175e60: 0x0
    // NOP
    // 0x175e64: 0x45000003
    ctx->f[1] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_175e74;
    }
label_175e6c:
    // 0x175e6c: 0x10000006
    ctx->f[0] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_175e88;
    }
label_175e74:
    // 0x175e74: 0x46030834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x175e78: 0x0
    // NOP
    // 0x175e7c: 0x45000002
    ctx->f[0] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_175e88;
    }
    // 0x175e84: 0x46000806
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
label_175e88:
    // 0x175e88: 0xe6402410
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9232), *(uint32_t*)&val); }
    // 0x175e8c: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_175e90:
    // 0x175e90: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x175e94: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_175eac(rdram, ctx, runtime); return;
    }
    // 0x175e9c: 0xc64c2410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9232)); ctx->f[12] = *(float*)&val; }
    // 0x175ea0: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x175ea4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x175eac);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_175eac
// Address: 0x175eac - 0x175ec4

void entry_175eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175eac: 0x8e422208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x175eb0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x175eb4: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x175eb8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175ebc: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x175ec4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_175ec4
// Address: 0x175ec4 - 0x175ed8

void entry_175ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175ec4: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x175ec8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175ecc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175ed0: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x175ed8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 9184));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_175ed8
// Address: 0x175ed8 - 0x175f0c

void entry_175ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175ed8: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x175edc: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x175ee0: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x175ee4: 0x8e422208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8712)));
    // 0x175ee8: 0xfa412400
    WRITE128(ADD32(GPR_U32(ctx, 18), 9216), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x175eec: 0xda420560
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 1376)));
    // 0x175ef0: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x175ef4: 0x8c570050
    SET_GPR_U32(ctx, 23, READ32(ADD32(GPR_U32(ctx, 2), 80)));
    // 0x175ef8: 0x1000019a
    WRITE128(ADD32(GPR_U32(ctx, 18), 9520), _mm_castps_si128(ctx->vu0_vf[2]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x175f00: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175f04: 0xc071878
    SET_GPR_U32(ctx, 31, 0x175f0c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_175f0c
// Address: 0x175f0c - 0x175f20

void entry_175f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175f0c: 0x24170059
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 89));
    // 0x175f10: 0x8e4524a0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9376)));
    // 0x175f14: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175f18: 0xc0735f8
    SET_GPR_U32(ctx, 31, 0x175f20);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    UpdateJtHookOx__FP2JTP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_175f20
// Address: 0x175f20 - 0x175f34

void entry_175f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175f20: 0x8e4424a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9376)));
    // 0x175f24: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x175f28: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x175f2c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x175f34);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 9392));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_175f34
// Address: 0x175f34 - 0x175f6c

void entry_175f34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x175f34: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x175f38: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x175f3c: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x175f40: 0xda4124c0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 9408)));
    // 0x175f44: 0x24c68d20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294937888));
    // 0x175f48: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x175f4c: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x175f50: 0x48a41000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x175f54: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x175f58: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x175f5c: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x175f60: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x175f64: 0xc07b5e0
    SET_GPR_U32(ctx, 31, 0x175f6c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    GetNormalVectors__FP6VECTORN30(rdram, ctx, runtime); return;
}


// Function: entry_175f6c
// Address: 0x175f6c - 0x176004

void entry_175f6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x175f6c) {
        switch (ctx->pc) {
            case 0x175fd8: ctx->pc = 0; goto label_175fd8;
            case 0x175ff0: ctx->pc = 0; goto label_175ff0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x175f6c: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x175f70: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x175f74: 0xdba50010
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x175f78: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x175f7c: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x175f80: 0x4be001ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x175f84: 0xda4324e0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 9440)));
    // 0x175f88: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x175f8c: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x175f90: 0x4bc320bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x175f94: 0x4bc308ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x175f98: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x175f9c: 0xda410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x175fa0: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x175fa4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x175fa8: 0xfa4124d0
    WRITE128(ADD32(GPR_U32(ctx, 18), 9424), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x175fac: 0x8e541038
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4152)));
    // 0x175fb0: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x175fb4: 0xfa460640
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x175fb8: 0x1000016a
    WRITE128(ADD32(GPR_U32(ctx, 18), 9216), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x175fc0: 0x8e442490
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9360)));
    // 0x175fc4: 0x10800004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_175fd8;
    }
    // 0x175fcc: 0x24423970
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 14704));
    // 0x175fd0: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x175fd4: 0x7c830300
    WRITE128(ADD32(GPR_U32(ctx, 4), 768), GPR_VEC(ctx, 3));
label_175fd8:
    // 0x175fd8: 0x8e442494
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9364)));
    // 0x175fdc: 0x10800004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_175ff0;
    }
    // 0x175fe4: 0x24423970
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 14704));
    // 0x175fe8: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x175fec: 0x7c830300
    WRITE128(ADD32(GPR_U32(ctx, 4), 768), GPR_VEC(ctx, 3));
label_175ff0:
    // 0x175ff0: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x175ff4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x175ff8: 0xfa410640
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x175ffc: 0xc071878
    SET_GPR_U32(ctx, 31, 0x176004);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_176004
// Address: 0x176004 - 0x176058

void entry_176004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176004: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x176008: 0xae400580
    WRITE32(ADD32(GPR_U32(ctx, 18), 1408), GPR_U32(ctx, 0));
    // 0x17600c: 0xc440ab7c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294945660)); ctx->f[0] = *(float*)&val; }
    // 0x176010: 0x10000154
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9932), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x176018: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x17601c: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x176020: 0x104000d6
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17637c(rdram, ctx, runtime); return;
    }
    // 0x176028: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17602c: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x176030: 0x2442ac90
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945936));
    // 0x176034: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x176038: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17603c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x176044: 0x8e442230
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x176048: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8756)));
        ctx->pc = 0x176060; return;
    }
    // 0x176050: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x176058);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_176058
// Address: 0x176058 - 0x176070

void entry_176058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176058) {
        switch (ctx->pc) {
            case 0x176060: ctx->pc = 0; goto label_176060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176058: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 18), 8752), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176074; return;
    }
label_176060:
    // 0x176060: 0x10800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176074; return;
    }
    // 0x176068: 0xc06d90e
    SET_GPR_U32(ctx, 31, 0x176070);
    RetractSma__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_176070
// Address: 0x176070 - 0x1760b8

void entry_176070(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176070) {
        switch (ctx->pc) {
            case 0x176074: ctx->pc = 0; goto label_176074;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176070: 0xae402234
    WRITE32(ADD32(GPR_U32(ctx, 18), 8756), GPR_U32(ctx, 0));
label_176074:
    // 0x176074: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x176078: 0x2404004d
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 77));
    // 0x17607c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x176080: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x176084: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x176088: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17608c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x176090: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x176094: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176098: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17609c: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1760a0: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1760a4: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1760a8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1760ac: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1760b0: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1760b8);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1760b8
// Address: 0x1760b8 - 0x1760c4

void entry_1760b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1760b8: 0x8e4423b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9136)));
    // 0x1760bc: 0xc05a97c
    SET_GPR_U32(ctx, 31, 0x1760c4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetHbskHbsks__FP4HBSK5HBSKS(rdram, ctx, runtime); return;
}


// Function: entry_1760c4
// Address: 0x1760c4 - 0x1760e0

void entry_1760c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1760c4: 0x100000ae
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176380; return;
    }
    // 0x1760cc: 0x8e4423b8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9144)));
    // 0x1760d0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1760d4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1760d8: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x1760e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_1760e0
// Address: 0x1760e0 - 0x1760fc

void entry_1760e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1760e0: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1760e4: 0xafa20078
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 2));
    // 0x1760e8: 0x8e4423b8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9144)));
    // 0x1760ec: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1760f0: 0x8c62006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 108)));
    // 0x1760f4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1760fc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1760fc
// Address: 0x1760fc - 0x17610c

void entry_1760fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1760fc: 0x8e4523b8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9144)));
    // 0x176100: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176104: 0xc0735f8
    SET_GPR_U32(ctx, 31, 0x17610c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    UpdateJtHookOx__FP2JTP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_17610c
// Address: 0x17610c - 0x176134

void entry_17610c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17610c: 0x1000009c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176380; return;
    }
    // 0x176114: 0x8e5023bc
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 18), 9148)));
    // 0x176118: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17611c: 0xafa30078
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 3));
    // 0x176120: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176124: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176128: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17612c: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x176134);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_176134
// Address: 0x176134 - 0x176148

void entry_176134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176134: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x176138: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17613c: 0x8c62006c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 108)));
    // 0x176140: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176148);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176148
// Address: 0x176148 - 0x176158

void entry_176148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176148: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17614c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x176150: 0xc0735f8
    SET_GPR_U32(ctx, 31, 0x176158);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    UpdateJtHookOx__FP2JTP2LOi(rdram, ctx, runtime); return;
}


// Function: entry_176158
// Address: 0x176158 - 0x176184

void entry_176158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176158: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x17615c: 0xae42241c
    WRITE32(ADD32(GPR_U32(ctx, 18), 9244), GPR_U32(ctx, 2));
    // 0x176160: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x176164: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176168: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x17616c: 0x10400005
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_176184(rdram, ctx, runtime); return;
    }
    // 0x176174: 0xc64c23c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9152)); ctx->f[12] = *(float*)&val; }
    // 0x176178: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17617c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176184);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176184
// Address: 0x176184 - 0x176198

void entry_176184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176184: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x176188: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17618c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176190: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x176198);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_176198
// Address: 0x176198 - 0x176268

void entry_176198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176198) {
        switch (ctx->pc) {
            case 0x1761f4: ctx->pc = 0; goto label_1761f4;
            case 0x176200: ctx->pc = 0; goto label_176200;
            case 0x176240: ctx->pc = 0; goto label_176240;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176198: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x17619c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1761a0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x1761a4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x1761a8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1761ac: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x1761b0: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1761b4: 0x3a0182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1761b8: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1761bc: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1761c0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1761c4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1761c8: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1761cc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1761d0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1761d4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1761d8: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1761dc: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1761e0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1761e4: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1761f4;
    }
    // 0x1761ec: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_176200;
    }
label_1761f4:
    // 0x1761f4: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x1761f8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1761fc: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_176200:
    // 0x176200: 0xf8610000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x176204: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x176208: 0xc4413990
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14736)); ctx->f[1] = *(float*)&val; }
    // 0x17620c: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x176210: 0xda420110
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 272)));
    // 0x176214: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x176218: 0x4bc2086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17621c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176220: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x176224: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x176228: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17622c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x176230: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x176234: 0x0
    // NOP
    // 0x176238: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 3, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_176240;
    }
label_176240:
    // 0x176240: 0x1000004e
    WRITE32(ADD32(GPR_U32(ctx, 18), 9160), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17637c(rdram, ctx, runtime); return;
    }
    // 0x176248: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x17624c: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x176250: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x176254: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176258: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x17625c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x176260: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176268);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176268
// Address: 0x176268 - 0x17627c

void entry_176268(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176268: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x17626c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176270: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x176274: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17627c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17627c
// Address: 0x17627c - 0x17628c

void entry_17627c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17627c: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176280: 0x8e4423cc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9164)));
    // 0x176284: 0xc064a74
    SET_GPR_U32(ctx, 31, 0x17628c);
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    SwitchToPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_17628c
// Address: 0x17628c - 0x1762b0

void entry_17628c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17628c: 0x1000003c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176380; return;
    }
    // 0x176294: 0x8e44272c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 10028)));
    // 0x176298: 0x10800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_1762b0(rdram, ctx, runtime); return;
    }
    // 0x1762a0: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1762a4: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x1762a8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1762b0);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1762b0
// Address: 0x1762b0 - 0x1762b8

void entry_1762b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1762b0: 0xc07451e
    SET_GPR_U32(ctx, 31, 0x1762b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_001d1478(rdram, ctx, runtime); return;
}


// Function: entry_1762b8
// Address: 0x1762b8 - 0x176310

void entry_1762b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1762b8) {
        switch (ctx->pc) {
            case 0x1762d0: ctx->pc = 0; goto label_1762d0;
            case 0x1762e0: ctx->pc = 0; goto label_1762e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1762b8: 0x10400005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1762d0;
    }
    // 0x1762c0: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1762c4: 0xc44e2e20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11808)); ctx->f[14] = *(float*)&val; }
    // 0x1762c8: 0x10000005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 148));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1762e0;
    }
label_1762d0:
    // 0x1762d0: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1762d4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1762d8: 0xc44e2e24
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11812)); ctx->f[14] = *(float*)&val; }
    // 0x1762dc: 0x2404007e
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 126));
label_1762e0:
    // 0x1762e0: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1762e4: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1762e8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1762ec: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1762f0: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1762f4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1762f8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1762fc: 0x26470140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 320));
    // 0x176300: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x176304: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176308: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x176310);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_176310
// Address: 0x176310 - 0x17637c

void entry_176310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176310) {
        switch (ctx->pc) {
            case 0x17633c: ctx->pc = 0; goto label_17633c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176310: 0x1000001b
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176380; return;
    }
    // 0x176318: 0x8e432220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    // 0x17631c: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x176320: 0x14620006
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_17633c;
    }
    // 0x176328: 0x8e422228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    // 0x17632c: 0x2442fff4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967284));
    // 0x176330: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x176334: 0x14400012
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x176380; return;
    }
label_17633c:
    // 0x17633c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x176340: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x176344: 0xc44e2e20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11808)); ctx->f[14] = *(float*)&val; }
    // 0x176348: 0x24040094
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 148));
    // 0x17634c: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x176350: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x176354: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x176358: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17635c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x176360: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x176364: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176368: 0x26470140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 320));
    // 0x17636c: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x176370: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176374: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x17637c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_17637c
// Address: 0x17637c - 0x176390

void entry_17637c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17637c) {
        switch (ctx->pc) {
            case 0x176380: ctx->pc = 0; goto label_176380;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17637c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
label_176380:
    // 0x176380: 0x12600078
    WRITE32(ADD32(GPR_U32(ctx, 18), 9860), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x176388: 0xc06fbbe
    SET_GPR_U32(ctx, 31, 0x176390);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4294967276));
    PexcSetExcitement__Fi(rdram, ctx, runtime); return;
}


// Function: entry_176390
// Address: 0x176390 - 0x1763dc

void entry_176390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176390) {
        switch (ctx->pc) {
            case 0x1763b4: ctx->pc = 0; goto label_1763b4;
            case 0x1763c8: ctx->pc = 0; goto label_1763c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176390: 0x10000074
    WRITE32(ADD32(GPR_U32(ctx, 18), 9892), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x176398: 0x8e4226d4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9940)));
    // 0x17639c: 0x10400005
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1763b4;
    }
    // 0x1763a4: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1763a8: 0x8c622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x1763ac: 0x10000006
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1763c8;
    }
label_1763b4:
    // 0x1763b4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1763b8: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x1763bc: 0x8c652e10
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 11792)));
    // 0x1763c0: 0xd8810040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 64)));
    // 0x1763c4: 0xd8a20140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 320)));
label_1763c8:
    // 0x1763c8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1763cc: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1763d0: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1763d4: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1763dc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1763dc
// Address: 0x1763dc - 0x1763e8

void entry_1763dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1763dc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1763e0: 0xc071756
    SET_GPR_U32(ctx, 31, 0x1763e8);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    FixStepAngularVelocity__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_1763e8
// Address: 0x1763e8 - 0x1763fc

void entry_1763e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1763e8: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1763ec: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1763f0: 0xfa410640
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1763f4: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1763fc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1763fc
// Address: 0x1763fc - 0x176410

void entry_1763fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1763fc: 0x10000059
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x176404: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176408: 0xc071878
    SET_GPR_U32(ctx, 31, 0x176410);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_176410
// Address: 0x176410 - 0x176428

void entry_176410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176410: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176414: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x176418: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17641c: 0x24070003
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 3));
    // 0x176420: 0xc06e6b8
    SET_GPR_U32(ctx, 31, 0x176428);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoConstraints__FP2SO2CTP6VECTORT1T2(rdram, ctx, runtime); return;
}


// Function: entry_176428
// Address: 0x176428 - 0x176434

void entry_176428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176428: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17642c: 0xc06ecec
    SET_GPR_U32(ctx, 31, 0x176434);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetSoNoXpsAll__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_176434
// Address: 0x176434 - 0x176450

void entry_176434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176434: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176438: 0xae400690
    WRITE32(ADD32(GPR_U32(ctx, 18), 1680), GPR_U32(ctx, 0));
    // 0x17643c: 0x10000049
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x176444: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176448: 0xc071878
    SET_GPR_U32(ctx, 31, 0x176450);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_176450
// Address: 0x176450 - 0x17645c

void entry_176450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176450: 0xae4025ec
    WRITE32(ADD32(GPR_U32(ctx, 18), 9708), GPR_U32(ctx, 0));
    // 0x176454: 0xc071b96
    SET_GPR_U32(ctx, 31, 0x17645c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ChooseJtRushTarget__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_17645c
// Address: 0x17645c - 0x1764b4

void entry_17645c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17645c: 0x10000041
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x176464: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176468: 0x1000003e
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x176470: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x176474: 0xde430538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 18), 1336)));
    // 0x176478: 0xc4402e30
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11824)); ctx->f[0] = *(float*)&val; }
    // 0x17647c: 0x34048000
    SET_GPR_U32(ctx, 4, OR32(GPR_U32(ctx, 0), 32768));
    // 0x176480: 0x42678
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 4) << 25);
    // 0x176484: 0x8e4203c8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 968)));
    // 0x176488: 0x641825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 4)));
    // 0x17648c: 0x8e4513c4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 5060)));
    // 0x176490: 0xae42273c
    WRITE32(ADD32(GPR_U32(ctx, 18), 10044), GPR_U32(ctx, 2));
    // 0x176494: 0xfe430538
    WRITE64(ADD32(GPR_U32(ctx, 18), 1336), GPR_U64(ctx, 3));
    // 0x176498: 0xe64003cc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 972), *(uint32_t*)&val); }
    // 0x17649c: 0x10a00005
    WRITE32(ADD32(GPR_U32(ctx, 18), 968), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        entry_1764b4(rdram, ctx, runtime); return;
    }
    // 0x1764a4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1764a8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1764ac: 0xc071358
    SET_GPR_U32(ctx, 31, 0x1764b4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetStepPhys__FP4STEPP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1764b4
// Address: 0x1764b4 - 0x1764d0

void entry_1764b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1764b4: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x1764b8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1764bc: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x1764c0: 0x2405ffff
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1764c4: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1764c8: 0xc071878
    SET_GPR_U32(ctx, 31, 0x1764d0);
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), GPR_VEC(ctx, 2));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_1764d0
// Address: 0x1764d0 - 0x1764f4

void entry_1764d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1764d0: 0x10000024
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x1764d8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1764dc: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1764e0: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1764e4: 0x1000001f
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176564; return;
    }
    // 0x1764ec: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x1764f4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 10064)));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_1764f4
// Address: 0x1764f4 - 0x176508

void entry_1764f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1764f4: 0x10400004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_176508(rdram, ctx, runtime); return;
    }
    // 0x1764fc: 0x8e442750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 10064)));
    // 0x176500: 0xc074cb6
    SET_GPR_U32(ctx, 31, 0x176508);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    func_001D32D8__FiP2JTl(rdram, ctx, runtime); return;
}


// Function: entry_176508
// Address: 0x176508 - 0x17651c

void entry_176508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176508: 0x8e442750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 10064)));
    // 0x17650c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176510: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x176514: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17651c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17651c
// Address: 0x17651c - 0x176530

void entry_17651c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17651c: 0x8e442750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 10064)));
    // 0x176520: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176524: 0x8c620064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
    // 0x176528: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176530);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176530
// Address: 0x176530 - 0x176544

void entry_176530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176530: 0x8e442750
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 10064)));
    // 0x176534: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176538: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x17653c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176544);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176544
// Address: 0x176544 - 0x17656c

void entry_176544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176544) {
        switch (ctx->pc) {
            case 0x176558: ctx->pc = 0; goto label_176558;
            case 0x176564: ctx->pc = 0; goto label_176564;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176544: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x176548: 0x10000003
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 10060)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_176558;
    }
    // 0x176550: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x176554: 0x8e542754
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 10068)));
label_176558:
    // 0x176558: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x17655c: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x176560: 0x7e420640
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), GPR_VEC(ctx, 2));
label_176564:
    // 0x176564: 0xc0735b0
    SET_GPR_U32(ctx, 31, 0x17656c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    CheckJtUnhook__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_17656c
// Address: 0x17656c - 0x1765bc

void entry_17656c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17656c: 0x8e422228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    // 0x176570: 0x10560443
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 4294967292));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 22)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176578: 0x2c620034
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 52));
    // 0x17657c: 0x104000a9
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_176824(rdram, ctx, runtime); return;
    }
    // 0x176584: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x176588: 0x2442acb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294945968));
    // 0x17658c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x176590: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x176594: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x17659c: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1765a0: 0x100000a0
    WRITE32(ADD32(GPR_U32(ctx, 18), 2580), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_176824(rdram, ctx, runtime); return;
    }
    // 0x1765a8: 0x8e4223b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9136)));
    // 0x1765ac: 0xae4023b0
    WRITE32(ADD32(GPR_U32(ctx, 18), 9136), GPR_U32(ctx, 0));
    // 0x1765b0: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1765b4: 0xc04e3ca
    SET_GPR_U32(ctx, 31, 0x1765bc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1765bc
// Address: 0x1765bc - 0x1765f4

void entry_1765bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1765bc) {
        switch (ctx->pc) {
            case 0x1765e4: ctx->pc = 0; goto label_1765e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1765bc: 0x1000009a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176828; return;
    }
    // 0x1765c4: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1765c8: 0x56a20006
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9136)));
        goto label_1765e4;
    }
    // 0x1765d0: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x1765d4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x1765d8: 0x50620010
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
        ctx->pc = 0x17661C; return;
    }
    // 0x1765e0: 0x8e4223b0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9136)));
label_1765e4:
    // 0x1765e4: 0xae4023b0
    WRITE32(ADD32(GPR_U32(ctx, 18), 9136), GPR_U32(ctx, 0));
    // 0x1765e8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x1765ec: 0xc04e3ca
    SET_GPR_U32(ctx, 31, 0x1765f4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 20)));
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1765f4
// Address: 0x1765f4 - 0x176634

void entry_1765f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1765f4) {
        switch (ctx->pc) {
            case 0x176614: ctx->pc = 0; goto label_176614;
            case 0x17661c: ctx->pc = 0; goto label_17661c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1765f4: 0x10000009
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17661c;
    }
    // 0x1765fc: 0x8e4223b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9140)));
    // 0x176600: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
        goto label_17661c;
    }
    // 0x176608: 0x8c420060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 96)));
    // 0x17660c: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 2), 1248), GPR_U32(ctx, 0));
        goto label_176614;
    }
label_176614:
    // 0x176614: 0xae4023b4
    WRITE32(ADD32(GPR_U32(ctx, 18), 9140), GPR_U32(ctx, 0));
    // 0x176618: 0x8e452514
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
label_17661c:
    // 0x17661c: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x176620: 0xa0a30010
    WRITE8(ADD32(GPR_U32(ctx, 5), 16), (uint8_t)GPR_U32(ctx, 3));
    // 0x176624: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x176628: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x17662c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x176634);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_176634
// Address: 0x176634 - 0x176714

void entry_176634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176634) {
        switch (ctx->pc) {
            case 0x1766fc: ctx->pc = 0; goto label_1766fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176634: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x176638: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x17663c: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x176640: 0x10000078
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_176824(rdram, ctx, runtime); return;
    }
    // 0x176648: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x17664c: 0x56a20041
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 9144), GPR_U32(ctx, 0));
        entry_176754(rdram, ctx, runtime); return;
    }
    // 0x176654: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x176658: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x17665c: 0x5062003e
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
        ctx->pc = 0x176758; return;
    }
    // 0x176664: 0x1000003b
    WRITE32(ADD32(GPR_U32(ctx, 18), 9144), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_176754(rdram, ctx, runtime); return;
    }
    // 0x17666c: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x176670: 0x56a20038
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 9148), GPR_U32(ctx, 0));
        entry_176754(rdram, ctx, runtime); return;
    }
    // 0x176678: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x17667c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x176680: 0x50620035
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
        ctx->pc = 0x176758; return;
    }
    // 0x176688: 0x10000032
    WRITE32(ADD32(GPR_U32(ctx, 18), 9148), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_176754(rdram, ctx, runtime); return;
    }
    // 0x176690: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x176694: 0x56a2002f
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 9128), GPR_U32(ctx, 0));
        entry_176754(rdram, ctx, runtime); return;
    }
    // 0x17669c: 0x8e4223a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9128)));
    // 0x1766a0: 0x8e44239c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x1766a4: 0x8c430058
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x1766a8: 0x5083002b
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
        ctx->pc = 0x176758; return;
    }
    // 0x1766b0: 0x10000028
    WRITE32(ADD32(GPR_U32(ctx, 18), 9128), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_176754(rdram, ctx, runtime); return;
    }
    // 0x1766b8: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x1766bc: 0x56a20025
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 9120), GPR_U32(ctx, 0));
        entry_176754(rdram, ctx, runtime); return;
    }
    // 0x1766c4: 0x8e4223a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9120)));
    // 0x1766c8: 0x8e44239c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x1766cc: 0x8c430040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1766d0: 0x50830021
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
        ctx->pc = 0x176758; return;
    }
    // 0x1766d8: 0x1000001e
    WRITE32(ADD32(GPR_U32(ctx, 18), 9120), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_176754(rdram, ctx, runtime); return;
    }
    // 0x1766e0: 0x8e43223c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8764)));
    // 0x1766e4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1766e8: 0x54620004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9692)));
        goto label_1766fc;
    }
    // 0x1766f0: 0xae402200
    WRITE32(ADD32(GPR_U32(ctx, 18), 8704), GPR_U32(ctx, 0));
    // 0x1766f4: 0xae402204
    WRITE32(ADD32(GPR_U32(ctx, 18), 8708), GPR_U32(ctx, 0));
    // 0x1766f8: 0x8e4425dc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9692)));
label_1766fc:
    // 0x1766fc: 0x50800006
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9700)));
        ctx->pc = 0x176718; return;
    }
    // 0x176704: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176708: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x17670c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176714);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176714
// Address: 0x176714 - 0x176730

void entry_176714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176714) {
        switch (ctx->pc) {
            case 0x176718: ctx->pc = 0; goto label_176718;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176714: 0x8e4425e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9700)));
label_176718:
    // 0x176718: 0x10800043
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176828; return;
    }
    // 0x176720: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176724: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x176728: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176730);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176730
// Address: 0x176730 - 0x176744

void entry_176730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176730: 0x1000003d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176828; return;
    }
    // 0x176738: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17673c: 0xc06ecec
    SET_GPR_U32(ctx, 31, 0x176744);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetSoNoXpsAll__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_176744
// Address: 0x176744 - 0x176754

void entry_176744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176744: 0x26442b70
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 11120));
    // 0x176748: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17674c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x176754);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_176754
// Address: 0x176754 - 0x176770

void entry_176754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176754) {
        switch (ctx->pc) {
            case 0x176758: ctx->pc = 0; goto label_176758;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176754: 0x8e452514
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
label_176758:
    // 0x176758: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x17675c: 0xa0a30010
    WRITE8(ADD32(GPR_U32(ctx, 5), 16), (uint8_t)GPR_U32(ctx, 3));
    // 0x176760: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x176764: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x176768: 0x60f809
    SET_GPR_U32(ctx, 31, 0x176770);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_176770
// Address: 0x176770 - 0x17679c

void entry_176770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176770: 0x1000002d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176828; return;
    }
    // 0x176778: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x17677c: 0x16a2002a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x176828; return;
    }
    // 0x176784: 0x8e431018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 4120)));
    // 0x176788: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17678c: 0x2405000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    // 0x176790: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176794: 0xc071878
    SET_GPR_U32(ctx, 31, 0x17679c);
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 5, GPR_U32(ctx, 2));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_17679c
// Address: 0x17679c - 0x1767bc

void entry_17679c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17679c: 0x10000022
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176828; return;
    }
    // 0x1767a4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1767a8: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x1767ac: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1767b0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1767b4: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1767bc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1767bc
// Address: 0x1767bc - 0x1767cc

void entry_1767bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1767bc: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1767c0: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x1767c4: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1767cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1767cc
// Address: 0x1767cc - 0x176800

void entry_1767cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1767cc: 0x10000016
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176828; return;
    }
    // 0x1767d4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1767d8: 0x8e442490
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9360)));
    // 0x1767dc: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1767e0: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1767e4: 0x1000000f
    WRITE128(ADD32(GPR_U32(ctx, 4), 768), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_176824(rdram, ctx, runtime); return;
    }
    // 0x1767ec: 0x8e442674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x1767f0: 0x1080000d
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176828; return;
    }
    // 0x1767f8: 0xc078a10
    SET_GPR_U32(ctx, 31, 0x176800);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001e2840__FP2TN3TNS(rdram, ctx, runtime); return;
}


// Function: entry_176800
// Address: 0x176800 - 0x176824

void entry_176800(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176800: 0x10000008
    WRITE32(ADD32(GPR_U32(ctx, 18), 9844), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_176824(rdram, ctx, runtime); return;
    }
    // 0x176808: 0x8e4425e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9704)));
    // 0x17680c: 0x10800006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 1));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176828; return;
    }
    // 0x176814: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176818: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x17681c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176824);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176824
// Address: 0x176824 - 0x1768cc

void entry_176824(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176824) {
        switch (ctx->pc) {
            case 0x176828: ctx->pc = 0; goto label_176828;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176824: 0x26c30001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 22), 1));
label_176828:
    // 0x176828: 0x2c62003c
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 60));
    // 0x17682c: 0x10400394
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176834: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x176838: 0x2442ad80
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946176));
    // 0x17683c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x176840: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x176844: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x17684c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x176850: 0xae402268
    WRITE32(ADD32(GPR_U32(ctx, 18), 8808), GPR_U32(ctx, 0));
    // 0x176854: 0xae422498
    WRITE32(ADD32(GPR_U32(ctx, 18), 9368), GPR_U32(ctx, 2));
    // 0x176858: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17685c: 0xae402270
    WRITE32(ADD32(GPR_U32(ctx, 18), 8816), GPR_U32(ctx, 0));
    // 0x176860: 0xc6410700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1792)); ctx->f[1] = *(float*)&val; }
    // 0x176864: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x176868: 0xe6402274
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8820), *(uint32_t*)&val); }
    // 0x17686c: 0xe640227c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8828), *(uint32_t*)&val); }
    // 0x176870: 0xe6402278
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8824), *(uint32_t*)&val); }
    // 0x176874: 0x46010084
    ctx->f[2] = FPU_SQRT_S(ctx->f[0]);
    // 0x176878: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17687c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x176880: 0xc4402e14
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11796)); ctx->f[0] = *(float*)&val; }
    // 0x176884: 0x2404004f
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 79));
    // 0x176888: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x17688c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x176890: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x176894: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176898: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x17689c: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1768a0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1768a4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1768a8: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1768ac: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1768b0: 0xae400690
    WRITE32(ADD32(GPR_U32(ctx, 18), 1680), GPR_U32(ctx, 0));
    // 0x1768b4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1768b8: 0xe640226c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8812), *(uint32_t*)&val); }
    // 0x1768bc: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x1768c0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1768c4: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x1768cc);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_1768cc
// Address: 0x1768cc - 0x1768d8

void entry_1768cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1768cc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1768d0: 0xc05fede
    SET_GPR_U32(ctx, 31, 0x1768d8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetJtJumpVelocity__FP2JTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1768d8
// Address: 0x1768d8 - 0x176988

void entry_1768d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1768d8) {
        switch (ctx->pc) {
            case 0x176924: ctx->pc = 0; goto label_176924;
            case 0x176948: ctx->pc = 0; goto label_176948;
            case 0x176950: ctx->pc = 0; goto label_176950;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1768d8: 0x8e43224c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8780)));
    // 0x1768dc: 0x2c620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 5));
    // 0x1768e0: 0x10400019
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_176948;
    }
    // 0x1768e8: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1768ec: 0x2442ae70
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946416));
    // 0x1768f0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1768f4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1768f8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x176900: 0x10000011
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4136)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_176948;
    }
    // 0x176908: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17690c: 0xc640226c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8812)); ctx->f[0] = *(float*)&val; }
    // 0x176910: 0x10000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11804)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_176924;
    }
    // 0x176918: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17691c: 0xc640226c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8812)); ctx->f[0] = *(float*)&val; }
    // 0x176920: 0xc4412e18
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11800)); ctx->f[1] = *(float*)&val; }
label_176924:
    // 0x176924: 0x8e541028
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4136)));
    // 0x176928: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x17692c: 0x10000006
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8812), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_176948;
    }
    // 0x176934: 0x8e43224c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8780)));
    // 0x176938: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17693c: 0x54620002
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4128)));
        goto label_176948;
    }
    // 0x176944: 0x8e541024
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4132)));
label_176948:
    // 0x176948: 0x52800001
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4128)));
        goto label_176950;
    }
label_176950:
    // 0x176950: 0x8e43224c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8780)));
    // 0x176954: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x176958: 0x1462000e
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1588)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x176994; return;
    }
    // 0x176960: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x176964: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x176968: 0x0
    // NOP
    // 0x17696c: 0x45000009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x176994; return;
    }
    // 0x176974: 0xc64c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x176978: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x17697c: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x176980: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x176988);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[14] = *(float*)&val; }
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_176988
// Address: 0x176988 - 0x1769ac

void entry_176988(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176988) {
        switch (ctx->pc) {
            case 0x176994: ctx->pc = 0; goto label_176994;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176988: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x17698c: 0x100000fd
    WRITE32(ADD32(GPR_U32(ctx, 18), 8816), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_176d84(rdram, ctx, runtime); return;
    }
label_176994:
    // 0x176994: 0xc64d226c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8812)); ctx->f[13] = *(float*)&val; }
    // 0x176998: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17699c: 0xc64c0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1584)); ctx->f[12] = *(float*)&val; }
    // 0x1769a0: 0x46016b42
    ctx->f[13] = FPU_MUL_S(ctx->f[13], ctx->f[1]);
    // 0x1769a4: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x1769ac);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[14] = *(float*)&val; }
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_1769ac
// Address: 0x1769ac - 0x176a14

void entry_1769ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1769ac) {
        switch (ctx->pc) {
            case 0x176a08: ctx->pc = 0; goto label_176a08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1769ac: 0x100000f6
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176D88; return;
    }
    // 0x1769b4: 0x8e432228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    // 0x1769b8: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1769bc: 0x10620017
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x176A1C; return;
    }
    // 0x1769c4: 0x10620016
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x176A20; return;
    }
    // 0x1769cc: 0x8e43224c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8780)));
    // 0x1769d0: 0x2c620005
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 5));
    // 0x1769d4: 0x1040000c
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_176a08;
    }
    // 0x1769dc: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x1769e0: 0x2442ae90
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946448));
    // 0x1769e4: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1769e8: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1769ec: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x1769f4: 0x10000004
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4136)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_176a08;
    }
    // 0x1769fc: 0x10000002
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_176a08;
    }
    // 0x176a04: 0x8e541024
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4132)));
label_176a08:
    // 0x176a08: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x176a0c: 0xc04b330
    SET_GPR_U32(ctx, 31, 0x176a14);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 308));
    TFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_176a14
// Address: 0x176a14 - 0x176a44

void entry_176a14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176a14) {
        switch (ctx->pc) {
            case 0x176a1c: ctx->pc = 0; goto label_176a1c;
            case 0x176a20: ctx->pc = 0; goto label_176a20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176a14: 0x1000031a
    ctx->f[22] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
label_176a1c:
    // 0x176a1c: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
label_176a20:
    // 0x176a20: 0x10000317
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176a28: 0x8e452514
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x176a2c: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x176a30: 0xa0a30010
    WRITE8(ADD32(GPR_U32(ctx, 5), 16), (uint8_t)GPR_U32(ctx, 3));
    // 0x176a34: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x176a38: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x176a3c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x176a44);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_176a44
// Address: 0x176a44 - 0x176a68

void entry_176a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176a44) {
        switch (ctx->pc) {
            case 0x176a5c: ctx->pc = 0; goto label_176a5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176a44: 0x8e442220
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    // 0x176a48: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x176a4c: 0x54820003
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4128)));
        goto label_176a5c;
    }
    // 0x176a54: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x176a58: 0xafa20080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 2));
label_176a5c:
    // 0x176a5c: 0x8e4523b0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9136)));
    // 0x176a60: 0xc04e3ca
    SET_GPR_U32(ctx, 31, 0x176a68);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 5), 20)));
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_176a68
// Address: 0x176a68 - 0x176a90

void entry_176a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176a68: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176a6c: 0x10000304
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176a74: 0x8e452514
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x176a78: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x176a7c: 0xa0a30010
    WRITE8(ADD32(GPR_U32(ctx, 5), 16), (uint8_t)GPR_U32(ctx, 3));
    // 0x176a80: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x176a84: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x176a88: 0x60f809
    SET_GPR_U32(ctx, 31, 0x176a90);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_176a90
// Address: 0x176a90 - 0x176ad4

void entry_176a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176a90) {
        switch (ctx->pc) {
            case 0x176aa4: ctx->pc = 0; goto label_176aa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176a90: 0x8e442220
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    // 0x176a94: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x176a98: 0x14820002
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_176aa4;
    }
    // 0x176aa0: 0xafa30080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 3));
label_176aa4:
    // 0x176aa4: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176aa8: 0x8e4223b4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9140)));
    // 0x176aac: 0xfa410640
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x176ab0: 0x8c430060
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 96)));
    // 0x176ab4: 0x106002f2
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4144)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176abc: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x176ac0: 0x100002ef
    WRITE32(ADD32(GPR_U32(ctx, 3), 1248), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176ac8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x176acc: 0xc05ff12
    SET_GPR_U32(ctx, 31, 0x176ad4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetJtJumpToTargetVelocity__FP2JTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_176ad4
// Address: 0x176ad4 - 0x176ae8

void entry_176ad4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176ad4: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x176ad8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x176adc: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x176ae0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176ae8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176ae8
// Address: 0x176ae8 - 0x176b04

void entry_176ae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176ae8: 0x8e452514
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x176aec: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x176af0: 0xa0a30010
    WRITE8(ADD32(GPR_U32(ctx, 5), 16), (uint8_t)GPR_U32(ctx, 3));
    // 0x176af4: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x176af8: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x176afc: 0x60f809
    SET_GPR_U32(ctx, 31, 0x176b04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_176b04
// Address: 0x176b04 - 0x176b58

void entry_176b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176b04: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x176b08: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x176b0c: 0xc44e3994
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14740)); ctx->f[14] = *(float*)&val; }
    // 0x176b10: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176b14: 0xc46f3998
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 14744)); ctx->f[15] = *(float*)&val; }
    // 0x176b18: 0x24040050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 80));
    // 0x176b1c: 0xae402498
    WRITE32(ADD32(GPR_U32(ctx, 18), 9368), GPR_U32(ctx, 0));
    // 0x176b20: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176b24: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x176b28: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x176b2c: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x176b30: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176b34: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x176b38: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x176b3c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176b40: 0x44808000
    *(uint32_t*)&ctx->f[16] = GPR_U32(ctx, 0);
    // 0x176b44: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176b48: 0xfa410640
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x176b4c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176b50: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x176b58);
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4144)));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_176b58
// Address: 0x176b58 - 0x176b84

void entry_176b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176b58: 0x100002ca
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
    // 0x176b60: 0x8e452514
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x176b64: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x176b68: 0xafa20080
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 2));
    // 0x176b6c: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x176b70: 0xa0a30010
    WRITE8(ADD32(GPR_U32(ctx, 5), 16), (uint8_t)GPR_U32(ctx, 3));
    // 0x176b74: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x176b78: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x176b7c: 0x60f809
    SET_GPR_U32(ctx, 31, 0x176b84);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_176b84
// Address: 0x176b84 - 0x176bdc

void entry_176b84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176b84: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176b88: 0x26c2fff4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 22), 4294967284));
    // 0x176b8c: 0xfa410640
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x176b90: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x176b94: 0x104002ba
    WRITE32(ADD32(GPR_U32(ctx, 18), 9368), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176b9c: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x176ba0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x176ba4: 0xc44e2e20
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11808)); ctx->f[14] = *(float*)&val; }
    // 0x176ba8: 0x24040094
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 148));
    // 0x176bac: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x176bb0: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x176bb4: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x176bb8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176bbc: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x176bc0: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x176bc4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176bc8: 0x26470140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 320));
    // 0x176bcc: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x176bd0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x176bd4: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x176bdc);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_176bdc
// Address: 0x176bdc - 0x176c34

void entry_176bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176bdc: 0x100002a9
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
    // 0x176be4: 0x8e540e2c
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 3628)));
    // 0x176be8: 0xc6400700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1792)); ctx->f[0] = *(float*)&val; }
    // 0x176bec: 0x46000044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x176bf0: 0x3c014448
    SET_GPR_U32(ctx, 1, ((uint32_t)17480 << 16));
    // 0x176bf4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x176bf8: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176bfc: 0xda4100f0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 240)));
    // 0x176c00: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x176c04: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x176c08: 0xda430150
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x176c0c: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x176c10: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x176c14: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x176c18: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x176c1c: 0x4be30868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x176c20: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x176c24: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x176c28: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x176c2c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176c34);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176c34
// Address: 0x176c34 - 0x176cc4

void entry_176c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176c34) {
        switch (ctx->pc) {
            case 0x176ca8: ctx->pc = 0; goto label_176ca8;
            case 0x176cac: ctx->pc = 0; goto label_176cac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176c34: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x176c38: 0x10000291
    WRITE32(ADD32(GPR_U32(ctx, 18), 9368), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176c40: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x176c44: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x176c48: 0xae432268
    WRITE32(ADD32(GPR_U32(ctx, 18), 8808), GPR_U32(ctx, 3));
    // 0x176c4c: 0xae422270
    WRITE32(ADD32(GPR_U32(ctx, 18), 8816), GPR_U32(ctx, 2));
    // 0x176c50: 0xae432498
    WRITE32(ADD32(GPR_U32(ctx, 18), 9368), GPR_U32(ctx, 3));
    // 0x176c54: 0xc6400700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1792)); ctx->f[0] = *(float*)&val; }
    // 0x176c58: 0x46000044
    ctx->f[1] = FPU_SQRT_S(ctx->f[0]);
    // 0x176c5c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x176c60: 0x7a420150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x176c64: 0xc4602e14
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 11796)); ctx->f[0] = *(float*)&val; }
    // 0x176c68: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176c6c: 0x7e422290
    WRITE128(ADD32(GPR_U32(ctx, 18), 8848), GPR_VEC(ctx, 2));
    // 0x176c70: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x176c74: 0xfa410640
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x176c78: 0xae400690
    WRITE32(ADD32(GPR_U32(ctx, 18), 1680), GPR_U32(ctx, 0));
    // 0x176c7c: 0x8e541020
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4128)));
    // 0x176c80: 0xe640226c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8812), *(uint32_t*)&val); }
    // 0x176c84: 0x1000027e
    WRITE32(ADD32(GPR_U32(ctx, 18), 8856), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176c8c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x176c90: 0x8e432730
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 10032)));
    // 0x176c94: 0xae422498
    WRITE32(ADD32(GPR_U32(ctx, 18), 9368), GPR_U32(ctx, 2));
    // 0x176c98: 0x10600003
    WRITE32(ADD32(GPR_U32(ctx, 18), 1680), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_176ca8;
    }
    // 0x176ca0: 0x10000002
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4424)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_176cac;
    }
label_176ca8:
    // 0x176ca8: 0x8e541020
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4128)));
label_176cac:
    // 0x176cac: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176cb0: 0x8e442b70
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 11120)));
    // 0x176cb4: 0x1080000b
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        entry_176ce4(rdram, ctx, runtime); return;
    }
    // 0x176cbc: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x176cc4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 112));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_176cc4
// Address: 0x176cc4 - 0x176cd8

void entry_176cc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176cc4: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
        ctx->pc = 0x176CE8; return;
    }
    // 0x176ccc: 0xc64c0154
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 340)); ctx->f[12] = *(float*)&val; }
    // 0x176cd0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x176cd8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 336)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_176cd8
// Address: 0x176cd8 - 0x176ce4

void entry_176cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176cd8: 0xe6400638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    // 0x176cdc: 0xc071756
    SET_GPR_U32(ctx, 31, 0x176ce4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FixStepAngularVelocity__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_176ce4
// Address: 0x176ce4 - 0x176d00

void entry_176ce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176ce4) {
        switch (ctx->pc) {
            case 0x176ce8: ctx->pc = 0; goto label_176ce8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176ce4: 0x8e452514
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
label_176ce8:
    // 0x176ce8: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x176cec: 0xa0a30010
    WRITE8(ADD32(GPR_U32(ctx, 5), 16), (uint8_t)GPR_U32(ctx, 3));
    // 0x176cf0: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x176cf4: 0x8c4300bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 188)));
    // 0x176cf8: 0x60f809
    SET_GPR_U32(ctx, 31, 0x176d00);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_176d00
// Address: 0x176d00 - 0x176d0c

void entry_176d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176d00: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176d04: 0xc06ecec
    SET_GPR_U32(ctx, 31, 0x176d0c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetSoNoXpsAll__FP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_176d0c
// Address: 0x176d0c - 0x176d38

void entry_176d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176d0c: 0x1000025c
    WRITE32(ADD32(GPR_U32(ctx, 18), 1680), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176d14: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x176d18: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176d1c: 0xae4025ec
    WRITE32(ADD32(GPR_U32(ctx, 18), 9708), GPR_U32(ctx, 0));
    // 0x176d20: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176d24: 0xae422268
    WRITE32(ADD32(GPR_U32(ctx, 18), 8808), GPR_U32(ctx, 2));
    // 0x176d28: 0x2417000a
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 10));
    // 0x176d2c: 0xfa410640
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x176d30: 0xc071bb4
    SET_GPR_U32(ctx, 31, 0x176d38);
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 9664)));
    ChooseJtSmashTarget__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_176d38
// Address: 0x176d38 - 0x176d84

void entry_176d38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176d38: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x176d3c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x176d40: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x176d44: 0xc461399c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 14748)); ctx->f[1] = *(float*)&val; }
    // 0x176d48: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x176d4c: 0x1000024c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 9252), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176d54: 0x4be0006c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x176d58: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x176d5c: 0xfa410640
    WRITE128(ADD32(GPR_U32(ctx, 18), 1600), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x176d60: 0xae422268
    WRITE32(ADD32(GPR_U32(ctx, 18), 8808), GPR_U32(ctx, 2));
    // 0x176d64: 0xae4025ec
    WRITE32(ADD32(GPR_U32(ctx, 18), 9708), GPR_U32(ctx, 0));
    // 0x176d68: 0x10000245
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 9672)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176d70: 0xae402498
    WRITE32(ADD32(GPR_U32(ctx, 18), 9368), GPR_U32(ctx, 0));
    // 0x176d74: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176d78: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x176d7c: 0xc05ff32
    SET_GPR_U32(ctx, 31, 0x176d84);
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4148)));
    GetJtJumpBoostVelocity__FP2JTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_176d84
// Address: 0x176d84 - 0x176d98

void entry_176d84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176d84) {
        switch (ctx->pc) {
            case 0x176d88: ctx->pc = 0; goto label_176d88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176d84: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_176d88:
    // 0x176d88: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176d8c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x176d90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176d98);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176d98
// Address: 0x176d98 - 0x176ec0

void entry_176d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176d98) {
        switch (ctx->pc) {
            case 0x176e20: ctx->pc = 0; goto label_176e20;
            case 0x176e28: ctx->pc = 0; goto label_176e28;
            case 0x176e6c: ctx->pc = 0; goto label_176e6c;
            case 0x176e7c: ctx->pc = 0; goto label_176e7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176d98: 0x1000023a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
    // 0x176da0: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x176da4: 0x2c620008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 8));
    // 0x176da8: 0x10400235
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176db0: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x176db4: 0x2442aeb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946480));
    // 0x176db8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x176dbc: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x176dc0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x176dc8: 0x1000022d
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 2852)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176dd0: 0x1000022b
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 3620)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176dd8: 0x10000229
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 3124)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176de0: 0x8e5e1188
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 18), 4488)));
    // 0x176de4: 0x2404014c
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 332));
    // 0x176de8: 0x10000225
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176df0: 0x8e4223bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9148)));
    // 0x176df4: 0x8c430040
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x176df8: 0x50600009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 18), 4488)));
        goto label_176e20;
    }
    // 0x176e00: 0x8e421090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4240)));
    // 0x176e04: 0x50400006
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 18), 4488)));
        goto label_176e20;
    }
    // 0x176e0c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x176e10: 0x40a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x176e14: 0xe6401094
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 4244), *(uint32_t*)&val); }
    // 0x176e18: 0x10000003
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 4248), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_176e28;
    }
label_176e20:
    // 0x176e20: 0x2402014d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 333));
    // 0x176e24: 0xafa2007c
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 2));
label_176e28:
    // 0x176e28: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x176e2c: 0x10000214
    WRITE32(ADD32(GPR_U32(ctx, 29), 120), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176e34: 0x10000212
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4116)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176e3c: 0x10000210
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176e44: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x176e48: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x176e4c: 0x10700067
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 16)) {
        ctx->pc = 0x176FEC; return;
    }
    // 0x176e54: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_176e6c;
    }
    // 0x176e5c: 0x50600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
        goto label_176e7c;
    }
    // 0x176e64: 0x10000207
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
label_176e6c:
    // 0x176e6c: 0x50620204
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 2576)));
        ctx->pc = 0x177680; return;
    }
    // 0x176e74: 0x10000203
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
label_176e7c:
    // 0x176e7c: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x176e80: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x176e84: 0x144001fe
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 2848)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176e8c: 0x8e4323a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9120)));
    // 0x176e90: 0x50600016
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9128)));
        ctx->pc = 0x176EEC; return;
    }
    // 0x176e98: 0x8c62004c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 76)));
    // 0x176e9c: 0x50400031
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 9844), GPR_U32(ctx, 0));
        ctx->pc = 0x176F64; return;
    }
    // 0x176ea4: 0x8c620048
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 72)));
    // 0x176ea8: 0x5440002e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 9844), GPR_U32(ctx, 2));
        ctx->pc = 0x176F64; return;
    }
    // 0x176eb0: 0x8e422678
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9848)));
    // 0x176eb4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176eb8: 0xc074498
    SET_GPR_U32(ctx, 31, 0x176ec0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 9844), GPR_U32(ctx, 2));
    ResetJtDynamicTunnel__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_176ec0
// Address: 0x176ec0 - 0x176ed8

void entry_176ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176ec0: 0x8e442674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x176ec4: 0x8e4323a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9120)));
    // 0x176ec8: 0x8c860000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176ecc: 0x8cc20064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 100)));
    // 0x176ed0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176ed8);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176ed8
// Address: 0x176ed8 - 0x176f24

void entry_176ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176ed8) {
        switch (ctx->pc) {
            case 0x176eec: ctx->pc = 0; goto label_176eec;
            case 0x176f08: ctx->pc = 0; goto label_176f08;
            case 0x176f18: ctx->pc = 0; goto label_176f18;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176ed8: 0x8e4323a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9120)));
    // 0x176edc: 0x8e442674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x176ee0: 0x8c620034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x176ee4: 0x1000001f
    WRITE32(ADD32(GPR_U32(ctx, 4), 740), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176F64; return;
    }
label_176eec:
    // 0x176eec: 0x5060001e
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
        ctx->pc = 0x176F68; return;
    }
    // 0x176ef4: 0x8c620068
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 104)));
    // 0x176ef8: 0x54400003
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 100)));
        goto label_176f08;
    }
    // 0x176f00: 0x10000018
    WRITE32(ADD32(GPR_U32(ctx, 18), 9844), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176F64; return;
    }
label_176f08:
    // 0x176f08: 0x50400003
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9848)));
        goto label_176f18;
    }
    // 0x176f10: 0x10000014
    WRITE32(ADD32(GPR_U32(ctx, 18), 9844), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x176F64; return;
    }
label_176f18:
    // 0x176f18: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x176f1c: 0xc074498
    SET_GPR_U32(ctx, 31, 0x176f24);
    WRITE32(ADD32(GPR_U32(ctx, 18), 9844), GPR_U32(ctx, 2));
    ResetJtDynamicTunnel__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_176f24
// Address: 0x176f24 - 0x176f3c

void entry_176f24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176f24: 0x8e442674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x176f28: 0x8e4323a8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9128)));
    // 0x176f2c: 0x8c860000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176f30: 0x8cc20064
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 100)));
    // 0x176f34: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176f3c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176f3c
// Address: 0x176f3c - 0x176f8c

void entry_176f3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176f3c) {
        switch (ctx->pc) {
            case 0x176f64: ctx->pc = 0; goto label_176f64;
            case 0x176f68: ctx->pc = 0; goto label_176f68;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176f3c: 0x8e432674
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x176f40: 0xac70038c
    WRITE32(ADD32(GPR_U32(ctx, 3), 908), GPR_U32(ctx, 16));
    // 0x176f44: 0x8e4423a8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9128)));
    // 0x176f48: 0x8e432674
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x176f4c: 0x78820040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 64)));
    // 0x176f50: 0x7c620400
    WRITE128(ADD32(GPR_U32(ctx, 3), 1024), GPR_VEC(ctx, 2));
    // 0x176f54: 0x8e4423a8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9128)));
    // 0x176f58: 0x8e422674
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x176f5c: 0xc480005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 92)); ctx->f[0] = *(float*)&val; }
    // 0x176f60: 0xe4400410
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 1040), *(uint32_t*)&val); }
label_176f64:
    // 0x176f64: 0x8e442674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
label_176f68:
    // 0x176f68: 0x8e422678
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9848)));
    // 0x176f6c: 0x54820018
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
        ctx->pc = 0x176FD0; return;
    }
    // 0x176f74: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176f78: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x176f7c: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x176f80: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x176f84: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176f8c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176f8c
// Address: 0x176f8c - 0x176fa4

void entry_176f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176f8c: 0x8e442674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x176f90: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x176f94: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176f98: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x176f9c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176fa4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294935504));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176fa4
// Address: 0x176fa4 - 0x176fb8

void entry_176fa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176fa4: 0x8e442674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x176fa8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176fac: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x176fb0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176fb8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176fb8
// Address: 0x176fb8 - 0x176fcc

void entry_176fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x176fb8: 0x8e442674
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    // 0x176fbc: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x176fc0: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x176fc4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x176fcc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_176fcc
// Address: 0x176fcc - 0x176fe4

void entry_176fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176fcc) {
        switch (ctx->pc) {
            case 0x176fd0: ctx->pc = 0; goto label_176fd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176fcc: 0x8e422674
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
label_176fd0:
    // 0x176fd0: 0x104001ab
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176fd8: 0xac5202d0
    WRITE32(ADD32(GPR_U32(ctx, 2), 720), GPR_U32(ctx, 18));
    // 0x176fdc: 0xc078a10
    SET_GPR_U32(ctx, 31, 0x176fe4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9844)));
    FUN_001e2840__FP2TN3TNS(rdram, ctx, runtime); return;
}


// Function: entry_176fe4
// Address: 0x176fe4 - 0x177114

void entry_176fe4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x176fe4) {
        switch (ctx->pc) {
            case 0x176fec: ctx->pc = 0; goto label_176fec;
            case 0x177024: ctx->pc = 0; goto label_177024;
            case 0x177038: ctx->pc = 0; goto label_177038;
            case 0x17705c: ctx->pc = 0; goto label_17705c;
            case 0x177080: ctx->pc = 0; goto label_177080;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x176fe4: 0x100001a7
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
label_176fec:
    // 0x176fec: 0x3c013fe0
    SET_GPR_U32(ctx, 1, ((uint32_t)16352 << 16));
    // 0x176ff0: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x176ff4: 0x100001a2
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 3120)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x176ffc: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x177000: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x177004: 0x1062000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_177038;
    }
    // 0x17700c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_177024;
    }
    // 0x177014: 0x5062019a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 3616)));
        ctx->pc = 0x177680; return;
    }
    // 0x17701c: 0x10000199
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
label_177024:
    // 0x177024: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x177028: 0x50620195
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4112)));
        ctx->pc = 0x177680; return;
    }
    // 0x177030: 0x10000194
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
label_177038:
    // 0x177038: 0x10000191
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 2304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x177040: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x177044: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_17705c;
    }
    // 0x17704c: 0x5062018c
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 3132)));
        ctx->pc = 0x177680; return;
    }
    // 0x177054: 0x1000018b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
label_17705c:
    // 0x17705c: 0x10000188
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 2860)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x177064: 0x8e43239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9116)));
    // 0x177068: 0x10600005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_177080;
    }
    // 0x177070: 0x50620183
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 3128)));
        ctx->pc = 0x177680; return;
    }
    // 0x177078: 0x10000182
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
label_177080:
    // 0x177080: 0x1000017f
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 2856)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x177088: 0x8e541060
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4192)));
    // 0x17708c: 0x5680017c
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 9240), GPR_U32(ctx, 0));
        ctx->pc = 0x177680; return;
    }
    // 0x177094: 0x8e541068
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4200)));
    // 0x177098: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x17709c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1770a0: 0xc6810034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 52)); ctx->f[1] = *(float*)&val; }
    // 0x1770a4: 0x46000546
    ctx->f[21] = FPU_MOV_S(ctx->f[0]);
    // 0x1770a8: 0x46000d82
    ctx->f[22] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x1770ac: 0x10000174
    WRITE32(ADD32(GPR_U32(ctx, 18), 9240), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x1770b4: 0x10000172
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4196)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x1770bc: 0x10000170
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4188)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x1770c4: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x1770c8: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x1770cc: 0x1000016c
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4188)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x1770d4: 0x8e42221c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8732)));
    // 0x1770d8: 0x8e541068
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 4200)));
    // 0x1770dc: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x1770e0: 0x10000167
    WRITE32(ADD32(GPR_U32(ctx, 18), 8732), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x1770e8: 0x161080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
    // 0x1770ec: 0x2403001c
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 28));
    // 0x1770f0: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x1770f4: 0x16c30007
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 2), 4252)));
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 3)) {
        entry_177114(rdram, ctx, runtime); return;
    }
    // 0x1770fc: 0x8e42267c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9852)));
    // 0x177100: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_177114(rdram, ctx, runtime); return;
    }
    // 0x177108: 0xae422674
    WRITE32(ADD32(GPR_U32(ctx, 18), 9844), GPR_U32(ctx, 2));
    // 0x17710c: 0xc078a10
    SET_GPR_U32(ctx, 31, 0x177114);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FUN_001e2840__FP2TN3TNS(rdram, ctx, runtime); return;
}


// Function: entry_177114
// Address: 0x177114 - 0x177130

void entry_177114(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177114: 0x2402001e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 30));
    // 0x177118: 0x16c20005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 2)) {
        entry_177130(rdram, ctx, runtime); return;
    }
    // 0x177120: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x177124: 0x8c62014c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 332)));
    // 0x177128: 0x40f809
    SET_GPR_U32(ctx, 31, 0x177130);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_177130
// Address: 0x177130 - 0x177138

void entry_177130(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177130: 0xc0776b4
    SET_GPR_U32(ctx, 31, 0x177138);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    CancelSwDialogPlaying__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_177138
// Address: 0x177138 - 0x177178

void entry_177138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177138: 0x10000152
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
    // 0x177140: 0x8e5425b8
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 9656)));
    // 0x177144: 0x1000014e
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 14));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x17714c: 0x1000014c
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 9660)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x177154: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x177158: 0x8e4325cc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9676)));
    // 0x17715c: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x177160: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x177164: 0x63a00b
    if (GPR_U32(ctx, 3) != 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 3));
    // 0x177168: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17716c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177170: 0xc051422
    SET_GPR_U32(ctx, 31, 0x177178);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 4), 1120));
    SetCmPolicy(rdram, ctx, runtime); return;
}


// Function: entry_177178
// Address: 0x177178 - 0x1771a0

void entry_177178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177178: 0x10000142
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
    // 0x177180: 0x3c013f19
    SET_GPR_U32(ctx, 1, ((uint32_t)16153 << 16));
    // 0x177184: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x177188: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x17718c: 0x24040005
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    // 0x177190: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177194: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x177198: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1771a0);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1771a0
// Address: 0x1771a0 - 0x1771b0

void entry_1771a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1771a0: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1771a4: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x1771a8: 0xc0701a8
    SET_GPR_U32(ctx, 31, 0x1771b0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    SetMvgkRvol__Fi4MVGKf(rdram, ctx, runtime); return;
}


// Function: entry_1771b0
// Address: 0x1771b0 - 0x1771bc

void entry_1771b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1771b0: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1771b4: 0xc052542
    SET_GPR_U32(ctx, 31, 0x1771bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1120));
    plays_binoc_sfx(rdram, ctx, runtime); return;
}


// Function: entry_1771bc
// Address: 0x1771bc - 0x1771c8

void entry_1771bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1771bc: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1771c0: 0xc051570
    SET_GPR_U32(ctx, 31, 0x1771c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetCmCut__FP2CMPf(rdram, ctx, runtime); return;
}


// Function: entry_1771c8
// Address: 0x1771c8 - 0x1771e8

void entry_1771c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1771c8: 0x8e422bd0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 11216)));
    // 0x1771cc: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x1771d0: 0x24a501f8
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 504));
    // 0x1771d4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x1771d8: 0xaca20324
    WRITE32(ADD32(GPR_U32(ctx, 5), 804), GPR_U32(ctx, 2));
    // 0x1771dc: 0x24845bc0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 23488));
    // 0x1771e0: 0xc07a526
    SET_GPR_U32(ctx, 31, 0x1771e8);
    WRITE32(ADD32(GPR_U32(ctx, 18), 11216), GPR_U32(ctx, 0));
    PushUiActiveBlot__FP2UIP4BLOT(rdram, ctx, runtime); return;
}


// Function: entry_1771e8
// Address: 0x1771e8 - 0x177218

void entry_1771e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1771e8: 0x10000126
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
    // 0x1771f0: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x1771f4: 0x8e4225d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9680)));
    // 0x1771f8: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x1771fc: 0x2405000f
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 15));
    // 0x177200: 0x42a00b
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 20, GPR_U32(ctx, 2));
    // 0x177204: 0x24060006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 6));
    // 0x177208: 0x24870460
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 4), 1120));
    // 0x17720c: 0x240402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x177210: 0xc05147c
    SET_GPR_U32(ctx, 31, 0x177218);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    RevokeCmPolicy(rdram, ctx, runtime); return;
}


// Function: entry_177218
// Address: 0x177218 - 0x177224

void entry_177218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177218: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x17721c: 0xc051570
    SET_GPR_U32(ctx, 31, 0x177224);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetCmCut__FP2CMPf(rdram, ctx, runtime); return;
}


// Function: entry_177224
// Address: 0x177224 - 0x1772f8

void entry_177224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177224) {
        switch (ctx->pc) {
            case 0x177278: ctx->pc = 0; goto label_177278;
            case 0x1772d8: ctx->pc = 0; goto label_1772d8;
            case 0x1772ec: ctx->pc = 0; goto label_1772ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177224: 0x10000117
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
    // 0x17722c: 0x2402002d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 45));
    // 0x177230: 0x16c20040
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x177334; return;
    }
    // 0x177238: 0xda430150
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x17723c: 0xda410660
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 1632)));
    // 0x177240: 0x4bc1186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x177244: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x177248: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17724c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x177250: 0x3c01c37a
    SET_GPR_U32(ctx, 1, ((uint32_t)50042 << 16));
    // 0x177254: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x177258: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17725c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x177260: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x177264: 0x0
    // NOP
    // 0x177268: 0x45000003
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_177278;
    }
    // 0x177270: 0x1000002f
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 0), 46));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_177330(rdram, ctx, runtime); return;
    }
label_177278:
    // 0x177278: 0x4b83186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17727c: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x177280: 0x248339a0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 14752));
    // 0x177284: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x177288: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17728c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x177290: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x177294: 0xc4620008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[2] = *(float*)&val; }
    // 0x177298: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x17729c: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x1772a0: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1772a4: 0xc48339a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 14752)); ctx->f[3] = *(float*)&val; }
    // 0x1772a8: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x1772ac: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x1772b0: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x1772b4: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x1772b8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1772bc: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x1772c0: 0x46041834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1772c4: 0x0
    // NOP
    // 0x1772c8: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[5] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1772d8;
    }
    // 0x1772d0: 0x10000006
    ctx->f[20] = FPU_MOV_S(ctx->f[4]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1772ec;
    }
label_1772d8:
    // 0x1772d8: 0x46032834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[5], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1772dc: 0x0
    // NOP
    // 0x1772e0: 0x45000002
    ctx->f[20] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1772ec;
    }
    // 0x1772e8: 0x46002d06
    ctx->f[20] = FPU_MOV_S(ctx->f[5]);
label_1772ec:
    // 0x1772ec: 0xc64d0150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 336)); ctx->f[13] = *(float*)&val; }
    // 0x1772f0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1772f8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 340)); ctx->f[12] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1772f8
// Address: 0x1772f8 - 0x177314

void entry_1772f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1772f8: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x1772fc: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x177300: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x177304: 0xc64c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x177308: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17730c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x177314);
    ctx->f[12] = FPU_SUB_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_177314
// Address: 0x177314 - 0x177324

void entry_177314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177314: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x177318: 0xc64c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x17731c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x177324);
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_177324
// Address: 0x177324 - 0x177330

void entry_177324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177324: 0xe6400638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    // 0x177328: 0xc071756
    SET_GPR_U32(ctx, 31, 0x177330);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FixStepAngularVelocity__FP4STEP(rdram, ctx, runtime); return;
}


// Function: entry_177330
// Address: 0x177330 - 0x177398

void entry_177330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177330) {
        switch (ctx->pc) {
            case 0x177334: ctx->pc = 0; goto label_177334;
            case 0x177350: ctx->pc = 0; goto label_177350;
            case 0x177368: ctx->pc = 0; goto label_177368;
            case 0x17736c: ctx->pc = 0; goto label_17736c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177330: 0x161080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
label_177334:
    // 0x177334: 0x2403002f
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 47));
    // 0x177338: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x17733c: 0x12c30004
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 2), 4252)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 3)) {
        goto label_177350;
    }
    // 0x177344: 0x24020027
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 39));
    // 0x177348: 0x16c20008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 47));
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 2)) {
        goto label_17736c;
    }
label_177350:
    // 0x177350: 0x8e442490
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9360)));
    // 0x177354: 0x10800004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_177368;
    }
    // 0x17735c: 0x24423980
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 14720));
    // 0x177360: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x177364: 0x7c830300
    WRITE128(ADD32(GPR_U32(ctx, 4), 768), GPR_VEC(ctx, 3));
label_177368:
    // 0x177368: 0x2402002f
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 47));
label_17736c:
    // 0x17736c: 0x56c200c5
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
        ctx->pc = 0x177684; return;
    }
    // 0x177374: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x177378: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x17737c: 0x8c621990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6544)));
    // 0x177380: 0xd8410040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x177384: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x177388: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17738c: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x177390: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x177398);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_177398
// Address: 0x177398 - 0x1773c4

void entry_177398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177398: 0x100000b9
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x1773a0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x1773a4: 0xda420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1773a8: 0x8c621990
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6544)));
    // 0x1773ac: 0xd8410040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 64)));
    // 0x1773b0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1773b4: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1773b8: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1773bc: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1773c4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1773c4
// Address: 0x1773c4 - 0x1773f0

void entry_1773c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1773c4: 0xe6400638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    // 0x1773c8: 0x1000000f
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177408; return;
    }
    // 0x1773d0: 0x1000000d
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177408; return;
    }
    // 0x1773d8: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1773dc: 0x3c050025
    SET_GPR_U32(ctx, 5, ((uint32_t)37 << 16));
    // 0x1773e0: 0x24a58d30
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294937904));
    // 0x1773e4: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x1773e8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1773f0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1773f0
// Address: 0x1773f0 - 0x1773fc

void entry_1773f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1773f0: 0xc64c0114
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 276)); ctx->f[12] = *(float*)&val; }
    // 0x1773f4: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1773fc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 272)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1773fc
// Address: 0x1773fc - 0x177424

void entry_1773fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1773fc) {
        switch (ctx->pc) {
            case 0x177408: ctx->pc = 0; goto label_177408;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1773fc: 0x161080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
    // 0x177400: 0xe6400638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    // 0x177404: 0xe6400630
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1584), *(uint32_t*)&val); }
label_177408:
    // 0x177408: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x17740c: 0x1000009c
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 2), 4252)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x177414: 0xc64c0114
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 276)); ctx->f[12] = *(float*)&val; }
    // 0x177418: 0xafa00074
    WRITE32(ADD32(GPR_U32(ctx, 29), 116), GPR_U32(ctx, 0));
    // 0x17741c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x177424);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 272)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_177424
// Address: 0x177424 - 0x177500

void entry_177424(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177424) {
        switch (ctx->pc) {
            case 0x177474: ctx->pc = 0; goto label_177474;
            case 0x177478: ctx->pc = 0; goto label_177478;
            case 0x1774e8: ctx->pc = 0; goto label_1774e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177424: 0x161080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 2));
    // 0x177428: 0xe6400638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    // 0x17742c: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x177430: 0xe6400630
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1584), *(uint32_t*)&val); }
    // 0x177434: 0x2421021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 2)));
    // 0x177438: 0x8c8339b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 14776)));
    // 0x17743c: 0x10600090
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 2), 4252)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x177444: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x177448: 0x1000008e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177684; return;
    }
    // 0x177450: 0x8e422230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x177454: 0x10400007
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9092)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_177474;
    }
    // 0x17745c: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x177460: 0x54430005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        SET_GPR_U64(ctx, 20, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
        goto label_177478;
    }
    // 0x177468: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17746c: 0x10000084
    WRITE32(ADD32(GPR_U32(ctx, 29), 128), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
label_177474:
    // 0x177474: 0x60a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 3) + GPR_U64(ctx, 0));
label_177478:
    // 0x177478: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x17747c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x177480: 0xc6800034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 52)); ctx->f[0] = *(float*)&val; }
    // 0x177484: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x177488: 0x1000007d
    ctx->f[22] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x177490: 0x8e5e1188
    SET_GPR_U32(ctx, 30, READ32(ADD32(GPR_U32(ctx, 18), 4488)));
    // 0x177494: 0x2404014b
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 331));
    // 0x177498: 0x10000079
    WRITE32(ADD32(GPR_U32(ctx, 29), 124), GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x1774a0: 0xda430150
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x1774a4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1774a8: 0x4b83186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x1774ac: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1774b0: 0xc44139b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 14768)); ctx->f[1] = *(float*)&val; }
    // 0x1774b4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1774b8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1774bc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1774c0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1774c4: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1774c8: 0xc44d2e2c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 11820)); ctx->f[13] = *(float*)&val; }
    // 0x1774cc: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x1774d0: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x1774d4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1774d8: 0x0
    // NOP
    // 0x1774dc: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_1774e8;
    }
    // 0x1774e4: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_1774e8:
    // 0x1774e8: 0x10400007
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177508; return;
    }
    // 0x1774f0: 0xc64c0638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1592)); ctx->f[12] = *(float*)&val; }
    // 0x1774f4: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x1774f8: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x177500);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_177500
// Address: 0x177500 - 0x177568

void entry_177500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177500) {
        switch (ctx->pc) {
            case 0x177508: ctx->pc = 0; goto label_177508;
            case 0x177558: ctx->pc = 0; goto label_177558;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177500: 0x10000015
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_177558;
    }
label_177508:
    // 0x177508: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17750c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x177510: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x177514: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x177518: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17751c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x177520: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x177524: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x177528: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x17752c: 0x460d0034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[13])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x177530: 0x0
    // NOP
    // 0x177534: 0x45020008
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
        goto label_177558;
    }
    // 0x17753c: 0x46006803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[13] * 0.0f); } else ctx->f[0] = ctx->f[13] / ctx->f[0];
    // 0x177540: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x177544: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x177548: 0x4be11898
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17754c: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x177550: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x177554: 0x8e430000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 0)));
label_177558:
    // 0x177558: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17755c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x177560: 0x40f809
    SET_GPR_U32(ctx, 31, 0x177568);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_177568
// Address: 0x177568 - 0x177630

void entry_177568(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177568) {
        switch (ctx->pc) {
            case 0x1775c4: ctx->pc = 0; goto label_1775c4;
            case 0x1775d4: ctx->pc = 0; goto label_1775d4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177568: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x17756c: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x177570: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x177574: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x177578: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17757c: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x177580: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x177584: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x177588: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17758c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x177590: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x177594: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x177598: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17759c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1775a0: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1775a4: 0x48241000
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1775a8: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x1775ac: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1775b0: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1775c4;
    }
    // 0x1775b8: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1775bc: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1775d4;
    }
label_1775c4:
    // 0x1775c4: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x1775c8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1775cc: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x1775d0: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_1775d4:
    // 0x1775d4: 0xc64003cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 972)); ctx->f[0] = *(float*)&val; }
    // 0x1775d8: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1775dc: 0x44820800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 2);
    // 0x1775e0: 0xc7a40004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[4] = *(float*)&val; }
    // 0x1775e4: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x1775e8: 0xc7a30000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[3] = *(float*)&val; }
    // 0x1775ec: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x1775f0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1775f4: 0x8e460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x1775f8: 0x27a50010
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1775fc: 0x46000807
    ctx->f[0] = FPU_NEG_S(ctx->f[1]);
    // 0x177600: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x177604: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x177608: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17760c: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x177610: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x177614: 0x44031000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[2]);
    // 0x177618: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x17761c: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x177620: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x177624: 0x8cc30094
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 148)));
    // 0x177628: 0x60f809
    SET_GPR_U32(ctx, 31, 0x177630);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_177630
// Address: 0x177630 - 0x177644

void entry_177630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177630: 0x8e4225e8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9704)));
    // 0x177634: 0x10400012
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 9684)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177680; return;
    }
    // 0x17763c: 0xc058344
    SET_GPR_U32(ctx, 31, 0x177644);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_177644
// Address: 0x177644 - 0x177664

void entry_177644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177644: 0x30420400
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1024));
    // 0x177648: 0x5040000e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
        ctx->pc = 0x177684; return;
    }
    // 0x177650: 0x8e4425e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9704)));
    // 0x177654: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x177658: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x17765c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x177664);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_177664
// Address: 0x177664 - 0x1776b8

void entry_177664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177664) {
        switch (ctx->pc) {
            case 0x177680: ctx->pc = 0; goto label_177680;
            case 0x177684: ctx->pc = 0; goto label_177684;
            case 0x177698: ctx->pc = 0; goto label_177698;
            case 0x1776b0: ctx->pc = 0; goto label_1776b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177664: 0x10000007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_177684;
    }
    // 0x17766c: 0x10000004
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 9684)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_177680;
    }
    // 0x177674: 0x10000002
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 10080)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_177680;
    }
    // 0x17767c: 0x8e542764
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 18), 10084)));
label_177680:
    // 0x177680: 0x8e422220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8736)));
label_177684:
    // 0x177684: 0x12a20004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 2)) {
        goto label_177698;
    }
    // 0x17768c: 0xae552220
    WRITE32(ADD32(GPR_U32(ctx, 18), 8736), GPR_U32(ctx, 21));
    // 0x177690: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x177694: 0xe6402224
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8740), *(uint32_t*)&val); }
label_177698:
    // 0x177698: 0x8e422228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    // 0x17769c: 0x12c20004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 2)) {
        goto label_1776b0;
    }
    // 0x1776a4: 0xae562228
    WRITE32(ADD32(GPR_U32(ctx, 18), 8744), GPR_U32(ctx, 22));
    // 0x1776a8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1776ac: 0xe640222c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8748), *(uint32_t*)&val); }
label_1776b0:
    // 0x1776b0: 0xc05d3d4
    SET_GPR_U32(ctx, 31, 0x1776b8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ChooseJtPhys__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_1776b8
// Address: 0x1776b8 - 0x1776c4

void entry_1776b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1776b8: 0x8fa50078
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 120)));
    // 0x1776bc: 0xc05d41e
    SET_GPR_U32(ctx, 31, 0x1776c4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    EnableJtActadj__FP2JTi(rdram, ctx, runtime); return;
}


// Function: entry_1776c4
// Address: 0x1776c4 - 0x17770c

void entry_1776c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1776c4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1776c8: 0x12e20010
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 23) == GPR_U32(ctx, 2)) {
        entry_17770c(rdram, ctx, runtime); return;
    }
    // 0x1776d0: 0x44807800
    *(uint32_t*)&ctx->f[15] = GPR_U32(ctx, 0);
    // 0x1776d4: 0x3c01453b
    SET_GPR_U32(ctx, 1, ((uint32_t)17723 << 16));
    // 0x1776d8: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x1776dc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x1776e0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1776e4: 0x3c014396
    SET_GPR_U32(ctx, 1, ((uint32_t)17302 << 16));
    // 0x1776e8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x1776ec: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1776f0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1776f4: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x1776f8: 0x26470140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 320));
    // 0x1776fc: 0x46007c06
    ctx->f[16] = FPU_MOV_S(ctx->f[15]);
    // 0x177700: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177704: 0xc06ff36
    SET_GPR_U32(ctx, 31, 0x17770c);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    StartSound__F5SFXIDPP3AMBP3ALOP6VECTORfffffP2LMT9(rdram, ctx, runtime); return;
}


// Function: entry_17770c
// Address: 0x17770c - 0x17772c

void entry_17770c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17770c: 0x8fa30080
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x177710: 0x1460002a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1777BC; return;
    }
    // 0x177718: 0x8e442230
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x17771c: 0x50800005
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8756)));
        ctx->pc = 0x177734; return;
    }
    // 0x177724: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x17772c);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_17772c
// Address: 0x17772c - 0x177744

void entry_17772c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17772c) {
        switch (ctx->pc) {
            case 0x177734: ctx->pc = 0; goto label_177734;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17772c: 0x10000006
    WRITE32(ADD32(GPR_U32(ctx, 18), 8752), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177748; return;
    }
label_177734:
    // 0x177734: 0x10800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177748; return;
    }
    // 0x17773c: 0xc06d90e
    SET_GPR_U32(ctx, 31, 0x177744);
    RetractSma__FP3SMA(rdram, ctx, runtime); return;
}


// Function: entry_177744
// Address: 0x177744 - 0x177794

void entry_177744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177744) {
        switch (ctx->pc) {
            case 0x177748: ctx->pc = 0; goto label_177748;
            case 0x17776c: ctx->pc = 0; goto label_17776c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177744: 0xae402234
    WRITE32(ADD32(GPR_U32(ctx, 18), 8756), GPR_U32(ctx, 0));
label_177748:
    // 0x177748: 0x12800014
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17779C; return;
    }
    // 0x177750: 0x8e4323b0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9136)));
    // 0x177754: 0x10600005
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_17776c;
    }
    // 0x17775c: 0x24020061
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 97));
    // 0x177760: 0xafa30004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 3));
    // 0x177764: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x177768: 0x27a60008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 8));
label_17776c:
    // 0x17776c: 0xdd3023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 29)));
    // 0x177770: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x177774: 0x8fa80074
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x177778: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x17777c: 0x630c3
    SET_GPR_S32(ctx, 6, SRA32(GPR_S32(ctx, 6), 3));
    // 0x177780: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x177784: 0x4600ab46
    ctx->f[13] = FPU_MOV_S(ctx->f[21]);
    // 0x177788: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17778c: 0xc04b0a2
    SET_GPR_U32(ctx, 31, 0x177794);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 5), 8752));
    ApplyAsegOvr__FP4ASEGP3ALOiP3OVRffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_177794
// Address: 0x177794 - 0x1777b4

void entry_177794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177794) {
        switch (ctx->pc) {
            case 0x17779c: ctx->pc = 0; goto label_17779c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177794: 0x10000009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1777BC; return;
    }
label_17779c:
    // 0x17779c: 0x13c00006
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 124)));
    if (GPR_U32(ctx, 30) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1777B8; return;
    }
    // 0x1777a4: 0x3c0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1777a8: 0x8fa70074
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 116)));
    // 0x1777ac: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x1777b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_1777b4
// Address: 0x1777b4 - 0x1777f8

void entry_1777b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1777b4) {
        switch (ctx->pc) {
            case 0x1777b8: ctx->pc = 0; goto label_1777b8;
            case 0x1777bc: ctx->pc = 0; goto label_1777bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1777b4: 0xae422234
    WRITE32(ADD32(GPR_U32(ctx, 18), 8756), GPR_U32(ctx, 2));
label_1777b8:
    // 0x1777b8: 0x7bbf0130
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 304)));
label_1777bc:
    // 0x1777bc: 0x7bbe0120
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x1777c0: 0x7bb70110
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x1777c4: 0x7bb60100
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x1777c8: 0x7bb500f0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1777cc: 0x7bb400e0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1777d0: 0x7bb300d0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1777d4: 0x7bb200c0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x1777d8: 0x7bb100b0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x1777dc: 0x7bb000a0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x1777e0: 0xc7b60150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 336)); ctx->f[22] = *(float*)&val; }
    // 0x1777e4: 0xc7b50148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 328)); ctx->f[21] = *(float*)&val; }
    // 0x1777e8: 0xc7b40140
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 320)); ctx->f[20] = *(float*)&val; }
    // 0x1777ec: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 352));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1777f4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1777f8; return;
}


// Function: ProfileJt__FP2JTi
// Address: 0x1777f8 - 0x177800

void entry_17781c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17781c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x177820: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00177828
// Address: 0x177828 - 0x177838

void FUN_00177828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177828: 0xac852bd8
    WRITE32(ADD32(GPR_U32(ctx, 4), 11224), GPR_U32(ctx, 5));
    // 0x17782c: 0x3e00008
    WRITE32(ADD32(GPR_U32(ctx, 4), 1208), GPR_U32(ctx, 0));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x177834: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x177838; return;
}


// Function: PaloAbsorbWkr__FP3WKRiPP3ALO
// Address: 0x177838 - 0x177938

void entry_177938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177938) {
        switch (ctx->pc) {
            case 0x17794c: ctx->pc = 0; goto label_17794c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177938: 0x14400004
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_17794c;
    }
    // 0x177940: 0x8e100018
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x177944: 0x1600ffd2
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x177890; return;
    }
label_17794c:
    // 0x17794c: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x177950: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x177954: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x177958: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17795c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x177960: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: NCmpWkr__FP3WKRT0
// Address: 0x177968 - 0x177990

void entry_177a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177a48) {
        switch (ctx->pc) {
            case 0x177a50: ctx->pc = 0; goto label_177a50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177a48: 0x100000e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177DDC; return;
    }
label_177a50:
    // 0x177a50: 0x548200e2
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
        ctx->pc = 0x177DDC; return;
    }
    // 0x177a58: 0xc058344
    SET_GPR_U32(ctx, 31, 0x177a60);
    GetGrfvault_unknown__Fv(rdram, ctx, runtime); return;
}


// Function: entry_177a60
// Address: 0x177a60 - 0x177a80

void entry_177a60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177a60) {
        switch (ctx->pc) {
            case 0x177a70: ctx->pc = 0; goto label_177a70;
            case 0x177a74: ctx->pc = 0; goto label_177a74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177a60: 0x30420400
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1024));
    // 0x177a64: 0x504000dd
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
        ctx->pc = 0x177DDC; return;
    }
    // 0x177a6c: 0x8e7425e8
    SET_GPR_U32(ctx, 20, READ32(ADD32(GPR_U32(ctx, 19), 9704)));
label_177a70:
    // 0x177a70: 0x24170008
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 8));
label_177a74:
    // 0x177a74: 0xb02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177a78: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x177a80);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_177a80
// Address: 0x177a80 - 0x177ab0

void entry_177a80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177a80) {
        switch (ctx->pc) {
            case 0x177aa0: ctx->pc = 0; goto label_177aa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177a80: 0x10400047
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177BA0; return;
    }
    // 0x177a88: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x177a8c: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x177a90: 0x8c5158d0
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 22736)));
    // 0x177a94: 0x27b5fff0
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x177a98: 0x10000028
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177B3C; return;
    }
label_177aa0:
    // 0x177aa0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177aa4: 0x24060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    // 0x177aa8: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x177ab0);
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 21), 64));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_177ab0
// Address: 0x177ab0 - 0x177ad8

void entry_177ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177ab0: 0x26100040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 64));
    // 0x177ab4: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x177ab8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177abc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x177ac0: 0x2a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x177ac4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177ac8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177acc: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177ad0: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x177ad8);
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 1));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_177ad8
// Address: 0x177ad8 - 0x177af8

void entry_177ad8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177ad8: 0x8e240018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x177adc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x177ae0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177ae4: 0x27a71020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 4128));
    // 0x177ae8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177aec: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177af0: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x177af8);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_177af8
// Address: 0x177af8 - 0x177b6c

void entry_177af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177af8) {
        switch (ctx->pc) {
            case 0x177b38: ctx->pc = 0; goto label_177b38;
            case 0x177b3c: ctx->pc = 0; goto label_177b3c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177af8: 0xae13ffc0
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294967232), GPR_U32(ctx, 19));
    // 0x177afc: 0xae11ffc4
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294967236), GPR_U32(ctx, 17));
    // 0x177b00: 0x7ba21010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 4112)));
    // 0x177b04: 0xae17ffd0
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294967248), GPR_U32(ctx, 23));
    // 0x177b08: 0x7e02ffe0
    WRITE128(ADD32(GPR_U32(ctx, 16), 4294967264), GPR_VEC(ctx, 2));
    // 0x177b0c: 0xc6600368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 872)); ctx->f[0] = *(float*)&val; }
    // 0x177b10: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x177b14: 0xe600ffc8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 4294967240), *(uint32_t*)&val); }
    // 0x177b18: 0xda820110
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 272)));
    // 0x177b1c: 0xdba11010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 4112)));
    // 0x177b20: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x177b24: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x177b28: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x177b2c: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x177b30: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x177b34: 0xae02ffd4
    WRITE32(ADD32(GPR_U32(ctx, 16), 4294967252), GPR_U32(ctx, 2));
label_177b38:
    // 0x177b38: 0x8e310080
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 128)));
label_177b3c:
    // 0x177b3c: 0x12200018
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177BA0; return;
    }
    // 0x177b44: 0x8e220090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 144)));
    // 0x177b48: 0x5040fffc
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 128)));
        goto label_177b3c;
    }
    // 0x177b50: 0x8e220088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 136)));
    // 0x177b54: 0x571024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 23)));
    // 0x177b58: 0x1040fff7
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 4112));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_177b38;
    }
    // 0x177b60: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x177b64: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x177b6c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_177b6c
// Address: 0x177b6c - 0x177b90

void entry_177b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177b6c: 0xc62c008c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 140)); ctx->f[12] = *(float*)&val; }
    // 0x177b70: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x177b74: 0x8e8503f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 1012)));
    // 0x177b78: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177b7c: 0x8e8603f8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 1016)));
    // 0x177b80: 0x268803a4
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 20), 932));
    // 0x177b84: 0x24090001
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 1));
    // 0x177b88: 0xc061c98
    SET_GPR_U32(ctx, 31, 0x177b90);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 4144));
    CsbiIntersectSphereBsp__FP6VECTORfiP3BSPT3P4GEOMiP3SBI(rdram, ctx, runtime); return;
}


// Function: entry_177b90
// Address: 0x177b90 - 0x177bd8

void entry_177b90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177b90) {
        switch (ctx->pc) {
            case 0x177ba0: ctx->pc = 0; goto label_177ba0;
            case 0x177bb0: ctx->pc = 0; goto label_177bb0;
            case 0x177bc0: ctx->pc = 0; goto label_177bc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177b90: 0x1840ffe9
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), 64));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x177B38; return;
    }
    // 0x177b98: 0x1440ffc1
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x177AA0; return;
    }
label_177ba0:
    // 0x177ba0: 0x16c00003
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 9840)));
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        goto label_177bb0;
    }
    // 0x177ba8: 0x10400090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 4352)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177DEC; return;
    }
label_177bb0:
    // 0x177bb0: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x177bb4: 0x1000002a
    SET_GPR_U32(ctx, 21, ((uint32_t)23 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177C60; return;
    }
    // 0x177bbc: 0x0
    // NOP
label_177bc0:
    // 0x177bc0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177bc4: 0x3a28021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 29), GPR_U32(ctx, 2)));
    // 0x177bc8: 0x24060040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    // 0x177bcc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x177bd0: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x177bd8);
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 1));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_177bd8
// Address: 0x177bd8 - 0x177c3c

void entry_177bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177bd8: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x177bdc: 0xae130000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 19));
    // 0x177be0: 0x721823
    SET_GPR_U32(ctx, 3, SUB32(GPR_U32(ctx, 3), GPR_U32(ctx, 18)));
    // 0x177be4: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x177be8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x177bec: 0x31980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 6));
    // 0x177bf0: 0x125980
    SET_GPR_U32(ctx, 11, SLL32(GPR_U32(ctx, 18), 6));
    // 0x177bf4: 0x2231821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x177bf8: 0x22b5821
    SET_GPR_U32(ctx, 11, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 11)));
    // 0x177bfc: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x177c00: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177c04: 0x26060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 32));
    // 0x177c08: 0x26070030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 48));
    // 0x177c0c: 0xae020004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 2));
    // 0x177c10: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177c14: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177c18: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177c1c: 0x78620010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x177c20: 0xae170010
    WRITE32(ADD32(GPR_U32(ctx, 16), 16), GPR_U32(ctx, 23));
    // 0x177c24: 0x7e020020
    WRITE128(ADD32(GPR_U32(ctx, 16), 32), GPR_VEC(ctx, 2));
    // 0x177c28: 0xc6600368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 872)); ctx->f[0] = *(float*)&val; }
    // 0x177c2c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x177c30: 0xe6000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 8), *(uint32_t*)&val); }
    // 0x177c34: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x177c3c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 11), 4)));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_177c3c
// Address: 0x177c3c - 0x177ca8

void entry_177c3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177c3c) {
        switch (ctx->pc) {
            case 0x177c60: ctx->pc = 0; goto label_177c60;
            case 0x177c98: ctx->pc = 0; goto label_177c98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177c3c: 0xda820110
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 272)));
    // 0x177c40: 0xda010020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 32)));
    // 0x177c44: 0x4bc110aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x177c48: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x177c4c: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x177c50: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x177c54: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x177c58: 0xae030014
    WRITE32(ADD32(GPR_U32(ctx, 16), 20), GPR_U32(ctx, 3));
    // 0x177c5c: 0x8e3100d0
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
label_177c60:
    // 0x177c60: 0x1220000d
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 21), 31080));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_177c98;
    }
    // 0x177c68: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x177c6c: 0x2621026
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 19), GPR_U32(ctx, 2)));
    // 0x177c70: 0x2902b
    SET_GPR_U32(ctx, 18, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x177c74: 0x121980
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 6));
    // 0x177c78: 0x2231821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 17), GPR_U32(ctx, 3)));
    // 0x177c7c: 0x8c620004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 4)));
    // 0x177c80: 0x5454fff7
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 20)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 208)));
        goto label_177c60;
    }
    // 0x177c88: 0x2ec20040
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 22), 64));
    // 0x177c8c: 0x1440ffcc
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 22), 6));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x177BC0; return;
    }
    // 0x177c94: 0x26a77968
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 21), 31080));
label_177c98:
    // 0x177c98: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x177c9c: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x177ca0: 0xc06f82a
    SET_GPR_U32(ctx, 31, 0x177ca8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    HeapSort__FPviiPFPvPv_i(rdram, ctx, runtime); return;
}


// Function: entry_177ca8
// Address: 0x177ca8 - 0x177cd8

void entry_177ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177ca8) {
        switch (ctx->pc) {
            case 0x177cc8: ctx->pc = 0; goto label_177cc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177ca8: 0x1ac0004b
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 22) <= 0) {
        ctx->pc = 0x177DD8; return;
    }
    // 0x177cb0: 0x32e20004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 23), 4));
    // 0x177cb4: 0x32f50002
    SET_GPR_U32(ctx, 21, AND32(GPR_U32(ctx, 23), 2));
    // 0x177cb8: 0xafa21060
    WRITE32(ADD32(GPR_U32(ctx, 29), 4192), GPR_U32(ctx, 2));
    // 0x177cbc: 0x267e25f0
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 19), 9712));
    // 0x177cc0: 0x24170004
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 0), 4));
    // 0x177cc4: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_177cc8:
    // 0x177cc8: 0x8e6525ec
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 9708)));
    // 0x177ccc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x177cd0: 0xc05de0e
    SET_GPR_U32(ctx, 31, 0x177cd8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 19), 9712));
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_177cd8
// Address: 0x177cd8 - 0x177d20

void entry_177cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177cd8) {
        switch (ctx->pc) {
            case 0x177d14: ctx->pc = 0; goto label_177d14;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177cd8: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x177cdc: 0x5220003b
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
        ctx->pc = 0x177DCC; return;
    }
    // 0x177ce4: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x177ce8: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x177cec: 0x50400022
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
        ctx->pc = 0x177D78; return;
    }
    // 0x177cf4: 0x12a00016
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177D50; return;
    }
    // 0x177cfc: 0x8e62223c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8764)));
    // 0x177d00: 0x10430004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        goto label_177d14;
    }
    // 0x177d08: 0x5457000a
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 23)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        ctx->pc = 0x177D34; return;
    }
    // 0x177d10: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_177d14:
    // 0x177d14: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177d18: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x177d20);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_177d20
// Address: 0x177d20 - 0x177d2c

void entry_177d20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177d20: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x177d24: 0xc071878
    SET_GPR_U32(ctx, 31, 0x177d2c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_177d2c
// Address: 0x177d2c - 0x177d3c

void entry_177d2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177d2c) {
        switch (ctx->pc) {
            case 0x177d34: ctx->pc = 0; goto label_177d34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177d2c: 0x10000012
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177D78; return;
    }
label_177d34:
    // 0x177d34: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x177d3c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_177d3c
// Address: 0x177d3c - 0x177d48

void entry_177d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177d3c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x177d40: 0xc071878
    SET_GPR_U32(ctx, 31, 0x177d48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_177d48
// Address: 0x177d48 - 0x177d68

void entry_177d48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177d48) {
        switch (ctx->pc) {
            case 0x177d50: ctx->pc = 0; goto label_177d50;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177d48: 0x1000000b
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177D78; return;
    }
label_177d50:
    // 0x177d50: 0x8fa21060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 4192)));
    // 0x177d54: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_177d74(rdram, ctx, runtime); return;
    }
    // 0x177d5c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x177d60: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x177d68);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_177d68
// Address: 0x177d68 - 0x177d74

void entry_177d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x177d68: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x177d6c: 0xc071878
    SET_GPR_U32(ctx, 31, 0x177d74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_177d74
// Address: 0x177d74 - 0x177da0

void entry_177d74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177d74) {
        switch (ctx->pc) {
            case 0x177d78: ctx->pc = 0; goto label_177d78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177d74: 0x8e02000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 12)));
label_177d78:
    // 0x177d78: 0x30420001
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 1));
    // 0x177d7c: 0x1040000a
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 55));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177DA8; return;
    }
    // 0x177d84: 0x8e622228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 8744)));
    // 0x177d88: 0x1043ff2c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 3)) {
        ctx->pc = 0x177A3C; return;
    }
    // 0x177d90: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x177d94: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x177d98: 0x40f809
    SET_GPR_U32(ctx, 31, 0x177da0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_177da0
// Address: 0x177da0 - 0x177de4

void entry_177da0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177da0) {
        switch (ctx->pc) {
            case 0x177da8: ctx->pc = 0; goto label_177da8;
            case 0x177dc8: ctx->pc = 0; goto label_177dc8;
            case 0x177dcc: ctx->pc = 0; goto label_177dcc;
            case 0x177dd8: ctx->pc = 0; goto label_177dd8;
            case 0x177ddc: ctx->pc = 0; goto label_177ddc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177da0: 0x1000000e
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_177ddc;
    }
label_177da8:
    // 0x177da8: 0x8e6325ec
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 19), 9708)));
    // 0x177dac: 0x2c620020
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 32));
    // 0x177db0: 0x10400005
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_177dc8;
    }
    // 0x177db8: 0x3c21021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 30), GPR_U32(ctx, 2)));
    // 0x177dbc: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x177dc0: 0xac510000
    WRITE32(ADD32(GPR_U32(ctx, 2), 0), GPR_U32(ctx, 17));
    // 0x177dc4: 0xae6325ec
    WRITE32(ADD32(GPR_U32(ctx, 19), 9708), GPR_U32(ctx, 3));
label_177dc8:
    // 0x177dc8: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
label_177dcc:
    // 0x177dcc: 0x256102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 22)));
    // 0x177dd0: 0x1440ffbd
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 64));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x177CC8; return;
    }
label_177dd8:
    // 0x177dd8: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
label_177ddc:
    // 0x177ddc: 0xc06187a
    SET_GPR_U32(ctx, 31, 0x177de4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 19), 9840)));
    FreeSwXpList__FP2SWP2XP(rdram, ctx, runtime); return;
}


// Function: entry_177de4
// Address: 0x177de4 - 0x177e20

void entry_177de4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177de4) {
        switch (ctx->pc) {
            case 0x177dec: ctx->pc = 0; goto label_177dec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177de4: 0xae602670
    WRITE32(ADD32(GPR_U32(ctx, 19), 9840), GPR_U32(ctx, 0));
    // 0x177de8: 0x7bbf1100
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 4352)));
label_177dec:
    // 0x177dec: 0x7bbe10f0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 4336)));
    // 0x177df0: 0x7bb710e0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 4320)));
    // 0x177df4: 0x7bb610d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 4304)));
    // 0x177df8: 0x7bb510c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 4288)));
    // 0x177dfc: 0x7bb410b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 4272)));
    // 0x177e00: 0x7bb310a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 4256)));
    // 0x177e04: 0x7bb21090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 4240)));
    // 0x177e08: 0x7bb11080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 4224)));
    // 0x177e0c: 0x7bb01070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 4208)));
    // 0x177e10: 0xc7b41110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4368)); ctx->f[20] = *(float*)&val; }
    // 0x177e14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4384));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x177e1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x177e20; return;
}


// Function: FIsJtSoundBase__FP2JT
// Address: 0x177e20 - 0x177e5c

void entry_177e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177e5c) {
        switch (ctx->pc) {
            case 0x177e60: ctx->pc = 0; goto label_177e60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177e5c: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
label_177e60:
    // 0x177e60: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x177e64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x177e6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x177e70; return;
}


// Function: CollectJtPrize__FP2JT3PCKP3ALO
// Address: 0x177e70 - 0x177e8c

void entry_177e8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177e8c) {
        switch (ctx->pc) {
            case 0x177ea4: ctx->pc = 0; goto label_177ea4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177e8c: 0x12000005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_177ea4;
    }
    // 0x177e94: 0x12020009
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x177EBC; return;
    }
    // 0x177e9c: 0x1000000d
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177ED4; return;
    }
label_177ea4:
    // 0x177ea4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x177ea8: 0x24050009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    // 0x177eac: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x177eb4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 28));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_177eb4
// Address: 0x177eb4 - 0x177ecc

void entry_177eb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177eb4) {
        switch (ctx->pc) {
            case 0x177ebc: ctx->pc = 0; goto label_177ebc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177eb4: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x177ED0; return;
    }
label_177ebc:
    // 0x177ebc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x177ec0: 0x24050009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    // 0x177ec4: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x177ecc);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 29));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_177ecc
// Address: 0x177ecc - 0x177ee0

void entry_177ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177ecc) {
        switch (ctx->pc) {
            case 0x177ed0: ctx->pc = 0; goto label_177ed0;
            case 0x177ed4: ctx->pc = 0; goto label_177ed4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177ecc: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_177ed0:
    // 0x177ed0: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_177ed4:
    // 0x177ed4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x177ed8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetJtDiapi__FP2JTP6DIALOGP5DIAPI
// Address: 0x177ee0 - 0x177f98

void entry_177fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x177fcc) {
        switch (ctx->pc) {
            case 0x177fd4: ctx->pc = 0; goto label_177fd4;
            case 0x177ffc: ctx->pc = 0; goto label_177ffc;
            case 0x178000: ctx->pc = 0; goto label_178000;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x177fcc: 0x1000000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_178000;
    }
label_177fd4:
    // 0x177fd4: 0x8c822220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x177fd8: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x177fdc: 0x10450007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 33));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 5)) {
        goto label_177ffc;
    }
    // 0x177fe4: 0x8c832254
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8788)));
    // 0x177fe8: 0xac82225c
    WRITE32(ADD32(GPR_U32(ctx, 4), 8796), GPR_U32(ctx, 2));
    // 0x177fec: 0x34630001
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), 1));
    // 0x177ff0: 0xac862bd0
    WRITE32(ADD32(GPR_U32(ctx, 4), 11216), GPR_U32(ctx, 6));
    // 0x177ff4: 0xac832254
    WRITE32(ADD32(GPR_U32(ctx, 4), 8788), GPR_U32(ctx, 3));
    // 0x177ff8: 0xac852258
    WRITE32(ADD32(GPR_U32(ctx, 4), 8792), GPR_U32(ctx, 5));
label_177ffc:
    // 0x177ffc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_178000:
    // 0x178000: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00178008
// Address: 0x178008 - 0x17801c

void FUN_00178008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178008: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x17800c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x178010: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x178014: 0xc06e5a4
    SET_GPR_U32(ctx, 31, 0x17801c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    TranslateSoToPos__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17801c
// Address: 0x17801c - 0x178024

void entry_17801c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17801c: 0xc070a7a
    SET_GPR_U32(ctx, 31, 0x178024);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 5408));
    FUN_001c29e8(rdram, ctx, runtime); return;
}


// Function: entry_178024
// Address: 0x178024 - 0x178038

void entry_178024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178024: 0xae002768
    WRITE32(ADD32(GPR_U32(ctx, 16), 10088), GPR_U32(ctx, 0));
    // 0x178028: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17802c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x178030: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnPoAdd
// Address: 0x178038 - 0x178050

void entry_178050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178050: 0xc064a08
    SET_GPR_U32(ctx, 31, 0x178058);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    OnPoAdd__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_178058
// Address: 0x178058 - 0x178068

void entry_178058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178058: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17805c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x178060: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00178068
// Address: 0x178068 - 0x1780e0

void FUN_00178068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178068) {
        switch (ctx->pc) {
            case 0x1780a4: ctx->pc = 0; goto label_1780a4;
            case 0x1780b4: ctx->pc = 0; goto label_1780b4;
            case 0x1780c0: ctx->pc = 0; goto label_1780c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178068: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x17806c: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x178070: 0x7fb30050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 19));
    // 0x178074: 0x7fb20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 18));
    // 0x178078: 0x7fb10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 17));
    // 0x17807c: 0x7fb00020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 16));
    // 0x178080: 0x8c832220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x178084: 0x460004f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_S32(ctx, 3) < 0) {
        ctx->pc = 0x1781C4; return;
    }
    // 0x17808c: 0x54400005
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 11236)));
        goto label_1780a4;
    }
    // 0x178094: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x178098: 0x1462004b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1781C8; return;
    }
    // 0x1780a0: 0x8c852be4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 11236)));
label_1780a4:
    // 0x1780a4: 0x50a00003
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 11240)));
        goto label_1780b4;
    }
    // 0x1780ac: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 4), 11236), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1780c0;
    }
label_1780b4:
    // 0x1780b4: 0x50a0000c
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 4), 11232)));
        ctx->pc = 0x1780E8; return;
    }
    // 0x1780bc: 0xac802be8
    WRITE32(ADD32(GPR_U32(ctx, 4), 11240), GPR_U32(ctx, 0));
label_1780c0:
    // 0x1780c0: 0x8ca202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 720)));
    // 0x1780c4: 0x14400040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1781C8; return;
    }
    // 0x1780cc: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x1780d0: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1780d4: 0x8c6200cc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 204)));
    // 0x1780d8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1780e0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1780e0
// Address: 0x1780e0 - 0x1780fc

void entry_1780e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1780e0) {
        switch (ctx->pc) {
            case 0x1780e8: ctx->pc = 0; goto label_1780e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1780e0: 0x10000039
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1781C8; return;
    }
label_1780e8:
    // 0x1780e8: 0x12400036
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1781C4; return;
    }
    // 0x1780f0: 0xac802be0
    WRITE32(ADD32(GPR_U32(ctx, 4), 11232), GPR_U32(ctx, 0));
    // 0x1780f4: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x1780fc);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 728)));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_1780fc
// Address: 0x1780fc - 0x178108

void entry_1780fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1780fc: 0x8e4402d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 728)));
    // 0x178100: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x178108);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 20));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_178108
// Address: 0x178108 - 0x178154

void entry_178108(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178108) {
        switch (ctx->pc) {
            case 0x17812c: ctx->pc = 0; goto label_17812c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178108: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17810c: 0x2402022e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 558));
    // 0x178110: 0x1482002d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1781C8; return;
    }
    // 0x178118: 0x8fa30014
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x17811c: 0x10640003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_17812c;
    }
    // 0x178124: 0x14620029
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x1781CC; return;
    }
label_17812c:
    // 0x17812c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x178130: 0x8c4323c4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 9156)));
    // 0x178134: 0x8c640438
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 1080)));
    // 0x178138: 0x18800008
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 4) <= 0) {
        ctx->pc = 0x17815C; return;
    }
    // 0x178140: 0x24050009
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 9));
    // 0x178144: 0x8c442e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x178148: 0x2406001e
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 30));
    // 0x17814c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x178154);
    WRITE32(ADD32(GPR_U32(ctx, 4), 9940), GPR_U32(ctx, 18));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_178154
// Address: 0x178154 - 0x17818c

void entry_178154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178154) {
        switch (ctx->pc) {
            case 0x17815c: ctx->pc = 0; goto label_17815c;
            case 0x178178: ctx->pc = 0; goto label_178178;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178154: 0x1000001c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1781C8; return;
    }
label_17815c:
    // 0x17815c: 0x8e420300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 768)));
    // 0x178160: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178164: 0x1840000d
    SET_GPR_U32(ctx, 19, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x17819C; return;
    }
    // 0x17816c: 0x26500304
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 772));
    // 0x178170: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x178174: 0x0
    // NOP
label_178178:
    // 0x178178: 0x24050231
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 561));
    // 0x17817c: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x178180: 0x26100004
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    // 0x178184: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x17818c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 724)));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_17818c
// Address: 0x17818c - 0x1781bc

void entry_17818c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17818c) {
        switch (ctx->pc) {
            case 0x17819c: ctx->pc = 0; goto label_17819c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17818c: 0x8e420300
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 768)));
    // 0x178190: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x178194: 0x5440fff8
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x178178; return;
    }
label_17819c:
    // 0x17819c: 0x8e622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    // 0x1781a0: 0xda410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x1781a4: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x1781a8: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1781ac: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1781b0: 0xc7ac0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1781b4: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1781bc);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1781bc
// Address: 0x1781bc - 0x1781e0

void entry_1781bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1781bc) {
        switch (ctx->pc) {
            case 0x1781c4: ctx->pc = 0; goto label_1781c4;
            case 0x1781c8: ctx->pc = 0; goto label_1781c8;
            case 0x1781cc: ctx->pc = 0; goto label_1781cc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1781bc: 0x8e622e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 11792)));
    // 0x1781c0: 0xe4400638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 1592), *(uint32_t*)&val); }
label_1781c4:
    // 0x1781c4: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_1781c8:
    // 0x1781c8: 0x7bb30050
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1781cc:
    // 0x1781cc: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1781d0: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1781d4: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1781d8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001781e0
// Address: 0x1781e0 - 0x178210

void FUN_001781e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1781e0: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x1781e4: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    // 0x1781e8: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x1781ec: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x1781f0: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1781f4: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x1781f8: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x1781fc: 0x10620011
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x178244; return;
    }
    // 0x178204: 0x8e0402d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 728)));
    // 0x178208: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x178210);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_178210
// Address: 0x178210 - 0x17821c

void entry_178210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178210: 0x8e0402d8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 728)));
    // 0x178214: 0xc06d95a
    SET_GPR_U32(ctx, 31, 0x17821c);
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 29), 4));
    GetSmaGoal__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_17821c
// Address: 0x17821c - 0x178258

void entry_17821c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17821c) {
        switch (ctx->pc) {
            case 0x178240: ctx->pc = 0; goto label_178240;
            case 0x178244: ctx->pc = 0; goto label_178244;
            case 0x178248: ctx->pc = 0; goto label_178248;
            case 0x17824c: ctx->pc = 0; goto label_17824c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17821c: 0x8fa40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x178220: 0x2402022e
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 558));
    // 0x178224: 0x14820008
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        goto label_178248;
    }
    // 0x17822c: 0x8fa30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 4)));
    // 0x178230: 0x10640003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_178240;
    }
    // 0x178238: 0x54620004
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
        goto label_17824c;
    }
label_178240:
    // 0x178240: 0xae302be0
    WRITE32(ADD32(GPR_U32(ctx, 17), 11232), GPR_U32(ctx, 16));
label_178244:
    // 0x178244: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_178248:
    // 0x178248: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_17824c:
    // 0x17824c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x178250: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00178258
// Address: 0x178258 - 0x178280

void FUN_00178258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178258) {
        switch (ctx->pc) {
            case 0x178274: ctx->pc = 0; goto label_178274;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178258: 0x8c832220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x17825c: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    // 0x178260: 0x10620004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_178274;
    }
    // 0x178268: 0x8ca202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 720)));
    // 0x17826c: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 4), 11236), GPR_U32(ctx, 5));
        goto label_178274;
    }
label_178274:
    // 0x178274: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17827c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x178280; return;
}


// Function: FUN_00178280
// Address: 0x178280 - 0x1782c0

void FUN_00178280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178280) {
        switch (ctx->pc) {
            case 0x17829c: ctx->pc = 0; goto label_17829c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178280: 0x8c832220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8736)));
    // 0x178284: 0x24020009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 9));
    // 0x178288: 0x10620004
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17829c;
    }
    // 0x178290: 0x8ca202d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 720)));
    // 0x178294: 0x50400001
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 4), 11240), GPR_U32(ctx, 5));
        goto label_17829c;
    }
label_17829c:
    // 0x17829c: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1782a4: 0x0
    // NOP
    // 0x1782a8: 0x27bd0010
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1782ac: 0x0
    // NOP
    // 0x1782b0: 0x7c450000
    WRITE128(ADD32(GPR_U32(ctx, 2), 0), GPR_VEC(ctx, 5));
    // 0x1782b4: 0x0
    // NOP
    // 0x1782b8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1782bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1782c0; return;
}


// Function: FUN_001782c0
// Address: 0x1782c0 - 0x178328

void FUN_001782c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1782c0: 0x27bdfef0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967024));
    // 0x1782c4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1782c8: 0x7fb600e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 22));
    // 0x1782cc: 0x244239c0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 14784));
    // 0x1782d0: 0x7fb500d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 21));
    // 0x1782d4: 0x100b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 8) + GPR_U64(ctx, 0));
    // 0x1782d8: 0x7fb400c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), GPR_VEC(ctx, 20));
    // 0x1782dc: 0xe0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x1782e0: 0x7fb300b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 19));
    // 0x1782e4: 0xc0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x1782e8: 0x7fb00080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 16));
    // 0x1782ec: 0x80982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1782f0: 0xe7b40100
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 256), *(uint32_t*)&val); }
    // 0x1782f4: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1782f8: 0x7fbf00f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 31));
    // 0x1782fc: 0x46006506
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    // 0x178300: 0x7fb200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 18));
    // 0x178304: 0x7fb10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 17));
    // 0x178308: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17830c: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x178310: 0x10a00065
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1784A8; return;
    }
    // 0x178318: 0xa0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x17831c: 0x8cb20018
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 5), 24)));
    // 0x178320: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x178328);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 118));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_178328
// Address: 0x178328 - 0x17835c

void entry_178328(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178328) {
        switch (ctx->pc) {
            case 0x178350: ctx->pc = 0; goto label_178350;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178328: 0x10400009
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_178350;
    }
    // 0x178330: 0x8e050000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x178334: 0x244239d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 14800));
    // 0x178338: 0x3c110025
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
    // 0x17833c: 0x78a30040
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 5), 64)));
    // 0x178340: 0x78440000
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x178344: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x178348: 0x1000005b
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1784B8; return;
    }
label_178350:
    // 0x178350: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x178354: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17835c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 112));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17835c
// Address: 0x17835c - 0x178388

void entry_17835c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17835c: 0x50400018
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x1783C0; return;
    }
    // 0x178364: 0x8e110000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x178368: 0x8e240034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 52)));
    // 0x17836c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x178370: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x178374: 0x10400004
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_178388(rdram, ctx, runtime); return;
    }
    // 0x17837c: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x178380: 0x40f809
    SET_GPR_U32(ctx, 31, 0x178388);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_178388
// Address: 0x178388 - 0x17839c

void entry_178388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178388: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x17838c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x178390: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x178394: 0xc07458c
    SET_GPR_U32(ctx, 31, 0x17839c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    GetJtPipeGoalMat__FP2JTP4PIPEfP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17839c
// Address: 0x17839c - 0x1783c8

void entry_17839c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17839c) {
        switch (ctx->pc) {
            case 0x1783c0: ctx->pc = 0; goto label_1783c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17839c: 0x3c110025
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
    // 0x1783a0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1783a4: 0xdba10040
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1783a8: 0x8c4239e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 14816)));
    // 0x1783ac: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x1783b0: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1783b4: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1783b8: 0x1000003f
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1784B8; return;
    }
label_1783c0:
    // 0x1783c0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1783c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 111));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1783c8
// Address: 0x1783c8 - 0x1783e4

void entry_1783c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1783c8: 0x10400008
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1783EC; return;
    }
    // 0x1783d0: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1783d4: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x1783d8: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1783dc: 0xc05a788
    SET_GPR_U32(ctx, 31, 0x1783e4);
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
    GetHshapeHidePos__FP6HSHAPEfP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_1783e4
// Address: 0x1783e4 - 0x1783f8

void entry_1783e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1783e4) {
        switch (ctx->pc) {
            case 0x1783ec: ctx->pc = 0; goto label_1783ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1783e4: 0x1000000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x178418; return;
    }
label_1783ec:
    // 0x1783ec: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1783f0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x1783f8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 127));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_1783f8
// Address: 0x1783f8 - 0x178414

void entry_1783f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1783f8: 0x1040000d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x178430; return;
    }
    // 0x178400: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x178404: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x178408: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17840c: 0xc05a890
    SET_GPR_U32(ctx, 31, 0x178414);
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
    GetHpntClosestHidePos__FP4HPNTP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_178414
// Address: 0x178414 - 0x178428

void entry_178414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178414) {
        switch (ctx->pc) {
            case 0x178418: ctx->pc = 0; goto label_178418;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178414: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_178418:
    // 0x178418: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17841c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x178420: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x178428);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_178428
// Address: 0x178428 - 0x17843c

void entry_178428(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178428) {
        switch (ctx->pc) {
            case 0x178430: ctx->pc = 0; goto label_178430;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178428: 0x10000024
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294937904));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1784BC; return;
    }
label_178430:
    // 0x178430: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x178434: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17843c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 110));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17843c
// Address: 0x17843c - 0x17846c

void entry_17843c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17843c: 0x5040000d
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x178474; return;
    }
    // 0x178444: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x178448: 0x8c640034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x17844c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x178450: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x178454: 0x10400018
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1784B8; return;
    }
    // 0x17845c: 0xc60c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[12] = *(float*)&val; }
    // 0x178460: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x178464: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17846c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17846c
// Address: 0x17846c - 0x17847c

void entry_17846c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17846c) {
        switch (ctx->pc) {
            case 0x178474: ctx->pc = 0; goto label_178474;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17846c: 0x10000013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294937904));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1784BC; return;
    }
label_178474:
    // 0x178474: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17847c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 126));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17847c
// Address: 0x17847c - 0x1784e4

void entry_17847c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17847c) {
        switch (ctx->pc) {
            case 0x178490: ctx->pc = 0; goto label_178490;
            case 0x1784a8: ctx->pc = 0; goto label_1784a8;
            case 0x1784b4: ctx->pc = 0; goto label_1784b4;
            case 0x1784b8: ctx->pc = 0; goto label_1784b8;
            case 0x1784bc: ctx->pc = 0; goto label_1784bc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17847c: 0x10400004
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_178490;
    }
    // 0x178484: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x178488: 0x1000000a
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1784b4;
    }
label_178490:
    // 0x178490: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x178494: 0x24448d30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x178498: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17849c: 0x78830000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x1784a0: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1784b8;
    }
label_1784a8:
    // 0x1784a8: 0x7a020010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1784ac: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1784b0: 0x3c110025
    SET_GPR_U32(ctx, 17, ((uint32_t)37 << 16));
label_1784b4:
    // 0x1784b4: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
label_1784b8:
    // 0x1784b8: 0x26228d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 4294937904));
label_1784bc:
    // 0x1784bc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1784c0: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1784c4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1784c8: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x1784cc: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1784d0: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x1784d4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1784d8: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1784dc: 0xc049676
    SET_GPR_U32(ctx, 31, 0x1784e4);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_1784e4
// Address: 0x1784e4 - 0x178598

void entry_1784e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1784e4) {
        switch (ctx->pc) {
            case 0x178554: ctx->pc = 0; goto label_178554;
            case 0x178560: ctx->pc = 0; goto label_178560;
            case 0x17856c: ctx->pc = 0; goto label_17856c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1784e4: 0x3c01bf00
    SET_GPR_U32(ctx, 1, ((uint32_t)48896 << 16));
    // 0x1784e8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1784ec: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1784f0: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x1784f4: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1784f8: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x1784fc: 0x4be218e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x178500: 0xda610140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 320)));
    // 0x178504: 0x48a22800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x178508: 0x4be1186c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17850c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x178510: 0xda620350
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 19), 848)));
    // 0x178514: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x178518: 0x4a6503bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x17851c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x178520: 0x4be0085c
    ctx->vu0_vf[1] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x178524: 0xfba50040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x178528: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17852c: 0x4be41048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x178530: 0xfba40040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x178534: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x178538: 0x4be51088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17853c: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x178540: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x178544: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x178548: 0x12800002
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[5]));
    if (GPR_U32(ctx, 20) == GPR_U32(ctx, 0)) {
        goto label_178554;
    }
    // 0x178550: 0xfa810000
    WRITE128(ADD32(GPR_U32(ctx, 20), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_178554:
    // 0x178554: 0x12a00002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        goto label_178560;
    }
    // 0x17855c: 0x7ea20000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), GPR_VEC(ctx, 2));
label_178560:
    // 0x178560: 0x12c00002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_17856c;
    }
    // 0x178568: 0x7ec20000
    WRITE128(ADD32(GPR_U32(ctx, 22), 0), GPR_VEC(ctx, 2));
label_17856c:
    // 0x17856c: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x178570: 0x7bb600e0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x178574: 0x7bb500d0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x178578: 0x7bb400c0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x17857c: 0x7bb300b0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x178580: 0x7bb200a0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x178584: 0x7bb10090
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x178588: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x17858c: 0xc7b40100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[20] = *(float*)&val; }
    // 0x178590: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00178598
// Address: 0x178598 - 0x1785d4

void FUN_00178598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178598: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x17859c: 0x7fb20080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 18));
    // 0x1785a0: 0x7fb10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 17));
    // 0x1785a4: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x1785a8: 0x7fbf0090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 31));
    // 0x1785ac: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1785b0: 0x7fb00060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 16));
    // 0x1785b4: 0x16400008
    { float val = ctx->f[12]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1785D8; return;
    }
    // 0x1785bc: 0x27b00030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1785c0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1785c4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1785c8: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1785cc: 0xc05e366
    SET_GPR_U32(ctx, 31, 0x1785d4);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 80));
    FUN_00178d98(rdram, ctx, runtime); return;
}


// Function: entry_1785d4
// Address: 0x1785d4 - 0x1785f8

void entry_1785d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1785d4) {
        switch (ctx->pc) {
            case 0x1785d8: ctx->pc = 0; goto label_1785d8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1785d4: 0x200902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_1785d8:
    // 0x1785d8: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1785dc: 0xc7ac0050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[12] = *(float*)&val; }
    // 0x1785e0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1785e4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1785e8: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x1785ec: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1785f0: 0xc05e0b0
    SET_GPR_U32(ctx, 31, 0x1785f8);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    FUN_001782c0(rdram, ctx, runtime); return;
}


// Function: entry_1785f8
// Address: 0x1785f8 - 0x17863c

void entry_1785f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1785f8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1785fc: 0xc7a10050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[1] = *(float*)&val; }
    // 0x178600: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x178604: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x178608: 0x8e222514
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x17860c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x178610: 0xe4400018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 24), *(uint32_t*)&val); }
    // 0x178614: 0x8e232514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x178618: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17861c: 0x7c620020
    WRITE128(ADD32(GPR_U32(ctx, 3), 32), GPR_VEC(ctx, 2));
    // 0x178620: 0x8e262514
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x178624: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x178628: 0x7cc20030
    WRITE128(ADD32(GPR_U32(ctx, 6), 48), GPR_VEC(ctx, 2));
    // 0x17862c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x178630: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x178634: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17863c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17863c
// Address: 0x17863c - 0x17865c

void entry_17863c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17863c: 0x7a430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x178640: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x178644: 0x24050004
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    // 0x178648: 0x2406002c
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 44));
    // 0x17864c: 0x7e232b70
    WRITE128(ADD32(GPR_U32(ctx, 17), 11120), GPR_VEC(ctx, 3));
    // 0x178650: 0x7a420010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 18), 16)));
    // 0x178654: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17865c);
    WRITE128(ADD32(GPR_U32(ctx, 17), 11136), GPR_VEC(ctx, 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17865c
// Address: 0x17865c - 0x178678

void entry_17865c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17865c: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x178660: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x178664: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x178668: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17866c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x178674: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x178678; return;
}


// Function: FUN_00178678
// Address: 0x178678 - 0x178738

void FUN_00178678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178678) {
        switch (ctx->pc) {
            case 0x178708: ctx->pc = 0; goto label_178708;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178678: 0x27bdfb40
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966080));
    // 0x17867c: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x178680: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x178684: 0x7fbe0470
    WRITE128(ADD32(GPR_U32(ctx, 29), 1136), GPR_VEC(ctx, 30));
    // 0x178688: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17868c: 0x7fb70460
    WRITE128(ADD32(GPR_U32(ctx, 29), 1120), GPR_VEC(ctx, 23));
    // 0x178690: 0xc0f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x178694: 0x7fb50440
    WRITE128(ADD32(GPR_U32(ctx, 29), 1088), GPR_VEC(ctx, 21));
    // 0x178698: 0xe0b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 7) + GPR_U64(ctx, 0));
    // 0x17869c: 0x7fb40430
    WRITE128(ADD32(GPR_U32(ctx, 29), 1072), GPR_VEC(ctx, 20));
    // 0x1786a0: 0x27b50020
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1786a4: 0x7fb30420
    WRITE128(ADD32(GPR_U32(ctx, 29), 1056), GPR_VEC(ctx, 19));
    // 0x1786a8: 0x27b40010
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1786ac: 0x7fb10400
    WRITE128(ADD32(GPR_U32(ctx, 29), 1024), GPR_VEC(ctx, 17));
    // 0x1786b0: 0x27b30030
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1786b4: 0xe7b804b0
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 1200), *(uint32_t*)&val); }
    // 0x1786b8: 0x882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1786bc: 0xe7b704a8
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 1192), *(uint32_t*)&val); }
    // 0x1786c0: 0x7fbf0480
    WRITE128(ADD32(GPR_U32(ctx, 29), 1152), GPR_VEC(ctx, 31));
    // 0x1786c4: 0x7fb60450
    WRITE128(ADD32(GPR_U32(ctx, 29), 1104), GPR_VEC(ctx, 22));
    // 0x1786c8: 0x7fb20410
    WRITE128(ADD32(GPR_U32(ctx, 29), 1040), GPR_VEC(ctx, 18));
    // 0x1786cc: 0x7fb003f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 1008), GPR_VEC(ctx, 16));
    // 0x1786d0: 0xe7b604a0
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 1184), *(uint32_t*)&val); }
    // 0x1786d4: 0xe7b50498
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 1176), *(uint32_t*)&val); }
    // 0x1786d8: 0xe7b40490
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 1168), *(uint32_t*)&val); }
    // 0x1786dc: 0xafa403e0
    WRITE32(ADD32(GPR_U32(ctx, 29), 992), GPR_U32(ctx, 4));
    // 0x1786e0: 0xc458afa0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294946720)); ctx->f[24] = *(float*)&val; }
    // 0x1786e4: 0x78830140
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x1786e8: 0xafa503e4
    WRITE32(ADD32(GPR_U32(ctx, 29), 996), GPR_U32(ctx, 5));
    // 0x1786ec: 0x4600c5c6
    ctx->f[23] = FPU_MOV_S(ctx->f[24]);
    // 0x1786f0: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x1786f4: 0xafa803e8
    WRITE32(ADD32(GPR_U32(ctx, 29), 1000), GPR_U32(ctx, 8));
    // 0x1786f8: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x1786fc: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x178700: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x178704: 0x118080
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 17), 2));
label_178708:
    // 0x178708: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17870c: 0x244239e8
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 14824));
    // 0x178710: 0x200902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x178714: 0x2028021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x178718: 0x8fa403e0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 992)));
    // 0x17871c: 0xc60c0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[12] = *(float*)&val; }
    // 0x178720: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x178724: 0x8fa503e4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 996)));
    // 0x178728: 0x280382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x17872c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x178730: 0xc05e0b0
    SET_GPR_U32(ctx, 31, 0x178738);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    FUN_001782c0(rdram, ctx, runtime); return;
}


// Function: entry_178738
// Address: 0x178738 - 0x1787c0

void entry_178738(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178738) {
        switch (ctx->pc) {
            case 0x178788: ctx->pc = 0; goto label_178788;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178738: 0x26360001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 17), 1));
    // 0x17873c: 0xc7a10018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[1] = *(float*)&val; }
    // 0x178740: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x178744: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x178748: 0xc6020000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 0)); ctx->f[2] = *(float*)&val; }
    // 0x17874c: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x178750: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x178754: 0x4602a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178758: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17875c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x178760: 0x7fa20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    // 0x178764: 0x45000037
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x178844; return;
    }
    // 0x17876c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x178770: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x178774: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x178778: 0x246339e8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 14824));
    // 0x17877c: 0x27b00040
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 64));
    // 0x178780: 0x2438821
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x178784: 0x0
    // NOP
label_178788:
    // 0x178788: 0xc62d0000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[13] = *(float*)&val; }
    // 0x17878c: 0x4616a000
    ctx->f[0] = FPU_ADD_S(ctx->f[20], ctx->f[22]);
    // 0x178790: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x178794: 0x44817000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 1);
    // 0x178798: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17879c: 0x46006b06
    ctx->f[12] = FPU_MOV_S(ctx->f[13]);
    // 0x1787a0: 0x2a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x1787a4: 0x280302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x1787a8: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x1787ac: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1787b0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1787b4: 0x46006b69
    ctx->f[13] = std::min(ctx->f[13], ctx->f[0]);
    // 0x1787b8: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x1787c0);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_1787c0
// Address: 0x1787c0 - 0x1787dc

void entry_1787c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1787c0: 0x27a40050
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 80));
    // 0x1787c4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1787c8: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x1787cc: 0x2e0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x1787d0: 0x24080008
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 8));
    // 0x1787d4: 0xc0506d2
    SET_GPR_U32(ctx, 31, 0x1787dc);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 96));
    FUN_00141b48(rdram, ctx, runtime); return;
}


// Function: entry_1787dc
// Address: 0x1787dc - 0x1788f0

void entry_1787dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1787dc) {
        switch (ctx->pc) {
            case 0x1787e8: ctx->pc = 0; goto label_1787e8;
            case 0x17882c: ctx->pc = 0; goto label_17882c;
            case 0x178844: ctx->pc = 0; goto label_178844;
            case 0x178890: ctx->pc = 0; goto label_178890;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1787dc: 0x58400013
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[22]);
        goto label_17882c;
    }
    // 0x1787e4: 0x27a30070
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 112));
label_1787e8:
    // 0x1787e8: 0xd8620000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1787ec: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x1787f0: 0xd861fff0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 4294967280)));
    // 0x1787f4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1787f8: 0x24630070
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 112));
    // 0x1787fc: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178800: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x178804: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178808: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17880c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178810: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x178814: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x178818: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17881c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x178820: 0x1440fff1
    ctx->f[21] = FPU_ADD_S(ctx->f[21], ctx->f[0]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1787e8;
    }
    // 0x178828: 0x4616a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[22]);
label_17882c:
    // 0x17882c: 0xc6200000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 0)); ctx->f[0] = *(float*)&val; }
    // 0x178830: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x178834: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178838: 0x0
    // NOP
    // 0x17883c: 0x4501ffd2
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x178788; return;
    }
label_178844:
    // 0x178844: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x178848: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17884c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x178850: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178854: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x178858: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17885c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x178860: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x178864: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x178868: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x17886c: 0x4600a802
    ctx->f[0] = FPU_MUL_S(ctx->f[21], ctx->f[0]);
    // 0x178870: 0x46170034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[23])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178874: 0x0
    // NOP
    // 0x178878: 0x45000005
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_178890;
    }
    // 0x178880: 0x460005c6
    ctx->f[23] = FPU_MOV_S(ctx->f[0]);
    // 0x178884: 0x246339e8
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 14824));
    // 0x178888: 0x2431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 18), GPR_U32(ctx, 3)));
    // 0x17888c: 0xc4580000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[24] = *(float*)&val; }
label_178890:
    // 0x178890: 0x2c0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x178894: 0x2e220009
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 17), 9));
    // 0x178898: 0x1440ff9b
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 17), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x178708; return;
    }
    // 0x1788a0: 0x8fa403e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 1000)));
    // 0x1788a4: 0x7bbf0480
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1152)));
    // 0x1788a8: 0xe4980000
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 4), 0), *(uint32_t*)&val); }
    // 0x1788ac: 0x7bbe0470
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 1136)));
    // 0x1788b0: 0x7bb70460
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 1120)));
    // 0x1788b4: 0x7bb60450
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 1104)));
    // 0x1788b8: 0x7bb50440
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 1088)));
    // 0x1788bc: 0x7bb40430
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 1072)));
    // 0x1788c0: 0x7bb30420
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1056)));
    // 0x1788c4: 0x7bb20410
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1040)));
    // 0x1788c8: 0x7bb10400
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1024)));
    // 0x1788cc: 0x7bb003f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1008)));
    // 0x1788d0: 0xc7b804b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1200)); ctx->f[24] = *(float*)&val; }
    // 0x1788d4: 0xc7b704a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1192)); ctx->f[23] = *(float*)&val; }
    // 0x1788d8: 0xc7b604a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1184)); ctx->f[22] = *(float*)&val; }
    // 0x1788dc: 0xc7b50498
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1176)); ctx->f[21] = *(float*)&val; }
    // 0x1788e0: 0xc7b40490
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1168)); ctx->f[20] = *(float*)&val; }
    // 0x1788e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1216));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1788ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1788f0; return;
}


// Function: FUN_001788f0
// Address: 0x1788f0 - 0x178950

void FUN_001788f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1788f0: 0x27bdfe40
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966848));
    // 0x1788f4: 0x7fbe0180
    WRITE128(ADD32(GPR_U32(ctx, 29), 384), GPR_VEC(ctx, 30));
    // 0x1788f8: 0x7fb20120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 18));
    // 0x1788fc: 0xc0f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x178900: 0x7fb00100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 16));
    // 0x178904: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x178908: 0xe7b501a8
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 424), *(uint32_t*)&val); }
    // 0x17890c: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x178910: 0x7fb70170
    WRITE128(ADD32(GPR_U32(ctx, 29), 368), GPR_VEC(ctx, 23));
    // 0x178914: 0x7fb60160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), GPR_VEC(ctx, 22));
    // 0x178918: 0xe7b401a0
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 416), *(uint32_t*)&val); }
    // 0x17891c: 0xafa900f4
    WRITE32(ADD32(GPR_U32(ctx, 29), 244), GPR_U32(ctx, 9));
    // 0x178920: 0xafa700ec
    WRITE32(ADD32(GPR_U32(ctx, 29), 236), GPR_U32(ctx, 7));
    // 0x178924: 0xafa800f0
    WRITE32(ADD32(GPR_U32(ctx, 29), 240), GPR_U32(ctx, 8));
    // 0x178928: 0x7fbf0190
    WRITE128(ADD32(GPR_U32(ctx, 29), 400), GPR_VEC(ctx, 31));
    // 0x17892c: 0x7fb50150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), GPR_VEC(ctx, 21));
    // 0x178930: 0x7fb40140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), GPR_VEC(ctx, 20));
    // 0x178934: 0x7fb30130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 19));
    // 0x178938: 0x7fb10110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 17));
    // 0x17893c: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x178940: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x178944: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x178948: 0xc063582
    SET_GPR_U32(ctx, 31, 0x178950);
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 432), *(uint32_t*)&val); }
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_178950
// Address: 0x178950 - 0x17896c

void entry_178950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178950: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x178954: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x178958: 0x4600ab06
    ctx->f[12] = FPU_MOV_S(ctx->f[21]);
    // 0x17895c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x178960: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178964: 0xc05e0b0
    SET_GPR_U32(ctx, 31, 0x17896c);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001782c0(rdram, ctx, runtime); return;
}


// Function: entry_17896c
// Address: 0x17896c - 0x1789e0

void entry_17896c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17896c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x178970: 0xda410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 320)));
    // 0x178974: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x178978: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17897c: 0x24423a90
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 14992));
    // 0x178980: 0x4bc308ab
    { __m128 res = _mm_max_ps(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178984: 0x3c014348
    SET_GPR_U32(ctx, 1, ((uint32_t)17224 << 16));
    // 0x178988: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17898c: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x178990: 0x4bc3086f
    { __m128 res = _mm_min_ps(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178994: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x178998: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17899c: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x1789a0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1789a4: 0xd8440000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1789a8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1789ac: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x1789b0: 0x4be408ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1789b4: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1789b8: 0x27aa00e0
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 224));
    // 0x1789bc: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x1789c0: 0x27ab00e4
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 228));
    // 0x1789c4: 0x8e440014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 20)));
    // 0x1789c8: 0xe7a00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    // 0x1789cc: 0xfba20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x1789d0: 0xdba10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1789d4: 0x4be40868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1789d8: 0xc07708e
    SET_GPR_U32(ctx, 31, 0x1789e0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    IntersectSwBoundingBox__FP2SWP2SOP6VECTORT2PFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_1789e0
// Address: 0x1789e0 - 0x178a5c

void entry_1789e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1789e0: 0x7a030000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1789e4: 0x27b70030
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 48));
    // 0x1789e8: 0x7a020010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 16)));
    // 0x1789ec: 0x27b600e8
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 232));
    // 0x1789f0: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1789f4: 0x7fa30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 3));
    // 0x1789f8: 0x14800066
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x178B94; return;
    }
    // 0x178a00: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x178a04: 0x27a60060
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 96));
    // 0x178a08: 0x3c0142fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17146 << 16));
    // 0x178a0c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x178a10: 0x27a50050
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 80));
    // 0x178a14: 0x7fa20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    // 0x178a18: 0x27a90070
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 112));
    // 0x178a1c: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x178a20: 0xc0a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x178a24: 0xc7a00058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[0] = *(float*)&val; }
    // 0x178a28: 0xa0a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x178a2c: 0xc7a10068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[1] = *(float*)&val; }
    // 0x178a30: 0x120982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 9) + GPR_U64(ctx, 0));
    // 0x178a34: 0x3c01432f
    SET_GPR_U32(ctx, 1, ((uint32_t)17199 << 16));
    // 0x178a38: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x178a3c: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x178a40: 0x8fa700e0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x178a44: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178a48: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x178a4c: 0x8fa800e4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x178a50: 0xe7a00058
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 88), *(uint32_t*)&val); }
    // 0x178a54: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x178a5c);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_178a5c
// Address: 0x178a5c - 0x178b00

void entry_178a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178a5c) {
        switch (ctx->pc) {
            case 0x178a84: ctx->pc = 0; goto label_178a84;
            case 0x178a98: ctx->pc = 0; goto label_178a98;
            case 0x178aac: ctx->pc = 0; goto label_178aac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178a5c: 0x10400009
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_178a84;
    }
    // 0x178a64: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178a68: 0x0
    // NOP
    // 0x178a6c: 0x45010005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[0] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_178a84;
    }
    // 0x178a74: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178a78: 0x0
    // NOP
    // 0x178a7c: 0x4500000b
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_178aac;
    }
label_178a84:
    // 0x178a84: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x178a88: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x178a8c: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x178a90: 0x10000006
    ctx->f[20] = std::max(ctx->f[0], ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_178aac;
    }
label_178a98:
    // 0x178a98: 0x3c0144bb
    SET_GPR_U32(ctx, 1, ((uint32_t)17595 << 16));
    // 0x178a9c: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x178aa0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x178aa4: 0x1000003b
    ctx->f[20] = std::max(ctx->f[0], ctx->f[20]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x178B94; return;
    }
label_178aac:
    // 0x178aac: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x178ab0: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x178ab4: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178ab8: 0x3c014334
    SET_GPR_U32(ctx, 1, ((uint32_t)17204 << 16));
    // 0x178abc: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x178ac0: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x178ac4: 0x7fa20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 2));
    // 0x178ac8: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x178acc: 0x7fa20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 2));
    // 0x178ad0: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x178ad4: 0xc7a00058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[0] = *(float*)&val; }
    // 0x178ad8: 0xc7a10068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[1] = *(float*)&val; }
    // 0x178adc: 0x3c0140a0
    SET_GPR_U32(ctx, 1, ((uint32_t)16544 << 16));
    // 0x178ae0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x178ae4: 0x46030000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[3]);
    // 0x178ae8: 0x8fa700e0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x178aec: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x178af0: 0x8fa800e4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x178af4: 0xe7a00058
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 88), *(uint32_t*)&val); }
    // 0x178af8: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x178b00);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_178b00
// Address: 0x178b00 - 0x178b80

void entry_178b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178b00) {
        switch (ctx->pc) {
            case 0x178b14: ctx->pc = 0; goto label_178b14;
            case 0x178b38: ctx->pc = 0; goto label_178b38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178b00: 0x10400004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_178b14;
    }
    // 0x178b08: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x178b0c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x178b10: 0x46140528
    ctx->f[20] = std::max(ctx->f[0], ctx->f[20]);
label_178b14:
    // 0x178b14: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x178b18: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x178b1c: 0x3c0141f0
    SET_GPR_U32(ctx, 1, ((uint32_t)16880 << 16));
    // 0x178b20: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x178b24: 0x24513a10
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 14864));
    // 0x178b28: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178b2c: 0x27b70030
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 48));
    // 0x178b30: 0x27b600e8
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 232));
    // 0x178b34: 0x0
    // NOP
label_178b38:
    // 0x178b38: 0xda210000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x178b3c: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178b40: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x178b44: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x178b48: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x178b4c: 0x8fa700e0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x178b50: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x178b54: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x178b58: 0xfba20060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x178b5c: 0x260482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x178b60: 0x8fa800e4
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x178b64: 0xc7a00058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 88)); ctx->f[0] = *(float*)&val; }
    // 0x178b68: 0xc7a10068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[1] = *(float*)&val; }
    // 0x178b6c: 0x46160000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[22]);
    // 0x178b70: 0x46150841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[21]);
    // 0x178b74: 0xe7a00058
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 88), *(uint32_t*)&val); }
    // 0x178b78: 0xc05067a
    SET_GPR_U32(ctx, 31, 0x178b80);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    PsoHitTestLineObjects__FiP6VECTORT1iPP2SOP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_178b80
// Address: 0x178b80 - 0x178cb0

void entry_178b80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178b80) {
        switch (ctx->pc) {
            case 0x178b94: ctx->pc = 0; goto label_178b94;
            case 0x178bc8: ctx->pc = 0; goto label_178bc8;
            case 0x178c10: ctx->pc = 0; goto label_178c10;
            case 0x178c78: ctx->pc = 0; goto label_178c78;
            case 0x178c88: ctx->pc = 0; goto label_178c88;
            case 0x178c98: ctx->pc = 0; goto label_178c98;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178b80: 0x1040ffc5
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x178A98; return;
    }
    // 0x178b88: 0x2e020008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 16), 8));
    // 0x178b8c: 0x1440ffea
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x178B38; return;
    }
label_178b94:
    // 0x178b94: 0x1bc00040
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_S32(ctx, 30) <= 0) {
        goto label_178c98;
    }
    // 0x178b9c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x178ba0: 0xc4463aa0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15008)); ctx->f[6] = *(float*)&val; }
    // 0x178ba4: 0x24483aa0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 2), 15008));
    // 0x178ba8: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x178bac: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x178bb0: 0xc4653ab0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 15024)); ctx->f[5] = *(float*)&val; }
    // 0x178bb4: 0x24498d20
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x178bb8: 0x8fa700ec
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 236)));
    // 0x178bbc: 0x24633ab0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 15024));
    // 0x178bc0: 0x3c0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 30) + GPR_U64(ctx, 0));
    // 0x178bc4: 0x0
    // NOP
label_178bc8:
    // 0x178bc8: 0x8ce40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 7), 0)));
    // 0x178bcc: 0x8c850388
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 4), 904)));
    // 0x178bd0: 0x50a0000f
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[3]));
        goto label_178c10;
    }
    // 0x178bd8: 0x8c8206d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1744)));
    // 0x178bdc: 0xc48106cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 1740)); ctx->f[1] = *(float*)&val; }
    // 0x178be0: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x178be4: 0xd9220000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 9), 0)));
    // 0x178be8: 0x451021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x178bec: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x178bf0: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x178bf4: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x178bf8: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x178bfc: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x178c00: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x178c04: 0x4be11088
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x178c08: 0xfba10060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x178c0c: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
label_178c10:
    // 0x178c10: 0xd8810140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 320)));
    // 0x178c14: 0xdba20050
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x178c18: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178c1c: 0xc48303d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 976)); ctx->f[3] = *(float*)&val; }
    // 0x178c20: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178c24: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x178c28: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178c2c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x178c30: 0xc5020008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 8)); ctx->f[2] = *(float*)&val; }
    // 0x178c34: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178c38: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x178c3c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x178c40: 0xc5010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 4)); ctx->f[1] = *(float*)&val; }
    // 0x178c44: 0x48240800
    SET_GPR_VEC(ctx, 4, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x178c48: 0xc4640004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[4] = *(float*)&val; }
    // 0x178c4c: 0x44840000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 4);
    // 0x178c50: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x178c54: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x178c58: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x178c5c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x178c60: 0x46003000
    ctx->f[0] = FPU_ADD_S(ctx->f[6], ctx->f[0]);
    // 0x178c64: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178c68: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_178c78;
    }
    // 0x178c70: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_178c88;
    }
label_178c78:
    // 0x178c78: 0x46002034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178c7c: 0x0
    // NOP
    // 0x178c80: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[4]);
        goto label_178c88;
    }
label_178c88:
    // 0x178c88: 0x46140528
    ctx->f[20] = std::max(ctx->f[0], ctx->f[20]);
    // 0x178c8c: 0x24c6ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967295));
    // 0x178c90: 0x14c0ffcd
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        goto label_178bc8;
    }
label_178c98:
    // 0x178c98: 0x8fa600e0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x178c9c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x178ca0: 0x8fa700e4
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 228)));
    // 0x178ca4: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x178ca8: 0xc05e19e
    SET_GPR_U32(ctx, 31, 0x178cb0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    FUN_00178678(rdram, ctx, runtime); return;
}


// Function: entry_178cb0
// Address: 0x178cb0 - 0x178cb8

void entry_178cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178cb0: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x178cb8);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_178cb8
// Address: 0x178cb8 - 0x178d98

void entry_178cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178cb8) {
        switch (ctx->pc) {
            case 0x178d90: ctx->pc = 0; goto label_178d90;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178cb8: 0x7ba30040
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x178cbc: 0x4600a006
    ctx->f[0] = FPU_MOV_S(ctx->f[20]);
    // 0x178cc0: 0x8fa400f0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x178cc4: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x178cc8: 0xc7a100e8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 232)); ctx->f[1] = *(float*)&val; }
    // 0x178ccc: 0x7c830010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 3));
    // 0x178cd0: 0x7c820000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 2));
    // 0x178cd4: 0x8fa200f4
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 244)));
    // 0x178cd8: 0x7bbf0190
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x178cdc: 0x7bbe0180
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x178ce0: 0x7bb70170
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x178ce4: 0x7bb60160
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x178ce8: 0x7bb50150
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x178cec: 0x7bb40140
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x178cf0: 0x7bb30130
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x178cf4: 0x7bb20120
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x178cf8: 0x7bb10110
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x178cfc: 0x7bb00100
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x178d00: 0xc7b601b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[22] = *(float*)&val; }
    // 0x178d04: 0xc7b501a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 424)); ctx->f[21] = *(float*)&val; }
    // 0x178d08: 0xc7b401a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 416)); ctx->f[20] = *(float*)&val; }
    // 0x178d0c: 0xe4410000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    // 0x178d10: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 448));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x178d18: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x178d1c: 0xd8820010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 16)));
    // 0x178d20: 0x8c432e10
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x178d24: 0xd8a10010
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x178d28: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x178d2c: 0xd8630140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x178d30: 0x4be310ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x178d34: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178d38: 0x4bc210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x178d3c: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x178d40: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x178d44: 0x4b02208a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x178d48: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178d4c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x178d50: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178d54: 0x4b01184a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x178d58: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x178d5c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x178d60: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x178d64: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x178d68: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x178d6c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x178d70: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x178d74: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x178d78: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x178d7c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x178d80: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178d84: 0x0
    // NOP
    // 0x178d88: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
        goto label_178d90;
    }
label_178d90:
    // 0x178d90: 0x3e00008
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00178d98
// Address: 0x178d98 - 0x178e00

void FUN_00178d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178d98: 0x27bdfe80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966912));
    // 0x178d9c: 0x7fb70140
    WRITE128(ADD32(GPR_U32(ctx, 29), 320), GPR_VEC(ctx, 23));
    // 0x178da0: 0x3a0482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x178da4: 0x7fb50120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), GPR_VEC(ctx, 21));
    // 0x178da8: 0xb82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178dac: 0x7fb100e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), GPR_VEC(ctx, 17));
    // 0x178db0: 0x80a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x178db4: 0x7fb000d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), GPR_VEC(ctx, 16));
    // 0x178db8: 0xc0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x178dbc: 0xafa700b4
    WRITE32(ADD32(GPR_U32(ctx, 29), 180), GPR_U32(ctx, 7));
    // 0x178dc0: 0xa0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x178dc4: 0xafa800b8
    WRITE32(ADD32(GPR_U32(ctx, 29), 184), GPR_U32(ctx, 8));
    // 0x178dc8: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x178dcc: 0x7fbf0160
    WRITE128(ADD32(GPR_U32(ctx, 29), 352), GPR_VEC(ctx, 31));
    // 0x178dd0: 0x24060008
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 8));
    // 0x178dd4: 0x7fbe0150
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), GPR_VEC(ctx, 30));
    // 0x178dd8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178ddc: 0x7fb60130
    WRITE128(ADD32(GPR_U32(ctx, 29), 304), GPR_VEC(ctx, 22));
    // 0x178de0: 0x24080020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 32));
    // 0x178de4: 0x7fb40110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 20));
    // 0x178de8: 0x7fb30100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), GPR_VEC(ctx, 19));
    // 0x178dec: 0x7fb200f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), GPR_VEC(ctx, 18));
    // 0x178df0: 0xe7b50178
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 376), *(uint32_t*)&val); }
    // 0x178df4: 0xe7b40170
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 368), *(uint32_t*)&val); }
    // 0x178df8: 0xc05693c
    SET_GPR_U32(ctx, 31, 0x178e00);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 21), 20)));
    CploFindSwObjectsByClass__FP2SWi3CIDP2LOiPP2LO(rdram, ctx, runtime); return;
}


// Function: entry_178e00
// Address: 0x178e00 - 0x178e08

void entry_178e00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178e00: 0xc063582
    SET_GPR_U32(ctx, 31, 0x178e08);
    WRITE32(ADD32(GPR_U32(ctx, 29), 188), GPR_U32(ctx, 2));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_178e08
// Address: 0x178e08 - 0x178e10

void entry_178e08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178e08: 0xc0635aa
    SET_GPR_U32(ctx, 31, 0x178e10);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 16), 5));
    PvAllocStackClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_178e10
// Address: 0x178e10 - 0x178e34

void entry_178e10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178e10) {
        switch (ctx->pc) {
            case 0x178e28: ctx->pc = 0; goto label_178e28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178e10: 0x1a000032
    WRITE32(ADD32(GPR_U32(ctx, 29), 192), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 16) <= 0) {
        ctx->pc = 0x178EDC; return;
    }
    // 0x178e18: 0x220f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x178e1c: 0x200b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x178e20: 0x2454ffe4
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 2), 4294967268));
    // 0x178e24: 0x40982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
label_178e28:
    // 0x178e28: 0x8fd00000
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 30), 0)));
    // 0x178e2c: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x178e34);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_178e34
// Address: 0x178e34 - 0x178e58

void entry_178e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178e34: 0x10400026
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_178ed0(rdram, ctx, runtime); return;
    }
    // 0x178e3c: 0x26940020
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 32));
    // 0x178e40: 0x26530020
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 18), 32));
    // 0x178e44: 0x26f70001
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 23), 1));
    // 0x178e48: 0xae70ffe0
    WRITE32(ADD32(GPR_U32(ctx, 19), 4294967264), GPR_U32(ctx, 16));
    // 0x178e4c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x178e50: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x178e58);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 110));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_178e58
// Address: 0x178e58 - 0x178e74

void entry_178e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178e58: 0x10400013
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 160));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x178EA8; return;
    }
    // 0x178e60: 0x8e050018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x178e64: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178e68: 0x26a60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 21), 320));
    // 0x178e6c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x178e74);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_178e74
// Address: 0x178e74 - 0x178ea0

void entry_178e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x178e74: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x178e78: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x178e7c: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x178e80: 0x1040000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x178EAC; return;
    }
    // 0x178e88: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178e8c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178e90: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178e94: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178e98: 0x40f809
    SET_GPR_U32(ctx, 31, 0x178ea0);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_178ea0
// Address: 0x178ea0 - 0x178ed0

void entry_178ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178ea0) {
        switch (ctx->pc) {
            case 0x178ea8: ctx->pc = 0; goto label_178ea8;
            case 0x178eac: ctx->pc = 0; goto label_178eac;
            case 0x178eb0: ctx->pc = 0; goto label_178eb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178ea0: 0x10000003
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_178eb0;
    }
label_178ea8:
    // 0x178ea8: 0xae400004
    WRITE32(ADD32(GPR_U32(ctx, 18), 4), GPR_U32(ctx, 0));
label_178eac:
    // 0x178eac: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_178eb0:
    // 0x178eb0: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x178eb4: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x178eb8: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x178ebc: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x178ec0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x178ec4: 0x24a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 5), 16));
    // 0x178ec8: 0xc05e0b0
    SET_GPR_U32(ctx, 31, 0x178ed0);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001782c0(rdram, ctx, runtime); return;
}


// Function: entry_178ed0
// Address: 0x178ed0 - 0x178ef8

void entry_178ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178ed0) {
        switch (ctx->pc) {
            case 0x178edc: ctx->pc = 0; goto label_178edc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178ed0: 0x26d6ffff
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 4294967295));
    // 0x178ed4: 0x16c0ffd4
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 30), 4));
    if (GPR_U32(ctx, 22) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x178E28; return;
    }
label_178edc:
    // 0x178edc: 0x3c070018
    SET_GPR_U32(ctx, 7, ((uint32_t)24 << 16));
    // 0x178ee0: 0x8fa400c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x178ee4: 0x24e78d18
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4294937880));
    // 0x178ee8: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x178eec: 0x24060020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    // 0x178ef0: 0xc07d734
    SET_GPR_U32(ctx, 31, 0x178ef8);
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    qsort(rdram, ctx, runtime); return;
}


// Function: entry_178ef8
// Address: 0x178ef8 - 0x178f2c

void entry_178ef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178ef8) {
        switch (ctx->pc) {
            case 0x178f10: ctx->pc = 0; goto label_178f10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178ef8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x178efc: 0x1ae0001d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294946724)); ctx->f[20] = *(float*)&val; }
    if (GPR_S32(ctx, 23) <= 0) {
        ctx->pc = 0x178F74; return;
    }
    // 0x178f04: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x178f08: 0x8fb000c0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x178f0c: 0x0
    // NOP
label_178f10:
    // 0x178f10: 0x8fa600bc
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 188)));
    // 0x178f14: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x178f18: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x178f1c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x178f20: 0x27a80080
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 128));
    // 0x178f24: 0xc05e23c
    SET_GPR_U32(ctx, 31, 0x178f2c);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 176));
    FUN_001788f0(rdram, ctx, runtime); return;
}


// Function: entry_178f2c
// Address: 0x178f2c - 0x178fb4

void entry_178f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178f2c) {
        switch (ctx->pc) {
            case 0x178f64: ctx->pc = 0; goto label_178f64;
            case 0x178f74: ctx->pc = 0; goto label_178f74;
            case 0x178fa0: ctx->pc = 0; goto label_178fa0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178f2c: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178f30: 0x0
    // NOP
    // 0x178f34: 0x4500000b
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_178f64;
    }
    // 0x178f3c: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x178f40: 0x8fa400b4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x178f44: 0x4615a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178f48: 0x7ba20080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x178f4c: 0xc7a000b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[0] = *(float*)&val; }
    // 0x178f50: 0x7c830010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 3));
    // 0x178f54: 0x7c820000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 2));
    // 0x178f58: 0x8fa200b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 184)));
    // 0x178f5c: 0x45010046
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x179078; return;
    }
label_178f64:
    // 0x178f64: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x178f68: 0x237102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 23)));
    // 0x178f6c: 0x1440ffe8
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x178F10; return;
    }
label_178f74:
    // 0x178f74: 0x3c01447a
    SET_GPR_U32(ctx, 1, ((uint32_t)17530 << 16));
    // 0x178f78: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x178f7c: 0x4600a036
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178f80: 0x4501003d
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x179078; return;
    }
    // 0x178f88: 0x8ea22768
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 10088)));
    // 0x178f8c: 0x18400024
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x179020; return;
    }
    // 0x178f94: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x178f98: 0x26b02770
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 21), 10096));
    // 0x178f9c: 0x0
    // NOP
label_178fa0:
    // 0x178fa0: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x178fa4: 0x10800005
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 188)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x178FBC; return;
    }
    // 0x178fac: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x178fb4);
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_178fb4
// Address: 0x178fb4 - 0x178fd4

void entry_178fb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178fb4) {
        switch (ctx->pc) {
            case 0x178fbc: ctx->pc = 0; goto label_178fbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178fb4: 0x10400015
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 188)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17900C; return;
    }
label_178fbc:
    // 0x178fbc: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x178fc0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x178fc4: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x178fc8: 0x27a80080
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 128));
    // 0x178fcc: 0xc05e23c
    SET_GPR_U32(ctx, 31, 0x178fd4);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 176));
    FUN_001788f0(rdram, ctx, runtime); return;
}


// Function: entry_178fd4
// Address: 0x178fd4 - 0x179044

void entry_178fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x178fd4) {
        switch (ctx->pc) {
            case 0x17900c: ctx->pc = 0; goto label_17900c;
            case 0x179020: ctx->pc = 0; goto label_179020;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x178fd4: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178fd8: 0x0
    // NOP
    // 0x178fdc: 0x4500000b
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17900c;
    }
    // 0x178fe4: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x178fe8: 0x8fa400b4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x178fec: 0x4615a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x178ff0: 0x7ba20080
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x178ff4: 0xc7a000b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[0] = *(float*)&val; }
    // 0x178ff8: 0x7c830010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 3));
    // 0x178ffc: 0x7c820000
    WRITE128(ADD32(GPR_U32(ctx, 4), 0), GPR_VEC(ctx, 2));
    // 0x179000: 0x8fa200b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 184)));
    // 0x179004: 0x4501001c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x179078; return;
    }
label_17900c:
    // 0x17900c: 0x8ea22768
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 10088)));
    // 0x179010: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x179014: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x179018: 0x1440ffe1
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x178FA0; return;
    }
label_179020:
    // 0x179020: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x179024: 0xc460afa4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4294946724)); ctx->f[0] = *(float*)&val; }
    // 0x179028: 0x4600a032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17902c: 0x0
    // NOP
    // 0x179030: 0x45000011
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x179078; return;
    }
    // 0x179038: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17903c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x179044);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_179044
// Address: 0x179044 - 0x179080

void entry_179044(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179044) {
        switch (ctx->pc) {
            case 0x179078: ctx->pc = 0; goto label_179078;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179044: 0x8fa400b4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 180)));
    // 0x179048: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x17904c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x179050: 0xac800000
    WRITE32(ADD32(GPR_U32(ctx, 4), 0), GPR_U32(ctx, 0));
    // 0x179054: 0x3c013f40
    SET_GPR_U32(ctx, 1, ((uint32_t)16192 << 16));
    // 0x179058: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x17905c: 0x7aa20140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 21), 320)));
    // 0x179060: 0x7c820010
    WRITE128(ADD32(GPR_U32(ctx, 4), 16), GPR_VEC(ctx, 2));
    // 0x179064: 0xc4800018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[0] = *(float*)&val; }
    // 0x179068: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x17906c: 0xe4800018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 4), 24), *(uint32_t*)&val); }
    // 0x179070: 0x8fa200b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 184)));
    // 0x179074: 0xe4420000
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
label_179078:
    // 0x179078: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x179080);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_179080
// Address: 0x179080 - 0x1790b8

void entry_179080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179080: 0x7bbf0160
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x179084: 0x7bbe0150
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x179088: 0x7bb70140
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x17908c: 0x7bb60130
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x179090: 0x7bb50120
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x179094: 0x7bb40110
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x179098: 0x7bb30100
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x17909c: 0x7bb200f0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x1790a0: 0x7bb100e0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x1790a4: 0x7bb000d0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x1790a8: 0xc7b50178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[21] = *(float*)&val; }
    // 0x1790ac: 0xc7b40170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[20] = *(float*)&val; }
    // 0x1790b0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001790b8
// Address: 0x1790b8 - 0x1791d8

void FUN_001790b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1790b8) {
        switch (ctx->pc) {
            case 0x179154: ctx->pc = 0; goto label_179154;
            case 0x17916c: ctx->pc = 0; goto label_17916c;
            case 0x179188: ctx->pc = 0; goto label_179188;
            case 0x1791a0: ctx->pc = 0; goto label_1791a0;
            case 0x1791c0: ctx->pc = 0; goto label_1791c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1790b8: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x1790bc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1790c0: 0x7fb20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 18));
    // 0x1790c4: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x1790c8: 0x7fb10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 17));
    // 0x1790cc: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1790d0: 0xe7b40070
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
    // 0x1790d4: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1790d8: 0x7fbf0060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 31));
    // 0x1790dc: 0x7fb00030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 16));
    // 0x1790e0: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x1790e4: 0x8e242220
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x1790e8: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x1790ec: 0x2c820011
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 4), 17));
    // 0x1790f0: 0x10400059
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x179258; return;
    }
    // 0x1790f8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1790fc: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x179100: 0x2442afb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946736));
    // 0x179104: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x179108: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17910c: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x179114: 0x8e242204
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8708)));
    // 0x179118: 0x8c8200b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 184)));
    // 0x17911c: 0x144000a1
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1793A4; return;
    }
    // 0x179124: 0x1000004c
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x179258; return;
    }
    // 0x17912c: 0x8e23239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x179130: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x179134: 0x1062000d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17916c;
    }
    // 0x17913c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_179154;
    }
    // 0x179144: 0x50600016
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9120)));
        goto label_1791a0;
    }
    // 0x17914c: 0x1000002e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x179208; return;
    }
label_179154:
    // 0x179154: 0x1062000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_179188;
    }
    // 0x17915c: 0x10620091
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x1793A4; return;
    }
    // 0x179164: 0x10000028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x179208; return;
    }
label_17916c:
    // 0x17916c: 0x8e2423bc
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9148)));
    // 0x179170: 0x8c820050
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 80)));
    // 0x179174: 0x1440008b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1793A4; return;
    }
    // 0x17917c: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x179180: 0x10000035
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9156)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x179258; return;
    }
label_179188:
    // 0x179188: 0x8e2423b8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9144)));
    // 0x17918c: 0x8c82005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 92)));
    // 0x179190: 0x14400084
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1793A4; return;
    }
    // 0x179198: 0x1000002f
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x179258; return;
    }
label_1791a0:
    // 0x1791a0: 0x50800007
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9128)));
        goto label_1791c0;
    }
    // 0x1791a8: 0x8c82005c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 92)));
    // 0x1791ac: 0x1440007d
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1793A4; return;
    }
    // 0x1791b4: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1791b8: 0x10000027
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9124)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x179258; return;
    }
label_1791c0:
    // 0x1791c0: 0x8c820074
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 116)));
    // 0x1791c4: 0x14400077
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1793A4; return;
    }
    // 0x1791cc: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1791d0: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x1791d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_1791d8
// Address: 0x1791d8 - 0x1791f4

void entry_1791d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1791d8: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x1791dc: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1791e0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1791e4: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1791e8: 0xc7ac0024
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 36)); ctx->f[12] = *(float*)&val; }
    // 0x1791ec: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x1791f4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_1791f4
// Address: 0x1791f4 - 0x17930c

void entry_1791f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1791f4) {
        switch (ctx->pc) {
            case 0x179208: ctx->pc = 0; goto label_179208;
            case 0x179238: ctx->pc = 0; goto label_179238;
            case 0x179258: ctx->pc = 0; goto label_179258;
            case 0x179278: ctx->pc = 0; goto label_179278;
            case 0x1792e4: ctx->pc = 0; goto label_1792e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1791f4: 0x8e2223a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9128)));
    // 0x1791f8: 0xc441005c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 92)); ctx->f[1] = *(float*)&val; }
    // 0x1791fc: 0x10000016
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_179258;
    }
    // 0x179204: 0x8e220690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
label_179208:
    // 0x179208: 0x10400066
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1793A4; return;
    }
    // 0x179210: 0x8e2206c0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1728)));
    // 0x179214: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 1696)));
        goto label_179238;
    }
    // 0x17921c: 0xdc420538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 2), 1336)));
    // 0x179220: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x179224: 0x3197c
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << (32 + 5));
    // 0x179228: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x17922c: 0x5440005e
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
        ctx->pc = 0x1793A8; return;
    }
    // 0x179234: 0x7a2206a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 1696)));
label_179238:
    // 0x179238: 0x10000007
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_179258;
    }
    // 0x179240: 0x8e242208
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    // 0x179244: 0x8c820060
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 96)));
    // 0x179248: 0x14400056
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1793A4; return;
    }
    // 0x179250: 0xc6342410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9232)); ctx->f[20] = *(float*)&val; }
    // 0x179254: 0x80902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
label_179258:
    // 0x179258: 0x8e222768
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10088)));
    // 0x17925c: 0x24100001
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
    // 0x179260: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x179264: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x179268: 0x10400035
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x179340; return;
    }
    // 0x179270: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179274: 0x26232790
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 17), 10128));
label_179278:
    // 0x179278: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17927c: 0x16420019
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 2)) {
        goto label_1792e4;
    }
    // 0x179284: 0xd8620010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x179288: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17928c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x179290: 0x3c014248
    SET_GPR_U32(ctx, 1, ((uint32_t)16968 << 16));
    // 0x179294: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x179298: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17929c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x1792a0: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1792a4: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x1792a8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x1792ac: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x1792b0: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x1792b4: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x1792b8: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x1792bc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1792c0: 0x45000008
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1792e4;
    }
    // 0x1792c8: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x1792cc: 0x4600a001
    ctx->f[0] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x1792d0: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x1792d4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1792d8: 0x0
    // NOP
    // 0x1792dc: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
        goto label_1792e4;
    }
label_1792e4:
    // 0x1792e4: 0x5080000e
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
        ctx->pc = 0x179320; return;
    }
    // 0x1792ec: 0x12070010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 10160));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 7)) {
        ctx->pc = 0x179330; return;
    }
    // 0x1792f4: 0x78620010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 16)));
    // 0x1792f8: 0x78630000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x1792fc: 0x26252790
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 10128));
    // 0x179300: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x179304: 0xc07d6c2
    SET_GPR_U32(ctx, 31, 0x17930c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    memmove(rdram, ctx, runtime); return;
}


// Function: entry_17930c
// Address: 0x17930c - 0x179370

void entry_17930c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17930c) {
        switch (ctx->pc) {
            case 0x179320: ctx->pc = 0; goto label_179320;
            case 0x179330: ctx->pc = 0; goto label_179330;
            case 0x179340: ctx->pc = 0; goto label_179340;
            case 0x179354: ctx->pc = 0; goto label_179354;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17930c: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x179310: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x179314: 0x7e232790
    WRITE128(ADD32(GPR_U32(ctx, 17), 10128), GPR_VEC(ctx, 3));
    // 0x179318: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 17), 10144), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_179330;
    }
label_179320:
    // 0x179320: 0x24c60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 32));
    // 0x179324: 0x205102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 5)));
    // 0x179328: 0x1440ffd3
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x179278; return;
    }
label_179330:
    // 0x179330: 0x8e222768
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 10088)));
    // 0x179334: 0x202102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 2)));
    // 0x179338: 0x14400012
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x179384; return;
    }
label_179340:
    // 0x179340: 0x8e232768
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 10088)));
    // 0x179344: 0x2c620020
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 32));
    // 0x179348: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_179354;
    }
    // 0x179350: 0xae222768
    WRITE32(ADD32(GPR_U32(ctx, 17), 10088), GPR_U32(ctx, 2));
label_179354:
    // 0x179354: 0x8e262768
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 10088)));
    // 0x179358: 0x26302770
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 17), 10096));
    // 0x17935c: 0x26242790
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 10128));
    // 0x179360: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179364: 0x63140
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 5));
    // 0x179368: 0xc07d6c2
    SET_GPR_U32(ctx, 31, 0x179370);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4294967264));
    memmove(rdram, ctx, runtime); return;
}


// Function: entry_179370
// Address: 0x179370 - 0x179380

void entry_179370(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179370: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179374: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179378: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x179380);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 32));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_179380
// Address: 0x179380 - 0x1793c0

void entry_179380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179380) {
        switch (ctx->pc) {
            case 0x179384: ctx->pc = 0; goto label_179384;
            case 0x1793a4: ctx->pc = 0; goto label_1793a4;
            case 0x1793a8: ctx->pc = 0; goto label_1793a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179380: 0x7ba30000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_179384:
    // 0x179384: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x179388: 0xae322770
    WRITE32(ADD32(GPR_U32(ctx, 17), 10096), GPR_U32(ctx, 18));
    // 0x17938c: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x179390: 0x7e232780
    WRITE128(ADD32(GPR_U32(ctx, 17), 10112), GPR_VEC(ctx, 3));
    // 0x179394: 0xe6342774
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 17), 10100), *(uint32_t*)&val); }
    // 0x179398: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17939c: 0xe6202778
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 10104), *(uint32_t*)&val); }
    // 0x1793a0: 0x7bbf0060
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 96)));
label_1793a4:
    // 0x1793a4: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_1793a8:
    // 0x1793a8: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x1793ac: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x1793b0: 0xc7b40070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[20] = *(float*)&val; }
    // 0x1793b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1793bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1793c0; return;
}


// Function: FUN_001793c0
// Address: 0x1793c0 - 0x1793d4

void FUN_001793c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1793c0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x1793c4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1793c8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1793cc: 0xc06486a
    SET_GPR_U32(ctx, 31, 0x1793d4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    InitPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_1793d4
// Address: 0x1793d4 - 0x1793f0

void entry_1793d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1793d4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x1793d8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1793dc: 0xae020610
    WRITE32(ADD32(GPR_U32(ctx, 16), 1552), GPR_U32(ctx, 2));
    // 0x1793e0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1793e4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1793ec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1793f0; return;
}


// Function: FUN_001793f0
// Address: 0x1793f0 - 0x179408

void FUN_001793f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1793f0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x1793f4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x1793f8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1793fc: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x179400: 0xc049292
    SET_GPR_U32(ctx, 31, 0x179408);
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    PostAloLoad__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_179408
// Address: 0x179408 - 0x179420

void entry_179408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179408: 0x26110684
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1668));
    // 0x17940c: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x179410: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179414: 0x24c63ac8
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 15048));
    // 0x179418: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x179420);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 26));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_179420
// Address: 0x179420 - 0x179430

void entry_179420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179420: 0x8e050680
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1664)));
    // 0x179424: 0x8e0406e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1768)));
    // 0x179428: 0xc04ad6e
    SET_GPR_U32(ctx, 31, 0x179430);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    FUN_0012b5b8(rdram, ctx, runtime); return;
}


// Function: entry_179430
// Address: 0x179430 - 0x179450

void entry_179430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179430: 0x8e030650
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1616)));
    // 0x179434: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179438: 0x8e020660
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1632)));
    // 0x17943c: 0x2406ffff
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x179440: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179444: 0xac6200e0
    WRITE32(ADD32(GPR_U32(ctx, 3), 224), GPR_U32(ctx, 2));
    // 0x179448: 0xc06d8a4
    SET_GPR_U32(ctx, 31, 0x179450);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1620)));
    PsmaApplySm__FP2SMP3ALO3OIDi(rdram, ctx, runtime); return;
}


// Function: entry_179450
// Address: 0x179450 - 0x179478

void entry_179450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179450: 0x260b06c0
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 16), 1728));
    // 0x179454: 0xae020658
    WRITE32(ADD32(GPR_U32(ctx, 16), 1624), GPR_U32(ctx, 2));
    // 0x179458: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17945c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179460: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179464: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179468: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17946c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x179470: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x179478);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_179478
// Address: 0x179478 - 0x179498

void entry_179478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179478: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17947c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x179480: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x179484: 0x8e0406c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1728)));
    // 0x179488: 0x24060005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    // 0x17948c: 0xe6000684
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1668), *(uint32_t*)&val); }
    // 0x179490: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x179498);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_179498
// Address: 0x179498 - 0x1794a4

void entry_179498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179498: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17949c: 0xc05eafa
    SET_GPR_U32(ctx, 31, 0x1794a4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0017abe8(rdram, ctx, runtime); return;
}


// Function: entry_1794a4
// Address: 0x1794a4 - 0x1794c4

void entry_1794a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1794a4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x1794a8: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x1794ac: 0x26100650
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1616));
    // 0x1794b0: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x1794b4: 0xaa02028b
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 651); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1794b8: 0xba020288
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 648); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x1794bc: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x1794c4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 874));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_1794c4
// Address: 0x1794c4 - 0x1794e0

void entry_1794c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1794c4: 0xae020284
    WRITE32(ADD32(GPR_U32(ctx, 16), 644), GPR_U32(ctx, 2));
    // 0x1794c8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x1794cc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x1794d0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1794d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x1794dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x1794e0; return;
}


// Function: FUN_001794e0
// Address: 0x1794e0 - 0x179590

void FUN_001794e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1794e0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1794e4: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x1794e8: 0x24433c00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 15360));
    // 0x1794ec: 0x25073c10
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 8), 15376));
    // 0x1794f0: 0xc48706fc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 1788)); ctx->f[7] = *(float*)&val; }
    // 0x1794f4: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x1794f8: 0xc4880700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 1792)); ctx->f[8] = *(float*)&val; }
    // 0x1794fc: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x179500: 0xc4e40008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 8)); ctx->f[4] = *(float*)&val; }
    // 0x179504: 0x46013842
    ctx->f[1] = FPU_MUL_S(ctx->f[7], ctx->f[1]);
    // 0x179508: 0xc4650004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[5] = *(float*)&val; }
    // 0x17950c: 0x46044102
    ctx->f[4] = FPU_MUL_S(ctx->f[8], ctx->f[4]);
    // 0x179510: 0xc4e20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[2] = *(float*)&val; }
    // 0x179514: 0xc4433c00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15360)); ctx->f[3] = *(float*)&val; }
    // 0x179518: 0x46012940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[1]);
    // 0x17951c: 0xc5003c10
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 15376)); ctx->f[0] = *(float*)&val; }
    // 0x179520: 0x46041080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[4]);
    // 0x179524: 0x44803000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 0);
    // 0x179528: 0x460539c2
    ctx->f[7] = FPU_MUL_S(ctx->f[7], ctx->f[5]);
    // 0x17952c: 0x46024202
    ctx->f[8] = FPU_MUL_S(ctx->f[8], ctx->f[2]);
    // 0x179530: 0x460718c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[7]);
    // 0x179534: 0x46080000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[8]);
    // 0x179538: 0x44023000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[6]);
    // 0x17953c: 0x44081800
    SET_GPR_U32(ctx, 8, *(uint32_t*)&ctx->f[3]);
    // 0x179540: 0x71021488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 8), GPR_VEC(ctx, 2)));
    // 0x179544: 0x44080000
    SET_GPR_U32(ctx, 8, *(uint32_t*)&ctx->f[0]);
    // 0x179548: 0x71021389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 8), GPR_VEC(ctx, 2)));
    // 0x17954c: 0x7ca20000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 2));
    // 0x179550: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x179554: 0xc4630004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[3] = *(float*)&val; }
    // 0x179558: 0xc4810708
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 1800)); ctx->f[1] = *(float*)&val; }
    // 0x17955c: 0xc4e20004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 4)); ctx->f[2] = *(float*)&val; }
    // 0x179560: 0xc4800704
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 1796)); ctx->f[0] = *(float*)&val; }
    // 0x179564: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x179568: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x17956c: 0x44023000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[6]);
    // 0x179570: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x179574: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x179578: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x17957c: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x179580: 0x7cc20000
    WRITE128(ADD32(GPR_U32(ctx, 6), 0), GPR_VEC(ctx, 2));
    // 0x179584: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x179588: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00179590
// Address: 0x179590 - 0x1795dc

void FUN_00179590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179590) {
        switch (ctx->pc) {
            case 0x1795d0: ctx->pc = 0; goto label_1795d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179590: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x179594: 0x7fb10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 17));
    // 0x179598: 0xe7b40050
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x17959c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1795a0: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x1795a4: 0x7fb00020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 16));
    // 0x1795a8: 0x8e230610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 1552)));
    // 0x1795ac: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    // 0x1795b0: 0x14400007
    ctx->f[20] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_1795d0;
    }
    // 0x1795b8: 0x28620004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 4));
    // 0x1795bc: 0x14400009
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x1795E4; return;
    }
    // 0x1795c4: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x1795c8: 0x10620017
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x179628; return;
    }
label_1795d0:
    // 0x1795d0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1795d4: 0xc06e4ce
    SET_GPR_U32(ctx, 31, 0x1795dc);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    PresetSoAccel__FP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_1795dc
// Address: 0x1795dc - 0x1795f4

void entry_1795dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1795dc) {
        switch (ctx->pc) {
            case 0x1795e4: ctx->pc = 0; goto label_1795e4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1795dc: 0x10000027
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17967C; return;
    }
label_1795e4:
    // 0x1795e4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x1795e8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x1795ec: 0xc05e538
    SET_GPR_U32(ctx, 31, 0x1795f4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001794e0(rdram, ctx, runtime); return;
}


// Function: entry_1795f4
// Address: 0x1795f4 - 0x179620

void entry_1795f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1795f4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x1795f8: 0x8e240668
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1640)));
    // 0x1795fc: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x179600: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179604: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x179608: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17960c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x179610: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179614: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    // 0x179618: 0xc049f98
    SET_GPR_U32(ctx, 31, 0x179620);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2(rdram, ctx, runtime); return;
}


// Function: entry_179620
// Address: 0x179620 - 0x179660

void entry_179620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179620) {
        switch (ctx->pc) {
            case 0x179628: ctx->pc = 0; goto label_179628;
            case 0x179640: ctx->pc = 0; goto label_179640;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179620: 0x10000007
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_179640;
    }
label_179628:
    // 0x179628: 0x7a240100
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x17962c: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x179630: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x179634: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x179638: 0x7fa40000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 4));
    // 0x17963c: 0x7fa30010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
label_179640:
    // 0x179640: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x179644: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x179648: 0x24c63c20
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 15392));
    // 0x17964c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x179650: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x179654: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x179658: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x179660);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 15408));
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_179660
// Address: 0x179660 - 0x179678

void entry_179660(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179660: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x179664: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x179668: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x17966c: 0x24c63c40
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 15424));
    // 0x179670: 0xc06e744
    SET_GPR_U32(ctx, 31, 0x179678);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 4), 1568));
    AccelSoTowardMatSmooth__FP2SOfP7MATRIX3P3SMP(rdram, ctx, runtime); return;
}


// Function: entry_179678
// Address: 0x179678 - 0x179690

void entry_179678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179678) {
        switch (ctx->pc) {
            case 0x17967c: ctx->pc = 0; goto label_17967c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179678: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
label_17967c:
    // 0x17967c: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x179680: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x179684: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x179688: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00179690
// Address: 0x179690 - 0x1796a8

void FUN_00179690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179690: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x179694: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179698: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17969c: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x1796a0: 0xc06f022
    SET_GPR_U32(ctx, 31, 0x1796a8);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    ProjectSoTransform__FP2SOfi(rdram, ctx, runtime); return;
}


// Function: entry_1796a8
// Address: 0x1796a8 - 0x1796c0

void entry_1796a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1796a8: 0x8e020000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x1796ac: 0x8c420058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 88)));
    // 0x1796b0: 0x10400004
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x1796C4; return;
    }
    // 0x1796b8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x1796c0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_1796c0
// Address: 0x1796c0 - 0x1796d0

void entry_1796c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1796c0) {
        switch (ctx->pc) {
            case 0x1796c4: ctx->pc = 0; goto label_1796c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1796c0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_1796c4:
    // 0x1796c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x1796c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_001796d0
// Address: 0x1796d0 - 0x1796f4

void FUN_001796d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1796d0: 0x27bdff80
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967168));
    // 0x1796d4: 0x7fb00030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 16));
    // 0x1796d8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x1796dc: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x1796e0: 0x7fb10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 17));
    // 0x1796e4: 0xe7b60070
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 112), *(uint32_t*)&val); }
    // 0x1796e8: 0xe7b50068
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    // 0x1796ec: 0xc064ad6
    SET_GPR_U32(ctx, 31, 0x1796f4);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    UpdatePo__FP2POf(rdram, ctx, runtime); return;
}


// Function: entry_1796f4
// Address: 0x1796f4 - 0x179720

void entry_1796f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1796f4: 0x8e02070c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1804)));
    // 0x1796f8: 0x10400031
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_1797c0(rdram, ctx, runtime); return;
    }
    // 0x179700: 0xae00070c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1804), GPR_U32(ctx, 0));
    // 0x179704: 0x8e242e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x179708: 0x50800020
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1764)));
        ctx->pc = 0x17978C; return;
    }
    // 0x179710: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x179714: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x179718: 0x40f809
    SET_GPR_U32(ctx, 31, 0x179720);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_179720
// Address: 0x179720 - 0x17972c

void entry_179720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179720: 0x8e242e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x179724: 0xc064a64
    SET_GPR_U32(ctx, 31, 0x17972c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    SetPoPlayable__FP2POi(rdram, ctx, runtime); return;
}


// Function: entry_17972c
// Address: 0x17972c - 0x17973c

void entry_17972c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17972c: 0x8e242e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x179730: 0x24060002
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    // 0x179734: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17973c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17973c
// Address: 0x17973c - 0x179750

void entry_17973c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17973c: 0x8e242e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x179740: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x179744: 0x8c43008c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 140)));
    // 0x179748: 0x60f809
    SET_GPR_U32(ctx, 31, 0x179750);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1764)));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_179750
// Address: 0x179750 - 0x179764

void entry_179750(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179750: 0x8e222e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x179754: 0x78430140
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x179758: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17975c: 0xc064a74
    SET_GPR_U32(ctx, 31, 0x179764);
    WRITE128(ADD32(GPR_U32(ctx, 2), 1376), GPR_VEC(ctx, 3));
    SwitchToPo__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_179764
// Address: 0x179764 - 0x179774

void entry_179764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179764: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x179768: 0x24050005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 5));
    // 0x17976c: 0xc075c26
    SET_GPR_U32(ctx, 31, 0x179774);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    InitZpr__FP3ZPR3ZPKP2LO(rdram, ctx, runtime); return;
}


// Function: entry_179774
// Address: 0x179774 - 0x179788

void entry_179774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179774: 0x8e242e10
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 11792)));
    // 0x179778: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17977c: 0x8c620140
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 320)));
    // 0x179780: 0x40f809
    SET_GPR_U32(ctx, 31, 0x179788);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_179788
// Address: 0x179788 - 0x17979c

void entry_179788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179788) {
        switch (ctx->pc) {
            case 0x17978c: ctx->pc = 0; goto label_17978c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179788: 0x8e0406e4
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1764)));
label_17978c:
    // 0x17978c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x179790: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x179794: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17979c);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17979c
// Address: 0x17979c - 0x1797c0

void entry_17979c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17979c: 0xde030538
    SET_GPR_U64(ctx, 3, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x1797a0: 0x34028000
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 0), 32768));
    // 0x1797a4: 0x216f8
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 2) << 27);
    // 0x1797a8: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x1797ac: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x1797b0: 0x621825
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x1797b4: 0x24060007
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 7));
    // 0x1797b8: 0xc04e2f8
    SET_GPR_U32(ctx, 31, 0x1797c0);
    WRITE64(ADD32(GPR_U32(ctx, 16), 1336), GPR_U64(ctx, 3));
    InvalidateSwXpForObject__FP2SWP2SOi(rdram, ctx, runtime); return;
}


// Function: entry_1797c0
// Address: 0x1797c0 - 0x179804

void entry_1797c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x1797c0) {
        switch (ctx->pc) {
            case 0x1797fc: ctx->pc = 0; goto label_1797fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x1797c0: 0x8e0206d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1744)));
    // 0x1797c4: 0x1040000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_1797fc;
    }
    // 0x1797cc: 0x8e030610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x1797d0: 0x1062000a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_1797fc;
    }
    // 0x1797d8: 0xc60206d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1752)); ctx->f[2] = *(float*)&val; }
    // 0x1797dc: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x1797e0: 0x3c014000
    SET_GPR_U32(ctx, 1, ((uint32_t)16384 << 16));
    // 0x1797e4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x1797e8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x1797ec: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1797f0: 0x0
    // NOP
    // 0x1797f4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 1744), GPR_U32(ctx, 0));
        goto label_1797fc;
    }
label_1797fc:
    // 0x1797fc: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x179804);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_179804
// Address: 0x179804 - 0x179838

void entry_179804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179804: 0x1602000e
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x179840; return;
    }
    // 0x17980c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x179810: 0x8c622c6c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 11372)));
    // 0x179814: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x179818: 0x1440000a
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x179844; return;
    }
    // 0x179820: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x179824: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x179828: 0x8c830650
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1616)));
    // 0x17982c: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x179830: 0x40f809
    SET_GPR_U32(ctx, 31, 0x179838);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1616));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_179838
// Address: 0x179838 - 0x179854

void entry_179838(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179838) {
        switch (ctx->pc) {
            case 0x179840: ctx->pc = 0; goto label_179840;
            case 0x179844: ctx->pc = 0; goto label_179844;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179838: 0x10000007
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1640)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x179858; return;
    }
label_179840:
    // 0x179840: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_179844:
    // 0x179844: 0x8c830650
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1616)));
    // 0x179848: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x17984c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x179854);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1616));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_179854
// Address: 0x179854 - 0x17987c

void entry_179854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179854) {
        switch (ctx->pc) {
            case 0x179858: ctx->pc = 0; goto label_179858;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179854: 0x8e040668
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1640)));
label_179858:
    // 0x179858: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17985c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179860: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179864: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179868: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17986c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x179870: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x179874: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x17987c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 256));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_17987c
// Address: 0x17987c - 0x1798a0

void entry_17987c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17987c: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x179880: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x179884: 0xda010150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x179888: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x17988c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x179890: 0x8e050668
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1640)));
    // 0x179894: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x179898: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x1798a0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_1798a0
// Address: 0x1798a0 - 0x17990c

void entry_1798a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x1798a0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x1798a4: 0xc7a60014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[6] = *(float*)&val; }
    // 0x1798a8: 0xc4443c4c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15436)); ctx->f[4] = *(float*)&val; }
    // 0x1798ac: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x1798b0: 0x3c01bada
    SET_GPR_U32(ctx, 1, ((uint32_t)47834 << 16));
    // 0x1798b4: 0x3421740e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 29710));
    // 0x1798b8: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1798bc: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x1798c0: 0x4604b001
    ctx->f[0] = FPU_SUB_S(ctx->f[22], ctx->f[4]);
    // 0x1798c4: 0xc7a50018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[5] = *(float*)&val; }
    // 0x1798c8: 0x3c01bb5a
    SET_GPR_U32(ctx, 1, ((uint32_t)47962 << 16));
    // 0x1798cc: 0x3421740e
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 29710));
    // 0x1798d0: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x1798d4: 0x46023502
    ctx->f[20] = FPU_MUL_S(ctx->f[6], ctx->f[2]);
    // 0x1798d8: 0xc6010704
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1796)); ctx->f[1] = *(float*)&val; }
    // 0x1798dc: 0x46032d42
    ctx->f[21] = FPU_MUL_S(ctx->f[5], ctx->f[3]);
    // 0x1798e0: 0xc6020708
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1800)); ctx->f[2] = *(float*)&val; }
    // 0x1798e4: 0x46010042
    ctx->f[1] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x1798e8: 0x8e060660
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 1632)));
    // 0x1798ec: 0x46020002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x1798f0: 0x8e050668
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 1640)));
    // 0x1798f4: 0x46152082
    ctx->f[2] = FPU_MUL_S(ctx->f[4], ctx->f[21]);
    // 0x1798f8: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x1798fc: 0x46142102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[20]);
    // 0x179900: 0x46001540
    ctx->f[21] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x179904: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17990c);
    ctx->f[20] = FPU_ADD_S(ctx->f[4], ctx->f[1]);
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17990c
// Address: 0x17990c - 0x179a48

void entry_17990c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17990c) {
        switch (ctx->pc) {
            case 0x179924: ctx->pc = 0; goto label_179924;
            case 0x17994c: ctx->pc = 0; goto label_17994c;
            case 0x179960: ctx->pc = 0; goto label_179960;
            case 0x179970: ctx->pc = 0; goto label_179970;
            case 0x1799a0: ctx->pc = 0; goto label_1799a0;
            case 0x1799a4: ctx->pc = 0; goto label_1799a4;
            case 0x1799c8: ctx->pc = 0; goto label_1799c8;
            case 0x1799d8: ctx->pc = 0; goto label_1799d8;
            case 0x1799dc: ctx->pc = 0; goto label_1799dc;
            case 0x179a08: ctx->pc = 0; goto label_179a08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17990c: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x179910: 0xc7a00020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 32)); ctx->f[0] = *(float*)&val; }
    // 0x179914: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x179918: 0x0
    // NOP
    // 0x17991c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[20] = FPU_NEG_S(ctx->f[20]);
        goto label_179924;
    }
label_179924:
    // 0x179924: 0x4600a045
    ctx->f[1] = FPU_ABS_S(ctx->f[20]);
    // 0x179928: 0x4600a805
    ctx->f[0] = FPU_ABS_S(ctx->f[21]);
    // 0x17992c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x179930: 0x4601b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x179934: 0x0
    // NOP
    // 0x179938: 0x45020004
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_NEG_S(ctx->f[20]);
        goto label_17994c;
    }
    // 0x179940: 0x4601ad43
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[21] = copysignf(INFINITY, ctx->f[21] * 0.0f); } else ctx->f[21] = ctx->f[21] / ctx->f[1];
    // 0x179944: 0x4601a503
    if (ctx->f[1] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[20] * 0.0f); } else ctx->f[20] = ctx->f[20] / ctx->f[1];
    // 0x179948: 0x4600a007
    ctx->f[0] = FPU_NEG_S(ctx->f[20]);
label_17994c:
    // 0x17994c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x179950: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_179960;
    }
    // 0x179958: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_179970;
    }
label_179960:
    // 0x179960: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x179964: 0x0
    // NOP
    // 0x179968: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[22]);
        goto label_179970;
    }
label_179970:
    // 0x179970: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x179974: 0xe6000690
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1680), *(uint32_t*)&val); }
    // 0x179978: 0x4601a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17997c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x179980: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x179984: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_NEG_S(ctx->f[21]);
        goto label_1799a4;
    }
    // 0x17998c: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x179990: 0x0
    // NOP
    // 0x179994: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[20]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1799a0;
    }
    // 0x17999c: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
label_1799a0:
    // 0x1799a0: 0x4600a807
    ctx->f[0] = FPU_NEG_S(ctx->f[21]);
label_1799a4:
    // 0x1799a4: 0xe601069c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1692), *(uint32_t*)&val); }
    // 0x1799a8: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x1799ac: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1799b0: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x1799b4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1799b8: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_1799c8;
    }
    // 0x1799c0: 0x10000006
    ctx->f[0] = FPU_MOV_S(ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_1799dc;
    }
label_1799c8:
    // 0x1799c8: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1799cc: 0x0
    // NOP
    // 0x1799d0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[2]);
        goto label_1799d8;
    }
label_1799d8:
    // 0x1799d8: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
label_1799dc:
    // 0x1799dc: 0xe60006a8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1704), *(uint32_t*)&val); }
    // 0x1799e0: 0x4601a834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[21], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1799e4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x1799e8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x1799ec: 0x45010006
    ctx->f[5] = FPU_MOV_S(ctx->f[1]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_179a08;
    }
    // 0x1799f4: 0x46150034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x1799f8: 0x0
    // NOP
    // 0x1799fc: 0x45000002
    ctx->f[5] = FPU_MOV_S(ctx->f[21]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_179a08;
    }
    // 0x179a04: 0x46000146
    ctx->f[5] = FPU_MOV_S(ctx->f[0]);
label_179a08:
    // 0x179a08: 0xc6020690
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1680)); ctx->f[2] = *(float*)&val; }
    // 0x179a0c: 0x26070684
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1668));
    // 0x179a10: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x179a14: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x179a18: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x179a1c: 0xc603069c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1692)); ctx->f[3] = *(float*)&val; }
    // 0x179a20: 0x24060005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    // 0x179a24: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x179a28: 0xc60106a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1704)); ctx->f[1] = *(float*)&val; }
    // 0x179a2c: 0x8e0406c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1728)));
    // 0x179a30: 0xe60506b4
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 1716), *(uint32_t*)&val); }
    // 0x179a34: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x179a38: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x179a3c: 0x46050001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[5]);
    // 0x179a40: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x179a48);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1668), *(uint32_t*)&val); }
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_179a48
// Address: 0x179a48 - 0x179a68

void entry_179a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179a48: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x179a4c: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x179a50: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x179a54: 0xc7b60070
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 112)); ctx->f[22] = *(float*)&val; }
    // 0x179a58: 0xc7b50068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[21] = *(float*)&val; }
    // 0x179a5c: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x179a60: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 128));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_00179a68
// Address: 0x179a68 - 0x179ac8

void FUN_00179a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179a68: 0x27bdfc70
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294966384));
    // 0x179a6c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x179a70: 0x7fb60320
    WRITE128(ADD32(GPR_U32(ctx, 29), 800), GPR_VEC(ctx, 22));
    // 0x179a74: 0x7fb40300
    WRITE128(ADD32(GPR_U32(ctx, 29), 768), GPR_VEC(ctx, 20));
    // 0x179a78: 0xa0b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x179a7c: 0xe7b70378
    { float val = ctx->f[23]; WRITE32(ADD32(GPR_U32(ctx, 29), 888), *(uint32_t*)&val); }
    // 0x179a80: 0x80a02d
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x179a84: 0x7fbf0350
    WRITE128(ADD32(GPR_U32(ctx, 29), 848), GPR_VEC(ctx, 31));
    // 0x179a88: 0x7fbe0340
    WRITE128(ADD32(GPR_U32(ctx, 29), 832), GPR_VEC(ctx, 30));
    // 0x179a8c: 0x7fb70330
    WRITE128(ADD32(GPR_U32(ctx, 29), 816), GPR_VEC(ctx, 23));
    // 0x179a90: 0x7fb50310
    WRITE128(ADD32(GPR_U32(ctx, 29), 784), GPR_VEC(ctx, 21));
    // 0x179a94: 0x7fb302f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 752), GPR_VEC(ctx, 19));
    // 0x179a98: 0x7fb202e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 736), GPR_VEC(ctx, 18));
    // 0x179a9c: 0x7fb102d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 720), GPR_VEC(ctx, 17));
    // 0x179aa0: 0x7fb002c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 704), GPR_VEC(ctx, 16));
    // 0x179aa4: 0xe7b80380
    { float val = ctx->f[24]; WRITE32(ADD32(GPR_U32(ctx, 29), 896), *(uint32_t*)&val); }
    // 0x179aa8: 0xe7b60370
    { float val = ctx->f[22]; WRITE32(ADD32(GPR_U32(ctx, 29), 880), *(uint32_t*)&val); }
    // 0x179aac: 0xe7b50368
    { float val = ctx->f[21]; WRITE32(ADD32(GPR_U32(ctx, 29), 872), *(uint32_t*)&val); }
    // 0x179ab0: 0xe7b40360
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 864), *(uint32_t*)&val); }
    // 0x179ab4: 0x8e830610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1552)));
    // 0x179ab8: 0x1462002c
    ctx->f[23] = FPU_MOV_S(ctx->f[12]);
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        entry_179b6c(rdram, ctx, runtime); return;
    }
    // 0x179ac0: 0xc058316
    SET_GPR_U32(ctx, 31, 0x179ac8);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_179ac8
// Address: 0x179ac8 - 0x179b04

void entry_179ac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179ac8) {
        switch (ctx->pc) {
            case 0x179af8: ctx->pc = 0; goto label_179af8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179ac8: 0x50400029
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 22), 168)));
        ctx->pc = 0x179B70; return;
    }
    // 0x179ad0: 0x8e820618
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1560)));
    // 0x179ad4: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
        goto label_179af8;
    }
    // 0x179adc: 0xc4410018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[1] = *(float*)&val; }
    // 0x179ae0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x179ae4: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x179ae8: 0x0
    // NOP
    // 0x179aec: 0x45020007
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 22), 170)));
        ctx->pc = 0x179B0C; return;
    }
    // 0x179af4: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
label_179af8:
    // 0x179af8: 0x8c620150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x179afc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x179b04);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_179b04
// Address: 0x179b04 - 0x179b20

void entry_179b04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179b04) {
        switch (ctx->pc) {
            case 0x179b0c: ctx->pc = 0; goto label_179b0c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179b04: 0x1000001a
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 22), 168)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x179B70; return;
    }
label_179b0c:
    // 0x179b0c: 0x30420040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64));
    // 0x179b10: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x179B2C; return;
    }
    // 0x179b18: 0xc05bb08
    SET_GPR_U32(ctx, 31, 0x179b20);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 64));
    SetJoyBtnHandled__FP3JOYUs(rdram, ctx, runtime); return;
}


// Function: entry_179b20
// Address: 0x179b20 - 0x179b6c

void entry_179b20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179b20) {
        switch (ctx->pc) {
            case 0x179b2c: ctx->pc = 0; goto label_179b2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179b20: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x179b24: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x179b28: 0xe68006dc
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 1756), *(uint32_t*)&val); }
label_179b2c:
    // 0x179b2c: 0x8e8206e0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1760)));
    // 0x179b30: 0x1040000e
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_179b6c(rdram, ctx, runtime); return;
    }
    // 0x179b38: 0xc68206dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1756)); ctx->f[2] = *(float*)&val; }
    // 0x179b3c: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x179b40: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x179b44: 0xc4413c50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15440)); ctx->f[1] = *(float*)&val; }
    // 0x179b48: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x179b4c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x179b50: 0x0
    // NOP
    // 0x179b54: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 22), 168)));
        ctx->pc = 0x179B70; return;
    }
    // 0x179b5c: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x179b60: 0x8c620150
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 336)));
    // 0x179b64: 0x40f809
    SET_GPR_U32(ctx, 31, 0x179b6c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_179b6c
// Address: 0x179b6c - 0x179b88

void entry_179b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179b6c) {
        switch (ctx->pc) {
            case 0x179b70: ctx->pc = 0; goto label_179b70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179b6c: 0x96c200a8
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 22), 168)));
label_179b70:
    // 0x179b70: 0x30420080
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 128));
    // 0x179b74: 0x50400013
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1552)));
        ctx->pc = 0x179BC4; return;
    }
    // 0x179b7c: 0x8e840658
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 1624)));
    // 0x179b80: 0xc06d966
    SET_GPR_U32(ctx, 31, 0x179b88);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 640));
    GetSmaCur__FP3SMAP3OID(rdram, ctx, runtime); return;
}


// Function: entry_179b88
// Address: 0x179b88 - 0x179bc0

void entry_179b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179b88) {
        switch (ctx->pc) {
            case 0x179bb0: ctx->pc = 0; goto label_179bb0;
            case 0x179bb4: ctx->pc = 0; goto label_179bb4;
            case 0x179bb8: ctx->pc = 0; goto label_179bb8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179b88: 0x8fa30280
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 640)));
    // 0x179b8c: 0x2862044f
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1103));
    // 0x179b90: 0x54400009
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 1624)));
        goto label_179bb8;
    }
    // 0x179b98: 0x28620451
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1105));
    // 0x179b9c: 0x14400004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1105));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_179bb0;
    }
    // 0x179ba4: 0x28620453
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 1107));
    // 0x179ba8: 0x10400002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1103));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_179bb4;
    }
label_179bb0:
    // 0x179bb0: 0xafa20280
    WRITE32(ADD32(GPR_U32(ctx, 29), 640), GPR_U32(ctx, 2));
label_179bb4:
    // 0x179bb4: 0x8e840658
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 1624)));
label_179bb8:
    // 0x179bb8: 0xc06d936
    SET_GPR_U32(ctx, 31, 0x179bc0);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 640)));
    SetSmaGoal__FP3SMA3OID(rdram, ctx, runtime); return;
}


// Function: entry_179bc0
// Address: 0x179bc0 - 0x179bf4

void entry_179bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179bc0) {
        switch (ctx->pc) {
            case 0x179bc4: ctx->pc = 0; goto label_179bc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179bc0: 0x8e830610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1552)));
label_179bc4:
    // 0x179bc4: 0x28620005
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    // 0x179bc8: 0x1040024c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17A4FC; return;
    }
    // 0x179bd0: 0x5440024b
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
        ctx->pc = 0x17A500; return;
    }
    // 0x179bd8: 0x8e860664
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 1636)));
    // 0x179bdc: 0x27b30090
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 144));
    // 0x179be0: 0x8e850660
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 1632)));
    // 0x179be4: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x179be8: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x179bec: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x179bf4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_179bf4
// Address: 0x179bf4 - 0x179c68

void entry_179bf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179bf4: 0x3c110026
    SET_GPR_U32(ctx, 17, ((uint32_t)38 << 16));
    // 0x179bf8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x179bfc: 0xc7a00094
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 148)); ctx->f[0] = *(float*)&val; }
    // 0x179c00: 0xc4413ca0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15520)); ctx->f[1] = *(float*)&val; }
    // 0x179c04: 0x40f02d
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x179c08: 0x24423ca0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 15520));
    // 0x179c0c: 0x26323c78
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 17), 15480));
    // 0x179c10: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x179c14: 0xc4430004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    // 0x179c18: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x179c1c: 0xc7a10098
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 152)); ctx->f[1] = *(float*)&val; }
    // 0x179c20: 0xc4423cb0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15536)); ctx->f[2] = *(float*)&val; }
    // 0x179c24: 0x40b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x179c28: 0x46030543
    if (ctx->f[3] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[21] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[21] = ctx->f[0] / ctx->f[3];
    // 0x179c2c: 0xc64d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[13] = *(float*)&val; }
    // 0x179c30: 0x24423cb0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 15536));
    // 0x179c34: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x179c38: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x179c3c: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x179c40: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x179c44: 0x26103c58
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 15448));
    // 0x179c48: 0xc68c06ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1772)); ctx->f[12] = *(float*)&val; }
    // 0x179c4c: 0x46000d83
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[22] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[22] = ctx->f[1] / ctx->f[0];
    // 0x179c50: 0x27a50284
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 644));
    // 0x179c54: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x179c58: 0x460dab40
    ctx->f[13] = FPU_ADD_S(ctx->f[21], ctx->f[13]);
    // 0x179c5c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179c60: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x179c68);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_179c68
// Address: 0x179c68 - 0x179c88

void entry_179c68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179c68: 0xc62d3c78
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 15480)); ctx->f[13] = *(float*)&val; }
    // 0x179c6c: 0x27a50288
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 648));
    // 0x179c70: 0xafb3029c
    WRITE32(ADD32(GPR_U32(ctx, 29), 668), GPR_U32(ctx, 19));
    // 0x179c74: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x179c78: 0x460dab40
    ctx->f[13] = FPU_ADD_S(ctx->f[21], ctx->f[13]);
    // 0x179c7c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179c80: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x179c88);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1772)); ctx->f[12] = *(float*)&val; }
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_179c88
// Address: 0x179c88 - 0x179ca4

void entry_179c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179c88: 0xc64d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 4)); ctx->f[13] = *(float*)&val; }
    // 0x179c8c: 0x27a5028c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 652));
    // 0x179c90: 0xc68c06f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1776)); ctx->f[12] = *(float*)&val; }
    // 0x179c94: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x179c98: 0x460db340
    ctx->f[13] = FPU_ADD_S(ctx->f[22], ctx->f[13]);
    // 0x179c9c: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x179ca4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_179ca4
// Address: 0x179ca4 - 0x179cc0

void entry_179ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179ca4: 0xc62d3c78
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 15480)); ctx->f[13] = *(float*)&val; }
    // 0x179ca8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179cac: 0xc68c06f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1776)); ctx->f[12] = *(float*)&val; }
    // 0x179cb0: 0x27a50290
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 656));
    // 0x179cb4: 0x460db340
    ctx->f[13] = FPU_ADD_S(ctx->f[22], ctx->f[13]);
    // 0x179cb8: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x179cc0);
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_179cc0
// Address: 0x179cc0 - 0x179d7c

void entry_179cc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179cc0) {
        switch (ctx->pc) {
            case 0x179cdc: ctx->pc = 0; goto label_179cdc;
            case 0x179d3c: ctx->pc = 0; goto label_179d3c;
            case 0x179d60: ctx->pc = 0; goto label_179d60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179cc0: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x179cc4: 0x8c8323c0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 9152)));
    // 0x179cc8: 0x8c6219ec
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 6636)));
    // 0x179ccc: 0x30420800
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2048));
    // 0x179cd0: 0x10400002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 68)); ctx->f[24] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_179cdc;
    }
    // 0x179cd8: 0x4600c607
    ctx->f[24] = FPU_NEG_S(ctx->f[24]);
label_179cdc:
    // 0x179cdc: 0x8e830610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1552)));
    // 0x179ce0: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x179ce4: 0x14620015
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 648)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_179d3c;
    }
    // 0x179cec: 0xc7a70288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 648)); ctx->f[7] = *(float*)&val; }
    // 0x179cf0: 0xc7a60290
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 656)); ctx->f[6] = *(float*)&val; }
    // 0x179cf4: 0xc7a30284
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 644)); ctx->f[3] = *(float*)&val; }
    // 0x179cf8: 0xc7a2028c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 652)); ctx->f[2] = *(float*)&val; }
    // 0x179cfc: 0x460718c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[7]);
    // 0x179d00: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x179d04: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x179d08: 0x46061081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[6]);
    // 0x179d0c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x179d10: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x179d14: 0xc6c00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 64)); ctx->f[0] = *(float*)&val; }
    // 0x179d18: 0x4605c040
    ctx->f[1] = FPU_ADD_S(ctx->f[24], ctx->f[5]);
    // 0x179d1c: 0x460418c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[4]);
    // 0x179d20: 0x46041082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x179d24: 0x46050000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[5]);
    // 0x179d28: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x179d2c: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x179d30: 0x46013500
    ctx->f[20] = FPU_ADD_S(ctx->f[6], ctx->f[1]);
    // 0x179d34: 0x1000000a
    ctx->f[13] = FPU_ADD_S(ctx->f[7], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_179d60;
    }
label_179d3c:
    // 0x179d3c: 0xc7a30284
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 644)); ctx->f[3] = *(float*)&val; }
    // 0x179d40: 0xc7a00290
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 656)); ctx->f[0] = *(float*)&val; }
    // 0x179d44: 0xc7a4028c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 652)); ctx->f[4] = *(float*)&val; }
    // 0x179d48: 0x46030840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[3]);
    // 0x179d4c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x179d50: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x179d54: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x179d58: 0x46020b42
    ctx->f[13] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x179d5c: 0x46020502
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
label_179d60:
    // 0x179d60: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x179d64: 0xc68c06f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1780)); ctx->f[12] = *(float*)&val; }
    // 0x179d68: 0x26103c68
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 15464));
    // 0x179d6c: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x179d70: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179d74: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x179d7c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_179d7c
// Address: 0x179d7c - 0x179d98

void entry_179d7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179d7c: 0xc68c06f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1784)); ctx->f[12] = *(float*)&val; }
    // 0x179d80: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x179d84: 0xe68006f4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 1780), *(uint32_t*)&val); }
    // 0x179d88: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179d8c: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x179d90: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x179d98);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_179d98
// Address: 0x179d98 - 0x179ec4

void entry_179d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179d98) {
        switch (ctx->pc) {
            case 0x179de0: ctx->pc = 0; goto label_179de0;
            case 0x179e1c: ctx->pc = 0; goto label_179e1c;
            case 0x179e30: ctx->pc = 0; goto label_179e30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179d98: 0xc68106f4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1780)); ctx->f[1] = *(float*)&val; }
    // 0x179d9c: 0x26a23c78
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 15480));
    // 0x179da0: 0xe68006f8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 1784), *(uint32_t*)&val); }
    // 0x179da4: 0x4601b842
    ctx->f[1] = FPU_MUL_S(ctx->f[23], ctx->f[1]);
    // 0x179da8: 0xc68006ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1772)); ctx->f[0] = *(float*)&val; }
    // 0x179dac: 0xc6a23c78
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 15480)); ctx->f[2] = *(float*)&val; }
    // 0x179db0: 0xc4430004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    // 0x179db4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x179db8: 0x4602a840
    ctx->f[1] = FPU_ADD_S(ctx->f[21], ctx->f[2]);
    // 0x179dbc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x179dc0: 0x0
    // NOP
    // 0x179dc4: 0x45010006
    ctx->f[13] = FPU_ADD_S(ctx->f[21], ctx->f[3]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_179de0;
    }
    // 0x179dcc: 0x46006834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x179dd0: 0x0
    // NOP
    // 0x179dd4: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_179de0;
    }
    // 0x179ddc: 0x46006846
    ctx->f[1] = FPU_MOV_S(ctx->f[13]);
label_179de0:
    // 0x179de0: 0xc68006f8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1784)); ctx->f[0] = *(float*)&val; }
    // 0x179de4: 0x26a23c78
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 15480));
    // 0x179de8: 0xe68106ec
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 20), 1772), *(uint32_t*)&val); }
    // 0x179dec: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x179df0: 0xc68106f0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1776)); ctx->f[1] = *(float*)&val; }
    // 0x179df4: 0xc6a23c78
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 15480)); ctx->f[2] = *(float*)&val; }
    // 0x179df8: 0xc4430004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    // 0x179dfc: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x179e00: 0x4602b080
    ctx->f[2] = FPU_ADD_S(ctx->f[22], ctx->f[2]);
    // 0x179e04: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x179e08: 0x0
    // NOP
    // 0x179e0c: 0x45000003
    ctx->f[13] = FPU_ADD_S(ctx->f[22], ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_179e1c;
    }
    // 0x179e14: 0x10000006
    ctx->f[7] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_179e30;
    }
label_179e1c:
    // 0x179e1c: 0x46016834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[13], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x179e20: 0x0
    // NOP
    // 0x179e24: 0x45000002
    ctx->f[7] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_179e30;
    }
    // 0x179e2c: 0x460069c6
    ctx->f[7] = FPU_MOV_S(ctx->f[13]);
label_179e30:
    // 0x179e30: 0xe68706f0
    { float val = ctx->f[7]; WRITE32(ADD32(GPR_U32(ctx, 20), 1776), *(uint32_t*)&val); }
    // 0x179e34: 0x27c23ca0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 30), 15520));
    // 0x179e38: 0x26e33cb0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 23), 15536));
    // 0x179e3c: 0xc68606ec
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1772)); ctx->f[6] = *(float*)&val; }
    // 0x179e40: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x179e44: 0x27b000a0
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 160));
    // 0x179e48: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x179e4c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179e50: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x179e54: 0xc4430004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    // 0x179e58: 0x46013842
    ctx->f[1] = FPU_MUL_S(ctx->f[7], ctx->f[1]);
    // 0x179e5c: 0xc4620004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[2] = *(float*)&val; }
    // 0x179e60: 0xc7c53ca0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 30), 15520)); ctx->f[5] = *(float*)&val; }
    // 0x179e64: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179e68: 0x460018c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x179e6c: 0xc6e43cb0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 15536)); ctx->f[4] = *(float*)&val; }
    // 0x179e70: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x179e74: 0xc7a00090
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 144)); ctx->f[0] = *(float*)&val; }
    // 0x179e78: 0x8e840660
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 1632)));
    // 0x179e7c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179e80: 0x46033182
    ctx->f[6] = FPU_MUL_S(ctx->f[6], ctx->f[3]);
    // 0x179e84: 0x26970674
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 20), 1652));
    // 0x179e88: 0x46023882
    ctx->f[2] = FPU_MUL_S(ctx->f[7], ctx->f[2]);
    // 0x179e8c: 0x3c1e0025
    SET_GPR_U32(ctx, 30, ((uint32_t)37 << 16));
    // 0x179e90: 0x3c150026
    SET_GPR_U32(ctx, 21, ((uint32_t)38 << 16));
    // 0x179e94: 0x2e0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x179e98: 0x46062940
    ctx->f[5] = FPU_ADD_S(ctx->f[5], ctx->f[6]);
    // 0x179e9c: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x179ea0: 0x46022100
    ctx->f[4] = FPU_ADD_S(ctx->f[4], ctx->f[2]);
    // 0x179ea4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x179ea8: 0x44032800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[5]);
    // 0x179eac: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x179eb0: 0x44032000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[4]);
    // 0x179eb4: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x179eb8: 0x7fa200a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 160), GPR_VEC(ctx, 2));
    // 0x179ebc: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x179ec4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), GPR_VEC(ctx, 2));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_179ec4
// Address: 0x179ec4 - 0x179edc

void entry_179ec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179ec4: 0x8e870650
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 20), 1616)));
    // 0x179ec8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179ecc: 0x8e850660
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 1632)));
    // 0x179ed0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179ed4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x179edc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 240));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_179edc
// Address: 0x179edc - 0x179ef4

void entry_179edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179edc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x179ee0: 0x3c060027
    SET_GPR_U32(ctx, 6, ((uint32_t)39 << 16));
    // 0x179ee4: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x179ee8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179eec: 0xc051070
    SET_GPR_U32(ctx, 31, 0x179ef4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 2240));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_179ef4
// Address: 0x179ef4 - 0x179f64

void entry_179ef4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x179ef4) {
        switch (ctx->pc) {
            case 0x179f40: ctx->pc = 0; goto label_179f40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x179ef4: 0x27a20160
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 352));
    // 0x179ef8: 0x27a300c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 192));
    // 0x179efc: 0xafa202b0
    WRITE32(ADD32(GPR_U32(ctx, 29), 688), GPR_U32(ctx, 2));
    // 0x179f00: 0x27a400f0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 240));
    // 0x179f04: 0xafa302a0
    WRITE32(ADD32(GPR_U32(ctx, 29), 672), GPR_U32(ctx, 3));
    // 0x179f08: 0x27a50150
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 336));
    // 0x179f0c: 0x27a60120
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 288));
    // 0x179f10: 0x27a701a0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 416));
    // 0x179f14: 0x27a20170
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 368));
    // 0x179f18: 0x27a30060
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 29), 96));
    // 0x179f1c: 0xafa402a4
    WRITE32(ADD32(GPR_U32(ctx, 29), 676), GPR_U32(ctx, 4));
    // 0x179f20: 0x27b300b0
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 176));
    // 0x179f24: 0xafa502ac
    WRITE32(ADD32(GPR_U32(ctx, 29), 684), GPR_U32(ctx, 5));
    // 0x179f28: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x179f2c: 0xafa602a8
    WRITE32(ADD32(GPR_U32(ctx, 29), 680), GPR_U32(ctx, 6));
    // 0x179f30: 0xafa70294
    WRITE32(ADD32(GPR_U32(ctx, 29), 660), GPR_U32(ctx, 7));
    // 0x179f34: 0xafa202b4
    WRITE32(ADD32(GPR_U32(ctx, 29), 692), GPR_U32(ctx, 2));
    // 0x179f38: 0xafa30298
    WRITE32(ADD32(GPR_U32(ctx, 29), 664), GPR_U32(ctx, 3));
    // 0x179f3c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
label_179f40:
    // 0x179f40: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179f44: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x179f48: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x179f4c: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x179f50: 0x27c58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 4294937888));
    // 0x179f54: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x179f58: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x179f5c: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x179f64);
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[1]));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_179f64
// Address: 0x179f64 - 0x179f84

void entry_179f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179f64: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x179f68: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179f6c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179f70: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x179f74: 0x8c450018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x179f78: 0x26100030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 48));
    // 0x179f7c: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x179f84);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_179f84
// Address: 0x179f84 - 0x179fb8

void entry_179f84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179f84: 0x643ffee
    if (GPR_S32(ctx, 18) >= 0) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
        ctx->pc = 0x179F40; return;
    }
    // 0x179f8c: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x179f90: 0x26b13c90
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 21), 15504));
    // 0x179f94: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x179f98: 0xc68c06fc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1788)); ctx->f[12] = *(float*)&val; }
    // 0x179f9c: 0x24903c58
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 4), 15448));
    // 0x179fa0: 0xc62d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[13] = *(float*)&val; }
    // 0x179fa4: 0x27a50284
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 644));
    // 0x179fa8: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x179fac: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179fb0: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x179fb8);
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 2));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_179fb8
// Address: 0x179fb8 - 0x179fd0

void entry_179fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179fb8: 0xc68c06fc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1788)); ctx->f[12] = *(float*)&val; }
    // 0x179fbc: 0x27a50288
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 648));
    // 0x179fc0: 0xc6ad3c90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 15504)); ctx->f[13] = *(float*)&val; }
    // 0x179fc4: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x179fc8: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x179fd0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_179fd0
// Address: 0x179fd0 - 0x179fe8

void entry_179fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179fd0: 0xc62d0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[13] = *(float*)&val; }
    // 0x179fd4: 0x27a5028c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 652));
    // 0x179fd8: 0xc68c0700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1792)); ctx->f[12] = *(float*)&val; }
    // 0x179fdc: 0x4600a386
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    // 0x179fe0: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x179fe8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_179fe8
// Address: 0x179fe8 - 0x17a000

void entry_179fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x179fe8: 0xc68c0700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1792)); ctx->f[12] = *(float*)&val; }
    // 0x179fec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x179ff0: 0xc6ad3c90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 15504)); ctx->f[13] = *(float*)&val; }
    // 0x179ff4: 0x27a50290
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 656));
    // 0x179ff8: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x17a000);
    ctx->f[14] = FPU_MOV_S(ctx->f[20]);
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_17a000
// Address: 0x17a000 - 0x17a138

void entry_17a000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17a000) {
        switch (ctx->pc) {
            case 0x17a07c: ctx->pc = 0; goto label_17a07c;
            case 0x17a0fc: ctx->pc = 0; goto label_17a0fc;
            case 0x17a10c: ctx->pc = 0; goto label_17a10c;
            case 0x17a124: ctx->pc = 0; goto label_17a124;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17a000: 0x8e830610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1552)));
    // 0x17a004: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17a008: 0x24443c80
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 15488));
    // 0x17a00c: 0x68850007
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x17a010: 0x6c850000
    { uint32_t addr = ADD32(GPR_U32(ctx, 4), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 5, (GPR_U64(ctx, 5) & ~mask) | (aligned_data & mask)); }
    // 0x17a014: 0x8c860008
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x17a018: 0xb3a500b7
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 183); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x17a01c: 0xb7a500b0
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 176); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 5) & mask); WRITE64(aligned_addr, new_data); }
    // 0x17a020: 0xafa600b8
    WRITE32(ADD32(GPR_U32(ctx, 29), 184), GPR_U32(ctx, 6));
    // 0x17a024: 0x14720015
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 18)) {
        goto label_17a07c;
    }
    // 0x17a02c: 0xc7a70288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 648)); ctx->f[7] = *(float*)&val; }
    // 0x17a030: 0xc7a60290
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 656)); ctx->f[6] = *(float*)&val; }
    // 0x17a034: 0xc7a30284
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 644)); ctx->f[3] = *(float*)&val; }
    // 0x17a038: 0xc7a2028c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 652)); ctx->f[2] = *(float*)&val; }
    // 0x17a03c: 0x460718c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[7]);
    // 0x17a040: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17a044: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x17a048: 0x46061081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[6]);
    // 0x17a04c: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x17a050: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x17a054: 0xc6c00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 64)); ctx->f[0] = *(float*)&val; }
    // 0x17a058: 0x4605c040
    ctx->f[1] = FPU_ADD_S(ctx->f[24], ctx->f[5]);
    // 0x17a05c: 0x460418c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[4]);
    // 0x17a060: 0x46041082
    ctx->f[2] = FPU_MUL_S(ctx->f[2], ctx->f[4]);
    // 0x17a064: 0x46050000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[5]);
    // 0x17a068: 0x46020842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[2]);
    // 0x17a06c: 0x46030002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x17a070: 0x46013500
    ctx->f[20] = FPU_ADD_S(ctx->f[6], ctx->f[1]);
    // 0x17a074: 0x1000002b
    ctx->f[13] = FPU_ADD_S(ctx->f[7], ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17a124;
    }
label_17a07c:
    // 0x17a07c: 0x8e840618
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 1560)));
    // 0x17a080: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x17a084: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x17a088: 0xc6800614
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1556)); ctx->f[0] = *(float*)&val; }
    // 0x17a08c: 0x24c33cc0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 15552));
    // 0x17a090: 0x8c820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x17a094: 0x3c050027
    SET_GPR_U32(ctx, 5, ((uint32_t)39 << 16));
    // 0x17a098: 0x46000841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x17a09c: 0xc4640008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[4] = *(float*)&val; }
    // 0x17a0a0: 0xc4400034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 52)); ctx->f[0] = *(float*)&val; }
    // 0x17a0a4: 0x24a45c60
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 5), 23648));
    // 0x17a0a8: 0xc4630004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[3] = *(float*)&val; }
    // 0x17a0ac: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x17a0b0: 0xc4c63cc0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 15552)); ctx->f[6] = *(float*)&val; }
    // 0x17a0b4: 0xc7a20284
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 644)); ctx->f[2] = *(float*)&val; }
    // 0x17a0b8: 0xc7a00288
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 648)); ctx->f[0] = *(float*)&val; }
    // 0x17a0bc: 0xc4a85c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 23648)); ctx->f[8] = *(float*)&val; }
    // 0x17a0c0: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x17a0c4: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x17a0c8: 0x44812800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 1);
    // 0x17a0cc: 0xc4820004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 4)); ctx->f[2] = *(float*)&val; }
    // 0x17a0d0: 0x46040902
    ctx->f[4] = FPU_MUL_S(ctx->f[1], ctx->f[4]);
    // 0x17a0d4: 0xc7b4028c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 652)); ctx->f[20] = *(float*)&val; }
    // 0x17a0d8: 0x460418c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[4]);
    // 0x17a0dc: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x17a0e0: 0x46013180
    ctx->f[6] = FPU_ADD_S(ctx->f[6], ctx->f[1]);
    // 0x17a0e4: 0x46083034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[6], ctx->f[8])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a0e8: 0x0
    // NOP
    // 0x17a0ec: 0x45000003
    ctx->f[13] = FPU_MUL_S(ctx->f[0], ctx->f[5]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17a0fc;
    }
    // 0x17a0f4: 0x10000005
    ctx->f[6] = FPU_MOV_S(ctx->f[8]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17a10c;
    }
label_17a0fc:
    // 0x17a0fc: 0x46061034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[6])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a100: 0x0
    // NOP
    // 0x17a104: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[6] = FPU_MOV_S(ctx->f[2]);
        goto label_17a10c;
    }
label_17a10c:
    // 0x17a10c: 0xc7a000b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 176)); ctx->f[0] = *(float*)&val; }
    // 0x17a110: 0xc7a100b4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 180)); ctx->f[1] = *(float*)&val; }
    // 0x17a114: 0x46060002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[6]);
    // 0x17a118: 0x46060842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[6]);
    // 0x17a11c: 0xe7a000b0
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 176), *(uint32_t*)&val); }
    // 0x17a120: 0xe7a100b4
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 180), *(uint32_t*)&val); }
label_17a124:
    // 0x17a124: 0xc68c0704
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1796)); ctx->f[12] = *(float*)&val; }
    // 0x17a128: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x17a12c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17a130: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x17a138);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_17a138
// Address: 0x17a138 - 0x17a154

void entry_17a138(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a138: 0xc68c0708
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1800)); ctx->f[12] = *(float*)&val; }
    // 0x17a13c: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x17a140: 0xe6800704
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 1796), *(uint32_t*)&val); }
    // 0x17a144: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17a148: 0x4600bb86
    ctx->f[14] = FPU_MOV_S(ctx->f[23]);
    // 0x17a14c: 0xc07a92e
    SET_GPR_U32(ctx, 31, 0x17a154);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GSmooth__FfffP3SMPPf(rdram, ctx, runtime); return;
}


// Function: entry_17a154
// Address: 0x17a154 - 0x17a1f8

void entry_17a154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17a154) {
        switch (ctx->pc) {
            case 0x17a188: ctx->pc = 0; goto label_17a188;
            case 0x17a198: ctx->pc = 0; goto label_17a198;
            case 0x17a1cc: ctx->pc = 0; goto label_17a1cc;
            case 0x17a1dc: ctx->pc = 0; goto label_17a1dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17a154: 0xc6810704
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1796)); ctx->f[1] = *(float*)&val; }
    // 0x17a158: 0x26a23c90
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 15504));
    // 0x17a15c: 0xc68206fc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1788)); ctx->f[2] = *(float*)&val; }
    // 0x17a160: 0x4601b842
    ctx->f[1] = FPU_MUL_S(ctx->f[23], ctx->f[1]);
    // 0x17a164: 0xe6800708
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 1800), *(uint32_t*)&val); }
    // 0x17a168: 0xc6a03c90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 15504)); ctx->f[0] = *(float*)&val; }
    // 0x17a16c: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x17a170: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a174: 0x0
    // NOP
    // 0x17a178: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17a188;
    }
    // 0x17a180: 0x10000005
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17a198;
    }
label_17a188:
    // 0x17a188: 0x46021834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a18c: 0x0
    // NOP
    // 0x17a190: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[2] = FPU_MOV_S(ctx->f[3]);
        goto label_17a198;
    }
label_17a198:
    // 0x17a198: 0xc6800708
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1800)); ctx->f[0] = *(float*)&val; }
    // 0x17a19c: 0x26a23c90
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 21), 15504));
    // 0x17a1a0: 0xc6810700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1792)); ctx->f[1] = *(float*)&val; }
    // 0x17a1a4: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x17a1a8: 0xe68206fc
    { float val = ctx->f[2]; WRITE32(ADD32(GPR_U32(ctx, 20), 1788), *(uint32_t*)&val); }
    // 0x17a1ac: 0xc6a23c90
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 15504)); ctx->f[2] = *(float*)&val; }
    // 0x17a1b0: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x17a1b4: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a1b8: 0x0
    // NOP
    // 0x17a1bc: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17a1cc;
    }
    // 0x17a1c4: 0x10000005
    ctx->f[1] = FPU_MOV_S(ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17a1dc;
    }
label_17a1cc:
    // 0x17a1cc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a1d0: 0x0
    // NOP
    // 0x17a1d4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[1] = FPU_MOV_S(ctx->f[0]);
        goto label_17a1dc;
    }
label_17a1dc:
    // 0x17a1dc: 0x8e860660
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 20), 1632)));
    // 0x17a1e0: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17a1e4: 0x8fa702b0
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 688)));
    // 0x17a1e8: 0x8e850668
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 20), 1640)));
    // 0x17a1ec: 0x24c60140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 320));
    // 0x17a1f0: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17a1f8);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 20), 1792), *(uint32_t*)&val); }
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17a1f8
// Address: 0x17a1f8 - 0x17a248

void entry_17a1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17a1f8) {
        switch (ctx->pc) {
            case 0x17a214: ctx->pc = 0; goto label_17a214;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17a1f8: 0xc7a10160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[1] = *(float*)&val; }
    // 0x17a1fc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17a200: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a204: 0x0
    // NOP
    // 0x17a208: 0x45000002
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 64)); ctx->f[2] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17a214;
    }
    // 0x17a210: 0x46001087
    ctx->f[2] = FPU_NEG_S(ctx->f[2]);
label_17a214:
    // 0x17a214: 0x3c050026
    SET_GPR_U32(ctx, 5, ((uint32_t)38 << 16));
    // 0x17a218: 0x3c060025
    SET_GPR_U32(ctx, 6, ((uint32_t)37 << 16));
    // 0x17a21c: 0x24a23cd0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 5), 15568));
    // 0x17a220: 0xc4a13cd0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 5), 15568)); ctx->f[1] = *(float*)&val; }
    // 0x17a224: 0xc4400008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[0] = *(float*)&val; }
    // 0x17a228: 0x24c48d00
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 6), 4294937856));
    // 0x17a22c: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x17a230: 0x46001002
    ctx->f[0] = FPU_MUL_S(ctx->f[2], ctx->f[0]);
    // 0x17a234: 0x8fa502a0
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 672)));
    // 0x17a238: 0x46006300
    ctx->f[12] = FPU_ADD_S(ctx->f[12], ctx->f[0]);
    // 0x17a23c: 0x460c1302
    ctx->f[12] = FPU_MUL_S(ctx->f[2], ctx->f[12]);
    // 0x17a240: 0xc062214
    SET_GPR_U32(ctx, 31, 0x17a248);
    ctx->f[12] = FPU_ADD_S(ctx->f[1], ctx->f[12]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17a248
// Address: 0x17a248 - 0x17a280

void entry_17a248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a248: 0x3c070026
    SET_GPR_U32(ctx, 7, ((uint32_t)38 << 16));
    // 0x17a24c: 0xc6cc0044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 68)); ctx->f[12] = *(float*)&val; }
    // 0x17a250: 0x24e23ce0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 7), 15584));
    // 0x17a254: 0xc4e23ce0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 15584)); ctx->f[2] = *(float*)&val; }
    // 0x17a258: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x17a25c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x17a260: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17a264: 0x24848d10
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937872));
    // 0x17a268: 0x46016042
    ctx->f[1] = FPU_MUL_S(ctx->f[12], ctx->f[1]);
    // 0x17a26c: 0x8fa502a4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 676)));
    // 0x17a270: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17a274: 0x46006302
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    // 0x17a278: 0xc062214
    SET_GPR_U32(ctx, 31, 0x17a280);
    ctx->f[12] = FPU_ADD_S(ctx->f[2], ctx->f[12]);
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17a280
// Address: 0x17a280 - 0x17a2a4

void entry_17a280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a280: 0x8e820660
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1632)));
    // 0x17a284: 0x27c58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 4294937888));
    // 0x17a288: 0xda820140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 320)));
    // 0x17a28c: 0xd8410140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x17a290: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17a294: 0x8fa602a8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 680)));
    // 0x17a298: 0x8fa402ac
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 684)));
    // 0x17a29c: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x17a2a4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[1]));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17a2a4
// Address: 0x17a2a4 - 0x17a3c4

void entry_17a2a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17a2a4) {
        switch (ctx->pc) {
            case 0x17a314: ctx->pc = 0; goto label_17a314;
            case 0x17a324: ctx->pc = 0; goto label_17a324;
            case 0x17a3a8: ctx->pc = 0; goto label_17a3a8;
            case 0x17a3b4: ctx->pc = 0; goto label_17a3b4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17a2a4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17a2a8: 0xda810150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 336)));
    // 0x17a2ac: 0xc4453d00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15616)); ctx->f[5] = *(float*)&val; }
    // 0x17a2b0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17a2b4: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17a2b8: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17a2bc: 0x24623cf0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 15600));
    // 0x17a2c0: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17a2c4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17a2c8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17a2cc: 0xc4420008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[2] = *(float*)&val; }
    // 0x17a2d0: 0x48250800
    SET_GPR_VEC(ctx, 5, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17a2d4: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x17a2d8: 0x44850000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 5);
    // 0x17a2dc: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x17a2e0: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x17a2e4: 0xc4c33cf0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 15600)); ctx->f[3] = *(float*)&val; }
    // 0x17a2e8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x17a2ec: 0x24833d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 4), 15616));
    // 0x17a2f0: 0x46020840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[2]);
    // 0x17a2f4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x17a2f8: 0x46001b00
    ctx->f[12] = FPU_ADD_S(ctx->f[3], ctx->f[0]);
    // 0x17a2fc: 0x46056034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a300: 0x0
    // NOP
    // 0x17a304: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[4] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17a314;
    }
    // 0x17a30c: 0x10000005
    ctx->f[12] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17a324;
    }
label_17a314:
    // 0x17a314: 0x460c2034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[12])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a318: 0x0
    // NOP
    // 0x17a31c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[12] = FPU_MOV_S(ctx->f[4]);
        goto label_17a324;
    }
label_17a324:
    // 0x17a324: 0xc6810154
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 340)); ctx->f[1] = *(float*)&val; }
    // 0x17a328: 0x3c070025
    SET_GPR_U32(ctx, 7, ((uint32_t)37 << 16));
    // 0x17a32c: 0xc6820150
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 336)); ctx->f[2] = *(float*)&val; }
    // 0x17a330: 0x24e28d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 7), 4294937856));
    // 0x17a334: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17a338: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x17a33c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17a340: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x17a344: 0x44031000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[2]);
    // 0x17a348: 0x70642488
    SET_GPR_VEC(ctx, 4, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 4)));
    // 0x17a34c: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x17a350: 0x70642389
    SET_GPR_VEC(ctx, 4, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 4)));
    // 0x17a354: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x17a358: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x17a35c: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x17a360: 0x48a40800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    // 0x17a364: 0x7fa401b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 432), GPR_VEC(ctx, 4));
    // 0x17a368: 0x4bc108aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17a36c: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17a370: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17a374: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a378: 0xfba101a0
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17a37c: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17a380: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17a384: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17a388: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17a38c: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x17a390: 0x46030034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a394: 0x0
    // NOP
    // 0x17a398: 0x45000003
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 4));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17a3a8;
    }
    // 0x17a3a0: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17a3b4;
    }
label_17a3a8:
    // 0x17a3a8: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17a3ac: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17a3b0: 0x4be0105c
    ctx->vu0_vf[2] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_17a3b4:
    // 0x17a3b4: 0x8fa40294
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 660)));
    // 0x17a3b8: 0x8fa502b4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 692)));
    // 0x17a3bc: 0xc062214
    SET_GPR_U32(ctx, 31, 0x17a3c4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 416), _mm_castps_si128(ctx->vu0_vf[1]));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17a3c4
// Address: 0x17a3c4 - 0x17a4d8

void entry_17a3c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a3c4: 0xdba40180
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x17a3c8: 0x27c58d20
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 30), 4294937888));
    // 0x17a3cc: 0xdba10190
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x17a3d0: 0xdba70170
    ctx->vu0_vf[7] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x17a3d4: 0xdba50120
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x17a3d8: 0xdba60130
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x17a3dc: 0x4bc539bc
    ctx->vu0_i = (float)ctx->vi[5];
    // 0x17a3e0: 0x4bc520bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x17a3e4: 0x4bc5094a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a3e8: 0x4bc639bc
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x17a3ec: 0x4bc620bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[6] = _mm_blendv_ps(ctx->vu0_vf[6], res, _mm_castsi128_ps(mask)); }
    // 0x17a3f0: 0x4bc6098a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a3f4: 0xdba20140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x17a3f8: 0x4bc239bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x17a3fc: 0x4bc220bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17a400: 0x4bc209ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a404: 0xdba300f0
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x17a408: 0xdba20100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x17a40c: 0x4bc329bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x17a410: 0x4bc330bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17a414: 0x4bc338ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a418: 0xdba10110
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x17a41c: 0x4bc229bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x17a420: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17a424: 0x4bc2388a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a428: 0xfba50250
    WRITE128(ADD32(GPR_U32(ctx, 29), 592), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x17a42c: 0x4bc129bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17a430: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17a434: 0x4bc1384a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[7] = _mm_blendv_ps(ctx->vu0_vf[7], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a438: 0xfba60260
    WRITE128(ADD32(GPR_U32(ctx, 29), 608), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x17a43c: 0xfba70270
    WRITE128(ADD32(GPR_U32(ctx, 29), 624), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x17a440: 0xdba400c0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x17a444: 0xdba800d0
    ctx->vu0_vf[8] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x17a448: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x17a44c: 0x4bc410bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x17a450: 0x4bc4090a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a454: 0xdba900e0
    ctx->vu0_vf[9] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x17a458: 0x4bc819bc
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x17a45c: 0x4bc810bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x17a460: 0x4bc80a0a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a464: 0xfba30250
    WRITE128(ADD32(GPR_U32(ctx, 29), 592), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17a468: 0x4bc919bc
    ctx->vu0_i = (float)ctx->vi[9];
    // 0x17a46c: 0x4bc910bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); }
    // 0x17a470: 0x4bc90a4a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[9], ctx->vu0_vf[9], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a474: 0xfba20260
    WRITE128(ADD32(GPR_U32(ctx, 29), 608), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17a478: 0xfba10270
    WRITE128(ADD32(GPR_U32(ctx, 29), 624), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17a47c: 0x8fa402ac
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 684)));
    // 0x17a480: 0x8fa60298
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 664)));
    // 0x17a484: 0xfa840620
    WRITE128(ADD32(GPR_U32(ctx, 20), 1568), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17a488: 0xfa880630
    WRITE128(ADD32(GPR_U32(ctx, 20), 1584), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x17a48c: 0xfa890640
    WRITE128(ADD32(GPR_U32(ctx, 20), 1600), _mm_castps_si128(ctx->vu0_vf[9]));
    // 0x17a490: 0xfba10210
    WRITE128(ADD32(GPR_U32(ctx, 29), 528), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17a494: 0xfba50220
    WRITE128(ADD32(GPR_U32(ctx, 29), 544), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x17a498: 0xfba60230
    WRITE128(ADD32(GPR_U32(ctx, 29), 560), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x17a49c: 0xfba70240
    WRITE128(ADD32(GPR_U32(ctx, 29), 576), _mm_castps_si128(ctx->vu0_vf[7]));
    // 0x17a4a0: 0xfba301f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 496), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17a4a4: 0xfba20200
    WRITE128(ADD32(GPR_U32(ctx, 29), 512), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17a4a8: 0xfba40250
    WRITE128(ADD32(GPR_U32(ctx, 29), 592), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17a4ac: 0xfba401c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 448), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17a4b0: 0xfba80260
    WRITE128(ADD32(GPR_U32(ctx, 29), 608), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x17a4b4: 0xfba801d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 464), _mm_castps_si128(ctx->vu0_vf[8]));
    // 0x17a4b8: 0xfba90270
    WRITE128(ADD32(GPR_U32(ctx, 29), 624), _mm_castps_si128(ctx->vu0_vf[9]));
    // 0x17a4bc: 0xfba901e0
    WRITE128(ADD32(GPR_U32(ctx, 29), 480), _mm_castps_si128(ctx->vu0_vf[9]));
    // 0x17a4c0: 0xdba100a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x17a4c4: 0x8e82067c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 1660)));
    // 0x17a4c8: 0xd8420140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 320)));
    // 0x17a4cc: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17a4d0: 0xc06270a
    SET_GPR_U32(ctx, 31, 0x17a4d8);
    WRITE128(ADD32(GPR_U32(ctx, 29), 336), _mm_castps_si128(ctx->vu0_vf[1]));
    BuildOrthonormalMatrixZ__FP6VECTORT0P7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17a4d8
// Address: 0x17a4d8 - 0x17a4f4

void entry_17a4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a4d8: 0x8e83067c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 1660)));
    // 0x17a4dc: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17a4e0: 0x8fa60298
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 29), 664)));
    // 0x17a4e4: 0x8c620224
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 548)));
    // 0x17a4e8: 0xc0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x17a4ec: 0xc04a054
    SET_GPR_U32(ctx, 31, 0x17a4f4);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 96)));
    ConvertAloMat__FP3ALOT0P7MATRIX3T2(rdram, ctx, runtime); return;
}


// Function: entry_17a4f4
// Address: 0x17a4f4 - 0x17a510

void entry_17a4f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17a4f4) {
        switch (ctx->pc) {
            case 0x17a4fc: ctx->pc = 0; goto label_17a4fc;
            case 0x17a500: ctx->pc = 0; goto label_17a500;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17a4f4: 0x10000020
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 29), 668)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17A578; return;
    }
label_17a4fc:
    // 0x17a4fc: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
label_17a500:
    // 0x17a500: 0xc68c061c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1564)); ctx->f[12] = *(float*)&val; }
    // 0x17a504: 0x26850620
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 20), 1568));
    // 0x17a508: 0xc062214
    SET_GPR_U32(ctx, 31, 0x17a510);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17a510
// Address: 0x17a510 - 0x17a5a8

void entry_17a510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17a510) {
        switch (ctx->pc) {
            case 0x17a528: ctx->pc = 0; goto label_17a528;
            case 0x17a578: ctx->pc = 0; goto label_17a578;
            case 0x17a588: ctx->pc = 0; goto label_17a588;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17a510: 0x26970674
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 20), 1652));
    // 0x17a514: 0x27a20090
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 144));
    // 0x17a518: 0x2e0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x17a51c: 0xafa2029c
    WRITE32(ADD32(GPR_U32(ctx, 29), 668), GPR_U32(ctx, 2));
    // 0x17a520: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17a524: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
label_17a528:
    // 0x17a528: 0x8cc40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x17a52c: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x17a530: 0x24c60004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 4));
    // 0x17a534: 0x788201a0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 416)));
    // 0x17a538: 0x7ca20000
    WRITE128(ADD32(GPR_U32(ctx, 5), 0), GPR_VEC(ctx, 2));
    // 0x17a53c: 0x788301b0
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 4), 432)));
    // 0x17a540: 0x7ca30010
    WRITE128(ADD32(GPR_U32(ctx, 5), 16), GPR_VEC(ctx, 3));
    // 0x17a544: 0x788201c0
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 4), 448)));
    // 0x17a548: 0x7ca20020
    WRITE128(ADD32(GPR_U32(ctx, 5), 32), GPR_VEC(ctx, 2));
    // 0x17a54c: 0x641fff6
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 48));
    if (GPR_S32(ctx, 18) >= 0) {
        goto label_17a528;
    }
    // 0x17a554: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17a558: 0x244283d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294935504));
    // 0x17a55c: 0x78450020
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x17a560: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17a564: 0x78440010
    SET_GPR_VEC(ctx, 4, READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x17a568: 0x7fa30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 3));
    // 0x17a56c: 0x7fa40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 4));
    // 0x17a570: 0x7fa50080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 5));
    // 0x17a574: 0x8fb3029c
    SET_GPR_U32(ctx, 19, READ32(ADD32(GPR_U32(ctx, 29), 668)));
label_17a578:
    // 0x17a578: 0x2e0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x17a57c: 0x3a0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17a580: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17a584: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
label_17a588:
    // 0x17a588: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17a58c: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17a590: 0x24663d08
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 3), 15624));
    // 0x17a594: 0x248400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 208));
    // 0x17a598: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x17a59c: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17a5a0: 0xc07aa46
    SET_GPR_U32(ctx, 31, 0x17a5a8);
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SmoothMatrix(rdram, ctx, runtime); return;
}


// Function: entry_17a5a8
// Address: 0x17a5a8 - 0x17a5c8

void entry_17a5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a5a8: 0x26310030
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 48));
    // 0x17a5ac: 0x8e040000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x17a5b0: 0x2652ffff
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 4294967295));
    // 0x17a5b4: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17a5b8: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17a5bc: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x17a5c0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17a5c8);
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17a5c8
// Address: 0x17a5c8 - 0x17a664

void entry_17a5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a5c8: 0x643ffef
    if (GPR_S32(ctx, 18) >= 0) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x17A588; return;
    }
    // 0x17a5d0: 0x8e84067c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 1660)));
    // 0x17a5d4: 0x8c8201f0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 496)));
    // 0x17a5d8: 0x54400028
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
        ctx->pc = 0x17A67C; return;
    }
    // 0x17a5e0: 0xd88401a0
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 416)));
    // 0x17a5e4: 0x248201a0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 416));
    // 0x17a5e8: 0xdba30060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17a5ec: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x17a5f0: 0xdba60070
    ctx->vu0_vf[6] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x17a5f4: 0x248400d0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 208));
    // 0x17a5f8: 0xdba50080
    ctx->vu0_vf[5] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x17a5fc: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x17a600: 0x4bc419bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x17a604: 0x4bc430bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x17a608: 0x4bc4290a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a60c: 0x8fa7029c
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 29), 668)));
    // 0x17a610: 0xfba400c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17a614: 0x24c63d18
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 15640));
    // 0x17a618: 0xfba400f0
    WRITE128(ADD32(GPR_U32(ctx, 29), 240), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17a61c: 0x4600bb06
    ctx->f[12] = FPU_MOV_S(ctx->f[23]);
    // 0x17a620: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17a624: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x17a628: 0x4bc219bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x17a62c: 0x4bc230bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17a630: 0x4bc2288a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a634: 0xfba200d0
    WRITE128(ADD32(GPR_U32(ctx, 29), 208), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17a638: 0xfba20100
    WRITE128(ADD32(GPR_U32(ctx, 29), 256), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17a63c: 0xd8410020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x17a640: 0x4bc119bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17a644: 0x4bc130bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17a648: 0x4bc128ca
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17a64c: 0xfba40060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17a650: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17a654: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17a658: 0xfba30110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17a65c: 0xc07aa46
    SET_GPR_U32(ctx, 31, 0x17a664);
    WRITE128(ADD32(GPR_U32(ctx, 29), 224), _mm_castps_si128(ctx->vu0_vf[3]));
    SmoothMatrix(rdram, ctx, runtime); return;
}


// Function: entry_17a664
// Address: 0x17a664 - 0x17a678

void entry_17a664(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a664: 0x8e84067c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 1660)));
    // 0x17a668: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17a66c: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x17a670: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17a678);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 668)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17a678
// Address: 0x17a678 - 0x17a684

void entry_17a678(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17a678) {
        switch (ctx->pc) {
            case 0x17a67c: ctx->pc = 0; goto label_17a67c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17a678: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_17a67c:
    // 0x17a67c: 0xc064a9c
    SET_GPR_U32(ctx, 31, 0x17a684);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    FUN_00192a70(rdram, ctx, runtime); return;
}


// Function: entry_17a684
// Address: 0x17a684 - 0x17a68c

void entry_17a684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a684: 0xc04a77e
    SET_GPR_U32(ctx, 31, 0x17a68c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    ResolveAlo__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_17a68c
// Address: 0x17a68c - 0x17a6d0

void entry_17a68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a68c: 0x7bbf0350
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 848)));
    // 0x17a690: 0x7bbe0340
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 832)));
    // 0x17a694: 0x7bb70330
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 816)));
    // 0x17a698: 0x7bb60320
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 800)));
    // 0x17a69c: 0x7bb50310
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 784)));
    // 0x17a6a0: 0x7bb40300
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 768)));
    // 0x17a6a4: 0x7bb302f0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 752)));
    // 0x17a6a8: 0x7bb202e0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 736)));
    // 0x17a6ac: 0x7bb102d0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 720)));
    // 0x17a6b0: 0x7bb002c0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 704)));
    // 0x17a6b4: 0xc7b80380
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 896)); ctx->f[24] = *(float*)&val; }
    // 0x17a6b8: 0xc7b70378
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 888)); ctx->f[23] = *(float*)&val; }
    // 0x17a6bc: 0xc7b60370
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 880)); ctx->f[22] = *(float*)&val; }
    // 0x17a6c0: 0xc7b50368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 872)); ctx->f[21] = *(float*)&val; }
    // 0x17a6c4: 0xc7b40360
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 864)); ctx->f[20] = *(float*)&val; }
    // 0x17a6c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 912));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017a6d0
// Address: 0x17a6d0 - 0x17a6e4

void FUN_0017a6d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a6d0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x17a6d4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17a6d8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x17a6dc: 0xc064b16
    SET_GPR_U32(ctx, 31, 0x17a6e4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    UsePoCharm__FP2PO(rdram, ctx, runtime); return;
}


// Function: entry_17a6e4
// Address: 0x17a6e4 - 0x17a6f0

void entry_17a6e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a6e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17a6e8: 0xc05eafa
    SET_GPR_U32(ctx, 31, 0x17a6f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FUN_0017abe8(rdram, ctx, runtime); return;
}


// Function: entry_17a6f0
// Address: 0x17a6f0 - 0x17a700

void entry_17a6f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a6f0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17a6f4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17a6f8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017a700
// Address: 0x17a700 - 0x17a71c

void FUN_0017a700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a700: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x17a704: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x17a708: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x17a70c: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17a710: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x17a714: 0xc0648ba
    SET_GPR_U32(ctx, 31, 0x17a71c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    OnPoActive__FP2POiT0(rdram, ctx, runtime); return;
}


// Function: entry_17a71c
// Address: 0x17a71c - 0x17a76c

void entry_17a71c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17a71c) {
        switch (ctx->pc) {
            case 0x17a754: ctx->pc = 0; goto label_17a754;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17a71c: 0x1200000d
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        goto label_17a754;
    }
    // 0x17a724: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17a728: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x17a72c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17a730: 0x246308c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 2240));
    // 0x17a734: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17a738: 0x44040000
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[0]);
    // 0x17a73c: 0x70821488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 4), GPR_VEC(ctx, 2)));
    // 0x17a740: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x17a744: 0x70821389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 4), GPR_VEC(ctx, 2)));
    // 0x17a748: 0x7c620000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 2));
    // 0x17a74c: 0x10000008
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17A770; return;
    }
label_17a754:
    // 0x17a754: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x17a758: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17a75c: 0x8c830650
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1616)));
    // 0x17a760: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
    // 0x17a764: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17a76c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 1616));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17a76c
// Address: 0x17a76c - 0x17a788

void entry_17a76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17a76c) {
        switch (ctx->pc) {
            case 0x17a770: ctx->pc = 0; goto label_17a770;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17a76c: 0xae2006d0
    WRITE32(ADD32(GPR_U32(ctx, 17), 1744), GPR_U32(ctx, 0));
label_17a770:
    // 0x17a770: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17a774: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17a778: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17a77c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17a784: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17a788; return;
}


// Function: FUN_0017a788
// Address: 0x17a788 - 0x17a828

void FUN_0017a788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17a788) {
        switch (ctx->pc) {
            case 0x17a804: ctx->pc = 0; goto label_17a804;
            case 0x17a80c: ctx->pc = 0; goto label_17a80c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17a788: 0x27bdff90
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967184));
    // 0x17a78c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x17a790: 0x31c78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 17);
    // 0x17a794: 0x7fb20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 18));
    // 0x17a798: 0x7fb10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 17));
    // 0x17a79c: 0xc0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 6) + GPR_U64(ctx, 0));
    // 0x17a7a0: 0x7fb00020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 16));
    // 0x17a7a4: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x17a7a8: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17a7ac: 0xe7b40060
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 96), *(uint32_t*)&val); }
    // 0x17a7b0: 0xde0202c8
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 712)));
    // 0x17a7b4: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x17a7b8: 0x14400081
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_17a9c0(rdram, ctx, runtime); return;
    }
    // 0x17a7c0: 0x3c028000
    SET_GPR_U32(ctx, 2, ((uint32_t)32768 << 16));
    // 0x17a7c4: 0x8e0306d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1744)));
    // 0x17a7c8: 0x344200a0
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 160));
    // 0x17a7cc: 0x1060006f
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17A98C; return;
    }
    // 0x17a7d4: 0x8e030610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x17a7d8: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x17a7dc: 0x10620009
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17a804;
    }
    // 0x17a7e4: 0xc60206d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1752)); ctx->f[2] = *(float*)&val; }
    // 0x17a7e8: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
    // 0x17a7ec: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x17a7f0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17a7f4: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17a7f8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17a7fc: 0x10000003
    ctx->f[20] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17a80c;
    }
label_17a804:
    // 0x17a804: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x17a808: 0x24621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 3), 6232));
label_17a80c:
    // 0x17a80c: 0xc60106d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1748)); ctx->f[1] = *(float*)&val; }
    // 0x17a810: 0xc44c0004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[12] = *(float*)&val; }
    // 0x17a814: 0x3c014120
    SET_GPR_U32(ctx, 1, ((uint32_t)16672 << 16));
    // 0x17a818: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17a81c: 0x46016301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
    // 0x17a820: 0xc081484
    SET_GPR_U32(ctx, 31, 0x17a828);
    ctx->f[12] = FPU_MUL_S(ctx->f[12], ctx->f[0]);
    cosf(rdram, ctx, runtime); return;
}


// Function: entry_17a828
// Address: 0x17a828 - 0x17a9b0

void entry_17a828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17a828) {
        switch (ctx->pc) {
            case 0x17a884: ctx->pc = 0; goto label_17a884;
            case 0x17a8c8: ctx->pc = 0; goto label_17a8c8;
            case 0x17a8d8: ctx->pc = 0; goto label_17a8d8;
            case 0x17a98c: ctx->pc = 0; goto label_17a98c;
            case 0x17a9a4: ctx->pc = 0; goto label_17a9a4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17a828: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17a82c: 0x46000186
    ctx->f[6] = FPU_MOV_S(ctx->f[0]);
    // 0x17a830: 0x24433d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 15664));
    // 0x17a834: 0xc4423d30
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15664)); ctx->f[2] = *(float*)&val; }
    // 0x17a838: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x17a83c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x17a840: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17a844: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17a848: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x17a84c: 0xc4445c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 23648)); ctx->f[4] = *(float*)&val; }
    // 0x17a850: 0x24425c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 23648));
    // 0x17a854: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17a858: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x17a85c: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x17a860: 0x46040034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a864: 0x0
    // NOP
    // 0x17a868: 0x45010006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17a884;
    }
    // 0x17a870: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a874: 0x0
    // NOP
    // 0x17a878: 0x45000002
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17a884;
    }
    // 0x17a880: 0x46001906
    ctx->f[4] = FPU_MOV_S(ctx->f[3]);
label_17a884:
    // 0x17a884: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17a888: 0xc4855c60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 23648)); ctx->f[5] = *(float*)&val; }
    // 0x17a88c: 0x24433d40
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 2), 15680));
    // 0x17a890: 0xc4423d40
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15680)); ctx->f[2] = *(float*)&val; }
    // 0x17a894: 0xc4610008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 8)); ctx->f[1] = *(float*)&val; }
    // 0x17a898: 0x24825c60
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 4), 23648));
    // 0x17a89c: 0xc4600004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17a8a0: 0x46013042
    ctx->f[1] = FPU_MUL_S(ctx->f[6], ctx->f[1]);
    // 0x17a8a4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17a8a8: 0x46003002
    ctx->f[0] = FPU_MUL_S(ctx->f[6], ctx->f[0]);
    // 0x17a8ac: 0x46001000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[0]);
    // 0x17a8b0: 0x46050034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[5])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a8b4: 0x0
    // NOP
    // 0x17a8b8: 0x45000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[3] = *(float*)&val; }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17a8c8;
    }
    // 0x17a8c0: 0x10000005
    ctx->f[0] = FPU_MOV_S(ctx->f[5]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17a8d8;
    }
label_17a8c8:
    // 0x17a8c8: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17a8cc: 0x0
    // NOP
    // 0x17a8d0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MOV_S(ctx->f[3]);
        goto label_17a8d8;
    }
label_17a8d8:
    // 0x17a8d8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17a8dc: 0x46002102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[0]);
    // 0x17a8e0: 0x904323e0
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 2), 9184)));
    // 0x17a8e4: 0x244423e0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 9184));
    // 0x17a8e8: 0x93a20010
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17a8ec: 0x44831800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 3);
    // 0x17a8f0: 0x468018e0
    ctx->f[3] = FPU_CVT_S_W(*(int32_t*)&ctx->f[3]);
    // 0x17a8f4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17a8f8: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17a8fc: 0x90830002
    SET_GPR_U32(ctx, 3, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 2)));
    // 0x17a900: 0x44822800
    *(uint32_t*)&ctx->f[5] = GPR_U32(ctx, 2);
    // 0x17a904: 0x46802960
    ctx->f[5] = FPU_CVT_S_W(*(int32_t*)&ctx->f[5]);
    // 0x17a908: 0x93a50012
    SET_GPR_U32(ctx, 5, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 18)));
    // 0x17a90c: 0x46040001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[4]);
    // 0x17a910: 0x90860001
    SET_GPR_U32(ctx, 6, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 1)));
    // 0x17a914: 0x44831000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 3);
    // 0x17a918: 0x468010a0
    ctx->f[2] = FPU_CVT_S_W(*(int32_t*)&ctx->f[2]);
    // 0x17a91c: 0x93a70011
    SET_GPR_U32(ctx, 7, (uint8_t)READ8(ADD32(GPR_U32(ctx, 29), 17)));
    // 0x17a920: 0x44850800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 5);
    // 0x17a924: 0x46800860
    ctx->f[1] = FPU_CVT_S_W(*(int32_t*)&ctx->f[1]);
    // 0x17a928: 0x44863800
    *(uint32_t*)&ctx->f[7] = GPR_U32(ctx, 6);
    // 0x17a92c: 0x468039e0
    ctx->f[7] = FPU_CVT_S_W(*(int32_t*)&ctx->f[7]);
    // 0x17a930: 0x90820003
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 4), 3)));
    // 0x17a934: 0x44873000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 7);
    // 0x17a938: 0x468031a0
    ctx->f[6] = FPU_CVT_S_W(*(int32_t*)&ctx->f[6]);
    // 0x17a93c: 0x460300c2
    ctx->f[3] = FPU_MUL_S(ctx->f[0], ctx->f[3]);
    // 0x17a940: 0xa3a20003
    WRITE8(ADD32(GPR_U32(ctx, 29), 3), (uint8_t)GPR_U32(ctx, 2));
    // 0x17a944: 0x46052142
    ctx->f[5] = FPU_MUL_S(ctx->f[4], ctx->f[5]);
    // 0x17a948: 0x46012042
    ctx->f[1] = FPU_MUL_S(ctx->f[4], ctx->f[1]);
    // 0x17a94c: 0x46020082
    ctx->f[2] = FPU_MUL_S(ctx->f[0], ctx->f[2]);
    // 0x17a950: 0x46070002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[7]);
    // 0x17a954: 0x46062102
    ctx->f[4] = FPU_MUL_S(ctx->f[4], ctx->f[6]);
    // 0x17a958: 0x460518c0
    ctx->f[3] = FPU_ADD_S(ctx->f[3], ctx->f[5]);
    // 0x17a95c: 0x46011080
    ctx->f[2] = FPU_ADD_S(ctx->f[2], ctx->f[1]);
    // 0x17a960: 0x46040000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[4]);
    // 0x17a964: 0x46001864
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[3]);
    // 0x17a968: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x17a96c: 0x46001064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[2]);
    // 0x17a970: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x17a974: 0x46000064
    *(int32_t*)&ctx->f[1] = FPU_CVT_W_S(ctx->f[0]);
    // 0x17a978: 0x44040800
    SET_GPR_U32(ctx, 4, *(uint32_t*)&ctx->f[1]);
    // 0x17a97c: 0xa3a20000
    WRITE8(ADD32(GPR_U32(ctx, 29), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x17a980: 0xa3a30002
    WRITE8(ADD32(GPR_U32(ctx, 29), 2), (uint8_t)GPR_U32(ctx, 3));
    // 0x17a984: 0x10000007
    WRITE8(ADD32(GPR_U32(ctx, 29), 1), (uint8_t)GPR_U32(ctx, 4));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17a9a4;
    }
label_17a98c:
    // 0x17a98c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17a990: 0x244623e0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 9184));
    // 0x17a994: 0x88c30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | ((word >> shift) & mask)); }
    // 0x17a998: 0x98c30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 6), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 3, (GPR_U32(ctx,3) & ~mask) | (word << shift)); }
    // 0x17a99c: 0xaba30003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
    // 0x17a9a0: 0xbba30000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 3) & mask); WRITE32(aligned_addr, new_data); }
label_17a9a4:
    // 0x17a9a4: 0x8fa50000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17a9a8: 0xc049a92
    SET_GPR_U32(ctx, 31, 0x17a9b0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    SetAloOverrideCel__FP3ALOG4RGBA(rdram, ctx, runtime); return;
}


// Function: entry_17a9b0
// Address: 0x17a9b0 - 0x17a9c0

void entry_17a9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a9b0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17a9b4: 0x220282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17a9b8: 0xc049724
    SET_GPR_U32(ctx, 31, 0x17a9c0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    RenderAloAll__FP3ALOP2CMP2RO(rdram, ctx, runtime); return;
}


// Function: entry_17a9c0
// Address: 0x17a9c0 - 0x17a9e0

void entry_17a9c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a9c0: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x17a9c4: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17a9c8: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17a9cc: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17a9d0: 0xc7b40060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[20] = *(float*)&val; }
    // 0x17a9d4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 112));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17a9dc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17a9e0; return;
}


// Function: FUN_0017a9e0
// Address: 0x17a9e0 - 0x17aa24

void FUN_0017a9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17a9e0: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x17a9e4: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x17a9e8: 0x10a20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17AA2C; return;
    }
    // 0x17a9f0: 0x8c830610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1552)));
    // 0x17a9f4: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x17a9f8: 0x1062000d
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17AA30; return;
    }
    // 0x17aa00: 0x1060000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17AA2C; return;
    }
    // 0x17aa08: 0x10620009
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17AA30; return;
    }
    // 0x17aa10: 0x8c8206d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1744)));
    // 0x17aa14: 0x14400006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17AA30; return;
    }
    // 0x17aa1c: 0xc0776a0
    SET_GPR_U32(ctx, 31, 0x17aa24);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 20)));
    IsSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_17aa24
// Address: 0x17aa24 - 0x17aa40

void entry_17aa24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17aa24) {
        switch (ctx->pc) {
            case 0x17aa2c: ctx->pc = 0; goto label_17aa2c;
            case 0x17aa30: ctx->pc = 0; goto label_17aa30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17aa24: 0x10400002
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17aa30;
    }
label_17aa2c:
    // 0x17aa2c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_17aa30:
    // 0x17aa30: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17aa34: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17aa3c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17aa40; return;
}


// Function: FUN_0017aa40
// Address: 0x17aa40 - 0x17aa6c

void FUN_0017aa40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17aa40: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x17aa44: 0x7fb20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 18));
    // 0x17aa48: 0x7fb10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 17));
    // 0x17aa4c: 0xa0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x17aa50: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x17aa54: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17aa58: 0x7fb00020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 16));
    // 0x17aa5c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17aa60: 0x8c62013c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 316)));
    // 0x17aa64: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17aa6c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17aa6c
// Address: 0x17aa6c - 0x17aa7c

void entry_17aa6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17aa6c: 0x14400034
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17AB40; return;
    }
    // 0x17aa74: 0xc058316
    SET_GPR_U32(ctx, 31, 0x17aa7c);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_17aa7c
// Address: 0x17aa7c - 0x17aac0

void entry_17aa7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17aa7c) {
        switch (ctx->pc) {
            case 0x17aa94: ctx->pc = 0; goto label_17aa94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17aa7c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17aa94;
    }
    // 0x17aa84: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17aa88: 0xae2206d0
    WRITE32(ADD32(GPR_U32(ctx, 17), 1744), GPR_U32(ctx, 2));
    // 0x17aa8c: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17aa90: 0xe62006d4
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1748), *(uint32_t*)&val); }
label_17aa94:
    // 0x17aa94: 0x8e2206d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1744)));
    // 0x17aa98: 0x10400015
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17aaf0(rdram, ctx, runtime); return;
    }
    // 0x17aaa0: 0x3c014040
    SET_GPR_U32(ctx, 1, ((uint32_t)16448 << 16));
    // 0x17aaa4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17aaa8: 0xae200704
    WRITE32(ADD32(GPR_U32(ctx, 17), 1796), GPR_U32(ctx, 0));
    // 0x17aaac: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17aab0: 0xe6200708
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1800), *(uint32_t*)&val); }
    // 0x17aab4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17aab8: 0xc05e538
    SET_GPR_U32(ctx, 31, 0x17aac0);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_001794e0(rdram, ctx, runtime); return;
}


// Function: entry_17aac0
// Address: 0x17aac0 - 0x17aadc

void entry_17aac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17aac0: 0x8e240668
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 1640)));
    // 0x17aac4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17aac8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17aacc: 0x200402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17aad0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17aad4: 0xc049f98
    SET_GPR_U32(ctx, 31, 0x17aadc);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2(rdram, ctx, runtime); return;
}


// Function: entry_17aadc
// Address: 0x17aadc - 0x17aaf0

void entry_17aadc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17aadc: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17aae0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17aae4: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x17aae8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17aaf0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17aaf0
// Address: 0x17aaf0 - 0x17aaf8

void entry_17aaf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17aaf0: 0xc058316
    SET_GPR_U32(ctx, 31, 0x17aaf8);
    FCharmAvailable__Fv(rdram, ctx, runtime); return;
}


// Function: entry_17aaf8
// Address: 0x17aaf8 - 0x17ab08

void entry_17aaf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17aaf8: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17AB10; return;
    }
    // 0x17ab00: 0xc05eafa
    SET_GPR_U32(ctx, 31, 0x17ab08);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    FUN_0017abe8(rdram, ctx, runtime); return;
}


// Function: entry_17ab08
// Address: 0x17ab08 - 0x17ab18

void entry_17ab08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ab08) {
        switch (ctx->pc) {
            case 0x17ab10: ctx->pc = 0; goto label_17ab10;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ab08: 0x10000004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17AB1C; return;
    }
label_17ab10:
    // 0x17ab10: 0xc05eafa
    SET_GPR_U32(ctx, 31, 0x17ab18);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 4));
    FUN_0017abe8(rdram, ctx, runtime); return;
}


// Function: entry_17ab18
// Address: 0x17ab18 - 0x17ab3c

void entry_17ab18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ab18) {
        switch (ctx->pc) {
            case 0x17ab1c: ctx->pc = 0; goto label_17ab1c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ab18: 0x8e420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 4)));
label_17ab1c:
    // 0x17ab1c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17ab20: 0xafb10000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 17));
    // 0x17ab24: 0x24050017
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 23));
    // 0x17ab28: 0xafa20004
    WRITE32(ADD32(GPR_U32(ctx, 29), 4), GPR_U32(ctx, 2));
    // 0x17ab2c: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17ab30: 0x8c430048
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 72)));
    // 0x17ab34: 0x60f809
    SET_GPR_U32(ctx, 31, 0x17ab3c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_17ab3c
// Address: 0x17ab3c - 0x17ab58

void entry_17ab3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ab3c) {
        switch (ctx->pc) {
            case 0x17ab40: ctx->pc = 0; goto label_17ab40;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ab3c: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_17ab40:
    // 0x17ab40: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x17ab44: 0x7bb20040
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17ab48: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17ab4c: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17ab50: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017ab58
// Address: 0x17ab58 - 0x17abcc

void FUN_0017ab58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ab58) {
        switch (ctx->pc) {
            case 0x17ab9c: ctx->pc = 0; goto label_17ab9c;
            case 0x17abb0: ctx->pc = 0; goto label_17abb0;
            case 0x17abb8: ctx->pc = 0; goto label_17abb8;
            case 0x17abc0: ctx->pc = 0; goto label_17abc0;
            case 0x17abc4: ctx->pc = 0; goto label_17abc4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ab58: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x17ab5c: 0x24020013
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 19));
    // 0x17ab60: 0x14a20018
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_17abc4;
    }
    // 0x17ab68: 0x8cc30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x17ab6c: 0x8c820618
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1560)));
    // 0x17ab70: 0x14620014
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 351));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_17abc4;
    }
    // 0x17ab78: 0x8cc30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 8)));
    // 0x17ab7c: 0x1062000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 352));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17abb8;
    }
    // 0x17ab84: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 350));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17ab9c;
    }
    // 0x17ab8c: 0x10620008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17abb0;
    }
    // 0x17ab94: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17abc4;
    }
label_17ab9c:
    // 0x17ab9c: 0x24020467
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1127));
    // 0x17aba0: 0x10620007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17abc0;
    }
    // 0x17aba8: 0x10000006
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17abc4;
    }
label_17abb0:
    // 0x17abb0: 0x10000004
    WRITE32(ADD32(GPR_U32(ctx, 4), 1760), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17abc4;
    }
label_17abb8:
    // 0x17abb8: 0x10000002
    WRITE32(ADD32(GPR_U32(ctx, 4), 1760), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17abc4;
    }
label_17abc0:
    // 0x17abc0: 0xac82070c
    WRITE32(ADD32(GPR_U32(ctx, 4), 1804), GPR_U32(ctx, 2));
label_17abc4:
    // 0x17abc4: 0xc06488c
    SET_GPR_U32(ctx, 31, 0x17abcc);
    HandlePoMessage__FP2PO5MSGIDPv(rdram, ctx, runtime); return;
}


// Function: entry_17abcc
// Address: 0x17abcc - 0x17abe8

void entry_17abcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17abcc: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17abd0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17abd8: 0x8c8206d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1744)));
    // 0x17abdc: 0x3e00008
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17abe4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17abe8; return;
}


// Function: FUN_0017abe8
// Address: 0x17abe8 - 0x17accc

void FUN_0017abe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17abe8) {
        switch (ctx->pc) {
            case 0x17ac34: ctx->pc = 0; goto label_17ac34;
            case 0x17ac38: ctx->pc = 0; goto label_17ac38;
            case 0x17ac5c: ctx->pc = 0; goto label_17ac5c;
            case 0x17ac78: ctx->pc = 0; goto label_17ac78;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17abe8: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x17abec: 0x7fb10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 17));
    // 0x17abf0: 0x7fb00010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 16));
    // 0x17abf4: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x17abf8: 0x7fbf0050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 31));
    // 0x17abfc: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17ac00: 0x7fb30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 19));
    // 0x17ac04: 0x7fb20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 18));
    // 0x17ac08: 0x8e030610
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x17ac0c: 0x12230049
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 3)) {
        entry_17ad34(rdram, ctx, runtime); return;
    }
    // 0x17ac14: 0x10400007
    SET_GPR_U32(ctx, 19, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17ac34;
    }
    // 0x17ac1c: 0x28620003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 3));
    // 0x17ac20: 0x14400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_17ac38;
    }
    // 0x17ac28: 0x26621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 6232));
    // 0x17ac2c: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17ac30: 0xe60006d8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1752), *(uint32_t*)&val); }
label_17ac34:
    // 0x17ac34: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_17ac38:
    // 0x17ac38: 0x1222000f
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        goto label_17ac78;
    }
    // 0x17ac40: 0x2a220003
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 3));
    // 0x17ac44: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17ac5c;
    }
    // 0x17ac4c: 0x5222002d
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1732)));
        entry_17ad04(rdram, ctx, runtime); return;
    }
    // 0x17ac54: 0x1000002c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1552), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17AD08; return;
    }
label_17ac5c:
    // 0x17ac5c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x17ac60: 0x1222001c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17ACD4; return;
    }
    // 0x17ac68: 0x1222001f
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17ACE8; return;
    }
    // 0x17ac70: 0x10000025
    WRITE32(ADD32(GPR_U32(ctx, 16), 1552), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17AD08; return;
    }
label_17ac78:
    // 0x17ac78: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17ac7c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17ac80: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x17ac84: 0x3c0144fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17658 << 16));
    // 0x17ac88: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17ac8c: 0x78450000
    SET_GPR_VEC(ctx, 5, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17ac90: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    // 0x17ac94: 0x246308c0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 2240));
    // 0x17ac98: 0x44060000
    SET_GPR_U32(ctx, 6, *(uint32_t*)&ctx->f[0]);
    // 0x17ac9c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17aca0: 0x70463488
    SET_GPR_VEC(ctx, 6, PS2_PEXTLW(GPR_VEC(ctx, 2), GPR_VEC(ctx, 6)));
    // 0x17aca4: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x17aca8: 0x70463389
    SET_GPR_VEC(ctx, 6, _mm_unpacklo_epi64(GPR_VEC(ctx, 2), GPR_VEC(ctx, 6)));
    // 0x17acac: 0x7c65fff0
    WRITE128(ADD32(GPR_U32(ctx, 3), 4294967280), GPR_VEC(ctx, 5));
    // 0x17acb0: 0x2464fd90
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 3), 4294966672));
    // 0x17acb4: 0x7c660000
    WRITE128(ADD32(GPR_U32(ctx, 3), 0), GPR_VEC(ctx, 6));
    // 0x17acb8: 0x8c67fd90
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 3), 4294966672)));
    // 0x17acbc: 0x7fa60000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 6));
    // 0x17acc0: 0x8ce20040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 7), 64)));
    // 0x17acc4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17accc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17accc
// Address: 0x17accc - 0x17ad04

void entry_17accc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17accc) {
        switch (ctx->pc) {
            case 0x17acd4: ctx->pc = 0; goto label_17acd4;
            case 0x17ace8: ctx->pc = 0; goto label_17ace8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17accc: 0x1000000d
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1728)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17ad04(rdram, ctx, runtime); return;
    }
label_17acd4:
    // 0x17acd4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17acd8: 0x8e1206c8
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1736)));
    // 0x17acdc: 0xc440aff4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294946804)); ctx->f[0] = *(float*)&val; }
    // 0x17ace0: 0x10000008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1752), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17ad04(rdram, ctx, runtime); return;
    }
label_17ace8:
    // 0x17ace8: 0x8e0406e8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1768)));
    // 0x17acec: 0xc440aff4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4294946804)); ctx->f[0] = *(float*)&val; }
    // 0x17acf0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17acf4: 0x8e1206cc
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1740)));
    // 0x17acf8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17acfc: 0xc04ad6e
    SET_GPR_U32(ctx, 31, 0x17ad04);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1752), *(uint32_t*)&val); }
    FUN_0012b5b8(rdram, ctx, runtime); return;
}


// Function: entry_17ad04
// Address: 0x17ad04 - 0x17ad34

void entry_17ad04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ad04) {
        switch (ctx->pc) {
            case 0x17ad08: ctx->pc = 0; goto label_17ad08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ad04: 0xae110610
    WRITE32(ADD32(GPR_U32(ctx, 16), 1552), GPR_U32(ctx, 17));
label_17ad08:
    // 0x17ad08: 0x26621858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 19), 6232));
    // 0x17ad0c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17ad10: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x17ad14: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17ad18: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17ad1c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17ad20: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x17ad24: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17ad28: 0xe6000614
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1556), *(uint32_t*)&val); }
    // 0x17ad2c: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x17ad34);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 5), 1560));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_17ad34
// Address: 0x17ad34 - 0x17ad50

void entry_17ad34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ad34: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x17ad38: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17ad3c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17ad40: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17ad44: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17ad48: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017ad50
// Address: 0x17ad50 - 0x17ad74

void FUN_0017ad50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ad50: 0x27bdffb0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967216));
    // 0x17ad54: 0x7fb10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 17));
    // 0x17ad58: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17ad5c: 0x7fb00020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 16));
    // 0x17ad60: 0x27b10010
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17ad64: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17ad68: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x17ad6c: 0xc05e538
    SET_GPR_U32(ctx, 31, 0x17ad74);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001794e0(rdram, ctx, runtime); return;
}


// Function: entry_17ad74
// Address: 0x17ad74 - 0x17ad90

void entry_17ad74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ad74: 0x8e040668
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1640)));
    // 0x17ad78: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17ad7c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ad80: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ad84: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17ad88: 0xc049f98
    SET_GPR_U32(ctx, 31, 0x17ad90);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloTransformAdjust__FP3ALOT0P6VECTORP7MATRIX3T2T2(rdram, ctx, runtime); return;
}


// Function: entry_17ad90
// Address: 0x17ad90 - 0x17ada4

void entry_17ad90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ad90: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x17ad94: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17ad98: 0x8c620084
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 132)));
    // 0x17ad9c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17ada4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17ada4
// Address: 0x17ada4 - 0x17adb8

void entry_17ada4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ada4: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x17ada8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17adac: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x17adb0: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17adb8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17adb8
// Address: 0x17adb8 - 0x17add0

void entry_17adb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17adb8: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17adbc: 0x7bb10030
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17adc0: 0x7bb00020
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17adc4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17adcc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17add0; return;
}


// Function: FUN_0017add0
// Address: 0x17add0 - 0x17ade4

void FUN_0017add0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17add0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x17add4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17add8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x17addc: 0xc06de5a
    SET_GPR_U32(ctx, 31, 0x17ade4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    InitSo__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_17ade4
// Address: 0x17ade4 - 0x17ae00

void entry_17ade4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ade4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x17ade8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17adec: 0xae020550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 2));
    // 0x17adf0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17adf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17adfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17ae00; return;
}


// Function: FUN_0017ae00
// Address: 0x17ae00 - 0x17ae30

void FUN_0017ae00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ae00: 0x27bdffa0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967200));
    // 0x17ae04: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17ae08: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17ae0c: 0x7fbf0040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 31));
    // 0x17ae10: 0x7fb30030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 19));
    // 0x17ae14: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x17ae18: 0x261305c4
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 16), 1476));
    // 0x17ae1c: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x17ae20: 0x26120590
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 16), 1424));
    // 0x17ae24: 0xe7b40050
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 80), *(uint32_t*)&val); }
    // 0x17ae28: 0xc049292
    SET_GPR_U32(ctx, 31, 0x17ae30);
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 16), 1372));
    PostAloLoad__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_17ae30
// Address: 0x17ae30 - 0x17ae4c

void entry_17ae30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ae30: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17ae34: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x17ae38: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x17ae3c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17ae40: 0x24c63d58
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 15704));
    // 0x17ae44: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x17ae4c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 13));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_17ae4c
// Address: 0x17ae4c - 0x17ae70

void entry_17ae4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ae4c: 0x260b058c
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 16), 1420));
    // 0x17ae50: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ae54: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ae58: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ae5c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17ae60: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17ae64: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x17ae68: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x17ae70);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_17ae70
// Address: 0x17ae70 - 0x17ae88

void entry_17ae70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ae70: 0x8e04058c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1420)));
    // 0x17ae74: 0x220382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17ae78: 0xe6140580
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 1408), *(uint32_t*)&val); }
    // 0x17ae7c: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x17ae80: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x17ae88);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_17ae88
// Address: 0x17ae88 - 0x17aeac

void entry_17ae88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ae88: 0x260b05c0
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 16), 1472));
    // 0x17ae8c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ae90: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ae94: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ae98: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17ae9c: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17aea0: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x17aea4: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x17aeac);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_17aeac
// Address: 0x17aeac - 0x17aec4

void entry_17aeac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17aeac: 0x8e0405c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1472)));
    // 0x17aeb0: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17aeb4: 0xe6140590
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 1424), *(uint32_t*)&val); }
    // 0x17aeb8: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x17aebc: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x17aec4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_17aec4
// Address: 0x17aec4 - 0x17aee8

void entry_17aec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17aec4: 0x260b0600
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 16), 1536));
    // 0x17aec8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17aecc: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17aed0: 0x502d
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17aed4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17aed8: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17aedc: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x17aee0: 0xc04e40e
    SET_GPR_U32(ctx, 31, 0x17aee8);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    EnsureAsegBlendDynamic__FP3ALOiiPviPiT5PP6ASEGBL(rdram, ctx, runtime); return;
}


// Function: entry_17aee8
// Address: 0x17aee8 - 0x17af00

void entry_17aee8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17aee8: 0xe61405c4
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 1476), *(uint32_t*)&val); }
    // 0x17aeec: 0x260382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17aef0: 0x8e040600
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1536)));
    // 0x17aef4: 0x24060005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    // 0x17aef8: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x17af00);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_17af00
// Address: 0x17af00 - 0x17af0c

void entry_17af00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17af00: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17af04: 0xc05ed04
    SET_GPR_U32(ctx, 31, 0x17af0c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_0017b410(rdram, ctx, runtime); return;
}


// Function: entry_17af0c
// Address: 0x17af0c - 0x17af18

void entry_17af0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17af0c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17af10: 0xc05ed44
    SET_GPR_U32(ctx, 31, 0x17af18);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    FUN_0017b510(rdram, ctx, runtime); return;
}


// Function: entry_17af18
// Address: 0x17af18 - 0x17af38

void entry_17af18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17af18: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17af1c: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17af20: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17af24: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17af28: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17af2c: 0xc7b40050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[20] = *(float*)&val; }
    // 0x17af30: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017af38
// Address: 0x17af38 - 0x17af4c

void FUN_0017af38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17af38: 0x27bdff60
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967136));
    // 0x17af3c: 0x7fb00080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 16));
    // 0x17af40: 0x7fbf0090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), GPR_VEC(ctx, 31));
    // 0x17af44: 0xc06e4fe
    SET_GPR_U32(ctx, 31, 0x17af4c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    UpdateSo__FP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_17af4c
// Address: 0x17af4c - 0x17af7c

void entry_17af4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17af4c: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x17af50: 0x44000b2
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), 2));
    if (GPR_S32(ctx, 2) < 0) {
        entry_17b21c(rdram, ctx, runtime); return;
    }
    // 0x17af58: 0x104000b0
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17b21c(rdram, ctx, runtime); return;
    }
    // 0x17af60: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17af64: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17af68: 0x26060140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 16), 320));
    // 0x17af6c: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17af70: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17af74: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x17af7c);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_17af7c
// Address: 0x17af7c - 0x17afe0

void entry_17af7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17af7c: 0x26020110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 16), 272));
    // 0x17af80: 0xda010110
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 272)));
    // 0x17af84: 0xd8430020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x17af88: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17af8c: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x17af90: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17af94: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17af98: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17af9c: 0x4be40a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17afa0: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x17afa4: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17afa8: 0x4be419aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17afac: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x17afb0: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17afb4: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x17afb8: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17afbc: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x17afc0: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17afc4: 0xc46c3df4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 15860)); ctx->f[12] = *(float*)&val; }
    // 0x17afc8: 0xfba50010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x17afcc: 0x27a60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 64));
    // 0x17afd0: 0x27a70050
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 80));
    // 0x17afd4: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x17afd8: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x17afe0);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_17afe0
// Address: 0x17afe0 - 0x17b0c4

void entry_17afe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17afe0) {
        switch (ctx->pc) {
            case 0x17b068: ctx->pc = 0; goto label_17b068;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17afe0: 0xdba40020
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17afe4: 0xdba30050
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x17afe8: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17afec: 0xdba10070
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x17aff0: 0x4be41a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17aff4: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x17aff8: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17affc: 0x4be409aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17b000: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x17b004: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17b008: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x17b00c: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17b010: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x17b014: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17b018: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x17b01c: 0x1440002b
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[5]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B0CC; return;
    }
    // 0x17b024: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17b028: 0xc7a10030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[1] = *(float*)&val; }
    // 0x17b02c: 0xc4403df8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15864)); ctx->f[0] = *(float*)&val; }
    // 0x17b030: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x17b034: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x17b038: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x17b03c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b040: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17b044: 0x46040834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[4])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b048: 0x0
    // NOP
    // 0x17b04c: 0x45010006
    ctx->f[2] = FPU_MOV_S(ctx->f[4]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17b068;
    }
    // 0x17b054: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b058: 0x0
    // NOP
    // 0x17b05c: 0x45000002
    ctx->f[2] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17b068;
    }
    // 0x17b064: 0x46000086
    ctx->f[2] = FPU_MOV_S(ctx->f[0]);
label_17b068:
    // 0x17b068: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17b06c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17b070: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b074: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17b078: 0x46001107
    ctx->f[4] = FPU_NEG_S(ctx->f[2]);
    // 0x17b07c: 0x460200e8
    ctx->f[3] = std::max(ctx->f[0], ctx->f[2]);
    // 0x17b080: 0xc4453ac0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15040)); ctx->f[5] = *(float*)&val; }
    // 0x17b084: 0x46030881
    ctx->f[2] = FPU_SUB_S(ctx->f[1], ctx->f[3]);
    // 0x17b088: 0x8e04058c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1420)));
    // 0x17b08c: 0x46050841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[5]);
    // 0x17b090: 0x46040028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[4]);
    // 0x17b094: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x17b098: 0xe6050580
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 1408), *(uint32_t*)&val); }
    // 0x17b09c: 0x46001081
    ctx->f[2] = FPU_SUB_S(ctx->f[2], ctx->f[0]);
    // 0x17b0a0: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x17b0a4: 0x460118c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[1]);
    // 0x17b0a8: 0x2607055c
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1372));
    // 0x17b0ac: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x17b0b0: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x17b0b4: 0xe603055c
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 1372), *(uint32_t*)&val); }
    // 0x17b0b8: 0xe6000574
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1396), *(uint32_t*)&val); }
    // 0x17b0bc: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x17b0c4);
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1384), *(uint32_t*)&val); }
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_17b0c4
// Address: 0x17b0c4 - 0x17b21c

void entry_17b0c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b0c4) {
        switch (ctx->pc) {
            case 0x17b0cc: ctx->pc = 0; goto label_17b0cc;
            case 0x17b10c: ctx->pc = 0; goto label_17b10c;
            case 0x17b150: ctx->pc = 0; goto label_17b150;
            case 0x17b1a0: ctx->pc = 0; goto label_17b1a0;
            case 0x17b1b4: ctx->pc = 0; goto label_17b1b4;
            case 0x17b1ec: ctx->pc = 0; goto label_17b1ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b0c4: 0x10000055
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17b21c(rdram, ctx, runtime); return;
    }
label_17b0cc:
    // 0x17b0cc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17b0d0: 0xc7a10030
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[1] = *(float*)&val; }
    // 0x17b0d4: 0xc4403dfc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15868)); ctx->f[0] = *(float*)&val; }
    // 0x17b0d8: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x17b0dc: 0x46000803
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[0] = ctx->f[1] / ctx->f[0];
    // 0x17b0e0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b0e4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17b0e8: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b0ec: 0x0
    // NOP
    // 0x17b0f0: 0x45010006
    ctx->f[5] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17b10c;
    }
    // 0x17b0f8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b0fc: 0x0
    // NOP
    // 0x17b100: 0x45000002
    ctx->f[5] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17b10c;
    }
    // 0x17b108: 0x46000946
    ctx->f[5] = FPU_MOV_S(ctx->f[1]);
label_17b10c:
    // 0x17b10c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17b110: 0xc7a10034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 52)); ctx->f[1] = *(float*)&val; }
    // 0x17b114: 0xc4403e00
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15872)); ctx->f[0] = *(float*)&val; }
    // 0x17b118: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x17b11c: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x17b120: 0x46000843
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[1] = copysignf(INFINITY, ctx->f[1] * 0.0f); } else ctx->f[1] = ctx->f[1] / ctx->f[0];
    // 0x17b124: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b128: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17b12c: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b130: 0x0
    // NOP
    // 0x17b134: 0x45010006
    ctx->f[3] = FPU_MOV_S(ctx->f[2]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17b150;
    }
    // 0x17b13c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b140: 0x0
    // NOP
    // 0x17b144: 0x45000002
    ctx->f[3] = FPU_MOV_S(ctx->f[1]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17b150;
    }
    // 0x17b14c: 0x460000c6
    ctx->f[3] = FPU_MOV_S(ctx->f[0]);
label_17b150:
    // 0x17b150: 0x46002805
    ctx->f[0] = FPU_ABS_S(ctx->f[5]);
    // 0x17b154: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b158: 0x44812000
    *(uint32_t*)&ctx->f[4] = GPR_U32(ctx, 1);
    // 0x17b15c: 0x46001885
    ctx->f[2] = FPU_ABS_S(ctx->f[3]);
    // 0x17b160: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17b164: 0xc4413ac0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15040)); ctx->f[1] = *(float*)&val; }
    // 0x17b168: 0x44803000
    *(uint32_t*)&ctx->f[6] = GPR_U32(ctx, 0);
    // 0x17b16c: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x17b170: 0x46012041
    ctx->f[1] = FPU_SUB_S(ctx->f[4], ctx->f[1]);
    // 0x17b174: 0x46002028
    ctx->f[0] = std::max(ctx->f[4], ctx->f[0]);
    // 0x17b178: 0x46002003
    if (ctx->f[0] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[0] = copysignf(INFINITY, ctx->f[4] * 0.0f); } else ctx->f[0] = ctx->f[4] / ctx->f[0];
    // 0x17b17c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x17b180: 0x460018c2
    ctx->f[3] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x17b184: 0x46002942
    ctx->f[5] = FPU_MUL_S(ctx->f[5], ctx->f[0]);
    // 0x17b188: 0x46061834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[6])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b18c: 0x0
    // NOP
    // 0x17b190: 0x45000003
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 1436), *(uint32_t*)&val); }
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17b1a0;
    }
    // 0x17b198: 0x10000006
    ctx->f[1] = FPU_MOV_S(ctx->f[6]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17b1b4;
    }
label_17b1a0:
    // 0x17b1a0: 0x46032034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[4], ctx->f[3])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b1a4: 0x0
    // NOP
    // 0x17b1a8: 0x45000002
    ctx->f[1] = FPU_MOV_S(ctx->f[3]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17b1b4;
    }
    // 0x17b1b0: 0x46002046
    ctx->f[1] = FPU_MOV_S(ctx->f[4]);
label_17b1b4:
    // 0x17b1b4: 0x46001807
    ctx->f[0] = FPU_NEG_S(ctx->f[3]);
    // 0x17b1b8: 0xe60105a8
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1448), *(uint32_t*)&val); }
    // 0x17b1bc: 0x44800800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 0);
    // 0x17b1c0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b1c4: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x17b1c8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b1cc: 0x0
    // NOP
    // 0x17b1d0: 0x45010006
    ctx->f[4] = FPU_MOV_S(ctx->f[1]);
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17b1ec;
    }
    // 0x17b1d8: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b1dc: 0x0
    // NOP
    // 0x17b1e0: 0x45000002
    ctx->f[4] = FPU_MOV_S(ctx->f[0]);
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17b1ec;
    }
    // 0x17b1e8: 0x46001106
    ctx->f[4] = FPU_MOV_S(ctx->f[2]);
label_17b1ec:
    // 0x17b1ec: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b1f0: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17b1f4: 0x46001845
    ctx->f[1] = FPU_ABS_S(ctx->f[3]);
    // 0x17b1f8: 0x8e0405c0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1472)));
    // 0x17b1fc: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x17b200: 0x46050001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[5]);
    // 0x17b204: 0xe60405b4
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 1460), *(uint32_t*)&val); }
    // 0x17b208: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x17b20c: 0x26070590
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1424));
    // 0x17b210: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x17b214: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x17b21c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1424), *(uint32_t*)&val); }
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_17b21c
// Address: 0x17b21c - 0x17b224

void entry_17b21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b21c: 0xc06497c
    SET_GPR_U32(ctx, 31, 0x17b224);
    PpoCur__Fv(rdram, ctx, runtime); return;
}


// Function: entry_17b224
// Address: 0x17b224 - 0x17b23c

void entry_17b224(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b224: 0x10400027
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 2), 320));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17b2c4(rdram, ctx, runtime); return;
    }
    // 0x17b22c: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17b230: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17b234: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17b23c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17b23c
// Address: 0x17b23c - 0x17b250

void entry_17b23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b23c: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x17b240: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17b244: 0x24848d00
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937856));
    // 0x17b248: 0xc07b642
    SET_GPR_U32(ctx, 31, 0x17b250);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    RadBetweenVectors__FP6VECTORN20(rdram, ctx, runtime); return;
}


// Function: entry_17b250
// Address: 0x17b250 - 0x17b2c4

void entry_17b250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b250: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b254: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x17b258: 0x2405000c
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 12));
    // 0x17b25c: 0xc7a60014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[6] = *(float*)&val; }
    // 0x17b260: 0x24060005
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 5));
    // 0x17b264: 0x46001829
    ctx->f[0] = std::min(ctx->f[3], ctx->f[0]);
    // 0x17b268: 0xc7a40018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[4] = *(float*)&val; }
    // 0x17b26c: 0x46000047
    ctx->f[1] = FPU_NEG_S(ctx->f[0]);
    // 0x17b270: 0x8e040600
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1536)));
    // 0x17b274: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x17b278: 0x260705c4
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1476));
    // 0x17b27c: 0x46040002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[4]);
    // 0x17b280: 0x46060842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[6]);
    // 0x17b284: 0x46000147
    ctx->f[5] = FPU_NEG_S(ctx->f[0]);
    // 0x17b288: 0x46000907
    ctx->f[4] = FPU_NEG_S(ctx->f[1]);
    // 0x17b28c: 0x46020028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[2]);
    // 0x17b290: 0x46020868
    ctx->f[1] = std::max(ctx->f[1], ctx->f[2]);
    // 0x17b294: 0xe60005e8
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1512), *(uint32_t*)&val); }
    // 0x17b298: 0x460118c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[1]);
    // 0x17b29c: 0x46022968
    ctx->f[5] = std::max(ctx->f[5], ctx->f[2]);
    // 0x17b2a0: 0x46022128
    ctx->f[4] = std::max(ctx->f[4], ctx->f[2]);
    // 0x17b2a4: 0xe60105d0
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 1488), *(uint32_t*)&val); }
    // 0x17b2a8: 0xe60505f4
    { float val = ctx->f[5]; WRITE32(ADD32(GPR_U32(ctx, 16), 1524), *(uint32_t*)&val); }
    // 0x17b2ac: 0x460418c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[4]);
    // 0x17b2b0: 0xe60405dc
    { float val = ctx->f[4]; WRITE32(ADD32(GPR_U32(ctx, 16), 1500), *(uint32_t*)&val); }
    // 0x17b2b4: 0x460018c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[0]);
    // 0x17b2b8: 0x460518c1
    ctx->f[3] = FPU_SUB_S(ctx->f[3], ctx->f[5]);
    // 0x17b2bc: 0xc04e67e
    SET_GPR_U32(ctx, 31, 0x17b2c4);
    { float val = ctx->f[3]; WRITE32(ADD32(GPR_U32(ctx, 16), 1476), *(uint32_t*)&val); }
    ReblendAsegbl__FP6ASEGBLiiPv(rdram, ctx, runtime); return;
}


// Function: entry_17b2c4
// Address: 0x17b2c4 - 0x17b2f0

void entry_17b2c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b2c4: 0x8e040610
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1552)));
    // 0x17b2c8: 0x1080000b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B2F8; return;
    }
    // 0x17b2d0: 0xc4810018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[1] = *(float*)&val; }
    // 0x17b2d4: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17b2d8: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b2dc: 0x0
    // NOP
    // 0x17b2e0: 0x45020006
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
        ctx->pc = 0x17B2FC; return;
    }
    // 0x17b2e8: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x17b2f0);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_17b2f0
// Address: 0x17b2f0 - 0x17b308

void entry_17b2f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b2f0) {
        switch (ctx->pc) {
            case 0x17b2f8: ctx->pc = 0; goto label_17b2f8;
            case 0x17b2fc: ctx->pc = 0; goto label_17b2fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b2f0: 0xae000610
    WRITE32(ADD32(GPR_U32(ctx, 16), 1552), GPR_U32(ctx, 0));
    // 0x17b2f4: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_17b2f8:
    // 0x17b2f8: 0x7bb00080
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 128)));
label_17b2fc:
    // 0x17b2fc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17b304: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17b308; return;
}


// Function: FUN_0017b308
// Address: 0x17b308 - 0x17b334

void FUN_0017b308(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b308: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x17b30c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17b310: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x17b314: 0x8c830550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1360)));
    // 0x17b318: 0x28620002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    // 0x17b31c: 0x10400012
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B368; return;
    }
    // 0x17b324: 0x4600010
    if (GPR_S32(ctx, 3) < 0) {
        ctx->pc = 0x17B368; return;
    }
    // 0x17b32c: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x17b334);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_17b334
// Address: 0x17b334 - 0x17b380

void entry_17b334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b334) {
        switch (ctx->pc) {
            case 0x17b368: ctx->pc = 0; goto label_17b368;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b334: 0x1040000c
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17b368;
    }
    // 0x17b33c: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x17b340: 0x8c430458
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x17b344: 0x54640008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
        goto label_17b368;
    }
    // 0x17b34c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x17b350: 0x8c430b54
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 2900)));
    // 0x17b354: 0x14600004
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_17b368;
    }
    // 0x17b35c: 0x8c4317cc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6092)));
    // 0x17b360: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
        goto label_17b368;
    }
label_17b368:
    // 0x17b368: 0x12000007
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B388; return;
    }
    // 0x17b370: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x17b374: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x17b378: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17b380);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17b380
// Address: 0x17b380 - 0x17b398

void entry_17b380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b380) {
        switch (ctx->pc) {
            case 0x17b388: ctx->pc = 0; goto label_17b388;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b380: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B39C; return;
    }
label_17b388:
    // 0x17b388: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x17b38c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x17b390: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17b398);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17b398
// Address: 0x17b398 - 0x17b3a8

void entry_17b398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b398) {
        switch (ctx->pc) {
            case 0x17b39c: ctx->pc = 0; goto label_17b39c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b398: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_17b39c:
    // 0x17b39c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b3a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017b3a8
// Address: 0x17b3a8 - 0x17b3e0

void FUN_0017b3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b3a8: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x17b3ac: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17b3b0: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x17b3b4: 0x8ca20010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 16)));
    // 0x17b3b8: 0x30420010
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 16));
    // 0x17b3bc: 0x1040000f
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17b3fc(rdram, ctx, runtime); return;
    }
    // 0x17b3c4: 0x8ca30004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 4)));
    // 0x17b3c8: 0x8e020608
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1544)));
    // 0x17b3cc: 0x1462000c
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x17B400; return;
    }
    // 0x17b3d4: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x17b3d8: 0xc06b018
    SET_GPR_U32(ctx, 31, 0x17b3e0);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    FUN_001ac060(rdram, ctx, runtime); return;
}


// Function: entry_17b3e0
// Address: 0x17b3e0 - 0x17b3e8

void entry_17b3e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b3e0: 0xc05ed66
    SET_GPR_U32(ctx, 31, 0x17b3e8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0017b598(rdram, ctx, runtime); return;
}


// Function: entry_17b3e8
// Address: 0x17b3e8 - 0x17b3fc

void entry_17b3e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b3e8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17b3ec: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17b3f0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17b3f4: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x17b3fc);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_17b3fc
// Address: 0x17b3fc - 0x17b410

void entry_17b3fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b3fc) {
        switch (ctx->pc) {
            case 0x17b400: ctx->pc = 0; goto label_17b400;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b3fc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_17b400:
    // 0x17b400: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17b404: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b408: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017b410
// Address: 0x17b410 - 0x17b498

void FUN_0017b410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b410) {
        switch (ctx->pc) {
            case 0x17b454: ctx->pc = 0; goto label_17b454;
            case 0x17b458: ctx->pc = 0; goto label_17b458;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b410: 0x27bdffc0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967232));
    // 0x17b414: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x17b418: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17b41c: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x17b420: 0x7fbf0030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 31));
    // 0x17b424: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17b428: 0x7fb20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 18));
    // 0x17b42c: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x17b430: 0x12220032
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17B4FC; return;
    }
    // 0x17b438: 0x12200006
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        goto label_17b454;
    }
    // 0x17b440: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17b444: 0x52220004
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1472)));
        goto label_17b458;
    }
    // 0x17b44c: 0x10000002
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17b458;
    }
label_17b454:
    // 0x17b454: 0x8e12058c
    SET_GPR_U32(ctx, 18, READ32(ADD32(GPR_U32(ctx, 16), 1420)));
label_17b458:
    // 0x17b458: 0x620001b
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 2));
    if (GPR_S32(ctx, 17) < 0) {
        entry_17b4c8(rdram, ctx, runtime); return;
    }
    // 0x17b460: 0x1040000f
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B4A0; return;
    }
    // 0x17b468: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b46c: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17b470: 0x2442e248
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294959688));
    // 0x17b474: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17b478: 0x8c440264
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 612)));
    // 0x17b47c: 0x8c430260
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 608)));
    // 0x17b480: 0xe4400278
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 632), *(uint32_t*)&val); }
    // 0x17b484: 0xac43026c
    WRITE32(ADD32(GPR_U32(ctx, 2), 620), GPR_U32(ctx, 3));
    // 0x17b488: 0xac440270
    WRITE32(ADD32(GPR_U32(ctx, 2), 624), GPR_U32(ctx, 4));
    // 0x17b48c: 0xac400274
    WRITE32(ADD32(GPR_U32(ctx, 2), 628), GPR_U32(ctx, 0));
    // 0x17b490: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x17b498);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_17b498
// Address: 0x17b498 - 0x17b4bc

void entry_17b498(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b498) {
        switch (ctx->pc) {
            case 0x17b4a0: ctx->pc = 0; goto label_17b4a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b498: 0x1000000b
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17b4c8(rdram, ctx, runtime); return;
    }
label_17b4a0:
    // 0x17b4a0: 0x2a220004
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), 4));
    // 0x17b4a4: 0x10400008
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17b4c8(rdram, ctx, runtime); return;
    }
    // 0x17b4ac: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x17b4b0: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x17b4b4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17b4bc);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17b4bc
// Address: 0x17b4bc - 0x17b4c8

void entry_17b4bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b4bc: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x17b4c0: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x17b4c8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_17b4c8
// Address: 0x17b4c8 - 0x17b4e8

void entry_17b4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b4c8: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x17b4cc: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17b4d0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b4d4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x17b4d8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17b4dc: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17b4e0: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x17b4e8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1368));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_17b4e8
// Address: 0x17b4e8 - 0x17b510

void entry_17b4e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b4e8) {
        switch (ctx->pc) {
            case 0x17b4fc: ctx->pc = 0; goto label_17b4fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b4e8: 0xae110550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 17));
    // 0x17b4ec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17b4f0: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17b4f4: 0xe6000554
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1364), *(uint32_t*)&val); }
    // 0x17b4f8: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
label_17b4fc:
    // 0x17b4fc: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17b500: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17b504: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b508: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017b510
// Address: 0x17b510 - 0x17b544

void FUN_0017b510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b510) {
        switch (ctx->pc) {
            case 0x17b524: ctx->pc = 0; goto label_17b524;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b510: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x17b514: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17b518: 0x10a00002
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        goto label_17b524;
    }
    // 0x17b520: 0x8c820600
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 1536)));
label_17b524:
    // 0x17b524: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17b528: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x17b52c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b530: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x17b534: 0x40202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17b538: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17b53c: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x17b544);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 5), 1540));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_17b544
// Address: 0x17b544 - 0x17b550

void entry_17b544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b544: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b548: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017b550
// Address: 0x17b550 - 0x17b584

void FUN_0017b550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b550) {
        switch (ctx->pc) {
            case 0x17b570: ctx->pc = 0; goto label_17b570;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b550: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x17b554: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x17b558: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17b55c: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x17b560: 0x14a20003
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 2)) {
        goto label_17b570;
    }
    // 0x17b568: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 1548), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B588; return;
    }
label_17b570:
    // 0x17b570: 0xa0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x17b574: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x17b578: 0x24050101
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 257));
    // 0x17b57c: 0xc056906
    SET_GPR_U32(ctx, 31, 0x17b584);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_17b584
// Address: 0x17b584 - 0x17b598

void entry_17b584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b584) {
        switch (ctx->pc) {
            case 0x17b588: ctx->pc = 0; goto label_17b588;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b584: 0xae02060c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1548), GPR_U32(ctx, 2));
label_17b588:
    // 0x17b588: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17b58c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b590: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017b598
// Address: 0x17b598 - 0x17b5c0

void FUN_0017b598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b598: 0x27bdfff0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967280));
    // 0x17b59c: 0x80282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17b5a0: 0x7fbf0000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 31));
    // 0x17b5a4: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17b5a8: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x17b5ac: 0x24a70610
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 5), 1552));
    // 0x17b5b0: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b5b4: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x17b5b8: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x17b5c0);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 1548)));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_17b5c0
// Address: 0x17b5c0 - 0x17b5d0

void entry_17b5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b5c0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b5c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17b5cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17b5d0; return;
}


// Function: FUN_0017b5d0
// Address: 0x17b5d0 - 0x17b5e4

void FUN_0017b5d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b5d0: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x17b5d4: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17b5d8: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x17b5dc: 0xc06de5a
    SET_GPR_U32(ctx, 31, 0x17b5e4);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    InitSo__FP2SO(rdram, ctx, runtime); return;
}


// Function: entry_17b5e4
// Address: 0x17b5e4 - 0x17b610

void entry_17b5e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b5e4: 0x24020010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 16));
    // 0x17b5e8: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x17b5ec: 0xae020558
    WRITE32(ADD32(GPR_U32(ctx, 16), 1368), GPR_U32(ctx, 2));
    // 0x17b5f0: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x17b5f4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17b5f8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17b5fc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b600: 0xac833e2c
    WRITE32(ADD32(GPR_U32(ctx, 4), 15916), GPR_U32(ctx, 3));
    // 0x17b604: 0xac403e30
    WRITE32(ADD32(GPR_U32(ctx, 2), 15920), GPR_U32(ctx, 0));
    // 0x17b608: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017b610
// Address: 0x17b610 - 0x17b624

void FUN_0017b610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b610: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x17b614: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17b618: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x17b61c: 0xc049292
    SET_GPR_U32(ctx, 31, 0x17b624);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    PostAloLoad__FP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_17b624
// Address: 0x17b624 - 0x17b638

void entry_17b624(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b624: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x17b628: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17b62c: 0x24c63e08
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 15880));
    // 0x17b630: 0xc04937e
    SET_GPR_U32(ctx, 31, 0x17b638);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SnipAloObjects__FP3ALOiP4SNIP(rdram, ctx, runtime); return;
}


// Function: entry_17b638
// Address: 0x17b638 - 0x17b648

void entry_17b638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b638: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17b63c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b640: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017b648
// Address: 0x17b648 - 0x17b65c

void FUN_0017b648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b648: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x17b64c: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17b650: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x17b654: 0xc06e4fe
    SET_GPR_U32(ctx, 31, 0x17b65c);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    UpdateSo__FP2SOf(rdram, ctx, runtime); return;
}


// Function: entry_17b65c
// Address: 0x17b65c - 0x17b688

void entry_17b65c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b65c: 0x8e040568
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1384)));
    // 0x17b660: 0x1080000b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B690; return;
    }
    // 0x17b668: 0xc4810018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[1] = *(float*)&val; }
    // 0x17b66c: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17b670: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b674: 0x0
    // NOP
    // 0x17b678: 0x45000006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17B694; return;
    }
    // 0x17b680: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x17b688);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_17b688
// Address: 0x17b688 - 0x17b6a8

void entry_17b688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b688) {
        switch (ctx->pc) {
            case 0x17b690: ctx->pc = 0; goto label_17b690;
            case 0x17b694: ctx->pc = 0; goto label_17b694;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b688: 0xae000568
    WRITE32(ADD32(GPR_U32(ctx, 16), 1384), GPR_U32(ctx, 0));
    // 0x17b68c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_17b690:
    // 0x17b690: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
label_17b694:
    // 0x17b694: 0x8c453e2c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 15916)));
    // 0x17b698: 0x50a30004
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 3)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
        ctx->pc = 0x17B6AC; return;
    }
    // 0x17b6a0: 0xc05ee30
    SET_GPR_U32(ctx, 31, 0x17b6a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FUN_0017b8c0(rdram, ctx, runtime); return;
}


// Function: entry_17b6a8
// Address: 0x17b6a8 - 0x17b6fc

void entry_17b6a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b6a8) {
        switch (ctx->pc) {
            case 0x17b6ac: ctx->pc = 0; goto label_17b6ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b6a8: 0x8e030550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
label_17b6ac:
    // 0x17b6ac: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17b6b0: 0x14620013
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x17B700; return;
    }
    // 0x17b6b8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17b6bc: 0xc6020554
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1364)); ctx->f[2] = *(float*)&val; }
    // 0x17b6c0: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17b6c4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17b6c8: 0xc4413e04
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15876)); ctx->f[1] = *(float*)&val; }
    // 0x17b6cc: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17b6d0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17b6d4: 0x0
    // NOP
    // 0x17b6d8: 0x45000009
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17B700; return;
    }
    // 0x17b6e0: 0x8c623e30
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 15920)));
    // 0x17b6e4: 0x14400007
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B704; return;
    }
    // 0x17b6ec: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17b6f0: 0x24040002
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17b6f4: 0xc05815e
    SET_GPR_U32(ctx, 31, 0x17b6fc);
    WRITE32(ADD32(GPR_U32(ctx, 3), 15920), GPR_U32(ctx, 2));
    PlayEndingFromCompletionFlags(rdram, ctx, runtime); return;
}


// Function: entry_17b6fc
// Address: 0x17b6fc - 0x17b710

void entry_17b6fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b6fc) {
        switch (ctx->pc) {
            case 0x17b700: ctx->pc = 0; goto label_17b700;
            case 0x17b704: ctx->pc = 0; goto label_17b704;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b6fc: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_17b700:
    // 0x17b700: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
label_17b704:
    // 0x17b704: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17b70c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17b710; return;
}


// Function: FUN_0017b710
// Address: 0x17b710 - 0x17b734

void FUN_0017b710(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b710: 0x27bdffe0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967264));
    // 0x17b714: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17b718: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17b71c: 0x7fbf0010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 31));
    // 0x17b720: 0x8c830550
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1360)));
    // 0x17b724: 0x14620010
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x17B768; return;
    }
    // 0x17b72c: 0xc07a65c
    SET_GPR_U32(ctx, 31, 0x17b734);
    FUN_001e9970__Fv(rdram, ctx, runtime); return;
}


// Function: entry_17b734
// Address: 0x17b734 - 0x17b780

void entry_17b734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b734) {
        switch (ctx->pc) {
            case 0x17b768: ctx->pc = 0; goto label_17b768;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b734: 0x1040000c
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17b768;
    }
    // 0x17b73c: 0x24040003
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 3));
    // 0x17b740: 0x8c430458
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 1112)));
    // 0x17b744: 0x54640008
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 4)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
        goto label_17b768;
    }
    // 0x17b74c: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x17b750: 0x8c430b54
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 2900)));
    // 0x17b754: 0x14600004
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_17b768;
    }
    // 0x17b75c: 0x8c4317cc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 6092)));
    // 0x17b760: 0x50600001
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
        goto label_17b768;
    }
label_17b768:
    // 0x17b768: 0x12000007
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B788; return;
    }
    // 0x17b770: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x17b774: 0x8c620038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 56)));
    // 0x17b778: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17b780);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17b780
// Address: 0x17b780 - 0x17b798

void entry_17b780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b780) {
        switch (ctx->pc) {
            case 0x17b788: ctx->pc = 0; goto label_17b788;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b780: 0x10000006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B79C; return;
    }
label_17b788:
    // 0x17b788: 0x8c83e248
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 4294959688)));
    // 0x17b78c: 0x8c62003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 60)));
    // 0x17b790: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17b798);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17b798
// Address: 0x17b798 - 0x17b7a8

void entry_17b798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b798) {
        switch (ctx->pc) {
            case 0x17b79c: ctx->pc = 0; goto label_17b79c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b798: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_17b79c:
    // 0x17b79c: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b7a0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017b7a8
// Address: 0x17b7a8 - 0x17b7ec

void FUN_0017b7a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b7a8: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x17b7ac: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x17b7b0: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17b7b4: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x17b7b8: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x17b7bc: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x17b7c0: 0x30420020
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 32));
    // 0x17b7c4: 0x10400035
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17b89c(rdram, ctx, runtime); return;
    }
    // 0x17b7cc: 0x8e020558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x17b7d0: 0x3c040027
    SET_GPR_U32(ctx, 4, ((uint32_t)39 << 16));
    // 0x17b7d4: 0x2484e248
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294959688));
    // 0x17b7d8: 0x2442ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967295));
    // 0x17b7dc: 0x2182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 0), GPR_S32(ctx, 2)));
    // 0x17b7e0: 0x3100a
    if (GPR_U32(ctx, 3) == 0) SET_GPR_U32(ctx, 2, GPR_U32(ctx, 0));
    // 0x17b7e4: 0xc06b018
    SET_GPR_U32(ctx, 31, 0x17b7ec);
    WRITE32(ADD32(GPR_U32(ctx, 16), 1368), GPR_U32(ctx, 2));
    FUN_001ac060(rdram, ctx, runtime); return;
}


// Function: entry_17b7ec
// Address: 0x17b7ec - 0x17b878

void entry_17b7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b7ec) {
        switch (ctx->pc) {
            case 0x17b80c: ctx->pc = 0; goto label_17b80c;
            case 0x17b844: ctx->pc = 0; goto label_17b844;
            case 0x17b858: ctx->pc = 0; goto label_17b858;
            case 0x17b85c: ctx->pc = 0; goto label_17b85c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b7ec: 0x8e020558
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
    // 0x17b7f0: 0x54400006
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 16)));
        goto label_17b80c;
    }
    // 0x17b7f8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17b7fc: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17b800: 0xac623e2c
    WRITE32(ADD32(GPR_U32(ctx, 3), 15916), GPR_U32(ctx, 2));
    // 0x17b804: 0x10000015
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17b85c;
    }
label_17b80c:
    // 0x17b80c: 0x30620002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 2));
    // 0x17b810: 0x1040000c
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17b844;
    }
    // 0x17b818: 0x8c422e10
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 11792)));
    // 0x17b81c: 0x5040000f
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
        goto label_17b85c;
    }
    // 0x17b824: 0x8c43223c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 8764)));
    // 0x17b828: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x17b82c: 0x1062000a
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17b858;
    }
    // 0x17b834: 0x50620009
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
        goto label_17b85c;
    }
    // 0x17b83c: 0x10000007
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1376)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17b85c;
    }
label_17b844:
    // 0x17b844: 0x30620004
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 3), 4));
    // 0x17b848: 0x50400004
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
        goto label_17b85c;
    }
    // 0x17b850: 0x10000002
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1380)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17b85c;
    }
label_17b858:
    // 0x17b858: 0x8e04055c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 1372)));
label_17b85c:
    // 0x17b85c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x17b860: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17b864: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b868: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x17b86c: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17b870: 0xc04b246
    SET_GPR_U32(ctx, 31, 0x17b878);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 1384));
    ApplyAsegCur__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_17b878
// Address: 0x17b878 - 0x17b89c

void entry_17b878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b878: 0x8e22000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 12)));
    // 0x17b87c: 0x2403ffdf
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967263));
    // 0x17b880: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17b884: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17b888: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x17b88c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17b890: 0xae22000c
    WRITE32(ADD32(GPR_U32(ctx, 17), 12), GPR_U32(ctx, 2));
    // 0x17b894: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x17b89c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_17b89c
// Address: 0x17b89c - 0x17b8a8

void entry_17b89c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b89c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17b8a0: 0xc06f0c8
    SET_GPR_U32(ctx, 31, 0x17b8a8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FAbsorbSoWkr__FP2SOP3WKR(rdram, ctx, runtime); return;
}


// Function: entry_17b8a8
// Address: 0x17b8a8 - 0x17b8c0

void entry_17b8a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b8a8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17b8ac: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17b8b0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b8b4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17b8bc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17b8c0; return;
}


// Function: FUN_0017b8c0
// Address: 0x17b8c0 - 0x17b954

void FUN_0017b8c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b8c0) {
        switch (ctx->pc) {
            case 0x17b908: ctx->pc = 0; goto label_17b908;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b8c0: 0x27bdffd0
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967248));
    // 0x17b8c4: 0x7fb10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 17));
    // 0x17b8c8: 0x7fb00000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 16));
    // 0x17b8cc: 0xa0882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x17b8d0: 0x7fbf0020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 31));
    // 0x17b8d4: 0x80802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17b8d8: 0x8e020550
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 1360)));
    // 0x17b8dc: 0x12220028
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17B980; return;
    }
    // 0x17b8e4: 0x2403ffff
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x17b8e8: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17b8ec: 0x12240006
    WRITE32(ADD32(GPR_U32(ctx, 2), 15916), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 4)) {
        goto label_17b908;
    }
    // 0x17b8f4: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17b8f8: 0x12220018
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17B95C; return;
    }
    // 0x17b900: 0x1000001c
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B974; return;
    }
label_17b908:
    // 0x17b908: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x17b90c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17b910: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17b914: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x17b918: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17b91c: 0x2442e248
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294959688));
    // 0x17b920: 0x24030004
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 4));
    // 0x17b924: 0x24040010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 16));
    // 0x17b928: 0xe440027c
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 636), *(uint32_t*)&val); }
    // 0x17b92c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17b930: 0xac430270
    WRITE32(ADD32(GPR_U32(ctx, 2), 624), GPR_U32(ctx, 3));
    // 0x17b934: 0xac440268
    WRITE32(ADD32(GPR_U32(ctx, 2), 616), GPR_U32(ctx, 4));
    // 0x17b938: 0xe4410278
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 632), *(uint32_t*)&val); }
    // 0x17b93c: 0xac430260
    WRITE32(ADD32(GPR_U32(ctx, 2), 608), GPR_U32(ctx, 3));
    // 0x17b940: 0xac43026c
    WRITE32(ADD32(GPR_U32(ctx, 2), 620), GPR_U32(ctx, 3));
    // 0x17b944: 0xac430264
    WRITE32(ADD32(GPR_U32(ctx, 2), 612), GPR_U32(ctx, 3));
    // 0x17b948: 0xac400274
    WRITE32(ADD32(GPR_U32(ctx, 2), 628), GPR_U32(ctx, 0));
    // 0x17b94c: 0xc07770e
    SET_GPR_U32(ctx, 31, 0x17b954);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    FUN_001ddc38(rdram, ctx, runtime); return;
}


// Function: entry_17b954
// Address: 0x17b954 - 0x17b964

void entry_17b954(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b954) {
        switch (ctx->pc) {
            case 0x17b95c: ctx->pc = 0; goto label_17b95c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b954: 0x10000007
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 17));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17B974; return;
    }
label_17b95c:
    // 0x17b95c: 0xc0580fa
    SET_GPR_U32(ctx, 31, 0x17b964);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 5));
    DefeatBossFromWid(rdram, ctx, runtime); return;
}


// Function: entry_17b964
// Address: 0x17b964 - 0x17b970

void entry_17b964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b964: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x17b968: 0xc0631fe
    SET_GPR_U32(ctx, 31, 0x17b970);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 19008));
    FUN_0018c7f8__FP4SAVE(rdram, ctx, runtime); return;
}


// Function: entry_17b970
// Address: 0x17b970 - 0x17b998

void entry_17b970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17b970) {
        switch (ctx->pc) {
            case 0x17b974: ctx->pc = 0; goto label_17b974;
            case 0x17b980: ctx->pc = 0; goto label_17b980;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17b970: 0xae110550
    WRITE32(ADD32(GPR_U32(ctx, 16), 1360), GPR_U32(ctx, 17));
label_17b974:
    // 0x17b974: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17b978: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17b97c: 0xe6000554
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1364), *(uint32_t*)&val); }
label_17b980:
    // 0x17b980: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17b984: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17b988: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b98c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17b994: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17b998; return;
}


// Function: InitJsg__FP3JSG
// Address: 0x17b998 - 0x17b9ac

void entry_17b9ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b9ac: 0xc063540
    SET_GPR_U32(ctx, 31, 0x17b9b4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 2560));
    PvAllocSwImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_17b9b4
// Address: 0x17b9b4 - 0x17b9d0

void entry_17b9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17b9b4: 0x24030001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17b9b8: 0xae020038
    WRITE32(ADD32(GPR_U32(ctx, 16), 56), GPR_U32(ctx, 2));
    // 0x17b9bc: 0xae030068
    WRITE32(ADD32(GPR_U32(ctx, 16), 104), GPR_U32(ctx, 3));
    // 0x17b9c0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17b9c4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17b9c8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: GetJsgLocation__FP3JSGP2LOP6VECTORPf
// Address: 0x17b9d0 - 0x17ba0c

void entry_17ba0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ba0c: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BA24; return;
    }
    // 0x17ba14: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x17ba1c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17ba1c
// Address: 0x17ba1c - 0x17ba2c

void entry_17ba1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ba1c) {
        switch (ctx->pc) {
            case 0x17ba24: ctx->pc = 0; goto label_17ba24;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ba1c: 0x10000048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1592)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BB40; return;
    }
label_17ba24:
    // 0x17ba24: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17ba2c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 115));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17ba2c
// Address: 0x17ba2c - 0x17ba3c

void entry_17ba2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ba2c: 0x1040000b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BA5C; return;
    }
    // 0x17ba34: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x17ba3c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17ba3c
// Address: 0x17ba3c - 0x17ba48

void entry_17ba3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ba3c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17ba40: 0xc07cf02
    SET_GPR_U32(ctx, 31, 0x17ba48);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 16));
    GetXfmMat__FP3XFMP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17ba48
// Address: 0x17ba48 - 0x17ba54

void entry_17ba48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ba48: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x17ba4c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x17ba54);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_17ba54
// Address: 0x17ba54 - 0x17ba68

void entry_17ba54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ba54) {
        switch (ctx->pc) {
            case 0x17ba5c: ctx->pc = 0; goto label_17ba5c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ba54: 0x1000003a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BB40; return;
    }
label_17ba5c:
    // 0x17ba5c: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17ba60: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17ba68);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 110));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17ba68
// Address: 0x17ba68 - 0x17ba84

void entry_17ba68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ba68: 0x10400021
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BAF0; return;
    }
    // 0x17ba70: 0x8e050018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x17ba74: 0x26260100
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 256));
    // 0x17ba78: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ba7c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17ba84);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17ba84
// Address: 0x17ba84 - 0x17bab4

void entry_17ba84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ba84: 0x8e040034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x17ba88: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17ba8c: 0x8c420028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 40)));
    // 0x17ba90: 0x10400008
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17bab4(rdram, ctx, runtime); return;
    }
    // 0x17ba98: 0x220402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17ba9c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17baa0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17baa4: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17baa8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17baac: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17bab4);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17bab4
// Address: 0x17bab4 - 0x17bac8

void entry_17bab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bab4: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x17bab8: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17babc: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17bac0: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17bac8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17bac8
// Address: 0x17bac8 - 0x17badc

void entry_17bac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bac8: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x17bacc: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17bad0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17bad4: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x17badc);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17badc
// Address: 0x17badc - 0x17bae8

void entry_17badc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17badc: 0xc7ac0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 52)); ctx->f[12] = *(float*)&val; }
    // 0x17bae0: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x17bae8);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_17bae8
// Address: 0x17bae8 - 0x17bafc

void entry_17bae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17bae8) {
        switch (ctx->pc) {
            case 0x17baf0: ctx->pc = 0; goto label_17baf0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17bae8: 0x10000015
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BB40; return;
    }
label_17baf0:
    // 0x17baf0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17baf4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17bafc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17bafc
// Address: 0x17bafc - 0x17bb18

void entry_17bafc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bafc: 0x50400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 256)));
        ctx->pc = 0x17BB24; return;
    }
    // 0x17bb04: 0x7a020140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x17bb08: 0xc60d0110
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 272)); ctx->f[13] = *(float*)&val; }
    // 0x17bb0c: 0xc60c0114
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 276)); ctx->f[12] = *(float*)&val; }
    // 0x17bb10: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x17bb18);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_17bb18
// Address: 0x17bb18 - 0x17bb78

void entry_17bb18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17bb18) {
        switch (ctx->pc) {
            case 0x17bb20: ctx->pc = 0; goto label_17bb20;
            case 0x17bb24: ctx->pc = 0; goto label_17bb24;
            case 0x17bb40: ctx->pc = 0; goto label_17bb40;
            case 0x17bb4c: ctx->pc = 0; goto label_17bb4c;
            case 0x17bb54: ctx->pc = 0; goto label_17bb54;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17bb18: 0x10000009
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17bb40;
    }
label_17bb20:
    // 0x17bb20: 0x7a220100
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 256)));
label_17bb24:
    // 0x17bb24: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x17bb28: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17bb2c: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x17bb30: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x17bb34: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x17bb38: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x17bb3c: 0xc6200638
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1592)); ctx->f[0] = *(float*)&val; }
label_17bb40:
    // 0x17bb40: 0x12600002
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        goto label_17bb4c;
    }
    // 0x17bb48: 0x7e620000
    WRITE128(ADD32(GPR_U32(ctx, 19), 0), GPR_VEC(ctx, 2));
label_17bb4c:
    // 0x17bb4c: 0x56800001
    if (GPR_U32(ctx, 20) != GPR_U32(ctx, 0)) {
        { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 0), *(uint32_t*)&val); }
        goto label_17bb54;
    }
label_17bb54:
    // 0x17bb54: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x17bb58: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x17bb5c: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x17bb60: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17bb64: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x17bb68: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17bb6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 160));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17bb74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17bb78; return;
}


// Function: SetJsgFocus__FP3JSGP2LO
// Address: 0x17bb78 - 0x17bbdc

void entry_17bbdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17bbdc) {
        switch (ctx->pc) {
            case 0x17bc04: ctx->pc = 0; goto label_17bc04;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17bbdc: 0xc6000568
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1384)); ctx->f[0] = *(float*)&val; }
    // 0x17bbe0: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x17bbe4: 0x3c0142fa
    SET_GPR_U32(ctx, 1, ((uint32_t)17146 << 16));
    // 0x17bbe8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17bbec: 0x24638d30
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937904));
    // 0x17bbf0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17bbf4: 0xe6000568
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 16), 1384), *(uint32_t*)&val); }
    // 0x17bbf8: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17bbfc: 0x7e022530
    WRITE128(ADD32(GPR_U32(ctx, 16), 9520), GPR_VEC(ctx, 2));
    // 0x17bc00: 0xae320054
    WRITE32(ADD32(GPR_U32(ctx, 17), 84), GPR_U32(ctx, 18));
label_17bc04:
    // 0x17bc04: 0x7bbf0030
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17bc08: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17bc0c: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17bc10: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17bc14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 64));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17bc1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17bc20; return;
}


// Function: SetJsgTn__FP3JSGP2TN
// Address: 0x17bc20 - 0x17bc48

void entry_17bc48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bc48: 0x8e020058
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x17bc4c: 0xac4002d0
    WRITE32(ADD32(GPR_U32(ctx, 2), 720), GPR_U32(ctx, 0));
    // 0x17bc50: 0x8e03005c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 92)));
    // 0x17bc54: 0x50600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 88), GPR_U32(ctx, 0));
        ctx->pc = 0x17BC74; return;
    }
    // 0x17bc5c: 0x8e040058
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 88)));
    // 0x17bc60: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17bc64: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x17bc68: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17bc70);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17bc70
// Address: 0x17bc70 - 0x17bc88

void entry_17bc70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17bc70) {
        switch (ctx->pc) {
            case 0x17bc74: ctx->pc = 0; goto label_17bc74;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17bc70: 0xae000058
    WRITE32(ADD32(GPR_U32(ctx, 16), 88), GPR_U32(ctx, 0));
label_17bc74:
    // 0x17bc74: 0x12200011
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BCBC; return;
    }
    // 0x17bc7c: 0xae110058
    WRITE32(ADD32(GPR_U32(ctx, 16), 88), GPR_U32(ctx, 17));
    // 0x17bc80: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x17bc88);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_17bc88
// Address: 0x17bc88 - 0x17bca4

void entry_17bc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bc88: 0x2c420001
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 1));
    // 0x17bc8c: 0x10400005
    WRITE32(ADD32(GPR_U32(ctx, 16), 92), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17bca4(rdram, ctx, runtime); return;
    }
    // 0x17bc94: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17bc98: 0x8c620018
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    // 0x17bc9c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17bca4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17bca4
// Address: 0x17bca4 - 0x17bcb8

void entry_17bca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bca4: 0x8e02003c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x17bca8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17bcac: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17bcb0: 0xc078a10
    SET_GPR_U32(ctx, 31, 0x17bcb8);
    WRITE32(ADD32(GPR_U32(ctx, 17), 720), GPR_U32(ctx, 2));
    FUN_001e2840__FP2TN3TNS(rdram, ctx, runtime); return;
}


// Function: entry_17bcb8
// Address: 0x17bcb8 - 0x17bcd0

void entry_17bcb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17bcb8) {
        switch (ctx->pc) {
            case 0x17bcbc: ctx->pc = 0; goto label_17bcbc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17bcb8: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_17bcbc:
    // 0x17bcbc: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17bcc0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17bcc4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17bccc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17bcd0; return;
}


// Function: NextJsgJsge__FP3JSG
// Address: 0x17bcd0 - 0x17bd40

void entry_17bd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bd40: 0x8e830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 0)));
    // 0x17bd44: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17bd48: 0x2c62000c
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 12));
    // 0x17bd4c: 0x104001a7
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17c3ec(rdram, ctx, runtime); return;
    }
    // 0x17bd54: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x17bd58: 0x2442b000
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946816));
    // 0x17bd5c: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x17bd60: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17bd64: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x17bd6c: 0x1000019f
    WRITE32(ADD32(GPR_U32(ctx, 19), 76), GPR_U32(ctx, 18));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17c3ec(rdram, ctx, runtime); return;
    }
    // 0x17bd74: 0x12400009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BD9C; return;
    }
    // 0x17bd7c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17bd84);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 116));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17bd84
// Address: 0x17bd84 - 0x17bd94

void entry_17bd84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bd84: 0x10400006
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BDA0; return;
    }
    // 0x17bd8c: 0xc07d002
    SET_GPR_U32(ctx, 31, 0x17bd94);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    TriggerWarp__FP4WARP(rdram, ctx, runtime); return;
}


// Function: entry_17bd94
// Address: 0x17bd94 - 0x17bdb0

void entry_17bd94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17bd94) {
        switch (ctx->pc) {
            case 0x17bd9c: ctx->pc = 0; goto label_17bd9c;
            case 0x17bda0: ctx->pc = 0; goto label_17bda0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17bd94: 0x10000196
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
label_17bd9c:
    // 0x17bd9c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
label_17bda0:
    // 0x17bda0: 0x27a70060
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 96));
    // 0x17bda4: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17bda8: 0xc05ee74
    SET_GPR_U32(ctx, 31, 0x17bdb0);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    GetJsgLocation__FP3JSGP2LOP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_17bdb0
// Address: 0x17bdb0 - 0x17bde8

void entry_17bdb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bdb0: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17bdb4: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17bdb8: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x17bdbc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17bdc0: 0x7e2206a0
    WRITE128(ADD32(GPR_U32(ctx, 17), 1696), GPR_VEC(ctx, 2));
    // 0x17bdc4: 0xc7a00008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[0] = *(float*)&val; }
    // 0x17bdc8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17bdcc: 0xe7a00008
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 8), *(uint32_t*)&val); }
    // 0x17bdd0: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17bdd4: 0x8e260000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17bdd8: 0x7e220560
    WRITE128(ADD32(GPR_U32(ctx, 17), 1376), GPR_VEC(ctx, 2));
    // 0x17bddc: 0x8cc30084
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 6), 132)));
    // 0x17bde0: 0x60f809
    SET_GPR_U32(ctx, 31, 0x17bde8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_17bde8
// Address: 0x17bde8 - 0x17be08

void entry_17bde8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bde8: 0xc7a00060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[0] = *(float*)&val; }
    // 0x17bdec: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17bdf0: 0x3c040025
    SET_GPR_U32(ctx, 4, ((uint32_t)37 << 16));
    // 0x17bdf4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17bdf8: 0xe6200638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
    // 0x17bdfc: 0x24848d20
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 4294937888));
    // 0x17be00: 0xc062214
    SET_GPR_U32(ctx, 31, 0x17be08);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 96)); ctx->f[12] = *(float*)&val; }
    LoadRotateMatrixRad__FfP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17be08
// Address: 0x17be08 - 0x17be1c

void entry_17be08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17be08: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17be0c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17be10: 0x8c620088
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 136)));
    // 0x17be14: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17be1c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17be1c
// Address: 0x17be1c - 0x17be38

void entry_17be1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17be1c: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17be20: 0x3c100025
    SET_GPR_U32(ctx, 16, ((uint32_t)37 << 16));
    // 0x17be24: 0x26108d30
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4294937904));
    // 0x17be28: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17be2c: 0x8c620090
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 144)));
    // 0x17be30: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17be38);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17be38
// Address: 0x17be38 - 0x17be4c

void entry_17be38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17be38: 0x8e230000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17be3c: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17be40: 0x8c620094
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 148)));
    // 0x17be44: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17be4c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17be4c
// Address: 0x17be4c - 0x17be5c

void entry_17be4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17be4c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17be50: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17be54: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17be5c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17be5c
// Address: 0x17be5c - 0x17be7c

void entry_17be5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17be5c: 0xae200690
    WRITE32(ADD32(GPR_U32(ctx, 17), 1680), GPR_U32(ctx, 0));
    // 0x17be60: 0x10000162
    WRITE32(ADD32(GPR_U32(ctx, 19), 72), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17c3ec(rdram, ctx, runtime); return;
    }
    // 0x17be68: 0x12400160
    WRITE32(ADD32(GPR_U32(ctx, 19), 72), GPR_U32(ctx, 20));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_17c3ec(rdram, ctx, runtime); return;
    }
    // 0x17be70: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17be74: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17be7c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 127));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17be7c
// Address: 0x17be7c - 0x17be90

void entry_17be7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17be7c: 0x14400015
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 9116));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BED4; return;
    }
    // 0x17be84: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17be88: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17be90);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 111));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17be90
// Address: 0x17be90 - 0x17bea4

void entry_17be90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17be90: 0x14400010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 9116));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BED4; return;
    }
    // 0x17be98: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17be9c: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17bea4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 58));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17bea4
// Address: 0x17bea4 - 0x17beb8

void entry_17bea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bea4: 0x1440000b
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 9116));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BED4; return;
    }
    // 0x17beac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17beb0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17beb8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 112));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17beb8
// Address: 0x17beb8 - 0x17becc

void entry_17beb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17beb8: 0x14400006
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 9116));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17BED4; return;
    }
    // 0x17bec0: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17bec4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17becc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 118));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17becc
// Address: 0x17becc - 0x17bee0

void entry_17becc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17becc) {
        switch (ctx->pc) {
            case 0x17bed4: ctx->pc = 0; goto label_17bed4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17becc: 0x1040000a
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 17), 9116));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17bef8(rdram, ctx, runtime); return;
    }
label_17bed4:
    // 0x17bed4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17bed8: 0xc0737ee
    SET_GPR_U32(ctx, 31, 0x17bee0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    JtbsChooseJtHide__FP2JTP2LOP4JTHK(rdram, ctx, runtime); return;
}


// Function: entry_17bee0
// Address: 0x17bee0 - 0x17bef8

void entry_17bee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bee0: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17bee4: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x17bee8: 0x10c20003
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        entry_17bef8(rdram, ctx, runtime); return;
    }
    // 0x17bef0: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17bef8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17bef8
// Address: 0x17bef8 - 0x17bf2c

void entry_17bef8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bef8: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x17befc: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x17bf00: 0x1462013b
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x17C3F0; return;
    }
    // 0x17bf08: 0x8e23239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x17bf0c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x17bf10: 0x14620137
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x17C3F0; return;
    }
    // 0x17bf18: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17bf1c: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17bf20: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17bf24: 0xc05ee74
    SET_GPR_U32(ctx, 31, 0x17bf2c);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetJsgLocation__FP3JSGP2LOP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_17bf2c
// Address: 0x17bf2c - 0x17bf44

void entry_17bf2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bf2c: 0x8e2223bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9148)));
    // 0x17bf30: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17bf34: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17bf38: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17bf3c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17bf44);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17bf44
// Address: 0x17bf44 - 0x17bf74

void entry_17bf44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bf44: 0x8e2223bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9148)));
    // 0x17bf48: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x17bf4c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17bf50: 0x8c620028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 40)));
    // 0x17bf54: 0x10400125
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17c3ec(rdram, ctx, runtime); return;
    }
    // 0x17bf5c: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17bf60: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17bf64: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17bf68: 0x26690060
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 19), 96));
    // 0x17bf6c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17bf74);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17bf74
// Address: 0x17bf74 - 0x17bf94

void entry_17bf74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bf74: 0x1000011e
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
    // 0x17bf7c: 0xae740048
    WRITE32(ADD32(GPR_U32(ctx, 19), 72), GPR_U32(ctx, 20));
    // 0x17bf80: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17bf84: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17bf88: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17bf8c: 0xc05ee74
    SET_GPR_U32(ctx, 31, 0x17bf94);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetJsgLocation__FP3JSGP2LOP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_17bf94
// Address: 0x17bf94 - 0x17bfac

void entry_17bf94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bf94: 0x8e222208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    // 0x17bf98: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17bf9c: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17bfa0: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17bfa4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17bfac);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17bfac
// Address: 0x17bfac - 0x17bfdc

void entry_17bfac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bfac: 0x8e222208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    // 0x17bfb0: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x17bfb4: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17bfb8: 0x8c620028
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 40)));
    // 0x17bfbc: 0x1040010b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17c3ec(rdram, ctx, runtime); return;
    }
    // 0x17bfc4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17bfc8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17bfcc: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17bfd0: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17bfd4: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17bfdc);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 19), 100));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17bfdc
// Address: 0x17bfdc - 0x17c018

void entry_17bfdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17bfdc: 0x10000104
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
    // 0x17bfe4: 0x56400101
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 19), 72), GPR_U32(ctx, 20));
        entry_17c3ec(rdram, ctx, runtime); return;
    }
    // 0x17bfec: 0x10000100
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
    // 0x17bff4: 0xae740048
    WRITE32(ADD32(GPR_U32(ctx, 19), 72), GPR_U32(ctx, 20));
    // 0x17bff8: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17bffc: 0xa0b82d
    SET_GPR_U64(ctx, 23, GPR_U64(ctx, 5) + GPR_U64(ctx, 0));
    // 0x17c000: 0x8e82000c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x17c004: 0x16400006
    if (GPR_U32(ctx, 2) != 0) SET_GPR_U32(ctx, 23, GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C020; return;
    }
    // 0x17c00c: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17c010: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17c018);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17c018
// Address: 0x17c018 - 0x17c0d4

void entry_17c018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c018) {
        switch (ctx->pc) {
            case 0x17c020: ctx->pc = 0; goto label_17c020;
            case 0x17c058: ctx->pc = 0; goto label_17c058;
            case 0x17c074: ctx->pc = 0; goto label_17c074;
            case 0x17c078: ctx->pc = 0; goto label_17c078;
            case 0x17c07c: ctx->pc = 0; goto label_17c07c;
            case 0x17c080: ctx->pc = 0; goto label_17c080;
            case 0x17c084: ctx->pc = 0; goto label_17c084;
            case 0x17c0a4: ctx->pc = 0; goto label_17c0a4;
            case 0x17c0b4: ctx->pc = 0; goto label_17c0b4;
            case 0x17c0c0: ctx->pc = 0; goto label_17c0c0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c018: 0x100000f5
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
label_17c020:
    // 0x17c020: 0x7a220100
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x17c024: 0x24030003
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 3));
    // 0x17c028: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x17c02c: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x17c030: 0xae20224c
    WRITE32(ADD32(GPR_U32(ctx, 17), 8780), GPR_U32(ctx, 0));
    // 0x17c034: 0x8e242220
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x17c038: 0x1083000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 4));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 3)) {
        goto label_17c074;
    }
    // 0x17c040: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17c058;
    }
    // 0x17c048: 0x5082000c
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 8780), GPR_U32(ctx, 5));
        goto label_17c07c;
    }
    // 0x17c050: 0x1000000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17c084;
    }
label_17c058:
    // 0x17c058: 0x24020007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    // 0x17c05c: 0x10820005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_17c074;
    }
    // 0x17c064: 0x10820004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 2)) {
        goto label_17c078;
    }
    // 0x17c06c: 0x10000004
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17c080;
    }
label_17c074:
    // 0x17c074: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_17c078:
    // 0x17c078: 0xae22224c
    WRITE32(ADD32(GPR_U32(ctx, 17), 8780), GPR_U32(ctx, 2));
label_17c07c:
    // 0x17c07c: 0x8e83000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 12)));
label_17c080:
    // 0x17c080: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
label_17c084:
    // 0x17c084: 0x1062000e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17c0c0;
    }
    // 0x17c08c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17c0a4;
    }
    // 0x17c094: 0x10600007
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_17c0b4;
    }
    // 0x17c09c: 0x10000034
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C170; return;
    }
label_17c0a4:
    // 0x17c0a4: 0x1062000d
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17C0DC; return;
    }
    // 0x17c0ac: 0x10000030
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C170; return;
    }
label_17c0b4:
    // 0x17c0b4: 0x7a220150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x17c0b8: 0x1000002c
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C16C; return;
    }
label_17c0c0:
    // 0x17c0c0: 0x27a20010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17c0c4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17c0c8: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17c0cc: 0xc05fede
    SET_GPR_U32(ctx, 31, 0x17c0d4);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    GetJtJumpVelocity__FP2JTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17c0d4
// Address: 0x17c0d4 - 0x17c0f0

void entry_17c0d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c0d4) {
        switch (ctx->pc) {
            case 0x17c0dc: ctx->pc = 0; goto label_17c0dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c0d4: 0x10000026
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C170; return;
    }
label_17c0dc:
    // 0x17c0dc: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17c0e0: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17c0e4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c0e8: 0xc05fede
    SET_GPR_U32(ctx, 31, 0x17c0f0);
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    GetJtJumpVelocity__FP2JTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17c0f0
// Address: 0x17c0f0 - 0x17c164

void entry_17c0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c0f0: 0xc7a00018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 24)); ctx->f[0] = *(float*)&val; }
    // 0x17c0f4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17c0f8: 0xc6220358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 856)); ctx->f[2] = *(float*)&val; }
    // 0x17c0fc: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c100: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x17c104: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x17c108: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17c10c: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17c110: 0xdba30000
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17c114: 0x46020503
    if (ctx->f[2] == 0.0f) { ctx->fcr31 |= 0x100000; /* DZ flag */ ctx->f[20] = copysignf(INFINITY, ctx->f[0] * 0.0f); } else ctx->f[20] = ctx->f[0] / ctx->f[2];
    // 0x17c118: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x17c11c: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17c120: 0x4601a042
    ctx->f[1] = FPU_MUL_S(ctx->f[20], ctx->f[1]);
    // 0x17c124: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17c128: 0x44020800
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[1]);
    // 0x17c12c: 0xda210350
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 848)));
    // 0x17c130: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x17c134: 0x4be20888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17c138: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17c13c: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17c140: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x17c144: 0x4be120bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17c148: 0x4be110c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17c14c: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17c150: 0xfba30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17c154: 0x7a220150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x17c158: 0x7fa20030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 2));
    // 0x17c15c: 0xc05ff32
    SET_GPR_U32(ctx, 31, 0x17c164);
    WRITE128(ADD32(GPR_U32(ctx, 17), 336), _mm_castps_si128(ctx->vu0_vf[2]));
    GetJtJumpBoostVelocity__FP2JTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17c164
// Address: 0x17c164 - 0x17c184

void entry_17c164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c164) {
        switch (ctx->pc) {
            case 0x17c16c: ctx->pc = 0; goto label_17c16c;
            case 0x17c170: ctx->pc = 0; goto label_17c170;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c164: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17c168: 0x7e220150
    WRITE128(ADD32(GPR_U32(ctx, 17), 336), GPR_VEC(ctx, 2));
label_17c16c:
    // 0x17c16c: 0x27b00020
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 32));
label_17c170:
    // 0x17c170: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17c174: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17c178: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c17c: 0xc05ee74
    SET_GPR_U32(ctx, 31, 0x17c184);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetJsgLocation__FP3JSGP2LOP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_17c184
// Address: 0x17c184 - 0x17c1a8

void entry_17c184(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c184: 0x27b60030
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 29), 48));
    // 0x17c188: 0x8e440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 24)));
    // 0x17c18c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17c190: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c194: 0x2c0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x17c198: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17c19c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17c1a0: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x17c1a8);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_17c1a8
// Address: 0x17c1a8 - 0x17c1d4

void entry_17c1a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c1a8: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x17c1ac: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17c1b0: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17c1b4: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17c1b8: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17c1bc: 0x24050076
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 118));
    // 0x17c1c0: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17c1c4: 0x4be31048
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[3], ctx->vu0_vf[3], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17c1c8: 0xfba30040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17c1cc: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17c1d4);
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17c1d4
// Address: 0x17c1d4 - 0x17c208

void entry_17c1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c1d4) {
        switch (ctx->pc) {
            case 0x17c1ec: ctx->pc = 0; goto label_17c1ec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c1d4: 0x10400005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17c1ec;
    }
    // 0x17c1dc: 0xc7a00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 40)); ctx->f[0] = *(float*)&val; }
    // 0x17c1e0: 0xc4413e34
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15924)); ctx->f[1] = *(float*)&val; }
    // 0x17c1e4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17c1e8: 0xe7a00028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
label_17c1ec:
    // 0x17c1ec: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x17c1f0: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c1f4: 0x2c0402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
    // 0x17c1f8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17c1fc: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17c200: 0xc05feb0
    SET_GPR_U32(ctx, 31, 0x17c208);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 100));
    FTimeJtJumpToTarget__FP2JTP6VECTORN31Pf(rdram, ctx, runtime); return;
}


// Function: entry_17c208
// Address: 0x17c208 - 0x17c21c

void entry_17c208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c208: 0x10400028
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C2AC; return;
    }
    // 0x17c210: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17c214: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17c21c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17c21c
// Address: 0x17c21c - 0x17c288

void entry_17c21c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c21c: 0xc7a00064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 100)); ctx->f[0] = *(float*)&val; }
    // 0x17c220: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17c224: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17c228: 0x27a50040
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 64));
    // 0x17c22c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17c230: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17c234: 0xdba10030
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17c238: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x17c23c: 0x4be208c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17c240: 0x46140000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[20]);
    // 0x17c244: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17c248: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17c24c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17c250: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17c254: 0xda210100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x17c258: 0xfba20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17c25c: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17c260: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x17c264: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17c268: 0x4be0189c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x17c26c: 0xfba20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17c270: 0xc6200158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 344)); ctx->f[0] = *(float*)&val; }
    // 0x17c274: 0xe7a00048
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 72), *(uint32_t*)&val); }
    // 0x17c278: 0x8e220000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 0)));
    // 0x17c27c: 0x8c430090
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 2), 144)));
    // 0x17c280: 0x60f809
    SET_GPR_U32(ctx, 31, 0x17c288);
    ctx->pc = GPR_U32(ctx, 3); return;
}


// Function: entry_17c288
// Address: 0x17c288 - 0x17c2a4

void entry_17c288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c288: 0xda220100
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 256)));
    // 0x17c28c: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17c290: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17c294: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17c298: 0xc7ac0054
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 84)); ctx->f[12] = *(float*)&val; }
    // 0x17c29c: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x17c2a4);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_17c2a4
// Address: 0x17c2a4 - 0x17c2c8

void entry_17c2a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c2a4) {
        switch (ctx->pc) {
            case 0x17c2ac: ctx->pc = 0; goto label_17c2ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c2a4: 0xe6200630
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1584), *(uint32_t*)&val); }
    // 0x17c2a8: 0xe6200638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
label_17c2ac:
    // 0x17c2ac: 0x8e820010
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 16)));
    // 0x17c2b0: 0x1000004e
    WRITE32(ADD32(GPR_U32(ctx, 17), 8784), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17c3ec(rdram, ctx, runtime); return;
    }
    // 0x17c2b8: 0x1240004c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        entry_17c3ec(rdram, ctx, runtime); return;
    }
    // 0x17c2c0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17c2c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 131));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17c2c8
// Address: 0x17c2c8 - 0x17c2ec

void entry_17c2c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c2c8: 0x10400048
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17c3ec(rdram, ctx, runtime); return;
    }
    // 0x17c2d0: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x17c2d4: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17c2d8: 0x44816800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 1);
    // 0x17c2dc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17c2e0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17c2e4: 0xc04b1ec
    SET_GPR_U32(ctx, 31, 0x17c2ec);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 104));
    ApplyAseg__FP4ASEGP3ALOffiPP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_17c2ec
// Address: 0x17c2ec - 0x17c310

void entry_17c2ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c2ec: 0x8e820008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 8)));
    // 0x17c2f0: 0x1440003f
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
    // 0x17c2f8: 0x8fa20068
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 104)));
    // 0x17c2fc: 0x1000003b
    WRITE32(ADD32(GPR_U32(ctx, 19), 80), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17c3ec(rdram, ctx, runtime); return;
    }
    // 0x17c304: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17c308: 0xc05eede
    SET_GPR_U32(ctx, 31, 0x17c310);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetJsgFocus__FP3JSGP2LO(rdram, ctx, runtime); return;
}


// Function: entry_17c310
// Address: 0x17c310 - 0x17c360

void entry_17c310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c310) {
        switch (ctx->pc) {
            case 0x17c340: ctx->pc = 0; goto label_17c340;
            case 0x17c354: ctx->pc = 0; goto label_17c354;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c310: 0x10000037
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
    // 0x17c318: 0x8e83000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 12)));
    // 0x17c31c: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x17c320: 0x10620011
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 5));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17C368; return;
    }
    // 0x17c328: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17c340;
    }
    // 0x17c330: 0x10620008
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17c354;
    }
    // 0x17c338: 0x1000002e
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F4; return;
    }
label_17c340:
    // 0x17c340: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x17c344: 0x1062000e
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17C380; return;
    }
    // 0x17c34c: 0x10000029
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F4; return;
    }
label_17c354:
    // 0x17c354: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17c358: 0xc071878
    SET_GPR_U32(ctx, 31, 0x17c360);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    SetJtJtcs__FP2JT4JTCS(rdram, ctx, runtime); return;
}


// Function: entry_17c360
// Address: 0x17c360 - 0x17c378

void entry_17c360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c360) {
        switch (ctx->pc) {
            case 0x17c368: ctx->pc = 0; goto label_17c368;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c360: 0x10000023
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
label_17c368:
    // 0x17c368: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17c36c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17c370: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17c378);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 7));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17c378
// Address: 0x17c378 - 0x17c390

void entry_17c378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c378) {
        switch (ctx->pc) {
            case 0x17c380: ctx->pc = 0; goto label_17c380;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c378: 0x1000001d
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
label_17c380:
    // 0x17c380: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17c384: 0x2405000a
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 10));
    // 0x17c388: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17c390);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 31));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17c390
// Address: 0x17c390 - 0x17c3b4

void entry_17c390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c390: 0x10000017
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
    // 0x17c398: 0x2682000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 20), 12));
    // 0x17c39c: 0x260202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17c3a0: 0xafa2006c
    WRITE32(ADD32(GPR_U32(ctx, 29), 108), GPR_U32(ctx, 2));
    // 0x17c3a4: 0x24050018
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 24));
    // 0x17c3a8: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17c3ac: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x17c3b4);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 108));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_17c3b4
// Address: 0x17c3b4 - 0x17c3cc

void entry_17c3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c3b4: 0x1000000e
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
    // 0x17c3bc: 0x12400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3D0; return;
    }
    // 0x17c3c4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17c3cc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 99));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17c3cc
// Address: 0x17c3cc - 0x17c3dc

void entry_17c3cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c3cc) {
        switch (ctx->pc) {
            case 0x17c3d0: ctx->pc = 0; goto label_17c3d0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c3cc: 0x2900a
    if (GPR_U32(ctx, 2) == 0) SET_GPR_U32(ctx, 18, GPR_U32(ctx, 0));
label_17c3d0:
    // 0x17c3d0: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17c3d4: 0xc05ef08
    SET_GPR_U32(ctx, 31, 0x17c3dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    SetJsgTn__FP3JSGP2TN(rdram, ctx, runtime); return;
}


// Function: entry_17c3dc
// Address: 0x17c3dc - 0x17c3ec

void entry_17c3dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c3dc: 0x10000004
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C3F0; return;
    }
    // 0x17c3e4: 0xc050bb4
    SET_GPR_U32(ctx, 31, 0x17c3ec);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 12)); ctx->f[12] = *(float*)&val; }
    SetClockRate__Ff(rdram, ctx, runtime); return;
}


// Function: entry_17c3ec
// Address: 0x17c3ec - 0x17c428

void entry_17c3ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c3ec) {
        switch (ctx->pc) {
            case 0x17c3f0: ctx->pc = 0; goto label_17c3f0;
            case 0x17c3f4: ctx->pc = 0; goto label_17c3f4;
            case 0x17c3f8: ctx->pc = 0; goto label_17c3f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c3ec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_17c3f0:
    // 0x17c3f0: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
label_17c3f4:
    // 0x17c3f4: 0xe6600044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 19), 68), *(uint32_t*)&val); }
label_17c3f8:
    // 0x17c3f8: 0x7bbf00f0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x17c3fc: 0x7bb700e0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 224)));
    // 0x17c400: 0x7bb600d0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x17c404: 0x7bb500c0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x17c408: 0x7bb400b0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x17c40c: 0x7bb300a0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x17c410: 0x7bb20090
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x17c414: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x17c418: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x17c41c: 0xc7b40100
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 256)); ctx->f[20] = *(float*)&val; }
    // 0x17c420: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 272));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FIsJsgJsgeComplete__FP3JSGP4JSGE
// Address: 0x17c428 - 0x17c460

void entry_17c460(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c460: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17c464: 0x8e420000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 0)));
    // 0x17c468: 0x2444fffc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967292));
    // 0x17c46c: 0x2c830009
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 9));
    // 0x17c470: 0x10600072
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C63C; return;
    }
    // 0x17c478: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x17c47c: 0x2442b030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946864));
    // 0x17c480: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x17c484: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17c488: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x17c490: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17c494: 0xc6220044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 68)); ctx->f[2] = *(float*)&val; }
    // 0x17c498: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17c49c: 0xc641000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 12)); ctx->f[1] = *(float*)&val; }
    // 0x17c4a0: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17c4a4: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17c4a8: 0x1000001f
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C528; return;
    }
    // 0x17c4b0: 0x10a00062
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C63C; return;
    }
    // 0x17c4b8: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17c4bc: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17c4c0: 0xc05ee74
    SET_GPR_U32(ctx, 31, 0x17c4c8);
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    GetJsgLocation__FP3JSGP2LOP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_17c4c8
// Address: 0x17c4c8 - 0x17c574

void entry_17c4c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c4c8) {
        switch (ctx->pc) {
            case 0x17c528: ctx->pc = 0; goto label_17c528;
            case 0x17c558: ctx->pc = 0; goto label_17c558;
            case 0x17c55c: ctx->pc = 0; goto label_17c55c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c4c8: 0xda010140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
    // 0x17c4cc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17c4d0: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17c4d4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17c4d8: 0xc4413e38
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15928)); ctx->f[1] = *(float*)&val; }
    // 0x17c4dc: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17c4e0: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17c4e4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17c4e8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17c4ec: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17c4f0: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17c4f4: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x17c4f8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17c4fc: 0x1000000a
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17c528;
    }
    // 0x17c504: 0xc6002410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 9232)); ctx->f[0] = *(float*)&val; }
    // 0x17c508: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17c50c: 0xc6210064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 100)); ctx->f[1] = *(float*)&val; }
    // 0x17c510: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17c514: 0xc4423e3c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15932)); ctx->f[2] = *(float*)&val; }
    // 0x17c518: 0x46010001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    // 0x17c51c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x17c520: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17c524: 0x0
    // NOP
label_17c528:
    // 0x17c528: 0x45010046
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17C644; return;
    }
    // 0x17c530: 0x10000043
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C640; return;
    }
    // 0x17c538: 0x8e240050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 80)));
    // 0x17c53c: 0x10800006
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_17c558;
    }
    // 0x17c544: 0xc4810018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[1] = *(float*)&val; }
    // 0x17c548: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17c54c: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17c550: 0x45000002
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17c55c;
    }
label_17c558:
    // 0x17c558: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
label_17c55c:
    // 0x17c55c: 0x12600039
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C644; return;
    }
    // 0x17c564: 0x10800038
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C648; return;
    }
    // 0x17c56c: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x17c574);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_17c574
// Address: 0x17c574 - 0x17c634

void entry_17c574(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c574) {
        switch (ctx->pc) {
            case 0x17c5a4: ctx->pc = 0; goto label_17c5a4;
            case 0x17c5b8: ctx->pc = 0; goto label_17c5b8;
            case 0x17c5c8: ctx->pc = 0; goto label_17c5c8;
            case 0x17c5d8: ctx->pc = 0; goto label_17c5d8;
            case 0x17c610: ctx->pc = 0; goto label_17c610;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c574: 0x10000032
    WRITE32(ADD32(GPR_U32(ctx, 17), 80), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C640; return;
    }
    // 0x17c57c: 0x8e45000c
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 12)));
    // 0x17c580: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x17c584: 0x10a20010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 5), 5));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_17c5c8;
    }
    // 0x17c58c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17c5a4;
    }
    // 0x17c594: 0x10a20008
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_17c5b8;
    }
    // 0x17c59c: 0x10000029
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C644; return;
    }
label_17c5a4:
    // 0x17c5a4: 0x24020008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 8));
    // 0x17c5a8: 0x10a2000b
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 2)) {
        goto label_17c5d8;
    }
    // 0x17c5b0: 0x10000024
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C644; return;
    }
label_17c5b8:
    // 0x17c5b8: 0x8e02223c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8764)));
    // 0x17c5bc: 0x21027
    SET_GPR_U32(ctx, 2, NOR32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    // 0x17c5c0: 0x1000001f
    SET_GPR_U32(ctx, 19, SLTU32(GPR_U32(ctx, 2), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C640; return;
    }
label_17c5c8:
    // 0x17c5c8: 0x8e022220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x17c5cc: 0x38420002
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 2));
    // 0x17c5d0: 0x1000001b
    SET_GPR_U32(ctx, 19, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C640; return;
    }
label_17c5d8:
    // 0x17c5d8: 0x8e022220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x17c5dc: 0x3842000a
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 10));
    // 0x17c5e0: 0x10000017
    SET_GPR_U32(ctx, 19, SLTU32(GPR_U32(ctx, 0), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C640; return;
    }
    // 0x17c5e8: 0x8e032220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8736)));
    // 0x17c5ec: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17c5f0: 0x14620007
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_17c610;
    }
    // 0x17c5f8: 0x8e022228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8744)));
    // 0x17c5fc: 0x2442fff4
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294967284));
    // 0x17c600: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x17c604: 0x1440000e
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C640; return;
    }
    // 0x17c60c: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
label_17c610:
    // 0x17c610: 0x1462000b
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x17C640; return;
    }
    // 0x17c618: 0x8e02239c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 9116)));
    // 0x17c61c: 0x2c420002
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 2), 2));
    // 0x17c620: 0x10400007
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C640; return;
    }
    // 0x17c628: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17c62c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17c634);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17c634
// Address: 0x17c634 - 0x17c660

void entry_17c634(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c634) {
        switch (ctx->pc) {
            case 0x17c63c: ctx->pc = 0; goto label_17c63c;
            case 0x17c640: ctx->pc = 0; goto label_17c640;
            case 0x17c644: ctx->pc = 0; goto label_17c644;
            case 0x17c648: ctx->pc = 0; goto label_17c648;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c634: 0x10000003
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17c644;
    }
label_17c63c:
    // 0x17c63c: 0x24130001
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 0), 1));
label_17c640:
    // 0x17c640: 0x260102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
label_17c644:
    // 0x17c644: 0x7bbf0050
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 80)));
label_17c648:
    // 0x17c648: 0x7bb30040
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17c64c: 0x7bb20030
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17c650: 0x7bb10020
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17c654: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17c658: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 96));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJsgJsge__FP3JSG
// Address: 0x17c660 - 0x17c694

void entry_17c694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c694) {
        switch (ctx->pc) {
            case 0x17c6a0: ctx->pc = 0; goto label_17c6a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c694: 0x10000005
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C6AC; return;
    }
    // 0x17c69c: 0x0
    // NOP
label_17c6a0:
    // 0x17c6a0: 0xc05ef34
    SET_GPR_U32(ctx, 31, 0x17c6a8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    NextJsgJsge__FP3JSG(rdram, ctx, runtime); return;
}


// Function: entry_17c6a8
// Address: 0x17c6a8 - 0x17c6dc

void entry_17c6a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c6a8) {
        switch (ctx->pc) {
            case 0x17c6ac: ctx->pc = 0; goto label_17c6ac;
            case 0x17c6b0: ctx->pc = 0; goto label_17c6b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c6a8: 0x8e040040
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 64)));
label_17c6ac:
    // 0x17c6ac: 0x8e020034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
label_17c6b0:
    // 0x17c6b0: 0x82102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), GPR_S32(ctx, 2)));
    // 0x17c6b4: 0x5040000c
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 72)));
        ctx->pc = 0x17C6E8; return;
    }
    // 0x17c6bc: 0x912018
    { int64_t result = (int64_t)GPR_S32(ctx, 4) * (int64_t)GPR_S32(ctx, 17); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x17c6c0: 0x8e020038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 56)));
    // 0x17c6c4: 0x442821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x17c6c8: 0x8ca30008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 8)));
    // 0x17c6cc: 0x1460fff4
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C6A0; return;
    }
    // 0x17c6d4: 0xc05f10a
    SET_GPR_U32(ctx, 31, 0x17c6dc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsJsgJsgeComplete__FP3JSGP4JSGE(rdram, ctx, runtime); return;
}


// Function: entry_17c6dc
// Address: 0x17c6dc - 0x17c6f8

void entry_17c6dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c6dc) {
        switch (ctx->pc) {
            case 0x17c6e8: ctx->pc = 0; goto label_17c6e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c6dc: 0x1440fff0
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C6A0; return;
    }
    // 0x17c6e4: 0x8e050048
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 16), 72)));
label_17c6e8:
    // 0x17c6e8: 0x10a00006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C704; return;
    }
    // 0x17c6f0: 0xc05f10a
    SET_GPR_U32(ctx, 31, 0x17c6f8);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    FIsJsgJsgeComplete__FP3JSGP4JSGE(rdram, ctx, runtime); return;
}


// Function: entry_17c6f8
// Address: 0x17c6f8 - 0x17c718

void entry_17c6f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c6f8) {
        switch (ctx->pc) {
            case 0x17c700: ctx->pc = 0; goto label_17c700;
            case 0x17c704: ctx->pc = 0; goto label_17c704;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c6f8: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 0));
        goto label_17c700;
    }
label_17c700:
    // 0x17c700: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_17c704:
    // 0x17c704: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17c708: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17c70c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17c714: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17c718; return;
}


// Function: ReadJsgJoystick__FP3JSGP3JOY
// Address: 0x17c718 - 0x17c780

void entry_17c780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c780) {
        switch (ctx->pc) {
            case 0x17c7ac: ctx->pc = 0; goto label_17c7ac;
            case 0x17c7c8: ctx->pc = 0; goto label_17c7c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c780: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17c784: 0x8ea30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x17c788: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x17c78c: 0x1062001d
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 6));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17C804; return;
    }
    // 0x17c794: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17c7ac;
    }
    // 0x17c79c: 0x1062000a
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17c7c8;
    }
    // 0x17c7a4: 0x10000177
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CD84; return;
    }
label_17c7ac:
    // 0x17c7ac: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x17c7b0: 0x10620067
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 7));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17C950; return;
    }
    // 0x17c7b8: 0x106200e9
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17CB60; return;
    }
    // 0x17c7c0: 0x10000170
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CD84; return;
    }
label_17c7c8:
    // 0x17c7c8: 0x12000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C7EC; return;
    }
    // 0x17c7d0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c7d4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17c7d8: 0xc05ee74
    SET_GPR_U32(ctx, 31, 0x17c7e0);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 80));
    GetJsgLocation__FP3JSGP2LOP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_17c7e0
// Address: 0x17c7e0 - 0x17c88c

void entry_17c7e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c7e0) {
        switch (ctx->pc) {
            case 0x17c7ec: ctx->pc = 0; goto label_17c7ec;
            case 0x17c804: ctx->pc = 0; goto label_17c804;
            case 0x17c854: ctx->pc = 0; goto label_17c854;
            case 0x17c884: ctx->pc = 0; goto label_17c884;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c7e0: 0xc7a00050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 80)); ctx->f[0] = *(float*)&val; }
    // 0x17c7e4: 0xe6200630
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1584), *(uint32_t*)&val); }
    // 0x17c7e8: 0xe6200638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1592), *(uint32_t*)&val); }
label_17c7ec:
    // 0x17c7ec: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x17c7f0: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x17c7f4: 0x14620161
    WRITE32(ADD32(GPR_U32(ctx, 17), 1588), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x17CD7C; return;
    }
    // 0x17c7fc: 0x100000d5
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 20), 168)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CB54; return;
    }
label_17c804:
    // 0x17c804: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x17c808: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17c80c: 0x54620043
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 12)));
        ctx->pc = 0x17C91C; return;
    }
    // 0x17c814: 0x52000041
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 12)));
        ctx->pc = 0x17C91C; return;
    }
    // 0x17c81c: 0x8e242228
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x17c820: 0x1483000c
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 3)) {
        goto label_17c854;
    }
    // 0x17c828: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17c82c: 0xc622222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x17c830: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17c834: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17c838: 0xc4413e40
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15936)); ctx->f[1] = *(float*)&val; }
    // 0x17c83c: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17c840: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17c844: 0x0
    // NOP
    // 0x17c848: 0x4503000e
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
        goto label_17c884;
    }
    // 0x17c850: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
label_17c854:
    // 0x17c854: 0x54820030
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 12)));
        ctx->pc = 0x17C918; return;
    }
    // 0x17c85c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17c860: 0xc622222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x17c864: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17c868: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17c86c: 0xc4413e44
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15940)); ctx->f[1] = *(float*)&val; }
    // 0x17c870: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17c874: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17c878: 0x0
    // NOP
    // 0x17c87c: 0x45000025
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_17c914(rdram, ctx, runtime); return;
    }
label_17c884:
    // 0x17c884: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17c88c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 129));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17c88c
// Address: 0x17c88c - 0x17c8a0

void entry_17c88c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c88c: 0x1440001b
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C8FC; return;
    }
    // 0x17c894: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c898: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17c8a0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 113));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17c8a0
// Address: 0x17c8a0 - 0x17c8b4

void entry_17c8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c8a0: 0x14400016
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C8FC; return;
    }
    // 0x17c8a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c8ac: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17c8b4);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 111));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17c8b4
// Address: 0x17c8b4 - 0x17c8c8

void entry_17c8b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c8b4: 0x14400011
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C8FC; return;
    }
    // 0x17c8bc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c8c0: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17c8c8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 127));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17c8c8
// Address: 0x17c8c8 - 0x17c8dc

void entry_17c8c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c8c8: 0x1440000c
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C8FC; return;
    }
    // 0x17c8d0: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c8d4: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17c8dc);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 112));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17c8dc
// Address: 0x17c8dc - 0x17c8f0

void entry_17c8dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c8dc: 0x14400007
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17C8FC; return;
    }
    // 0x17c8e4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c8e8: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17c8f0);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 118));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17c8f0
// Address: 0x17c8f0 - 0x17c904

void entry_17c8f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c8f0) {
        switch (ctx->pc) {
            case 0x17c8fc: ctx->pc = 0; goto label_17c8fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c8f0: 0x50400009
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 12)));
        ctx->pc = 0x17C918; return;
    }
    // 0x17c8f8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_17c8fc:
    // 0x17c8fc: 0xc073c56
    SET_GPR_U32(ctx, 31, 0x17c904);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FUN_001cf158(rdram, ctx, runtime); return;
}


// Function: entry_17c904
// Address: 0x17c904 - 0x17c914

void entry_17c904(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c904: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17c908: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17c90c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17c914);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17c914
// Address: 0x17c914 - 0x17c948

void entry_17c914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c914) {
        switch (ctx->pc) {
            case 0x17c918: ctx->pc = 0; goto label_17c918;
            case 0x17c91c: ctx->pc = 0; goto label_17c91c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c914: 0x8ea3000c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 21), 12)));
label_17c918:
    // 0x17c918: 0x24020002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
label_17c91c:
    // 0x17c91c: 0x54620117
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1588), GPR_U32(ctx, 0));
        ctx->pc = 0x17CD7C; return;
    }
    // 0x17c924: 0x8e222228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x17c928: 0x54430114
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        WRITE32(ADD32(GPR_U32(ctx, 17), 1588), GPR_U32(ctx, 0));
        ctx->pc = 0x17CD7C; return;
    }
    // 0x17c930: 0x8e222498
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9368)));
    // 0x17c934: 0x10400004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17c948(rdram, ctx, runtime); return;
    }
    // 0x17c93c: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17c940: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17c948);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 3));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17c948
// Address: 0x17c948 - 0x17c9a0

void entry_17c948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c948) {
        switch (ctx->pc) {
            case 0x17c950: ctx->pc = 0; goto label_17c950;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c948: 0x1000010c
    WRITE32(ADD32(GPR_U32(ctx, 17), 1588), GPR_U32(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CD7C; return;
    }
label_17c950:
    // 0x17c950: 0x52000074
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 12)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x17CB24; return;
    }
    // 0x17c958: 0x8e222220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x17c95c: 0x14430064
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x17CAF0; return;
    }
    // 0x17c964: 0x8e23239c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x17c968: 0x24020004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    // 0x17c96c: 0x14620061
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x17CAF4; return;
    }
    // 0x17c974: 0x8e2323bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9148)));
    // 0x17c978: 0x27b20010
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17c97c: 0x8c640034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x17c980: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17c984: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x17c988: 0x10400005
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 3), 24)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17c9a0(rdram, ctx, runtime); return;
    }
    // 0x17c990: 0xc62c23c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9152)); ctx->f[12] = *(float*)&val; }
    // 0x17c994: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17c998: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17c9a0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17c9a0
// Address: 0x17c9a0 - 0x17c9b4

void entry_17c9a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c9a0: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17c9a4: 0x27a70020
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 32));
    // 0x17c9a8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c9ac: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17c9b4);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17c9b4
// Address: 0x17c9b4 - 0x17c9c8

void entry_17c9b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17c9b4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17c9b8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17c9bc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17c9c0: 0xc04a030
    SET_GPR_U32(ctx, 31, 0x17c9c8);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    ConvertAloVec__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17c9c8
// Address: 0x17c9c8 - 0x17ca40

void entry_17c9c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17c9c8) {
        switch (ctx->pc) {
            case 0x17ca20: ctx->pc = 0; goto label_17ca20;
            case 0x17ca2c: ctx->pc = 0; goto label_17ca2c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17c9c8: 0xafa00038
    WRITE32(ADD32(GPR_U32(ctx, 29), 56), GPR_U32(ctx, 0));
    // 0x17c9cc: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17c9d0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x17c9d4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x17c9d8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17c9dc: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x17c9e0: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17c9e4: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17c9e8: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17c9ec: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17c9f0: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17c9f4: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17c9f8: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17c9fc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17ca00: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17ca04: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17ca08: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x17ca0c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17ca10: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17ca20;
    }
    // 0x17ca18: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17ca2c;
    }
label_17ca20:
    // 0x17ca20: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17ca24: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17ca28: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_17ca2c:
    // 0x17ca2c: 0xfba10030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17ca30: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ca34: 0xc7ac0034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 52)); ctx->f[12] = *(float*)&val; }
    // 0x17ca38: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x17ca40);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 48)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_17ca40
// Address: 0x17ca40 - 0x17ca78

void entry_17ca40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ca40: 0xe6200630
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1584), *(uint32_t*)&val); }
    // 0x17ca44: 0x8e2223bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9148)));
    // 0x17ca48: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x17ca4c: 0x8c830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x17ca50: 0x10600018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 96)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CAB4; return;
    }
    // 0x17ca58: 0xc62023c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9152)); ctx->f[0] = *(float*)&val; }
    // 0x17ca5c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17ca60: 0x0
    // NOP
    // 0x17ca64: 0x45000009
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17CA8C; return;
    }
    // 0x17ca6c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x17ca70: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17ca78);
    ctx->f[20] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17ca78
// Address: 0x17ca78 - 0x17ca98

void entry_17ca78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ca78) {
        switch (ctx->pc) {
            case 0x17ca8c: ctx->pc = 0; goto label_17ca8c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ca78: 0xc6610060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 96)); ctx->f[1] = *(float*)&val; }
    // 0x17ca7c: 0xc62223c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9152)); ctx->f[2] = *(float*)&val; }
    // 0x17ca80: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17ca84: 0x10000008
    ctx->f[21] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CAA8; return;
    }
label_17ca8c:
    // 0x17ca8c: 0x8c62001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 28)));
    // 0x17ca90: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17ca98);
    ctx->f[21] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17ca98
// Address: 0x17ca98 - 0x17cae8

void entry_17ca98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ca98) {
        switch (ctx->pc) {
            case 0x17caa8: ctx->pc = 0; goto label_17caa8;
            case 0x17cab4: ctx->pc = 0; goto label_17cab4;
            case 0x17cac0: ctx->pc = 0; goto label_17cac0;
            case 0x17cac8: ctx->pc = 0; goto label_17cac8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ca98: 0xc62123c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9152)); ctx->f[1] = *(float*)&val; }
    // 0x17ca9c: 0xc6620060
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 96)); ctx->f[2] = *(float*)&val; }
    // 0x17caa0: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17caa4: 0x46020501
    ctx->f[20] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
label_17caa8:
    // 0x17caa8: 0x4615a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17caac: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17cac0;
    }
label_17cab4:
    // 0x17cab4: 0xc62023c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9152)); ctx->f[0] = *(float*)&val; }
    // 0x17cab8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17cabc: 0x0
    // NOP
label_17cac0:
    // 0x17cac0: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
        goto label_17cac8;
    }
label_17cac8:
    // 0x17cac8: 0x52000016
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 12)); ctx->f[0] = *(float*)&val; }
        ctx->pc = 0x17CB24; return;
    }
    // 0x17cad0: 0xc6200630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[0] = *(float*)&val; }
    // 0x17cad4: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x17cad8: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x17cadc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x17cae0: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x17cae8);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_17cae8
// Address: 0x17cae8 - 0x17cb00

void entry_17cae8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17cae8) {
        switch (ctx->pc) {
            case 0x17caf0: ctx->pc = 0; goto label_17caf0;
            case 0x17caf4: ctx->pc = 0; goto label_17caf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17cae8: 0x1000000d
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1584), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CB20; return;
    }
label_17caf0:
    // 0x17caf0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
label_17caf4:
    // 0x17caf4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17caf8: 0xc05ee74
    SET_GPR_U32(ctx, 31, 0x17cb00);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetJsgLocation__FP3JSGP2LOP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_17cb00
// Address: 0x17cb00 - 0x17cb1c

void entry_17cb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17cb00: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x17cb04: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17cb08: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17cb0c: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17cb10: 0xc7ac0014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[12] = *(float*)&val; }
    // 0x17cb14: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x17cb1c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_17cb1c
// Address: 0x17cb1c - 0x17cb94

void entry_17cb1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17cb1c) {
        switch (ctx->pc) {
            case 0x17cb20: ctx->pc = 0; goto label_17cb20;
            case 0x17cb24: ctx->pc = 0; goto label_17cb24;
            case 0x17cb54: ctx->pc = 0; goto label_17cb54;
            case 0x17cb60: ctx->pc = 0; goto label_17cb60;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17cb1c: 0xe6200630
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1584), *(uint32_t*)&val); }
label_17cb20:
    // 0x17cb20: 0xc6a0000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 21), 12)); ctx->f[0] = *(float*)&val; }
label_17cb24:
    // 0x17cb24: 0x24030006
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 6));
    // 0x17cb28: 0x8e222220
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x17cb2c: 0x46000005
    ctx->f[0] = FPU_ABS_S(ctx->f[0]);
    // 0x17cb30: 0x14430092
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1588), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 3)) {
        ctx->pc = 0x17CD7C; return;
    }
    // 0x17cb38: 0x8e24239c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 9116)));
    // 0x17cb3c: 0x28820002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 4), 2));
    // 0x17cb40: 0x1040008f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CD80; return;
    }
    // 0x17cb48: 0x480008e
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    if (GPR_S32(ctx, 4) < 0) {
        ctx->pc = 0x17CD84; return;
    }
    // 0x17cb50: 0x968200a8
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 20), 168)));
label_17cb54:
    // 0x17cb54: 0x34420020
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), 32));
    // 0x17cb58: 0x10000088
    WRITE16(ADD32(GPR_U32(ctx, 20), 168), (uint16_t)GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CD7C; return;
    }
label_17cb60:
    // 0x17cb60: 0x8e232208
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    // 0x17cb64: 0x8c640034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x17cb68: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17cb6c: 0x8c420008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 8)));
    // 0x17cb70: 0x10400013
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17cbc0(rdram, ctx, runtime); return;
    }
    // 0x17cb78: 0x3c100027
    SET_GPR_U32(ctx, 16, ((uint32_t)39 << 16));
    // 0x17cb7c: 0xc6202410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9232)); ctx->f[0] = *(float*)&val; }
    // 0x17cb80: 0xc60c4f14
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20244)); ctx->f[12] = *(float*)&val; }
    // 0x17cb84: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17cb88: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17cb8c: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17cb94);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17cb94
// Address: 0x17cb94 - 0x17cbc0

void entry_17cb94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17cb94: 0x8e222208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    // 0x17cb98: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x17cb9c: 0x8c830000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17cba0: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x17cba4: 0x10400006
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 20244)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17cbc0(rdram, ctx, runtime); return;
    }
    // 0x17cbac: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17cbb0: 0xc62c2410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9232)); ctx->f[12] = *(float*)&val; }
    // 0x17cbb4: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17cbb8: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17cbc0);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17cbc0
// Address: 0x17cbc0 - 0x17cbdc

void entry_17cbc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17cbc0: 0x8e222208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    // 0x17cbc4: 0x3a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17cbc8: 0x3a0382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17cbcc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17cbd0: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x17cbd4: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17cbdc);
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17cbdc
// Address: 0x17cbdc - 0x17cbf4

void entry_17cbdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17cbdc: 0x8e222208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    // 0x17cbe0: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17cbe4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17cbe8: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17cbec: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17cbf4);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17cbf4
// Address: 0x17cbf4 - 0x17cc04

void entry_17cbf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17cbf4: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x17cbf8: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17cbfc: 0xc051070
    SET_GPR_U32(ctx, 31, 0x17cc04);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 32));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_17cc04
// Address: 0x17cc04 - 0x17cc14

void entry_17cc04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17cc04: 0x8e041990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 6544)));
    // 0x17cc08: 0x240282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17cc0c: 0xc051070
    SET_GPR_U32(ctx, 31, 0x17cc14);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    ConvertCmWorldToScreen(rdram, ctx, runtime); return;
}


// Function: entry_17cc14
// Address: 0x17cc14 - 0x17cc9c

void entry_17cc14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17cc14) {
        switch (ctx->pc) {
            case 0x17cc7c: ctx->pc = 0; goto label_17cc7c;
            case 0x17cc88: ctx->pc = 0; goto label_17cc88;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17cc14: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17cc18: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17cc1c: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17cc20: 0x24428d10
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937872));
    // 0x17cc24: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17cc28: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x17cc2c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x17cc30: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17cc34: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17cc38: 0xafa00048
    WRITE32(ADD32(GPR_U32(ctx, 29), 72), GPR_U32(ctx, 0));
    // 0x17cc3c: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17cc40: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17cc44: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17cc48: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17cc4c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17cc50: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17cc54: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17cc58: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17cc5c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17cc60: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17cc64: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x17cc68: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17cc6c: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17cc7c;
    }
    // 0x17cc74: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17cc88;
    }
label_17cc7c:
    // 0x17cc7c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17cc80: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17cc84: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_17cc88:
    // 0x17cc88: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17cc8c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17cc90: 0xc7ac0044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 68)); ctx->f[12] = *(float*)&val; }
    // 0x17cc94: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x17cc9c);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_17cc9c
// Address: 0x17cc9c - 0x17cce4

void entry_17cc9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17cc9c: 0xe6200630
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1584), *(uint32_t*)&val); }
    // 0x17cca0: 0xc7a00040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 64)); ctx->f[0] = *(float*)&val; }
    // 0x17cca4: 0xc7a10044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 68)); ctx->f[1] = *(float*)&val; }
    // 0x17cca8: 0xe6800040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 64), *(uint32_t*)&val); }
    // 0x17ccac: 0xe6810044
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 20), 68), *(uint32_t*)&val); }
    // 0x17ccb0: 0x8e222208
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8712)));
    // 0x17ccb4: 0x8c440034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 52)));
    // 0x17ccb8: 0x8c830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x17ccbc: 0x10600018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 100)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CD20; return;
    }
    // 0x17ccc4: 0xc6202410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9232)); ctx->f[0] = *(float*)&val; }
    // 0x17ccc8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17cccc: 0x0
    // NOP
    // 0x17ccd0: 0x45000009
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17CCF8; return;
    }
    // 0x17ccd8: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x17ccdc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17cce4);
    ctx->f[20] = FPU_SUB_S(ctx->f[0], ctx->f[1]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17cce4
// Address: 0x17cce4 - 0x17cd04

void entry_17cce4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17cce4) {
        switch (ctx->pc) {
            case 0x17ccf8: ctx->pc = 0; goto label_17ccf8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17cce4: 0xc6610064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 100)); ctx->f[1] = *(float*)&val; }
    // 0x17cce8: 0xc6222410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9232)); ctx->f[2] = *(float*)&val; }
    // 0x17ccec: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17ccf0: 0x10000008
    ctx->f[21] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CD14; return;
    }
label_17ccf8:
    // 0x17ccf8: 0x8c620020
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 32)));
    // 0x17ccfc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17cd04);
    ctx->f[21] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17cd04
// Address: 0x17cd04 - 0x17cd54

void entry_17cd04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17cd04) {
        switch (ctx->pc) {
            case 0x17cd14: ctx->pc = 0; goto label_17cd14;
            case 0x17cd20: ctx->pc = 0; goto label_17cd20;
            case 0x17cd2c: ctx->pc = 0; goto label_17cd2c;
            case 0x17cd34: ctx->pc = 0; goto label_17cd34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17cd04: 0xc6212410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9232)); ctx->f[1] = *(float*)&val; }
    // 0x17cd08: 0xc6620064
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 19), 100)); ctx->f[2] = *(float*)&val; }
    // 0x17cd0c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17cd10: 0x46020501
    ctx->f[20] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
label_17cd14:
    // 0x17cd14: 0x4615a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17cd18: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17cd2c;
    }
label_17cd20:
    // 0x17cd20: 0xc6202410
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 9232)); ctx->f[0] = *(float*)&val; }
    // 0x17cd24: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17cd28: 0x0
    // NOP
label_17cd2c:
    // 0x17cd2c: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 0), 1));
        goto label_17cd34;
    }
label_17cd34:
    // 0x17cd34: 0x1200000e
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CD70; return;
    }
    // 0x17cd3c: 0xc6200630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 1584)); ctx->f[0] = *(float*)&val; }
    // 0x17cd40: 0x3c014049
    SET_GPR_U32(ctx, 1, ((uint32_t)16457 << 16));
    // 0x17cd44: 0x34210fdb
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 4059));
    // 0x17cd48: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x17cd4c: 0xc07a902
    SET_GPR_U32(ctx, 31, 0x17cd54);
    ctx->f[12] = FPU_ADD_S(ctx->f[0], ctx->f[12]);
    RadNormalize__Ff(rdram, ctx, runtime); return;
}


// Function: entry_17cd54
// Address: 0x17cd54 - 0x17cda8

void entry_17cd54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17cd54) {
        switch (ctx->pc) {
            case 0x17cd70: ctx->pc = 0; goto label_17cd70;
            case 0x17cd7c: ctx->pc = 0; goto label_17cd7c;
            case 0x17cd80: ctx->pc = 0; goto label_17cd80;
            case 0x17cd84: ctx->pc = 0; goto label_17cd84;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17cd54: 0xe6200630
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1584), *(uint32_t*)&val); }
    // 0x17cd58: 0xc6800040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 64)); ctx->f[0] = *(float*)&val; }
    // 0x17cd5c: 0xc6810044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 68)); ctx->f[1] = *(float*)&val; }
    // 0x17cd60: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x17cd64: 0x46000847
    ctx->f[1] = FPU_NEG_S(ctx->f[1]);
    // 0x17cd68: 0xe6800040
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 64), *(uint32_t*)&val); }
    // 0x17cd6c: 0xe6810044
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 20), 68), *(uint32_t*)&val); }
label_17cd70:
    // 0x17cd70: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17cd74: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17cd78: 0xe6200634
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 17), 1588), *(uint32_t*)&val); }
label_17cd7c:
    // 0x17cd7c: 0x7bbf00c0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 192)));
label_17cd80:
    // 0x17cd80: 0x7bb500b0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 176)));
label_17cd84:
    // 0x17cd84: 0x7bb400a0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x17cd88: 0x7bb30090
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x17cd8c: 0x7bb20080
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x17cd90: 0x7bb10070
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x17cd94: 0x7bb00060
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17cd98: 0xc7b500d8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[21] = *(float*)&val; }
    // 0x17cd9c: 0xc7b400d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[20] = *(float*)&val; }
    // 0x17cda0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FIsJsgActive__FP3JSG
// Address: 0x17cda8 - 0x17cdbc

void entry_17cdbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17cdbc) {
        switch (ctx->pc) {
            case 0x17cdd0: ctx->pc = 0; goto label_17cdd0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17cdbc: 0x8e030034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x17cdc0: 0x18600003
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_17cdd0;
    }
    // 0x17cdc8: 0x8e020040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 64)));
    // 0x17cdcc: 0x43102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 2), GPR_S32(ctx, 3)));
label_17cdd0:
    // 0x17cdd0: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17cdd4: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17cdd8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: ClearJsg__FP3JSG
// Address: 0x17cde0 - 0x17ce04

void entry_17ce04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ce04) {
        switch (ctx->pc) {
            case 0x17ce08: ctx->pc = 0; goto label_17ce08;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ce04: 0xae000034
    WRITE32(ADD32(GPR_U32(ctx, 16), 52), GPR_U32(ctx, 0));
label_17ce08:
    // 0x17ce08: 0xae000040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 0));
    // 0x17ce0c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17ce10: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17ce14: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17ce1c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17ce20; return;
}


// Function: ApplyJsg__FP3JSGP2JT
// Address: 0x17ce20 - 0x17ce50

void entry_17ce50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ce50: 0x8e020068
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 104)));
    // 0x17ce54: 0x10400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CE70; return;
    }
    // 0x17ce5c: 0xc05b83c
    SET_GPR_U32(ctx, 31, 0x17ce64);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    AddGrfusr__Fi(rdram, ctx, runtime); return;
}


// Function: entry_17ce64
// Address: 0x17ce64 - 0x17ce6c

void entry_17ce64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ce64: 0xc077688
    SET_GPR_U32(ctx, 31, 0x17ce6c);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    IncrementSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_17ce6c
// Address: 0x17ce6c - 0x17ce80

void entry_17ce6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ce6c) {
        switch (ctx->pc) {
            case 0x17ce70: ctx->pc = 0; goto label_17ce70;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ce6c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_17ce70:
    // 0x17ce70: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17ce74: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17ce7c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17ce80; return;
}


// Function: RetractJsg__FP3JSG
// Address: 0x17ce80 - 0x17cea4

void entry_17cea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17cea4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17cea8: 0xc05eede
    SET_GPR_U32(ctx, 31, 0x17ceb0);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    SetJsgFocus__FP3JSGP2LO(rdram, ctx, runtime); return;
}


// Function: entry_17ceb0
// Address: 0x17ceb0 - 0x17cec4

void entry_17ceb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ceb0: 0x8e040050
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 80)));
    // 0x17ceb4: 0x10800004
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CEC8; return;
    }
    // 0x17cebc: 0xc04b9d8
    SET_GPR_U32(ctx, 31, 0x17cec4);
    RetractAsega__FP5ASEGA(rdram, ctx, runtime); return;
}


// Function: entry_17cec4
// Address: 0x17cec4 - 0x17ced8

void entry_17cec4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17cec4) {
        switch (ctx->pc) {
            case 0x17cec8: ctx->pc = 0; goto label_17cec8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17cec4: 0xae000050
    WRITE32(ADD32(GPR_U32(ctx, 16), 80), GPR_U32(ctx, 0));
label_17cec8:
    // 0x17cec8: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17cecc: 0x44816000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 1);
    // 0x17ced0: 0xc050bb4
    SET_GPR_U32(ctx, 31, 0x17ced8);
    SetClockRate__Ff(rdram, ctx, runtime); return;
}


// Function: entry_17ced8
// Address: 0x17ced8 - 0x17cf08

void entry_17ced8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ced8: 0x8e020034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 52)));
    // 0x17cedc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17cee0: 0x8e03003c
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 60)));
    // 0x17cee4: 0x24050019
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 25));
    // 0x17cee8: 0xae020040
    WRITE32(ADD32(GPR_U32(ctx, 16), 64), GPR_U32(ctx, 2));
    // 0x17ceec: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17cef0: 0xae00004c
    WRITE32(ADD32(GPR_U32(ctx, 16), 76), GPR_U32(ctx, 0));
    // 0x17cef4: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17cef8: 0xae000048
    WRITE32(ADD32(GPR_U32(ctx, 16), 72), GPR_U32(ctx, 0));
    // 0x17cefc: 0xac602740
    WRITE32(ADD32(GPR_U32(ctx, 3), 10048), GPR_U32(ctx, 0));
    // 0x17cf00: 0xc060df8
    SET_GPR_U32(ctx, 31, 0x17cf08);
    WRITE32(ADD32(GPR_U32(ctx, 16), 60), GPR_U32(ctx, 0));
    HandleLoSpliceEvent__FP2LOUiiPPv(rdram, ctx, runtime); return;
}


// Function: entry_17cf08
// Address: 0x17cf08 - 0x17cf1c

void entry_17cf08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17cf08: 0x8e020068
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 104)));
    // 0x17cf0c: 0x10400006
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17CF28; return;
    }
    // 0x17cf14: 0xc05b846
    SET_GPR_U32(ctx, 31, 0x17cf1c);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 4));
    RemoveGrfusr__Fi(rdram, ctx, runtime); return;
}


// Function: entry_17cf1c
// Address: 0x17cf1c - 0x17cf24

void entry_17cf1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17cf1c: 0xc077694
    SET_GPR_U32(ctx, 31, 0x17cf24);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    DecrementSwHandsOff__FP2SW(rdram, ctx, runtime); return;
}


// Function: entry_17cf24
// Address: 0x17cf24 - 0x17cf38

void entry_17cf24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17cf24) {
        switch (ctx->pc) {
            case 0x17cf28: ctx->pc = 0; goto label_17cf28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17cf24: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_17cf28:
    // 0x17cf28: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17cf2c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17cf34: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17cf38; return;
}


// Function: PjsgeAllocJsg__FP3JSG5JSGEK3OIDi
// Address: 0x17cf38 - 0x17cf90

void entry_17cf90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17cf90) {
        switch (ctx->pc) {
            case 0x17cfa4: ctx->pc = 0; goto label_17cfa4;
            case 0x17cfac: ctx->pc = 0; goto label_17cfac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17cf90: 0xae110000
    WRITE32(ADD32(GPR_U32(ctx, 16), 0), GPR_U32(ctx, 17));
    // 0x17cf94: 0x200102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17cf98: 0xae120004
    WRITE32(ADD32(GPR_U32(ctx, 16), 4), GPR_U32(ctx, 18));
    // 0x17cf9c: 0x10000003
    WRITE32(ADD32(GPR_U32(ctx, 16), 8), GPR_U32(ctx, 19));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17cfac;
    }
label_17cfa4:
    // 0x17cfa4: 0x3c02002c
    SET_GPR_U32(ctx, 2, ((uint32_t)44 << 16));
    // 0x17cfa8: 0x2442e478
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294960248));
label_17cfac:
    // 0x17cfac: 0x7bbf0040
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17cfb0: 0x7bb30030
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17cfb4: 0x7bb20020
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17cfb8: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17cfbc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17cfc0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 80));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddJsgContext__FP3JSG3OID
// Address: 0x17cfc8 - 0x17cfe0

void entry_17cfe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17cfe0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17cfe4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17cfec: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17cff0; return;
}


// Function: AddJsgCut__FP3JSG3OID
// Address: 0x17cff0 - 0x17d008

void entry_17d008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d008: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d00c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17d014: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17d018; return;
}


// Function: AddJsgFocus__FP3JSG3OID
// Address: 0x17d018 - 0x17d030

void entry_17d030(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d030: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d034: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17d03c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17d040; return;
}


// Function: AddJsgLabel__FP3JSG3OID
// Address: 0x17d040 - 0x17d060

void entry_17d060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d060: 0xac50000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 12), GPR_U32(ctx, 16));
    // 0x17d064: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17d068: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d06c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17d074: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17d078; return;
}


// Function: AddJsgTunnel__FP3JSG3OID
// Address: 0x17d078 - 0x17d090

void entry_17d090(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d090: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d094: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17d09c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17d0a0; return;
}


// Function: AddJsgPause__FP3JSG3OIDf
// Address: 0x17d0a0 - 0x17d0c0

void entry_17d0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d0c0: 0xe454000c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x17d0c4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d0c8: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x17d0cc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17d0d4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17d0d8; return;
}


// Function: AddJsgAseg__FP3JSG3OIDi
// Address: 0x17d0d8 - 0x17d0f0

void entry_17d0f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d0f0: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d0f4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17d0fc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17d100; return;
}


// Function: AddJsgJump__FP3JSG3OID5JSGJK5JSGLKi
// Address: 0x17d100 - 0x17d128

void entry_17d128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d128: 0xac500010
    WRITE32(ADD32(GPR_U32(ctx, 2), 16), GPR_U32(ctx, 16));
    // 0x17d12c: 0xac51000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 12), GPR_U32(ctx, 17));
    // 0x17d130: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17d134: 0x7bb10010
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17d138: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d13c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17d144: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17d148; return;
}


// Function: AddJsgRun__FP3JSG3OIDfi
// Address: 0x17d148 - 0x17d168

void entry_17d168(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d168: 0xe454000c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x17d16c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d170: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x17d174: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17d17c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17d180; return;
}


// Function: AddJsgClimb__FP3JSG3OIDfi
// Address: 0x17d180 - 0x17d1a0

void entry_17d1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d1a0: 0xe454000c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x17d1a4: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d1a8: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x17d1ac: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17d1b4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17d1b8; return;
}


// Function: AddJsgAttack__FP3JSG3OID4FTAKi
// Address: 0x17d1b8 - 0x17d1d4

void entry_17d1d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d1d4: 0xac50000c
    WRITE32(ADD32(GPR_U32(ctx, 2), 12), GPR_U32(ctx, 16));
    // 0x17d1d8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17d1dc: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d1e0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: AddJsgClock__FP3JSGf
// Address: 0x17d1e8 - 0x17d208

void entry_17d208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d208: 0xe454000c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 2), 12), *(uint32_t*)&val); }
    // 0x17d20c: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d210: 0xc7b40010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[20] = *(float*)&val; }
    // 0x17d214: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17d21c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17d220; return;
}


// Function: AddJsgUnknown__FP3JSG
// Address: 0x17d220 - 0x17d238

void entry_17d238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d238: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d23c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17d244: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17d248; return;
}


// Function: PresetJtAccelJump__FP2JT
// Address: 0x17d248 - 0x17d27c

void entry_17d27c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d27c: 0x8e022228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8744)));
    // 0x17d280: 0x2444fffc
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 2), 4294967292));
    // 0x17d284: 0x2c83000c
    SET_GPR_U32(ctx, 3, SLTU32(GPR_U32(ctx, 4), 12));
    // 0x17d288: 0x1060005a
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17D3F4; return;
    }
    // 0x17d290: 0x41880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 4), 2));
    // 0x17d294: 0x2442b060
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946912));
    // 0x17d298: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x17d29c: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17d2a0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x17d2a8: 0xc6010634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1588)); ctx->f[1] = *(float*)&val; }
    // 0x17d2ac: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x17d2b0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x17d2b4: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17d2b8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d2bc: 0x0
    // NOP
    // 0x17d2c0: 0x450000bf
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_17d5c0(rdram, ctx, runtime); return;
    }
    // 0x17d2c8: 0xc60d226c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 8812)); ctx->f[13] = *(float*)&val; }
    // 0x17d2cc: 0xc60c0630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1584)); ctx->f[12] = *(float*)&val; }
    // 0x17d2d0: 0x44807000
    *(uint32_t*)&ctx->f[14] = GPR_U32(ctx, 0);
    // 0x17d2d4: 0xc07b594
    SET_GPR_U32(ctx, 31, 0x17d2dc);
    ctx->f[13] = FPU_MUL_S(ctx->f[1], ctx->f[13]);
    SetVectorCylind__FP6VECTORfff(rdram, ctx, runtime); return;
}


// Function: entry_17d2dc
// Address: 0x17d2dc - 0x17d318

void entry_17d2dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d2dc: 0xda012290
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 8848)));
    // 0x17d2e0: 0x26221858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 6232));
    // 0x17d2e4: 0xdba20000
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d2e8: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x17d2ec: 0xc6000158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 344)); ctx->f[0] = *(float*)&val; }
    // 0x17d2f0: 0x4be20868
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17d2f4: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17d2f8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17d2fc: 0x25083e90
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 16016));
    // 0x17d300: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17d304: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17d308: 0x27a70010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17d30c: 0xc44c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[12] = *(float*)&val; }
    // 0x17d310: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x17d318);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 24), *(uint32_t*)&val); }
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_17d318
// Address: 0x17d318 - 0x17d32c

void entry_17d318(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d318: 0x100000aa
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17D5C4; return;
    }
    // 0x17d320: 0x8e0425c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9672)));
    // 0x17d324: 0xc04b330
    SET_GPR_U32(ctx, 31, 0x17d32c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 442));
    TFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_17d32c
// Address: 0x17d32c - 0x17d33c

void entry_17d32c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d32c: 0x8e0425c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 9672)));
    // 0x17d330: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x17d334: 0xc04b330
    SET_GPR_U32(ctx, 31, 0x17d33c);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 443));
    TFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_17d33c
// Address: 0x17d33c - 0x17d37c

void entry_17d33c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d33c: 0x8e022230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8752)));
    // 0x17d340: 0xc4410014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[1] = *(float*)&val; }
    // 0x17d344: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d348: 0x0
    // NOP
    // 0x17d34c: 0x4500000c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17D380; return;
    }
    // 0x17d354: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x17d358: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17d35c: 0xda010350
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 848)));
    // 0x17d360: 0x3a0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17d364: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17d368: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17d36c: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17d370: 0xfba20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17d374: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x17d37c);
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17d37c
// Address: 0x17d37c - 0x17d3ec

void entry_17d37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17d37c) {
        switch (ctx->pc) {
            case 0x17d380: ctx->pc = 0; goto label_17d380;
            case 0x17d3a4: ctx->pc = 0; goto label_17d3a4;
            case 0x17d3c8: ctx->pc = 0; goto label_17d3c8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17d37c: 0x8e022230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8752)));
label_17d380:
    // 0x17d380: 0xc4400014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[0] = *(float*)&val; }
    // 0x17d384: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d388: 0x0
    // NOP
    // 0x17d38c: 0x45000005
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17d3a4;
    }
    // 0x17d394: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x17d398: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17d39c: 0x1000000a
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17d3c8;
    }
label_17d3a4:
    // 0x17d3a4: 0xc6010158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 344)); ctx->f[1] = *(float*)&val; }
    // 0x17d3a8: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17d3ac: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17d3b0: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x17d3b4: 0x70621488
    SET_GPR_VEC(ctx, 2, PS2_PEXTLW(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x17d3b8: 0x44030800
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[1]);
    // 0x17d3bc: 0x70621389
    SET_GPR_VEC(ctx, 2, _mm_unpacklo_epi64(GPR_VEC(ctx, 3), GPR_VEC(ctx, 2)));
    // 0x17d3c0: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x17d3c4: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
label_17d3c8:
    // 0x17d3c8: 0x26221858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 6232));
    // 0x17d3cc: 0x3c080026
    SET_GPR_U32(ctx, 8, ((uint32_t)38 << 16));
    // 0x17d3d0: 0xc44c0008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[12] = *(float*)&val; }
    // 0x17d3d4: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17d3d8: 0x25083ea0
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 16032));
    // 0x17d3dc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17d3e0: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17d3e4: 0xc06e416
    SET_GPR_U32(ctx, 31, 0x17d3ec);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    AccelSoTowardPosSpring__FP2SOP6VECTORP3CLQT1T2f(rdram, ctx, runtime); return;
}


// Function: entry_17d3ec
// Address: 0x17d3ec - 0x17d488

void entry_17d3ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17d3ec) {
        switch (ctx->pc) {
            case 0x17d3f4: ctx->pc = 0; goto label_17d3f4;
            case 0x17d464: ctx->pc = 0; goto label_17d464;
            case 0x17d474: ctx->pc = 0; goto label_17d474;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17d3ec: 0x10000075
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17D5C4; return;
    }
label_17d3f4:
    // 0x17d3f4: 0x8e022740
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 10048)));
    // 0x17d3f8: 0x14400072
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17D5C4; return;
    }
    // 0x17d400: 0x7a020150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x17d404: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x17d408: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x17d40c: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x17d410: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17d414: 0x24638d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x17d418: 0x7fa20000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    // 0x17d41c: 0xafa00008
    WRITE32(ADD32(GPR_U32(ctx, 29), 8), GPR_U32(ctx, 0));
    // 0x17d420: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17d424: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17d428: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17d42c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17d430: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17d434: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17d438: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17d43c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17d440: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17d444: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17d448: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x17d44c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d450: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17d464;
    }
    // 0x17d458: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17d45c: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17d474;
    }
label_17d464:
    // 0x17d464: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x17d468: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17d46c: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x17d470: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_17d474:
    // 0x17d474: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17d478: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17d47c: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x17d480: 0xc0624d4
    SET_GPR_U32(ctx, 31, 0x17d488);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    LoadLookAtMatrix__FP6VECTORP7MATRIX3(rdram, ctx, runtime); return;
}


// Function: entry_17d488
// Address: 0x17d488 - 0x17d5c0

void entry_17d488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17d488) {
        switch (ctx->pc) {
            case 0x17d4e8: ctx->pc = 0; goto label_17d4e8;
            case 0x17d4f0: ctx->pc = 0; goto label_17d4f0;
            case 0x17d4fc: ctx->pc = 0; goto label_17d4fc;
            case 0x17d518: ctx->pc = 0; goto label_17d518;
            case 0x17d520: ctx->pc = 0; goto label_17d520;
            case 0x17d528: ctx->pc = 0; goto label_17d528;
            case 0x17d594: ctx->pc = 0; goto label_17d594;
            case 0x17d598: ctx->pc = 0; goto label_17d598;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17d488: 0xda042290
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 8848)));
    // 0x17d48c: 0xdba30030
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17d490: 0xdba20040
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17d494: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x17d498: 0x4be41a2a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17d49c: 0x4be00253
    // Unhandled VU0 Special1 function: 0x13
    // 0x17d4a0: 0x4be411ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17d4a4: 0x4be409aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17d4a8: 0x4b08403d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[8] = _mm_blendv_ps(ctx->vu0_vf[8], res, _mm_castsi128_ps(mask)); }
    // 0x17d4ac: 0x4b08494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17d4b0: 0x4a87383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x17d4b4: 0x4a87494a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17d4b8: 0x4a46303c
    ctx->vu0_i = (float)ctx->vi[6];
    // 0x17d4bc: 0x4a464949
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[6], ctx->vu0_vf[6], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17d4c0: 0x8e022228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 8744)));
    // 0x17d4c4: 0x1440000d
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[5]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_17d4fc;
    }
    // 0x17d4cc: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x17d4d0: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d4d4: 0x0
    // NOP
    // 0x17d4d8: 0x45000003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17d4e8;
    }
    // 0x17d4e0: 0x10000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15976)); ctx->f[2] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17d4f0;
    }
label_17d4e8:
    // 0x17d4e8: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17d4ec: 0xc4423e64
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15972)); ctx->f[2] = *(float*)&val; }
label_17d4f0:
    // 0x17d4f0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17d4f4: 0x1000000c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15980)); ctx->f[3] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17d528;
    }
label_17d4fc:
    // 0x17d4fc: 0xc7a00010
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 16)); ctx->f[0] = *(float*)&val; }
    // 0x17d500: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d504: 0x0
    // NOP
    // 0x17d508: 0x45000003
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17d518;
    }
    // 0x17d510: 0x10000003
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15964)); ctx->f[2] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17d520;
    }
label_17d518:
    // 0x17d518: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17d51c: 0xc4423e58
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15960)); ctx->f[2] = *(float*)&val; }
label_17d520:
    // 0x17d520: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17d524: 0xc4433e60
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15968)); ctx->f[3] = *(float*)&val; }
label_17d528:
    // 0x17d528: 0x46140041
    ctx->f[1] = FPU_SUB_S(ctx->f[0], ctx->f[20]);
    // 0x17d52c: 0x8e032228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 8744)));
    // 0x17d530: 0xc7a00014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 20)); ctx->f[0] = *(float*)&val; }
    // 0x17d534: 0x24020006
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 6));
    // 0x17d538: 0xafa00028
    WRITE32(ADD32(GPR_U32(ctx, 29), 40), GPR_U32(ctx, 0));
    // 0x17d53c: 0x46001802
    ctx->f[0] = FPU_MUL_S(ctx->f[3], ctx->f[0]);
    // 0x17d540: 0x46011042
    ctx->f[1] = FPU_MUL_S(ctx->f[2], ctx->f[1]);
    // 0x17d544: 0xe7a00024
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 36), *(uint32_t*)&val); }
    // 0x17d548: 0x10620012
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 32), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17d594;
    }
    // 0x17d550: 0xc6020700
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1792)); ctx->f[2] = *(float*)&val; }
    // 0x17d554: 0x46020004
    ctx->f[0] = FPU_SQRT_S(ctx->f[0]);
    // 0x17d558: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17d55c: 0xc6030158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 344)); ctx->f[3] = *(float*)&val; }
    // 0x17d560: 0xc4413e78
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15992)); ctx->f[1] = *(float*)&val; }
    // 0x17d564: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x17d568: 0x46001834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[3], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d56c: 0x0
    // NOP
    // 0x17d570: 0x45000009
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17d598;
    }
    // 0x17d578: 0x46020004
    ctx->f[0] = FPU_SQRT_S(ctx->f[0]);
    // 0x17d57c: 0x46000802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[0]);
    // 0x17d580: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17d584: 0xc4413e7c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15996)); ctx->f[1] = *(float*)&val; }
    // 0x17d588: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x17d58c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x17d590: 0xe7a00028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
label_17d594:
    // 0x17d594: 0xdba20020
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
label_17d598:
    // 0x17d598: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17d59c: 0xdba40030
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17d5a0: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x17d5a4: 0xdba30040
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17d5a8: 0xdba10050
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x17d5ac: 0x4bc221bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x17d5b0: 0x4bc218bd
    { float val = (float)ctx->vi[30]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17d5b4: 0x4bc2088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[30], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17d5b8: 0xc06e6ac
    SET_GPR_U32(ctx, 31, 0x17d5c0);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    AddSoAcceleration__FP2SOP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17d5c0
// Address: 0x17d5c0 - 0x17d5d8

void entry_17d5c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17d5c0) {
        switch (ctx->pc) {
            case 0x17d5c4: ctx->pc = 0; goto label_17d5c4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17d5c0: 0x7bbf0090
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 144)));
label_17d5c4:
    // 0x17d5c4: 0x7bb10080
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x17d5c8: 0x7bb00070
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x17d5cc: 0xc7b400a0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 160)); ctx->f[20] = *(float*)&val; }
    // 0x17d5d0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 176));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: UpdateJtActiveJump__FP2JTP3JOY
// Address: 0x17d5d8 - 0x17d668

void entry_17d668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17d668) {
        switch (ctx->pc) {
            case 0x17d6d8: ctx->pc = 0; goto label_17d6d8;
            case 0x17d744: ctx->pc = 0; goto label_17d744;
            case 0x17d754: ctx->pc = 0; goto label_17d754;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17d668: 0x26220660
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 17), 1632));
    // 0x17d66c: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x17d670: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17d674: 0xd8430020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 32)));
    // 0x17d678: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x17d67c: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17d680: 0x48a23000
    ctx->vu0_vf[6] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17d684: 0xdba40010
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17d688: 0xda210660
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 1632)));
    // 0x17d68c: 0x4be40a6a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17d690: 0x4be00293
    // Unhandled VU0 Special1 function: 0x13
    // 0x17d694: 0x4be4122a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17d698: 0x4be419ea
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17d69c: 0x4b09483d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[9] = _mm_blendv_ps(ctx->vu0_vf[9], res, _mm_castsi128_ps(mask)); }
    // 0x17d6a0: 0x4b09514a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[9], ctx->vu0_vf[9], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17d6a4: 0x4a88403c
    ctx->vu0_i = (float)ctx->vi[8];
    // 0x17d6a8: 0x4a88514a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[20], _mm_shuffle_ps(ctx->vu0_vf[8], ctx->vu0_vf[8], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, -1, 0, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17d6ac: 0x4a47383c
    ctx->vu0_i = (float)ctx->vi[7];
    // 0x17d6b0: 0x4a475149
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[18], _mm_shuffle_ps(ctx->vu0_vf[7], ctx->vu0_vf[7], _MM_SHUFFLE(1,1,1,1))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(0, 0, -1, 0); ctx->vu0_vf[10] = _mm_blendv_ps(ctx->vu0_vf[10], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17d6b4: 0x8e222228
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x17d6b8: 0x4be62958
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[6]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[5] = _mm_blendv_ps(ctx->vu0_vf[5], res, _mm_castsi128_ps(mask)); }
    // 0x17d6bc: 0xfba60020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[6]));
    // 0x17d6c0: 0x14400005
    WRITE128(ADD32(GPR_U32(ctx, 17), 1600), _mm_castps_si128(ctx->vu0_vf[5]));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_17d6d8;
    }
    // 0x17d6c8: 0x8e232270
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8816)));
    // 0x17d6cc: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x17d6d0: 0x1462003c
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        ctx->pc = 0x17D7C4; return;
    }
label_17d6d8:
    // 0x17d6d8: 0x8e222268
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 8808)));
    // 0x17d6dc: 0x14400039
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17D7C4; return;
    }
    // 0x17d6e4: 0x7a220150
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x17d6e8: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x17d6ec: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x17d6f0: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x17d6f4: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17d6f8: 0x24638d00
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937856));
    // 0x17d6fc: 0x7fa20020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    // 0x17d700: 0xe7b40028
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
    // 0x17d704: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17d708: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17d70c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17d710: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17d714: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17d718: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17d71c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17d720: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17d724: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17d728: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x17d72c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d730: 0x45000004
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17d744;
    }
    // 0x17d738: 0x78620000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17d73c: 0x10000005
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17d754;
    }
label_17d744:
    // 0x17d744: 0x4a6203bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x17d748: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17d74c: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x17d750: 0xfba10020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[1]));
label_17d754:
    // 0x17d754: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17d758: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17d75c: 0x4482a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 2);
    // 0x17d760: 0x27a50020
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 32));
    // 0x17d764: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17d768: 0xc07b5ce
    SET_GPR_U32(ctx, 31, 0x17d770);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 48));
    SProjectVector__FP6VECTORT0(rdram, ctx, runtime); return;
}


// Function: entry_17d770
// Address: 0x17d770 - 0x17d8c8

void entry_17d770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17d770) {
        switch (ctx->pc) {
            case 0x17d7c4: ctx->pc = 0; goto label_17d7c4;
            case 0x17d7c8: ctx->pc = 0; goto label_17d7c8;
            case 0x17d7cc: ctx->pc = 0; goto label_17d7cc;
            case 0x17d7d0: ctx->pc = 0; goto label_17d7d0;
            case 0x17d818: ctx->pc = 0; goto label_17d818;
            case 0x17d848: ctx->pc = 0; goto label_17d848;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17d770: 0x46000046
    ctx->f[1] = FPU_MOV_S(ctx->f[0]);
    // 0x17d774: 0x46140834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d778: 0x0
    // NOP
    // 0x17d77c: 0x45000011
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17d7c4;
    }
    // 0x17d784: 0x3c01be80
    SET_GPR_U32(ctx, 1, ((uint32_t)48768 << 16));
    // 0x17d788: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17d78c: 0x4600a002
    ctx->f[0] = FPU_MUL_S(ctx->f[20], ctx->f[0]);
    // 0x17d790: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d794: 0x0
    // NOP
    // 0x17d798: 0x4502000b
    if (!(ctx->fcr31 & 0x800000)) {
        WRITE128(ADD32(GPR_U32(ctx, 17), 8848), GPR_VEC(ctx, 2));
        goto label_17d7c8;
    }
    // 0x17d7a0: 0x4402a000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[20]);
    // 0x17d7a4: 0x48a20800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17d7a8: 0xdba20030
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17d7ac: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17d7b0: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x17d7b4: 0x4be11888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17d7b8: 0xfba10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17d7bc: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17d7c0: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_17d7c4:
    // 0x17d7c4: 0x7e222290
    WRITE128(ADD32(GPR_U32(ctx, 17), 8848), GPR_VEC(ctx, 2));
label_17d7c8:
    // 0x17d7c8: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
label_17d7cc:
    // 0x17d7cc: 0x2c620010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 16));
label_17d7d0:
    // 0x17d7d0: 0x10400011
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17d818;
    }
    // 0x17d7d8: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x17d7dc: 0x2442b090
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294946960));
    // 0x17d7e0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x17d7e4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17d7e8: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x17d7f0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17d7f4: 0xc622222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x17d7f8: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17d7fc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17d800: 0xc4413eb0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16048)); ctx->f[1] = *(float*)&val; }
    // 0x17d804: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17d808: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d80c: 0x0
    // NOP
    // 0x17d810: 0x45000126
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17DCAC; return;
    }
label_17d818:
    // 0x17d818: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17d81c: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17d820: 0x8c502708
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 9992)));
    // 0x17d824: 0x3c0144bb
    SET_GPR_U32(ctx, 1, ((uint32_t)17595 << 16));
    // 0x17d828: 0x34218000
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 32768));
    // 0x17d82c: 0x4481b000
    *(uint32_t*)&ctx->f[22] = GPR_U32(ctx, 1);
    // 0x17d830: 0x12000064
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17D9C4; return;
    }
    // 0x17d838: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x17d83c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x17d840: 0x3c120025
    SET_GPR_U32(ctx, 18, ((uint32_t)37 << 16));
    // 0x17d844: 0xda020140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
label_17d848:
    // 0x17d848: 0x26070140
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 16), 320));
    // 0x17d84c: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x17d850: 0x4be110ac
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17d854: 0x3c0148af
    SET_GPR_U32(ctx, 1, ((uint32_t)18607 << 16));
    // 0x17d858: 0x3421c800
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 51200));
    // 0x17d85c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17d860: 0x4b8210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17d864: 0x4b021081
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17d868: 0x48221000
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17d86c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x17d870: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d874: 0x0
    // NOP
    // 0x17d878: 0x45030050
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
        ctx->pc = 0x17D9BC; return;
    }
    // 0x17d880: 0xc6000148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 328)); ctx->f[0] = *(float*)&val; }
    // 0x17d884: 0xc6010568
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 1384)); ctx->f[1] = *(float*)&val; }
    // 0x17d888: 0xc6220148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 328)); ctx->f[2] = *(float*)&val; }
    // 0x17d88c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17d890: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d894: 0x0
    // NOP
    // 0x17d898: 0x45030048
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
        ctx->pc = 0x17D9BC; return;
    }
    // 0x17d8a0: 0x27a20030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 48));
    // 0x17d8a4: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17d8a8: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x17d8ac: 0x26250150
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 336));
    // 0x17d8b0: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17d8b4: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17d8b8: 0x27a900d0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 208));
    // 0x17d8bc: 0x27aa00d4
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 212));
    // 0x17d8c0: 0xc073964
    SET_GPR_U32(ctx, 31, 0x17d8c8);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 16));
    MeasureJtJumpToTarget__FP2JTP6VECTORP3ALOT1T1PfT5T1T1(rdram, ctx, runtime); return;
}


// Function: entry_17d8c8
// Address: 0x17d8c8 - 0x17d940

void entry_17d8c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d8c8: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x17d8cc: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d8d0: 0x0
    // NOP
    // 0x17d8d4: 0x45030039
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
        ctx->pc = 0x17D9BC; return;
    }
    // 0x17d8dc: 0xda010100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 256)));
    // 0x17d8e0: 0x26448d30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 18), 4294937904));
    // 0x17d8e4: 0xda230140
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x17d8e8: 0x27a50060
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    // 0x17d8ec: 0x4be118ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17d8f0: 0xc7a000d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[0] = *(float*)&val; }
    // 0x17d8f4: 0xfba30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17d8f8: 0x27a60080
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 128));
    // 0x17d8fc: 0x4600a829
    ctx->f[0] = std::min(ctx->f[21], ctx->f[0]);
    // 0x17d900: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x17d904: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17d908: 0x27a700d8
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 216));
    // 0x17d90c: 0xda210150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x17d910: 0x48a22000
    ctx->vu0_vf[4] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17d914: 0xda020150
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 336)));
    // 0x17d918: 0x27a800dc
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 220));
    // 0x17d91c: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17d920: 0xfba40090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17d924: 0x4be302bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x17d928: 0x4be408c8
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[4], ctx->vu0_vf[4], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17d92c: 0xfba10070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17d930: 0xfba30080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17d934: 0xe7b40088
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 136), *(uint32_t*)&val); }
    // 0x17d938: 0xc0618c8
    SET_GPR_U32(ctx, 31, 0x17d940);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 104), *(uint32_t*)&val); }
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime); return;
}


// Function: entry_17d940
// Address: 0x17d940 - 0x17d9e8

void entry_17d940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17d940) {
        switch (ctx->pc) {
            case 0x17d96c: ctx->pc = 0; goto label_17d96c;
            case 0x17d99c: ctx->pc = 0; goto label_17d99c;
            case 0x17d9bc: ctx->pc = 0; goto label_17d9bc;
            case 0x17d9c4: ctx->pc = 0; goto label_17d9c4;
            case 0x17d9e0: ctx->pc = 0; goto label_17d9e0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17d940: 0xc7a100dc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 220)); ctx->f[1] = *(float*)&val; }
    // 0x17d944: 0x3c0142c8
    SET_GPR_U32(ctx, 1, ((uint32_t)17096 << 16));
    // 0x17d948: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17d94c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d950: 0x0
    // NOP
    // 0x17d954: 0x45010005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 216)); ctx->f[0] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17d96c;
    }
    // 0x17d95c: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d960: 0x0
    // NOP
    // 0x17d964: 0x4500000d
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17d99c;
    }
label_17d96c:
    // 0x17d96c: 0x3c0141c8
    SET_GPR_U32(ctx, 1, ((uint32_t)16840 << 16));
    // 0x17d970: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17d974: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d978: 0x0
    // NOP
    // 0x17d97c: 0x4503000f
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
        goto label_17d9bc;
    }
    // 0x17d984: 0xc6200158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 344)); ctx->f[0] = *(float*)&val; }
    // 0x17d988: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17d98c: 0x0
    // NOP
    // 0x17d990: 0x4503000a
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
        goto label_17d9bc;
    }
    // 0x17d998: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_17d99c:
    // 0x17d99c: 0x200982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17d9a0: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17d9a4: 0xa82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17d9a8: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x17d9ac: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x17d9b0: 0xc7b700d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[23] = *(float*)&val; }
    // 0x17d9b4: 0xc7b600d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[22] = *(float*)&val; }
    // 0x17d9b8: 0x8e100558
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 1368)));
label_17d9bc:
    // 0x17d9bc: 0x5600ffa2
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 16), 320)));
        ctx->pc = 0x17D848; return;
    }
label_17d9c4:
    // 0x17d9c4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17d9c8: 0x8c504088
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 2), 16520)));
    // 0x17d9cc: 0x12000067
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17DB6C; return;
    }
    // 0x17d9d4: 0x27b20060
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 29), 96));
    // 0x17d9d8: 0x3c140025
    SET_GPR_U32(ctx, 20, ((uint32_t)37 << 16));
    // 0x17d9dc: 0x0
    // NOP
label_17d9e0:
    // 0x17d9e0: 0xc06482c
    SET_GPR_U32(ctx, 31, 0x17d9e8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    GetPntPos__FP3PNTP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17d9e8
// Address: 0x17d9e8 - 0x17da4c

void entry_17d9e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17d9e8: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17d9ec: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x17d9f0: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17d9f4: 0x3c0148af
    SET_GPR_U32(ctx, 1, ((uint32_t)18607 << 16));
    // 0x17d9f8: 0x3421c800
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 51200));
    // 0x17d9fc: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17da00: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17da04: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17da08: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17da0c: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x17da10: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17da14: 0x0
    // NOP
    // 0x17da18: 0x45030052
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        ctx->pc = 0x17DB64; return;
    }
    // 0x17da20: 0x27a20030
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 29), 48));
    // 0x17da24: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17da28: 0xafa20000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 2));
    // 0x17da2c: 0x26250150
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 17), 336));
    // 0x17da30: 0x240382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17da34: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17da38: 0x8e060018
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x17da3c: 0x27a900d0
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 208));
    // 0x17da40: 0x27aa00d4
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 212));
    // 0x17da44: 0xc073964
    SET_GPR_U32(ctx, 31, 0x17da4c);
    SET_GPR_S32(ctx, 11, ADD32(GPR_U32(ctx, 29), 16));
    MeasureJtJumpToTarget__FP2JTP6VECTORP3ALOT1T1PfT5T1T1(rdram, ctx, runtime); return;
}


// Function: entry_17da4c
// Address: 0x17da4c - 0x17da88

void entry_17da4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17da4c: 0xc7a000d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[0] = *(float*)&val; }
    // 0x17da50: 0x4600b034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[22], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17da54: 0x0
    // NOP
    // 0x17da58: 0x45030042
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        ctx->pc = 0x17DB64; return;
    }
    // 0x17da60: 0x8e040018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x17da64: 0x27a70070
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 112));
    // 0x17da68: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17da6c: 0x240302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17da70: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17da74: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17da78: 0x3c013e80
    SET_GPR_U32(ctx, 1, ((uint32_t)16000 << 16));
    // 0x17da7c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x17da80: 0xc049e2a
    SET_GPR_U32(ctx, 31, 0x17da88);
    SET_GPR_U64(ctx, 10, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CalculateAloMovement__FP3ALOT0P6VECTORN42(rdram, ctx, runtime); return;
}


// Function: entry_17da88
// Address: 0x17da88 - 0x17daec

void entry_17da88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17da88: 0x4480a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 0);
    // 0x17da8c: 0xc7a000d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[0] = *(float*)&val; }
    // 0x17da90: 0x26848d30
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 4294937904));
    // 0x17da94: 0xda240140
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x17da98: 0x27a50080
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 128));
    // 0x17da9c: 0x4600a829
    ctx->f[0] = std::min(ctx->f[21], ctx->f[0]);
    // 0x17daa0: 0xdba20060
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17daa4: 0xda210150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 336)));
    // 0x17daa8: 0x4be2212c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x17daac: 0xdba30070
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x17dab0: 0x27a600b0
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 176));
    // 0x17dab4: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17dab8: 0x4be3086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17dabc: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17dac0: 0xfba40080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17dac4: 0x4be402bc
    ctx->vu0_i = (float)ctx->vi[4];
    // 0x17dac8: 0x4be20908
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17dacc: 0xfba10090
    WRITE128(ADD32(GPR_U32(ctx, 29), 144), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17dad0: 0xfba400b0
    WRITE128(ADD32(GPR_U32(ctx, 29), 176), _mm_castps_si128(ctx->vu0_vf[4]));
    // 0x17dad4: 0x27a700e0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 224));
    // 0x17dad8: 0xfba200c0
    WRITE128(ADD32(GPR_U32(ctx, 29), 192), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17dadc: 0x27a800e4
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 228));
    // 0x17dae0: 0xe7b400b8
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 184), *(uint32_t*)&val); }
    // 0x17dae4: 0xc0618c8
    SET_GPR_U32(ctx, 31, 0x17daec);
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 29), 136), *(uint32_t*)&val); }
    FindClosestPointOnLineSegment__FP6VECTORN20PfT3(rdram, ctx, runtime); return;
}


// Function: entry_17daec
// Address: 0x17daec - 0x17dba8

void entry_17daec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17daec) {
        switch (ctx->pc) {
            case 0x17db1c: ctx->pc = 0; goto label_17db1c;
            case 0x17db44: ctx->pc = 0; goto label_17db44;
            case 0x17db64: ctx->pc = 0; goto label_17db64;
            case 0x17db6c: ctx->pc = 0; goto label_17db6c;
            case 0x17db94: ctx->pc = 0; goto label_17db94;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17daec: 0xc7a200e4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 228)); ctx->f[2] = *(float*)&val; }
    // 0x17daf0: 0xc6010058
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 88)); ctx->f[1] = *(float*)&val; }
    // 0x17daf4: 0x46020834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17daf8: 0x0
    // NOP
    // 0x17dafc: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
        goto label_17db1c;
    }
    // 0x17db04: 0xc7a000e0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 224)); ctx->f[0] = *(float*)&val; }
    // 0x17db08: 0x46140032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17db0c: 0x0
    // NOP
    // 0x17db10: 0x4500000c
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17db44;
    }
    // 0x17db18: 0x46150802
    ctx->f[0] = FPU_MUL_S(ctx->f[1], ctx->f[21]);
label_17db1c:
    // 0x17db1c: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17db20: 0x0
    // NOP
    // 0x17db24: 0x4503000f
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        goto label_17db64;
    }
    // 0x17db2c: 0xc6200158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 344)); ctx->f[0] = *(float*)&val; }
    // 0x17db30: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17db34: 0x0
    // NOP
    // 0x17db38: 0x4503000a
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
        goto label_17db64;
    }
    // 0x17db40: 0x7ba30010
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 16)));
label_17db44:
    // 0x17db44: 0x200a82d
    SET_GPR_U64(ctx, 21, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17db48: 0x7ba20030
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17db4c: 0x982d
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17db50: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x17db54: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
    // 0x17db58: 0xc7b700d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[23] = *(float*)&val; }
    // 0x17db5c: 0xc7b600d4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 212)); ctx->f[22] = *(float*)&val; }
    // 0x17db60: 0x8e100050
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 80)));
label_17db64:
    // 0x17db64: 0x1600ff9e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17D9E0; return;
    }
label_17db6c:
    // 0x17db6c: 0x12600031
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 19) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17DC34; return;
    }
    // 0x17db74: 0x8e232220
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8736)));
    // 0x17db78: 0x54620006
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 9136)));
        goto label_17db94;
    }
    // 0x17db80: 0x8e232228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 8744)));
    // 0x17db84: 0x24020005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    // 0x17db88: 0x1062002a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17DC34; return;
    }
    // 0x17db90: 0x8e3023b0
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 9136)));
label_17db94:
    // 0x17db94: 0x1213000a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 19)) {
        ctx->pc = 0x17DBC0; return;
    }
    // 0x17db9c: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x17dba0: 0xc04e3ca
    SET_GPR_U32(ctx, 31, 0x17dba8);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_17dba8
// Address: 0x17dba8 - 0x17dbbc

void entry_17dba8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17dba8: 0x12000005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17DBC0; return;
    }
    // 0x17dbb0: 0x8e240014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x17dbb4: 0xc04e3ca
    SET_GPR_U32(ctx, 31, 0x17dbbc);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    RecalcSwOxfFilterForObject__FP2SWP2SO(rdram, ctx, runtime); return;
}


// Function: entry_17dbbc
// Address: 0x17dbbc - 0x17dc2c

void entry_17dbbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17dbbc) {
        switch (ctx->pc) {
            case 0x17dbc0: ctx->pc = 0; goto label_17dbc0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17dbbc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
label_17dbc0:
    // 0x17dbc0: 0x8e272514
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x17dbc4: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17dbc8: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17dbcc: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x17dbd0: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17dbd4: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17dbd8: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x17dbdc: 0x24060004
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4));
    // 0x17dbe0: 0xe4e00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 24), *(uint32_t*)&val); }
    // 0x17dbe4: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17dbe8: 0x8e232514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x17dbec: 0x7c620020
    WRITE128(ADD32(GPR_U32(ctx, 3), 32), GPR_VEC(ctx, 2));
    // 0x17dbf0: 0x8e272514
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x17dbf4: 0xc4e00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 40)); ctx->f[0] = *(float*)&val; }
    // 0x17dbf8: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17dbfc: 0xe4e00028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 40), *(uint32_t*)&val); }
    // 0x17dc00: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17dc04: 0x8e232514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x17dc08: 0x7c620030
    WRITE128(ADD32(GPR_U32(ctx, 3), 48), GPR_VEC(ctx, 2));
    // 0x17dc0c: 0xc6200358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 856)); ctx->f[0] = *(float*)&val; }
    // 0x17dc10: 0xc6210158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 344)); ctx->f[1] = *(float*)&val; }
    // 0x17dc14: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x17dc18: 0x8e222514
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x17dc1c: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x17dc20: 0xe4410038
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 56), *(uint32_t*)&val); }
    // 0x17dc24: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17dc2c);
    WRITE32(ADD32(GPR_U32(ctx, 17), 9136), GPR_U32(ctx, 19));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17dc2c
// Address: 0x17dc2c - 0x17dca8

void entry_17dc2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17dc2c) {
        switch (ctx->pc) {
            case 0x17dc34: ctx->pc = 0; goto label_17dc34;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17dc2c: 0x1000001f
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17DCAC; return;
    }
label_17dc34:
    // 0x17dc34: 0x12a0001c
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 21) == GPR_U32(ctx, 0)) {
        entry_17dca8(rdram, ctx, runtime); return;
    }
    // 0x17dc3c: 0x8e272514
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x17dc40: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17dc44: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17dc48: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x17dc4c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17dc50: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17dc54: 0x46170000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[23]);
    // 0x17dc58: 0x24060009
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 9));
    // 0x17dc5c: 0xe4e00018
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 24), *(uint32_t*)&val); }
    // 0x17dc60: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17dc64: 0x8e232514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x17dc68: 0x7c620020
    WRITE128(ADD32(GPR_U32(ctx, 3), 32), GPR_VEC(ctx, 2));
    // 0x17dc6c: 0x8e272514
    SET_GPR_U32(ctx, 7, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x17dc70: 0xc4e00028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 40)); ctx->f[0] = *(float*)&val; }
    // 0x17dc74: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17dc78: 0xe4e00028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 7), 40), *(uint32_t*)&val); }
    // 0x17dc7c: 0x7ba20040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17dc80: 0x8e232514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x17dc84: 0x7c620030
    WRITE128(ADD32(GPR_U32(ctx, 3), 48), GPR_VEC(ctx, 2));
    // 0x17dc88: 0xc6200358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 856)); ctx->f[0] = *(float*)&val; }
    // 0x17dc8c: 0xc6210158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 344)); ctx->f[1] = *(float*)&val; }
    // 0x17dc90: 0x4600b802
    ctx->f[0] = FPU_MUL_S(ctx->f[23], ctx->f[0]);
    // 0x17dc94: 0x8e222514
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 9492)));
    // 0x17dc98: 0x46000840
    ctx->f[1] = FPU_ADD_S(ctx->f[1], ctx->f[0]);
    // 0x17dc9c: 0xe4410038
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 2), 56), *(uint32_t*)&val); }
    // 0x17dca0: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17dca8);
    WRITE32(ADD32(GPR_U32(ctx, 17), 9140), GPR_U32(ctx, 21));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17dca8
// Address: 0x17dca8 - 0x17dce0

void entry_17dca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17dca8) {
        switch (ctx->pc) {
            case 0x17dcac: ctx->pc = 0; goto label_17dcac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17dca8: 0x7bbf0150
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 336)));
label_17dcac:
    // 0x17dcac: 0x7bb50140
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x17dcb0: 0x7bb40130
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x17dcb4: 0x7bb30120
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x17dcb8: 0x7bb20110
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x17dcbc: 0x7bb10100
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x17dcc0: 0x7bb000f0
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 240)));
    // 0x17dcc4: 0xc7b70178
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 376)); ctx->f[23] = *(float*)&val; }
    // 0x17dcc8: 0xc7b60170
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 368)); ctx->f[22] = *(float*)&val; }
    // 0x17dccc: 0xc7b50168
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 360)); ctx->f[21] = *(float*)&val; }
    // 0x17dcd0: 0xc7b40160
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 352)); ctx->f[20] = *(float*)&val; }
    // 0x17dcd4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 384));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17dcdc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17dce0; return;
}


// Function: FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR
// Address: 0x17dce0 - 0x17de88

void entry_17defc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17defc: 0x27a60030
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    // 0x17df00: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17df04: 0xc0622c2
    SET_GPR_U32(ctx, 31, 0x17df0c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    LoadMatrixFromPosRot__FP6VECTORP7MATRIX3P7MATRIX4(rdram, ctx, runtime); return;
}


// Function: entry_17df0c
// Address: 0x17df0c - 0x17df3c

void entry_17df0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17df0c) {
        switch (ctx->pc) {
            case 0x17df28: ctx->pc = 0; goto label_17df28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17df0c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17df10: 0x27b70070
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 29), 112));
    // 0x17df14: 0x24423ec0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16064));
    // 0x17df18: 0x27b50080
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 29), 128));
    // 0x17df1c: 0xafa20108
    WRITE32(ADD32(GPR_U32(ctx, 29), 264), GPR_U32(ctx, 2));
    // 0x17df20: 0x24420010
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 16));
    // 0x17df24: 0xafa20104
    WRITE32(ADD32(GPR_U32(ctx, 29), 260), GPR_U32(ctx, 2));
label_17df28:
    // 0x17df28: 0x8fa50108
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 264)));
    // 0x17df2c: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x17df30: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x17df34: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x17df3c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_17df3c
// Address: 0x17df3c - 0x17df50

void entry_17df3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17df3c: 0x8fa50104
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    // 0x17df40: 0x27a40030
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 48));
    // 0x17df44: 0x4600b306
    ctx->f[12] = FPU_MOV_S(ctx->f[22]);
    // 0x17df48: 0xc0621c0
    SET_GPR_U32(ctx, 31, 0x17df50);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    MultiplyMatrix4Vector__FP7MATRIX4P6VECTORfT1(rdram, ctx, runtime); return;
}


// Function: entry_17df50
// Address: 0x17df50 - 0x17dfd4

void entry_17df50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17df50) {
        switch (ctx->pc) {
            case 0x17df70: ctx->pc = 0; goto label_17df70;
            case 0x17dfb0: ctx->pc = 0; goto label_17dfb0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17df50: 0x8fa30100
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x17df54: 0x8c620480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 1152)));
    // 0x17df58: 0x8c510000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17df5c: 0x12200031
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 260)));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E024; return;
    }
    // 0x17df64: 0x341e8000
    SET_GPR_U32(ctx, 30, OR32(GPR_U32(ctx, 0), 32768));
    // 0x17df68: 0x1ef6f8
    SET_GPR_U64(ctx, 30, GPR_U64(ctx, 30) << 27);
    // 0x17df6c: 0x8e24000c
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
label_17df70:
    // 0x17df70: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x17df74: 0x5e1024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 30)));
    // 0x17df78: 0x54400027
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        ctx->pc = 0x17E018; return;
    }
    // 0x17df80: 0x8c9002d8
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 4), 728)));
    // 0x17df84: 0x52000024
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
        ctx->pc = 0x17E018; return;
    }
    // 0x17df8c: 0x4480a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 0);
    // 0x17df90: 0x34138000
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 0), 32768));
    // 0x17df94: 0x139f38
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) << 28);
    // 0x17df98: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x17df9c: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x17dfa0: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x17dfa4: 0x2a920004
    SET_GPR_U32(ctx, 18, SLT32(GPR_S32(ctx, 20), 4));
    // 0x17dfa8: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x17dfac: 0x0
    // NOP
label_17dfb0:
    // 0x17dfb0: 0x531024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x17dfb4: 0x54400015
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        ctx->pc = 0x17E00C; return;
    }
    // 0x17dfbc: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17dfc0: 0x2e0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 23) + GPR_U64(ctx, 0));
    // 0x17dfc4: 0x2a0302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x17dfc8: 0x24070001
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17dfcc: 0xc05070a
    SET_GPR_U32(ctx, 31, 0x17dfd4);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 144));
    ClsgClipEdgeToObject__FP2SOP6VECTORT1iP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_17dfd4
// Address: 0x17dfd4 - 0x17e088

void entry_17dfd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17dfd4) {
        switch (ctx->pc) {
            case 0x17e008: ctx->pc = 0; goto label_17e008;
            case 0x17e00c: ctx->pc = 0; goto label_17e00c;
            case 0x17e018: ctx->pc = 0; goto label_17e018;
            case 0x17e024: ctx->pc = 0; goto label_17e024;
            case 0x17e04c: ctx->pc = 0; goto label_17e04c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17dfd4: 0x5840000d
    if (GPR_S32(ctx, 2) <= 0) {
        SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
        goto label_17e00c;
    }
    // 0x17dfdc: 0x1640001b
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) != GPR_U32(ctx, 0)) {
        goto label_17e04c;
    }
    // 0x17dfe4: 0xc7a000d0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 208)); ctx->f[0] = *(float*)&val; }
    // 0x17dfe8: 0x46150032
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[0], ctx->f[21])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17dfec: 0x0
    // NOP
    // 0x17dff0: 0x45010016
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 184)); ctx->f[0] = *(float*)&val; }
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17e04c;
    }
    // 0x17dff8: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17dffc: 0x0
    // NOP
    // 0x17e000: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 22), 1));
        goto label_17e008;
    }
label_17e008:
    // 0x17e008: 0x8e1002e4
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 740)));
label_17e00c:
    // 0x17e00c: 0x5600ffe8
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
        ctx->pc = 0x17DFB0; return;
    }
    // 0x17e014: 0x8e310004
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 17), 4)));
label_17e018:
    // 0x17e018: 0x5620ffd5
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 12)));
        ctx->pc = 0x17DF70; return;
    }
    // 0x17e020: 0x8fa20104
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 260)));
label_17e024:
    // 0x17e024: 0x26940002
    SET_GPR_S32(ctx, 20, ADD32(GPR_U32(ctx, 20), 2));
    // 0x17e028: 0x8fa30108
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 264)));
    // 0x17e02c: 0x24420020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 32));
    // 0x17e030: 0xafa20104
    WRITE32(ADD32(GPR_U32(ctx, 29), 260), GPR_U32(ctx, 2));
    // 0x17e034: 0x24630020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 32));
    // 0x17e038: 0x2e820016
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 20), 22));
    // 0x17e03c: 0x1440ffba
    WRITE32(ADD32(GPR_U32(ctx, 29), 264), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17DF28; return;
    }
    // 0x17e044: 0x2ac20002
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 22), 2));
    // 0x17e048: 0x38420001
    SET_GPR_U32(ctx, 2, XOR32(GPR_U32(ctx, 2), 1));
label_17e04c:
    // 0x17e04c: 0x7bbf01a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x17e050: 0x7bbe0190
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x17e054: 0x7bb70180
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x17e058: 0x7bb60170
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x17e05c: 0x7bb50160
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x17e060: 0x7bb40150
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x17e064: 0x7bb30140
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x17e068: 0x7bb20130
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x17e06c: 0x7bb10120
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 288)));
    // 0x17e070: 0x7bb00110
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 272)));
    // 0x17e074: 0xc7b601c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 448)); ctx->f[22] = *(float*)&val; }
    // 0x17e078: 0xc7b501b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 440)); ctx->f[21] = *(float*)&val; }
    // 0x17e07c: 0xc7b401b0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 432)); ctx->f[20] = *(float*)&val; }
    // 0x17e080: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 464));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FCheckJtEdgeGrab__FP2JTP2SOP6VECTOR3XPKPvT2
// Address: 0x17e088 - 0x17e12c

void entry_17e12c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e12c) {
        switch (ctx->pc) {
            case 0x17e140: ctx->pc = 0; goto label_17e140;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e12c: 0x18400012
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x17E178; return;
    }
    // 0x17e134: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17e138: 0x3a0802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17e13c: 0x0
    // NOP
label_17e140:
    // 0x17e140: 0x8e060000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x17e144: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x17e148: 0xfba30120
    WRITE128(ADD32(GPR_U32(ctx, 29), 288), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17e14c: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17e150: 0xc05f738
    SET_GPR_U32(ctx, 31, 0x17e158);
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 256));
    FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17e158
// Address: 0x17e158 - 0x17e1ec

void entry_17e158(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e158) {
        switch (ctx->pc) {
            case 0x17e16c: ctx->pc = 0; goto label_17e16c;
            case 0x17e178: ctx->pc = 0; goto label_17e178;
            case 0x17e1dc: ctx->pc = 0; goto label_17e1dc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e158: 0x10400004
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 288)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17e16c;
    }
    // 0x17e160: 0xdba10100
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 256)));
    // 0x17e164: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17e168: 0x4be118e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
label_17e16c:
    // 0x17e16c: 0x2631ffff
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 4294967295));
    // 0x17e170: 0x1620fff3
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 4));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E140; return;
    }
label_17e178:
    // 0x17e178: 0x52400088
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        entry_17e39c(rdram, ctx, runtime); return;
    }
    // 0x17e180: 0x4bc3186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17e184: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17e188: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17e18c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17e190: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x17e194: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x17e198: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17e19c: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17e1a0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17e1a4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17e1a8: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17e1ac: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17e1b0: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x17e1b4: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x17e1b8: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17e1bc: 0x0
    // NOP
    // 0x17e1c0: 0x4501006c
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17E374; return;
    }
    // 0x17e1c8: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17e1cc: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17e1d0: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
    // 0x17e1d4: 0x1000006d
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E38C; return;
    }
label_17e1dc:
    // 0x17e1dc: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17e1e0: 0x220302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17e1e4: 0xc05f738
    SET_GPR_U32(ctx, 31, 0x17e1ec);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17e1ec
// Address: 0x17e1ec - 0x17e250

void entry_17e1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e1ec) {
        switch (ctx->pc) {
            case 0x17e1f4: ctx->pc = 0; goto label_17e1f4;
            case 0x17e1fc: ctx->pc = 0; goto label_17e1fc;
            case 0x17e240: ctx->pc = 0; goto label_17e240;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e1ec: 0x14400068
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E390; return;
    }
label_17e1f4:
    // 0x17e1f4: 0x10000069
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17e39c(rdram, ctx, runtime); return;
    }
label_17e1fc:
    // 0x17e1fc: 0xc6210008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8)); ctx->f[1] = *(float*)&val; }
    // 0x17e200: 0x3c013f33
    SET_GPR_U32(ctx, 1, ((uint32_t)16179 << 16));
    // 0x17e204: 0x34213333
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 13107));
    // 0x17e208: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17e20c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17e210: 0x0
    // NOP
    // 0x17e214: 0x45010061
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        entry_17e39c(rdram, ctx, runtime); return;
    }
    // 0x17e21c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17e220: 0x8e300014
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 20)));
    // 0x17e224: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x17e228: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17e22c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17e230: 0x1200001d
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E2A8; return;
    }
    // 0x17e238: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x17e23c: 0x0
    // NOP
label_17e240:
    // 0x17e240: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17e244: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17e248: 0xc05f738
    SET_GPR_U32(ctx, 31, 0x17e250);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17e250
// Address: 0x17e250 - 0x17e284

void entry_17e250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17e250: 0x10400012
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E29C; return;
    }
    // 0x17e258: 0x86050000
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x17e25c: 0x86060002
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 16), 2)));
    // 0x17e260: 0x24080002
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17e264: 0x8e6203ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 940)));
    // 0x17e268: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x17e26c: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x17e270: 0x8e8403f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 1016)));
    // 0x17e274: 0x463021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x17e278: 0x452821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x17e27c: 0xc04f7f6
    SET_GPR_U32(ctx, 31, 0x17e284);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_17e284
// Address: 0x17e284 - 0x17e2c8

void entry_17e284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e284) {
        switch (ctx->pc) {
            case 0x17e29c: ctx->pc = 0; goto label_17e29c;
            case 0x17e2a8: ctx->pc = 0; goto label_17e2a8;
            case 0x17e2b8: ctx->pc = 0; goto label_17e2b8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e284: 0x18400005
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_17e29c;
    }
    // 0x17e28c: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17e290: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17e294: 0x4be110a8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17e298: 0xfba20110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[2]));
label_17e29c:
    // 0x17e29c: 0x8e100008
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 8)));
    // 0x17e2a0: 0x1600ffe7
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E240; return;
    }
label_17e2a8:
    // 0x17e2a8: 0x8e300018
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x17e2ac: 0x1200001c
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E320; return;
    }
    // 0x17e2b4: 0x0
    // NOP
label_17e2b8:
    // 0x17e2b8: 0x260282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17e2bc: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17e2c0: 0xc05f738
    SET_GPR_U32(ctx, 31, 0x17e2c8);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17e2c8
// Address: 0x17e2c8 - 0x17e2fc

void entry_17e2c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17e2c8: 0x10400012
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E314; return;
    }
    // 0x17e2d0: 0x86050000
    SET_GPR_S32(ctx, 5, (int16_t)READ16(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x17e2d4: 0x86060002
    SET_GPR_S32(ctx, 6, (int16_t)READ16(ADD32(GPR_U32(ctx, 16), 2)));
    // 0x17e2d8: 0x24080002
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17e2dc: 0x8e6203ac
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 940)));
    // 0x17e2e0: 0x52900
    SET_GPR_U32(ctx, 5, SLL32(GPR_U32(ctx, 5), 4));
    // 0x17e2e4: 0x63100
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 4));
    // 0x17e2e8: 0x8e8403f8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 1016)));
    // 0x17e2ec: 0x463021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 6)));
    // 0x17e2f0: 0x452821
    SET_GPR_U32(ctx, 5, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x17e2f4: 0xc04f7f6
    SET_GPR_U32(ctx, 31, 0x17e2fc);
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 16));
    ClsgClipEdgeToBsp__FP3BSPP6VECTORT1PiiP3LSG(rdram, ctx, runtime); return;
}


// Function: entry_17e2fc
// Address: 0x17e2fc - 0x17e39c

void entry_17e2fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e2fc) {
        switch (ctx->pc) {
            case 0x17e314: ctx->pc = 0; goto label_17e314;
            case 0x17e320: ctx->pc = 0; goto label_17e320;
            case 0x17e374: ctx->pc = 0; goto label_17e374;
            case 0x17e37c: ctx->pc = 0; goto label_17e37c;
            case 0x17e388: ctx->pc = 0; goto label_17e388;
            case 0x17e38c: ctx->pc = 0; goto label_17e38c;
            case 0x17e390: ctx->pc = 0; goto label_17e390;
            case 0x17e394: ctx->pc = 0; goto label_17e394;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e2fc: 0x18400005
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_17e314;
    }
    // 0x17e304: 0x24120001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17e308: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17e30c: 0x4be118e8
    { __m128 res = PS2_VADD(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17e310: 0xfba30110
    WRITE128(ADD32(GPR_U32(ctx, 29), 272), _mm_castps_si128(ctx->vu0_vf[3]));
label_17e314:
    // 0x17e314: 0x8e10000c
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 12)));
    // 0x17e318: 0x1600ffe7
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E2B8; return;
    }
label_17e320:
    // 0x17e320: 0x1240ffb4
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E1F4; return;
    }
    // 0x17e328: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17e32c: 0x4bc4206a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x17e330: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17e334: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17e338: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17e33c: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x17e340: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x17e344: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17e348: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17e34c: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17e350: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17e354: 0x24428d00
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x17e358: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17e35c: 0x78420000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17e360: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x17e364: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17e368: 0x0
    // NOP
    // 0x17e36c: 0x45000003
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 272)));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17e37c;
    }
label_17e374:
    // 0x17e374: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17e388;
    }
label_17e37c:
    // 0x17e37c: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17e380: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17e384: 0x4be0105c
    ctx->vu0_vf[2] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_17e388:
    // 0x17e388: 0xfaa10000
    WRITE128(ADD32(GPR_U32(ctx, 21), 0), _mm_castps_si128(ctx->vu0_vf[1]));
label_17e38c:
    // 0x17e38c: 0x280202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
label_17e390:
    // 0x17e390: 0x2c0282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_17e394:
    // 0x17e394: 0xc05f7a2
    SET_GPR_U32(ctx, 31, 0x17e39c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    FCheckJtEdgeNormal__FP2JTP6VECTORT1(rdram, ctx, runtime); return;
}


// Function: entry_17e39c
// Address: 0x17e39c - 0x17e3c8

void entry_17e39c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17e39c: 0x7bbf01a0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 416)));
    // 0x17e3a0: 0x7bb60190
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 400)));
    // 0x17e3a4: 0x7bb50180
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 384)));
    // 0x17e3a8: 0x7bb40170
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 368)));
    // 0x17e3ac: 0x7bb30160
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 352)));
    // 0x17e3b0: 0x7bb20150
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 336)));
    // 0x17e3b4: 0x7bb10140
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 320)));
    // 0x17e3b8: 0x7bb00130
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 304)));
    // 0x17e3bc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 432));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17e3c4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17e3c8; return;
}


// Function: PxpFindJtBestEdge__FP2JTPiP6VECTOR
// Address: 0x17e3c8 - 0x17e564

void entry_17e564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e564) {
        switch (ctx->pc) {
            case 0x17e594: ctx->pc = 0; goto label_17e594;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e564: 0x10400046
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E680; return;
    }
    // 0x17e56c: 0x8e6204b8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 19), 1208)));
    // 0x17e570: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x17e574: 0x10400007
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17e594;
    }
    // 0x17e57c: 0x501021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 16)));
    // 0x17e580: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17e584: 0x8c8304b8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 1208)));
    // 0x17e588: 0x30630002
    SET_GPR_U32(ctx, 3, AND32(GPR_U32(ctx, 3), 2));
    // 0x17e58c: 0x14600006
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E5A8; return;
    }
label_17e594:
    // 0x17e594: 0x8e640014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 19), 20)));
    // 0x17e598: 0x24050001
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17e59c: 0xc06182a
    SET_GPR_U32(ctx, 31, 0x17e5a4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 48));
    RecalcSwXpMovement__FP2SWiPP2XP(rdram, ctx, runtime); return;
}


// Function: entry_17e5a4
// Address: 0x17e5a4 - 0x17e63c

void entry_17e5a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e5a4) {
        switch (ctx->pc) {
            case 0x17e5a8: ctx->pc = 0; goto label_17e5a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e5a4: 0x3c030027
    SET_GPR_U32(ctx, 3, ((uint32_t)39 << 16));
label_17e5a8:
    // 0x17e5a8: 0x111080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 17), 2));
    // 0x17e5ac: 0x8fa40030
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17e5b0: 0x24634ad0
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 19152));
    // 0x17e5b4: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x17e5b8: 0x44801000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 0);
    // 0x17e5bc: 0xc4400000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 0)); ctx->f[0] = *(float*)&val; }
    // 0x17e5c0: 0xc48100b8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 184)); ctx->f[1] = *(float*)&val; }
    // 0x17e5c4: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x17e5c8: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17e5cc: 0x0
    // NOP
    // 0x17e5d0: 0x4501002b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17E680; return;
    }
    // 0x17e5d8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17e5dc: 0x2911023
    SET_GPR_U32(ctx, 2, SUB32(GPR_U32(ctx, 20), GPR_U32(ctx, 17)));
    // 0x17e5e0: 0xc4604020
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 16416)); ctx->f[0] = *(float*)&val; }
    // 0x17e5e4: 0x28180
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 2), 6));
    // 0x17e5e8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17e5ec: 0x2041021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 4)));
    // 0x17e5f0: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x17e5f4: 0x8c634024
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 16420)));
    // 0x17e5f8: 0x48a32800
    ctx->vu0_vf[5] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x17e5fc: 0xd8420010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 16)));
    // 0x17e600: 0x3c030025
    SET_GPR_U32(ctx, 3, ((uint32_t)37 << 16));
    // 0x17e604: 0xdba40000
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17e608: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17e60c: 0x24638d20
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 4294937888));
    // 0x17e610: 0xd8610000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17e614: 0x48a21800
    ctx->vu0_vf[3] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17e618: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17e61c: 0x4be202bc
    ctx->vu0_i = (float)ctx->vi[2];
    // 0x17e620: 0x4be320bc
    ctx->vu0_i = (float)ctx->vi[3];
    // 0x17e624: 0x4be50888
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[5], ctx->vu0_vf[5], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17e628: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17e62c: 0x27a40010
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17e630: 0xfba50020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[5]));
    // 0x17e634: 0xc04f996
    SET_GPR_U32(ctx, 31, 0x17e63c);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 18), 1016)));
    PbspPointInBspQuick__FP6VECTORP3BSP(rdram, ctx, runtime); return;
}


// Function: entry_17e63c
// Address: 0x17e63c - 0x17e6d0

void entry_17e63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e63c) {
        switch (ctx->pc) {
            case 0x17e668: ctx->pc = 0; goto label_17e668;
            case 0x17e680: ctx->pc = 0; goto label_17e680;
            case 0x17e684: ctx->pc = 0; goto label_17e684;
            case 0x17e68c: ctx->pc = 0; goto label_17e68c;
            case 0x17e698: ctx->pc = 0; goto label_17e698;
            case 0x17e69c: ctx->pc = 0; goto label_17e69c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e63c: 0x14400010
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_17e680;
    }
    // 0x17e644: 0x12c00008
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 22), GPR_U32(ctx, 16)));
    if (GPR_U32(ctx, 22) == GPR_U32(ctx, 0)) {
        goto label_17e668;
    }
    // 0x17e64c: 0xc4410018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[1] = *(float*)&val; }
    // 0x17e650: 0x701821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 16)));
    // 0x17e654: 0xc4600018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[0] = *(float*)&val; }
    // 0x17e658: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17e65c: 0x0
    // NOP
    // 0x17e660: 0x45010007
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17e680;
    }
label_17e668:
    // 0x17e668: 0x8fa30034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 52)));
    // 0x17e66c: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17e670: 0xac710000
    WRITE32(ADD32(GPR_U32(ctx, 3), 0), GPR_U32(ctx, 17));
    // 0x17e674: 0x7fc20000
    WRITE128(ADD32(GPR_U32(ctx, 30), 0), GPR_VEC(ctx, 2));
    // 0x17e678: 0x8fb60030
    SET_GPR_U32(ctx, 22, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17e67c: 0x8fa30030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
label_17e680:
    // 0x17e680: 0x8c6200d0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 208)));
label_17e684:
    // 0x17e684: 0x1440ff74
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E458; return;
    }
label_17e68c:
    // 0x17e68c: 0x8eb50004
    SET_GPR_U32(ctx, 21, READ32(ADD32(GPR_U32(ctx, 21), 4)));
    // 0x17e690: 0x56a0ff6b
    if (GPR_U32(ctx, 21) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 21), 0)));
        ctx->pc = 0x17E440; return;
    }
label_17e698:
    // 0x17e698: 0x2c0102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 22) + GPR_U64(ctx, 0));
label_17e69c:
    // 0x17e69c: 0x7bbf00d0
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 208)));
    // 0x17e6a0: 0x7bbe00c0
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 192)));
    // 0x17e6a4: 0x7bb700b0
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 176)));
    // 0x17e6a8: 0x7bb600a0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 160)));
    // 0x17e6ac: 0x7bb50090
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 144)));
    // 0x17e6b0: 0x7bb40080
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x17e6b4: 0x7bb30070
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x17e6b8: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17e6bc: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x17e6c0: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17e6c4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 224));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17e6cc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17e6d0; return;
}


// Function: JtsResetJt__FP2JT
// Address: 0x17e6d0 - 0x17e710

void entry_17e74c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17e74c: 0x10400159
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17ECB4; return;
    }
    // 0x17e754: 0x3c100026
    SET_GPR_U32(ctx, 16, ((uint32_t)38 << 16));
    // 0x17e758: 0x8c441990
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 6544)));
    // 0x17e75c: 0x200b02d
    SET_GPR_U64(ctx, 22, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17e760: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17e764: 0xc05180a
    SET_GPR_U32(ctx, 31, 0x17e76c);
    SET_GPR_U32(ctx, 30, ((uint32_t)40 << 16));
    FUN_00146028__FP2CM(rdram, ctx, runtime); return;
}


// Function: entry_17e76c
// Address: 0x17e76c - 0x17e774

void entry_17e76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17e76c: 0xc063582
    SET_GPR_U32(ctx, 31, 0x17e774);
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_17e774
// Address: 0x17e774 - 0x17e798

void entry_17e774(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17e774: 0x8e840014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 20), 20)));
    // 0x17e778: 0x26860140
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 20), 320));
    // 0x17e77c: 0xc60c4028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 16424)); ctx->f[12] = *(float*)&val; }
    // 0x17e780: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17e784: 0x280282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    // 0x17e788: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17e78c: 0x27a90680
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 29), 1664));
    // 0x17e790: 0xc077134
    SET_GPR_U32(ctx, 31, 0x17e798);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 1668));
    IntersectSwBoundingSphere__FP2SWP2SOP6VECTORfPFPvP2SO_iPvPiPPP2SO(rdram, ctx, runtime); return;
}


// Function: entry_17e798
// Address: 0x17e798 - 0x17e898

void entry_17e798(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e798) {
        switch (ctx->pc) {
            case 0x17e7b8: ctx->pc = 0; goto label_17e7b8;
            case 0x17e7e4: ctx->pc = 0; goto label_17e7e4;
            case 0x17e850: ctx->pc = 0; goto label_17e850;
            case 0x17e870: ctx->pc = 0; goto label_17e870;
            case 0x17e890: ctx->pc = 0; goto label_17e890;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e798: 0x8fa20680
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 1664)));
    // 0x17e79c: 0x3c060026
    SET_GPR_U32(ctx, 6, ((uint32_t)38 << 16));
    // 0x17e7a0: 0x18400010
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_S32(ctx, 2) <= 0) {
        goto label_17e7e4;
    }
    // 0x17e7a8: 0x34058000
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 0), 32768));
    // 0x17e7ac: 0x52bfc
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << (32 + 15));
    // 0x17e7b0: 0x8fa20684
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 1668)));
    // 0x17e7b4: 0x0
    // NOP
label_17e7b8:
    // 0x17e7b8: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x17e7bc: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x17e7c0: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x17e7c4: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17e7c8: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x17e7cc: 0x451025
    SET_GPR_U32(ctx, 2, OR32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x17e7d0: 0xfc820538
    WRITE64(ADD32(GPR_U32(ctx, 4), 1336), GPR_U64(ctx, 2));
    // 0x17e7d4: 0x8fa30680
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 1664)));
    // 0x17e7d8: 0x243182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 3)));
    // 0x17e7dc: 0x1460fff6
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 1668)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_17e7b8;
    }
label_17e7e4:
    // 0x17e7e4: 0x24c34038
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 6), 16440));
    // 0x17e7e8: 0xc68006a8
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 1704)); ctx->f[0] = *(float*)&val; }
    // 0x17e7ec: 0xc4610004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 4)); ctx->f[1] = *(float*)&val; }
    // 0x17e7f0: 0x3c020027
    SET_GPR_U32(ctx, 2, ((uint32_t)39 << 16));
    // 0x17e7f4: 0xc4c24038
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 16440)); ctx->f[2] = *(float*)&val; }
    // 0x17e7f8: 0x244258d0
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 22736));
    // 0x17e7fc: 0x46010040
    ctx->f[1] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17e800: 0x8fc6b314
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 30), 4294947604)));
    // 0x17e804: 0x46020000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[2]);
    // 0x17e808: 0xafa20010
    WRITE32(ADD32(GPR_U32(ctx, 29), 16), GPR_U32(ctx, 2));
    // 0x17e80c: 0xe7a10004
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 29), 4), *(uint32_t*)&val); }
    // 0x17e810: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
    // 0x17e814: 0xace20004
    WRITE32(ADD32(GPR_U32(ctx, 7), 4), GPR_U32(ctx, 2));
    // 0x17e818: 0x8fa40010
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17e81c: 0x8fa50014
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    // 0x17e820: 0x8c830008
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 4), 8)));
    // 0x17e824: 0xafa6001c
    WRITE32(ADD32(GPR_U32(ctx, 29), 28), GPR_U32(ctx, 6));
    // 0x17e828: 0xafc7b314
    WRITE32(ADD32(GPR_U32(ctx, 30), 4294947604), GPR_U32(ctx, 7));
    // 0x17e82c: 0xafa30018
    WRITE32(ADD32(GPR_U32(ctx, 29), 24), GPR_U32(ctx, 3));
    // 0x17e830: 0x8ca20000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 5), 0)));
    // 0x17e834: 0x431821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x17e838: 0x40882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17e83c: 0x12200073
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 17) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17EA0C; return;
    }
    // 0x17e844: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17e848: 0x3c170026
    SET_GPR_U32(ctx, 23, ((uint32_t)38 << 16));
    // 0x17e84c: 0x24558d00
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 2), 4294937856));
label_17e850:
    // 0x17e850: 0x8e300018
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 17), 24)));
    // 0x17e854: 0x12000015
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 16424)); ctx->f[20] = *(float*)&val; }
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E8AC; return;
    }
    // 0x17e85c: 0x34138000
    SET_GPR_U32(ctx, 19, OR32(GPR_U32(ctx, 0), 32768));
    // 0x17e860: 0x139bfc
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 19) << (32 + 15));
    // 0x17e864: 0x3c120026
    SET_GPR_U32(ctx, 18, ((uint32_t)38 << 16));
    // 0x17e868: 0x8e030000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
    // 0x17e86c: 0x0
    // NOP
label_17e870:
    // 0x17e870: 0x8c620008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 8)));
    // 0x17e874: 0x30420002
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 2));
    // 0x17e878: 0x10400005
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17e890;
    }
    // 0x17e880: 0xde020538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 16), 1336)));
    // 0x17e884: 0x531024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 19)));
    // 0x17e888: 0x1440005a
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E9F4; return;
    }
label_17e890:
    // 0x17e890: 0xc04c03a
    SET_GPR_U32(ctx, 31, 0x17e898);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 88));
    FIsBasicDerivedFrom__FP5BASIC3CID(rdram, ctx, runtime); return;
}


// Function: entry_17e898
// Address: 0x17e898 - 0x17e8b8

void entry_17e898(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e898) {
        switch (ctx->pc) {
            case 0x17e8a0: ctx->pc = 0; goto label_17e8a0;
            case 0x17e8ac: ctx->pc = 0; goto label_17e8ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e898: 0x54400001
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 16428)); ctx->f[20] = *(float*)&val; }
        goto label_17e8a0;
    }
label_17e8a0:
    // 0x17e8a0: 0x8e100018
    SET_GPR_U32(ctx, 16, READ32(ADD32(GPR_U32(ctx, 16), 24)));
    // 0x17e8a4: 0x5600fff2
    if (GPR_U32(ctx, 16) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 16), 0)));
        ctx->pc = 0x17E870; return;
    }
label_17e8ac:
    // 0x17e8ac: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17e8b0: 0xc07cef6
    SET_GPR_U32(ctx, 31, 0x17e8b8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 96));
    GetXfmPos__FP3XFMP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17e8b8
// Address: 0x17e8b8 - 0x17e944

void entry_17e8b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e8b8) {
        switch (ctx->pc) {
            case 0x17e8fc: ctx->pc = 0; goto label_17e8fc;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e8b8: 0xdba10060
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17e8bc: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17e8c0: 0xda8206a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 1696)));
    // 0x17e8c4: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17e8c8: 0xc623008c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 140)); ctx->f[3] = *(float*)&val; }
    // 0x17e8cc: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17e8d0: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17e8d4: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17e8d8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17e8dc: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17e8e0: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17e8e4: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x17e8e8: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x17e8ec: 0x4600a034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[20], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17e8f0: 0x0
    // NOP
    // 0x17e8f4: 0x45020001
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
        goto label_17e8fc;
    }
label_17e8fc:
    // 0x17e8fc: 0x1440003d
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E9F4; return;
    }
    // 0x17e904: 0xc7a20068
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 104)); ctx->f[2] = *(float*)&val; }
    // 0x17e908: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x17e90c: 0x46031000
    ctx->f[0] = FPU_ADD_S(ctx->f[2], ctx->f[3]);
    // 0x17e910: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17e914: 0x0
    // NOP
    // 0x17e918: 0x45010037
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17E9F8; return;
    }
    // 0x17e920: 0x46031041
    ctx->f[1] = FPU_SUB_S(ctx->f[2], ctx->f[3]);
    // 0x17e924: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17e928: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17e92c: 0x45010032
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17E9F8; return;
    }
    // 0x17e934: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x17e938: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17e93c: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x17e944);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_17e944
// Address: 0x17e944 - 0x17e9f0

void entry_17e944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e944) {
        switch (ctx->pc) {
            case 0x17e9a4: ctx->pc = 0; goto label_17e9a4;
            case 0x17e9b0: ctx->pc = 0; goto label_17e9b0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e944: 0xda8106a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 1696)));
    // 0x17e948: 0xdba30060
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17e94c: 0x4be1192c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17e950: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x17e954: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x17e958: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17e95c: 0x4bc420aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[4]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
    // 0x17e960: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17e964: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17e968: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17e96c: 0x7aa20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 21), 0)));
    // 0x17e970: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17e974: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17e978: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17e97c: 0xafb10024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 17));
    // 0x17e980: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17e984: 0xafb40020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 20));
    // 0x17e988: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x17e98c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17e990: 0x0
    // NOP
    // 0x17e994: 0x45000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), _mm_castps_si128(ctx->vu0_vf[3]));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17e9a4;
    }
    // 0x17e99c: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17e9b0;
    }
label_17e9a4:
    // 0x17e9a4: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17e9a8: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17e9ac: 0x4be0205c
    ctx->vu0_vf[4] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_17e9b0:
    // 0x17e9b0: 0xc6800368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 872)); ctx->f[0] = *(float*)&val; }
    // 0x17e9b4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17e9b8: 0xc6e14034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 23), 16436)); ctx->f[1] = *(float*)&val; }
    // 0x17e9bc: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x17e9c0: 0x8c424030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 16432)));
    // 0x17e9c4: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17e9c8: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x17e9cc: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17e9d0: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17e9d4: 0x24020020
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 32));
    // 0x17e9d8: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17e9dc: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17e9e0: 0xafa20030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 2));
    // 0x17e9e4: 0xfba20070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17e9e8: 0xc05de0e
    SET_GPR_U32(ctx, 31, 0x17e9f0);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_17e9f0
// Address: 0x17e9f0 - 0x17ea40

void entry_17e9f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17e9f0) {
        switch (ctx->pc) {
            case 0x17e9f4: ctx->pc = 0; goto label_17e9f4;
            case 0x17e9f8: ctx->pc = 0; goto label_17e9f8;
            case 0x17ea0c: ctx->pc = 0; goto label_17ea0c;
            case 0x17ea28: ctx->pc = 0; goto label_17ea28;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17e9f0: 0x8fa20014
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 20)));
label_17e9f4:
    // 0x17e9f4: 0x8fa30018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 24)));
label_17e9f8:
    // 0x17e9f8: 0x8c440000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17e9fc: 0x831821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 4), GPR_U32(ctx, 3)));
    // 0x17ea00: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17ea04: 0x1620ff92
    WRITE32(ADD32(GPR_U32(ctx, 29), 20), GPR_U32(ctx, 3));
    if (GPR_U32(ctx, 17) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17E850; return;
    }
label_17ea0c:
    // 0x17ea0c: 0x8fa20680
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 1664)));
    // 0x17ea10: 0x902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ea14: 0x1840008e
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 2) <= 0) {
        ctx->pc = 0x17EC50; return;
    }
    // 0x17ea1c: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17ea20: 0x24578d00
    SET_GPR_S32(ctx, 23, ADD32(GPR_U32(ctx, 2), 4294937856));
    // 0x17ea24: 0x8fa30684
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 1668)));
label_17ea28:
    // 0x17ea28: 0x121080
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 18), 2));
    // 0x17ea2c: 0x26550001
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 18), 1));
    // 0x17ea30: 0x431021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x17ea34: 0x8c510000
    SET_GPR_U32(ctx, 17, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17ea38: 0xc060bf2
    SET_GPR_U32(ctx, 31, 0x17ea40);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    FIsLoInWorld__FP2LO(rdram, ctx, runtime); return;
}


// Function: entry_17ea40
// Address: 0x17ea40 - 0x17eb18

void entry_17ea40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ea40) {
        switch (ctx->pc) {
            case 0x17eadc: ctx->pc = 0; goto label_17eadc;
            case 0x17eaec: ctx->pc = 0; goto label_17eaec;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ea40: 0x1040007e
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 1664)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17EC3C; return;
    }
    // 0x17ea48: 0xde220538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 17), 1336)));
    // 0x17ea4c: 0x34038000
    SET_GPR_U32(ctx, 3, OR32(GPR_U32(ctx, 0), 32768));
    // 0x17ea50: 0x31e78
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 3) << 25);
    // 0x17ea54: 0x431024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 3)));
    // 0x17ea58: 0x10400024
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17eaec;
    }
    // 0x17ea60: 0xda8206a0
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 1696)));
    // 0x17ea64: 0xda210140
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x17ea68: 0x4be2086c
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17ea6c: 0xc6c14028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 16424)); ctx->f[1] = *(float*)&val; }
    // 0x17ea70: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17ea74: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17ea78: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17ea7c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17ea80: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17ea84: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17ea88: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17ea8c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17ea90: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x17ea94: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17ea98: 0x0
    // NOP
    // 0x17ea9c: 0x4503000f
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
        goto label_17eadc;
    }
    // 0x17eaa4: 0xc6230148
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 328)); ctx->f[3] = *(float*)&val; }
    // 0x17eaa8: 0xc62203cc
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 972)); ctx->f[2] = *(float*)&val; }
    // 0x17eaac: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    // 0x17eab0: 0x46021800
    ctx->f[0] = FPU_ADD_S(ctx->f[3], ctx->f[2]);
    // 0x17eab4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17eab8: 0x0
    // NOP
    // 0x17eabc: 0x45030007
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
        goto label_17eadc;
    }
    // 0x17eac4: 0x46021841
    ctx->f[1] = FPU_SUB_S(ctx->f[3], ctx->f[2]);
    // 0x17eac8: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17eacc: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17ead0: 0x0
    // NOP
    // 0x17ead4: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
        goto label_17eadc;
    }
label_17eadc:
    // 0x17eadc: 0x14400056
    SET_GPR_S32(ctx, 21, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        entry_17ec38(rdram, ctx, runtime); return;
    }
    // 0x17eae4: 0x10000019
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17EB4C; return;
    }
label_17eaec:
    // 0x17eaec: 0x8e2603f8
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 17), 1016)));
    // 0x17eaf0: 0x10c00015
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 22), 16424)); ctx->f[12] = *(float*)&val; }
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17EB48; return;
    }
    // 0x17eaf8: 0x268406a0
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 20), 1696));
    // 0x17eafc: 0x8e2503f4
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 1012)));
    // 0x17eb00: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17eb04: 0x262803a4
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 17), 932));
    // 0x17eb08: 0x24090020
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 0), 32));
    // 0x17eb0c: 0x27aa0080
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 128));
    // 0x17eb10: 0xc061c98
    SET_GPR_U32(ctx, 31, 0x17eb18);
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    CsbiIntersectSphereBsp__FP6VECTORfiP3BSPT3P4GEOMiP3SBI(rdram, ctx, runtime); return;
}


// Function: entry_17eb18
// Address: 0x17eb18 - 0x17eb40

void entry_17eb18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17eb18) {
        switch (ctx->pc) {
            case 0x17eb20: ctx->pc = 0; goto label_17eb20;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17eb18: 0x40902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17eb1c: 0x27b30080
    SET_GPR_S32(ctx, 19, ADD32(GPR_U32(ctx, 29), 128));
label_17eb20:
    // 0x17eb20: 0x212102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 16), GPR_S32(ctx, 18)));
    // 0x17eb24: 0x10400044
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 48));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17ec38(rdram, ctx, runtime); return;
    }
    // 0x17eb2c: 0x3a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    // 0x17eb30: 0x2021818
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 2); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x17eb34: 0x731021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 19)));
    // 0x17eb38: 0xc07ac14
    SET_GPR_U32(ctx, 31, 0x17eb40);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[12] = *(float*)&val; }
    FCheckLm__FP2LMf(rdram, ctx, runtime); return;
}


// Function: entry_17eb40
// Address: 0x17eb40 - 0x17eb58

void entry_17eb40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17eb40) {
        switch (ctx->pc) {
            case 0x17eb48: ctx->pc = 0; goto label_17eb48;
            case 0x17eb4c: ctx->pc = 0; goto label_17eb4c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17eb40: 0x5040fff7
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 16), 1));
        ctx->pc = 0x17EB20; return;
    }
label_17eb48:
    // 0x17eb48: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_17eb4c:
    // 0x17eb4c: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x17eb50: 0xc07d703
    SET_GPR_U32(ctx, 31, 0x17eb58);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 64));
    memset(rdram, ctx, runtime); return;
}


// Function: entry_17eb58
// Address: 0x17eb58 - 0x17eb74

void entry_17eb58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17eb58: 0xafb40020
    WRITE32(ADD32(GPR_U32(ctx, 29), 32), GPR_U32(ctx, 20));
    // 0x17eb5c: 0xafb10024
    WRITE32(ADD32(GPR_U32(ctx, 29), 36), GPR_U32(ctx, 17));
    // 0x17eb60: 0x8e2503a8
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 17), 936)));
    // 0x17eb64: 0x18a00009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 5) <= 0) {
        ctx->pc = 0x17EB8C; return;
    }
    // 0x17eb6c: 0xc07aa9c
    SET_GPR_U32(ctx, 31, 0x17eb74);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 5), 4294967295));
    NRandInRange__Fii(rdram, ctx, runtime); return;
}


// Function: entry_17eb74
// Address: 0x17eb74 - 0x17ec38

void entry_17eb74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17eb74) {
        switch (ctx->pc) {
            case 0x17eb8c: ctx->pc = 0; goto label_17eb8c;
            case 0x17eb94: ctx->pc = 0; goto label_17eb94;
            case 0x17ebe8: ctx->pc = 0; goto label_17ebe8;
            case 0x17ebf4: ctx->pc = 0; goto label_17ebf4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17eb74: 0x8e2403ac
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 17), 940)));
    // 0x17eb78: 0x21100
    SET_GPR_U32(ctx, 2, SLL32(GPR_U32(ctx, 2), 4));
    // 0x17eb7c: 0x441021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 2), GPR_U32(ctx, 4)));
    // 0x17eb80: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17eb84: 0x10000003
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 3));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17eb94;
    }
label_17eb8c:
    // 0x17eb8c: 0x7a220140
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x17eb90: 0x7fa20040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 2));
label_17eb94:
    // 0x17eb94: 0xda220140
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 17), 320)));
    // 0x17eb98: 0xda8106a0
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 20), 1696)));
    // 0x17eb9c: 0x4be110ec
    { __m128 res = PS2_VSUB(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17eba0: 0x3c0138d1
    SET_GPR_U32(ctx, 1, ((uint32_t)14545 << 16));
    // 0x17eba4: 0x3421b717
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 46871));
    // 0x17eba8: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17ebac: 0x4bc318aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17ebb0: 0x4b000043
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17ebb4: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17ebb8: 0x4b02088a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17ebbc: 0x7ae20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 23), 0)));
    // 0x17ebc0: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17ebc4: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17ebc8: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17ebcc: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17ebd0: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x17ebd4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17ebd8: 0x45000003
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17ebe8;
    }
    // 0x17ebe0: 0x10000004
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17ebf4;
    }
label_17ebe8:
    // 0x17ebe8: 0x4a6103bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17ebec: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17ebf0: 0x4be0185c
    ctx->vu0_vf[3] = PS2_VMUL(ctx->vu0_vf[31], _mm_set1_ps(ctx->vu0_q));
label_17ebf4:
    // 0x17ebf4: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17ebf8: 0xc6800368
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 872)); ctx->f[0] = *(float*)&val; }
    // 0x17ebfc: 0xc4614034
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 16436)); ctx->f[1] = *(float*)&val; }
    // 0x17ec00: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17ec04: 0x8c424030
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 16432)));
    // 0x17ec08: 0x24030020
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 32));
    // 0x17ec0c: 0x46010002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[1]);
    // 0x17ec10: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17ec14: 0x4be20858
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17ec18: 0x27a40020
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 29), 32));
    // 0x17ec1c: 0xfba10050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17ec20: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ec24: 0xafa30030
    WRITE32(ADD32(GPR_U32(ctx, 29), 48), GPR_U32(ctx, 3));
    // 0x17ec28: 0x302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ec2c: 0xe7a00028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 40), *(uint32_t*)&val); }
    // 0x17ec30: 0xc05de0e
    SET_GPR_U32(ctx, 31, 0x17ec38);
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), _mm_castps_si128(ctx->vu0_vf[2]));
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime); return;
}


// Function: entry_17ec38
// Address: 0x17ec38 - 0x17ecac

void entry_17ec38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ec38) {
        switch (ctx->pc) {
            case 0x17ec3c: ctx->pc = 0; goto label_17ec3c;
            case 0x17ec50: ctx->pc = 0; goto label_17ec50;
            case 0x17ec78: ctx->pc = 0; goto label_17ec78;
            case 0x17eca4: ctx->pc = 0; goto label_17eca4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ec38: 0x8fa20680
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 1664)));
label_17ec3c:
    // 0x17ec3c: 0x2a0902d
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x17ec40: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17ec44: 0x242102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 2)));
    // 0x17ec48: 0x5440ff77
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 1668)));
        ctx->pc = 0x17EA28; return;
    }
label_17ec50:
    // 0x17ec50: 0x18600014
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_S32(ctx, 3) <= 0) {
        goto label_17eca4;
    }
    // 0x17ec58: 0x3c05bfff
    SET_GPR_U32(ctx, 5, ((uint32_t)49151 << 16));
    // 0x17ec5c: 0x34a5ffff
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 65535));
    // 0x17ec60: 0x52c38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 16);
    // 0x17ec64: 0x34a5ffff
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 65535));
    // 0x17ec68: 0x52c38
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 5) << 16);
    // 0x17ec6c: 0x34a5ffff
    SET_GPR_U32(ctx, 5, OR32(GPR_U32(ctx, 5), 65535));
    // 0x17ec70: 0x8fa20684
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 1668)));
    // 0x17ec74: 0x0
    // NOP
label_17ec78:
    // 0x17ec78: 0x121880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 18), 2));
    // 0x17ec7c: 0x26520001
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    // 0x17ec80: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x17ec84: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17ec88: 0xdc820538
    SET_GPR_U64(ctx, 2, READ64(ADD32(GPR_U32(ctx, 4), 1336)));
    // 0x17ec8c: 0x451024
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), GPR_U32(ctx, 5)));
    // 0x17ec90: 0xfc820538
    WRITE64(ADD32(GPR_U32(ctx, 4), 1336), GPR_U64(ctx, 2));
    // 0x17ec94: 0x8fa30680
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 1664)));
    // 0x17ec98: 0x243182a
    SET_GPR_U32(ctx, 3, SLT32(GPR_S32(ctx, 18), GPR_S32(ctx, 3)));
    // 0x17ec9c: 0x1460fff6
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 1668)));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_17ec78;
    }
label_17eca4:
    // 0x17eca4: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x17ecac);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_17ecac
// Address: 0x17ecac - 0x17ece8

void entry_17ecac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ecac) {
        switch (ctx->pc) {
            case 0x17ecb4: ctx->pc = 0; goto label_17ecb4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ecac: 0x8fa2001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 28)));
    // 0x17ecb0: 0xafc2b314
    WRITE32(ADD32(GPR_U32(ctx, 30), 4294947604), GPR_U32(ctx, 2));
label_17ecb4:
    // 0x17ecb4: 0x7bbf0720
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 1824)));
    // 0x17ecb8: 0x7bbe0710
    SET_GPR_VEC(ctx, 30, READ128(ADD32(GPR_U32(ctx, 29), 1808)));
    // 0x17ecbc: 0x7bb70700
    SET_GPR_VEC(ctx, 23, READ128(ADD32(GPR_U32(ctx, 29), 1792)));
    // 0x17ecc0: 0x7bb606f0
    SET_GPR_VEC(ctx, 22, READ128(ADD32(GPR_U32(ctx, 29), 1776)));
    // 0x17ecc4: 0x7bb506e0
    SET_GPR_VEC(ctx, 21, READ128(ADD32(GPR_U32(ctx, 29), 1760)));
    // 0x17ecc8: 0x7bb406d0
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 1744)));
    // 0x17eccc: 0x7bb306c0
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 1728)));
    // 0x17ecd0: 0x7bb206b0
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 1712)));
    // 0x17ecd4: 0x7bb106a0
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 1696)));
    // 0x17ecd8: 0x7bb00690
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 1680)));
    // 0x17ecdc: 0xc7b40730
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 1840)); ctx->f[20] = *(float*)&val; }
    // 0x17ece0: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 1856));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FUN_0017ece8
// Address: 0x17ece8 - 0x17edb8

void FUN_0017ece8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ece8) {
        switch (ctx->pc) {
            case 0x17ed54: ctx->pc = 0; goto label_17ed54;
            case 0x17ed5c: ctx->pc = 0; goto label_17ed5c;
            case 0x17ed78: ctx->pc = 0; goto label_17ed78;
            case 0x17ed80: ctx->pc = 0; goto label_17ed80;
            case 0x17ed9c: ctx->pc = 0; goto label_17ed9c;
            case 0x17eda8: ctx->pc = 0; goto label_17eda8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ece8: 0x27bdff70
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 4294967152));
    // 0x17ecec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17ecf0: 0x7fb20050
    WRITE128(ADD32(GPR_U32(ctx, 29), 80), GPR_VEC(ctx, 18));
    // 0x17ecf4: 0x7fb10040
    WRITE128(ADD32(GPR_U32(ctx, 29), 64), GPR_VEC(ctx, 17));
    // 0x17ecf8: 0x7fbf0080
    WRITE128(ADD32(GPR_U32(ctx, 29), 128), GPR_VEC(ctx, 31));
    // 0x17ecfc: 0x80882d
    SET_GPR_U64(ctx, 17, GPR_U64(ctx, 4) + GPR_U64(ctx, 0));
    // 0x17ed00: 0x7fb40070
    WRITE128(ADD32(GPR_U32(ctx, 29), 112), GPR_VEC(ctx, 20));
    // 0x17ed04: 0x7fb30060
    WRITE128(ADD32(GPR_U32(ctx, 29), 96), GPR_VEC(ctx, 19));
    // 0x17ed08: 0x7fb00030
    WRITE128(ADD32(GPR_U32(ctx, 29), 48), GPR_VEC(ctx, 16));
    // 0x17ed0c: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x17ed10: 0xc620222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8748)); ctx->f[0] = *(float*)&val; }
    // 0x17ed14: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17ed18: 0x44811000
    *(uint32_t*)&ctx->f[2] = GPR_U32(ctx, 1);
    // 0x17ed1c: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x17ed20: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17ed24: 0x0
    // NOP
    // 0x17ed28: 0x4501000a
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17ed54;
    }
    // 0x17ed30: 0xc6202238
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 8760)); ctx->f[0] = *(float*)&val; }
    // 0x17ed34: 0x46000801
    ctx->f[0] = FPU_SUB_S(ctx->f[1], ctx->f[0]);
    // 0x17ed38: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17ed3c: 0x0
    // NOP
    // 0x17ed40: 0x450100ac
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17EFF4; return;
    }
    // 0x17ed48: 0x8e220690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1680)));
    // 0x17ed4c: 0x10400003
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 17), 8760), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17ed5c;
    }
label_17ed54:
    // 0x17ed54: 0x100000a7
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17EFF4; return;
    }
label_17ed5c:
    // 0x17ed5c: 0x8e220480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1152)));
    // 0x17ed60: 0x10400011
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17eda8;
    }
    // 0x17ed68: 0x8c460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17ed6c: 0x10c0000e
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_17eda8;
    }
    // 0x17ed74: 0x8cc40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
label_17ed78:
    // 0x17ed78: 0x10800008
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        goto label_17ed9c;
    }
label_17ed80:
    // 0x17ed80: 0x8c8400d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 208)));
    // 0x17ed84: 0x0
    // NOP
    // 0x17ed88: 0x0
    // NOP
    // 0x17ed8c: 0x0
    // NOP
    // 0x17ed90: 0x0
    // NOP
    // 0x17ed94: 0x1480fffa
    SET_GPR_S32(ctx, 18, ADD32(GPR_U32(ctx, 18), 1));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_17ed80;
    }
label_17ed9c:
    // 0x17ed9c: 0x40302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17eda0: 0x54c0fff5
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
        goto label_17ed78;
    }
label_17eda8:
    // 0x17eda8: 0x12400092
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 18) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17EFF4; return;
    }
    // 0x17edb0: 0xc063582
    SET_GPR_U32(ctx, 31, 0x17edb8);
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 18), 2));
    InitStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_17edb8
// Address: 0x17edb8 - 0x17edec

void entry_17edb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17edb8: 0x3c01bf80
    SET_GPR_U32(ctx, 1, ((uint32_t)49024 << 16));
    // 0x17edbc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17edc0: 0x2522018
    { int64_t result = (int64_t)GPR_S32(ctx, 18) * (int64_t)GPR_S32(ctx, 18); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x17edc4: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17edc8: 0x44030000
    SET_GPR_U32(ctx, 3, *(uint32_t*)&ctx->f[0]);
    // 0x17edcc: 0x24428d20
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937888));
    // 0x17edd0: 0xd8410000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17edd4: 0x48a31000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x17edd8: 0x4be208d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17eddc: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17ede0: 0xfba30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), _mm_castps_si128(ctx->vu0_vf[3]));
    // 0x17ede4: 0xc063596
    SET_GPR_U32(ctx, 31, 0x17edec);
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 4), 2));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_17edec
// Address: 0x17edec - 0x17edf8

void entry_17edec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17edec: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17edf0: 0xc063596
    SET_GPR_U32(ctx, 31, 0x17edf8);
    SET_GPR_U64(ctx, 20, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_17edf8
// Address: 0x17edf8 - 0x17ee04

void entry_17edf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17edf8: 0x200202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17edfc: 0xc063596
    SET_GPR_U32(ctx, 31, 0x17ee04);
    SET_GPR_U64(ctx, 19, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    PvAllocStackImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_17ee04
// Address: 0x17ee04 - 0x17ef4c

void entry_17ee04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ee04) {
        switch (ctx->pc) {
            case 0x17ee20: ctx->pc = 0; goto label_17ee20;
            case 0x17ee30: ctx->pc = 0; goto label_17ee30;
            case 0x17ee44: ctx->pc = 0; goto label_17ee44;
            case 0x17ee58: ctx->pc = 0; goto label_17ee58;
            case 0x17ee68: ctx->pc = 0; goto label_17ee68;
            case 0x17ee80: ctx->pc = 0; goto label_17ee80;
            case 0x17eea8: ctx->pc = 0; goto label_17eea8;
            case 0x17eeb4: ctx->pc = 0; goto label_17eeb4;
            case 0x17eec0: ctx->pc = 0; goto label_17eec0;
            case 0x17eed0: ctx->pc = 0; goto label_17eed0;
            case 0x17eee0: ctx->pc = 0; goto label_17eee0;
            case 0x17eef0: ctx->pc = 0; goto label_17eef0;
            case 0x17ef08: ctx->pc = 0; goto label_17ef08;
            case 0x17ef30: ctx->pc = 0; goto label_17ef30;
            case 0x17ef38: ctx->pc = 0; goto label_17ef38;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ee04: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17ee08: 0x8e220480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1152)));
    // 0x17ee0c: 0x8c460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17ee10: 0x10c0002f
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_17eed0;
    }
    // 0x17ee18: 0x8cc40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x17ee1c: 0x0
    // NOP
label_17ee20:
    // 0x17ee20: 0x50800027
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 4)));
        goto label_17eec0;
    }
    // 0x17ee28: 0x3c09bf80
    SET_GPR_U32(ctx, 9, ((uint32_t)49024 << 16));
    // 0x17ee2c: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
label_17ee30:
    // 0x17ee30: 0x10510004
    ctx->vu0_vf[4] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 128)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        goto label_17ee44;
    }
    // 0x17ee38: 0x48a90800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 9));
    // 0x17ee3c: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17ee40: 0x4be12118
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); }
label_17ee44:
    // 0x17ee44: 0x8e220480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1152)));
    // 0x17ee48: 0x8c450000
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17ee4c: 0x50a00019
    if (GPR_U32(ctx, 5) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 208)));
        goto label_17eeb4;
    }
    // 0x17ee54: 0x8ca30000
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
label_17ee58:
    // 0x17ee58: 0x50600013
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 4)));
        goto label_17eea8;
    }
    // 0x17ee60: 0x3c08bf80
    SET_GPR_U32(ctx, 8, ((uint32_t)49024 << 16));
    // 0x17ee64: 0x4be3233c
    ctx->vu0_i = (float)ctx->vi[3];
label_17ee68:
    // 0x17ee68: 0x8c620000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17ee6c: 0x10510004
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 3), 128)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        goto label_17ee80;
    }
    // 0x17ee74: 0x48a80800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 8));
    // 0x17ee78: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17ee7c: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
label_17ee80:
    // 0x17ee80: 0x4bc2186a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
    // 0x17ee84: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17ee88: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17ee8c: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17ee90: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17ee94: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
    // 0x17ee98: 0x8c6300d0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 3), 208)));
    // 0x17ee9c: 0x1460fff2
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_17ee68;
    }
    // 0x17eea4: 0x8ca50004
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 5), 4)));
label_17eea8:
    // 0x17eea8: 0x54a0ffeb
    if (GPR_U32(ctx, 5) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 5), 0)));
        goto label_17ee58;
    }
    // 0x17eeb0: 0x8c8400d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 208)));
label_17eeb4:
    // 0x17eeb4: 0x5480ffde
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
        goto label_17ee30;
    }
    // 0x17eebc: 0x8cc60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 4)));
label_17eec0:
    // 0x17eec0: 0x54c0ffd7
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
        goto label_17ee20;
    }
    // 0x17eec8: 0x8e220480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1152)));
    // 0x17eecc: 0x8c460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
label_17eed0:
    // 0x17eed0: 0x10c00019
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_17ef38;
    }
    // 0x17eed8: 0x8cc40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
    // 0x17eedc: 0x0
    // NOP
label_17eee0:
    // 0x17eee0: 0x50800013
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 4)));
        goto label_17ef30;
    }
    // 0x17eee8: 0xdba30020
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17eeec: 0x3c03bf80
    SET_GPR_U32(ctx, 3, ((uint32_t)49024 << 16));
label_17eef0:
    // 0x17eef0: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17eef4: 0x10510004
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 128)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        goto label_17ef08;
    }
    // 0x17eefc: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x17ef00: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17ef04: 0x4be11098
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
label_17ef08:
    // 0x17ef08: 0x4bc3106a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[3]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17ef0c: 0x4b000083
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17ef10: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17ef14: 0x4b01104a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17ef18: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17ef1c: 0xace20000
    WRITE32(ADD32(GPR_U32(ctx, 7), 0), GPR_U32(ctx, 2));
    // 0x17ef20: 0x8c8400d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 208)));
    // 0x17ef24: 0x1480fff2
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        goto label_17eef0;
    }
    // 0x17ef2c: 0x8cc60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 4)));
label_17ef30:
    // 0x17ef30: 0x54c0ffeb
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
        goto label_17eee0;
    }
label_17ef38:
    // 0x17ef38: 0x260302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 19) + GPR_U64(ctx, 0));
    // 0x17ef3c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17ef40: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17ef44: 0xc055220
    SET_GPR_U32(ctx, 31, 0x17ef4c);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 20) + GPR_U64(ctx, 0));
    SolveInequalities__FiPfN21(rdram, ctx, runtime); return;
}


// Function: entry_17ef4c
// Address: 0x17ef4c - 0x17efd0

void entry_17ef4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ef4c) {
        switch (ctx->pc) {
            case 0x17ef68: ctx->pc = 0; goto label_17ef68;
            case 0x17ef78: ctx->pc = 0; goto label_17ef78;
            case 0x17ef8c: ctx->pc = 0; goto label_17ef8c;
            case 0x17efc0: ctx->pc = 0; goto label_17efc0;
            case 0x17efc8: ctx->pc = 0; goto label_17efc8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ef4c: 0x7ba30020
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17ef50: 0x7fa30000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), GPR_VEC(ctx, 3));
    // 0x17ef54: 0x8e220480
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 17), 1152)));
    // 0x17ef58: 0x8c460000
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17ef5c: 0x10c0001a
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 0)) {
        goto label_17efc8;
    }
    // 0x17ef64: 0x8cc40000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
label_17ef68:
    // 0x17ef68: 0x50800015
    if (GPR_U32(ctx, 4) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 4)));
        goto label_17efc0;
    }
    // 0x17ef70: 0x3c03bf80
    SET_GPR_U32(ctx, 3, ((uint32_t)49024 << 16));
    // 0x17ef74: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
label_17ef78:
    // 0x17ef78: 0x10510004
    ctx->vu0_vf[3] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 4), 128)));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 17)) {
        goto label_17ef8c;
    }
    // 0x17ef80: 0x48a30800
    ctx->vu0_vf[1] = _mm_castsi128_ps(GPR_VEC(ctx, 3));
    // 0x17ef84: 0xfba10010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17ef88: 0x4be118d8
    { __m128 res = PS2_VMUL(ctx->vu0_vf[31], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); }
label_17ef8c:
    // 0x17ef8c: 0xc4e00000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 7), 0)); ctx->f[0] = *(float*)&val; }
    // 0x17ef90: 0xdba10000
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17ef94: 0x24e70004
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 7), 4));
    // 0x17ef98: 0x44020000
    SET_GPR_U32(ctx, 2, *(uint32_t*)&ctx->f[0]);
    // 0x17ef9c: 0x48a21000
    ctx->vu0_vf[2] = _mm_castsi128_ps(GPR_VEC(ctx, 2));
    // 0x17efa0: 0x4be102bc
    ctx->vu0_i = (float)ctx->vi[1];
    // 0x17efa4: 0x4be21848
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[31], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(0,0,0,0))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, -1, -1, -1); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17efa8: 0xfba20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17efac: 0xfba10000
    WRITE128(ADD32(GPR_U32(ctx, 29), 0), _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17efb0: 0x8c8400d0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 4), 208)));
    // 0x17efb4: 0x5480fff0
    if (GPR_U32(ctx, 4) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
        goto label_17ef78;
    }
    // 0x17efbc: 0x8cc60004
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 6), 4)));
label_17efc0:
    // 0x17efc0: 0x54c0ffe9
    if (GPR_U32(ctx, 6) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 6), 0)));
        goto label_17ef68;
    }
label_17efc8:
    // 0x17efc8: 0xc0635bc
    SET_GPR_U32(ctx, 31, 0x17efd0);
    FreeStackImpl__Fv(rdram, ctx, runtime); return;
}


// Function: entry_17efd0
// Address: 0x17efd0 - 0x17f018

void entry_17efd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17efd0) {
        switch (ctx->pc) {
            case 0x17eff4: ctx->pc = 0; goto label_17eff4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17efd0: 0xc7a10008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 8)); ctx->f[1] = *(float*)&val; }
    // 0x17efd4: 0x3c01bdcc
    SET_GPR_U32(ctx, 1, ((uint32_t)48588 << 16));
    // 0x17efd8: 0x3421cccd
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 52429));
    // 0x17efdc: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17efe0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17efe4: 0x0
    // NOP
    // 0x17efe8: 0x45010002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17eff4;
    }
    // 0x17eff0: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_17eff4:
    // 0x17eff4: 0x7bbf0080
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 128)));
    // 0x17eff8: 0x7bb40070
    SET_GPR_VEC(ctx, 20, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    // 0x17effc: 0x7bb30060
    SET_GPR_VEC(ctx, 19, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17f000: 0x7bb20050
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x17f004: 0x7bb10040
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17f008: 0x7bb00030
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17f00c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17f014: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17f018; return;
}


// Function: UpdateJtJump__FP2JT
// Address: 0x17f018 - 0x17f084

void entry_17f084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f084: 0x10000022
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8816)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F110; return;
    }
    // 0x17f08c: 0x8e4423a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9120)));
    // 0x17f090: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f094: 0xc64c23a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9124)); ctx->f[12] = *(float*)&val; }
    // 0x17f098: 0xc05a788
    SET_GPR_U32(ctx, 31, 0x17f0a0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 18), 1592));
    GetHshapeHidePos__FP6HSHAPEfP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_17f0a0
// Address: 0x17f0a0 - 0x17f0ec

void entry_17f0a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f0a0) {
        switch (ctx->pc) {
            case 0x17f0a8: ctx->pc = 0; goto label_17f0a8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f0a0: 0x1000001b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8816)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F110; return;
    }
label_17f0a8:
    // 0x17f0a8: 0xda410150
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 18), 336)));
    // 0x17f0ac: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f0b0: 0x4b81086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[28], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17f0b4: 0x4b010841
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17f0b8: 0xc4413e54
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15956)); ctx->f[1] = *(float*)&val; }
    // 0x17f0bc: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17f0c0: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17f0c4: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17f0c8: 0x48220800
    SET_GPR_VEC(ctx, 2, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17f0cc: 0x44820000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 2);
    // 0x17f0d0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f0d4: 0x0
    // NOP
    // 0x17f0d8: 0x4502000d
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8816)));
        ctx->pc = 0x17F110; return;
    }
    // 0x17f0e0: 0xc64c0154
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 340)); ctx->f[12] = *(float*)&val; }
    // 0x17f0e4: 0xc0815de
    SET_GPR_U32(ctx, 31, 0x17f0ec);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 336)); ctx->f[13] = *(float*)&val; }
    atan2f(rdram, ctx, runtime); return;
}


// Function: entry_17f0ec
// Address: 0x17f0ec - 0x17f0fc

void entry_17f0ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f0ec) {
        switch (ctx->pc) {
            case 0x17f0f4: ctx->pc = 0; goto label_17f0f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f0ec: 0x10000007
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F10C; return;
    }
label_17f0f4:
    // 0x17f0f4: 0xc05c460
    SET_GPR_U32(ctx, 31, 0x17f0fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FTurnJtToTarget__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_17f0fc
// Address: 0x17f0fc - 0x17f204

void entry_17f0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f0fc) {
        switch (ctx->pc) {
            case 0x17f10c: ctx->pc = 0; goto label_17f10c;
            case 0x17f110: ctx->pc = 0; goto label_17f110;
            case 0x17f134: ctx->pc = 0; goto label_17f134;
            case 0x17f144: ctx->pc = 0; goto label_17f144;
            case 0x17f16c: ctx->pc = 0; goto label_17f16c;
            case 0x17f190: ctx->pc = 0; goto label_17f190;
            case 0x17f1e0: ctx->pc = 0; goto label_17f1e0;
            case 0x17f1ec: ctx->pc = 0; goto label_17f1ec;
            case 0x17f1f4: ctx->pc = 0; goto label_17f1f4;
            case 0x17f1f8: ctx->pc = 0; goto label_17f1f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f0fc: 0x54400004
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8816)));
        goto label_17f110;
    }
    // 0x17f104: 0xc6400630
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1584)); ctx->f[0] = *(float*)&val; }
    // 0x17f108: 0xe6400638
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 1592), *(uint32_t*)&val); }
label_17f10c:
    // 0x17f10c: 0x8e432270
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8816)));
label_17f110:
    // 0x17f110: 0x24040001
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17f114: 0x1064001e
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 4)) {
        goto label_17f190;
    }
    // 0x17f11c: 0x10400005
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17f134;
    }
    // 0x17f124: 0x50600007
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1588)); ctx->f[1] = *(float*)&val; }
        goto label_17f144;
    }
    // 0x17f12c: 0x10000032
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17f1f8;
    }
label_17f134:
    // 0x17f134: 0x5062002a
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1588)); ctx->f[1] = *(float*)&val; }
        goto label_17f1e0;
    }
    // 0x17f13c: 0x1000002e
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17f1f8;
    }
label_17f144:
    // 0x17f144: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17f148: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17f14c: 0x46000832
    ctx->fcr31 = (FPU_C_EQ_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f150: 0x0
    // NOP
    // 0x17f154: 0x45000005
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17f16c;
    }
    // 0x17f15c: 0xae442270
    WRITE32(ADD32(GPR_U32(ctx, 18), 8816), GPR_U32(ctx, 4));
    // 0x17f160: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17f164: 0x10000023
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 18), 8824), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17f1f4;
    }
label_17f16c:
    // 0x17f16c: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17f170: 0xc6422274
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8820)); ctx->f[2] = *(float*)&val; }
    // 0x17f174: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17f178: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f17c: 0xc4413e70
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15984)); ctx->f[1] = *(float*)&val; }
    // 0x17f180: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17f184: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f188: 0x10000018
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17f1ec;
    }
label_17f190:
    // 0x17f190: 0xc6410634
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 1588)); ctx->f[1] = *(float*)&val; }
    // 0x17f194: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17f198: 0x44810000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 1);
    // 0x17f19c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f1a0: 0x0
    // NOP
    // 0x17f1a4: 0x45000013
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 0), 2));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17f1f4;
    }
    // 0x17f1ac: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f1b0: 0xae432270
    WRITE32(ADD32(GPR_U32(ctx, 18), 8816), GPR_U32(ctx, 3));
    // 0x17f1b4: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x17f1b8: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17f1bc: 0xc6432278
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8824)); ctx->f[3] = *(float*)&val; }
    // 0x17f1c0: 0xc4410004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[1] = *(float*)&val; }
    // 0x17f1c4: 0xc4623e74
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 15988)); ctx->f[2] = *(float*)&val; }
    // 0x17f1c8: 0xe641227c
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 18), 8828), *(uint32_t*)&val); }
    // 0x17f1cc: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17f1d0: 0x46030001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[3]);
    // 0x17f1d4: 0x46020034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[2])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f1d8: 0x10000004
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17f1ec;
    }
label_17f1e0:
    // 0x17f1e0: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17f1e4: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f1e8: 0x0
    // NOP
label_17f1ec:
    // 0x17f1ec: 0x45030001
    if ((ctx->fcr31 & 0x800000)) {
        WRITE32(ADD32(GPR_U32(ctx, 18), 8808), GPR_U32(ctx, 4));
        goto label_17f1f4;
    }
label_17f1f4:
    // 0x17f1f4: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_17f1f8:
    // 0x17f1f8: 0x27a50030
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 29), 48));
    // 0x17f1fc: 0xc05f8f2
    SET_GPR_U32(ctx, 31, 0x17f204);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 29) + GPR_U64(ctx, 0));
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime); return;
}


// Function: entry_17f204
// Address: 0x17f204 - 0x17f23c

void entry_17f204(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f204: 0x40802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17f208: 0x1200001c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    if (GPR_U32(ctx, 16) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F27C; return;
    }
    // 0x17f210: 0x24060001
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17f214: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f218: 0x264724b0
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 18), 9392));
    // 0x17f21c: 0xc23023
    SET_GPR_U32(ctx, 6, SUB32(GPR_U32(ctx, 6), GPR_U32(ctx, 2)));
    // 0x17f220: 0x63180
    SET_GPR_U32(ctx, 6, SLL32(GPR_U32(ctx, 6), 6));
    // 0x17f224: 0x2063021
    SET_GPR_U32(ctx, 6, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 6)));
    // 0x17f228: 0x8cc20004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 6), 4)));
    // 0x17f22c: 0x24c60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 16));
    // 0x17f230: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17f234: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17f23c);
    WRITE32(ADD32(GPR_U32(ctx, 18), 9376), GPR_U32(ctx, 2));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17f23c
// Address: 0x17f23c - 0x17f274

void entry_17f23c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f23c) {
        switch (ctx->pc) {
            case 0x17f254: ctx->pc = 0; goto label_17f254;
            case 0x17f258: ctx->pc = 0; goto label_17f258;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f23c: 0x8e02009c
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 16), 156)));
    // 0x17f240: 0x8fa30030
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 29), 48)));
    // 0x17f244: 0x14600003
    WRITE32(ADD32(GPR_U32(ctx, 18), 9456), GPR_U32(ctx, 2));
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 0)) {
        goto label_17f254;
    }
    // 0x17f24c: 0x10000002
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 164)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17f258;
    }
label_17f254:
    // 0x17f254: 0x8e0600a0
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 160)));
label_17f258:
    // 0x17f258: 0x7ba20000
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17f25c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17f260: 0xae4624f4
    WRITE32(ADD32(GPR_U32(ctx, 18), 9460), GPR_U32(ctx, 6));
    // 0x17f264: 0x24050008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 8));
    // 0x17f268: 0x7e4224c0
    WRITE128(ADD32(GPR_U32(ctx, 18), 9408), GPR_VEC(ctx, 2));
    // 0x17f26c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17f274);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17f274
// Address: 0x17f274 - 0x17f284

void entry_17f274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f274) {
        switch (ctx->pc) {
            case 0x17f27c: ctx->pc = 0; goto label_17f27c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f274: 0x1000020b
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17FAA4; return;
    }
label_17f27c:
    // 0x17f27c: 0xc05fb3a
    SET_GPR_U32(ctx, 31, 0x17f284);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    FUN_0017ece8(rdram, ctx, runtime); return;
}


// Function: entry_17f284
// Address: 0x17f284 - 0x17f298

void entry_17f284(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f284: 0x10400006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F2A0; return;
    }
    // 0x17f28c: 0x44806000
    *(uint32_t*)&ctx->f[12] = GPR_U32(ctx, 0);
    // 0x17f290: 0xc05e166
    SET_GPR_U32(ctx, 31, 0x17f298);
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    FUN_00178598(rdram, ctx, runtime); return;
}


// Function: entry_17f298
// Address: 0x17f298 - 0x17f33c

void entry_17f298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f298) {
        switch (ctx->pc) {
            case 0x17f2a0: ctx->pc = 0; goto label_17f2a0;
            case 0x17f334: ctx->pc = 0; goto label_17f334;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f298: 0x10000202
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17FAA4; return;
    }
label_17f2a0:
    // 0x17f2a0: 0x8e432228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    // 0x17f2a4: 0x2c620010
    SET_GPR_U32(ctx, 2, SLTU32(GPR_U32(ctx, 3), 16));
    // 0x17f2a8: 0x104001b3
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F978; return;
    }
    // 0x17f2b0: 0x31880
    SET_GPR_U32(ctx, 3, SLL32(GPR_U32(ctx, 3), 2));
    // 0x17f2b4: 0x2442b110
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294947088));
    // 0x17f2b8: 0x621821
    SET_GPR_U32(ctx, 3, ADD32(GPR_U32(ctx, 3), GPR_U32(ctx, 2)));
    // 0x17f2bc: 0x8c640000
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x17f2c0: 0x800008
    ctx->pc = GPR_U32(ctx, 4); return;
    // 0x17f2c8: 0xc6410158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 344)); ctx->f[1] = *(float*)&val; }
    // 0x17f2cc: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17f2d0: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f2d4: 0x0
    // NOP
    // 0x17f2d8: 0x45010099
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17F540; return;
    }
    // 0x17f2e0: 0x3c030026
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    // 0x17f2e4: 0xc642222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x17f2e8: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17f2ec: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f2f0: 0xc4413e50
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 15952)); ctx->f[1] = *(float*)&val; }
    // 0x17f2f4: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17f2f8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f2fc: 0x0
    // NOP
    // 0x17f300: 0x4500019c
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_17f974(rdram, ctx, runtime); return;
    }
    // 0x17f308: 0x94622d18
    SET_GPR_U32(ctx, 2, (uint16_t)READ16(ADD32(GPR_U32(ctx, 3), 11544)));
    // 0x17f30c: 0x30420040
    SET_GPR_U32(ctx, 2, AND32(GPR_U32(ctx, 2), 64));
    // 0x17f310: 0x14400008
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        goto label_17f334;
    }
    // 0x17f318: 0x8e432270
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8816)));
    // 0x17f31c: 0x24020003
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 3));
    // 0x17f320: 0x10620004
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17f334;
    }
    // 0x17f328: 0xae422268
    WRITE32(ADD32(GPR_U32(ctx, 18), 8808), GPR_U32(ctx, 2));
    // 0x17f32c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17f330: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
label_17f334:
    // 0x17f334: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17f33c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 1));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17f33c
// Address: 0x17f33c - 0x17f410

void entry_17f33c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f33c) {
        switch (ctx->pc) {
            case 0x17f374: ctx->pc = 0; goto label_17f374;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f33c: 0x1000018e
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F978; return;
    }
    // 0x17f344: 0x8e420690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1680)));
    // 0x17f348: 0x1040000a
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        goto label_17f374;
    }
    // 0x17f350: 0xc6422224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8740)); ctx->f[2] = *(float*)&val; }
    // 0x17f354: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17f358: 0x3c013e19
    SET_GPR_U32(ctx, 1, ((uint32_t)15897 << 16));
    // 0x17f35c: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x17f360: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17f364: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17f368: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f36c: 0x45010043
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17F47C; return;
    }
label_17f374:
    // 0x17f374: 0xc6410158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 344)); ctx->f[1] = *(float*)&val; }
    // 0x17f378: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17f37c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f380: 0x0
    // NOP
    // 0x17f384: 0x4500017b
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_17f974(rdram, ctx, runtime); return;
    }
    // 0x17f38c: 0x1000006d
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F544; return;
    }
    // 0x17f394: 0x8e420690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1680)));
    // 0x17f398: 0x10400176
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17f974(rdram, ctx, runtime); return;
    }
    // 0x17f3a0: 0xc6422224
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8740)); ctx->f[2] = *(float*)&val; }
    // 0x17f3a4: 0x3c013e19
    SET_GPR_U32(ctx, 1, ((uint32_t)15897 << 16));
    // 0x17f3a8: 0x3421999a
    SET_GPR_U32(ctx, 1, OR32(GPR_U32(ctx, 1), 39322));
    // 0x17f3ac: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17f3b0: 0x1000002d
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F468; return;
    }
    // 0x17f3b8: 0x8e420690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1680)));
    // 0x17f3bc: 0x5040016e
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
        ctx->pc = 0x17F978; return;
    }
    // 0x17f3c4: 0x1000002d
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F47C; return;
    }
    // 0x17f3cc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f3d0: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f3d4: 0x24501858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x17f3d8: 0xc46c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[12] = *(float*)&val; }
    // 0x17f3dc: 0xc6000004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17f3e0: 0x46006034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f3e4: 0x0
    // NOP
    // 0x17f3e8: 0x450100a9
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17F690; return;
    }
    // 0x17f3f0: 0x46006301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x17f3f4: 0x8e4423b0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9136)));
    // 0x17f3f8: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f3fc: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17f400: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f404: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x17f408: 0xc0495d4
    SET_GPR_U32(ctx, 31, 0x17f410);
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    PredictAloTransform__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_17f410
// Address: 0x17f410 - 0x17f484

void entry_17f410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f410) {
        switch (ctx->pc) {
            case 0x17f468: ctx->pc = 0; goto label_17f468;
            case 0x17f47c: ctx->pc = 0; goto label_17f47c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f410: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f414: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17f418: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x17f41c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17f420: 0x7c820020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 2));
    // 0x17f424: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f428: 0xc4600028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 40)); ctx->f[0] = *(float*)&val; }
    // 0x17f42c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17f430: 0xe4600028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 40), *(uint32_t*)&val); }
    // 0x17f434: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f438: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17f43c: 0x7c820030
    WRITE128(ADD32(GPR_U32(ctx, 4), 48), GPR_VEC(ctx, 2));
    // 0x17f440: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f444: 0x10000116
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[2] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F8A0; return;
    }
    // 0x17f44c: 0x8e420690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1680)));
    // 0x17f450: 0x10400148
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17f974(rdram, ctx, runtime); return;
    }
    // 0x17f458: 0xc642222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x17f45c: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17f460: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f464: 0xc4414040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16448)); ctx->f[1] = *(float*)&val; }
label_17f468:
    // 0x17f468: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17f46c: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f470: 0x0
    // NOP
    // 0x17f474: 0x45020140
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
        ctx->pc = 0x17F978; return;
    }
label_17f47c:
    // 0x17f47c: 0xc05f9b4
    SET_GPR_U32(ctx, 31, 0x17f484);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    JtsResetJt__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_17f484
// Address: 0x17f484 - 0x17f494

void entry_17f484(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f484: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17f488: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17f48c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17f494);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17f494
// Address: 0x17f494 - 0x17f4d8

void entry_17f494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f494: 0x10000138
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F978; return;
    }
    // 0x17f49c: 0x8e420690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1680)));
    // 0x17f4a0: 0x10400134
    SET_GPR_U32(ctx, 3, ((uint32_t)38 << 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17f974(rdram, ctx, runtime); return;
    }
    // 0x17f4a8: 0xc642222c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 8748)); ctx->f[2] = *(float*)&val; }
    // 0x17f4ac: 0xc460185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17f4b0: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f4b4: 0xc4414044
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16452)); ctx->f[1] = *(float*)&val; }
    // 0x17f4b8: 0x46020001
    ctx->f[0] = FPU_SUB_S(ctx->f[0], ctx->f[2]);
    // 0x17f4bc: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f4c0: 0x0
    // NOP
    // 0x17f4c4: 0x4502012c
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
        ctx->pc = 0x17F978; return;
    }
    // 0x17f4cc: 0x8e4425c8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9672)));
    // 0x17f4d0: 0xc04b330
    SET_GPR_U32(ctx, 31, 0x17f4d8);
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 443));
    TFindAsegLabel__FP4ASEG3OID(rdram, ctx, runtime); return;
}


// Function: entry_17f4d8
// Address: 0x17f4d8 - 0x17f4fc

void entry_17f4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f4d8: 0x8e422230
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x17f4dc: 0x46000506
    ctx->f[20] = FPU_MOV_S(ctx->f[0]);
    // 0x17f4e0: 0xc4400014
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 20)); ctx->f[0] = *(float*)&val; }
    // 0x17f4e4: 0x46140034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[20])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f4e8: 0x0
    // NOP
    // 0x17f4ec: 0x45020122
    if (!(ctx->fcr31 & 0x800000)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
        ctx->pc = 0x17F978; return;
    }
    // 0x17f4f4: 0xc05f9c4
    SET_GPR_U32(ctx, 31, 0x17f4fc);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    HandleJtDiveEffect__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_17f4fc
// Address: 0x17f4fc - 0x17f510

void entry_17f4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f4fc: 0x8e442230
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 8752)));
    // 0x17f500: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x17f504: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f508: 0xc04bc28
    SET_GPR_U32(ctx, 31, 0x17f510);
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[13] = *(float*)&val; }
    SeekAsega__FP5ASEGA4SEEKff(rdram, ctx, runtime); return;
}


// Function: entry_17f510
// Address: 0x17f510 - 0x17f54c

void entry_17f510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f510) {
        switch (ctx->pc) {
            case 0x17f540: ctx->pc = 0; goto label_17f540;
            case 0x17f544: ctx->pc = 0; goto label_17f544;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f510: 0x10000119
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F978; return;
    }
    // 0x17f518: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f51c: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f520: 0x24501858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x17f524: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x17f528: 0xc4800018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[0] = *(float*)&val; }
    // 0x17f52c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f530: 0x0
    // NOP
    // 0x17f534: 0x45000007
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17F554; return;
    }
    // 0x17f53c: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
label_17f540:
    // 0x17f540: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
label_17f544:
    // 0x17f544: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17f54c);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17f54c
// Address: 0x17f54c - 0x17f590

void entry_17f54c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f54c) {
        switch (ctx->pc) {
            case 0x17f554: ctx->pc = 0; goto label_17f554;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f54c: 0x1000010a
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F978; return;
    }
label_17f554:
    // 0x17f554: 0x8e4a23b4
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 18), 9140)));
    // 0x17f558: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x17f55c: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f560: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17f564: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17f568: 0x79420040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 10), 64)));
    // 0x17f56c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f570: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x17f574: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x17f578: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x17f57c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f580: 0xc48c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[12] = *(float*)&val; }
    // 0x17f584: 0x8d440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 10), 24)));
    // 0x17f588: 0xc049676
    SET_GPR_U32(ctx, 31, 0x17f590);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_17f590
// Address: 0x17f590 - 0x17f630

void entry_17f590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f590: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f594: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17f598: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x17f59c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17f5a0: 0x7c820020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 2));
    // 0x17f5a4: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f5a8: 0xc4600028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 40)); ctx->f[0] = *(float*)&val; }
    // 0x17f5ac: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17f5b0: 0xe4600028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 40), *(uint32_t*)&val); }
    // 0x17f5b4: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f5b8: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17f5bc: 0x7c820030
    WRITE128(ADD32(GPR_U32(ctx, 4), 48), GPR_VEC(ctx, 2));
    // 0x17f5c0: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f5c4: 0x100000b6
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[2] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F8A0; return;
    }
    // 0x17f5cc: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f5d0: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f5d4: 0x24501858
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x17f5d8: 0xc6010004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[1] = *(float*)&val; }
    // 0x17f5dc: 0xc4800018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[0] = *(float*)&val; }
    // 0x17f5e0: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f5e4: 0x0
    // NOP
    // 0x17f5e8: 0x45010029
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 5));
    if ((ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17F690; return;
    }
    // 0x17f5f0: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17f5f4: 0x8e4a23b8
    SET_GPR_U32(ctx, 10, READ32(ADD32(GPR_U32(ctx, 18), 9144)));
    // 0x17f5f8: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x17f5fc: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f600: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17f604: 0x27a60010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17f608: 0x79420040
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 10), 64)));
    // 0x17f60c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f610: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x17f614: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x17f618: 0x7fa20010
    WRITE128(ADD32(GPR_U32(ctx, 29), 16), GPR_VEC(ctx, 2));
    // 0x17f61c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f620: 0xc48c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[12] = *(float*)&val; }
    // 0x17f624: 0x8d440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 10), 24)));
    // 0x17f628: 0xc049676
    SET_GPR_U32(ctx, 31, 0x17f630);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[1]);
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_17f630
// Address: 0x17f630 - 0x17f6a4

void entry_17f630(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f630) {
        switch (ctx->pc) {
            case 0x17f690: ctx->pc = 0; goto label_17f690;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f630: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f634: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17f638: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x17f63c: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17f640: 0x7c820020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 2));
    // 0x17f644: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f648: 0xc4600028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 40)); ctx->f[0] = *(float*)&val; }
    // 0x17f64c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17f650: 0xe4600028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 40), *(uint32_t*)&val); }
    // 0x17f654: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f658: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17f65c: 0x7c820030
    WRITE128(ADD32(GPR_U32(ctx, 4), 48), GPR_VEC(ctx, 2));
    // 0x17f660: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f664: 0x1000008e
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 16), 4)); ctx->f[2] = *(float*)&val; }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F8A0; return;
    }
    // 0x17f66c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f670: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f674: 0x24511858
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x17f678: 0xc4610018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[1] = *(float*)&val; }
    // 0x17f67c: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17f680: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f684: 0x0
    // NOP
    // 0x17f688: 0x45000008
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17F6AC; return;
    }
label_17f690:
    // 0x17f690: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17f694: 0xae42239c
    WRITE32(ADD32(GPR_U32(ctx, 18), 9116), GPR_U32(ctx, 2));
    // 0x17f698: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x17f69c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17f6a4);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17f6a4
// Address: 0x17f6a4 - 0x17f6d4

void entry_17f6a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f6a4) {
        switch (ctx->pc) {
            case 0x17f6ac: ctx->pc = 0; goto label_17f6ac;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f6a4: 0x100000b4
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F978; return;
    }
label_17f6ac:
    // 0x17f6ac: 0x8e4323bc
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9148)));
    // 0x17f6b0: 0x8c640034
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 3), 52)));
    // 0x17f6b4: 0x8c820000
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 4), 0)));
    // 0x17f6b8: 0x8c420004
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 2), 4)));
    // 0x17f6bc: 0x10400005
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17f6d4(rdram, ctx, runtime); return;
    }
    // 0x17f6c4: 0xc64c23c0
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9152)); ctx->f[12] = *(float*)&val; }
    // 0x17f6c8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17f6cc: 0x40f809
    SET_GPR_U32(ctx, 31, 0x17f6d4);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    ctx->pc = GPR_U32(ctx, 2); return;
}


// Function: entry_17f6d4
// Address: 0x17f6d4 - 0x17f704

void entry_17f6d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f6d4: 0x8e422514
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f6d8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17f6dc: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17f6e0: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f6e4: 0xc44c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 24)); ctx->f[12] = *(float*)&val; }
    // 0x17f6e8: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f6ec: 0x8e4223bc
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9148)));
    // 0x17f6f0: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f6f4: 0x46006301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x17f6f8: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f6fc: 0xc049676
    SET_GPR_U32(ctx, 31, 0x17f704);
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_17f704
// Address: 0x17f704 - 0x17f77c

void entry_17f704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f704) {
        switch (ctx->pc) {
            case 0x17f764: ctx->pc = 0; goto label_17f764;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f704: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f708: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17f70c: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x17f710: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17f714: 0x7c820020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 2));
    // 0x17f718: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f71c: 0xc4600028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 40)); ctx->f[0] = *(float*)&val; }
    // 0x17f720: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17f724: 0x10000093
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 40), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17f974(rdram, ctx, runtime); return;
    }
    // 0x17f72c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f730: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f734: 0x24511858
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x17f738: 0xc4610018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[1] = *(float*)&val; }
    // 0x17f73c: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17f740: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f744: 0x0
    // NOP
    // 0x17f748: 0x45000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        goto label_17f764;
    }
    // 0x17f750: 0x8e4323a8
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9128)));
    // 0x17f754: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x17f758: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x17f75c: 0x10000022
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 88)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F7E8; return;
    }
label_17f764:
    // 0x17f764: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17f768: 0xc64c23ac
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9132)); ctx->f[12] = *(float*)&val; }
    // 0x17f76c: 0x8e4423a8
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9128)));
    // 0x17f770: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17f774: 0xc05a890
    SET_GPR_U32(ctx, 31, 0x17f77c);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetHpntClosestHidePos__FP4HPNTP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_17f77c
// Address: 0x17f77c - 0x17f794

void entry_17f77c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f77c: 0x8e4223a8
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9128)));
    // 0x17f780: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f784: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17f788: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17f78c: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17f794);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17f794
// Address: 0x17f794 - 0x17f7f0

void entry_17f794(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f794) {
        switch (ctx->pc) {
            case 0x17f7e8: ctx->pc = 0; goto label_17f7e8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f794: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17f798: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f79c: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x17f7a0: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17f7a4: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17f7a8: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17f7ac: 0x10000025
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9128)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F844; return;
    }
    // 0x17f7b4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f7b8: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f7bc: 0x24511858
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x17f7c0: 0xc4610018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[1] = *(float*)&val; }
    // 0x17f7c4: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17f7c8: 0x46000834
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f7cc: 0x0
    // NOP
    // 0x17f7d0: 0x45000009
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17F7F8; return;
    }
    // 0x17f7d8: 0x8e4323a0
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9120)));
    // 0x17f7dc: 0x24050006
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 6));
    // 0x17f7e0: 0x24060010
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 16));
    // 0x17f7e4: 0x8c620040
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 3), 64)));
label_17f7e8:
    // 0x17f7e8: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17f7f0);
    WRITE32(ADD32(GPR_U32(ctx, 18), 9116), GPR_U32(ctx, 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17f7f0
// Address: 0x17f7f0 - 0x17f810

void entry_17f7f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f7f0) {
        switch (ctx->pc) {
            case 0x17f7f8: ctx->pc = 0; goto label_17f7f8;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f7f0: 0x10000061
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F978; return;
    }
label_17f7f8:
    // 0x17f7f8: 0x27b00010
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17f7fc: 0xc64c23a4
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 9124)); ctx->f[12] = *(float*)&val; }
    // 0x17f800: 0x8e4423a0
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9120)));
    // 0x17f804: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17f808: 0xc05a788
    SET_GPR_U32(ctx, 31, 0x17f810);
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    GetHshapeHidePos__FP6HSHAPEfP6VECTORPf(rdram, ctx, runtime); return;
}


// Function: entry_17f810
// Address: 0x17f810 - 0x17f828

void entry_17f810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f810: 0x8e4223a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9120)));
    // 0x17f814: 0x202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f818: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17f81c: 0x200382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17f820: 0xc04a006
    SET_GPR_U32(ctx, 31, 0x17f828);
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    ConvertAloPos__FP3ALOT0P6VECTORT2(rdram, ctx, runtime); return;
}


// Function: entry_17f828
// Address: 0x17f828 - 0x17f868

void entry_17f828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f828) {
        switch (ctx->pc) {
            case 0x17f844: ctx->pc = 0; goto label_17f844;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f828: 0x3c020025
    SET_GPR_U32(ctx, 2, ((uint32_t)37 << 16));
    // 0x17f82c: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f830: 0x24428d30
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 4294937904));
    // 0x17f834: 0xc6200004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17f838: 0x78430000
    SET_GPR_VEC(ctx, 3, READ128(ADD32(GPR_U32(ctx, 2), 0)));
    // 0x17f83c: 0x200302d
    SET_GPR_U64(ctx, 6, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17f840: 0x8e4223a0
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 9120)));
label_17f844:
    // 0x17f844: 0x282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f848: 0x7fa30020
    WRITE128(ADD32(GPR_U32(ctx, 29), 32), GPR_VEC(ctx, 3));
    // 0x17f84c: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f850: 0x27a80020
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 29), 32));
    // 0x17f854: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f858: 0xc48c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 4), 24)); ctx->f[12] = *(float*)&val; }
    // 0x17f85c: 0x8c440018
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 2), 24)));
    // 0x17f860: 0xc049676
    SET_GPR_U32(ctx, 31, 0x17f868);
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    PredictAloTransformAdjust__FP3ALOT0fP6VECTORP7MATRIX3T3T3(rdram, ctx, runtime); return;
}


// Function: entry_17f868
// Address: 0x17f868 - 0x17f8ec

void entry_17f868(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f868) {
        switch (ctx->pc) {
            case 0x17f8a0: ctx->pc = 0; goto label_17f8a0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f868: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f86c: 0x7ba20010
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17f870: 0x3c014296
    SET_GPR_U32(ctx, 1, ((uint32_t)17046 << 16));
    // 0x17f874: 0x44810800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 1);
    // 0x17f878: 0x7c820020
    WRITE128(ADD32(GPR_U32(ctx, 4), 32), GPR_VEC(ctx, 2));
    // 0x17f87c: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f880: 0xc4600028
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 40)); ctx->f[0] = *(float*)&val; }
    // 0x17f884: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17f888: 0xe4600028
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 40), *(uint32_t*)&val); }
    // 0x17f88c: 0x8e442514
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f890: 0x7ba20020
    SET_GPR_VEC(ctx, 2, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17f894: 0x7c820030
    WRITE128(ADD32(GPR_U32(ctx, 4), 48), GPR_VEC(ctx, 2));
    // 0x17f898: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f89c: 0xc6220004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 17), 4)); ctx->f[2] = *(float*)&val; }
label_17f8a0:
    // 0x17f8a0: 0xc4610018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[1] = *(float*)&val; }
    // 0x17f8a4: 0xc6430358
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 856)); ctx->f[3] = *(float*)&val; }
    // 0x17f8a8: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x17f8ac: 0xc6400158
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 18), 344)); ctx->f[0] = *(float*)&val; }
    // 0x17f8b0: 0x46030842
    ctx->f[1] = FPU_MUL_S(ctx->f[1], ctx->f[3]);
    // 0x17f8b4: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17f8b8: 0x1000002e
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 3), 56), *(uint32_t*)&val); }
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        entry_17f974(rdram, ctx, runtime); return;
    }
    // 0x17f8c0: 0x8e482514
    SET_GPR_U32(ctx, 8, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f8c4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f8c8: 0xc440185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[0] = *(float*)&val; }
    // 0x17f8cc: 0xc50c0018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 8), 24)); ctx->f[12] = *(float*)&val; }
    // 0x17f8d0: 0x46006034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[12], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f8d4: 0x0
    // NOP
    // 0x17f8d8: 0x45000006
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        ctx->pc = 0x17F8F4; return;
    }
    // 0x17f8e0: 0x24050003
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 3));
    // 0x17f8e4: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17f8ec);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 51));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17f8ec
// Address: 0x17f8ec - 0x17f914

void entry_17f8ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f8ec) {
        switch (ctx->pc) {
            case 0x17f8f4: ctx->pc = 0; goto label_17f8f4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f8ec: 0x10000022
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F978; return;
    }
label_17f8f4:
    // 0x17f8f4: 0x8e462204
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 8708)));
    // 0x17f8f8: 0x46006301
    ctx->f[12] = FPU_SUB_S(ctx->f[12], ctx->f[0]);
    // 0x17f8fc: 0x25090030
    SET_GPR_S32(ctx, 9, ADD32(GPR_U32(ctx, 8), 48));
    // 0x17f900: 0x8cc50018
    SET_GPR_U32(ctx, 5, READ32(ADD32(GPR_U32(ctx, 6), 24)));
    // 0x17f904: 0x382d
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f908: 0x24c60040
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 64));
    // 0x17f90c: 0xc073ac6
    SET_GPR_U32(ctx, 31, 0x17f914);
    SET_GPR_S32(ctx, 8, ADD32(GPR_U32(ctx, 8), 32));
    FUN_001ceb18(rdram, ctx, runtime); return;
}


// Function: entry_17f914
// Address: 0x17f914 - 0x17f948

void entry_17f914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f914: 0x10000018
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F978; return;
    }
    // 0x17f91c: 0x8e432514
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f920: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f924: 0xc441185c
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 6236)); ctx->f[1] = *(float*)&val; }
    // 0x17f928: 0xc4600018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 3), 24)); ctx->f[0] = *(float*)&val; }
    // 0x17f92c: 0x46010034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[0], ctx->f[1])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17f930: 0x0
    // NOP
    // 0x17f934: 0x4500000f
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_17f974(rdram, ctx, runtime); return;
    }
    // 0x17f93c: 0x24050007
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 7));
    // 0x17f940: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17f948);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 23));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17f948
// Address: 0x17f948 - 0x17f964

void entry_17f948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f948: 0x1000000b
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        ctx->pc = 0x17F978; return;
    }
    // 0x17f950: 0x8e420690
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 18), 1680)));
    // 0x17f954: 0x50400008
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
        ctx->pc = 0x17F978; return;
    }
    // 0x17f95c: 0xc05f9b4
    SET_GPR_U32(ctx, 31, 0x17f964);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    JtsResetJt__FP2JT(rdram, ctx, runtime); return;
}


// Function: entry_17f964
// Address: 0x17f964 - 0x17f974

void entry_17f964(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f964: 0x40282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17f968: 0x240202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    // 0x17f96c: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17f974);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 4294967295));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17f974
// Address: 0x17f974 - 0x17f9e8

void entry_17f974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17f974) {
        switch (ctx->pc) {
            case 0x17f978: ctx->pc = 0; goto label_17f978;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17f974: 0x8e432228
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 18), 8744)));
label_17f978:
    // 0x17f978: 0x28620010
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 16));
    // 0x17f97c: 0x10400048
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 9));
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        entry_17faa0(rdram, ctx, runtime); return;
    }
    // 0x17f984: 0x14400047
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        ctx->pc = 0x17FAA4; return;
    }
    // 0x17f98c: 0x8e462514
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f990: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17f994: 0x24421858
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 6232));
    // 0x17f998: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17f99c: 0x4481a800
    *(uint32_t*)&ctx->f[21] = GPR_U32(ctx, 1);
    // 0x17f9a0: 0xc4400004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17f9a4: 0x24c70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 48));
    // 0x17f9a8: 0xc4d40018
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 6), 24)); ctx->f[20] = *(float*)&val; }
    // 0x17f9ac: 0x26510100
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 18), 256));
    // 0x17f9b0: 0xc4410008
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 8)); ctx->f[1] = *(float*)&val; }
    // 0x17f9b4: 0x26500150
    SET_GPR_S32(ctx, 16, ADD32(GPR_U32(ctx, 18), 336));
    // 0x17f9b8: 0x4600a501
    ctx->f[20] = FPU_SUB_S(ctx->f[20], ctx->f[0]);
    // 0x17f9bc: 0x27aa0010
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 16));
    // 0x17f9c0: 0x44806800
    *(uint32_t*)&ctx->f[13] = GPR_U32(ctx, 0);
    // 0x17f9c4: 0x24c60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 32));
    // 0x17f9c8: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x17f9cc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17f9d0: 0x4601a500
    ctx->f[20] = FPU_ADD_S(ctx->f[20], ctx->f[1]);
    // 0x17f9d4: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17f9d8: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f9dc: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17f9e0: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x17f9e8);
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_17f9e8
// Address: 0x17f9e8 - 0x17fa18

void entry_17f9e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17f9e8: 0x8e462514
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 18), 9492)));
    // 0x17f9ec: 0x4600a306
    ctx->f[12] = FPU_MOV_S(ctx->f[20]);
    // 0x17f9f0: 0x4600a346
    ctx->f[13] = FPU_MOV_S(ctx->f[20]);
    // 0x17f9f4: 0x4600ab86
    ctx->f[14] = FPU_MOV_S(ctx->f[21]);
    // 0x17f9f8: 0x24c70030
    SET_GPR_S32(ctx, 7, ADD32(GPR_U32(ctx, 6), 48));
    // 0x17f9fc: 0x220202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x17fa00: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17fa04: 0x24c60020
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 6), 32));
    // 0x17fa08: 0x402d
    SET_GPR_U64(ctx, 8, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17fa0c: 0x482d
    SET_GPR_U64(ctx, 9, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17fa10: 0xc04c150
    SET_GPR_U32(ctx, 31, 0x17fa18);
    SET_GPR_S32(ctx, 10, ADD32(GPR_U32(ctx, 29), 32));
    EvaluateBezierPos__FfffP6VECTORN63(rdram, ctx, runtime); return;
}


// Function: entry_17fa18
// Address: 0x17fa18 - 0x17faa0

void entry_17fa18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17fa18: 0xdba20010
    ctx->vu0_vf[2] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17fa1c: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17fa20: 0x4bc210aa
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[2]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17fa24: 0x4b0000c3
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17fa28: 0x4b02103d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17fa2c: 0x4b02188a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[2], ctx->vu0_vf[2], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[3] = _mm_blendv_ps(ctx->vu0_vf[3], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17fa30: 0xdba10020
    ctx->vu0_vf[1] = _mm_castsi128_ps(READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17fa34: 0x4a0203bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[2] = _mm_blendv_ps(ctx->vu0_vf[2], res, _mm_castsi128_ps(mask)); }
    // 0x17fa38: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17fa3c: 0x4b0000a0
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17fa40: 0x4bc1086a
    { __m128 res = PS2_VMUL(ctx->vu0_vf[30], ctx->vu0_vf[1]); __m128i mask = _mm_set_epi32(-1, -1, -1, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17fa44: 0x4b000103
    { __m128 res = PS2_VADD(ctx->vu0_vf[24], ctx->vu0_vf[0]); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[0] = _mm_blendv_ps(ctx->vu0_vf[0], res, _mm_castsi128_ps(mask)); }
    // 0x17fa48: 0x4b01083d
    { float val = (float)ctx->vi[24]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17fa4c: 0x4b01204a
    { __m128 mul_res = PS2_VMUL(ctx->vu0_vf[24], _mm_shuffle_ps(ctx->vu0_vf[1], ctx->vu0_vf[1], _MM_SHUFFLE(2,2,2,2))); __m128 res = PS2_VADD(ctx->vu0_acc, mul_res); __m128i mask = _mm_set_epi32(-1, 0, 0, 0); ctx->vu0_vf[4] = _mm_blendv_ps(ctx->vu0_vf[4], res, _mm_castsi128_ps(mask)); ctx->vu0_acc = res; }
    // 0x17fa50: 0x48231000
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[2]));
    // 0x17fa54: 0x4a0103bd
    { float val = (float)ctx->vi[16]; __m128 res = _mm_set1_ps(val); __m128i mask = _mm_set_epi32(0, 0, 0, 0); ctx->vu0_vf[1] = _mm_blendv_ps(ctx->vu0_vf[1], res, _mm_castsi128_ps(mask)); }
    // 0x17fa58: 0x4a0003bf
    { uint32_t addr = (uint32_t)(_mm_cvtss_f32(_mm_shuffle_ps(ctx->vu0_vf[16], ctx->vu0_vf[16], _MM_SHUFFLE(0,0,0,0))) + ctx->vu0_i) & 0x3FFC; WRITE32(addr, ctx->vi[0]); }
    // 0x17fa5c: 0x4b000060
    ctx->vu0_vf[0] = PS2_VADD(ctx->vu0_vf[24], _mm_set1_ps(ctx->vu0_q));
    // 0x17fa60: 0x44830000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 3);
    // 0x17fa64: 0x3c013f00
    SET_GPR_U32(ctx, 1, ((uint32_t)16128 << 16));
    // 0x17fa68: 0x44811800
    *(uint32_t*)&ctx->f[3] = GPR_U32(ctx, 1);
    // 0x17fa6c: 0x48230800
    SET_GPR_VEC(ctx, 3, _mm_castps_si128(ctx->vu0_vf[1]));
    // 0x17fa70: 0xc4424048
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 2), 16456)); ctx->f[2] = *(float*)&val; }
    // 0x17fa74: 0x44830800
    *(uint32_t*)&ctx->f[1] = GPR_U32(ctx, 3);
    // 0x17fa78: 0x4603a502
    ctx->f[20] = FPU_MUL_S(ctx->f[20], ctx->f[3]);
    // 0x17fa7c: 0x46010000
    ctx->f[0] = FPU_ADD_S(ctx->f[0], ctx->f[1]);
    // 0x17fa80: 0x46140002
    ctx->f[0] = FPU_MUL_S(ctx->f[0], ctx->f[20]);
    // 0x17fa84: 0x46001034
    ctx->fcr31 = (FPU_C_OLT_S(ctx->f[2], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17fa88: 0x0
    // NOP
    // 0x17fa8c: 0x45000004
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 18) + GPR_U64(ctx, 0));
    if (!(ctx->fcr31 & 0x800000)) {
        entry_17faa0(rdram, ctx, runtime); return;
    }
    // 0x17fa94: 0x24050002
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 2));
    // 0x17fa98: 0xc05d45c
    SET_GPR_U32(ctx, 31, 0x17faa0);
    SET_GPR_S32(ctx, 6, ADD32(GPR_U32(ctx, 0), 2));
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime); return;
}


// Function: entry_17faa0
// Address: 0x17faa0 - 0x17fac0

void entry_17faa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17faa0) {
        switch (ctx->pc) {
            case 0x17faa4: ctx->pc = 0; goto label_17faa4;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17faa0: 0x7bbf0070
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 112)));
label_17faa4:
    // 0x17faa4: 0x7bb20060
    SET_GPR_VEC(ctx, 18, READ128(ADD32(GPR_U32(ctx, 29), 96)));
    // 0x17faa8: 0x7bb10050
    SET_GPR_VEC(ctx, 17, READ128(ADD32(GPR_U32(ctx, 29), 80)));
    // 0x17faac: 0x7bb00040
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 64)));
    // 0x17fab0: 0xc7b50088
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 136)); ctx->f[21] = *(float*)&val; }
    // 0x17fab4: 0xc7b40080
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 128)); ctx->f[20] = *(float*)&val; }
    // 0x17fab8: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 144));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: FTimeJtJumpToTarget__FP2JTP6VECTORN31Pf
// Address: 0x17fac0 - 0x17fb00

void entry_17fb00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17fb00) {
        switch (ctx->pc) {
            case 0x17fb28: ctx->pc = 0; goto label_17fb28;
            case 0x17fb3c: ctx->pc = 0; goto label_17fb3c;
            case 0x17fb40: ctx->pc = 0; goto label_17fb40;
            case 0x17fb60: ctx->pc = 0; goto label_17fb60;
            case 0x17fb64: ctx->pc = 0; goto label_17fb64;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17fb00: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17fb04: 0x24020001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    // 0x17fb08: 0x1062000c
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), 2));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 2)) {
        goto label_17fb3c;
    }
    // 0x17fb10: 0x50400005
    if (GPR_U32(ctx, 2) == GPR_U32(ctx, 0)) {
        SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 2));
        goto label_17fb28;
    }
    // 0x17fb18: 0x10600011
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_17fb60;
    }
    // 0x17fb20: 0x10000007
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17fb40;
    }
label_17fb28:
    // 0x17fb28: 0x14620005
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
    if (GPR_U32(ctx, 3) != GPR_U32(ctx, 2)) {
        goto label_17fb40;
    }
    // 0x17fb30: 0xc7a00004
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 4)); ctx->f[0] = *(float*)&val; }
    // 0x17fb34: 0x46010028
    ctx->f[0] = std::max(ctx->f[0], ctx->f[1]);
    // 0x17fb38: 0xe7a00000
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 29), 0), *(uint32_t*)&val); }
label_17fb3c:
    // 0x17fb3c: 0xc7a10000
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 29), 0)); ctx->f[1] = *(float*)&val; }
label_17fb40:
    // 0x17fb40: 0x44800000
    *(uint32_t*)&ctx->f[0] = GPR_U32(ctx, 0);
    // 0x17fb44: 0x46000836
    ctx->fcr31 = (FPU_C_OLE_S(ctx->f[1], ctx->f[0])) ? (ctx->fcr31 | 0x800000) : (ctx->fcr31 & ~0x800000);
    // 0x17fb48: 0x0
    // NOP
    // 0x17fb4c: 0x45010005
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    if ((ctx->fcr31 & 0x800000)) {
        goto label_17fb64;
    }
    // 0x17fb54: 0xe6010000
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 16), 0), *(uint32_t*)&val); }
    // 0x17fb58: 0x10000002
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 1));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_17fb64;
    }
label_17fb60:
    // 0x17fb60: 0x102d
    SET_GPR_U64(ctx, 2, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
label_17fb64:
    // 0x17fb64: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17fb68: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17fb6c: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17fb74: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17fb78; return;
}


// Function: GetJtJumpVelocity__FP2JTP6VECTOR
// Address: 0x17fb78 - 0x17fc48

void entry_17fd60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17fd60: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17fd64: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17fd6c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17fd70; return;
}


// Function: ResetJmtList__Fv
// Address: 0x17fd70 - 0x17fd84

void entry_17fd84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17fd84: 0x7bbf0000
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17fd88: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 16));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: OnJmtAdd__FP3JMT
// Address: 0x17fd90 - 0x17fda4

void entry_17fda4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17fda4: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x17fda8: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17fdac: 0xc05491c
    SET_GPR_U32(ctx, 31, 0x17fdb4);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16520));
    AppendDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_17fdb4
// Address: 0x17fdb4 - 0x17fdc8

void entry_17fdb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17fdb4: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17fdb8: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17fdbc: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17fdc4: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17fdc8; return;
}


// Function: OnJmtRemove__FP3JMT
// Address: 0x17fdc8 - 0x17fddc

void entry_17fddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17fddc: 0x3c040026
    SET_GPR_U32(ctx, 4, ((uint32_t)38 << 16));
    // 0x17fde0: 0x200282d
    SET_GPR_U64(ctx, 5, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    // 0x17fde4: 0xc054980
    SET_GPR_U32(ctx, 31, 0x17fdec);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 4), 16520));
    RemoveDlEntry__FP2DLPv(rdram, ctx, runtime); return;
}


// Function: entry_17fdec
// Address: 0x17fdec - 0x17fe00

void entry_17fdec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17fdec: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17fdf0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17fdf4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17fdfc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17fe00; return;
}


// Function: CloneJmt__FP3JMTT0
// Address: 0x17fe00 - 0x17fe28

void entry_17fe28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17fe28: 0x6ba20007
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 7); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x17fe2c: 0x6fa20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_data = READ64(addr & ~7ULL); SET_GPR_U64(ctx, 2, (GPR_U64(ctx, 2) & ~mask) | (aligned_data & mask)); }
    // 0x17fe30: 0xb2020057
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 87); uint32_t shift = (addr & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL << shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x17fe34: 0xb6020050
    { uint32_t addr = ADD32(GPR_U32(ctx, 16), 80); uint32_t shift = ((~addr) & 7) << 3; uint64_t mask = 0xFFFFFFFFFFFFFFFFULL >> shift; uint64_t aligned_addr = addr & ~7ULL; uint64_t old_data = READ64(aligned_addr); uint64_t new_data = (old_data & ~mask) | (GPR_U64(ctx, 2) & mask); WRITE64(aligned_addr, new_data); }
    // 0x17fe38: 0x7bbf0020
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 32)));
    // 0x17fe3c: 0x7bb00010
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17fe40: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 48));
    ctx->pc = GPR_U32(ctx, 31); return;
}


// Function: PostJmtLoad__FP3JMT
// Address: 0x17fe48 - 0x17fe5c

void entry_17fe5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17fe5c: 0x8e06005c
    SET_GPR_U32(ctx, 6, READ32(ADD32(GPR_U32(ctx, 16), 92)));
    // 0x17fe60: 0x2402ffff
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 0), 4294967295));
    // 0x17fe64: 0x10c20005
    SET_GPR_S32(ctx, 5, ADD32(GPR_U32(ctx, 0), 260));
    if (GPR_U32(ctx, 6) == GPR_U32(ctx, 2)) {
        ctx->pc = 0x17FE7C; return;
    }
    // 0x17fe6c: 0x8e040014
    SET_GPR_U32(ctx, 4, READ32(ADD32(GPR_U32(ctx, 16), 20)));
    // 0x17fe70: 0xc056906
    SET_GPR_U32(ctx, 31, 0x17fe78);
    SET_GPR_U64(ctx, 7, GPR_U64(ctx, 16) + GPR_U64(ctx, 0));
    PloFindSwObject__FP2SWi3OIDP2LO(rdram, ctx, runtime); return;
}


// Function: entry_17fe78
// Address: 0x17fe78 - 0x17fe90

void entry_17fe78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17fe78) {
        switch (ctx->pc) {
            case 0x17fe7c: ctx->pc = 0; goto label_17fe7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17fe78: 0xae020060
    WRITE32(ADD32(GPR_U32(ctx, 16), 96), GPR_U32(ctx, 2));
label_17fe7c:
    // 0x17fe7c: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17fe80: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17fe84: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17fe8c: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17fe90; return;
}


// Function: InitKeyhole__FP7KEYHOLE
// Address: 0x17fe90 - 0x17fea4

void entry_17fea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17fea4: 0x3c020026
    SET_GPR_U32(ctx, 2, ((uint32_t)38 << 16));
    // 0x17fea8: 0x7bbf0010
    SET_GPR_VEC(ctx, 31, READ128(ADD32(GPR_U32(ctx, 29), 16)));
    // 0x17feac: 0xac5040a4
    WRITE32(ADD32(GPR_U32(ctx, 2), 16548), GPR_U32(ctx, 16));
    // 0x17feb0: 0x7bb00000
    SET_GPR_VEC(ctx, 16, READ128(ADD32(GPR_U32(ctx, 29), 0)));
    // 0x17feb4: 0x3e00008
    SET_GPR_S32(ctx, 29, ADD32(GPR_U32(ctx, 29), 32));
    ctx->pc = GPR_U32(ctx, 31); return;
    // 0x17febc: 0x0
    // NOP
    // Fall-through to next function
    ctx->pc = 0x17fec0; return;
}


// Function: LoadKeyholeFromBrx__FP7KEYHOLEP18CBinaryInputStream
// Address: 0x17fec0 - 0x17ff00

void entry_17ff00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ff00: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x17ff08);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_17ff08
// Address: 0x17ff08 - 0x17ff14

void entry_17ff08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ff08: 0x22100
    SET_GPR_U32(ctx, 4, SLL32(GPR_U32(ctx, 2), 4));
    // 0x17ff0c: 0xc063570
    SET_GPR_U32(ctx, 31, 0x17ff14);
    WRITE32(ADD32(GPR_U32(ctx, 20), 52), GPR_U32(ctx, 2));
    PvAllocSwClearImpl__Fi(rdram, ctx, runtime); return;
}


// Function: entry_17ff14
// Address: 0x17ff14 - 0x17ff38

void entry_17ff14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ff14) {
        switch (ctx->pc) {
            case 0x17ff30: ctx->pc = 0; goto label_17ff30;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ff14: 0x8e830034
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 52)));
    // 0x17ff18: 0x18600018
    WRITE32(ADD32(GPR_U32(ctx, 20), 56), GPR_U32(ctx, 2));
    if (GPR_S32(ctx, 3) <= 0) {
        ctx->pc = 0x17FF7C; return;
    }
    // 0x17ff20: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17ff24: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x17ff28: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x17ff2c: 0x0
    // NOP
label_17ff30:
    // 0x17ff30: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x17ff38);
    SET_GPR_U32(ctx, 16, SLL32(GPR_U32(ctx, 17), 4));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_17ff38
// Address: 0x17ff38 - 0x17ff50

void entry_17ff38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ff38: 0x26310001
    SET_GPR_S32(ctx, 17, ADD32(GPR_U32(ctx, 17), 1));
    // 0x17ff3c: 0x8e820038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 56)));
    // 0x17ff40: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x17ff44: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x17ff48: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x17ff50);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 0), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_17ff50
// Address: 0x17ff50 - 0x17ff8c

void entry_17ff50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ff50) {
        switch (ctx->pc) {
            case 0x17ff7c: ctx->pc = 0; goto label_17ff7c;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ff50: 0x8e820038
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 56)));
    // 0x17ff54: 0x46000007
    ctx->f[0] = FPU_NEG_S(ctx->f[0]);
    // 0x17ff58: 0x2021021
    SET_GPR_U32(ctx, 2, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 2)));
    // 0x17ff5c: 0xe4400004
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 2), 4), *(uint32_t*)&val); }
    // 0x17ff60: 0x8e830038
    SET_GPR_U32(ctx, 3, READ32(ADD32(GPR_U32(ctx, 20), 56)));
    // 0x17ff64: 0x2038021
    SET_GPR_U32(ctx, 16, ADD32(GPR_U32(ctx, 16), GPR_U32(ctx, 3)));
    // 0x17ff68: 0xe614000c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 16), 12), *(uint32_t*)&val); }
    // 0x17ff6c: 0x8e820034
    SET_GPR_U32(ctx, 2, READ32(ADD32(GPR_U32(ctx, 20), 52)));
    // 0x17ff70: 0x222102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 17), GPR_S32(ctx, 2)));
    // 0x17ff74: 0x5440ffee
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
        ctx->pc = 0x17FF30; return;
    }
label_17ff7c:
    // 0x17ff7c: 0x3c013f80
    SET_GPR_U32(ctx, 1, ((uint32_t)16256 << 16));
    // 0x17ff80: 0x4481a000
    *(uint32_t*)&ctx->f[20] = GPR_U32(ctx, 1);
    // 0x17ff84: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x17ff8c);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_17ff8c
// Address: 0x17ff8c - 0x17ff9c

void entry_17ff8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ff8c: 0x3c178080
    SET_GPR_U32(ctx, 23, ((uint32_t)32896 << 16));
    // 0x17ff90: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x17ff94: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x17ff9c);
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 64), *(uint32_t*)&val); }
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_17ff9c
// Address: 0x17ff9c - 0x17ffb4

void entry_17ff9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ff9c: 0x802d
    SET_GPR_U64(ctx, 16, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    // 0x17ffa0: 0xe694004c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 20), 76), *(uint32_t*)&val); }
    // 0x17ffa4: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    // 0x17ffa8: 0xe6800044
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 68), *(uint32_t*)&val); }
    // 0x17ffac: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x17ffb4);
    SET_GPR_S32(ctx, 30, ADD32(GPR_U32(ctx, 0), 12));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_17ffb4
// Address: 0x17ffb4 - 0x17ffc4

void entry_17ffb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // 0x17ffb4: 0x36f78080
    SET_GPR_U32(ctx, 23, OR32(GPR_U32(ctx, 23), 32896));
    // 0x17ffb8: 0xe6800050
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 80), *(uint32_t*)&val); }
    // 0x17ffbc: 0xc04df7e
    SET_GPR_U32(ctx, 31, 0x17ffc4);
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    F32Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_17ffc4
// Address: 0x17ffc4 - 0x17ffe8

void entry_17ffc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ffc4) {
        switch (ctx->pc) {
            case 0x17ffe0: ctx->pc = 0; goto label_17ffe0;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ffc4: 0xc6810050
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 80)); ctx->f[1] = *(float*)&val; }
    // 0x17ffc8: 0xc6820040
    { uint32_t val = READ32(ADD32(GPR_U32(ctx, 20), 64)); ctx->f[2] = *(float*)&val; }
    // 0x17ffcc: 0xe6800054
    { float val = ctx->f[0]; WRITE32(ADD32(GPR_U32(ctx, 20), 84), *(uint32_t*)&val); }
    // 0x17ffd0: 0x46020841
    ctx->f[1] = FPU_SUB_S(ctx->f[1], ctx->f[2]);
    // 0x17ffd4: 0xe694005c
    { float val = ctx->f[20]; WRITE32(ADD32(GPR_U32(ctx, 20), 92), *(uint32_t*)&val); }
    // 0x17ffd8: 0xe6810060
    { float val = ctx->f[1]; WRITE32(ADD32(GPR_U32(ctx, 20), 96), *(uint32_t*)&val); }
    // 0x17ffdc: 0x0
    // NOP
label_17ffe0:
    // 0x17ffe0: 0xc06d1a2
    SET_GPR_U32(ctx, 31, 0x17ffe8);
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 16), 1166));
    PshdFindShader__F3OID(rdram, ctx, runtime); return;
}


// Function: entry_17ffe8
// Address: 0x17ffe8 - 0x180068

void entry_17ffe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {

    // Dispatch for mid-function entry points
    if (ctx->pc != 0 && ctx->pc != 0x17ffe8) {
        switch (ctx->pc) {
            case 0x180020: ctx->pc = 0; goto label_180020;
            case 0x180044: ctx->pc = 0; goto label_180044;
            case 0x180060: ctx->pc = 0; goto label_180060;
            default: break;
        }
        ctx->pc = 0; // Reset PC and continue from start
    }

    // 0x17ffe8: 0x40182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 2) + GPR_U64(ctx, 0));
    // 0x17ffec: 0x21e1018
    { int64_t result = (int64_t)GPR_S32(ctx, 16) * (int64_t)GPR_S32(ctx, 30); ctx->lo = (uint32_t)result; ctx->hi = (uint32_t)(result >> 32); }
    // 0x17fff0: 0x24420064
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 100));
    // 0x17fff4: 0x10600013
    SET_GPR_U32(ctx, 17, ADD32(GPR_U32(ctx, 20), GPR_U32(ctx, 2)));
    if (GPR_U32(ctx, 3) == GPR_U32(ctx, 0)) {
        goto label_180044;
    }
    // 0x17fffc: 0x88620007
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 7); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x180000: 0x98620004
    { uint32_t addr = ADD32(GPR_U32(ctx, 3), 4); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x180004: 0xaa220003
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180008: 0xba220000
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x18000c: 0x26160001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 16), 1));
    // 0x180010: 0x220182d
    SET_GPR_U64(ctx, 3, GPR_U64(ctx, 17) + GPR_U64(ctx, 0));
    // 0x180014: 0x26240004
    SET_GPR_S32(ctx, 4, ADD32(GPR_U32(ctx, 17), 4));
    // 0x180018: 0x90620000
    SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
    // 0x18001c: 0x0
    // NOP
label_180020:
    // 0x180020: 0x24420001
    SET_GPR_S32(ctx, 2, ADD32(GPR_U32(ctx, 2), 1));
    // 0x180024: 0x21043
    SET_GPR_S32(ctx, 2, SRA32(GPR_S32(ctx, 2), 1));
    // 0x180028: 0xa0620000
    WRITE8(ADD32(GPR_U32(ctx, 3), 0), (uint8_t)GPR_U32(ctx, 2));
    // 0x18002c: 0x24630001
    SET_GPR_S32(ctx, 3, ADD32(GPR_U32(ctx, 3), 1));
    // 0x180030: 0x64102a
    SET_GPR_U32(ctx, 2, SLT32(GPR_S32(ctx, 3), GPR_S32(ctx, 4)));
    // 0x180034: 0x5440fffa
    if (GPR_U32(ctx, 2) != GPR_U32(ctx, 0)) {
        SET_GPR_U32(ctx, 2, (uint8_t)READ8(ADD32(GPR_U32(ctx, 3), 0)));
        goto label_180020;
    }
    // 0x18003c: 0x10000008
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
    if (GPR_U32(ctx, 0) == GPR_U32(ctx, 0)) {
        goto label_180060;
    }
label_180044:
    // 0x180044: 0xafb70000
    WRITE32(ADD32(GPR_U32(ctx, 29), 0), GPR_U32(ctx, 23));
    // 0x180048: 0x26160001
    SET_GPR_S32(ctx, 22, ADD32(GPR_U32(ctx, 16), 1));
    // 0x18004c: 0x8ba20003
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 3); uint32_t shift = ((~addr) & 3) << 3; /* big-endian */ uint32_t mask  = 0xFFFFFFFF >> shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | ((word >> shift) & mask)); }
    // 0x180050: 0x9ba20000
    { uint32_t addr = ADD32(GPR_U32(ctx, 29), 0); uint32_t shift = (addr & 3) << 3; uint32_t mask  = 0xFFFFFFFF << shift; uint32_t word  = READ32(addr & ~3); SET_GPR_U32(ctx, 2, (GPR_U32(ctx,2) & ~mask) | (word << shift)); }
    // 0x180054: 0xaa220003
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 3); uint32_t shift = (addr & 3) << 3; uint32_t mask = 0xFFFFFFFF << shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x180058: 0xba220000
    { uint32_t addr = ADD32(GPR_U32(ctx, 17), 0); uint32_t shift = ((~addr) & 3) << 3; uint32_t mask = 0xFFFFFFFF >> shift; uint32_t aligned_addr = addr & ~3; uint32_t old_data = READ32(aligned_addr); uint32_t new_data = (old_data & ~mask) | (GPR_U32(ctx, 2) & mask); WRITE32(aligned_addr, new_data); }
    // 0x18005c: 0x2a0202d
    SET_GPR_U64(ctx, 4, GPR_U64(ctx, 21) + GPR_U64(ctx, 0));
label_180060:
    // 0x180060: 0xc04def8
    SET_GPR_U32(ctx, 31, 0x180068);
    SET_GPR_U64(ctx, 18, GPR_U64(ctx, 0) + GPR_U64(ctx, 0));
    U16Read__18CBinaryInputStream(rdram, ctx, runtime); return;
}


// Function: entry_180068
// Address: 0x180068 - 0x180074

void entry_170018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170018 inside entry_16ffe4 (0x16ffe4 - 0x170030)
    ctx->pc = 0x170018;
    entry_16ffe4(rdram, ctx, runtime);
}

void entry_170120(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170120 inside entry_170110 (0x170110 - 0x170154)
    ctx->pc = 0x170120;
    entry_170110(rdram, ctx, runtime);
}

void entry_1702b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1702b0 inside entry_1702a8 (0x1702a8 - 0x1702e4)
    ctx->pc = 0x1702b0;
    entry_1702a8(rdram, ctx, runtime);
}

void entry_1703d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1703d8 inside entry_1703d0 (0x1703d0 - 0x1703e0)
    ctx->pc = 0x1703d8;
    entry_1703d0(rdram, ctx, runtime);
}

void entry_1703e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1703e8 inside entry_1703e0 (0x1703e0 - 0x1703f0)
    ctx->pc = 0x1703e8;
    entry_1703e0(rdram, ctx, runtime);
}

void entry_1703f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1703f4 inside entry_1703f0 (0x1703f0 - 0x170410)
    ctx->pc = 0x1703f4;
    entry_1703f0(rdram, ctx, runtime);
}

void entry_1703f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1703f8 inside entry_1703f0 (0x1703f0 - 0x170410)
    ctx->pc = 0x1703f8;
    entry_1703f0(rdram, ctx, runtime);
}

void entry_170448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170448 inside AdjustJtNewXp__FP2JTP2XPi (0x170410 - 0x170464)
    ctx->pc = 0x170448;
    AdjustJtNewXp__FP2JTP2XPi(rdram, ctx, runtime);
}

void entry_17049c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17049c inside entry_170464 (0x170464 - 0x170528)
    ctx->pc = 0x17049c;
    entry_170464(rdram, ctx, runtime);
}

void entry_1704a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1704a4 inside entry_170464 (0x170464 - 0x170528)
    ctx->pc = 0x1704a4;
    entry_170464(rdram, ctx, runtime);
}

void entry_1704cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1704cc inside entry_170464 (0x170464 - 0x170528)
    ctx->pc = 0x1704cc;
    entry_170464(rdram, ctx, runtime);
}

void entry_1704d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1704d4 inside entry_170464 (0x170464 - 0x170528)
    ctx->pc = 0x1704d4;
    entry_170464(rdram, ctx, runtime);
}

void entry_1704e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1704e0 inside entry_170464 (0x170464 - 0x170528)
    ctx->pc = 0x1704e0;
    entry_170464(rdram, ctx, runtime);
}

void entry_1704ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1704ec inside entry_170464 (0x170464 - 0x170528)
    ctx->pc = 0x1704ec;
    entry_170464(rdram, ctx, runtime);
}

void entry_1704f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1704f8 inside entry_170464 (0x170464 - 0x170528)
    ctx->pc = 0x1704f8;
    entry_170464(rdram, ctx, runtime);
}

void entry_1704fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1704fc inside entry_170464 (0x170464 - 0x170528)
    ctx->pc = 0x1704fc;
    entry_170464(rdram, ctx, runtime);
}

void entry_170500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170500 inside entry_170464 (0x170464 - 0x170528)
    ctx->pc = 0x170500;
    entry_170464(rdram, ctx, runtime);
}

void entry_170578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170578 inside AdjustJtDz__FP2JTiP2DZif (0x170528 - 0x1705b8)
    ctx->pc = 0x170578;
    AdjustJtDz__FP2JTiP2DZif(rdram, ctx, runtime);
}

void entry_170594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170594 inside AdjustJtDz__FP2JTiP2DZif (0x170528 - 0x1705b8)
    ctx->pc = 0x170594;
    AdjustJtDz__FP2JTiP2DZif(rdram, ctx, runtime);
}

void entry_1705b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1705b0 inside AdjustJtDz__FP2JTiP2DZif (0x170528 - 0x1705b8)
    ctx->pc = 0x1705b0;
    AdjustJtDz__FP2JTiP2DZif(rdram, ctx, runtime);
}

void entry_1705bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1705bc inside entry_1705b8 (0x1705b8 - 0x1705c8)
    ctx->pc = 0x1705bc;
    entry_1705b8(rdram, ctx, runtime);
}

void entry_1705fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1705fc inside HandleJtGrfjtsc (0x1705c8 - 0x170618)
    ctx->pc = 0x1705fc;
    HandleJtGrfjtsc(rdram, ctx, runtime);
}

void entry_170638(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170638 inside entry_170634 (0x170634 - 0x17064c)
    ctx->pc = 0x170638;
    entry_170634(rdram, ctx, runtime);
}

void entry_170650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170650 inside entry_17064c (0x17064c - 0x170660)
    ctx->pc = 0x170650;
    entry_17064c(rdram, ctx, runtime);
}

void entry_1706a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1706a8 inside entry_17067c (0x17067c - 0x1706c4)
    ctx->pc = 0x1706a8;
    entry_17067c(rdram, ctx, runtime);
}

void entry_1706bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1706bc inside entry_17067c (0x17067c - 0x1706c4)
    ctx->pc = 0x1706bc;
    entry_17067c(rdram, ctx, runtime);
}

void entry_1706cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1706cc inside entry_1706c4 (0x1706c4 - 0x1706d4)
    ctx->pc = 0x1706cc;
    entry_1706c4(rdram, ctx, runtime);
}

void entry_1706dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1706dc inside entry_1706d4 (0x1706d4 - 0x1706f0)
    ctx->pc = 0x1706dc;
    entry_1706d4(rdram, ctx, runtime);
}

void entry_170780(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170780 inside entry_17077c (0x17077c - 0x170790)
    ctx->pc = 0x170780;
    entry_17077c(rdram, ctx, runtime);
}

void entry_170784(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170784 inside entry_17077c (0x17077c - 0x170790)
    ctx->pc = 0x170784;
    entry_17077c(rdram, ctx, runtime);
}

void entry_1707b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1707b8 inside entry_1707b0 (0x1707b0 - 0x170820)
    ctx->pc = 0x1707b8;
    entry_1707b0(rdram, ctx, runtime);
}

void entry_17080c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17080c inside entry_1707b0 (0x1707b0 - 0x170820)
    ctx->pc = 0x17080c;
    entry_1707b0(rdram, ctx, runtime);
}

void entry_170810(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170810 inside entry_1707b0 (0x1707b0 - 0x170820)
    ctx->pc = 0x170810;
    entry_1707b0(rdram, ctx, runtime);
}

void entry_170814(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170814 inside entry_1707b0 (0x1707b0 - 0x170820)
    ctx->pc = 0x170814;
    entry_1707b0(rdram, ctx, runtime);
}

void entry_1708d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1708d0 inside AdjustJtXpVelocity__FP2JTP2XPi (0x170820 - 0x1708f0)
    ctx->pc = 0x1708d0;
    AdjustJtXpVelocity__FP2JTP2XPi(rdram, ctx, runtime);
}

void entry_17090c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17090c inside entry_170904 (0x170904 - 0x170960)
    ctx->pc = 0x17090c;
    entry_170904(rdram, ctx, runtime);
}

void entry_170940(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170940 inside entry_170904 (0x170904 - 0x170960)
    ctx->pc = 0x170940;
    entry_170904(rdram, ctx, runtime);
}

void entry_170944(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170944 inside entry_170904 (0x170904 - 0x170960)
    ctx->pc = 0x170944;
    entry_170904(rdram, ctx, runtime);
}

void entry_170948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170948 inside entry_170904 (0x170904 - 0x170960)
    ctx->pc = 0x170948;
    entry_170904(rdram, ctx, runtime);
}

void entry_17094c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17094c inside entry_170904 (0x170904 - 0x170960)
    ctx->pc = 0x17094c;
    entry_170904(rdram, ctx, runtime);
}

void entry_170a04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170a04 inside entry_1709ac (0x1709ac - 0x170bb8)
    ctx->pc = 0x170a04;
    entry_1709ac(rdram, ctx, runtime);
}

void entry_170a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170a10 inside entry_1709ac (0x1709ac - 0x170bb8)
    ctx->pc = 0x170a10;
    entry_1709ac(rdram, ctx, runtime);
}

void entry_170a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170a5c inside entry_1709ac (0x1709ac - 0x170bb8)
    ctx->pc = 0x170a5c;
    entry_1709ac(rdram, ctx, runtime);
}

void entry_170a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170a84 inside entry_1709ac (0x1709ac - 0x170bb8)
    ctx->pc = 0x170a84;
    entry_1709ac(rdram, ctx, runtime);
}

void entry_170abc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170abc inside entry_1709ac (0x1709ac - 0x170bb8)
    ctx->pc = 0x170abc;
    entry_1709ac(rdram, ctx, runtime);
}

void entry_170ad0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170ad0 inside entry_1709ac (0x1709ac - 0x170bb8)
    ctx->pc = 0x170ad0;
    entry_1709ac(rdram, ctx, runtime);
}

void entry_170b5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170b5c inside entry_1709ac (0x1709ac - 0x170bb8)
    ctx->pc = 0x170b5c;
    entry_1709ac(rdram, ctx, runtime);
}

void entry_170c48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170c48 inside entry_170bf4 (0x170bf4 - 0x170c98)
    ctx->pc = 0x170c48;
    entry_170bf4(rdram, ctx, runtime);
}

void entry_170cf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170cf0 inside entry_170c98 (0x170c98 - 0x170d08)
    ctx->pc = 0x170cf0;
    entry_170c98(rdram, ctx, runtime);
}

void entry_170db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170db4 inside entry_170d54 (0x170d54 - 0x170e1c)
    ctx->pc = 0x170db4;
    entry_170d54(rdram, ctx, runtime);
}

void entry_170de8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170de8 inside entry_170d54 (0x170d54 - 0x170e1c)
    ctx->pc = 0x170de8;
    entry_170d54(rdram, ctx, runtime);
}

void entry_170e24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170e24 inside entry_170e1c (0x170e1c - 0x170e2c)
    ctx->pc = 0x170e24;
    entry_170e1c(rdram, ctx, runtime);
}

void entry_170e34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170e34 inside entry_170e2c (0x170e2c - 0x170e40)
    ctx->pc = 0x170e34;
    entry_170e2c(rdram, ctx, runtime);
}

void entry_170e44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170e44 inside entry_170e40 (0x170e40 - 0x170e78)
    ctx->pc = 0x170e44;
    entry_170e40(rdram, ctx, runtime);
}

void entry_170e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170e58 inside entry_170e40 (0x170e40 - 0x170e78)
    ctx->pc = 0x170e58;
    entry_170e40(rdram, ctx, runtime);
}

void entry_170e94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170e94 inside entry_170e78 (0x170e78 - 0x170e9c)
    ctx->pc = 0x170e94;
    entry_170e78(rdram, ctx, runtime);
}

void entry_170f20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170f20 inside entry_170eac (0x170eac - 0x170f38)
    ctx->pc = 0x170f20;
    entry_170eac(rdram, ctx, runtime);
}

void entry_170ff8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x170ff8 inside entry_170f88 (0x170f88 - 0x171120)
    ctx->pc = 0x170ff8;
    entry_170f88(rdram, ctx, runtime);
}

void entry_171060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171060 inside entry_170f88 (0x170f88 - 0x171120)
    ctx->pc = 0x171060;
    entry_170f88(rdram, ctx, runtime);
}

void entry_1710d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1710d0 inside entry_170f88 (0x170f88 - 0x171120)
    ctx->pc = 0x1710d0;
    entry_170f88(rdram, ctx, runtime);
}

void entry_1710e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1710e4 inside entry_170f88 (0x170f88 - 0x171120)
    ctx->pc = 0x1710e4;
    entry_170f88(rdram, ctx, runtime);
}

void entry_1710ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1710ec inside entry_170f88 (0x170f88 - 0x171120)
    ctx->pc = 0x1710ec;
    entry_170f88(rdram, ctx, runtime);
}

void entry_1710f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1710f4 inside entry_170f88 (0x170f88 - 0x171120)
    ctx->pc = 0x1710f4;
    entry_170f88(rdram, ctx, runtime);
}

void entry_171110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171110 inside entry_170f88 (0x170f88 - 0x171120)
    ctx->pc = 0x171110;
    entry_170f88(rdram, ctx, runtime);
}

void entry_171128(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171128 inside entry_171120 (0x171120 - 0x17113c)
    ctx->pc = 0x171128;
    entry_171120(rdram, ctx, runtime);
}

void entry_171140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171140 inside entry_17113c (0x17113c - 0x171180)
    ctx->pc = 0x171140;
    entry_17113c(rdram, ctx, runtime);
}

void entry_171144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171144 inside entry_17113c (0x17113c - 0x171180)
    ctx->pc = 0x171144;
    entry_17113c(rdram, ctx, runtime);
}

void entry_1711c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1711c0 inside entry_1711a4 (0x1711a4 - 0x1711e8)
    ctx->pc = 0x1711c0;
    entry_1711a4(rdram, ctx, runtime);
}

void entry_171218(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171218 inside entry_171200 (0x171200 - 0x171220)
    ctx->pc = 0x171218;
    entry_171200(rdram, ctx, runtime);
}

void entry_171228(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171228 inside entry_171220 (0x171220 - 0x171238)
    ctx->pc = 0x171228;
    entry_171220(rdram, ctx, runtime);
}

void entry_1712d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1712d4 inside UpdateJtBalance__FP2JT (0x171238 - 0x1712fc)
    ctx->pc = 0x1712d4;
    UpdateJtBalance__FP2JT(rdram, ctx, runtime);
}

void entry_171360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171360 inside entry_171318 (0x171318 - 0x17136c)
    ctx->pc = 0x171360;
    entry_171318(rdram, ctx, runtime);
}

void entry_171374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171374 inside entry_17136c (0x17136c - 0x1713a8)
    ctx->pc = 0x171374;
    entry_17136c(rdram, ctx, runtime);
}

void entry_171378(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171378 inside entry_17136c (0x17136c - 0x1713a8)
    ctx->pc = 0x171378;
    entry_17136c(rdram, ctx, runtime);
}

void entry_1713ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1713ac inside entry_1713a8 (0x1713a8 - 0x171448)
    ctx->pc = 0x1713ac;
    entry_1713a8(rdram, ctx, runtime);
}

void entry_1713f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1713f8 inside entry_1713a8 (0x1713a8 - 0x171448)
    ctx->pc = 0x1713f8;
    entry_1713a8(rdram, ctx, runtime);
}

void entry_171410(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171410 inside entry_1713a8 (0x1713a8 - 0x171448)
    ctx->pc = 0x171410;
    entry_1713a8(rdram, ctx, runtime);
}

void entry_171450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171450 inside entry_171448 (0x171448 - 0x171480)
    ctx->pc = 0x171450;
    entry_171448(rdram, ctx, runtime);
}

void entry_171540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171540 inside entry_171538 (0x171538 - 0x17158c)
    ctx->pc = 0x171540;
    entry_171538(rdram, ctx, runtime);
}

void entry_17155c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17155c inside entry_171538 (0x171538 - 0x17158c)
    ctx->pc = 0x17155c;
    entry_171538(rdram, ctx, runtime);
}

void entry_17156c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17156c inside entry_171538 (0x171538 - 0x17158c)
    ctx->pc = 0x17156c;
    entry_171538(rdram, ctx, runtime);
}

void entry_171688(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171688 inside entry_171648 (0x171648 - 0x1716c8)
    ctx->pc = 0x171688;
    entry_171648(rdram, ctx, runtime);
}

void entry_171694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171694 inside entry_171648 (0x171648 - 0x1716c8)
    ctx->pc = 0x171694;
    entry_171648(rdram, ctx, runtime);
}

void entry_171714(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171714 inside entry_17170c (0x17170c - 0x171740)
    ctx->pc = 0x171714;
    entry_17170c(rdram, ctx, runtime);
}

void entry_17171c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17171c inside entry_17170c (0x17170c - 0x171740)
    ctx->pc = 0x17171c;
    entry_17170c(rdram, ctx, runtime);
}

void entry_171720(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171720 inside entry_17170c (0x17170c - 0x171740)
    ctx->pc = 0x171720;
    entry_17170c(rdram, ctx, runtime);
}

void entry_171844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171844 inside entry_171780 (0x171780 - 0x1719e8)
    ctx->pc = 0x171844;
    entry_171780(rdram, ctx, runtime);
}

void entry_171854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171854 inside entry_171780 (0x171780 - 0x1719e8)
    ctx->pc = 0x171854;
    entry_171780(rdram, ctx, runtime);
}

void entry_1718e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1718e8 inside entry_171780 (0x171780 - 0x1719e8)
    ctx->pc = 0x1718e8;
    entry_171780(rdram, ctx, runtime);
}

void entry_1718f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1718f4 inside entry_171780 (0x171780 - 0x1719e8)
    ctx->pc = 0x1718f4;
    entry_171780(rdram, ctx, runtime);
}

void entry_17195c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17195c inside entry_171780 (0x171780 - 0x1719e8)
    ctx->pc = 0x17195c;
    entry_171780(rdram, ctx, runtime);
}

void entry_171960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171960 inside entry_171780 (0x171780 - 0x1719e8)
    ctx->pc = 0x171960;
    entry_171780(rdram, ctx, runtime);
}

void entry_1719a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1719a4 inside entry_171780 (0x171780 - 0x1719e8)
    ctx->pc = 0x1719a4;
    entry_171780(rdram, ctx, runtime);
}

void entry_1719c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1719c0 inside entry_171780 (0x171780 - 0x1719e8)
    ctx->pc = 0x1719c0;
    entry_171780(rdram, ctx, runtime);
}

void entry_1719c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1719c4 inside entry_171780 (0x171780 - 0x1719e8)
    ctx->pc = 0x1719c4;
    entry_171780(rdram, ctx, runtime);
}

void entry_171a4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171a4c inside RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG (0x1719e8 - 0x171a88)
    ctx->pc = 0x171a4c;
    RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG(rdram, ctx, runtime);
}

void entry_171a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171a50 inside RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG (0x1719e8 - 0x171a88)
    ctx->pc = 0x171a50;
    RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG(rdram, ctx, runtime);
}

void entry_171a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171a58 inside RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG (0x1719e8 - 0x171a88)
    ctx->pc = 0x171a58;
    RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG(rdram, ctx, runtime);
}

void entry_171a68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171a68 inside RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG (0x1719e8 - 0x171a88)
    ctx->pc = 0x171a68;
    RebuildJtXmg__FP2JTP3ALOfT1P6ACTADJP3XMG(rdram, ctx, runtime);
}

void entry_171a90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171a90 inside entry_171a88 (0x171a88 - 0x171ac0)
    ctx->pc = 0x171a90;
    entry_171a88(rdram, ctx, runtime);
}

void entry_171c50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171c50 inside entry_171c30 (0x171c30 - 0x171c80)
    ctx->pc = 0x171c50;
    entry_171c30(rdram, ctx, runtime);
}

void entry_171d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171d78 inside entry_171d60 (0x171d60 - 0x171dd8)
    ctx->pc = 0x171d78;
    entry_171d60(rdram, ctx, runtime);
}

void entry_171db0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171db0 inside entry_171d60 (0x171d60 - 0x171dd8)
    ctx->pc = 0x171db0;
    entry_171d60(rdram, ctx, runtime);
}

void entry_171db4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171db4 inside entry_171d60 (0x171d60 - 0x171dd8)
    ctx->pc = 0x171db4;
    entry_171d60(rdram, ctx, runtime);
}

void entry_171e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171e54 inside entry_171e38 (0x171e38 - 0x171e84)
    ctx->pc = 0x171e54;
    entry_171e38(rdram, ctx, runtime);
}

void entry_171e58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171e58 inside entry_171e38 (0x171e38 - 0x171e84)
    ctx->pc = 0x171e58;
    entry_171e38(rdram, ctx, runtime);
}

void entry_171ecc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171ecc inside entry_171ec4 (0x171ec4 - 0x171eec)
    ctx->pc = 0x171ecc;
    entry_171ec4(rdram, ctx, runtime);
}

void entry_171f04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171f04 inside entry_171f00 (0x171f00 - 0x171f28)
    ctx->pc = 0x171f04;
    entry_171f00(rdram, ctx, runtime);
}

void entry_171f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171f08 inside entry_171f00 (0x171f00 - 0x171f28)
    ctx->pc = 0x171f08;
    entry_171f00(rdram, ctx, runtime);
}

void entry_171f0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171f0c inside entry_171f00 (0x171f00 - 0x171f28)
    ctx->pc = 0x171f0c;
    entry_171f00(rdram, ctx, runtime);
}

void entry_171f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171f10 inside entry_171f00 (0x171f00 - 0x171f28)
    ctx->pc = 0x171f10;
    entry_171f00(rdram, ctx, runtime);
}

void entry_171fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x171fc4 inside entry_171fa4 (0x171fa4 - 0x171fe0)
    ctx->pc = 0x171fc4;
    entry_171fa4(rdram, ctx, runtime);
}

void entry_172014(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172014 inside UnhookJt__FP2JT (0x171fe0 - 0x172038)
    ctx->pc = 0x172014;
    UnhookJt__FP2JT(rdram, ctx, runtime);
}

void entry_172020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172020 inside UnhookJt__FP2JT (0x171fe0 - 0x172038)
    ctx->pc = 0x172020;
    UnhookJt__FP2JT(rdram, ctx, runtime);
}

void entry_172040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172040 inside entry_172038 (0x172038 - 0x172068)
    ctx->pc = 0x172040;
    entry_172038(rdram, ctx, runtime);
}

void entry_17206c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17206c inside entry_172068 (0x172068 - 0x172078)
    ctx->pc = 0x17206c;
    entry_172068(rdram, ctx, runtime);
}

void entry_1720ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1720ac inside CalculateJtToolSpin__FP2JTfP7MATRIX3 (0x172078 - 0x1720e4)
    ctx->pc = 0x1720ac;
    CalculateJtToolSpin__FP2JTfP7MATRIX3(rdram, ctx, runtime);
}

void entry_1720b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1720b4 inside CalculateJtToolSpin__FP2JTfP7MATRIX3 (0x172078 - 0x1720e4)
    ctx->pc = 0x1720b4;
    CalculateJtToolSpin__FP2JTfP7MATRIX3(rdram, ctx, runtime);
}

void entry_172258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172258 inside entry_172218 (0x172218 - 0x1722cc)
    ctx->pc = 0x172258;
    entry_172218(rdram, ctx, runtime);
}

void entry_172264(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172264 inside entry_172218 (0x172218 - 0x1722cc)
    ctx->pc = 0x172264;
    entry_172218(rdram, ctx, runtime);
}

void entry_17229c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17229c inside entry_172218 (0x172218 - 0x1722cc)
    ctx->pc = 0x17229c;
    entry_172218(rdram, ctx, runtime);
}

void entry_1722a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1722a0 inside entry_172218 (0x172218 - 0x1722cc)
    ctx->pc = 0x1722a0;
    entry_172218(rdram, ctx, runtime);
}

void entry_1722d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1722d4 inside entry_1722cc (0x1722cc - 0x1722ec)
    ctx->pc = 0x1722d4;
    entry_1722cc(rdram, ctx, runtime);
}

void entry_17231c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17231c inside entry_1722ec (0x1722ec - 0x17232c)
    ctx->pc = 0x17231c;
    entry_1722ec(rdram, ctx, runtime);
}

void entry_17234c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17234c inside entry_17232c (0x17232c - 0x172388)
    ctx->pc = 0x17234c;
    entry_17232c(rdram, ctx, runtime);
}

void entry_17237c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17237c inside entry_17232c (0x17232c - 0x172388)
    ctx->pc = 0x17237c;
    entry_17232c(rdram, ctx, runtime);
}

void entry_172450(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172450 inside entry_172434 (0x172434 - 0x172494)
    ctx->pc = 0x172450;
    entry_172434(rdram, ctx, runtime);
}

void entry_172478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172478 inside entry_172434 (0x172434 - 0x172494)
    ctx->pc = 0x172478;
    entry_172434(rdram, ctx, runtime);
}

void entry_1724b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1724b4 inside entry_172494 (0x172494 - 0x1724e4)
    ctx->pc = 0x1724b4;
    entry_172494(rdram, ctx, runtime);
}

void entry_1724d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1724d8 inside entry_172494 (0x172494 - 0x1724e4)
    ctx->pc = 0x1724d8;
    entry_172494(rdram, ctx, runtime);
}

void entry_172508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172508 inside entry_1724e4 (0x1724e4 - 0x172530)
    ctx->pc = 0x172508;
    entry_1724e4(rdram, ctx, runtime);
}

void entry_17250c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17250c inside entry_1724e4 (0x1724e4 - 0x172530)
    ctx->pc = 0x17250c;
    entry_1724e4(rdram, ctx, runtime);
}

void entry_17256c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17256c inside entry_172548 (0x172548 - 0x17259c)
    ctx->pc = 0x17256c;
    entry_172548(rdram, ctx, runtime);
}

void entry_1725c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1725c0 inside entry_1725b8 (0x1725b8 - 0x1725e0)
    ctx->pc = 0x1725c0;
    entry_1725b8(rdram, ctx, runtime);
}

void entry_1725c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1725c4 inside entry_1725b8 (0x1725b8 - 0x1725e0)
    ctx->pc = 0x1725c4;
    entry_1725b8(rdram, ctx, runtime);
}

void entry_1725cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1725cc inside entry_1725b8 (0x1725b8 - 0x1725e0)
    ctx->pc = 0x1725cc;
    entry_1725b8(rdram, ctx, runtime);
}

void entry_172628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172628 inside FUN_001725e0 (0x1725e0 - 0x17263c)
    ctx->pc = 0x172628;
    FUN_001725e0(rdram, ctx, runtime);
}

void entry_172654(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172654 inside entry_172650 (0x172650 - 0x1726b8)
    ctx->pc = 0x172654;
    entry_172650(rdram, ctx, runtime);
}

void entry_172680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172680 inside entry_172650 (0x172650 - 0x1726b8)
    ctx->pc = 0x172680;
    entry_172650(rdram, ctx, runtime);
}

void entry_1726d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1726d0 inside entry_1726b8 (0x1726b8 - 0x1726ec)
    ctx->pc = 0x1726d0;
    entry_1726b8(rdram, ctx, runtime);
}

void entry_172740(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172740 inside entry_172718 (0x172718 - 0x172754)
    ctx->pc = 0x172740;
    entry_172718(rdram, ctx, runtime);
}

void entry_172758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172758 inside entry_172754 (0x172754 - 0x172764)
    ctx->pc = 0x172758;
    entry_172754(rdram, ctx, runtime);
}

void entry_1727f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1727f8 inside UpdateJtTool__FP2JT (0x1727b0 - 0x172828)
    ctx->pc = 0x1727f8;
    UpdateJtTool__FP2JT(rdram, ctx, runtime);
}

void entry_172830(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172830 inside entry_172828 (0x172828 - 0x172868)
    ctx->pc = 0x172830;
    entry_172828(rdram, ctx, runtime);
}

void entry_17287c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17287c inside entry_172868 (0x172868 - 0x172898)
    ctx->pc = 0x17287c;
    entry_172868(rdram, ctx, runtime);
}

void entry_172880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172880 inside entry_172868 (0x172868 - 0x172898)
    ctx->pc = 0x172880;
    entry_172868(rdram, ctx, runtime);
}

void entry_1728e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1728e0 inside entry_1728c8 (0x1728c8 - 0x17292c)
    ctx->pc = 0x1728e0;
    entry_1728c8(rdram, ctx, runtime);
}

void entry_1728f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1728f0 inside entry_1728c8 (0x1728c8 - 0x17292c)
    ctx->pc = 0x1728f0;
    entry_1728c8(rdram, ctx, runtime);
}

void entry_172938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172938 inside entry_17292c (0x17292c - 0x172974)
    ctx->pc = 0x172938;
    entry_17292c(rdram, ctx, runtime);
}

void entry_172948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172948 inside entry_17292c (0x17292c - 0x172974)
    ctx->pc = 0x172948;
    entry_17292c(rdram, ctx, runtime);
}

void entry_172998(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172998 inside entry_172974 (0x172974 - 0x1729c4)
    ctx->pc = 0x172998;
    entry_172974(rdram, ctx, runtime);
}

void entry_1729a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1729a4 inside entry_172974 (0x172974 - 0x1729c4)
    ctx->pc = 0x1729a4;
    entry_172974(rdram, ctx, runtime);
}

void entry_1729bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1729bc inside entry_172974 (0x172974 - 0x1729c4)
    ctx->pc = 0x1729bc;
    entry_172974(rdram, ctx, runtime);
}

void entry_172a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172a28 inside entry_1729fc (0x1729fc - 0x172ab8)
    ctx->pc = 0x172a28;
    entry_1729fc(rdram, ctx, runtime);
}

void entry_172a40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172a40 inside entry_1729fc (0x1729fc - 0x172ab8)
    ctx->pc = 0x172a40;
    entry_1729fc(rdram, ctx, runtime);
}

void entry_172a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172a84 inside entry_1729fc (0x1729fc - 0x172ab8)
    ctx->pc = 0x172a84;
    entry_1729fc(rdram, ctx, runtime);
}

void entry_172a88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172a88 inside entry_1729fc (0x1729fc - 0x172ab8)
    ctx->pc = 0x172a88;
    entry_1729fc(rdram, ctx, runtime);
}

void entry_172a94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172a94 inside entry_1729fc (0x1729fc - 0x172ab8)
    ctx->pc = 0x172a94;
    entry_1729fc(rdram, ctx, runtime);
}

void entry_172ab0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172ab0 inside entry_1729fc (0x1729fc - 0x172ab8)
    ctx->pc = 0x172ab0;
    entry_1729fc(rdram, ctx, runtime);
}

void entry_172b78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172b78 inside entry_172b70 (0x172b70 - 0x172b88)
    ctx->pc = 0x172b78;
    entry_172b70(rdram, ctx, runtime);
}

void entry_172b7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172b7c inside entry_172b70 (0x172b70 - 0x172b88)
    ctx->pc = 0x172b7c;
    entry_172b70(rdram, ctx, runtime);
}

void entry_172bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172bb8 inside entry_172ba8 (0x172ba8 - 0x172bcc)
    ctx->pc = 0x172bb8;
    entry_172ba8(rdram, ctx, runtime);
}

void entry_172bdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172bdc inside entry_172bcc (0x172bcc - 0x172bf8)
    ctx->pc = 0x172bdc;
    entry_172bcc(rdram, ctx, runtime);
}

void entry_172c34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172c34 inside entry_172c20 (0x172c20 - 0x172c48)
    ctx->pc = 0x172c34;
    entry_172c20(rdram, ctx, runtime);
}

void entry_172c38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172c38 inside entry_172c20 (0x172c20 - 0x172c48)
    ctx->pc = 0x172c38;
    entry_172c20(rdram, ctx, runtime);
}

void entry_172c5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172c5c inside entry_172c48 (0x172c48 - 0x172c70)
    ctx->pc = 0x172c5c;
    entry_172c48(rdram, ctx, runtime);
}

void entry_172c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172c60 inside entry_172c48 (0x172c48 - 0x172c70)
    ctx->pc = 0x172c60;
    entry_172c48(rdram, ctx, runtime);
}

void entry_172c84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172c84 inside entry_172c70 (0x172c70 - 0x172c98)
    ctx->pc = 0x172c84;
    entry_172c70(rdram, ctx, runtime);
}

void entry_172c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172c88 inside entry_172c70 (0x172c70 - 0x172c98)
    ctx->pc = 0x172c88;
    entry_172c70(rdram, ctx, runtime);
}

void entry_172cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172cac inside entry_172c98 (0x172c98 - 0x172cc0)
    ctx->pc = 0x172cac;
    entry_172c98(rdram, ctx, runtime);
}

void entry_172cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172cb0 inside entry_172c98 (0x172c98 - 0x172cc0)
    ctx->pc = 0x172cb0;
    entry_172c98(rdram, ctx, runtime);
}

void entry_172cd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172cd4 inside entry_172cc0 (0x172cc0 - 0x172cf0)
    ctx->pc = 0x172cd4;
    entry_172cc0(rdram, ctx, runtime);
}

void entry_172cd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172cd8 inside entry_172cc0 (0x172cc0 - 0x172cf0)
    ctx->pc = 0x172cd8;
    entry_172cc0(rdram, ctx, runtime);
}

void entry_172d4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172d4c inside AddJtCustomXps__FP2JTP2SOiP3BSPT3PP2XP (0x172cf0 - 0x172db0)
    ctx->pc = 0x172d4c;
    AddJtCustomXps__FP2JTP2SOiP3BSPT3PP2XP(rdram, ctx, runtime);
}

void entry_172d68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172d68 inside AddJtCustomXps__FP2JTP2SOiP3BSPT3PP2XP (0x172cf0 - 0x172db0)
    ctx->pc = 0x172d68;
    AddJtCustomXps__FP2JTP2SOiP3BSPT3PP2XP(rdram, ctx, runtime);
}

void entry_172da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172da4 inside AddJtCustomXps__FP2JTP2SOiP3BSPT3PP2XP (0x172cf0 - 0x172db0)
    ctx->pc = 0x172da4;
    AddJtCustomXps__FP2JTP2SOiP3BSPT3PP2XP(rdram, ctx, runtime);
}

void entry_172db8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172db8 inside entry_172db0 (0x172db0 - 0x172dd4)
    ctx->pc = 0x172db8;
    entry_172db0(rdram, ctx, runtime);
}

void entry_172ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172ddc inside entry_172dd4 (0x172dd4 - 0x172df0)
    ctx->pc = 0x172ddc;
    entry_172dd4(rdram, ctx, runtime);
}

void entry_172df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172df4 inside entry_172df0 (0x172df0 - 0x172e04)
    ctx->pc = 0x172df4;
    entry_172df0(rdram, ctx, runtime);
}

void entry_172df8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172df8 inside entry_172df0 (0x172df0 - 0x172e04)
    ctx->pc = 0x172df8;
    entry_172df0(rdram, ctx, runtime);
}

void entry_172dfc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172dfc inside entry_172df0 (0x172df0 - 0x172e04)
    ctx->pc = 0x172dfc;
    entry_172df0(rdram, ctx, runtime);
}

void entry_172e48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172e48 inside entry_172e24 (0x172e24 - 0x172e88)
    ctx->pc = 0x172e48;
    entry_172e24(rdram, ctx, runtime);
}

void entry_172e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172e90 inside entry_172e88 (0x172e88 - 0x172eb8)
    ctx->pc = 0x172e90;
    entry_172e88(rdram, ctx, runtime);
}

void entry_172e98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172e98 inside entry_172e88 (0x172e88 - 0x172eb8)
    ctx->pc = 0x172e98;
    entry_172e88(rdram, ctx, runtime);
}

void entry_172e9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172e9c inside entry_172e88 (0x172e88 - 0x172eb8)
    ctx->pc = 0x172e9c;
    entry_172e88(rdram, ctx, runtime);
}

void entry_172ea0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172ea0 inside entry_172e88 (0x172e88 - 0x172eb8)
    ctx->pc = 0x172ea0;
    entry_172e88(rdram, ctx, runtime);
}

void entry_172ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172ed0 inside CtTorqueJt__FP2JT (0x172eb8 - 0x172ee0)
    ctx->pc = 0x172ed0;
    CtTorqueJt__FP2JT(rdram, ctx, runtime);
}

void entry_172ed8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172ed8 inside CtTorqueJt__FP2JT (0x172eb8 - 0x172ee0)
    ctx->pc = 0x172ed8;
    CtTorqueJt__FP2JT(rdram, ctx, runtime);
}

void entry_172fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172fe8 inside entry_172f90 (0x172f90 - 0x173038)
    ctx->pc = 0x172fe8;
    entry_172f90(rdram, ctx, runtime);
}

void entry_172ff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x172ff4 inside entry_172f90 (0x172f90 - 0x173038)
    ctx->pc = 0x172ff4;
    entry_172f90(rdram, ctx, runtime);
}

void entry_173024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173024 inside entry_172f90 (0x172f90 - 0x173038)
    ctx->pc = 0x173024;
    entry_172f90(rdram, ctx, runtime);
}

void entry_173050(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173050 inside entry_173038 (0x173038 - 0x173110)
    ctx->pc = 0x173050;
    entry_173038(rdram, ctx, runtime);
}

void entry_173060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173060 inside entry_173038 (0x173038 - 0x173110)
    ctx->pc = 0x173060;
    entry_173038(rdram, ctx, runtime);
}

void entry_173084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173084 inside entry_173038 (0x173038 - 0x173110)
    ctx->pc = 0x173084;
    entry_173038(rdram, ctx, runtime);
}

void entry_173088(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173088 inside entry_173038 (0x173038 - 0x173110)
    ctx->pc = 0x173088;
    entry_173038(rdram, ctx, runtime);
}

void entry_1730bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1730bc inside entry_173038 (0x173038 - 0x173110)
    ctx->pc = 0x1730bc;
    entry_173038(rdram, ctx, runtime);
}

void entry_1730d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1730d0 inside entry_173038 (0x173038 - 0x173110)
    ctx->pc = 0x1730d0;
    entry_173038(rdram, ctx, runtime);
}

void entry_1730f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1730f4 inside entry_173038 (0x173038 - 0x173110)
    ctx->pc = 0x1730f4;
    entry_173038(rdram, ctx, runtime);
}

void entry_173148(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173148 inside entry_173110 (0x173110 - 0x17318c)
    ctx->pc = 0x173148;
    entry_173110(rdram, ctx, runtime);
}

void entry_17315c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17315c inside entry_173110 (0x173110 - 0x17318c)
    ctx->pc = 0x17315c;
    entry_173110(rdram, ctx, runtime);
}

void entry_173160(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173160 inside entry_173110 (0x173110 - 0x17318c)
    ctx->pc = 0x173160;
    entry_173110(rdram, ctx, runtime);
}

void entry_173164(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173164 inside entry_173110 (0x173110 - 0x17318c)
    ctx->pc = 0x173164;
    entry_173110(rdram, ctx, runtime);
}

void entry_173190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173190 inside entry_17318c (0x17318c - 0x1731ac)
    ctx->pc = 0x173190;
    entry_17318c(rdram, ctx, runtime);
}

void entry_1731c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1731c4 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x1731c4;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_1731e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1731e8 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x1731e8;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_1731fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1731fc inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x1731fc;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173210(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173210 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173210;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173240 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173240;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173244 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173244;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_17324c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17324c inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x17324c;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173250(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173250 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173250;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173258 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173258;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_17327c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17327c inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x17327c;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_17328c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17328c inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x17328c;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173294(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173294 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173294;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173298(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173298 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173298;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_17329c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17329c inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x17329c;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_1732ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1732ac inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x1732ac;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_1732dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1732dc inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x1732dc;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_1732f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1732f4 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x1732f4;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173340 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173340;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173350 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173350;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173360 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173360;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_17338c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17338c inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x17338c;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173390 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173390;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173394 inside entry_1731ac (0x1731ac - 0x1733b8)
    ctx->pc = 0x173394;
    entry_1731ac(rdram, ctx, runtime);
}

void entry_173420(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173420 inside entry_1733e0 (0x1733e0 - 0x1734f0)
    ctx->pc = 0x173420;
    entry_1733e0(rdram, ctx, runtime);
}

void entry_173480(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173480 inside entry_1733e0 (0x1733e0 - 0x1734f0)
    ctx->pc = 0x173480;
    entry_1733e0(rdram, ctx, runtime);
}

void entry_173488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173488 inside entry_1733e0 (0x1733e0 - 0x1734f0)
    ctx->pc = 0x173488;
    entry_1733e0(rdram, ctx, runtime);
}

void entry_1734cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1734cc inside entry_1733e0 (0x1733e0 - 0x1734f0)
    ctx->pc = 0x1734cc;
    entry_1733e0(rdram, ctx, runtime);
}

void entry_1734d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1734d0 inside entry_1733e0 (0x1733e0 - 0x1734f0)
    ctx->pc = 0x1734d0;
    entry_1733e0(rdram, ctx, runtime);
}

void entry_173518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173518 inside entry_173508 (0x173508 - 0x1735e0)
    ctx->pc = 0x173518;
    entry_173508(rdram, ctx, runtime);
}

void entry_173554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173554 inside entry_173508 (0x173508 - 0x1735e0)
    ctx->pc = 0x173554;
    entry_173508(rdram, ctx, runtime);
}

void entry_173584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173584 inside entry_173508 (0x173508 - 0x1735e0)
    ctx->pc = 0x173584;
    entry_173508(rdram, ctx, runtime);
}

void entry_173594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173594 inside entry_173508 (0x173508 - 0x1735e0)
    ctx->pc = 0x173594;
    entry_173508(rdram, ctx, runtime);
}

void entry_1735a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1735a4 inside entry_173508 (0x173508 - 0x1735e0)
    ctx->pc = 0x1735a4;
    entry_173508(rdram, ctx, runtime);
}

void entry_1735b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1735b0 inside entry_173508 (0x173508 - 0x1735e0)
    ctx->pc = 0x1735b0;
    entry_173508(rdram, ctx, runtime);
}

void entry_173650(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173650 inside entry_1735e0 (0x1735e0 - 0x1736e4)
    ctx->pc = 0x173650;
    entry_1735e0(rdram, ctx, runtime);
}

void entry_173668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173668 inside entry_1735e0 (0x1735e0 - 0x1736e4)
    ctx->pc = 0x173668;
    entry_1735e0(rdram, ctx, runtime);
}

void entry_1736ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1736ac inside entry_1735e0 (0x1735e0 - 0x1736e4)
    ctx->pc = 0x1736ac;
    entry_1735e0(rdram, ctx, runtime);
}

void entry_1736c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1736c0 inside entry_1735e0 (0x1735e0 - 0x1736e4)
    ctx->pc = 0x1736c0;
    entry_1735e0(rdram, ctx, runtime);
}

void entry_1736c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1736c4 inside entry_1735e0 (0x1735e0 - 0x1736e4)
    ctx->pc = 0x1736c4;
    entry_1735e0(rdram, ctx, runtime);
}

void entry_1736f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1736f0 inside entry_1736e4 (0x1736e4 - 0x173708)
    ctx->pc = 0x1736f0;
    entry_1736e4(rdram, ctx, runtime);
}

void entry_1736f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1736f4 inside entry_1736e4 (0x1736e4 - 0x173708)
    ctx->pc = 0x1736f4;
    entry_1736e4(rdram, ctx, runtime);
}

void entry_173730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173730 inside entry_17371c (0x17371c - 0x17373c)
    ctx->pc = 0x173730;
    entry_17371c(rdram, ctx, runtime);
}

void entry_173734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173734 inside entry_17371c (0x17371c - 0x17373c)
    ctx->pc = 0x173734;
    entry_17371c(rdram, ctx, runtime);
}

void entry_1737c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1737c8 inside entry_1737b8 (0x1737b8 - 0x1737e8)
    ctx->pc = 0x1737c8;
    entry_1737b8(rdram, ctx, runtime);
}

void entry_173808(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173808 inside entry_1737e8 (0x1737e8 - 0x173838)
    ctx->pc = 0x173808;
    entry_1737e8(rdram, ctx, runtime);
}

void entry_173840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173840 inside entry_173838 (0x173838 - 0x173868)
    ctx->pc = 0x173840;
    entry_173838(rdram, ctx, runtime);
}

void entry_173844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173844 inside entry_173838 (0x173838 - 0x173868)
    ctx->pc = 0x173844;
    entry_173838(rdram, ctx, runtime);
}

void entry_17384c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17384c inside entry_173838 (0x173838 - 0x173868)
    ctx->pc = 0x17384c;
    entry_173838(rdram, ctx, runtime);
}

void entry_173860(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173860 inside entry_173838 (0x173838 - 0x173868)
    ctx->pc = 0x173860;
    entry_173838(rdram, ctx, runtime);
}

void entry_17386c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17386c inside entry_173868 (0x173868 - 0x173888)
    ctx->pc = 0x17386c;
    entry_173868(rdram, ctx, runtime);
}

void entry_1738ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1738ec inside entry_1738c0 (0x1738c0 - 0x1738f4)
    ctx->pc = 0x1738ec;
    entry_1738c0(rdram, ctx, runtime);
}

void entry_1738f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1738f8 inside entry_1738f4 (0x1738f4 - 0x173978)
    ctx->pc = 0x1738f8;
    entry_1738f4(rdram, ctx, runtime);
}

void entry_173928(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173928 inside entry_1738f4 (0x1738f4 - 0x173978)
    ctx->pc = 0x173928;
    entry_1738f4(rdram, ctx, runtime);
}

void entry_17394c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17394c inside entry_1738f4 (0x1738f4 - 0x173978)
    ctx->pc = 0x17394c;
    entry_1738f4(rdram, ctx, runtime);
}

void entry_173980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173980 inside entry_173978 (0x173978 - 0x1739c4)
    ctx->pc = 0x173980;
    entry_173978(rdram, ctx, runtime);
}

void entry_1739cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1739cc inside entry_1739c4 (0x1739c4 - 0x1739dc)
    ctx->pc = 0x1739cc;
    entry_1739c4(rdram, ctx, runtime);
}

void entry_1739f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1739f0 inside entry_1739e8 (0x1739e8 - 0x173a2c)
    ctx->pc = 0x1739f0;
    entry_1739e8(rdram, ctx, runtime);
}

void entry_173a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173a1c inside entry_1739e8 (0x1739e8 - 0x173a2c)
    ctx->pc = 0x173a1c;
    entry_1739e8(rdram, ctx, runtime);
}

void entry_173a30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173a30 inside entry_173a2c (0x173a2c - 0x173a3c)
    ctx->pc = 0x173a30;
    entry_173a2c(rdram, ctx, runtime);
}

void entry_173a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173a34 inside entry_173a2c (0x173a2c - 0x173a3c)
    ctx->pc = 0x173a34;
    entry_173a2c(rdram, ctx, runtime);
}

void entry_173a44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173a44 inside entry_173a3c (0x173a3c - 0x173a64)
    ctx->pc = 0x173a44;
    entry_173a3c(rdram, ctx, runtime);
}

void entry_173ab8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173ab8 inside entry_173a64 (0x173a64 - 0x173ae0)
    ctx->pc = 0x173ab8;
    entry_173a64(rdram, ctx, runtime);
}

void entry_173afc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173afc inside entry_173af4 (0x173af4 - 0x173b20)
    ctx->pc = 0x173afc;
    entry_173af4(rdram, ctx, runtime);
}

void entry_173b00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173b00 inside entry_173af4 (0x173af4 - 0x173b20)
    ctx->pc = 0x173b00;
    entry_173af4(rdram, ctx, runtime);
}

void entry_173b10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173b10 inside entry_173af4 (0x173af4 - 0x173b20)
    ctx->pc = 0x173b10;
    entry_173af4(rdram, ctx, runtime);
}

void entry_173b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173b14 inside entry_173af4 (0x173af4 - 0x173b20)
    ctx->pc = 0x173b14;
    entry_173af4(rdram, ctx, runtime);
}

void entry_173b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173b38 inside entry_173b30 (0x173b30 - 0x173b4c)
    ctx->pc = 0x173b38;
    entry_173b30(rdram, ctx, runtime);
}

void entry_173b50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173b50 inside entry_173b4c (0x173b4c - 0x173b58)
    ctx->pc = 0x173b50;
    entry_173b4c(rdram, ctx, runtime);
}

void entry_173b60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173b60 inside entry_173b58 (0x173b58 - 0x173b68)
    ctx->pc = 0x173b60;
    entry_173b58(rdram, ctx, runtime);
}

void entry_173b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173b6c inside entry_173b68 (0x173b68 - 0x173b84)
    ctx->pc = 0x173b6c;
    entry_173b68(rdram, ctx, runtime);
}

void entry_173c0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173c0c inside entry_173b90 (0x173b90 - 0x173c88)
    ctx->pc = 0x173c0c;
    entry_173b90(rdram, ctx, runtime);
}

void entry_173c94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173c94 inside entry_173c88 (0x173c88 - 0x173cf8)
    ctx->pc = 0x173c94;
    entry_173c88(rdram, ctx, runtime);
}

void entry_173d00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173d00 inside entry_173cf8 (0x173cf8 - 0x173e30)
    ctx->pc = 0x173d00;
    entry_173cf8(rdram, ctx, runtime);
}

void entry_173d04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173d04 inside entry_173cf8 (0x173cf8 - 0x173e30)
    ctx->pc = 0x173d04;
    entry_173cf8(rdram, ctx, runtime);
}

void entry_173d1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173d1c inside entry_173cf8 (0x173cf8 - 0x173e30)
    ctx->pc = 0x173d1c;
    entry_173cf8(rdram, ctx, runtime);
}

void entry_173d5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173d5c inside entry_173cf8 (0x173cf8 - 0x173e30)
    ctx->pc = 0x173d5c;
    entry_173cf8(rdram, ctx, runtime);
}

void entry_173d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173d60 inside entry_173cf8 (0x173cf8 - 0x173e30)
    ctx->pc = 0x173d60;
    entry_173cf8(rdram, ctx, runtime);
}

void entry_173df4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173df4 inside entry_173cf8 (0x173cf8 - 0x173e30)
    ctx->pc = 0x173df4;
    entry_173cf8(rdram, ctx, runtime);
}

void entry_173e18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173e18 inside entry_173cf8 (0x173cf8 - 0x173e30)
    ctx->pc = 0x173e18;
    entry_173cf8(rdram, ctx, runtime);
}

void entry_173e38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173e38 inside entry_173e30 (0x173e30 - 0x173e8c)
    ctx->pc = 0x173e38;
    entry_173e30(rdram, ctx, runtime);
}

void entry_173e3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173e3c inside entry_173e30 (0x173e30 - 0x173e8c)
    ctx->pc = 0x173e3c;
    entry_173e30(rdram, ctx, runtime);
}

void entry_173e5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173e5c inside entry_173e30 (0x173e30 - 0x173e8c)
    ctx->pc = 0x173e5c;
    entry_173e30(rdram, ctx, runtime);
}

void entry_173e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173e80 inside entry_173e30 (0x173e30 - 0x173e8c)
    ctx->pc = 0x173e80;
    entry_173e30(rdram, ctx, runtime);
}

void entry_173ec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173ec0 inside entry_173e9c (0x173e9c - 0x173f34)
    ctx->pc = 0x173ec0;
    entry_173e9c(rdram, ctx, runtime);
}

void entry_173ec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173ec8 inside entry_173e9c (0x173e9c - 0x173f34)
    ctx->pc = 0x173ec8;
    entry_173e9c(rdram, ctx, runtime);
}

void entry_173f2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173f2c inside entry_173e9c (0x173e9c - 0x173f34)
    ctx->pc = 0x173f2c;
    entry_173e9c(rdram, ctx, runtime);
}

void entry_173f48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173f48 inside entry_173f40 (0x173f40 - 0x173fcc)
    ctx->pc = 0x173f48;
    entry_173f40(rdram, ctx, runtime);
}

void entry_173f4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173f4c inside entry_173f40 (0x173f40 - 0x173fcc)
    ctx->pc = 0x173f4c;
    entry_173f40(rdram, ctx, runtime);
}

void entry_173f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173f68 inside entry_173f40 (0x173f40 - 0x173fcc)
    ctx->pc = 0x173f68;
    entry_173f40(rdram, ctx, runtime);
}

void entry_173f88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173f88 inside entry_173f40 (0x173f40 - 0x173fcc)
    ctx->pc = 0x173f88;
    entry_173f40(rdram, ctx, runtime);
}

void entry_173fc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173fc4 inside entry_173f40 (0x173f40 - 0x173fcc)
    ctx->pc = 0x173fc4;
    entry_173f40(rdram, ctx, runtime);
}

void entry_173fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173fd4 inside entry_173fcc (0x173fcc - 0x173ff8)
    ctx->pc = 0x173fd4;
    entry_173fcc(rdram, ctx, runtime);
}

void entry_173fe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173fe0 inside entry_173fcc (0x173fcc - 0x173ff8)
    ctx->pc = 0x173fe0;
    entry_173fcc(rdram, ctx, runtime);
}

void entry_173fe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173fe8 inside entry_173fcc (0x173fcc - 0x173ff8)
    ctx->pc = 0x173fe8;
    entry_173fcc(rdram, ctx, runtime);
}

void entry_173fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x173fec inside entry_173fcc (0x173fcc - 0x173ff8)
    ctx->pc = 0x173fec;
    entry_173fcc(rdram, ctx, runtime);
}

void entry_174000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174000 inside entry_173ff8 (0x173ff8 - 0x174038)
    ctx->pc = 0x174000;
    entry_173ff8(rdram, ctx, runtime);
}

void entry_174004(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174004 inside entry_173ff8 (0x173ff8 - 0x174038)
    ctx->pc = 0x174004;
    entry_173ff8(rdram, ctx, runtime);
}

void entry_174064(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174064 inside entry_174058 (0x174058 - 0x17409c)
    ctx->pc = 0x174064;
    entry_174058(rdram, ctx, runtime);
}

void entry_174068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174068 inside entry_174058 (0x174058 - 0x17409c)
    ctx->pc = 0x174068;
    entry_174058(rdram, ctx, runtime);
}

void entry_1740c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1740c8 inside entry_17409c (0x17409c - 0x1740e8)
    ctx->pc = 0x1740c8;
    entry_17409c(rdram, ctx, runtime);
}

void entry_1740f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1740f4 inside entry_1740e8 (0x1740e8 - 0x174108)
    ctx->pc = 0x1740f4;
    entry_1740e8(rdram, ctx, runtime);
}

void entry_17419c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17419c inside entry_174164 (0x174164 - 0x1741b4)
    ctx->pc = 0x17419c;
    entry_174164(rdram, ctx, runtime);
}

void entry_1741c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1741c0 inside entry_1741b4 (0x1741b4 - 0x1741d4)
    ctx->pc = 0x1741c0;
    entry_1741b4(rdram, ctx, runtime);
}

void entry_174280(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174280 inside entry_174270 (0x174270 - 0x1742d4)
    ctx->pc = 0x174280;
    entry_174270(rdram, ctx, runtime);
}

void entry_174288(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174288 inside entry_174270 (0x174270 - 0x1742d4)
    ctx->pc = 0x174288;
    entry_174270(rdram, ctx, runtime);
}

void entry_1742dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1742dc inside entry_1742d4 (0x1742d4 - 0x174378)
    ctx->pc = 0x1742dc;
    entry_1742d4(rdram, ctx, runtime);
}

void entry_174354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174354 inside entry_1742d4 (0x1742d4 - 0x174378)
    ctx->pc = 0x174354;
    entry_1742d4(rdram, ctx, runtime);
}

void entry_174398(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174398 inside entry_174390 (0x174390 - 0x1743c8)
    ctx->pc = 0x174398;
    entry_174390(rdram, ctx, runtime);
}

void entry_1743b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1743b4 inside entry_174390 (0x174390 - 0x1743c8)
    ctx->pc = 0x1743b4;
    entry_174390(rdram, ctx, runtime);
}

void entry_1743e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1743e0 inside entry_1743d8 (0x1743d8 - 0x1743f8)
    ctx->pc = 0x1743e0;
    entry_1743d8(rdram, ctx, runtime);
}

void entry_174414(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174414 inside entry_17440c (0x17440c - 0x174424)
    ctx->pc = 0x174414;
    entry_17440c(rdram, ctx, runtime);
}

void entry_174448(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174448 inside entry_174424 (0x174424 - 0x1744b8)
    ctx->pc = 0x174448;
    entry_174424(rdram, ctx, runtime);
}

void entry_174488(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174488 inside entry_174424 (0x174424 - 0x1744b8)
    ctx->pc = 0x174488;
    entry_174424(rdram, ctx, runtime);
}

void entry_174494(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174494 inside entry_174424 (0x174424 - 0x1744b8)
    ctx->pc = 0x174494;
    entry_174424(rdram, ctx, runtime);
}

void entry_17449c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17449c inside entry_174424 (0x174424 - 0x1744b8)
    ctx->pc = 0x17449c;
    entry_174424(rdram, ctx, runtime);
}

void entry_1744c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1744c8 inside entry_1744b8 (0x1744b8 - 0x174508)
    ctx->pc = 0x1744c8;
    entry_1744b8(rdram, ctx, runtime);
}

void entry_1744d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1744d0 inside entry_1744b8 (0x1744b8 - 0x174508)
    ctx->pc = 0x1744d0;
    entry_1744b8(rdram, ctx, runtime);
}

void entry_17451c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17451c inside entry_174508 (0x174508 - 0x174548)
    ctx->pc = 0x17451c;
    entry_174508(rdram, ctx, runtime);
}

void entry_174550(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174550 inside entry_174548 (0x174548 - 0x1746a4)
    ctx->pc = 0x174550;
    entry_174548(rdram, ctx, runtime);
}

void entry_174590(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174590 inside entry_174548 (0x174548 - 0x1746a4)
    ctx->pc = 0x174590;
    entry_174548(rdram, ctx, runtime);
}

void entry_174598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174598 inside entry_174548 (0x174548 - 0x1746a4)
    ctx->pc = 0x174598;
    entry_174548(rdram, ctx, runtime);
}

void entry_1745dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1745dc inside entry_174548 (0x174548 - 0x1746a4)
    ctx->pc = 0x1745dc;
    entry_174548(rdram, ctx, runtime);
}

void entry_17461c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17461c inside entry_174548 (0x174548 - 0x1746a4)
    ctx->pc = 0x17461c;
    entry_174548(rdram, ctx, runtime);
}

void entry_174620(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174620 inside entry_174548 (0x174548 - 0x1746a4)
    ctx->pc = 0x174620;
    entry_174548(rdram, ctx, runtime);
}

void entry_174668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174668 inside entry_174548 (0x174548 - 0x1746a4)
    ctx->pc = 0x174668;
    entry_174548(rdram, ctx, runtime);
}

void entry_17467c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17467c inside entry_174548 (0x174548 - 0x1746a4)
    ctx->pc = 0x17467c;
    entry_174548(rdram, ctx, runtime);
}

void entry_174680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174680 inside entry_174548 (0x174548 - 0x1746a4)
    ctx->pc = 0x174680;
    entry_174548(rdram, ctx, runtime);
}

void entry_174684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174684 inside entry_174548 (0x174548 - 0x1746a4)
    ctx->pc = 0x174684;
    entry_174548(rdram, ctx, runtime);
}

void entry_1747d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1747d8 inside entry_1747d4 (0x1747d4 - 0x174808)
    ctx->pc = 0x1747d8;
    entry_1747d4(rdram, ctx, runtime);
}

void entry_17485c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17485c inside entry_174858 (0x174858 - 0x1748cc)
    ctx->pc = 0x17485c;
    entry_174858(rdram, ctx, runtime);
}

void entry_174890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174890 inside entry_174858 (0x174858 - 0x1748cc)
    ctx->pc = 0x174890;
    entry_174858(rdram, ctx, runtime);
}

void entry_174894(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174894 inside entry_174858 (0x174858 - 0x1748cc)
    ctx->pc = 0x174894;
    entry_174858(rdram, ctx, runtime);
}

void entry_174a34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174a34 inside entry_1749fc (0x1749fc - 0x174a60)
    ctx->pc = 0x174a34;
    entry_1749fc(rdram, ctx, runtime);
}

void entry_174a48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174a48 inside entry_1749fc (0x1749fc - 0x174a60)
    ctx->pc = 0x174a48;
    entry_1749fc(rdram, ctx, runtime);
}

void entry_174a58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174a58 inside entry_1749fc (0x1749fc - 0x174a60)
    ctx->pc = 0x174a58;
    entry_1749fc(rdram, ctx, runtime);
}

void entry_174af0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174af0 inside entry_174a70 (0x174a70 - 0x174b04)
    ctx->pc = 0x174af0;
    entry_174a70(rdram, ctx, runtime);
}

void entry_174af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174af8 inside entry_174a70 (0x174a70 - 0x174b04)
    ctx->pc = 0x174af8;
    entry_174a70(rdram, ctx, runtime);
}

void entry_174b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174b0c inside entry_174b04 (0x174b04 - 0x174b2c)
    ctx->pc = 0x174b0c;
    entry_174b04(rdram, ctx, runtime);
}

void entry_174b88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174b88 inside entry_174b7c (0x174b7c - 0x174bb8)
    ctx->pc = 0x174b88;
    entry_174b7c(rdram, ctx, runtime);
}

void entry_174b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174b94 inside entry_174b7c (0x174b7c - 0x174bb8)
    ctx->pc = 0x174b94;
    entry_174b7c(rdram, ctx, runtime);
}

void entry_174bf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174bf0 inside entry_174be8 (0x174be8 - 0x174c00)
    ctx->pc = 0x174bf0;
    entry_174be8(rdram, ctx, runtime);
}

void entry_174c08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174c08 inside entry_174c00 (0x174c00 - 0x174c48)
    ctx->pc = 0x174c08;
    entry_174c00(rdram, ctx, runtime);
}

void entry_174c30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174c30 inside entry_174c00 (0x174c00 - 0x174c48)
    ctx->pc = 0x174c30;
    entry_174c00(rdram, ctx, runtime);
}

void entry_174c9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174c9c inside entry_174c7c (0x174c7c - 0x174cd8)
    ctx->pc = 0x174c9c;
    entry_174c7c(rdram, ctx, runtime);
}

void entry_174cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174cb8 inside entry_174c7c (0x174c7c - 0x174cd8)
    ctx->pc = 0x174cb8;
    entry_174c7c(rdram, ctx, runtime);
}

void entry_174d0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174d0c inside entry_174cd8 (0x174cd8 - 0x174d7c)
    ctx->pc = 0x174d0c;
    entry_174cd8(rdram, ctx, runtime);
}

void entry_174d10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174d10 inside entry_174cd8 (0x174cd8 - 0x174d7c)
    ctx->pc = 0x174d10;
    entry_174cd8(rdram, ctx, runtime);
}

void entry_174d28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174d28 inside entry_174cd8 (0x174cd8 - 0x174d7c)
    ctx->pc = 0x174d28;
    entry_174cd8(rdram, ctx, runtime);
}

void entry_174d40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174d40 inside entry_174cd8 (0x174cd8 - 0x174d7c)
    ctx->pc = 0x174d40;
    entry_174cd8(rdram, ctx, runtime);
}

void entry_174d70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174d70 inside entry_174cd8 (0x174cd8 - 0x174d7c)
    ctx->pc = 0x174d70;
    entry_174cd8(rdram, ctx, runtime);
}

void entry_174d80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174d80 inside entry_174d7c (0x174d7c - 0x174d9c)
    ctx->pc = 0x174d80;
    entry_174d7c(rdram, ctx, runtime);
}

void entry_174da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174da4 inside entry_174d9c (0x174d9c - 0x174db8)
    ctx->pc = 0x174da4;
    entry_174d9c(rdram, ctx, runtime);
}

void entry_174dbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174dbc inside entry_174db8 (0x174db8 - 0x174dd0)
    ctx->pc = 0x174dbc;
    entry_174db8(rdram, ctx, runtime);
}

void entry_174dd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174dd4 inside entry_174dd0 (0x174dd0 - 0x174ddc)
    ctx->pc = 0x174dd4;
    entry_174dd0(rdram, ctx, runtime);
}

void entry_174e54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174e54 inside UpdateJtDrive__FP2JT (0x174e20 - 0x174e64)
    ctx->pc = 0x174e54;
    UpdateJtDrive__FP2JT(rdram, ctx, runtime);
}

void entry_174e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174e6c inside entry_174e64 (0x174e64 - 0x174e78)
    ctx->pc = 0x174e6c;
    entry_174e64(rdram, ctx, runtime);
}

void entry_174e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174e7c inside entry_174e78 (0x174e78 - 0x174e88)
    ctx->pc = 0x174e7c;
    entry_174e78(rdram, ctx, runtime);
}

void entry_174e80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174e80 inside entry_174e78 (0x174e78 - 0x174e88)
    ctx->pc = 0x174e80;
    entry_174e78(rdram, ctx, runtime);
}

void entry_174ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174ebc inside entry_174e88 (0x174e88 - 0x174ee8)
    ctx->pc = 0x174ebc;
    entry_174e88(rdram, ctx, runtime);
}

void entry_174f00(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174f00 inside entry_174ee8 (0x174ee8 - 0x174f38)
    ctx->pc = 0x174f00;
    entry_174ee8(rdram, ctx, runtime);
}

void entry_174f80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174f80 inside ChooseJtPhys__FP2JT (0x174f50 - 0x175068)
    ctx->pc = 0x174f80;
    ChooseJtPhys__FP2JT(rdram, ctx, runtime);
}

void entry_174f9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174f9c inside ChooseJtPhys__FP2JT (0x174f50 - 0x175068)
    ctx->pc = 0x174f9c;
    ChooseJtPhys__FP2JT(rdram, ctx, runtime);
}

void entry_174fb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174fb8 inside ChooseJtPhys__FP2JT (0x174f50 - 0x175068)
    ctx->pc = 0x174fb8;
    ChooseJtPhys__FP2JT(rdram, ctx, runtime);
}

void entry_174fcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x174fcc inside ChooseJtPhys__FP2JT (0x174f50 - 0x175068)
    ctx->pc = 0x174fcc;
    ChooseJtPhys__FP2JT(rdram, ctx, runtime);
}

void entry_175000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175000 inside ChooseJtPhys__FP2JT (0x174f50 - 0x175068)
    ctx->pc = 0x175000;
    ChooseJtPhys__FP2JT(rdram, ctx, runtime);
}

void entry_17502c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17502c inside ChooseJtPhys__FP2JT (0x174f50 - 0x175068)
    ctx->pc = 0x17502c;
    ChooseJtPhys__FP2JT(rdram, ctx, runtime);
}

void entry_175040(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175040 inside ChooseJtPhys__FP2JT (0x174f50 - 0x175068)
    ctx->pc = 0x175040;
    ChooseJtPhys__FP2JT(rdram, ctx, runtime);
}

void entry_175048(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175048 inside ChooseJtPhys__FP2JT (0x174f50 - 0x175068)
    ctx->pc = 0x175048;
    ChooseJtPhys__FP2JT(rdram, ctx, runtime);
}

void entry_17504c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17504c inside ChooseJtPhys__FP2JT (0x174f50 - 0x175068)
    ctx->pc = 0x17504c;
    ChooseJtPhys__FP2JT(rdram, ctx, runtime);
}

void entry_175058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175058 inside ChooseJtPhys__FP2JT (0x174f50 - 0x175068)
    ctx->pc = 0x175058;
    ChooseJtPhys__FP2JT(rdram, ctx, runtime);
}

void entry_175060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175060 inside ChooseJtPhys__FP2JT (0x174f50 - 0x175068)
    ctx->pc = 0x175060;
    ChooseJtPhys__FP2JT(rdram, ctx, runtime);
}

void entry_17506c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17506c inside entry_175068 (0x175068 - 0x175078)
    ctx->pc = 0x17506c;
    entry_175068(rdram, ctx, runtime);
}

void entry_1750a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1750a0 inside EnableJtActadj__FP2JTi (0x175078 - 0x17510c)
    ctx->pc = 0x1750a0;
    EnableJtActadj__FP2JTi(rdram, ctx, runtime);
}

void entry_1750b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1750b4 inside EnableJtActadj__FP2JTi (0x175078 - 0x17510c)
    ctx->pc = 0x1750b4;
    EnableJtActadj__FP2JTi(rdram, ctx, runtime);
}

void entry_1750c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1750c8 inside EnableJtActadj__FP2JTi (0x175078 - 0x17510c)
    ctx->pc = 0x1750c8;
    EnableJtActadj__FP2JTi(rdram, ctx, runtime);
}

void entry_1750e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1750e0 inside EnableJtActadj__FP2JTi (0x175078 - 0x17510c)
    ctx->pc = 0x1750e0;
    EnableJtActadj__FP2JTi(rdram, ctx, runtime);
}

void entry_1750f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1750f4 inside EnableJtActadj__FP2JTi (0x175078 - 0x17510c)
    ctx->pc = 0x1750f4;
    EnableJtActadj__FP2JTi(rdram, ctx, runtime);
}

void entry_1751f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1751f4 inside SetJtJts__FP2JT3JTS4JTBS (0x175170 - 0x175280)
    ctx->pc = 0x1751f4;
    SetJtJts__FP2JT3JTS4JTBS(rdram, ctx, runtime);
}

void entry_175310(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175310 inside entry_1752ac (0x1752ac - 0x175320)
    ctx->pc = 0x175310;
    entry_1752ac(rdram, ctx, runtime);
}

void entry_175360(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175360 inside entry_175328 (0x175328 - 0x175370)
    ctx->pc = 0x175360;
    entry_175328(rdram, ctx, runtime);
}

void entry_17540c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17540c inside entry_175408 (0x175408 - 0x175414)
    ctx->pc = 0x17540c;
    entry_175408(rdram, ctx, runtime);
}

void entry_175434(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175434 inside entry_175414 (0x175414 - 0x175444)
    ctx->pc = 0x175434;
    entry_175414(rdram, ctx, runtime);
}

void entry_17548c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17548c inside entry_175468 (0x175468 - 0x175494)
    ctx->pc = 0x17548c;
    entry_175468(rdram, ctx, runtime);
}

void entry_1754f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1754f0 inside entry_1754c8 (0x1754c8 - 0x175518)
    ctx->pc = 0x1754f0;
    entry_1754c8(rdram, ctx, runtime);
}

void entry_175508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175508 inside entry_1754c8 (0x1754c8 - 0x175518)
    ctx->pc = 0x175508;
    entry_1754c8(rdram, ctx, runtime);
}

void entry_175570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175570 inside entry_175568 (0x175568 - 0x175580)
    ctx->pc = 0x175570;
    entry_175568(rdram, ctx, runtime);
}

void entry_175584(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175584 inside entry_175580 (0x175580 - 0x1755c4)
    ctx->pc = 0x175584;
    entry_175580(rdram, ctx, runtime);
}

void entry_175604(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175604 inside entry_175600 (0x175600 - 0x175610)
    ctx->pc = 0x175604;
    entry_175600(rdram, ctx, runtime);
}

void entry_1756a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1756a4 inside entry_175698 (0x175698 - 0x175714)
    ctx->pc = 0x1756a4;
    entry_175698(rdram, ctx, runtime);
}

void entry_1756a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1756a8 inside entry_175698 (0x175698 - 0x175714)
    ctx->pc = 0x1756a8;
    entry_175698(rdram, ctx, runtime);
}

void entry_1756ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1756ac inside entry_175698 (0x175698 - 0x175714)
    ctx->pc = 0x1756ac;
    entry_175698(rdram, ctx, runtime);
}

void entry_1756e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1756e8 inside entry_175698 (0x175698 - 0x175714)
    ctx->pc = 0x1756e8;
    entry_175698(rdram, ctx, runtime);
}

void entry_1756ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1756ec inside entry_175698 (0x175698 - 0x175714)
    ctx->pc = 0x1756ec;
    entry_175698(rdram, ctx, runtime);
}

void entry_175718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175718 inside entry_175714 (0x175714 - 0x17572c)
    ctx->pc = 0x175718;
    entry_175714(rdram, ctx, runtime);
}

void entry_175730(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175730 inside entry_17572c (0x17572c - 0x175750)
    ctx->pc = 0x175730;
    entry_17572c(rdram, ctx, runtime);
}

void entry_175770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175770 inside entry_17575c (0x17575c - 0x175788)
    ctx->pc = 0x175770;
    entry_17575c(rdram, ctx, runtime);
}

void entry_175818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175818 inside entry_1757e8 (0x1757e8 - 0x175838)
    ctx->pc = 0x175818;
    entry_1757e8(rdram, ctx, runtime);
}

void entry_17582c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17582c inside entry_1757e8 (0x1757e8 - 0x175838)
    ctx->pc = 0x17582c;
    entry_1757e8(rdram, ctx, runtime);
}

void entry_175840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175840 inside entry_175838 (0x175838 - 0x17584c)
    ctx->pc = 0x175840;
    entry_175838(rdram, ctx, runtime);
}

void entry_175854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175854 inside entry_17584c (0x17584c - 0x17585c)
    ctx->pc = 0x175854;
    entry_17584c(rdram, ctx, runtime);
}

void entry_1758a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1758a4 inside entry_1758a0 (0x1758a0 - 0x175948)
    ctx->pc = 0x1758a4;
    entry_1758a0(rdram, ctx, runtime);
}

void entry_175914(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175914 inside entry_1758a0 (0x1758a0 - 0x175948)
    ctx->pc = 0x175914;
    entry_1758a0(rdram, ctx, runtime);
}

void entry_175934(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175934 inside entry_1758a0 (0x1758a0 - 0x175948)
    ctx->pc = 0x175934;
    entry_1758a0(rdram, ctx, runtime);
}

void entry_175938(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175938 inside entry_1758a0 (0x1758a0 - 0x175948)
    ctx->pc = 0x175938;
    entry_1758a0(rdram, ctx, runtime);
}

void entry_175958(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175958 inside entry_175948 (0x175948 - 0x175964)
    ctx->pc = 0x175958;
    entry_175948(rdram, ctx, runtime);
}

void entry_17595c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17595c inside entry_175948 (0x175948 - 0x175964)
    ctx->pc = 0x17595c;
    entry_175948(rdram, ctx, runtime);
}

void entry_175974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175974 inside entry_175964 (0x175964 - 0x175a00)
    ctx->pc = 0x175974;
    entry_175964(rdram, ctx, runtime);
}

void entry_1759a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1759a8 inside entry_175964 (0x175964 - 0x175a00)
    ctx->pc = 0x1759a8;
    entry_175964(rdram, ctx, runtime);
}

void entry_175af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175af8 inside entry_175ae4 (0x175ae4 - 0x175b38)
    ctx->pc = 0x175af8;
    entry_175ae4(rdram, ctx, runtime);
}

void entry_175b1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175b1c inside entry_175ae4 (0x175ae4 - 0x175b38)
    ctx->pc = 0x175b1c;
    entry_175ae4(rdram, ctx, runtime);
}

void entry_175b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175b2c inside entry_175ae4 (0x175ae4 - 0x175b38)
    ctx->pc = 0x175b2c;
    entry_175ae4(rdram, ctx, runtime);
}

void entry_175b58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175b58 inside entry_175b38 (0x175b38 - 0x175b88)
    ctx->pc = 0x175b58;
    entry_175b38(rdram, ctx, runtime);
}

void entry_175b68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175b68 inside entry_175b38 (0x175b38 - 0x175b88)
    ctx->pc = 0x175b68;
    entry_175b38(rdram, ctx, runtime);
}

void entry_175b6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175b6c inside entry_175b38 (0x175b38 - 0x175b88)
    ctx->pc = 0x175b6c;
    entry_175b38(rdram, ctx, runtime);
}

void entry_175b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175b70 inside entry_175b38 (0x175b38 - 0x175b88)
    ctx->pc = 0x175b70;
    entry_175b38(rdram, ctx, runtime);
}

void entry_175ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175ba0 inside entry_175b88 (0x175b88 - 0x175c00)
    ctx->pc = 0x175ba0;
    entry_175b88(rdram, ctx, runtime);
}

void entry_175bd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175bd8 inside entry_175b88 (0x175b88 - 0x175c00)
    ctx->pc = 0x175bd8;
    entry_175b88(rdram, ctx, runtime);
}

void entry_175bf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175bf8 inside entry_175b88 (0x175b88 - 0x175c00)
    ctx->pc = 0x175bf8;
    entry_175b88(rdram, ctx, runtime);
}

void entry_175c20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175c20 inside entry_175c18 (0x175c18 - 0x175c38)
    ctx->pc = 0x175c20;
    entry_175c18(rdram, ctx, runtime);
}

void entry_175c28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175c28 inside entry_175c18 (0x175c18 - 0x175c38)
    ctx->pc = 0x175c28;
    entry_175c18(rdram, ctx, runtime);
}

void entry_175ca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175ca4 inside entry_175c78 (0x175c78 - 0x175ce4)
    ctx->pc = 0x175ca4;
    entry_175c78(rdram, ctx, runtime);
}

void entry_175cb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175cb0 inside entry_175c78 (0x175c78 - 0x175ce4)
    ctx->pc = 0x175cb0;
    entry_175c78(rdram, ctx, runtime);
}

void entry_175cb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175cb8 inside entry_175c78 (0x175c78 - 0x175ce4)
    ctx->pc = 0x175cb8;
    entry_175c78(rdram, ctx, runtime);
}

void entry_175d98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175d98 inside entry_175d3c (0x175d3c - 0x175eac)
    ctx->pc = 0x175d98;
    entry_175d3c(rdram, ctx, runtime);
}

void entry_175da4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175da4 inside entry_175d3c (0x175d3c - 0x175eac)
    ctx->pc = 0x175da4;
    entry_175d3c(rdram, ctx, runtime);
}

void entry_175dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175dcc inside entry_175d3c (0x175d3c - 0x175eac)
    ctx->pc = 0x175dcc;
    entry_175d3c(rdram, ctx, runtime);
}

void entry_175dd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175dd0 inside entry_175d3c (0x175d3c - 0x175eac)
    ctx->pc = 0x175dd0;
    entry_175d3c(rdram, ctx, runtime);
}

void entry_175e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175e30 inside entry_175d3c (0x175d3c - 0x175eac)
    ctx->pc = 0x175e30;
    entry_175d3c(rdram, ctx, runtime);
}

void entry_175e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175e6c inside entry_175d3c (0x175d3c - 0x175eac)
    ctx->pc = 0x175e6c;
    entry_175d3c(rdram, ctx, runtime);
}

void entry_175e74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175e74 inside entry_175d3c (0x175d3c - 0x175eac)
    ctx->pc = 0x175e74;
    entry_175d3c(rdram, ctx, runtime);
}

void entry_175e88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175e88 inside entry_175d3c (0x175d3c - 0x175eac)
    ctx->pc = 0x175e88;
    entry_175d3c(rdram, ctx, runtime);
}

void entry_175e90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175e90 inside entry_175d3c (0x175d3c - 0x175eac)
    ctx->pc = 0x175e90;
    entry_175d3c(rdram, ctx, runtime);
}

void entry_175fd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175fd8 inside entry_175f6c (0x175f6c - 0x176004)
    ctx->pc = 0x175fd8;
    entry_175f6c(rdram, ctx, runtime);
}

void entry_175ff0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x175ff0 inside entry_175f6c (0x175f6c - 0x176004)
    ctx->pc = 0x175ff0;
    entry_175f6c(rdram, ctx, runtime);
}

void entry_176060(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176060 inside entry_176058 (0x176058 - 0x176070)
    ctx->pc = 0x176060;
    entry_176058(rdram, ctx, runtime);
}

void entry_176074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176074 inside entry_176070 (0x176070 - 0x1760b8)
    ctx->pc = 0x176074;
    entry_176070(rdram, ctx, runtime);
}

void entry_1761f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1761f4 inside entry_176198 (0x176198 - 0x176268)
    ctx->pc = 0x1761f4;
    entry_176198(rdram, ctx, runtime);
}

void entry_176200(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176200 inside entry_176198 (0x176198 - 0x176268)
    ctx->pc = 0x176200;
    entry_176198(rdram, ctx, runtime);
}

void entry_176240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176240 inside entry_176198 (0x176198 - 0x176268)
    ctx->pc = 0x176240;
    entry_176198(rdram, ctx, runtime);
}

void entry_1762d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1762d0 inside entry_1762b8 (0x1762b8 - 0x176310)
    ctx->pc = 0x1762d0;
    entry_1762b8(rdram, ctx, runtime);
}

void entry_1762e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1762e0 inside entry_1762b8 (0x1762b8 - 0x176310)
    ctx->pc = 0x1762e0;
    entry_1762b8(rdram, ctx, runtime);
}

void entry_17633c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17633c inside entry_176310 (0x176310 - 0x17637c)
    ctx->pc = 0x17633c;
    entry_176310(rdram, ctx, runtime);
}

void entry_176380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176380 inside entry_17637c (0x17637c - 0x176390)
    ctx->pc = 0x176380;
    entry_17637c(rdram, ctx, runtime);
}

void entry_1763b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1763b4 inside entry_176390 (0x176390 - 0x1763dc)
    ctx->pc = 0x1763b4;
    entry_176390(rdram, ctx, runtime);
}

void entry_1763c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1763c8 inside entry_176390 (0x176390 - 0x1763dc)
    ctx->pc = 0x1763c8;
    entry_176390(rdram, ctx, runtime);
}

void entry_176558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176558 inside entry_176544 (0x176544 - 0x17656c)
    ctx->pc = 0x176558;
    entry_176544(rdram, ctx, runtime);
}

void entry_176564(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176564 inside entry_176544 (0x176544 - 0x17656c)
    ctx->pc = 0x176564;
    entry_176544(rdram, ctx, runtime);
}

void entry_1765e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1765e4 inside entry_1765bc (0x1765bc - 0x1765f4)
    ctx->pc = 0x1765e4;
    entry_1765bc(rdram, ctx, runtime);
}

void entry_176614(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176614 inside entry_1765f4 (0x1765f4 - 0x176634)
    ctx->pc = 0x176614;
    entry_1765f4(rdram, ctx, runtime);
}

void entry_17661c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17661c inside entry_1765f4 (0x1765f4 - 0x176634)
    ctx->pc = 0x17661c;
    entry_1765f4(rdram, ctx, runtime);
}

void entry_1766fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1766fc inside entry_176634 (0x176634 - 0x176714)
    ctx->pc = 0x1766fc;
    entry_176634(rdram, ctx, runtime);
}

void entry_176718(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176718 inside entry_176714 (0x176714 - 0x176730)
    ctx->pc = 0x176718;
    entry_176714(rdram, ctx, runtime);
}

void entry_176758(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176758 inside entry_176754 (0x176754 - 0x176770)
    ctx->pc = 0x176758;
    entry_176754(rdram, ctx, runtime);
}

void entry_176828(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176828 inside entry_176824 (0x176824 - 0x1768cc)
    ctx->pc = 0x176828;
    entry_176824(rdram, ctx, runtime);
}

void entry_176924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176924 inside entry_1768d8 (0x1768d8 - 0x176988)
    ctx->pc = 0x176924;
    entry_1768d8(rdram, ctx, runtime);
}

void entry_176948(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176948 inside entry_1768d8 (0x1768d8 - 0x176988)
    ctx->pc = 0x176948;
    entry_1768d8(rdram, ctx, runtime);
}

void entry_176950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176950 inside entry_1768d8 (0x1768d8 - 0x176988)
    ctx->pc = 0x176950;
    entry_1768d8(rdram, ctx, runtime);
}

void entry_176994(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176994 inside entry_176988 (0x176988 - 0x1769ac)
    ctx->pc = 0x176994;
    entry_176988(rdram, ctx, runtime);
}

void entry_176a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176a08 inside entry_1769ac (0x1769ac - 0x176a14)
    ctx->pc = 0x176a08;
    entry_1769ac(rdram, ctx, runtime);
}

void entry_176a1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176a1c inside entry_176a14 (0x176a14 - 0x176a44)
    ctx->pc = 0x176a1c;
    entry_176a14(rdram, ctx, runtime);
}

void entry_176a20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176a20 inside entry_176a14 (0x176a14 - 0x176a44)
    ctx->pc = 0x176a20;
    entry_176a14(rdram, ctx, runtime);
}

void entry_176a5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176a5c inside entry_176a44 (0x176a44 - 0x176a68)
    ctx->pc = 0x176a5c;
    entry_176a44(rdram, ctx, runtime);
}

void entry_176aa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176aa4 inside entry_176a90 (0x176a90 - 0x176ad4)
    ctx->pc = 0x176aa4;
    entry_176a90(rdram, ctx, runtime);
}

void entry_176ca8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176ca8 inside entry_176c34 (0x176c34 - 0x176cc4)
    ctx->pc = 0x176ca8;
    entry_176c34(rdram, ctx, runtime);
}

void entry_176cac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176cac inside entry_176c34 (0x176c34 - 0x176cc4)
    ctx->pc = 0x176cac;
    entry_176c34(rdram, ctx, runtime);
}

void entry_176ce8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176ce8 inside entry_176ce4 (0x176ce4 - 0x176d00)
    ctx->pc = 0x176ce8;
    entry_176ce4(rdram, ctx, runtime);
}

void entry_176d88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176d88 inside entry_176d84 (0x176d84 - 0x176d98)
    ctx->pc = 0x176d88;
    entry_176d84(rdram, ctx, runtime);
}

void entry_176e20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176e20 inside entry_176d98 (0x176d98 - 0x176ec0)
    ctx->pc = 0x176e20;
    entry_176d98(rdram, ctx, runtime);
}

void entry_176e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176e28 inside entry_176d98 (0x176d98 - 0x176ec0)
    ctx->pc = 0x176e28;
    entry_176d98(rdram, ctx, runtime);
}

void entry_176e6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176e6c inside entry_176d98 (0x176d98 - 0x176ec0)
    ctx->pc = 0x176e6c;
    entry_176d98(rdram, ctx, runtime);
}

void entry_176e7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176e7c inside entry_176d98 (0x176d98 - 0x176ec0)
    ctx->pc = 0x176e7c;
    entry_176d98(rdram, ctx, runtime);
}

void entry_176eec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176eec inside entry_176ed8 (0x176ed8 - 0x176f24)
    ctx->pc = 0x176eec;
    entry_176ed8(rdram, ctx, runtime);
}

void entry_176f08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176f08 inside entry_176ed8 (0x176ed8 - 0x176f24)
    ctx->pc = 0x176f08;
    entry_176ed8(rdram, ctx, runtime);
}

void entry_176f18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176f18 inside entry_176ed8 (0x176ed8 - 0x176f24)
    ctx->pc = 0x176f18;
    entry_176ed8(rdram, ctx, runtime);
}

void entry_176f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176f64 inside entry_176f3c (0x176f3c - 0x176f8c)
    ctx->pc = 0x176f64;
    entry_176f3c(rdram, ctx, runtime);
}

void entry_176f68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176f68 inside entry_176f3c (0x176f3c - 0x176f8c)
    ctx->pc = 0x176f68;
    entry_176f3c(rdram, ctx, runtime);
}

void entry_176fd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176fd0 inside entry_176fcc (0x176fcc - 0x176fe4)
    ctx->pc = 0x176fd0;
    entry_176fcc(rdram, ctx, runtime);
}

void entry_176fec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x176fec inside entry_176fe4 (0x176fe4 - 0x177114)
    ctx->pc = 0x176fec;
    entry_176fe4(rdram, ctx, runtime);
}

void entry_177024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177024 inside entry_176fe4 (0x176fe4 - 0x177114)
    ctx->pc = 0x177024;
    entry_176fe4(rdram, ctx, runtime);
}

void entry_177038(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177038 inside entry_176fe4 (0x176fe4 - 0x177114)
    ctx->pc = 0x177038;
    entry_176fe4(rdram, ctx, runtime);
}

void entry_17705c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17705c inside entry_176fe4 (0x176fe4 - 0x177114)
    ctx->pc = 0x17705c;
    entry_176fe4(rdram, ctx, runtime);
}

void entry_177080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177080 inside entry_176fe4 (0x176fe4 - 0x177114)
    ctx->pc = 0x177080;
    entry_176fe4(rdram, ctx, runtime);
}

void entry_177278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177278 inside entry_177224 (0x177224 - 0x1772f8)
    ctx->pc = 0x177278;
    entry_177224(rdram, ctx, runtime);
}

void entry_1772d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1772d8 inside entry_177224 (0x177224 - 0x1772f8)
    ctx->pc = 0x1772d8;
    entry_177224(rdram, ctx, runtime);
}

void entry_1772ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1772ec inside entry_177224 (0x177224 - 0x1772f8)
    ctx->pc = 0x1772ec;
    entry_177224(rdram, ctx, runtime);
}

void entry_177334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177334 inside entry_177330 (0x177330 - 0x177398)
    ctx->pc = 0x177334;
    entry_177330(rdram, ctx, runtime);
}

void entry_177350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177350 inside entry_177330 (0x177330 - 0x177398)
    ctx->pc = 0x177350;
    entry_177330(rdram, ctx, runtime);
}

void entry_177368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177368 inside entry_177330 (0x177330 - 0x177398)
    ctx->pc = 0x177368;
    entry_177330(rdram, ctx, runtime);
}

void entry_17736c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17736c inside entry_177330 (0x177330 - 0x177398)
    ctx->pc = 0x17736c;
    entry_177330(rdram, ctx, runtime);
}

void entry_177408(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177408 inside entry_1773fc (0x1773fc - 0x177424)
    ctx->pc = 0x177408;
    entry_1773fc(rdram, ctx, runtime);
}

void entry_177474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177474 inside entry_177424 (0x177424 - 0x177500)
    ctx->pc = 0x177474;
    entry_177424(rdram, ctx, runtime);
}

void entry_177478(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177478 inside entry_177424 (0x177424 - 0x177500)
    ctx->pc = 0x177478;
    entry_177424(rdram, ctx, runtime);
}

void entry_1774e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1774e8 inside entry_177424 (0x177424 - 0x177500)
    ctx->pc = 0x1774e8;
    entry_177424(rdram, ctx, runtime);
}

void entry_177508(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177508 inside entry_177500 (0x177500 - 0x177568)
    ctx->pc = 0x177508;
    entry_177500(rdram, ctx, runtime);
}

void entry_177558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177558 inside entry_177500 (0x177500 - 0x177568)
    ctx->pc = 0x177558;
    entry_177500(rdram, ctx, runtime);
}

void entry_1775c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1775c4 inside entry_177568 (0x177568 - 0x177630)
    ctx->pc = 0x1775c4;
    entry_177568(rdram, ctx, runtime);
}

void entry_1775d4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1775d4 inside entry_177568 (0x177568 - 0x177630)
    ctx->pc = 0x1775d4;
    entry_177568(rdram, ctx, runtime);
}

void entry_177680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177680 inside entry_177664 (0x177664 - 0x1776b8)
    ctx->pc = 0x177680;
    entry_177664(rdram, ctx, runtime);
}

void entry_177684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177684 inside entry_177664 (0x177664 - 0x1776b8)
    ctx->pc = 0x177684;
    entry_177664(rdram, ctx, runtime);
}

void entry_177698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177698 inside entry_177664 (0x177664 - 0x1776b8)
    ctx->pc = 0x177698;
    entry_177664(rdram, ctx, runtime);
}

void entry_1776b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1776b0 inside entry_177664 (0x177664 - 0x1776b8)
    ctx->pc = 0x1776b0;
    entry_177664(rdram, ctx, runtime);
}

void entry_177734(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177734 inside entry_17772c (0x17772c - 0x177744)
    ctx->pc = 0x177734;
    entry_17772c(rdram, ctx, runtime);
}

void entry_177748(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177748 inside entry_177744 (0x177744 - 0x177794)
    ctx->pc = 0x177748;
    entry_177744(rdram, ctx, runtime);
}

void entry_17776c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17776c inside entry_177744 (0x177744 - 0x177794)
    ctx->pc = 0x17776c;
    entry_177744(rdram, ctx, runtime);
}

void entry_17779c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17779c inside entry_177794 (0x177794 - 0x1777b4)
    ctx->pc = 0x17779c;
    entry_177794(rdram, ctx, runtime);
}

void entry_1777b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1777b8 inside entry_1777b4 (0x1777b4 - 0x1777f8)
    ctx->pc = 0x1777b8;
    entry_1777b4(rdram, ctx, runtime);
}

void entry_1777bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1777bc inside entry_1777b4 (0x1777b4 - 0x1777f8)
    ctx->pc = 0x1777bc;
    entry_1777b4(rdram, ctx, runtime);
}

void entry_177878(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177878 inside PaloAbsorbWkr__FP3WKRiPP3ALO (0x177838 - 0x177938)
    ctx->pc = 0x177878;
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime);
}

void entry_177880(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177880 inside PaloAbsorbWkr__FP3WKRiPP3ALO (0x177838 - 0x177938)
    ctx->pc = 0x177880;
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime);
}

void entry_177884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177884 inside PaloAbsorbWkr__FP3WKRiPP3ALO (0x177838 - 0x177938)
    ctx->pc = 0x177884;
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime);
}

void entry_177890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177890 inside PaloAbsorbWkr__FP3WKRiPP3ALO (0x177838 - 0x177938)
    ctx->pc = 0x177890;
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime);
}

void entry_1778a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1778a0 inside PaloAbsorbWkr__FP3WKRiPP3ALO (0x177838 - 0x177938)
    ctx->pc = 0x1778a0;
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime);
}

void entry_1778b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1778b8 inside PaloAbsorbWkr__FP3WKRiPP3ALO (0x177838 - 0x177938)
    ctx->pc = 0x1778b8;
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime);
}

void entry_177920(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177920 inside PaloAbsorbWkr__FP3WKRiPP3ALO (0x177838 - 0x177938)
    ctx->pc = 0x177920;
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime);
}

void entry_177924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177924 inside PaloAbsorbWkr__FP3WKRiPP3ALO (0x177838 - 0x177938)
    ctx->pc = 0x177924;
    PaloAbsorbWkr__FP3WKRiPP3ALO(rdram, ctx, runtime);
}

void entry_17794c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17794c inside entry_177938 (0x177938 - 0x177968)
    ctx->pc = 0x17794c;
    entry_177938(rdram, ctx, runtime);
}

void entry_177984(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177984 inside NCmpWkr__FP3WKRT0 (0x177968 - 0x177990)
    ctx->pc = 0x177984;
    NCmpWkr__FP3WKRT0(rdram, ctx, runtime);
}

void entry_1779ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1779ec inside UpdateJtEffect__FP2JT (0x177990 - 0x177a48)
    ctx->pc = 0x1779ec;
    UpdateJtEffect__FP2JT(rdram, ctx, runtime);
}

void entry_177a0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177a0c inside UpdateJtEffect__FP2JT (0x177990 - 0x177a48)
    ctx->pc = 0x177a0c;
    UpdateJtEffect__FP2JT(rdram, ctx, runtime);
}

void entry_177a10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177a10 inside UpdateJtEffect__FP2JT (0x177990 - 0x177a48)
    ctx->pc = 0x177a10;
    UpdateJtEffect__FP2JT(rdram, ctx, runtime);
}

void entry_177a18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177a18 inside UpdateJtEffect__FP2JT (0x177990 - 0x177a48)
    ctx->pc = 0x177a18;
    UpdateJtEffect__FP2JT(rdram, ctx, runtime);
}

void entry_177a28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177a28 inside UpdateJtEffect__FP2JT (0x177990 - 0x177a48)
    ctx->pc = 0x177a28;
    UpdateJtEffect__FP2JT(rdram, ctx, runtime);
}

void entry_177a3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177a3c inside UpdateJtEffect__FP2JT (0x177990 - 0x177a48)
    ctx->pc = 0x177a3c;
    UpdateJtEffect__FP2JT(rdram, ctx, runtime);
}

void entry_177a50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177a50 inside entry_177a48 (0x177a48 - 0x177a60)
    ctx->pc = 0x177a50;
    entry_177a48(rdram, ctx, runtime);
}

void entry_177a70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177a70 inside entry_177a60 (0x177a60 - 0x177a80)
    ctx->pc = 0x177a70;
    entry_177a60(rdram, ctx, runtime);
}

void entry_177a74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177a74 inside entry_177a60 (0x177a60 - 0x177a80)
    ctx->pc = 0x177a74;
    entry_177a60(rdram, ctx, runtime);
}

void entry_177aa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177aa0 inside entry_177a80 (0x177a80 - 0x177ab0)
    ctx->pc = 0x177aa0;
    entry_177a80(rdram, ctx, runtime);
}

void entry_177b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177b38 inside entry_177af8 (0x177af8 - 0x177b6c)
    ctx->pc = 0x177b38;
    entry_177af8(rdram, ctx, runtime);
}

void entry_177b3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177b3c inside entry_177af8 (0x177af8 - 0x177b6c)
    ctx->pc = 0x177b3c;
    entry_177af8(rdram, ctx, runtime);
}

void entry_177ba0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177ba0 inside entry_177b90 (0x177b90 - 0x177bd8)
    ctx->pc = 0x177ba0;
    entry_177b90(rdram, ctx, runtime);
}

void entry_177bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177bb0 inside entry_177b90 (0x177b90 - 0x177bd8)
    ctx->pc = 0x177bb0;
    entry_177b90(rdram, ctx, runtime);
}

void entry_177bc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177bc0 inside entry_177b90 (0x177b90 - 0x177bd8)
    ctx->pc = 0x177bc0;
    entry_177b90(rdram, ctx, runtime);
}

void entry_177c60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177c60 inside entry_177c3c (0x177c3c - 0x177ca8)
    ctx->pc = 0x177c60;
    entry_177c3c(rdram, ctx, runtime);
}

void entry_177c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177c98 inside entry_177c3c (0x177c3c - 0x177ca8)
    ctx->pc = 0x177c98;
    entry_177c3c(rdram, ctx, runtime);
}

void entry_177cc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177cc8 inside entry_177ca8 (0x177ca8 - 0x177cd8)
    ctx->pc = 0x177cc8;
    entry_177ca8(rdram, ctx, runtime);
}

void entry_177d14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177d14 inside entry_177cd8 (0x177cd8 - 0x177d20)
    ctx->pc = 0x177d14;
    entry_177cd8(rdram, ctx, runtime);
}

void entry_177d34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177d34 inside entry_177d2c (0x177d2c - 0x177d3c)
    ctx->pc = 0x177d34;
    entry_177d2c(rdram, ctx, runtime);
}

void entry_177d50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177d50 inside entry_177d48 (0x177d48 - 0x177d68)
    ctx->pc = 0x177d50;
    entry_177d48(rdram, ctx, runtime);
}

void entry_177d78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177d78 inside entry_177d74 (0x177d74 - 0x177da0)
    ctx->pc = 0x177d78;
    entry_177d74(rdram, ctx, runtime);
}

void entry_177da8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177da8 inside entry_177da0 (0x177da0 - 0x177de4)
    ctx->pc = 0x177da8;
    entry_177da0(rdram, ctx, runtime);
}

void entry_177dc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177dc8 inside entry_177da0 (0x177da0 - 0x177de4)
    ctx->pc = 0x177dc8;
    entry_177da0(rdram, ctx, runtime);
}

void entry_177dcc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177dcc inside entry_177da0 (0x177da0 - 0x177de4)
    ctx->pc = 0x177dcc;
    entry_177da0(rdram, ctx, runtime);
}

void entry_177dd8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177dd8 inside entry_177da0 (0x177da0 - 0x177de4)
    ctx->pc = 0x177dd8;
    entry_177da0(rdram, ctx, runtime);
}

void entry_177ddc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177ddc inside entry_177da0 (0x177da0 - 0x177de4)
    ctx->pc = 0x177ddc;
    entry_177da0(rdram, ctx, runtime);
}

void entry_177dec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177dec inside entry_177de4 (0x177de4 - 0x177e20)
    ctx->pc = 0x177dec;
    entry_177de4(rdram, ctx, runtime);
}

void entry_177e50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177e50 inside FIsJtSoundBase__FP2JT (0x177e20 - 0x177e5c)
    ctx->pc = 0x177e50;
    FIsJtSoundBase__FP2JT(rdram, ctx, runtime);
}

void entry_177e60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177e60 inside entry_177e5c (0x177e5c - 0x177e70)
    ctx->pc = 0x177e60;
    entry_177e5c(rdram, ctx, runtime);
}

void entry_177ea4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177ea4 inside entry_177e8c (0x177e8c - 0x177eb4)
    ctx->pc = 0x177ea4;
    entry_177e8c(rdram, ctx, runtime);
}

void entry_177ebc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177ebc inside entry_177eb4 (0x177eb4 - 0x177ecc)
    ctx->pc = 0x177ebc;
    entry_177eb4(rdram, ctx, runtime);
}

void entry_177ed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177ed0 inside entry_177ecc (0x177ecc - 0x177ee0)
    ctx->pc = 0x177ed0;
    entry_177ecc(rdram, ctx, runtime);
}

void entry_177ed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177ed4 inside entry_177ecc (0x177ecc - 0x177ee0)
    ctx->pc = 0x177ed4;
    entry_177ecc(rdram, ctx, runtime);
}

void entry_177f38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177f38 inside GetJtDiapi__FP2JTP6DIALOGP5DIAPI (0x177ee0 - 0x177f98)
    ctx->pc = 0x177f38;
    GetJtDiapi__FP2JTP6DIALOGP5DIAPI(rdram, ctx, runtime);
}

void entry_177f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177f74 inside GetJtDiapi__FP2JTP6DIALOGP5DIAPI (0x177ee0 - 0x177f98)
    ctx->pc = 0x177f74;
    GetJtDiapi__FP2JTP6DIALOGP5DIAPI(rdram, ctx, runtime);
}

void entry_177f78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177f78 inside GetJtDiapi__FP2JTP6DIALOGP5DIAPI (0x177ee0 - 0x177f98)
    ctx->pc = 0x177f78;
    GetJtDiapi__FP2JTP6DIALOGP5DIAPI(rdram, ctx, runtime);
}

void entry_177f8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177f8c inside GetJtDiapi__FP2JTP6DIALOGP5DIAPI (0x177ee0 - 0x177f98)
    ctx->pc = 0x177f8c;
    GetJtDiapi__FP2JTP6DIALOGP5DIAPI(rdram, ctx, runtime);
}

void entry_177fd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177fd4 inside entry_177fcc (0x177fcc - 0x178008)
    ctx->pc = 0x177fd4;
    entry_177fcc(rdram, ctx, runtime);
}

void entry_177ffc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x177ffc inside entry_177fcc (0x177fcc - 0x178008)
    ctx->pc = 0x177ffc;
    entry_177fcc(rdram, ctx, runtime);
}

void entry_178000(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178000 inside entry_177fcc (0x177fcc - 0x178008)
    ctx->pc = 0x178000;
    entry_177fcc(rdram, ctx, runtime);
}

void entry_1780a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1780a4 inside FUN_00178068 (0x178068 - 0x1780e0)
    ctx->pc = 0x1780a4;
    FUN_00178068(rdram, ctx, runtime);
}

void entry_1780b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1780b4 inside FUN_00178068 (0x178068 - 0x1780e0)
    ctx->pc = 0x1780b4;
    FUN_00178068(rdram, ctx, runtime);
}

void entry_1780c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1780c0 inside FUN_00178068 (0x178068 - 0x1780e0)
    ctx->pc = 0x1780c0;
    FUN_00178068(rdram, ctx, runtime);
}

void entry_1780e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1780e8 inside entry_1780e0 (0x1780e0 - 0x1780fc)
    ctx->pc = 0x1780e8;
    entry_1780e0(rdram, ctx, runtime);
}

void entry_17812c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17812c inside entry_178108 (0x178108 - 0x178154)
    ctx->pc = 0x17812c;
    entry_178108(rdram, ctx, runtime);
}

void entry_17815c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17815c inside entry_178154 (0x178154 - 0x17818c)
    ctx->pc = 0x17815c;
    entry_178154(rdram, ctx, runtime);
}

void entry_178178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178178 inside entry_178154 (0x178154 - 0x17818c)
    ctx->pc = 0x178178;
    entry_178154(rdram, ctx, runtime);
}

void entry_17819c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17819c inside entry_17818c (0x17818c - 0x1781bc)
    ctx->pc = 0x17819c;
    entry_17818c(rdram, ctx, runtime);
}

void entry_1781c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1781c4 inside entry_1781bc (0x1781bc - 0x1781e0)
    ctx->pc = 0x1781c4;
    entry_1781bc(rdram, ctx, runtime);
}

void entry_1781c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1781c8 inside entry_1781bc (0x1781bc - 0x1781e0)
    ctx->pc = 0x1781c8;
    entry_1781bc(rdram, ctx, runtime);
}

void entry_1781cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1781cc inside entry_1781bc (0x1781bc - 0x1781e0)
    ctx->pc = 0x1781cc;
    entry_1781bc(rdram, ctx, runtime);
}

void entry_178240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178240 inside entry_17821c (0x17821c - 0x178258)
    ctx->pc = 0x178240;
    entry_17821c(rdram, ctx, runtime);
}

void entry_178244(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178244 inside entry_17821c (0x17821c - 0x178258)
    ctx->pc = 0x178244;
    entry_17821c(rdram, ctx, runtime);
}

void entry_178248(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178248 inside entry_17821c (0x17821c - 0x178258)
    ctx->pc = 0x178248;
    entry_17821c(rdram, ctx, runtime);
}

void entry_17824c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17824c inside entry_17821c (0x17821c - 0x178258)
    ctx->pc = 0x17824c;
    entry_17821c(rdram, ctx, runtime);
}

void entry_178274(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178274 inside FUN_00178258 (0x178258 - 0x178280)
    ctx->pc = 0x178274;
    FUN_00178258(rdram, ctx, runtime);
}

void entry_17829c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17829c inside FUN_00178280 (0x178280 - 0x1782c0)
    ctx->pc = 0x17829c;
    FUN_00178280(rdram, ctx, runtime);
}

void entry_178350(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178350 inside entry_178328 (0x178328 - 0x17835c)
    ctx->pc = 0x178350;
    entry_178328(rdram, ctx, runtime);
}

void entry_1783c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1783c0 inside entry_17839c (0x17839c - 0x1783c8)
    ctx->pc = 0x1783c0;
    entry_17839c(rdram, ctx, runtime);
}

void entry_1783ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1783ec inside entry_1783e4 (0x1783e4 - 0x1783f8)
    ctx->pc = 0x1783ec;
    entry_1783e4(rdram, ctx, runtime);
}

void entry_178418(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178418 inside entry_178414 (0x178414 - 0x178428)
    ctx->pc = 0x178418;
    entry_178414(rdram, ctx, runtime);
}

void entry_178430(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178430 inside entry_178428 (0x178428 - 0x17843c)
    ctx->pc = 0x178430;
    entry_178428(rdram, ctx, runtime);
}

void entry_178474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178474 inside entry_17846c (0x17846c - 0x17847c)
    ctx->pc = 0x178474;
    entry_17846c(rdram, ctx, runtime);
}

void entry_178490(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178490 inside entry_17847c (0x17847c - 0x1784e4)
    ctx->pc = 0x178490;
    entry_17847c(rdram, ctx, runtime);
}

void entry_1784a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1784a8 inside entry_17847c (0x17847c - 0x1784e4)
    ctx->pc = 0x1784a8;
    entry_17847c(rdram, ctx, runtime);
}

void entry_1784b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1784b4 inside entry_17847c (0x17847c - 0x1784e4)
    ctx->pc = 0x1784b4;
    entry_17847c(rdram, ctx, runtime);
}

void entry_1784b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1784b8 inside entry_17847c (0x17847c - 0x1784e4)
    ctx->pc = 0x1784b8;
    entry_17847c(rdram, ctx, runtime);
}

void entry_1784bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1784bc inside entry_17847c (0x17847c - 0x1784e4)
    ctx->pc = 0x1784bc;
    entry_17847c(rdram, ctx, runtime);
}

void entry_178554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178554 inside entry_1784e4 (0x1784e4 - 0x178598)
    ctx->pc = 0x178554;
    entry_1784e4(rdram, ctx, runtime);
}

void entry_178560(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178560 inside entry_1784e4 (0x1784e4 - 0x178598)
    ctx->pc = 0x178560;
    entry_1784e4(rdram, ctx, runtime);
}

void entry_17856c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17856c inside entry_1784e4 (0x1784e4 - 0x178598)
    ctx->pc = 0x17856c;
    entry_1784e4(rdram, ctx, runtime);
}

void entry_1785d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1785d8 inside entry_1785d4 (0x1785d4 - 0x1785f8)
    ctx->pc = 0x1785d8;
    entry_1785d4(rdram, ctx, runtime);
}

void entry_178708(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178708 inside FUN_00178678 (0x178678 - 0x178738)
    ctx->pc = 0x178708;
    FUN_00178678(rdram, ctx, runtime);
}

void entry_178788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178788 inside entry_178738 (0x178738 - 0x1787c0)
    ctx->pc = 0x178788;
    entry_178738(rdram, ctx, runtime);
}

void entry_1787e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1787e8 inside entry_1787dc (0x1787dc - 0x1788f0)
    ctx->pc = 0x1787e8;
    entry_1787dc(rdram, ctx, runtime);
}

void entry_17882c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17882c inside entry_1787dc (0x1787dc - 0x1788f0)
    ctx->pc = 0x17882c;
    entry_1787dc(rdram, ctx, runtime);
}

void entry_178844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178844 inside entry_1787dc (0x1787dc - 0x1788f0)
    ctx->pc = 0x178844;
    entry_1787dc(rdram, ctx, runtime);
}

void entry_178890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178890 inside entry_1787dc (0x1787dc - 0x1788f0)
    ctx->pc = 0x178890;
    entry_1787dc(rdram, ctx, runtime);
}

void entry_178a84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178a84 inside entry_178a5c (0x178a5c - 0x178b00)
    ctx->pc = 0x178a84;
    entry_178a5c(rdram, ctx, runtime);
}

void entry_178a98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178a98 inside entry_178a5c (0x178a5c - 0x178b00)
    ctx->pc = 0x178a98;
    entry_178a5c(rdram, ctx, runtime);
}

void entry_178aac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178aac inside entry_178a5c (0x178a5c - 0x178b00)
    ctx->pc = 0x178aac;
    entry_178a5c(rdram, ctx, runtime);
}

void entry_178b14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178b14 inside entry_178b00 (0x178b00 - 0x178b80)
    ctx->pc = 0x178b14;
    entry_178b00(rdram, ctx, runtime);
}

void entry_178b38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178b38 inside entry_178b00 (0x178b00 - 0x178b80)
    ctx->pc = 0x178b38;
    entry_178b00(rdram, ctx, runtime);
}

void entry_178b94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178b94 inside entry_178b80 (0x178b80 - 0x178cb0)
    ctx->pc = 0x178b94;
    entry_178b80(rdram, ctx, runtime);
}

void entry_178bc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178bc8 inside entry_178b80 (0x178b80 - 0x178cb0)
    ctx->pc = 0x178bc8;
    entry_178b80(rdram, ctx, runtime);
}

void entry_178c10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178c10 inside entry_178b80 (0x178b80 - 0x178cb0)
    ctx->pc = 0x178c10;
    entry_178b80(rdram, ctx, runtime);
}

void entry_178c78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178c78 inside entry_178b80 (0x178b80 - 0x178cb0)
    ctx->pc = 0x178c78;
    entry_178b80(rdram, ctx, runtime);
}

void entry_178c88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178c88 inside entry_178b80 (0x178b80 - 0x178cb0)
    ctx->pc = 0x178c88;
    entry_178b80(rdram, ctx, runtime);
}

void entry_178c98(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178c98 inside entry_178b80 (0x178b80 - 0x178cb0)
    ctx->pc = 0x178c98;
    entry_178b80(rdram, ctx, runtime);
}

void entry_178d90(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178d90 inside entry_178cb8 (0x178cb8 - 0x178d98)
    ctx->pc = 0x178d90;
    entry_178cb8(rdram, ctx, runtime);
}

void entry_178e28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178e28 inside entry_178e10 (0x178e10 - 0x178e34)
    ctx->pc = 0x178e28;
    entry_178e10(rdram, ctx, runtime);
}

void entry_178ea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178ea8 inside entry_178ea0 (0x178ea0 - 0x178ed0)
    ctx->pc = 0x178ea8;
    entry_178ea0(rdram, ctx, runtime);
}

void entry_178eac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178eac inside entry_178ea0 (0x178ea0 - 0x178ed0)
    ctx->pc = 0x178eac;
    entry_178ea0(rdram, ctx, runtime);
}

void entry_178eb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178eb0 inside entry_178ea0 (0x178ea0 - 0x178ed0)
    ctx->pc = 0x178eb0;
    entry_178ea0(rdram, ctx, runtime);
}

void entry_178edc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178edc inside entry_178ed0 (0x178ed0 - 0x178ef8)
    ctx->pc = 0x178edc;
    entry_178ed0(rdram, ctx, runtime);
}

void entry_178f10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178f10 inside entry_178ef8 (0x178ef8 - 0x178f2c)
    ctx->pc = 0x178f10;
    entry_178ef8(rdram, ctx, runtime);
}

void entry_178f64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178f64 inside entry_178f2c (0x178f2c - 0x178fb4)
    ctx->pc = 0x178f64;
    entry_178f2c(rdram, ctx, runtime);
}

void entry_178f74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178f74 inside entry_178f2c (0x178f2c - 0x178fb4)
    ctx->pc = 0x178f74;
    entry_178f2c(rdram, ctx, runtime);
}

void entry_178fa0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178fa0 inside entry_178f2c (0x178f2c - 0x178fb4)
    ctx->pc = 0x178fa0;
    entry_178f2c(rdram, ctx, runtime);
}

void entry_178fbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x178fbc inside entry_178fb4 (0x178fb4 - 0x178fd4)
    ctx->pc = 0x178fbc;
    entry_178fb4(rdram, ctx, runtime);
}

void entry_17900c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17900c inside entry_178fd4 (0x178fd4 - 0x179044)
    ctx->pc = 0x17900c;
    entry_178fd4(rdram, ctx, runtime);
}

void entry_179020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179020 inside entry_178fd4 (0x178fd4 - 0x179044)
    ctx->pc = 0x179020;
    entry_178fd4(rdram, ctx, runtime);
}

void entry_179078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179078 inside entry_179044 (0x179044 - 0x179080)
    ctx->pc = 0x179078;
    entry_179044(rdram, ctx, runtime);
}

void entry_179154(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179154 inside FUN_001790b8 (0x1790b8 - 0x1791d8)
    ctx->pc = 0x179154;
    FUN_001790b8(rdram, ctx, runtime);
}

void entry_17916c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17916c inside FUN_001790b8 (0x1790b8 - 0x1791d8)
    ctx->pc = 0x17916c;
    FUN_001790b8(rdram, ctx, runtime);
}

void entry_179188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179188 inside FUN_001790b8 (0x1790b8 - 0x1791d8)
    ctx->pc = 0x179188;
    FUN_001790b8(rdram, ctx, runtime);
}

void entry_1791a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1791a0 inside FUN_001790b8 (0x1790b8 - 0x1791d8)
    ctx->pc = 0x1791a0;
    FUN_001790b8(rdram, ctx, runtime);
}

void entry_1791c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1791c0 inside FUN_001790b8 (0x1790b8 - 0x1791d8)
    ctx->pc = 0x1791c0;
    FUN_001790b8(rdram, ctx, runtime);
}

void entry_179208(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179208 inside entry_1791f4 (0x1791f4 - 0x17930c)
    ctx->pc = 0x179208;
    entry_1791f4(rdram, ctx, runtime);
}

void entry_179238(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179238 inside entry_1791f4 (0x1791f4 - 0x17930c)
    ctx->pc = 0x179238;
    entry_1791f4(rdram, ctx, runtime);
}

void entry_179258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179258 inside entry_1791f4 (0x1791f4 - 0x17930c)
    ctx->pc = 0x179258;
    entry_1791f4(rdram, ctx, runtime);
}

void entry_179278(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179278 inside entry_1791f4 (0x1791f4 - 0x17930c)
    ctx->pc = 0x179278;
    entry_1791f4(rdram, ctx, runtime);
}

void entry_1792e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1792e4 inside entry_1791f4 (0x1791f4 - 0x17930c)
    ctx->pc = 0x1792e4;
    entry_1791f4(rdram, ctx, runtime);
}

void entry_179320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179320 inside entry_17930c (0x17930c - 0x179370)
    ctx->pc = 0x179320;
    entry_17930c(rdram, ctx, runtime);
}

void entry_179330(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179330 inside entry_17930c (0x17930c - 0x179370)
    ctx->pc = 0x179330;
    entry_17930c(rdram, ctx, runtime);
}

void entry_179340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179340 inside entry_17930c (0x17930c - 0x179370)
    ctx->pc = 0x179340;
    entry_17930c(rdram, ctx, runtime);
}

void entry_179354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179354 inside entry_17930c (0x17930c - 0x179370)
    ctx->pc = 0x179354;
    entry_17930c(rdram, ctx, runtime);
}

void entry_179384(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179384 inside entry_179380 (0x179380 - 0x1793c0)
    ctx->pc = 0x179384;
    entry_179380(rdram, ctx, runtime);
}

void entry_1793a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1793a4 inside entry_179380 (0x179380 - 0x1793c0)
    ctx->pc = 0x1793a4;
    entry_179380(rdram, ctx, runtime);
}

void entry_1793a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1793a8 inside entry_179380 (0x179380 - 0x1793c0)
    ctx->pc = 0x1793a8;
    entry_179380(rdram, ctx, runtime);
}

void entry_1795d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1795d0 inside FUN_00179590 (0x179590 - 0x1795dc)
    ctx->pc = 0x1795d0;
    FUN_00179590(rdram, ctx, runtime);
}

void entry_1795e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1795e4 inside entry_1795dc (0x1795dc - 0x1795f4)
    ctx->pc = 0x1795e4;
    entry_1795dc(rdram, ctx, runtime);
}

void entry_179628(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179628 inside entry_179620 (0x179620 - 0x179660)
    ctx->pc = 0x179628;
    entry_179620(rdram, ctx, runtime);
}

void entry_179640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179640 inside entry_179620 (0x179620 - 0x179660)
    ctx->pc = 0x179640;
    entry_179620(rdram, ctx, runtime);
}

void entry_17967c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17967c inside entry_179678 (0x179678 - 0x179690)
    ctx->pc = 0x17967c;
    entry_179678(rdram, ctx, runtime);
}

void entry_1796c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1796c4 inside entry_1796c0 (0x1796c0 - 0x1796d0)
    ctx->pc = 0x1796c4;
    entry_1796c0(rdram, ctx, runtime);
}

void entry_17978c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17978c inside entry_179788 (0x179788 - 0x17979c)
    ctx->pc = 0x17978c;
    entry_179788(rdram, ctx, runtime);
}

void entry_1797fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1797fc inside entry_1797c0 (0x1797c0 - 0x179804)
    ctx->pc = 0x1797fc;
    entry_1797c0(rdram, ctx, runtime);
}

void entry_179840(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179840 inside entry_179838 (0x179838 - 0x179854)
    ctx->pc = 0x179840;
    entry_179838(rdram, ctx, runtime);
}

void entry_179844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179844 inside entry_179838 (0x179838 - 0x179854)
    ctx->pc = 0x179844;
    entry_179838(rdram, ctx, runtime);
}

void entry_179858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179858 inside entry_179854 (0x179854 - 0x17987c)
    ctx->pc = 0x179858;
    entry_179854(rdram, ctx, runtime);
}

void entry_179924(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179924 inside entry_17990c (0x17990c - 0x179a48)
    ctx->pc = 0x179924;
    entry_17990c(rdram, ctx, runtime);
}

void entry_17994c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17994c inside entry_17990c (0x17990c - 0x179a48)
    ctx->pc = 0x17994c;
    entry_17990c(rdram, ctx, runtime);
}

void entry_179960(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179960 inside entry_17990c (0x17990c - 0x179a48)
    ctx->pc = 0x179960;
    entry_17990c(rdram, ctx, runtime);
}

void entry_179970(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179970 inside entry_17990c (0x17990c - 0x179a48)
    ctx->pc = 0x179970;
    entry_17990c(rdram, ctx, runtime);
}

void entry_1799a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1799a0 inside entry_17990c (0x17990c - 0x179a48)
    ctx->pc = 0x1799a0;
    entry_17990c(rdram, ctx, runtime);
}

void entry_1799a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1799a4 inside entry_17990c (0x17990c - 0x179a48)
    ctx->pc = 0x1799a4;
    entry_17990c(rdram, ctx, runtime);
}

void entry_1799c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1799c8 inside entry_17990c (0x17990c - 0x179a48)
    ctx->pc = 0x1799c8;
    entry_17990c(rdram, ctx, runtime);
}

void entry_1799d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1799d8 inside entry_17990c (0x17990c - 0x179a48)
    ctx->pc = 0x1799d8;
    entry_17990c(rdram, ctx, runtime);
}

void entry_1799dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x1799dc inside entry_17990c (0x17990c - 0x179a48)
    ctx->pc = 0x1799dc;
    entry_17990c(rdram, ctx, runtime);
}

void entry_179a08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179a08 inside entry_17990c (0x17990c - 0x179a48)
    ctx->pc = 0x179a08;
    entry_17990c(rdram, ctx, runtime);
}

void entry_179af8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179af8 inside entry_179ac8 (0x179ac8 - 0x179b04)
    ctx->pc = 0x179af8;
    entry_179ac8(rdram, ctx, runtime);
}

void entry_179b0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179b0c inside entry_179b04 (0x179b04 - 0x179b20)
    ctx->pc = 0x179b0c;
    entry_179b04(rdram, ctx, runtime);
}

void entry_179b2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179b2c inside entry_179b20 (0x179b20 - 0x179b6c)
    ctx->pc = 0x179b2c;
    entry_179b20(rdram, ctx, runtime);
}

void entry_179b70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179b70 inside entry_179b6c (0x179b6c - 0x179b88)
    ctx->pc = 0x179b70;
    entry_179b6c(rdram, ctx, runtime);
}

void entry_179bb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179bb0 inside entry_179b88 (0x179b88 - 0x179bc0)
    ctx->pc = 0x179bb0;
    entry_179b88(rdram, ctx, runtime);
}

void entry_179bb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179bb4 inside entry_179b88 (0x179b88 - 0x179bc0)
    ctx->pc = 0x179bb4;
    entry_179b88(rdram, ctx, runtime);
}

void entry_179bb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179bb8 inside entry_179b88 (0x179b88 - 0x179bc0)
    ctx->pc = 0x179bb8;
    entry_179b88(rdram, ctx, runtime);
}

void entry_179bc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179bc4 inside entry_179bc0 (0x179bc0 - 0x179bf4)
    ctx->pc = 0x179bc4;
    entry_179bc0(rdram, ctx, runtime);
}

void entry_179cdc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179cdc inside entry_179cc0 (0x179cc0 - 0x179d7c)
    ctx->pc = 0x179cdc;
    entry_179cc0(rdram, ctx, runtime);
}

void entry_179d3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179d3c inside entry_179cc0 (0x179cc0 - 0x179d7c)
    ctx->pc = 0x179d3c;
    entry_179cc0(rdram, ctx, runtime);
}

void entry_179d60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179d60 inside entry_179cc0 (0x179cc0 - 0x179d7c)
    ctx->pc = 0x179d60;
    entry_179cc0(rdram, ctx, runtime);
}

void entry_179de0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179de0 inside entry_179d98 (0x179d98 - 0x179ec4)
    ctx->pc = 0x179de0;
    entry_179d98(rdram, ctx, runtime);
}

void entry_179e1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179e1c inside entry_179d98 (0x179d98 - 0x179ec4)
    ctx->pc = 0x179e1c;
    entry_179d98(rdram, ctx, runtime);
}

void entry_179e30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179e30 inside entry_179d98 (0x179d98 - 0x179ec4)
    ctx->pc = 0x179e30;
    entry_179d98(rdram, ctx, runtime);
}

void entry_179f40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x179f40 inside entry_179ef4 (0x179ef4 - 0x179f64)
    ctx->pc = 0x179f40;
    entry_179ef4(rdram, ctx, runtime);
}

void entry_17a07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a07c inside entry_17a000 (0x17a000 - 0x17a138)
    ctx->pc = 0x17a07c;
    entry_17a000(rdram, ctx, runtime);
}

void entry_17a0fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a0fc inside entry_17a000 (0x17a000 - 0x17a138)
    ctx->pc = 0x17a0fc;
    entry_17a000(rdram, ctx, runtime);
}

void entry_17a10c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a10c inside entry_17a000 (0x17a000 - 0x17a138)
    ctx->pc = 0x17a10c;
    entry_17a000(rdram, ctx, runtime);
}

void entry_17a124(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a124 inside entry_17a000 (0x17a000 - 0x17a138)
    ctx->pc = 0x17a124;
    entry_17a000(rdram, ctx, runtime);
}

void entry_17a188(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a188 inside entry_17a154 (0x17a154 - 0x17a1f8)
    ctx->pc = 0x17a188;
    entry_17a154(rdram, ctx, runtime);
}

void entry_17a198(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a198 inside entry_17a154 (0x17a154 - 0x17a1f8)
    ctx->pc = 0x17a198;
    entry_17a154(rdram, ctx, runtime);
}

void entry_17a1cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a1cc inside entry_17a154 (0x17a154 - 0x17a1f8)
    ctx->pc = 0x17a1cc;
    entry_17a154(rdram, ctx, runtime);
}

void entry_17a1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a1dc inside entry_17a154 (0x17a154 - 0x17a1f8)
    ctx->pc = 0x17a1dc;
    entry_17a154(rdram, ctx, runtime);
}

void entry_17a214(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a214 inside entry_17a1f8 (0x17a1f8 - 0x17a248)
    ctx->pc = 0x17a214;
    entry_17a1f8(rdram, ctx, runtime);
}

void entry_17a314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a314 inside entry_17a2a4 (0x17a2a4 - 0x17a3c4)
    ctx->pc = 0x17a314;
    entry_17a2a4(rdram, ctx, runtime);
}

void entry_17a324(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a324 inside entry_17a2a4 (0x17a2a4 - 0x17a3c4)
    ctx->pc = 0x17a324;
    entry_17a2a4(rdram, ctx, runtime);
}

void entry_17a3a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a3a8 inside entry_17a2a4 (0x17a2a4 - 0x17a3c4)
    ctx->pc = 0x17a3a8;
    entry_17a2a4(rdram, ctx, runtime);
}

void entry_17a3b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a3b4 inside entry_17a2a4 (0x17a2a4 - 0x17a3c4)
    ctx->pc = 0x17a3b4;
    entry_17a2a4(rdram, ctx, runtime);
}

void entry_17a4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a4fc inside entry_17a4f4 (0x17a4f4 - 0x17a510)
    ctx->pc = 0x17a4fc;
    entry_17a4f4(rdram, ctx, runtime);
}

void entry_17a500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a500 inside entry_17a4f4 (0x17a4f4 - 0x17a510)
    ctx->pc = 0x17a500;
    entry_17a4f4(rdram, ctx, runtime);
}

void entry_17a528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a528 inside entry_17a510 (0x17a510 - 0x17a5a8)
    ctx->pc = 0x17a528;
    entry_17a510(rdram, ctx, runtime);
}

void entry_17a578(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a578 inside entry_17a510 (0x17a510 - 0x17a5a8)
    ctx->pc = 0x17a578;
    entry_17a510(rdram, ctx, runtime);
}

void entry_17a588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a588 inside entry_17a510 (0x17a510 - 0x17a5a8)
    ctx->pc = 0x17a588;
    entry_17a510(rdram, ctx, runtime);
}

void entry_17a67c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a67c inside entry_17a678 (0x17a678 - 0x17a684)
    ctx->pc = 0x17a67c;
    entry_17a678(rdram, ctx, runtime);
}

void entry_17a754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a754 inside entry_17a71c (0x17a71c - 0x17a76c)
    ctx->pc = 0x17a754;
    entry_17a71c(rdram, ctx, runtime);
}

void entry_17a770(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a770 inside entry_17a76c (0x17a76c - 0x17a788)
    ctx->pc = 0x17a770;
    entry_17a76c(rdram, ctx, runtime);
}

void entry_17a804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a804 inside FUN_0017a788 (0x17a788 - 0x17a828)
    ctx->pc = 0x17a804;
    FUN_0017a788(rdram, ctx, runtime);
}

void entry_17a80c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a80c inside FUN_0017a788 (0x17a788 - 0x17a828)
    ctx->pc = 0x17a80c;
    FUN_0017a788(rdram, ctx, runtime);
}

void entry_17a884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a884 inside entry_17a828 (0x17a828 - 0x17a9b0)
    ctx->pc = 0x17a884;
    entry_17a828(rdram, ctx, runtime);
}

void entry_17a8c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a8c8 inside entry_17a828 (0x17a828 - 0x17a9b0)
    ctx->pc = 0x17a8c8;
    entry_17a828(rdram, ctx, runtime);
}

void entry_17a8d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a8d8 inside entry_17a828 (0x17a828 - 0x17a9b0)
    ctx->pc = 0x17a8d8;
    entry_17a828(rdram, ctx, runtime);
}

void entry_17a98c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a98c inside entry_17a828 (0x17a828 - 0x17a9b0)
    ctx->pc = 0x17a98c;
    entry_17a828(rdram, ctx, runtime);
}

void entry_17a9a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17a9a4 inside entry_17a828 (0x17a828 - 0x17a9b0)
    ctx->pc = 0x17a9a4;
    entry_17a828(rdram, ctx, runtime);
}

void entry_17aa2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17aa2c inside entry_17aa24 (0x17aa24 - 0x17aa40)
    ctx->pc = 0x17aa2c;
    entry_17aa24(rdram, ctx, runtime);
}

void entry_17aa30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17aa30 inside entry_17aa24 (0x17aa24 - 0x17aa40)
    ctx->pc = 0x17aa30;
    entry_17aa24(rdram, ctx, runtime);
}

void entry_17aa94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17aa94 inside entry_17aa7c (0x17aa7c - 0x17aac0)
    ctx->pc = 0x17aa94;
    entry_17aa7c(rdram, ctx, runtime);
}

void entry_17ab10(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ab10 inside entry_17ab08 (0x17ab08 - 0x17ab18)
    ctx->pc = 0x17ab10;
    entry_17ab08(rdram, ctx, runtime);
}

void entry_17ab1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ab1c inside entry_17ab18 (0x17ab18 - 0x17ab3c)
    ctx->pc = 0x17ab1c;
    entry_17ab18(rdram, ctx, runtime);
}

void entry_17ab40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ab40 inside entry_17ab3c (0x17ab3c - 0x17ab58)
    ctx->pc = 0x17ab40;
    entry_17ab3c(rdram, ctx, runtime);
}

void entry_17ab9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ab9c inside FUN_0017ab58 (0x17ab58 - 0x17abcc)
    ctx->pc = 0x17ab9c;
    FUN_0017ab58(rdram, ctx, runtime);
}

void entry_17abb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17abb0 inside FUN_0017ab58 (0x17ab58 - 0x17abcc)
    ctx->pc = 0x17abb0;
    FUN_0017ab58(rdram, ctx, runtime);
}

void entry_17abb8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17abb8 inside FUN_0017ab58 (0x17ab58 - 0x17abcc)
    ctx->pc = 0x17abb8;
    FUN_0017ab58(rdram, ctx, runtime);
}

void entry_17abc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17abc0 inside FUN_0017ab58 (0x17ab58 - 0x17abcc)
    ctx->pc = 0x17abc0;
    FUN_0017ab58(rdram, ctx, runtime);
}

void entry_17abc4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17abc4 inside FUN_0017ab58 (0x17ab58 - 0x17abcc)
    ctx->pc = 0x17abc4;
    FUN_0017ab58(rdram, ctx, runtime);
}

void entry_17ac34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ac34 inside FUN_0017abe8 (0x17abe8 - 0x17accc)
    ctx->pc = 0x17ac34;
    FUN_0017abe8(rdram, ctx, runtime);
}

void entry_17ac38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ac38 inside FUN_0017abe8 (0x17abe8 - 0x17accc)
    ctx->pc = 0x17ac38;
    FUN_0017abe8(rdram, ctx, runtime);
}

void entry_17ac5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ac5c inside FUN_0017abe8 (0x17abe8 - 0x17accc)
    ctx->pc = 0x17ac5c;
    FUN_0017abe8(rdram, ctx, runtime);
}

void entry_17ac78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ac78 inside FUN_0017abe8 (0x17abe8 - 0x17accc)
    ctx->pc = 0x17ac78;
    FUN_0017abe8(rdram, ctx, runtime);
}

void entry_17acd4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17acd4 inside entry_17accc (0x17accc - 0x17ad04)
    ctx->pc = 0x17acd4;
    entry_17accc(rdram, ctx, runtime);
}

void entry_17ace8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ace8 inside entry_17accc (0x17accc - 0x17ad04)
    ctx->pc = 0x17ace8;
    entry_17accc(rdram, ctx, runtime);
}

void entry_17ad08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ad08 inside entry_17ad04 (0x17ad04 - 0x17ad34)
    ctx->pc = 0x17ad08;
    entry_17ad04(rdram, ctx, runtime);
}

void entry_17b068(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b068 inside entry_17afe0 (0x17afe0 - 0x17b0c4)
    ctx->pc = 0x17b068;
    entry_17afe0(rdram, ctx, runtime);
}

void entry_17b0cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b0cc inside entry_17b0c4 (0x17b0c4 - 0x17b21c)
    ctx->pc = 0x17b0cc;
    entry_17b0c4(rdram, ctx, runtime);
}

void entry_17b10c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b10c inside entry_17b0c4 (0x17b0c4 - 0x17b21c)
    ctx->pc = 0x17b10c;
    entry_17b0c4(rdram, ctx, runtime);
}

void entry_17b150(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b150 inside entry_17b0c4 (0x17b0c4 - 0x17b21c)
    ctx->pc = 0x17b150;
    entry_17b0c4(rdram, ctx, runtime);
}

void entry_17b1a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b1a0 inside entry_17b0c4 (0x17b0c4 - 0x17b21c)
    ctx->pc = 0x17b1a0;
    entry_17b0c4(rdram, ctx, runtime);
}

void entry_17b1b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b1b4 inside entry_17b0c4 (0x17b0c4 - 0x17b21c)
    ctx->pc = 0x17b1b4;
    entry_17b0c4(rdram, ctx, runtime);
}

void entry_17b1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b1ec inside entry_17b0c4 (0x17b0c4 - 0x17b21c)
    ctx->pc = 0x17b1ec;
    entry_17b0c4(rdram, ctx, runtime);
}

void entry_17b2f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b2f8 inside entry_17b2f0 (0x17b2f0 - 0x17b308)
    ctx->pc = 0x17b2f8;
    entry_17b2f0(rdram, ctx, runtime);
}

void entry_17b2fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b2fc inside entry_17b2f0 (0x17b2f0 - 0x17b308)
    ctx->pc = 0x17b2fc;
    entry_17b2f0(rdram, ctx, runtime);
}

void entry_17b368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b368 inside entry_17b334 (0x17b334 - 0x17b380)
    ctx->pc = 0x17b368;
    entry_17b334(rdram, ctx, runtime);
}

void entry_17b388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b388 inside entry_17b380 (0x17b380 - 0x17b398)
    ctx->pc = 0x17b388;
    entry_17b380(rdram, ctx, runtime);
}

void entry_17b39c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b39c inside entry_17b398 (0x17b398 - 0x17b3a8)
    ctx->pc = 0x17b39c;
    entry_17b398(rdram, ctx, runtime);
}

void entry_17b400(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b400 inside entry_17b3fc (0x17b3fc - 0x17b410)
    ctx->pc = 0x17b400;
    entry_17b3fc(rdram, ctx, runtime);
}

void entry_17b454(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b454 inside FUN_0017b410 (0x17b410 - 0x17b498)
    ctx->pc = 0x17b454;
    FUN_0017b410(rdram, ctx, runtime);
}

void entry_17b458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b458 inside FUN_0017b410 (0x17b410 - 0x17b498)
    ctx->pc = 0x17b458;
    FUN_0017b410(rdram, ctx, runtime);
}

void entry_17b4a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b4a0 inside entry_17b498 (0x17b498 - 0x17b4bc)
    ctx->pc = 0x17b4a0;
    entry_17b498(rdram, ctx, runtime);
}

void entry_17b4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b4fc inside entry_17b4e8 (0x17b4e8 - 0x17b510)
    ctx->pc = 0x17b4fc;
    entry_17b4e8(rdram, ctx, runtime);
}

void entry_17b524(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b524 inside FUN_0017b510 (0x17b510 - 0x17b544)
    ctx->pc = 0x17b524;
    FUN_0017b510(rdram, ctx, runtime);
}

void entry_17b570(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b570 inside FUN_0017b550 (0x17b550 - 0x17b584)
    ctx->pc = 0x17b570;
    FUN_0017b550(rdram, ctx, runtime);
}

void entry_17b588(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b588 inside entry_17b584 (0x17b584 - 0x17b598)
    ctx->pc = 0x17b588;
    entry_17b584(rdram, ctx, runtime);
}

void entry_17b690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b690 inside entry_17b688 (0x17b688 - 0x17b6a8)
    ctx->pc = 0x17b690;
    entry_17b688(rdram, ctx, runtime);
}

void entry_17b694(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b694 inside entry_17b688 (0x17b688 - 0x17b6a8)
    ctx->pc = 0x17b694;
    entry_17b688(rdram, ctx, runtime);
}

void entry_17b6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b6ac inside entry_17b6a8 (0x17b6a8 - 0x17b6fc)
    ctx->pc = 0x17b6ac;
    entry_17b6a8(rdram, ctx, runtime);
}

void entry_17b700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b700 inside entry_17b6fc (0x17b6fc - 0x17b710)
    ctx->pc = 0x17b700;
    entry_17b6fc(rdram, ctx, runtime);
}

void entry_17b704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b704 inside entry_17b6fc (0x17b6fc - 0x17b710)
    ctx->pc = 0x17b704;
    entry_17b6fc(rdram, ctx, runtime);
}

void entry_17b768(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b768 inside entry_17b734 (0x17b734 - 0x17b780)
    ctx->pc = 0x17b768;
    entry_17b734(rdram, ctx, runtime);
}

void entry_17b788(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b788 inside entry_17b780 (0x17b780 - 0x17b798)
    ctx->pc = 0x17b788;
    entry_17b780(rdram, ctx, runtime);
}

void entry_17b79c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b79c inside entry_17b798 (0x17b798 - 0x17b7a8)
    ctx->pc = 0x17b79c;
    entry_17b798(rdram, ctx, runtime);
}

void entry_17b80c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b80c inside entry_17b7ec (0x17b7ec - 0x17b878)
    ctx->pc = 0x17b80c;
    entry_17b7ec(rdram, ctx, runtime);
}

void entry_17b844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b844 inside entry_17b7ec (0x17b7ec - 0x17b878)
    ctx->pc = 0x17b844;
    entry_17b7ec(rdram, ctx, runtime);
}

void entry_17b858(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b858 inside entry_17b7ec (0x17b7ec - 0x17b878)
    ctx->pc = 0x17b858;
    entry_17b7ec(rdram, ctx, runtime);
}

void entry_17b85c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b85c inside entry_17b7ec (0x17b7ec - 0x17b878)
    ctx->pc = 0x17b85c;
    entry_17b7ec(rdram, ctx, runtime);
}

void entry_17b908(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b908 inside FUN_0017b8c0 (0x17b8c0 - 0x17b954)
    ctx->pc = 0x17b908;
    FUN_0017b8c0(rdram, ctx, runtime);
}

void entry_17b95c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b95c inside entry_17b954 (0x17b954 - 0x17b964)
    ctx->pc = 0x17b95c;
    entry_17b954(rdram, ctx, runtime);
}

void entry_17b974(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b974 inside entry_17b970 (0x17b970 - 0x17b998)
    ctx->pc = 0x17b974;
    entry_17b970(rdram, ctx, runtime);
}

void entry_17b980(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17b980 inside entry_17b970 (0x17b970 - 0x17b998)
    ctx->pc = 0x17b980;
    entry_17b970(rdram, ctx, runtime);
}

void entry_17ba24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ba24 inside entry_17ba1c (0x17ba1c - 0x17ba2c)
    ctx->pc = 0x17ba24;
    entry_17ba1c(rdram, ctx, runtime);
}

void entry_17ba5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ba5c inside entry_17ba54 (0x17ba54 - 0x17ba68)
    ctx->pc = 0x17ba5c;
    entry_17ba54(rdram, ctx, runtime);
}

void entry_17baf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17baf0 inside entry_17bae8 (0x17bae8 - 0x17bafc)
    ctx->pc = 0x17baf0;
    entry_17bae8(rdram, ctx, runtime);
}

void entry_17bb20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bb20 inside entry_17bb18 (0x17bb18 - 0x17bb78)
    ctx->pc = 0x17bb20;
    entry_17bb18(rdram, ctx, runtime);
}

void entry_17bb24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bb24 inside entry_17bb18 (0x17bb18 - 0x17bb78)
    ctx->pc = 0x17bb24;
    entry_17bb18(rdram, ctx, runtime);
}

void entry_17bb40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bb40 inside entry_17bb18 (0x17bb18 - 0x17bb78)
    ctx->pc = 0x17bb40;
    entry_17bb18(rdram, ctx, runtime);
}

void entry_17bb4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bb4c inside entry_17bb18 (0x17bb18 - 0x17bb78)
    ctx->pc = 0x17bb4c;
    entry_17bb18(rdram, ctx, runtime);
}

void entry_17bb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bb54 inside entry_17bb18 (0x17bb18 - 0x17bb78)
    ctx->pc = 0x17bb54;
    entry_17bb18(rdram, ctx, runtime);
}

void entry_17bbbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bbbc inside SetJsgFocus__FP3JSGP2LO (0x17bb78 - 0x17bbdc)
    ctx->pc = 0x17bbbc;
    SetJsgFocus__FP3JSGP2LO(rdram, ctx, runtime);
}

void entry_17bc04(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bc04 inside entry_17bbdc (0x17bbdc - 0x17bc20)
    ctx->pc = 0x17bc04;
    entry_17bbdc(rdram, ctx, runtime);
}

void entry_17bc74(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bc74 inside entry_17bc70 (0x17bc70 - 0x17bc88)
    ctx->pc = 0x17bc74;
    entry_17bc70(rdram, ctx, runtime);
}

void entry_17bcbc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bcbc inside entry_17bcb8 (0x17bcb8 - 0x17bcd0)
    ctx->pc = 0x17bcbc;
    entry_17bcb8(rdram, ctx, runtime);
}

void entry_17bd9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bd9c inside entry_17bd94 (0x17bd94 - 0x17bdb0)
    ctx->pc = 0x17bd9c;
    entry_17bd94(rdram, ctx, runtime);
}

void entry_17bda0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bda0 inside entry_17bd94 (0x17bd94 - 0x17bdb0)
    ctx->pc = 0x17bda0;
    entry_17bd94(rdram, ctx, runtime);
}

void entry_17bed4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17bed4 inside entry_17becc (0x17becc - 0x17bee0)
    ctx->pc = 0x17bed4;
    entry_17becc(rdram, ctx, runtime);
}

void entry_17c020(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c020 inside entry_17c018 (0x17c018 - 0x17c0d4)
    ctx->pc = 0x17c020;
    entry_17c018(rdram, ctx, runtime);
}

void entry_17c058(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c058 inside entry_17c018 (0x17c018 - 0x17c0d4)
    ctx->pc = 0x17c058;
    entry_17c018(rdram, ctx, runtime);
}

void entry_17c074(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c074 inside entry_17c018 (0x17c018 - 0x17c0d4)
    ctx->pc = 0x17c074;
    entry_17c018(rdram, ctx, runtime);
}

void entry_17c078(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c078 inside entry_17c018 (0x17c018 - 0x17c0d4)
    ctx->pc = 0x17c078;
    entry_17c018(rdram, ctx, runtime);
}

void entry_17c07c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c07c inside entry_17c018 (0x17c018 - 0x17c0d4)
    ctx->pc = 0x17c07c;
    entry_17c018(rdram, ctx, runtime);
}

void entry_17c080(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c080 inside entry_17c018 (0x17c018 - 0x17c0d4)
    ctx->pc = 0x17c080;
    entry_17c018(rdram, ctx, runtime);
}

void entry_17c084(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c084 inside entry_17c018 (0x17c018 - 0x17c0d4)
    ctx->pc = 0x17c084;
    entry_17c018(rdram, ctx, runtime);
}

void entry_17c0a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c0a4 inside entry_17c018 (0x17c018 - 0x17c0d4)
    ctx->pc = 0x17c0a4;
    entry_17c018(rdram, ctx, runtime);
}

void entry_17c0b4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c0b4 inside entry_17c018 (0x17c018 - 0x17c0d4)
    ctx->pc = 0x17c0b4;
    entry_17c018(rdram, ctx, runtime);
}

void entry_17c0c0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c0c0 inside entry_17c018 (0x17c018 - 0x17c0d4)
    ctx->pc = 0x17c0c0;
    entry_17c018(rdram, ctx, runtime);
}

void entry_17c0dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c0dc inside entry_17c0d4 (0x17c0d4 - 0x17c0f0)
    ctx->pc = 0x17c0dc;
    entry_17c0d4(rdram, ctx, runtime);
}

void entry_17c16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c16c inside entry_17c164 (0x17c164 - 0x17c184)
    ctx->pc = 0x17c16c;
    entry_17c164(rdram, ctx, runtime);
}

void entry_17c170(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c170 inside entry_17c164 (0x17c164 - 0x17c184)
    ctx->pc = 0x17c170;
    entry_17c164(rdram, ctx, runtime);
}

void entry_17c1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c1ec inside entry_17c1d4 (0x17c1d4 - 0x17c208)
    ctx->pc = 0x17c1ec;
    entry_17c1d4(rdram, ctx, runtime);
}

void entry_17c2ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c2ac inside entry_17c2a4 (0x17c2a4 - 0x17c2c8)
    ctx->pc = 0x17c2ac;
    entry_17c2a4(rdram, ctx, runtime);
}

void entry_17c340(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c340 inside entry_17c310 (0x17c310 - 0x17c360)
    ctx->pc = 0x17c340;
    entry_17c310(rdram, ctx, runtime);
}

void entry_17c354(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c354 inside entry_17c310 (0x17c310 - 0x17c360)
    ctx->pc = 0x17c354;
    entry_17c310(rdram, ctx, runtime);
}

void entry_17c368(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c368 inside entry_17c360 (0x17c360 - 0x17c378)
    ctx->pc = 0x17c368;
    entry_17c360(rdram, ctx, runtime);
}

void entry_17c380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c380 inside entry_17c378 (0x17c378 - 0x17c390)
    ctx->pc = 0x17c380;
    entry_17c378(rdram, ctx, runtime);
}

void entry_17c3d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c3d0 inside entry_17c3cc (0x17c3cc - 0x17c3dc)
    ctx->pc = 0x17c3d0;
    entry_17c3cc(rdram, ctx, runtime);
}

void entry_17c3f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c3f0 inside entry_17c3ec (0x17c3ec - 0x17c428)
    ctx->pc = 0x17c3f0;
    entry_17c3ec(rdram, ctx, runtime);
}

void entry_17c3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c3f4 inside entry_17c3ec (0x17c3ec - 0x17c428)
    ctx->pc = 0x17c3f4;
    entry_17c3ec(rdram, ctx, runtime);
}

void entry_17c3f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c3f8 inside entry_17c3ec (0x17c3ec - 0x17c428)
    ctx->pc = 0x17c3f8;
    entry_17c3ec(rdram, ctx, runtime);
}

void entry_17c528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c528 inside entry_17c4c8 (0x17c4c8 - 0x17c574)
    ctx->pc = 0x17c528;
    entry_17c4c8(rdram, ctx, runtime);
}

void entry_17c558(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c558 inside entry_17c4c8 (0x17c4c8 - 0x17c574)
    ctx->pc = 0x17c558;
    entry_17c4c8(rdram, ctx, runtime);
}

void entry_17c55c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c55c inside entry_17c4c8 (0x17c4c8 - 0x17c574)
    ctx->pc = 0x17c55c;
    entry_17c4c8(rdram, ctx, runtime);
}

void entry_17c5a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c5a4 inside entry_17c574 (0x17c574 - 0x17c634)
    ctx->pc = 0x17c5a4;
    entry_17c574(rdram, ctx, runtime);
}

void entry_17c5b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c5b8 inside entry_17c574 (0x17c574 - 0x17c634)
    ctx->pc = 0x17c5b8;
    entry_17c574(rdram, ctx, runtime);
}

void entry_17c5c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c5c8 inside entry_17c574 (0x17c574 - 0x17c634)
    ctx->pc = 0x17c5c8;
    entry_17c574(rdram, ctx, runtime);
}

void entry_17c5d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c5d8 inside entry_17c574 (0x17c574 - 0x17c634)
    ctx->pc = 0x17c5d8;
    entry_17c574(rdram, ctx, runtime);
}

void entry_17c610(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c610 inside entry_17c574 (0x17c574 - 0x17c634)
    ctx->pc = 0x17c610;
    entry_17c574(rdram, ctx, runtime);
}

void entry_17c63c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c63c inside entry_17c634 (0x17c634 - 0x17c660)
    ctx->pc = 0x17c63c;
    entry_17c634(rdram, ctx, runtime);
}

void entry_17c640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c640 inside entry_17c634 (0x17c634 - 0x17c660)
    ctx->pc = 0x17c640;
    entry_17c634(rdram, ctx, runtime);
}

void entry_17c644(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c644 inside entry_17c634 (0x17c634 - 0x17c660)
    ctx->pc = 0x17c644;
    entry_17c634(rdram, ctx, runtime);
}

void entry_17c648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c648 inside entry_17c634 (0x17c634 - 0x17c660)
    ctx->pc = 0x17c648;
    entry_17c634(rdram, ctx, runtime);
}

void entry_17c6a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c6a0 inside entry_17c694 (0x17c694 - 0x17c6a8)
    ctx->pc = 0x17c6a0;
    entry_17c694(rdram, ctx, runtime);
}

void entry_17c6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c6ac inside entry_17c6a8 (0x17c6a8 - 0x17c6dc)
    ctx->pc = 0x17c6ac;
    entry_17c6a8(rdram, ctx, runtime);
}

void entry_17c6b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c6b0 inside entry_17c6a8 (0x17c6a8 - 0x17c6dc)
    ctx->pc = 0x17c6b0;
    entry_17c6a8(rdram, ctx, runtime);
}

void entry_17c6e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c6e8 inside entry_17c6dc (0x17c6dc - 0x17c6f8)
    ctx->pc = 0x17c6e8;
    entry_17c6dc(rdram, ctx, runtime);
}

void entry_17c700(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c700 inside entry_17c6f8 (0x17c6f8 - 0x17c718)
    ctx->pc = 0x17c700;
    entry_17c6f8(rdram, ctx, runtime);
}

void entry_17c704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c704 inside entry_17c6f8 (0x17c6f8 - 0x17c718)
    ctx->pc = 0x17c704;
    entry_17c6f8(rdram, ctx, runtime);
}

void entry_17c76c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c76c inside ReadJsgJoystick__FP3JSGP3JOY (0x17c718 - 0x17c780)
    ctx->pc = 0x17c76c;
    ReadJsgJoystick__FP3JSGP3JOY(rdram, ctx, runtime);
}

void entry_17c7ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c7ac inside entry_17c780 (0x17c780 - 0x17c7e0)
    ctx->pc = 0x17c7ac;
    entry_17c780(rdram, ctx, runtime);
}

void entry_17c7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c7c8 inside entry_17c780 (0x17c780 - 0x17c7e0)
    ctx->pc = 0x17c7c8;
    entry_17c780(rdram, ctx, runtime);
}

void entry_17c7ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c7ec inside entry_17c7e0 (0x17c7e0 - 0x17c88c)
    ctx->pc = 0x17c7ec;
    entry_17c7e0(rdram, ctx, runtime);
}

void entry_17c804(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c804 inside entry_17c7e0 (0x17c7e0 - 0x17c88c)
    ctx->pc = 0x17c804;
    entry_17c7e0(rdram, ctx, runtime);
}

void entry_17c854(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c854 inside entry_17c7e0 (0x17c7e0 - 0x17c88c)
    ctx->pc = 0x17c854;
    entry_17c7e0(rdram, ctx, runtime);
}

void entry_17c884(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c884 inside entry_17c7e0 (0x17c7e0 - 0x17c88c)
    ctx->pc = 0x17c884;
    entry_17c7e0(rdram, ctx, runtime);
}

void entry_17c8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c8fc inside entry_17c8f0 (0x17c8f0 - 0x17c904)
    ctx->pc = 0x17c8fc;
    entry_17c8f0(rdram, ctx, runtime);
}

void entry_17c918(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c918 inside entry_17c914 (0x17c914 - 0x17c948)
    ctx->pc = 0x17c918;
    entry_17c914(rdram, ctx, runtime);
}

void entry_17c91c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c91c inside entry_17c914 (0x17c914 - 0x17c948)
    ctx->pc = 0x17c91c;
    entry_17c914(rdram, ctx, runtime);
}

void entry_17c950(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17c950 inside entry_17c948 (0x17c948 - 0x17c9a0)
    ctx->pc = 0x17c950;
    entry_17c948(rdram, ctx, runtime);
}

void entry_17ca20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ca20 inside entry_17c9c8 (0x17c9c8 - 0x17ca40)
    ctx->pc = 0x17ca20;
    entry_17c9c8(rdram, ctx, runtime);
}

void entry_17ca2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ca2c inside entry_17c9c8 (0x17c9c8 - 0x17ca40)
    ctx->pc = 0x17ca2c;
    entry_17c9c8(rdram, ctx, runtime);
}

void entry_17ca8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ca8c inside entry_17ca78 (0x17ca78 - 0x17ca98)
    ctx->pc = 0x17ca8c;
    entry_17ca78(rdram, ctx, runtime);
}

void entry_17caa8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17caa8 inside entry_17ca98 (0x17ca98 - 0x17cae8)
    ctx->pc = 0x17caa8;
    entry_17ca98(rdram, ctx, runtime);
}

void entry_17cab4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cab4 inside entry_17ca98 (0x17ca98 - 0x17cae8)
    ctx->pc = 0x17cab4;
    entry_17ca98(rdram, ctx, runtime);
}

void entry_17cac0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cac0 inside entry_17ca98 (0x17ca98 - 0x17cae8)
    ctx->pc = 0x17cac0;
    entry_17ca98(rdram, ctx, runtime);
}

void entry_17cac8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cac8 inside entry_17ca98 (0x17ca98 - 0x17cae8)
    ctx->pc = 0x17cac8;
    entry_17ca98(rdram, ctx, runtime);
}

void entry_17caf0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17caf0 inside entry_17cae8 (0x17cae8 - 0x17cb00)
    ctx->pc = 0x17caf0;
    entry_17cae8(rdram, ctx, runtime);
}

void entry_17caf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17caf4 inside entry_17cae8 (0x17cae8 - 0x17cb00)
    ctx->pc = 0x17caf4;
    entry_17cae8(rdram, ctx, runtime);
}

void entry_17cb20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cb20 inside entry_17cb1c (0x17cb1c - 0x17cb94)
    ctx->pc = 0x17cb20;
    entry_17cb1c(rdram, ctx, runtime);
}

void entry_17cb24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cb24 inside entry_17cb1c (0x17cb1c - 0x17cb94)
    ctx->pc = 0x17cb24;
    entry_17cb1c(rdram, ctx, runtime);
}

void entry_17cb54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cb54 inside entry_17cb1c (0x17cb1c - 0x17cb94)
    ctx->pc = 0x17cb54;
    entry_17cb1c(rdram, ctx, runtime);
}

void entry_17cb60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cb60 inside entry_17cb1c (0x17cb1c - 0x17cb94)
    ctx->pc = 0x17cb60;
    entry_17cb1c(rdram, ctx, runtime);
}

void entry_17cc7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cc7c inside entry_17cc14 (0x17cc14 - 0x17cc9c)
    ctx->pc = 0x17cc7c;
    entry_17cc14(rdram, ctx, runtime);
}

void entry_17cc88(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cc88 inside entry_17cc14 (0x17cc14 - 0x17cc9c)
    ctx->pc = 0x17cc88;
    entry_17cc14(rdram, ctx, runtime);
}

void entry_17ccf8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ccf8 inside entry_17cce4 (0x17cce4 - 0x17cd04)
    ctx->pc = 0x17ccf8;
    entry_17cce4(rdram, ctx, runtime);
}

void entry_17cd14(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cd14 inside entry_17cd04 (0x17cd04 - 0x17cd54)
    ctx->pc = 0x17cd14;
    entry_17cd04(rdram, ctx, runtime);
}

void entry_17cd20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cd20 inside entry_17cd04 (0x17cd04 - 0x17cd54)
    ctx->pc = 0x17cd20;
    entry_17cd04(rdram, ctx, runtime);
}

void entry_17cd2c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cd2c inside entry_17cd04 (0x17cd04 - 0x17cd54)
    ctx->pc = 0x17cd2c;
    entry_17cd04(rdram, ctx, runtime);
}

void entry_17cd34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cd34 inside entry_17cd04 (0x17cd04 - 0x17cd54)
    ctx->pc = 0x17cd34;
    entry_17cd04(rdram, ctx, runtime);
}

void entry_17cd70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cd70 inside entry_17cd54 (0x17cd54 - 0x17cda8)
    ctx->pc = 0x17cd70;
    entry_17cd54(rdram, ctx, runtime);
}

void entry_17cd7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cd7c inside entry_17cd54 (0x17cd54 - 0x17cda8)
    ctx->pc = 0x17cd7c;
    entry_17cd54(rdram, ctx, runtime);
}

void entry_17cd80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cd80 inside entry_17cd54 (0x17cd54 - 0x17cda8)
    ctx->pc = 0x17cd80;
    entry_17cd54(rdram, ctx, runtime);
}

void entry_17cd84(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cd84 inside entry_17cd54 (0x17cd54 - 0x17cda8)
    ctx->pc = 0x17cd84;
    entry_17cd54(rdram, ctx, runtime);
}

void entry_17cdd0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cdd0 inside entry_17cdbc (0x17cdbc - 0x17cde0)
    ctx->pc = 0x17cdd0;
    entry_17cdbc(rdram, ctx, runtime);
}

void entry_17ce08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ce08 inside entry_17ce04 (0x17ce04 - 0x17ce20)
    ctx->pc = 0x17ce08;
    entry_17ce04(rdram, ctx, runtime);
}

void entry_17ce70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ce70 inside entry_17ce6c (0x17ce6c - 0x17ce80)
    ctx->pc = 0x17ce70;
    entry_17ce6c(rdram, ctx, runtime);
}

void entry_17cec8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cec8 inside entry_17cec4 (0x17cec4 - 0x17ced8)
    ctx->pc = 0x17cec8;
    entry_17cec4(rdram, ctx, runtime);
}

void entry_17cf28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cf28 inside entry_17cf24 (0x17cf24 - 0x17cf38)
    ctx->pc = 0x17cf28;
    entry_17cf24(rdram, ctx, runtime);
}

void entry_17cfa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cfa4 inside entry_17cf90 (0x17cf90 - 0x17cfc8)
    ctx->pc = 0x17cfa4;
    entry_17cf90(rdram, ctx, runtime);
}

void entry_17cfac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17cfac inside entry_17cf90 (0x17cf90 - 0x17cfc8)
    ctx->pc = 0x17cfac;
    entry_17cf90(rdram, ctx, runtime);
}

void entry_17d380(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d380 inside entry_17d37c (0x17d37c - 0x17d3ec)
    ctx->pc = 0x17d380;
    entry_17d37c(rdram, ctx, runtime);
}

void entry_17d3a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d3a4 inside entry_17d37c (0x17d37c - 0x17d3ec)
    ctx->pc = 0x17d3a4;
    entry_17d37c(rdram, ctx, runtime);
}

void entry_17d3c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d3c8 inside entry_17d37c (0x17d37c - 0x17d3ec)
    ctx->pc = 0x17d3c8;
    entry_17d37c(rdram, ctx, runtime);
}

void entry_17d3f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d3f4 inside entry_17d3ec (0x17d3ec - 0x17d488)
    ctx->pc = 0x17d3f4;
    entry_17d3ec(rdram, ctx, runtime);
}

void entry_17d464(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d464 inside entry_17d3ec (0x17d3ec - 0x17d488)
    ctx->pc = 0x17d464;
    entry_17d3ec(rdram, ctx, runtime);
}

void entry_17d474(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d474 inside entry_17d3ec (0x17d3ec - 0x17d488)
    ctx->pc = 0x17d474;
    entry_17d3ec(rdram, ctx, runtime);
}

void entry_17d4e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d4e8 inside entry_17d488 (0x17d488 - 0x17d5c0)
    ctx->pc = 0x17d4e8;
    entry_17d488(rdram, ctx, runtime);
}

void entry_17d4f0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d4f0 inside entry_17d488 (0x17d488 - 0x17d5c0)
    ctx->pc = 0x17d4f0;
    entry_17d488(rdram, ctx, runtime);
}

void entry_17d4fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d4fc inside entry_17d488 (0x17d488 - 0x17d5c0)
    ctx->pc = 0x17d4fc;
    entry_17d488(rdram, ctx, runtime);
}

void entry_17d518(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d518 inside entry_17d488 (0x17d488 - 0x17d5c0)
    ctx->pc = 0x17d518;
    entry_17d488(rdram, ctx, runtime);
}

void entry_17d520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d520 inside entry_17d488 (0x17d488 - 0x17d5c0)
    ctx->pc = 0x17d520;
    entry_17d488(rdram, ctx, runtime);
}

void entry_17d528(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d528 inside entry_17d488 (0x17d488 - 0x17d5c0)
    ctx->pc = 0x17d528;
    entry_17d488(rdram, ctx, runtime);
}

void entry_17d594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d594 inside entry_17d488 (0x17d488 - 0x17d5c0)
    ctx->pc = 0x17d594;
    entry_17d488(rdram, ctx, runtime);
}

void entry_17d598(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d598 inside entry_17d488 (0x17d488 - 0x17d5c0)
    ctx->pc = 0x17d598;
    entry_17d488(rdram, ctx, runtime);
}

void entry_17d5c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d5c4 inside entry_17d5c0 (0x17d5c0 - 0x17d5d8)
    ctx->pc = 0x17d5c4;
    entry_17d5c0(rdram, ctx, runtime);
}

void entry_17d640(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d640 inside UpdateJtActiveJump__FP2JTP3JOY (0x17d5d8 - 0x17d668)
    ctx->pc = 0x17d640;
    UpdateJtActiveJump__FP2JTP3JOY(rdram, ctx, runtime);
}

void entry_17d648(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d648 inside UpdateJtActiveJump__FP2JTP3JOY (0x17d5d8 - 0x17d668)
    ctx->pc = 0x17d648;
    UpdateJtActiveJump__FP2JTP3JOY(rdram, ctx, runtime);
}

void entry_17d64c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d64c inside UpdateJtActiveJump__FP2JTP3JOY (0x17d5d8 - 0x17d668)
    ctx->pc = 0x17d64c;
    UpdateJtActiveJump__FP2JTP3JOY(rdram, ctx, runtime);
}

void entry_17d6d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d6d8 inside entry_17d668 (0x17d668 - 0x17d770)
    ctx->pc = 0x17d6d8;
    entry_17d668(rdram, ctx, runtime);
}

void entry_17d744(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d744 inside entry_17d668 (0x17d668 - 0x17d770)
    ctx->pc = 0x17d744;
    entry_17d668(rdram, ctx, runtime);
}

void entry_17d754(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d754 inside entry_17d668 (0x17d668 - 0x17d770)
    ctx->pc = 0x17d754;
    entry_17d668(rdram, ctx, runtime);
}

void entry_17d7c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d7c4 inside entry_17d770 (0x17d770 - 0x17d8c8)
    ctx->pc = 0x17d7c4;
    entry_17d770(rdram, ctx, runtime);
}

void entry_17d7c8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d7c8 inside entry_17d770 (0x17d770 - 0x17d8c8)
    ctx->pc = 0x17d7c8;
    entry_17d770(rdram, ctx, runtime);
}

void entry_17d7cc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d7cc inside entry_17d770 (0x17d770 - 0x17d8c8)
    ctx->pc = 0x17d7cc;
    entry_17d770(rdram, ctx, runtime);
}

void entry_17d7d0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d7d0 inside entry_17d770 (0x17d770 - 0x17d8c8)
    ctx->pc = 0x17d7d0;
    entry_17d770(rdram, ctx, runtime);
}

void entry_17d818(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d818 inside entry_17d770 (0x17d770 - 0x17d8c8)
    ctx->pc = 0x17d818;
    entry_17d770(rdram, ctx, runtime);
}

void entry_17d848(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d848 inside entry_17d770 (0x17d770 - 0x17d8c8)
    ctx->pc = 0x17d848;
    entry_17d770(rdram, ctx, runtime);
}

void entry_17d96c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d96c inside entry_17d940 (0x17d940 - 0x17d9e8)
    ctx->pc = 0x17d96c;
    entry_17d940(rdram, ctx, runtime);
}

void entry_17d99c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d99c inside entry_17d940 (0x17d940 - 0x17d9e8)
    ctx->pc = 0x17d99c;
    entry_17d940(rdram, ctx, runtime);
}

void entry_17d9bc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d9bc inside entry_17d940 (0x17d940 - 0x17d9e8)
    ctx->pc = 0x17d9bc;
    entry_17d940(rdram, ctx, runtime);
}

void entry_17d9c4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d9c4 inside entry_17d940 (0x17d940 - 0x17d9e8)
    ctx->pc = 0x17d9c4;
    entry_17d940(rdram, ctx, runtime);
}

void entry_17d9e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17d9e0 inside entry_17d940 (0x17d940 - 0x17d9e8)
    ctx->pc = 0x17d9e0;
    entry_17d940(rdram, ctx, runtime);
}

void entry_17db1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17db1c inside entry_17daec (0x17daec - 0x17dba8)
    ctx->pc = 0x17db1c;
    entry_17daec(rdram, ctx, runtime);
}

void entry_17db44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17db44 inside entry_17daec (0x17daec - 0x17dba8)
    ctx->pc = 0x17db44;
    entry_17daec(rdram, ctx, runtime);
}

void entry_17db64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17db64 inside entry_17daec (0x17daec - 0x17dba8)
    ctx->pc = 0x17db64;
    entry_17daec(rdram, ctx, runtime);
}

void entry_17db6c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17db6c inside entry_17daec (0x17daec - 0x17dba8)
    ctx->pc = 0x17db6c;
    entry_17daec(rdram, ctx, runtime);
}

void entry_17db94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17db94 inside entry_17daec (0x17daec - 0x17dba8)
    ctx->pc = 0x17db94;
    entry_17daec(rdram, ctx, runtime);
}

void entry_17dbc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17dbc0 inside entry_17dbbc (0x17dbbc - 0x17dc2c)
    ctx->pc = 0x17dbc0;
    entry_17dbbc(rdram, ctx, runtime);
}

void entry_17dc34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17dc34 inside entry_17dc2c (0x17dc2c - 0x17dca8)
    ctx->pc = 0x17dc34;
    entry_17dc2c(rdram, ctx, runtime);
}

void entry_17dcac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17dcac inside entry_17dca8 (0x17dca8 - 0x17dce0)
    ctx->pc = 0x17dcac;
    entry_17dca8(rdram, ctx, runtime);
}

void entry_17dd40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17dd40 inside FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR (0x17dce0 - 0x17de88)
    ctx->pc = 0x17dd40;
    FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR(rdram, ctx, runtime);
}

void entry_17dd80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17dd80 inside FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR (0x17dce0 - 0x17de88)
    ctx->pc = 0x17dd80;
    FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR(rdram, ctx, runtime);
}

void entry_17de18(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17de18 inside FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR (0x17dce0 - 0x17de88)
    ctx->pc = 0x17de18;
    FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR(rdram, ctx, runtime);
}

void entry_17de24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17de24 inside FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR (0x17dce0 - 0x17de88)
    ctx->pc = 0x17de24;
    FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR(rdram, ctx, runtime);
}

void entry_17de78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17de78 inside FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR (0x17dce0 - 0x17de88)
    ctx->pc = 0x17de78;
    FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR(rdram, ctx, runtime);
}

void entry_17de80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17de80 inside FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR (0x17dce0 - 0x17de88)
    ctx->pc = 0x17de80;
    FCheckJtSingleEdge__FP2JTP2SOP4EDGEP6VECTOR(rdram, ctx, runtime);
}

void entry_17df28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17df28 inside entry_17df0c (0x17df0c - 0x17df3c)
    ctx->pc = 0x17df28;
    entry_17df0c(rdram, ctx, runtime);
}

void entry_17df70(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17df70 inside entry_17df50 (0x17df50 - 0x17dfd4)
    ctx->pc = 0x17df70;
    entry_17df50(rdram, ctx, runtime);
}

void entry_17dfb0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17dfb0 inside entry_17df50 (0x17df50 - 0x17dfd4)
    ctx->pc = 0x17dfb0;
    entry_17df50(rdram, ctx, runtime);
}

void entry_17e008(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e008 inside entry_17dfd4 (0x17dfd4 - 0x17e088)
    ctx->pc = 0x17e008;
    entry_17dfd4(rdram, ctx, runtime);
}

void entry_17e00c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e00c inside entry_17dfd4 (0x17dfd4 - 0x17e088)
    ctx->pc = 0x17e00c;
    entry_17dfd4(rdram, ctx, runtime);
}

void entry_17e018(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e018 inside entry_17dfd4 (0x17dfd4 - 0x17e088)
    ctx->pc = 0x17e018;
    entry_17dfd4(rdram, ctx, runtime);
}

void entry_17e024(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e024 inside entry_17dfd4 (0x17dfd4 - 0x17e088)
    ctx->pc = 0x17e024;
    entry_17dfd4(rdram, ctx, runtime);
}

void entry_17e04c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e04c inside entry_17dfd4 (0x17dfd4 - 0x17e088)
    ctx->pc = 0x17e04c;
    entry_17dfd4(rdram, ctx, runtime);
}

void entry_17e0e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e0e4 inside FCheckJtEdgeGrab__FP2JTP2SOP6VECTOR3XPKPvT2 (0x17e088 - 0x17e12c)
    ctx->pc = 0x17e0e4;
    FCheckJtEdgeGrab__FP2JTP2SOP6VECTOR3XPKPvT2(rdram, ctx, runtime);
}

void entry_17e0f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e0f8 inside FCheckJtEdgeGrab__FP2JTP2SOP6VECTOR3XPKPvT2 (0x17e088 - 0x17e12c)
    ctx->pc = 0x17e0f8;
    FCheckJtEdgeGrab__FP2JTP2SOP6VECTOR3XPKPvT2(rdram, ctx, runtime);
}

void entry_17e140(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e140 inside entry_17e12c (0x17e12c - 0x17e158)
    ctx->pc = 0x17e140;
    entry_17e12c(rdram, ctx, runtime);
}

void entry_17e16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e16c inside entry_17e158 (0x17e158 - 0x17e1ec)
    ctx->pc = 0x17e16c;
    entry_17e158(rdram, ctx, runtime);
}

void entry_17e178(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e178 inside entry_17e158 (0x17e158 - 0x17e1ec)
    ctx->pc = 0x17e178;
    entry_17e158(rdram, ctx, runtime);
}

void entry_17e1dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e1dc inside entry_17e158 (0x17e158 - 0x17e1ec)
    ctx->pc = 0x17e1dc;
    entry_17e158(rdram, ctx, runtime);
}

void entry_17e1f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e1f4 inside entry_17e1ec (0x17e1ec - 0x17e250)
    ctx->pc = 0x17e1f4;
    entry_17e1ec(rdram, ctx, runtime);
}

void entry_17e1fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e1fc inside entry_17e1ec (0x17e1ec - 0x17e250)
    ctx->pc = 0x17e1fc;
    entry_17e1ec(rdram, ctx, runtime);
}

void entry_17e240(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e240 inside entry_17e1ec (0x17e1ec - 0x17e250)
    ctx->pc = 0x17e240;
    entry_17e1ec(rdram, ctx, runtime);
}

void entry_17e29c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e29c inside entry_17e284 (0x17e284 - 0x17e2c8)
    ctx->pc = 0x17e29c;
    entry_17e284(rdram, ctx, runtime);
}

void entry_17e2a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e2a8 inside entry_17e284 (0x17e284 - 0x17e2c8)
    ctx->pc = 0x17e2a8;
    entry_17e284(rdram, ctx, runtime);
}

void entry_17e2b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e2b8 inside entry_17e284 (0x17e284 - 0x17e2c8)
    ctx->pc = 0x17e2b8;
    entry_17e284(rdram, ctx, runtime);
}

void entry_17e314(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e314 inside entry_17e2fc (0x17e2fc - 0x17e39c)
    ctx->pc = 0x17e314;
    entry_17e2fc(rdram, ctx, runtime);
}

void entry_17e320(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e320 inside entry_17e2fc (0x17e2fc - 0x17e39c)
    ctx->pc = 0x17e320;
    entry_17e2fc(rdram, ctx, runtime);
}

void entry_17e374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e374 inside entry_17e2fc (0x17e2fc - 0x17e39c)
    ctx->pc = 0x17e374;
    entry_17e2fc(rdram, ctx, runtime);
}

void entry_17e37c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e37c inside entry_17e2fc (0x17e2fc - 0x17e39c)
    ctx->pc = 0x17e37c;
    entry_17e2fc(rdram, ctx, runtime);
}

void entry_17e388(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e388 inside entry_17e2fc (0x17e2fc - 0x17e39c)
    ctx->pc = 0x17e388;
    entry_17e2fc(rdram, ctx, runtime);
}

void entry_17e38c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e38c inside entry_17e2fc (0x17e2fc - 0x17e39c)
    ctx->pc = 0x17e38c;
    entry_17e2fc(rdram, ctx, runtime);
}

void entry_17e390(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e390 inside entry_17e2fc (0x17e2fc - 0x17e39c)
    ctx->pc = 0x17e390;
    entry_17e2fc(rdram, ctx, runtime);
}

void entry_17e394(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e394 inside entry_17e2fc (0x17e2fc - 0x17e39c)
    ctx->pc = 0x17e394;
    entry_17e2fc(rdram, ctx, runtime);
}

void entry_17e440(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e440 inside PxpFindJtBestEdge__FP2JTPiP6VECTOR (0x17e3c8 - 0x17e564)
    ctx->pc = 0x17e440;
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime);
}

void entry_17e458(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e458 inside PxpFindJtBestEdge__FP2JTPiP6VECTOR (0x17e3c8 - 0x17e564)
    ctx->pc = 0x17e458;
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime);
}

void entry_17e4a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e4a0 inside PxpFindJtBestEdge__FP2JTPiP6VECTOR (0x17e3c8 - 0x17e564)
    ctx->pc = 0x17e4a0;
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime);
}

void entry_17e4b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e4b8 inside PxpFindJtBestEdge__FP2JTPiP6VECTOR (0x17e3c8 - 0x17e564)
    ctx->pc = 0x17e4b8;
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime);
}

void entry_17e4d8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e4d8 inside PxpFindJtBestEdge__FP2JTPiP6VECTOR (0x17e3c8 - 0x17e564)
    ctx->pc = 0x17e4d8;
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime);
}

void entry_17e4dc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e4dc inside PxpFindJtBestEdge__FP2JTPiP6VECTOR (0x17e3c8 - 0x17e564)
    ctx->pc = 0x17e4dc;
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime);
}

void entry_17e500(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e500 inside PxpFindJtBestEdge__FP2JTPiP6VECTOR (0x17e3c8 - 0x17e564)
    ctx->pc = 0x17e500;
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime);
}

void entry_17e510(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e510 inside PxpFindJtBestEdge__FP2JTPiP6VECTOR (0x17e3c8 - 0x17e564)
    ctx->pc = 0x17e510;
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime);
}

void entry_17e520(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e520 inside PxpFindJtBestEdge__FP2JTPiP6VECTOR (0x17e3c8 - 0x17e564)
    ctx->pc = 0x17e520;
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime);
}

void entry_17e530(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e530 inside PxpFindJtBestEdge__FP2JTPiP6VECTOR (0x17e3c8 - 0x17e564)
    ctx->pc = 0x17e530;
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime);
}

void entry_17e53c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e53c inside PxpFindJtBestEdge__FP2JTPiP6VECTOR (0x17e3c8 - 0x17e564)
    ctx->pc = 0x17e53c;
    PxpFindJtBestEdge__FP2JTPiP6VECTOR(rdram, ctx, runtime);
}

void entry_17e594(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e594 inside entry_17e564 (0x17e564 - 0x17e5a4)
    ctx->pc = 0x17e594;
    entry_17e564(rdram, ctx, runtime);
}

void entry_17e5a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e5a8 inside entry_17e5a4 (0x17e5a4 - 0x17e63c)
    ctx->pc = 0x17e5a8;
    entry_17e5a4(rdram, ctx, runtime);
}

void entry_17e668(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e668 inside entry_17e63c (0x17e63c - 0x17e6d0)
    ctx->pc = 0x17e668;
    entry_17e63c(rdram, ctx, runtime);
}

void entry_17e680(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e680 inside entry_17e63c (0x17e63c - 0x17e6d0)
    ctx->pc = 0x17e680;
    entry_17e63c(rdram, ctx, runtime);
}

void entry_17e684(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e684 inside entry_17e63c (0x17e63c - 0x17e6d0)
    ctx->pc = 0x17e684;
    entry_17e63c(rdram, ctx, runtime);
}

void entry_17e68c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e68c inside entry_17e63c (0x17e63c - 0x17e6d0)
    ctx->pc = 0x17e68c;
    entry_17e63c(rdram, ctx, runtime);
}

void entry_17e698(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e698 inside entry_17e63c (0x17e63c - 0x17e6d0)
    ctx->pc = 0x17e698;
    entry_17e63c(rdram, ctx, runtime);
}

void entry_17e69c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e69c inside entry_17e63c (0x17e63c - 0x17e6d0)
    ctx->pc = 0x17e69c;
    entry_17e63c(rdram, ctx, runtime);
}

void entry_17e6fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e6fc inside JtsResetJt__FP2JT (0x17e6d0 - 0x17e710)
    ctx->pc = 0x17e6fc;
    JtsResetJt__FP2JT(rdram, ctx, runtime);
}

void entry_17e704(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e704 inside JtsResetJt__FP2JT (0x17e6d0 - 0x17e710)
    ctx->pc = 0x17e704;
    JtsResetJt__FP2JT(rdram, ctx, runtime);
}

void entry_17e7b8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e7b8 inside entry_17e798 (0x17e798 - 0x17e898)
    ctx->pc = 0x17e7b8;
    entry_17e798(rdram, ctx, runtime);
}

void entry_17e7e4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e7e4 inside entry_17e798 (0x17e798 - 0x17e898)
    ctx->pc = 0x17e7e4;
    entry_17e798(rdram, ctx, runtime);
}

void entry_17e850(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e850 inside entry_17e798 (0x17e798 - 0x17e898)
    ctx->pc = 0x17e850;
    entry_17e798(rdram, ctx, runtime);
}

void entry_17e870(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e870 inside entry_17e798 (0x17e798 - 0x17e898)
    ctx->pc = 0x17e870;
    entry_17e798(rdram, ctx, runtime);
}

void entry_17e890(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e890 inside entry_17e798 (0x17e798 - 0x17e898)
    ctx->pc = 0x17e890;
    entry_17e798(rdram, ctx, runtime);
}

void entry_17e8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e8a0 inside entry_17e898 (0x17e898 - 0x17e8b8)
    ctx->pc = 0x17e8a0;
    entry_17e898(rdram, ctx, runtime);
}

void entry_17e8ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e8ac inside entry_17e898 (0x17e898 - 0x17e8b8)
    ctx->pc = 0x17e8ac;
    entry_17e898(rdram, ctx, runtime);
}

void entry_17e8fc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e8fc inside entry_17e8b8 (0x17e8b8 - 0x17e944)
    ctx->pc = 0x17e8fc;
    entry_17e8b8(rdram, ctx, runtime);
}

void entry_17e9a4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e9a4 inside entry_17e944 (0x17e944 - 0x17e9f0)
    ctx->pc = 0x17e9a4;
    entry_17e944(rdram, ctx, runtime);
}

void entry_17e9b0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e9b0 inside entry_17e944 (0x17e944 - 0x17e9f0)
    ctx->pc = 0x17e9b0;
    entry_17e944(rdram, ctx, runtime);
}

void entry_17e9f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e9f4 inside entry_17e9f0 (0x17e9f0 - 0x17ea40)
    ctx->pc = 0x17e9f4;
    entry_17e9f0(rdram, ctx, runtime);
}

void entry_17e9f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17e9f8 inside entry_17e9f0 (0x17e9f0 - 0x17ea40)
    ctx->pc = 0x17e9f8;
    entry_17e9f0(rdram, ctx, runtime);
}

void entry_17ea0c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ea0c inside entry_17e9f0 (0x17e9f0 - 0x17ea40)
    ctx->pc = 0x17ea0c;
    entry_17e9f0(rdram, ctx, runtime);
}

void entry_17ea28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ea28 inside entry_17e9f0 (0x17e9f0 - 0x17ea40)
    ctx->pc = 0x17ea28;
    entry_17e9f0(rdram, ctx, runtime);
}

void entry_17eadc(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eadc inside entry_17ea40 (0x17ea40 - 0x17eb18)
    ctx->pc = 0x17eadc;
    entry_17ea40(rdram, ctx, runtime);
}

void entry_17eaec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eaec inside entry_17ea40 (0x17ea40 - 0x17eb18)
    ctx->pc = 0x17eaec;
    entry_17ea40(rdram, ctx, runtime);
}

void entry_17eb20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eb20 inside entry_17eb18 (0x17eb18 - 0x17eb40)
    ctx->pc = 0x17eb20;
    entry_17eb18(rdram, ctx, runtime);
}

void entry_17eb48(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eb48 inside entry_17eb40 (0x17eb40 - 0x17eb58)
    ctx->pc = 0x17eb48;
    entry_17eb40(rdram, ctx, runtime);
}

void entry_17eb4c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eb4c inside entry_17eb40 (0x17eb40 - 0x17eb58)
    ctx->pc = 0x17eb4c;
    entry_17eb40(rdram, ctx, runtime);
}

void entry_17eb8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eb8c inside entry_17eb74 (0x17eb74 - 0x17ec38)
    ctx->pc = 0x17eb8c;
    entry_17eb74(rdram, ctx, runtime);
}

void entry_17eb94(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eb94 inside entry_17eb74 (0x17eb74 - 0x17ec38)
    ctx->pc = 0x17eb94;
    entry_17eb74(rdram, ctx, runtime);
}

void entry_17ebe8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ebe8 inside entry_17eb74 (0x17eb74 - 0x17ec38)
    ctx->pc = 0x17ebe8;
    entry_17eb74(rdram, ctx, runtime);
}

void entry_17ebf4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ebf4 inside entry_17eb74 (0x17eb74 - 0x17ec38)
    ctx->pc = 0x17ebf4;
    entry_17eb74(rdram, ctx, runtime);
}

void entry_17ec3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ec3c inside entry_17ec38 (0x17ec38 - 0x17ecac)
    ctx->pc = 0x17ec3c;
    entry_17ec38(rdram, ctx, runtime);
}

void entry_17ec50(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ec50 inside entry_17ec38 (0x17ec38 - 0x17ecac)
    ctx->pc = 0x17ec50;
    entry_17ec38(rdram, ctx, runtime);
}

void entry_17ec78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ec78 inside entry_17ec38 (0x17ec38 - 0x17ecac)
    ctx->pc = 0x17ec78;
    entry_17ec38(rdram, ctx, runtime);
}

void entry_17eca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eca4 inside entry_17ec38 (0x17ec38 - 0x17ecac)
    ctx->pc = 0x17eca4;
    entry_17ec38(rdram, ctx, runtime);
}

void entry_17ecb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ecb4 inside entry_17ecac (0x17ecac - 0x17ece8)
    ctx->pc = 0x17ecb4;
    entry_17ecac(rdram, ctx, runtime);
}

void entry_17ed54(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ed54 inside FUN_0017ece8 (0x17ece8 - 0x17edb8)
    ctx->pc = 0x17ed54;
    FUN_0017ece8(rdram, ctx, runtime);
}

void entry_17ed5c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ed5c inside FUN_0017ece8 (0x17ece8 - 0x17edb8)
    ctx->pc = 0x17ed5c;
    FUN_0017ece8(rdram, ctx, runtime);
}

void entry_17ed78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ed78 inside FUN_0017ece8 (0x17ece8 - 0x17edb8)
    ctx->pc = 0x17ed78;
    FUN_0017ece8(rdram, ctx, runtime);
}

void entry_17ed80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ed80 inside FUN_0017ece8 (0x17ece8 - 0x17edb8)
    ctx->pc = 0x17ed80;
    FUN_0017ece8(rdram, ctx, runtime);
}

void entry_17ed9c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ed9c inside FUN_0017ece8 (0x17ece8 - 0x17edb8)
    ctx->pc = 0x17ed9c;
    FUN_0017ece8(rdram, ctx, runtime);
}

void entry_17eda8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eda8 inside FUN_0017ece8 (0x17ece8 - 0x17edb8)
    ctx->pc = 0x17eda8;
    FUN_0017ece8(rdram, ctx, runtime);
}

void entry_17ee20(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ee20 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17ee20;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17ee30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ee30 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17ee30;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17ee44(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ee44 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17ee44;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17ee58(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ee58 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17ee58;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17ee68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ee68 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17ee68;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17ee80(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ee80 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17ee80;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17eea8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eea8 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17eea8;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17eeb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eeb4 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17eeb4;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17eec0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eec0 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17eec0;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17eed0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eed0 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17eed0;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17eee0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eee0 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17eee0;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17eef0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eef0 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17eef0;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17ef08(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ef08 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17ef08;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17ef30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ef30 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17ef30;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17ef38(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ef38 inside entry_17ee04 (0x17ee04 - 0x17ef4c)
    ctx->pc = 0x17ef38;
    entry_17ee04(rdram, ctx, runtime);
}

void entry_17ef68(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ef68 inside entry_17ef4c (0x17ef4c - 0x17efd0)
    ctx->pc = 0x17ef68;
    entry_17ef4c(rdram, ctx, runtime);
}

void entry_17ef78(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ef78 inside entry_17ef4c (0x17ef4c - 0x17efd0)
    ctx->pc = 0x17ef78;
    entry_17ef4c(rdram, ctx, runtime);
}

void entry_17ef8c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ef8c inside entry_17ef4c (0x17ef4c - 0x17efd0)
    ctx->pc = 0x17ef8c;
    entry_17ef4c(rdram, ctx, runtime);
}

void entry_17efc0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17efc0 inside entry_17ef4c (0x17ef4c - 0x17efd0)
    ctx->pc = 0x17efc0;
    entry_17ef4c(rdram, ctx, runtime);
}

void entry_17efc8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17efc8 inside entry_17ef4c (0x17ef4c - 0x17efd0)
    ctx->pc = 0x17efc8;
    entry_17ef4c(rdram, ctx, runtime);
}

void entry_17eff4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17eff4 inside entry_17efd0 (0x17efd0 - 0x17f018)
    ctx->pc = 0x17eff4;
    entry_17efd0(rdram, ctx, runtime);
}

void entry_17f0a8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f0a8 inside entry_17f0a0 (0x17f0a0 - 0x17f0ec)
    ctx->pc = 0x17f0a8;
    entry_17f0a0(rdram, ctx, runtime);
}

void entry_17f0f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f0f4 inside entry_17f0ec (0x17f0ec - 0x17f0fc)
    ctx->pc = 0x17f0f4;
    entry_17f0ec(rdram, ctx, runtime);
}

void entry_17f10c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f10c inside entry_17f0fc (0x17f0fc - 0x17f204)
    ctx->pc = 0x17f10c;
    entry_17f0fc(rdram, ctx, runtime);
}

void entry_17f110(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f110 inside entry_17f0fc (0x17f0fc - 0x17f204)
    ctx->pc = 0x17f110;
    entry_17f0fc(rdram, ctx, runtime);
}

void entry_17f134(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f134 inside entry_17f0fc (0x17f0fc - 0x17f204)
    ctx->pc = 0x17f134;
    entry_17f0fc(rdram, ctx, runtime);
}

void entry_17f144(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f144 inside entry_17f0fc (0x17f0fc - 0x17f204)
    ctx->pc = 0x17f144;
    entry_17f0fc(rdram, ctx, runtime);
}

void entry_17f16c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f16c inside entry_17f0fc (0x17f0fc - 0x17f204)
    ctx->pc = 0x17f16c;
    entry_17f0fc(rdram, ctx, runtime);
}

void entry_17f190(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f190 inside entry_17f0fc (0x17f0fc - 0x17f204)
    ctx->pc = 0x17f190;
    entry_17f0fc(rdram, ctx, runtime);
}

void entry_17f1e0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f1e0 inside entry_17f0fc (0x17f0fc - 0x17f204)
    ctx->pc = 0x17f1e0;
    entry_17f0fc(rdram, ctx, runtime);
}

void entry_17f1ec(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f1ec inside entry_17f0fc (0x17f0fc - 0x17f204)
    ctx->pc = 0x17f1ec;
    entry_17f0fc(rdram, ctx, runtime);
}

void entry_17f1f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f1f4 inside entry_17f0fc (0x17f0fc - 0x17f204)
    ctx->pc = 0x17f1f4;
    entry_17f0fc(rdram, ctx, runtime);
}

void entry_17f1f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f1f8 inside entry_17f0fc (0x17f0fc - 0x17f204)
    ctx->pc = 0x17f1f8;
    entry_17f0fc(rdram, ctx, runtime);
}

void entry_17f254(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f254 inside entry_17f23c (0x17f23c - 0x17f274)
    ctx->pc = 0x17f254;
    entry_17f23c(rdram, ctx, runtime);
}

void entry_17f258(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f258 inside entry_17f23c (0x17f23c - 0x17f274)
    ctx->pc = 0x17f258;
    entry_17f23c(rdram, ctx, runtime);
}

void entry_17f27c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f27c inside entry_17f274 (0x17f274 - 0x17f284)
    ctx->pc = 0x17f27c;
    entry_17f274(rdram, ctx, runtime);
}

void entry_17f2a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f2a0 inside entry_17f298 (0x17f298 - 0x17f33c)
    ctx->pc = 0x17f2a0;
    entry_17f298(rdram, ctx, runtime);
}

void entry_17f334(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f334 inside entry_17f298 (0x17f298 - 0x17f33c)
    ctx->pc = 0x17f334;
    entry_17f298(rdram, ctx, runtime);
}

void entry_17f374(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f374 inside entry_17f33c (0x17f33c - 0x17f410)
    ctx->pc = 0x17f374;
    entry_17f33c(rdram, ctx, runtime);
}

void entry_17f468(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f468 inside entry_17f410 (0x17f410 - 0x17f484)
    ctx->pc = 0x17f468;
    entry_17f410(rdram, ctx, runtime);
}

void entry_17f47c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f47c inside entry_17f410 (0x17f410 - 0x17f484)
    ctx->pc = 0x17f47c;
    entry_17f410(rdram, ctx, runtime);
}

void entry_17f540(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f540 inside entry_17f510 (0x17f510 - 0x17f54c)
    ctx->pc = 0x17f540;
    entry_17f510(rdram, ctx, runtime);
}

void entry_17f544(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f544 inside entry_17f510 (0x17f510 - 0x17f54c)
    ctx->pc = 0x17f544;
    entry_17f510(rdram, ctx, runtime);
}

void entry_17f554(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f554 inside entry_17f54c (0x17f54c - 0x17f590)
    ctx->pc = 0x17f554;
    entry_17f54c(rdram, ctx, runtime);
}

void entry_17f690(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f690 inside entry_17f630 (0x17f630 - 0x17f6a4)
    ctx->pc = 0x17f690;
    entry_17f630(rdram, ctx, runtime);
}

void entry_17f6ac(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f6ac inside entry_17f6a4 (0x17f6a4 - 0x17f6d4)
    ctx->pc = 0x17f6ac;
    entry_17f6a4(rdram, ctx, runtime);
}

void entry_17f764(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f764 inside entry_17f704 (0x17f704 - 0x17f77c)
    ctx->pc = 0x17f764;
    entry_17f704(rdram, ctx, runtime);
}

void entry_17f7e8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f7e8 inside entry_17f794 (0x17f794 - 0x17f7f0)
    ctx->pc = 0x17f7e8;
    entry_17f794(rdram, ctx, runtime);
}

void entry_17f7f8(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f7f8 inside entry_17f7f0 (0x17f7f0 - 0x17f810)
    ctx->pc = 0x17f7f8;
    entry_17f7f0(rdram, ctx, runtime);
}

void entry_17f844(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f844 inside entry_17f828 (0x17f828 - 0x17f868)
    ctx->pc = 0x17f844;
    entry_17f828(rdram, ctx, runtime);
}

void entry_17f8a0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f8a0 inside entry_17f868 (0x17f868 - 0x17f8ec)
    ctx->pc = 0x17f8a0;
    entry_17f868(rdram, ctx, runtime);
}

void entry_17f8f4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f8f4 inside entry_17f8ec (0x17f8ec - 0x17f914)
    ctx->pc = 0x17f8f4;
    entry_17f8ec(rdram, ctx, runtime);
}

void entry_17f978(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17f978 inside entry_17f974 (0x17f974 - 0x17f9e8)
    ctx->pc = 0x17f978;
    entry_17f974(rdram, ctx, runtime);
}

void entry_17faa4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17faa4 inside entry_17faa0 (0x17faa0 - 0x17fac0)
    ctx->pc = 0x17faa4;
    entry_17faa0(rdram, ctx, runtime);
}

void entry_17fb28(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17fb28 inside entry_17fb00 (0x17fb00 - 0x17fb78)
    ctx->pc = 0x17fb28;
    entry_17fb00(rdram, ctx, runtime);
}

void entry_17fb3c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17fb3c inside entry_17fb00 (0x17fb00 - 0x17fb78)
    ctx->pc = 0x17fb3c;
    entry_17fb00(rdram, ctx, runtime);
}

void entry_17fb40(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17fb40 inside entry_17fb00 (0x17fb00 - 0x17fb78)
    ctx->pc = 0x17fb40;
    entry_17fb00(rdram, ctx, runtime);
}

void entry_17fb60(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17fb60 inside entry_17fb00 (0x17fb00 - 0x17fb78)
    ctx->pc = 0x17fb60;
    entry_17fb00(rdram, ctx, runtime);
}

void entry_17fb64(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17fb64 inside entry_17fb00 (0x17fb00 - 0x17fb78)
    ctx->pc = 0x17fb64;
    entry_17fb00(rdram, ctx, runtime);
}

void entry_17fc1c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17fc1c inside GetJtJumpVelocity__FP2JTP6VECTOR (0x17fb78 - 0x17fc48)
    ctx->pc = 0x17fc1c;
    GetJtJumpVelocity__FP2JTP6VECTOR(rdram, ctx, runtime);
}

void entry_17fca4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17fca4 inside GetJtJumpToTargetVelocity__FP2JTP6VECTOR (0x17fc48 - 0x17fcc8)
    ctx->pc = 0x17fca4;
    GetJtJumpToTargetVelocity__FP2JTP6VECTOR(rdram, ctx, runtime);
}

void entry_17fcb4(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17fcb4 inside GetJtJumpToTargetVelocity__FP2JTP6VECTOR (0x17fc48 - 0x17fcc8)
    ctx->pc = 0x17fcb4;
    GetJtJumpToTargetVelocity__FP2JTP6VECTOR(rdram, ctx, runtime);
}

void entry_17fd24(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17fd24 inside GetJtJumpBoostVelocity__FP2JTP6VECTOR (0x17fcc8 - 0x17fd48)
    ctx->pc = 0x17fd24;
    GetJtJumpBoostVelocity__FP2JTP6VECTOR(rdram, ctx, runtime);
}

void entry_17fd34(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17fd34 inside GetJtJumpBoostVelocity__FP2JTP6VECTOR (0x17fcc8 - 0x17fd48)
    ctx->pc = 0x17fd34;
    GetJtJumpBoostVelocity__FP2JTP6VECTOR(rdram, ctx, runtime);
}

void entry_17fe7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17fe7c inside entry_17fe78 (0x17fe78 - 0x17fe90)
    ctx->pc = 0x17fe7c;
    entry_17fe78(rdram, ctx, runtime);
}

void entry_17ff30(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ff30 inside entry_17ff14 (0x17ff14 - 0x17ff38)
    ctx->pc = 0x17ff30;
    entry_17ff14(rdram, ctx, runtime);
}

void entry_17ff7c(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ff7c inside entry_17ff50 (0x17ff50 - 0x17ff8c)
    ctx->pc = 0x17ff7c;
    entry_17ff50(rdram, ctx, runtime);
}

void entry_17ffe0(uint8_t* rdram, R5900Context* ctx, PS2Runtime *runtime) {
    // Mid-function entry at 0x17ffe0 inside entry_17ffc4 (0x17ffc4 - 0x17ffe8)
    ctx->pc = 0x17ffe0;
    entry_17ffc4(rdram, ctx, runtime);
}

